<Type Name="Graphics" FullName="System.Drawing.Graphics">
  <Metadata><Meta Name="ms.openlocfilehash" Value="f2320c0e5dd768ab9aebaa6800aa7bdec9a90eae" /><Meta Name="ms.sourcegitcommit" Value="a22d0855bbf24d893f43605f8b7e3a44bd9551a5" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="09/05/2019" /><Meta Name="ms.locfileid" Value="70334622" /></Metadata><TypeSignature Language="C#" Value="public sealed class Graphics : MarshalByRefObject, IDisposable, System.Drawing.IDeviceContext" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Graphics extends System.MarshalByRefObject implements class System.Drawing.IDeviceContext, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Drawing.Graphics" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Graphics&#xA;Inherits MarshalByRefObject&#xA;Implements IDeviceContext, IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Graphics sealed : MarshalByRefObject, IDisposable, System::Drawing::IDeviceContext" />
  <TypeSignature Language="F#" Value="type Graphics = class&#xA;    inherit MarshalByRefObject&#xA;    interface IDisposable&#xA;    interface IDeviceContext" />
  <AssemblyInfo>
    <AssemblyName>System.Drawing</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Drawing.Common</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.1</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Drawing.IDeviceContext</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Kapselt eine GDI+-Zeichenoberfläche. Diese Klasse kann nicht vererbt werden.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Drawing.Graphics> -Klasse stellt Methoden zum Zeichnen von Objekten auf dem Anzeigegerät bereit. Ein <xref:System.Drawing.Graphics> ist einem bestimmten Gerätekontext zugeordnet.  
  
 Sie <xref:System.Drawing.Graphics> können ein <xref:System.Windows.Forms.Control?displayProperty=nameWithType> <xref:System.Windows.Forms.Control.CreateGraphics%2A?displayProperty=nameWithType> <xref:System.Windows.Forms.Control.Paint?displayProperty=nameWithType> -Objekt<xref:System.Windows.Forms.PaintEventArgs.Graphics%2A> abrufen, indem Sie die-Methode für ein Objekt aufrufen, das von erbt, oder indem Sie das-Ereignis eines-Steuer Elements behandeln und auf die-Eigenschaft der- Klassezugreifen.<xref:System.Windows.Forms.PaintEventArgs?displayProperty=nameWithType> Sie können auch ein <xref:System.Drawing.Graphics> -Objekt aus einem Image erstellen, indem Sie die <xref:System.Drawing.Graphics.FromImage%2A> -Methode verwenden. Weitere Informationen zum Erstellen eines <xref:System.Drawing.Graphics> -Objekts finden [Sie unter Gewusst wie: Erstellen Sie Grafik Objekte zum](~/docs/framework/winforms/advanced/how-to-create-graphics-objects-for-drawing.md)zeichnen.  
  
 Mithilfe eines <xref:System.Drawing.Graphics> -Objekts können Sie viele verschiedene Formen und Linien zeichnen. Weitere Informationen zum Zeichnen von Linien und Formen finden Sie in der spezifischen `Draw` *graphicalelement* -Methode für die gewünschte Zeile oder Form. Diese Methoden umfassen <xref:System.Drawing.Graphics.DrawLine%2A>, <xref:System.Drawing.Graphics.DrawArc%2A>, <xref:System.Drawing.Graphics.DrawClosedCurve%2A>, <xref:System.Drawing.Graphics.DrawPolygon%2A>und .<xref:System.Drawing.Graphics.DrawRectangle%2A> Weitere Informationen zum Zeichnen von Linien und Formen finden Sie unter [Verwenden eines Stifts zum Zeichnen von Linien und Formen](~/docs/framework/winforms/advanced/using-a-pen-to-draw-lines-and-shapes.md) und [Verwenden eines Pinsels zum Ausfüllen von Formen](~/docs/framework/winforms/advanced/using-a-brush-to-fill-shapes.md).  
  
 Sie können auch Bilder und Symbole zeichnen, indem Sie <xref:System.Drawing.Graphics.DrawImage%2A> die <xref:System.Drawing.Graphics.DrawIcon%2A> -Methode bzw. die-Methode verwenden. Informationen zum Durchführen einer Bitblock Übertragung von Farbdaten vom Bildschirm auf die Zeichen Oberfläche des <xref:System.Drawing.Graphics> Objekts finden <xref:System.Drawing.Graphics.CopyFromScreen%2A>Sie unter. Weitere Informationen zum Zeichnen von Bildern mit einem <xref:System.Drawing.Graphics> -Objekt finden Sie unter [Arbeiten mit Bildern, Bitmaps, Symbolen und Metadatendateien](~/docs/framework/winforms/advanced/working-with-images-bitmaps-icons-and-metafiles.md).  
  
 Außerdem können Sie das vom <xref:System.Drawing.Graphics> -Objekt verwendete Koordinatensystem bearbeiten. Weitere Informationen über das Koordinatensystem und deren Bearbeitung finden Sie unter [Koordinatensysteme und Transformationen](~/docs/framework/winforms/advanced/coordinate-systems-and-transformations.md).  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> ein-Objekt. Das <xref:System.Windows.Forms.PaintEventArgs> Objekt hat den `e` Namen und <xref:System.Windows.Forms.Control.Paint> ist ein Parameter des Ereignis Handlers. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein Bild aus einer JPEG-Datei. Die Datei hat den Namen "SampImag. jpg" und befindet sich im Ordner des Beispiels.  
  
-   Erstellt einen Punkt, an dem die obere linke Ecke des Bilds gezeichnet werden soll.  
  
-   Zeichnet das nicht skalierte Bild mithilfe eines <xref:System.Drawing.Graphics> -Objekts auf dem Bildschirm.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#40](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#40)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#40](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#40)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#40](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#40)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="https://msdn.microsoft.com/library/162861f9-f050-445e-8abb-b2c43a918b8b">Gewusst wie: Erstellen von Graphics-Objekten zum Zeichnen</related>
    <related type="Article" href="https://msdn.microsoft.com/library/eb0f6d6f-9e52-4167-9592-ff4b82fb5869">Erste Schritte mit der Grafikprogrammierung</related>
    <related type="Article" href="https://msdn.microsoft.com/library/6207cad1-7a34-4bd6-bfc1-db823ca7a73e">Verwalten des Zustands eines Graphics-Objekts</related>
  </Docs>
  <Members>
    <Member MemberName="AddMetafileComment">
      <MemberSignature Language="C#" Value="public void AddMetafileComment (byte[] data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddMetafileComment(unsigned int8[] data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.AddMetafileComment(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddMetafileComment (data As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddMetafileComment(cli::array &lt;System::Byte&gt; ^ data);" />
      <MemberSignature Language="F#" Value="member this.AddMetafileComment : byte[] -&gt; unit" Usage="graphics.AddMetafileComment data" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="data">Bytearray, das den Kommentar enthält.</param>
        <summary>Fügt der aktuellen <see cref="T:System.Drawing.Imaging.Metafile" /> einen Kommentar hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist nur gültig, wenn <xref:System.Drawing.Graphics> dieser einem <xref:System.Drawing.Imaging.Metafile>zugeordnet ist.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert <xref:System.Windows.Forms.PaintEventArgs>und erfordert `e`, ein Parameter des <xref:System.Windows.Forms.Control.Paint> <xref:System.Windows.Forms.Form> Ereignis Handlers sowie `thisForm`, für das Beispiel. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt eine temporäre <xref:System.Drawing.Graphics> zum Erstellen der Metadatei und `hdc`Ruft ein ab, ein Handle für den zugehörigen Gerätekontext.  
  
-   Erstellt eine neue Metadatei mit dem `hdc`.  
  
-   Erstellt einen <xref:System.Drawing.Graphics> für die Anzeige der Metadatei <xref:System.Drawing.Imaging.Metafile>aus.  
  
-   Zeichnet ein Rechteck in die Metadatei.  
  
-   Fügt der Metadatei einen Kommentar hinzu.  
  
-   Gibt den <xref:System.Drawing.Graphics> für die Metadatei aus, die die Metadatendatei schließt.  
  
-   Gibt die Metadatendatei frei.  
  
-   Gibt den temporären `hdc`frei.  
  
-   Löscht den temporären <xref:System.Drawing.Graphics>.  
  
-   Erstellt eine zweite Metadatei aus der zuvor erstellten Datei.  
  
-   Zeichnet die Metadatei auf dem Bildschirm.  
  
-   Gibt die Metadatendatei frei.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#1)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#1)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginContainer">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Speichert einen Grafikcontainer mit dem aktuellen Zustand dieses <see cref="T:System.Drawing.Graphics" /> und öffnet und verwendet einen neuen Grafikcontainer.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginContainer">
      <MemberSignature Language="C#" Value="public System.Drawing.Drawing2D.GraphicsContainer BeginContainer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Drawing.Drawing2D.GraphicsContainer BeginContainer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.BeginContainer" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginContainer () As GraphicsContainer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::Drawing2D::GraphicsContainer ^ BeginContainer();" />
      <MemberSignature Language="F#" Value="member this.BeginContainer : unit -&gt; System.Drawing.Drawing2D.GraphicsContainer" Usage="graphics.BeginContainer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Drawing2D.GraphicsContainer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Speichert einen Grafikcontainer mit dem aktuellen Zustand dieses <see cref="T:System.Drawing.Graphics" /> und öffnet und verwendet einen neuen Grafikcontainer.</summary>
        <returns>Diese Methode gibt einen <see cref="T:System.Drawing.Drawing2D.GraphicsContainer" /> zurück, der den Zustand dieses <see cref="T:System.Drawing.Graphics" /> zum Zeitpunkt des Methodenaufrufs darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode mit <xref:System.Drawing.Graphics.EndContainer%2A> der-Methode, um die Erstellung von Netz eigenen Grafik Containern durchführen Grafik Container behalten den Grafik Zustand bei, z. b. Transformation, Clippingbereich und Renderingeigenschaften.  
  
 Wenn Sie die <xref:System.Drawing.Graphics.BeginContainer%2A> -Methode <xref:System.Drawing.Graphics>eines aufzurufen, <xref:System.Drawing.Graphics> wird ein Informationsblock, der den Zustand von enthält, in einen Stapel eingefügt. Die <xref:System.Drawing.Graphics.BeginContainer%2A> -Methode gibt <xref:System.Drawing.Drawing2D.GraphicsContainer> einen zurück, der diesen Informationsblock identifiziert. Wenn Sie das identifizier <xref:System.Drawing.Graphics.EndContainer%2A> <xref:System.Drawing.Graphics> Ende Objekt an die-Methode übergeben, wird der Informationsblock aus dem Stapel entfernt und verwendet, um die in dem Zustand wiederherzustellen, in dem Sie sich zum Zeitpunkt des MethodenAufrufensbefand.<xref:System.Drawing.Graphics.BeginContainer%2A>  
  
 Container können eingebettet werden. Das heißt, Sie können die <xref:System.Drawing.Graphics.BeginContainer%2A> -Methode mehrmals aufzurufen, bevor Sie die <xref:System.Drawing.Graphics.EndContainer%2A> -Methode aufzurufen. Jedes Mal, wenn Sie <xref:System.Drawing.Graphics.BeginContainer%2A> die-Methode aufzurufen, wird ein Informationsblock in den Stapel eingefügt, <xref:System.Drawing.Drawing2D.GraphicsContainer> und Sie erhalten eine für den Informationsblock. Wenn Sie eines dieser Objekte <xref:System.Drawing.Graphics.EndContainer%2A> an die-Methode übergeben, wird die an den Zustand zurückgegeben, in dem Sie sich <xref:System.Drawing.Graphics.BeginContainer%2A> zum Zeitpunkt des Methoden Aufrufes befand <xref:System.Drawing.Drawing2D.GraphicsContainer>, der <xref:System.Drawing.Graphics> diese bestimmte zurückgegeben hat. Der Informationsblock, der durch diesen <xref:System.Drawing.Graphics.BeginContainer%2A> Methoden Anruf auf dem Stapel abgelegt wird, wird aus dem Stapel entfernt, und alle Informationsblöcke, die nach diesem <xref:System.Drawing.Graphics.BeginContainer%2A> Methoden Anruf auf diesem Stapel platziert werden, werden ebenfalls entfernt.  
  
 Aufrufe der <xref:System.Drawing.Graphics.Save%2A> -Methode platzieren Informationsblöcke auf demselben Stapel wie Aufrufe der <xref:System.Drawing.Graphics.BeginContainer%2A> -Methode. Ebenso wie ein <xref:System.Drawing.Graphics.EndContainer%2A> Methoden aufrufpaar mit einem <xref:System.Drawing.Graphics.BeginContainer%2A> Methoden aufrufpaar <xref:System.Drawing.Graphics.Restore%2A> kombiniert wird, wird ein Methoden <xref:System.Drawing.Graphics.Save%2A> aufrufspaar einem Methoden aufzurufen.  
  
 <xref:System.Drawing.Graphics.EndContainer%2A> Wenn Sie die-Methode aufzurufen, werden alle Informationsblöcke, die auf dem <xref:System.Drawing.Graphics.Save%2A> Stapel abgelegt werden ( <xref:System.Drawing.Graphics.BeginContainer%2A> durch die-Methode oder die- <xref:System.Drawing.Graphics.BeginContainer%2A> Methode), nachdem der entsprechende aufrufungsaufrufungsmethode aus dem Stapel entfernt wurde. Ebenso <xref:System.Drawing.Graphics.Restore%2A> werden beim Abrufen der-Methode alle Informationsblöcke, die auf dem Stapel abgelegt werden (durch die <xref:System.Drawing.Graphics.Save%2A> -Methode <xref:System.Drawing.Graphics.BeginContainer%2A> oder die- <xref:System.Drawing.Graphics.Save%2A> Methode), nachdem der entsprechende aufrufungsaufrufder Methode aus dem Stapel entfernt wurde.  
  
 Der von der <xref:System.Drawing.Graphics.BeginContainer%2A> -Methode festgelegte Grafik Zustand schließt die renderingqualitäten des Standard Grafik Zustands ein. alle renderqualitätsstatusänderungen, die beim Aufrufen der-Methode vorhanden sind, werden auf die Standardwerte zurückgesetzt.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Öffnet einen neuen Grafik Container und speichert den alten Container.  
  
-   Übersetzt die Weltkoordinaten im Container.  
  
-   Füllt ein rotes Rechteck im (übersetzten Koordinaten des) neuen Containers.  
  
-   Schließt den neuen Container und stellt den gespeicherten Container wieder her.  
  
-   Füllt ein grünes Rechteck (mit den nicht übersetzten Koordinaten) des gespeicherten Containers.  
  
 Das Ergebnis ist ein grünes Rechteck, das ein rotes Rechteck derselben Größe überschreitet.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#2)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#2)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginContainer">
      <MemberSignature Language="C#" Value="public System.Drawing.Drawing2D.GraphicsContainer BeginContainer (System.Drawing.Rectangle dstrect, System.Drawing.Rectangle srcrect, System.Drawing.GraphicsUnit unit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Drawing.Drawing2D.GraphicsContainer BeginContainer(valuetype System.Drawing.Rectangle dstrect, valuetype System.Drawing.Rectangle srcrect, valuetype System.Drawing.GraphicsUnit unit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.BeginContainer(System.Drawing.Rectangle,System.Drawing.Rectangle,System.Drawing.GraphicsUnit)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginContainer (dstrect As Rectangle, srcrect As Rectangle, unit As GraphicsUnit) As GraphicsContainer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::Drawing2D::GraphicsContainer ^ BeginContainer(System::Drawing::Rectangle dstrect, System::Drawing::Rectangle srcrect, System::Drawing::GraphicsUnit unit);" />
      <MemberSignature Language="F#" Value="member this.BeginContainer : System.Drawing.Rectangle * System.Drawing.Rectangle * System.Drawing.GraphicsUnit -&gt; System.Drawing.Drawing2D.GraphicsContainer" Usage="graphics.BeginContainer (dstrect, srcrect, unit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Drawing2D.GraphicsContainer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dstrect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcrect" Type="System.Drawing.Rectangle" />
        <Parameter Name="unit" Type="System.Drawing.GraphicsUnit" />
      </Parameters>
      <Docs>
        <param name="dstrect"><see cref="T:System.Drawing.Rectangle" />-Struktur, die gemeinsam mit dem <paramref name="srcrect" />-Parameter eine Skalierungstransformation für den Container angibt.</param>
        <param name="srcrect"><see cref="T:System.Drawing.Rectangle" />-Struktur, die gemeinsam mit dem <paramref name="dstrect" />-Parameter eine Skalierungstransformation für den Container angibt.</param>
        <param name="unit">Member der <see cref="T:System.Drawing.GraphicsUnit" />-Enumeration, die die Maßeinheit für den Container angibt.</param>
        <summary>Speichert einen Grafikcontainer mit dem aktuellen Zustand dieses <see cref="T:System.Drawing.Graphics" /> und öffnet und verwendet einen neuen Grafikcontainer mit der angegebenen Skalierungstransformation.</summary>
        <returns>Diese Methode gibt einen <see cref="T:System.Drawing.Drawing2D.GraphicsContainer" /> zurück, der den Zustand dieses <see cref="T:System.Drawing.Graphics" /> zum Zeitpunkt des Methodenaufrufs darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode mit <xref:System.Drawing.Graphics.EndContainer%2A> der-Methode, um die Erstellung von Netz eigenen Grafik Containern durchführen Grafik Container behalten den Grafik Zustand bei, z. b. Transformation, Clippingbereich und Renderingeigenschaften.  
  
 Wenn Sie die <xref:System.Drawing.Graphics.BeginContainer%2A> -Methode <xref:System.Drawing.Graphics>eines aufzurufen, <xref:System.Drawing.Graphics> wird ein Informationsblock, der den Zustand von enthält, in einen Stapel eingefügt. Die <xref:System.Drawing.Graphics.BeginContainer%2A> -Methode gibt <xref:System.Drawing.Drawing2D.GraphicsContainer> einen zurück, der diesen Informationsblock identifiziert. Wenn Sie das identifizier <xref:System.Drawing.Graphics.EndContainer%2A> <xref:System.Drawing.Graphics> Ende Objekt an die-Methode übergeben, wird der Informationsblock aus dem Stapel entfernt und verwendet, um die in dem Zustand wiederherzustellen, in dem Sie sich zum Zeitpunkt des MethodenAufrufensbefand.<xref:System.Drawing.Graphics.BeginContainer%2A>  
  
 Container können eingebettet werden. Das heißt, Sie können die <xref:System.Drawing.Graphics.BeginContainer%2A> -Methode mehrmals aufzurufen, bevor Sie die <xref:System.Drawing.Graphics.EndContainer%2A> -Methode aufzurufen. Jedes Mal, wenn Sie <xref:System.Drawing.Graphics.BeginContainer%2A> die-Methode aufzurufen, wird ein Informationsblock in den Stapel eingefügt, <xref:System.Drawing.Drawing2D.GraphicsContainer> und Sie erhalten eine für den Informationsblock. Wenn Sie eines dieser Objekte <xref:System.Drawing.Graphics.EndContainer%2A> an die-Methode übergeben, wird die an den Zustand zurückgegeben, in dem Sie sich <xref:System.Drawing.Graphics.BeginContainer%2A> zum Zeitpunkt des Methoden Aufrufes befand <xref:System.Drawing.Drawing2D.GraphicsContainer>, der <xref:System.Drawing.Graphics> diese bestimmte zurückgegeben hat. Der Informationsblock, der durch diesen <xref:System.Drawing.Graphics.BeginContainer%2A> Methoden Anruf auf dem Stapel abgelegt wird, wird aus dem Stapel entfernt, und alle Informationsblöcke, die nach diesem <xref:System.Drawing.Graphics.BeginContainer%2A> Methoden Anruf auf diesem Stapel platziert werden, werden ebenfalls entfernt.  
  
 Aufrufe der <xref:System.Drawing.Graphics.Save%2A> -Methode platzieren Informationsblöcke auf demselben Stapel wie Aufrufe der <xref:System.Drawing.Graphics.BeginContainer%2A> -Methode. Ebenso wie ein <xref:System.Drawing.Graphics.EndContainer%2A> Methoden aufrufpaar mit einem <xref:System.Drawing.Graphics.BeginContainer%2A> Methoden aufrufpaar <xref:System.Drawing.Graphics.Restore%2A> kombiniert wird, wird ein Methoden <xref:System.Drawing.Graphics.Save%2A> aufrufspaar einem Methoden aufzurufen.  
  
 <xref:System.Drawing.Graphics.EndContainer%2A> Wenn Sie die-Methode aufzurufen, werden alle Informationsblöcke, die auf dem <xref:System.Drawing.Graphics.Save%2A> Stapel abgelegt werden ( <xref:System.Drawing.Graphics.BeginContainer%2A> durch die-Methode oder die- <xref:System.Drawing.Graphics.BeginContainer%2A> Methode), nachdem der entsprechende aufrufungsaufrufungsmethode aus dem Stapel entfernt wurde. Ebenso <xref:System.Drawing.Graphics.Restore%2A> werden beim Abrufen der-Methode alle Informationsblöcke, die auf dem Stapel abgelegt werden (durch die <xref:System.Drawing.Graphics.Save%2A> -Methode <xref:System.Drawing.Graphics.BeginContainer%2A> oder die- <xref:System.Drawing.Graphics.Save%2A> Methode), nachdem der entsprechende aufrufungsaufrufder Methode aus dem Stapel entfernt wurde.  
  
 Diese Methode gibt eine Skalierungs Transformation für den neuen Grafik Container mit `dstrect` dem `srcrect` -Parameter und dem-Parameter an. Die Skala ist gleich der Transformation, die auf `srcrect` `dstrect`angewendet wird.  
  
 Der von der <xref:System.Drawing.Graphics.BeginContainer%2A> -Methode festgelegte Grafik Zustand schließt die renderingqualitäten des Standard Grafik Zustands ein. alle renderqualitätsstatusänderungen, die beim Aufrufen der-Methode vorhanden sind, werden auf die Standardwerte zurückgesetzt.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt zwei Rechtecke, um eine Skalierungs Transformation für den neuen Container anzugeben.  
  
-   Öffnet den neuen Grafik Container und speichert den alten Container.  
  
-   Füllt ein rotes Rechteck in den (skalierten Koordinaten des) neuen Containers.  
  
-   Schließt den neuen Container und stellt den gespeicherten Container wieder her.  
  
-   Füllt ein grünes Rechteck (auf die nicht skalierten Koordinaten) des gespeicherten Containers.  
  
 Das Ergebnis ist ein grünes Rechteck, das ein kleineres rotes Rechteck überschreitet.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#3](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#3)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#3)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginContainer">
      <MemberSignature Language="C#" Value="public System.Drawing.Drawing2D.GraphicsContainer BeginContainer (System.Drawing.RectangleF dstrect, System.Drawing.RectangleF srcrect, System.Drawing.GraphicsUnit unit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Drawing.Drawing2D.GraphicsContainer BeginContainer(valuetype System.Drawing.RectangleF dstrect, valuetype System.Drawing.RectangleF srcrect, valuetype System.Drawing.GraphicsUnit unit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.BeginContainer(System.Drawing.RectangleF,System.Drawing.RectangleF,System.Drawing.GraphicsUnit)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginContainer (dstrect As RectangleF, srcrect As RectangleF, unit As GraphicsUnit) As GraphicsContainer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::Drawing2D::GraphicsContainer ^ BeginContainer(System::Drawing::RectangleF dstrect, System::Drawing::RectangleF srcrect, System::Drawing::GraphicsUnit unit);" />
      <MemberSignature Language="F#" Value="member this.BeginContainer : System.Drawing.RectangleF * System.Drawing.RectangleF * System.Drawing.GraphicsUnit -&gt; System.Drawing.Drawing2D.GraphicsContainer" Usage="graphics.BeginContainer (dstrect, srcrect, unit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Drawing2D.GraphicsContainer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dstrect" Type="System.Drawing.RectangleF" />
        <Parameter Name="srcrect" Type="System.Drawing.RectangleF" />
        <Parameter Name="unit" Type="System.Drawing.GraphicsUnit" />
      </Parameters>
      <Docs>
        <param name="dstrect"><see cref="T:System.Drawing.RectangleF" />-Struktur, die gemeinsam mit dem <paramref name="srcrect" />-Parameter eine Skalierungstransformation für den neuen Grafikcontainer angibt.</param>
        <param name="srcrect"><see cref="T:System.Drawing.RectangleF" />-Struktur, die gemeinsam mit dem <paramref name="dstrect" />-Parameter eine Skalierungstransformation für den neuen Grafikcontainer angibt.</param>
        <param name="unit">Member der <see cref="T:System.Drawing.GraphicsUnit" />-Enumeration, die die Maßeinheit für den Container angibt.</param>
        <summary>Speichert einen Grafikcontainer mit dem aktuellen Zustand dieses <see cref="T:System.Drawing.Graphics" /> und öffnet und verwendet einen neuen Grafikcontainer mit der angegebenen Skalierungstransformation.</summary>
        <returns>Diese Methode gibt einen <see cref="T:System.Drawing.Drawing2D.GraphicsContainer" /> zurück, der den Zustand dieses <see cref="T:System.Drawing.Graphics" /> zum Zeitpunkt des Methodenaufrufs darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode mit <xref:System.Drawing.Graphics.EndContainer%2A> der-Methode, um die Erstellung von Netz eigenen Grafik Containern durchführen Grafik Container behalten den Grafik Zustand bei, z. b. Transformation, Clippingbereich und Renderingeigenschaften.  
  
 Wenn Sie die <xref:System.Drawing.Graphics.BeginContainer%2A> -Methode <xref:System.Drawing.Graphics>eines aufzurufen, <xref:System.Drawing.Graphics> wird ein Informationsblock, der den Zustand von enthält, in einen Stapel eingefügt. Die <xref:System.Drawing.Graphics.BeginContainer%2A> -Methode gibt <xref:System.Drawing.Drawing2D.GraphicsContainer> einen zurück, der diesen Informationsblock identifiziert. Wenn Sie das identifizier <xref:System.Drawing.Graphics.EndContainer%2A> <xref:System.Drawing.Graphics> Ende Objekt an die-Methode übergeben, wird der Informationsblock aus dem Stapel entfernt und verwendet, um die in dem Zustand wiederherzustellen, in dem Sie sich zum Zeitpunkt des MethodenAufrufensbefand.<xref:System.Drawing.Graphics.BeginContainer%2A>  
  
 Container können eingebettet werden. Das heißt, Sie können die <xref:System.Drawing.Graphics.BeginContainer%2A> -Methode mehrmals aufzurufen, bevor Sie die <xref:System.Drawing.Graphics.EndContainer%2A> -Methode aufzurufen. Jedes Mal, wenn Sie <xref:System.Drawing.Graphics.BeginContainer%2A> die-Methode aufzurufen, wird ein Informationsblock in den Stapel eingefügt, <xref:System.Drawing.Drawing2D.GraphicsContainer> und Sie erhalten eine für den Informationsblock. Wenn Sie eines dieser Objekte <xref:System.Drawing.Graphics.EndContainer%2A> an die-Methode übergeben, wird die an den Zustand zurückgegeben, in dem Sie sich <xref:System.Drawing.Graphics.BeginContainer%2A> zum Zeitpunkt des Methoden Aufrufes befand <xref:System.Drawing.Drawing2D.GraphicsContainer>, der <xref:System.Drawing.Graphics> diese bestimmte zurückgegeben hat. Der Informationsblock, der durch diesen <xref:System.Drawing.Graphics.BeginContainer%2A> Methoden Anruf auf dem Stapel abgelegt wird, wird aus dem Stapel entfernt, und alle Informationsblöcke, die nach diesem <xref:System.Drawing.Graphics.BeginContainer%2A> Methoden Anruf auf diesem Stapel platziert werden, werden ebenfalls entfernt.  
  
 Aufrufe der <xref:System.Drawing.Graphics.Save%2A> -Methode platzieren Informationsblöcke auf demselben Stapel wie Aufrufe der <xref:System.Drawing.Graphics.BeginContainer%2A> -Methode. Ebenso wie ein <xref:System.Drawing.Graphics.EndContainer%2A> Methoden aufrufpaar mit einem <xref:System.Drawing.Graphics.BeginContainer%2A> Methoden aufrufpaar <xref:System.Drawing.Graphics.Restore%2A> kombiniert wird, wird ein Methoden <xref:System.Drawing.Graphics.Save%2A> aufrufspaar einem Methoden aufzurufen.  
  
 <xref:System.Drawing.Graphics.EndContainer%2A> Wenn Sie die-Methode aufzurufen, werden alle Informationsblöcke, die auf dem `Save` Stapel abgelegt werden ( <xref:System.Drawing.Graphics.BeginContainer%2A> durch die-Methode oder die- <xref:System.Drawing.Graphics.BeginContainer%2A> Methode), nachdem der entsprechende aufrufungsaufrufungsmethode aus dem Stapel entfernt wurde. Ebenso <xref:System.Drawing.Graphics.Restore%2A> werden beim Abrufen der-Methode alle Informationsblöcke, die auf dem Stapel abgelegt werden (durch die <xref:System.Drawing.Graphics.Save%2A> -Methode <xref:System.Drawing.Graphics.BeginContainer%2A> oder die- <xref:System.Drawing.Graphics.Save%2A> Methode), nachdem der entsprechende aufrufungsaufrufder Methode aus dem Stapel entfernt wurde.  
  
 Diese Methode gibt eine Skalierungs Transformation für den neuen Grafik Container mit `dstrect` dem `srcrect` -Parameter und dem-Parameter an. Die Skala ist gleich der Transformation, die auf `srcrect` `dstrect`angewendet wird.  
  
 Der von der <xref:System.Drawing.Graphics.BeginContainer%2A> -Methode festgelegte Grafik Zustand schließt die renderingqualitäten des Standard Grafik Zustands ein. alle renderqualitätsstatusänderungen, die beim Aufrufen der-Methode vorhanden sind, werden auf die Standardwerte zurückgesetzt.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt zwei Rechtecke, um eine Skalierungs Transformation für den neuen Container anzugeben.  
  
-   Öffnet den neuen Grafik Container und speichert den alten Container.  
  
-   Füllt ein rotes Rechteck in den (skalierten Koordinaten des) neuen Containers.  
  
-   Schließt den neuen Container und stellt den gespeicherten Container wieder her.  
  
-   Füllt ein grünes Rechteck (auf die nicht skalierten Koordinaten) des gespeicherten Containers.  
  
 Das Ergebnis ist ein grünes Rechteck, das ein kleineres rotes Rechteck überschreitet.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#4](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#4)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#4)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear (System.Drawing.Color color);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear(valuetype System.Drawing.Color color) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.Clear(System.Drawing.Color)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear(System::Drawing::Color color);" />
      <MemberSignature Language="F#" Value="member this.Clear : System.Drawing.Color -&gt; unit" Usage="graphics.Clear color" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="color" Type="System.Drawing.Color" />
      </Parameters>
      <Docs>
        <param name="color"><see cref="T:System.Drawing.Color" />-Struktur, die die Hintergrundfarbe der Zeichenoberfläche darstellt.</param>
        <summary>Löscht die gesamte Zeichenoberfläche und füllt sie mit der angegebenen Hintergrundfarbe aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Drawing.Graphics.Clear%2A> -Methode löscht den Zustand des Grafik Objekts und sollte nicht aufgerufen werden, wenn das Grafik Objekt nicht aktualisiert werden kann. Wenn die <xref:System.Drawing.Graphics.Clear%2A> -Methode z. b. auf einem sicheren Desktop in einer Terminal Server Sitzung aufgerufen wird <xref:System.Runtime.InteropServices.ExternalException> , kann eine auftreten, <xref:System.Drawing.Graphics> die das-Objekt in einem inkonsistenten Zustand belassen wird.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code löscht die Zeichnungs Oberfläche <xref:System.Drawing.Graphics> der und legt die Hintergrundfarbe auf die System definierte blaugrün-Farbe fest.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#5](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#5)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#5](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#5)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clip">
      <MemberSignature Language="C#" Value="public System.Drawing.Region Clip { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Region Clip" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Graphics.Clip" />
      <MemberSignature Language="VB.NET" Value="Public Property Clip As Region" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Region ^ Clip { System::Drawing::Region ^ get(); void set(System::Drawing::Region ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Clip : System.Drawing.Region with get, set" Usage="System.Drawing.Graphics.Clip" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Region</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen <see cref="T:System.Drawing.Region" /> ab, der den Zeichnungsbereich dieses <see cref="T:System.Drawing.Graphics" /> einschränkt, oder legt diesen fest.</summary>
        <value>Ein <see cref="T:System.Drawing.Region" />, der den Teil dieses <see cref="T:System.Drawing.Graphics" /> einschränkt, der gerade für das Zeichnen verfügbar ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie <xref:System.Drawing.Region> das von der <xref:System.Drawing.Graphics.Clip%2A> -Eigenschaft zurückgegebene-Objekt ändern, wirkt <xref:System.Drawing.Graphics> sich dies nicht auf nachfolgende Zeichnungen mit dem Um den Clip Bereich zu ändern, ersetzen <xref:System.Drawing.Graphics.Clip%2A> Sie den-Eigenschafts <xref:System.Drawing.Region> Wert durch ein neues-Objekt. Rufen Sie die <xref:System.Drawing.Graphics.Clip%2A> -Eigenschaft ab, und rufen Sie Ihre <xref:System.Drawing.Region.IsInfinite%2A> -Methode auf, um zu bestimmen, ob der Ausschneide Bereich unendlich  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung des <xref:System.Drawing.Graphics.Clip%2A>-Attributs veranschaulicht. Dieses Beispiel ist für die Verwendung mit Windows Forms konzipiert. Fügen Sie den Code in ein Formular ein, `SetAndFillClip` und nennen Sie die-Methode <xref:System.Windows.Forms.Control.Paint> , wenn Sie das <xref:System.Windows.Forms.PaintEventArgs>-Ereignis des Formulars verarbeiten und als übergeben `e` .  
  
 [!code-cpp[System.Drawing.GraphicsProperties#4](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.GraphicsProperties/CPP/form1.cpp#4)]
 [!code-csharp[System.Drawing.GraphicsProperties#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.GraphicsProperties/CS/form1.cs#4)]
 [!code-vb[System.Drawing.GraphicsProperties#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.GraphicsProperties/VB/form1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClipBounds">
      <MemberSignature Language="C#" Value="public System.Drawing.RectangleF ClipBounds { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.RectangleF ClipBounds" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Graphics.ClipBounds" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ClipBounds As RectangleF" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::RectangleF ClipBounds { System::Drawing::RectangleF get(); };" />
      <MemberSignature Language="F#" Value="member this.ClipBounds : System.Drawing.RectangleF" Usage="System.Drawing.Graphics.ClipBounds" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.RectangleF</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine <see cref="T:System.Drawing.RectangleF" />-Struktur ab, die den Ausschneidebereich dieses <see cref="T:System.Drawing.Graphics" /> begrenzt.</summary>
        <value>Eine <see cref="T:System.Drawing.RectangleF" />-Struktur, die ein umschließendes Rechteck für den Ausschneidebereich dieses <see cref="T:System.Drawing.Graphics" /> darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Einheit für das resultierende Rechteck wird von der <xref:System.Drawing.Graphics.PageUnit%2A> -Eigenschaft bestimmt. Die Standardeinheit ist Pixel. Ein <xref:System.Drawing.Graphics> ist in der Regel mit einem-Steuerelement verknüpft, und der Ursprung des Rechtecks ist relativ zum Client Bereich des Steuer Elements.  
  
 Wenn der Clippingbereich unendlich ist, <xref:System.Drawing.Graphics.ClipBounds%2A> gibt die-Eigenschaft ein bedeutungsloses großes Rechteck zurück. Rufen Sie die <xref:System.Drawing.Graphics.Clip%2A> -Eigenschaft ab, und rufen Sie Ihre <xref:System.Drawing.Region.IsInfinite%2A> -Methode auf, um zu bestimmen, ob der Ausschneide Bereich unendlich  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompositingMode">
      <MemberSignature Language="C#" Value="public System.Drawing.Drawing2D.CompositingMode CompositingMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Drawing2D.CompositingMode CompositingMode" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Graphics.CompositingMode" />
      <MemberSignature Language="VB.NET" Value="Public Property CompositingMode As CompositingMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Drawing2D::CompositingMode CompositingMode { System::Drawing::Drawing2D::CompositingMode get(); void set(System::Drawing::Drawing2D::CompositingMode value); };" />
      <MemberSignature Language="F#" Value="member this.CompositingMode : System.Drawing.Drawing2D.CompositingMode with get, set" Usage="System.Drawing.Graphics.CompositingMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Drawing2D.CompositingMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, wie zusammengesetzte Bilder zu diesem <see cref="T:System.Drawing.Graphics" /> gezeichnet werden.</summary>
        <value>Diese Eigenschaft gibt einen Member der <see cref="T:System.Drawing.Drawing2D.CompositingMode" />-Enumeration an. Die Standardeinstellung ist <see cref="F:System.Drawing.Drawing2D.CompositingMode.SourceOver" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Zusammensetzung-Modus bestimmt, ob Pixel aus einem Quell Image überschrieben werden oder mit Hintergrund Pixeln kombiniert werden.  
  
> [!NOTE]
>  Sie sollten den <xref:System.Drawing.Graphics.CompositingMode%2A> -Eigenschafts <xref:System.Drawing.Drawing2D.CompositingMode.SourceCopy> Wert nicht verwenden, <xref:System.Drawing.Graphics.TextRenderingHint%2A> wenn die-Eigenschaft <xref:System.Drawing.Text.TextRenderingHint.ClearTypeGridFit>auf festgelegt ist. Eine Ausnahme kann auftreten, oder das Bild wird möglicherweise nicht ordnungsgemäß wiedergegeben.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompositingQuality">
      <MemberSignature Language="C#" Value="public System.Drawing.Drawing2D.CompositingQuality CompositingQuality { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Drawing2D.CompositingQuality CompositingQuality" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Graphics.CompositingQuality" />
      <MemberSignature Language="VB.NET" Value="Public Property CompositingQuality As CompositingQuality" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Drawing2D::CompositingQuality CompositingQuality { System::Drawing::Drawing2D::CompositingQuality get(); void set(System::Drawing::Drawing2D::CompositingQuality value); };" />
      <MemberSignature Language="F#" Value="member this.CompositingQuality : System.Drawing.Drawing2D.CompositingQuality with get, set" Usage="System.Drawing.Graphics.CompositingQuality" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Drawing2D.CompositingQuality</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Renderqualität von zusammengesetzten Bildern ab, die zu diesem <see cref="T:System.Drawing.Graphics" /> gezeichnet wurden, oder legt diese fest.</summary>
        <value>Diese Eigenschaft gibt einen Member der <see cref="T:System.Drawing.Drawing2D.CompositingQuality" />-Enumeration an. Die Standardeinstellung ist <see cref="F:System.Drawing.Drawing2D.CompositingQuality.Default" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Zusammensetzung-Qualität bestimmt die renderingqualitätsstufe von zusammengesetzten Bildern.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyFromScreen">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Führt einen Bitblocktransfer der Farbdaten vom Bildschirm auf die Zeichenoberfläche des <see cref="T:System.Drawing.Graphics" /> aus.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyFromScreen">
      <MemberSignature Language="C#" Value="public void CopyFromScreen (System.Drawing.Point upperLeftSource, System.Drawing.Point upperLeftDestination, System.Drawing.Size blockRegionSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyFromScreen(valuetype System.Drawing.Point upperLeftSource, valuetype System.Drawing.Point upperLeftDestination, valuetype System.Drawing.Size blockRegionSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.CopyFromScreen(System.Drawing.Point,System.Drawing.Point,System.Drawing.Size)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyFromScreen (upperLeftSource As Point, upperLeftDestination As Point, blockRegionSize As Size)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyFromScreen(System::Drawing::Point upperLeftSource, System::Drawing::Point upperLeftDestination, System::Drawing::Size blockRegionSize);" />
      <MemberSignature Language="F#" Value="member this.CopyFromScreen : System.Drawing.Point * System.Drawing.Point * System.Drawing.Size -&gt; unit" Usage="graphics.CopyFromScreen (upperLeftSource, upperLeftDestination, blockRegionSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="upperLeftSource" Type="System.Drawing.Point" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="upperLeftDestination" Type="System.Drawing.Point" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="blockRegionSize" Type="System.Drawing.Size" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="upperLeftSource">Der Punkt in der linken oberen Ecke des Quellrechtecks.</param>
        <param name="upperLeftDestination">Der Punkt in der linken oberen Ecke des Zielrechtecks.</param>
        <param name="blockRegionSize">Die Größe des Bereichs, der übertragen werden soll.</param>
        <summary>Führt entsprechend einem Rechteck aus Pixeln einen Bitblocktransfer der Farbdaten vom Bildschirm auf die Zeichenoberfläche des <see cref="T:System.Drawing.Graphics" /> aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Drawing.Graphics.CopyFromScreen%2A> -Methoden sind nützlich, um ein Bild auf einer anderen Ebene zu Schichten. Um anzugeben, wie die Quell-und Ziel Farben gemischt werden, verwenden Sie <xref:System.Drawing.Graphics.CopyFromScreen%2A> eine der-Methoden <xref:System.Drawing.CopyPixelOperation> , die einen-Parameter annimmt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung der <xref:System.Drawing.Graphics.CopyFromScreen%2A>-Methode veranschaulicht. Fügen Sie es in ein Windows Form ein, um dieses Beispiel auszuführen. Behandeln Sie das- <xref:System.Windows.Forms.Control.Paint> Ereignis des Formulars, `CopyPixels1` und wenden Sie <xref:System.Windows.Forms.Control.Paint> die-Methode aus der Ereignis `e` Behandlungs <xref:System.Windows.Forms.PaintEventArgs>Methode an, indem Sie als übergeben.  
  
 [!code-csharp[System.Drawing.MiscWhidbeySnippets#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.MiscWhidbeySnippets/CS/Form1.cs#4)]
 [!code-vb[System.Drawing.MiscWhidbeySnippets#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.MiscWhidbeySnippets/VB/Form1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Fehler bei diesem Vorgang.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">für den Zugriff auf alle Fenster. Verwandte Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" />.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/c8dff5f8-f56a-4c07-ae31-64643b31f8fc">Gewusst wie: Drucken eines Windows Form</related>
        <related type="Article" href="https://msdn.microsoft.com/library/33b76910-13a3-4521-be98-5c097341ae3b">Vorgehensweise: Kopieren Sie Pixel, um Flimmern in Windows Forms zu verringern.</related>
      </Docs>
    </Member>
    <Member MemberName="CopyFromScreen">
      <MemberSignature Language="C#" Value="public void CopyFromScreen (System.Drawing.Point upperLeftSource, System.Drawing.Point upperLeftDestination, System.Drawing.Size blockRegionSize, System.Drawing.CopyPixelOperation copyPixelOperation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyFromScreen(valuetype System.Drawing.Point upperLeftSource, valuetype System.Drawing.Point upperLeftDestination, valuetype System.Drawing.Size blockRegionSize, valuetype System.Drawing.CopyPixelOperation copyPixelOperation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.CopyFromScreen(System.Drawing.Point,System.Drawing.Point,System.Drawing.Size,System.Drawing.CopyPixelOperation)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyFromScreen(System::Drawing::Point upperLeftSource, System::Drawing::Point upperLeftDestination, System::Drawing::Size blockRegionSize, System::Drawing::CopyPixelOperation copyPixelOperation);" />
      <MemberSignature Language="F#" Value="member this.CopyFromScreen : System.Drawing.Point * System.Drawing.Point * System.Drawing.Size * System.Drawing.CopyPixelOperation -&gt; unit" Usage="graphics.CopyFromScreen (upperLeftSource, upperLeftDestination, blockRegionSize, copyPixelOperation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="upperLeftSource" Type="System.Drawing.Point" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="upperLeftDestination" Type="System.Drawing.Point" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="blockRegionSize" Type="System.Drawing.Size" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="copyPixelOperation" Type="System.Drawing.CopyPixelOperation" Index="3" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="upperLeftSource">Der Punkt in der linken oberen Ecke des Quellrechtecks.</param>
        <param name="upperLeftDestination">Der Punkt in der linken oberen Ecke des Zielrechtecks.</param>
        <param name="blockRegionSize">Die Größe des Bereichs, der übertragen werden soll.</param>
        <param name="copyPixelOperation">Einer der <see cref="T:System.Drawing.CopyPixelOperation" />-Werte.</param>
        <summary>Führt entsprechend einem Rechteck aus Pixeln einen Bitblocktransfer der Farbdaten vom Bildschirm auf die Zeichenoberfläche des <see cref="T:System.Drawing.Graphics" /> aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Drawing.Graphics.CopyFromScreen%2A> -Methoden sind nützlich, um ein Bild auf einer anderen Ebene zu Schichten. Mit `copyPixelOperation` dem-Parameter können Sie angeben, ob und wie die Quell Farben mit den Farben im Zielbereich gemischt werden sollen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung der <xref:System.Drawing.Graphics.CopyFromScreen%2A>-Methode veranschaulicht. Fügen Sie es in ein Windows Form ein, um dieses Beispiel auszuführen. Behandeln Sie das- <xref:System.Windows.Forms.Control.Paint> Ereignis des Formulars, `CopyPixels2` und wenden Sie <xref:System.Windows.Forms.Control.Paint> die-Methode aus der Ereignis `e` Behandlungs <xref:System.Windows.Forms.PaintEventArgs>Methode an, indem Sie als übergeben.  
  
 [!code-csharp[System.Drawing.MiscWhidbeySnippets#5](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.MiscWhidbeySnippets/CS/Form1.cs#5)]
 [!code-vb[System.Drawing.MiscWhidbeySnippets#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.MiscWhidbeySnippets/VB/Form1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="copyPixelOperation" /> ist kein Member von <see cref="T:System.Drawing.CopyPixelOperation" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Fehler bei diesem Vorgang.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">für den Zugriff auf alle Fenster. Verwandte Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" />.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/c8dff5f8-f56a-4c07-ae31-64643b31f8fc">Gewusst wie: Drucken eines Windows Form</related>
        <related type="Article" href="https://msdn.microsoft.com/library/33b76910-13a3-4521-be98-5c097341ae3b">Vorgehensweise: Kopieren Sie Pixel, um Flimmern in Windows Forms zu verringern.</related>
      </Docs>
    </Member>
    <Member MemberName="CopyFromScreen">
      <MemberSignature Language="C#" Value="public void CopyFromScreen (int sourceX, int sourceY, int destinationX, int destinationY, System.Drawing.Size blockRegionSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyFromScreen(int32 sourceX, int32 sourceY, int32 destinationX, int32 destinationY, valuetype System.Drawing.Size blockRegionSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.CopyFromScreen(System.Int32,System.Int32,System.Int32,System.Int32,System.Drawing.Size)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyFromScreen (sourceX As Integer, sourceY As Integer, destinationX As Integer, destinationY As Integer, blockRegionSize As Size)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyFromScreen(int sourceX, int sourceY, int destinationX, int destinationY, System::Drawing::Size blockRegionSize);" />
      <MemberSignature Language="F#" Value="member this.CopyFromScreen : int * int * int * int * System.Drawing.Size -&gt; unit" Usage="graphics.CopyFromScreen (sourceX, sourceY, destinationX, destinationY, blockRegionSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceX" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="sourceY" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="destinationX" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="destinationY" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="blockRegionSize" Type="System.Drawing.Size" Index="4" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="sourceX">Die x-Koordinate des Punktes in der linken oberen Ecke des Quellrechtecks.</param>
        <param name="sourceY">Die y-Koordinate des Punktes in der linken oberen Ecke des Quellrechtecks.</param>
        <param name="destinationX">Die x-Koordinate des Punktes in der linken oberen Ecke des Zielrechtecks.</param>
        <param name="destinationY">Die y-Koordinate des Punktes in der linken oberen Ecke des Zielrechtecks.</param>
        <param name="blockRegionSize">Die Größe des Bereichs, der übertragen werden soll.</param>
        <summary>Führt entsprechend einem Rechteck aus Pixeln einen Bitblocktransfer der Farbdaten vom Bildschirm auf die Zeichenoberfläche des <see cref="T:System.Drawing.Graphics" /> aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Drawing.Graphics.CopyFromScreen%2A> -Methoden sind nützlich, um ein Bild auf einer anderen Ebene zu Schichten. Um anzugeben, wie die Quell-und Ziel Farben gemischt werden, verwenden Sie <xref:System.Drawing.Graphics.CopyFromScreen%2A> eine der-Methoden <xref:System.Drawing.CopyPixelOperation> , die einen-Parameter annimmt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie das <xref:System.Drawing.Graphics.CopyFromScreen%2A> zum Drucken einer Kopie des aktuellen Formulars verwendet wird.  
  
 [!code-csharp[System.Drawing.Graphics.CopyFromScreen#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Graphics.CopyFromScreen/CS/Form1.cs#1)]
 [!code-vb[System.Drawing.Graphics.CopyFromScreen#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Graphics.CopyFromScreen/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Fehler bei diesem Vorgang.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">für den Zugriff auf alle Fenster. Verwandte Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" />.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/c8dff5f8-f56a-4c07-ae31-64643b31f8fc">Gewusst wie: Drucken eines Windows Form</related>
        <related type="Article" href="https://msdn.microsoft.com/library/33b76910-13a3-4521-be98-5c097341ae3b">Vorgehensweise: Kopieren Sie Pixel, um Flimmern in Windows Forms zu verringern.</related>
      </Docs>
    </Member>
    <Member MemberName="CopyFromScreen">
      <MemberSignature Language="C#" Value="public void CopyFromScreen (int sourceX, int sourceY, int destinationX, int destinationY, System.Drawing.Size blockRegionSize, System.Drawing.CopyPixelOperation copyPixelOperation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyFromScreen(int32 sourceX, int32 sourceY, int32 destinationX, int32 destinationY, valuetype System.Drawing.Size blockRegionSize, valuetype System.Drawing.CopyPixelOperation copyPixelOperation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.CopyFromScreen(System.Int32,System.Int32,System.Int32,System.Int32,System.Drawing.Size,System.Drawing.CopyPixelOperation)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyFromScreen(int sourceX, int sourceY, int destinationX, int destinationY, System::Drawing::Size blockRegionSize, System::Drawing::CopyPixelOperation copyPixelOperation);" />
      <MemberSignature Language="F#" Value="member this.CopyFromScreen : int * int * int * int * System.Drawing.Size * System.Drawing.CopyPixelOperation -&gt; unit" Usage="graphics.CopyFromScreen (sourceX, sourceY, destinationX, destinationY, blockRegionSize, copyPixelOperation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceX" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="sourceY" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="destinationX" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="destinationY" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="blockRegionSize" Type="System.Drawing.Size" Index="4" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="copyPixelOperation" Type="System.Drawing.CopyPixelOperation" Index="5" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="sourceX">Die x-Koordinate des Punktes in der linken oberen Ecke des Quellrechtecks.</param>
        <param name="sourceY">Die y-Koordinate des Punktes in der linken oberen Ecke des Quellrechtecks.</param>
        <param name="destinationX">Die x-Koordinate des Punktes in der linken oberen Ecke des Zielrechtecks.</param>
        <param name="destinationY">Die y-Koordinate des Punktes in der linken oberen Ecke des Zielrechtecks.</param>
        <param name="blockRegionSize">Die Größe des Bereichs, der übertragen werden soll.</param>
        <param name="copyPixelOperation">Einer der <see cref="T:System.Drawing.CopyPixelOperation" />-Werte.</param>
        <summary>Führt entsprechend einem Rechteck aus Pixeln einen Bitblocktransfer der Farbdaten vom Bildschirm auf die Zeichenoberfläche des <see cref="T:System.Drawing.Graphics" /> aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Drawing.Graphics.CopyFromScreen%2A> -Methoden sind nützlich, um ein Bild auf einer anderen Ebene zu Schichten. Mit `copyPixelOperation` dem-Parameter können Sie angeben, ob und wie die Quell Farben mit den Farben im Zielbereich gemischt werden sollen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung der <xref:System.Drawing.Graphics.CopyFromScreen%2A>-Methode veranschaulicht. Fügen Sie es in ein Windows Form ein, um dieses Beispiel auszuführen. Behandeln Sie das- <xref:System.Windows.Forms.Control.Paint> Ereignis des Formulars, `CopyPixels4` und wenden Sie <xref:System.Windows.Forms.Control.Paint> die-Methode aus der Ereignis `e` Behandlungs <xref:System.Windows.Forms.PaintEventArgs>Methode an, indem Sie als übergeben.  
  
 [!code-csharp[System.Drawing.MiscWhidbeySnippets#7](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.MiscWhidbeySnippets/CS/Form1.cs#7)]
 [!code-vb[System.Drawing.MiscWhidbeySnippets#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.MiscWhidbeySnippets/VB/Form1.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="copyPixelOperation" /> ist kein Member von <see cref="T:System.Drawing.CopyPixelOperation" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Fehler bei diesem Vorgang.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">für den Zugriff auf alle Fenster. Verwandte Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" />.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/c8dff5f8-f56a-4c07-ae31-64643b31f8fc">Gewusst wie: Drucken eines Windows Form</related>
        <related type="Article" href="https://msdn.microsoft.com/library/33b76910-13a3-4521-be98-5c097341ae3b">Vorgehensweise: Kopieren Sie Pixel, um Flimmern in Windows Forms zu verringern.</related>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="graphics.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt alle von dieser <see cref="T:System.Drawing.Graphics" /> verwendeten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch <xref:System.Drawing.Graphics.Dispose%2A> Aufrufen von können die von diesem <xref:System.Drawing.Graphics> verwendeten Ressourcen für andere Zwecke neu zugeordnet werden.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein <xref:System.Drawing.Image> aus einer Grafikdatei "SampImag. jpg" im Beispiel Verzeichnis.  
  
-   Erstellt eine <xref:System.Drawing.Graphics> aus dem <xref:System.Drawing.Image>.  
  
-   Ändert das Bild, indem es ein Rechteck darin füllt.  
  
-   Zeichnet das <xref:System.Drawing.Image> auf dem Bildschirm.  
  
-   Gibt die erstellte <xref:System.Drawing.Graphics>frei.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#6](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#6)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#6)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DpiX">
      <MemberSignature Language="C#" Value="public float DpiX { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float32 DpiX" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Graphics.DpiX" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DpiX As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property float DpiX { float get(); };" />
      <MemberSignature Language="F#" Value="member this.DpiX : single" Usage="System.Drawing.Graphics.DpiX" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die horizontale Auflösung dieses <see cref="T:System.Drawing.Graphics" /> ab.</summary>
        <value>Der Wert in dpi (Punkte pro Zoll) für die horizontale Auflösung, die durch dieses <see cref="T:System.Drawing.Graphics" /> unterstützt wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zum Erstellen von Anwendungen mit hoher Auflösung finden Sie unter.  
  
 [Hohes dpi](https://go.microsoft.com/fwlink/?LinkId=159804).  
  
   
  
## Examples  
 Die folgende Methode zeigt die Verwendung <xref:System.Drawing.Graphics.DpiX%2A> der-Eigenschaft und der- <xref:System.Drawing.Graphics.DpiY%2A> Eigenschaft. Dieses Beispiel ist für die Verwendung mit einem Windows Form konzipiert. Um dieses Beispiel auszuführen, fügen Sie es in ein Formular ein, <xref:System.Windows.Forms.ListBox> das ein benanntes ListBox1 enthält, und nennen Sie diese Methode aus dem Konstruktor des Formulars.  
  
 [!code-cpp[System.Drawing.MiscExamples#4](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.MiscExamples/CPP/form1.cpp#4)]
 [!code-csharp[System.Drawing.MiscExamples#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.MiscExamples/CS/form1.cs#4)]
 [!code-vb[System.Drawing.MiscExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.MiscExamples/VB/form1.vb#4)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=159804">Hoher dpi-</related>
      </Docs>
    </Member>
    <Member MemberName="DpiY">
      <MemberSignature Language="C#" Value="public float DpiY { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float32 DpiY" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Graphics.DpiY" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DpiY As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property float DpiY { float get(); };" />
      <MemberSignature Language="F#" Value="member this.DpiY : single" Usage="System.Drawing.Graphics.DpiY" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die vertikale Auflösung dieses <see cref="T:System.Drawing.Graphics" /> ab.</summary>
        <value>Der Wert in dpi (Punkte pro Zoll) für die vertikale Auflösung, die durch dieses <see cref="T:System.Drawing.Graphics" /> unterstützt wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zum Erstellen von Anwendungen mit hoher Auflösung finden Sie unter.  
  
 [Hohes dpi](https://go.microsoft.com/fwlink/?LinkId=159804).  
  
   
  
## Examples  
 Die folgende Methode zeigt die Verwendung <xref:System.Drawing.Graphics.DpiX%2A> der-Eigenschaft und der- <xref:System.Drawing.Graphics.DpiY%2A> Eigenschaft. Dieses Beispiel ist für die Verwendung mit einem Windows Form konzipiert. Um dieses Beispiel auszuführen, fügen Sie es in ein Formular ein, <xref:System.Windows.Forms.ListBox> das ein benanntes ListBox1 enthält, und nennen Sie diese Methode aus dem Konstruktor des Formulars.  
  
 [!code-cpp[System.Drawing.MiscExamples#4](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.MiscExamples/CPP/form1.cpp#4)]
 [!code-csharp[System.Drawing.MiscExamples#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.MiscExamples/CS/form1.cs#4)]
 [!code-vb[System.Drawing.MiscExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.MiscExamples/VB/form1.vb#4)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=159804">Hoher dpi-</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawArc">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zeichnet einen Bogen, der einen Teil einer Ellipse darstellt, die durch ein Koordinatenpaar, eine Breiten- und eine Höhenangabe angegeben ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawArc">
      <MemberSignature Language="C#" Value="public void DrawArc (System.Drawing.Pen pen, System.Drawing.Rectangle rect, float startAngle, float sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawArc(class System.Drawing.Pen pen, valuetype System.Drawing.Rectangle rect, float32 startAngle, float32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawArc(System.Drawing.Pen,System.Drawing.Rectangle,System.Single,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawArc(System::Drawing::Pen ^ pen, System::Drawing::Rectangle rect, float startAngle, float sweepAngle);" />
      <MemberSignature Language="F#" Value="member this.DrawArc : System.Drawing.Pen * System.Drawing.Rectangle * single * single -&gt; unit" Usage="graphics.DrawArc (pen, rect, startAngle, sweepAngle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
        <Parameter Name="startAngle" Type="System.Single" />
        <Parameter Name="sweepAngle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" />, der die Farbe, Breite und den Stil des Bogens bestimmt.</param>
        <param name="rect"><see cref="T:System.Drawing.RectangleF" />-Struktur, die die Begrenzungen der Ellipse definiert.</param>
        <param name="startAngle">Zwischen der x-Achse und dem Anfangspunkt des Bogens im Uhrzeigersinn gemessener Winkel in Grad.</param>
        <param name="sweepAngle">Zwischen dem <paramref name="startAngle" />-Parameter und dem Endpunkt des Bogens im Uhrzeigersinn gemessener Winkel in Grad.</param>
        <summary>Zeichnet einen Bogen, der einen Teil einer durch eine <see cref="T:System.Drawing.Rectangle" />-Struktur angegebene Ellipse darstellt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zeichnet einen Bogen, der einen Teil des Umkreis Werts einer Ellipse ist. Die Ellipse wird durch die Begrenzungen eines Rechtecks definiert. Der Bogen ist der Teil des Umfangs `startAngle` der Ellipse zwischen dem-Parameter und den `startAngle`  +  `sweepAngle` Parametern.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen schwarzen Stift.  
  
-   Erstellt ein Rechteck, um eine Ellipse zu binden.  
  
-   Definiert die Winkel für Start (45 Grad) und Sweep (270 Grad).  
  
-   Zeichnet den elliptischen Bogen auf den Bildschirm.  
  
 Das Ergebnis ist eine partielle Ellipse, die ein Segment zwischen + und-45 Grad der x-Achse fehlt.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#7](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#7)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#7](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#7)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawArc">
      <MemberSignature Language="C#" Value="public void DrawArc (System.Drawing.Pen pen, System.Drawing.RectangleF rect, float startAngle, float sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawArc(class System.Drawing.Pen pen, valuetype System.Drawing.RectangleF rect, float32 startAngle, float32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawArc(System.Drawing.Pen,System.Drawing.RectangleF,System.Single,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawArc(System::Drawing::Pen ^ pen, System::Drawing::RectangleF rect, float startAngle, float sweepAngle);" />
      <MemberSignature Language="F#" Value="member this.DrawArc : System.Drawing.Pen * System.Drawing.RectangleF * single * single -&gt; unit" Usage="graphics.DrawArc (pen, rect, startAngle, sweepAngle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="rect" Type="System.Drawing.RectangleF" />
        <Parameter Name="startAngle" Type="System.Single" />
        <Parameter Name="sweepAngle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" />, der die Farbe, Breite und den Stil des Bogens bestimmt.</param>
        <param name="rect"><see cref="T:System.Drawing.RectangleF" />-Struktur, die die Begrenzungen der Ellipse definiert.</param>
        <param name="startAngle">Zwischen der x-Achse und dem Anfangspunkt des Bogens im Uhrzeigersinn gemessener Winkel in Grad.</param>
        <param name="sweepAngle">Zwischen dem <paramref name="startAngle" />-Parameter und dem Endpunkt des Bogens im Uhrzeigersinn gemessener Winkel in Grad.</param>
        <summary>Zeichnet einen Bogen, der einen Teil einer durch eine <see cref="T:System.Drawing.RectangleF" />-Struktur angegebene Ellipse darstellt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zeichnet einen Bogen, der einen Teil des Umkreis Werts einer Ellipse ist. Die Ellipse wird durch die Begrenzungen eines Rechtecks definiert. Der Bogen ist der Teil des Umfangs `startAngle` der Ellipse zwischen dem-Parameter und den `startAngle`  +  `sweepAngle` Parametern.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen schwarzen Stift.  
  
-   Erstellt ein Rechteck, um eine Ellipse zu binden.  
  
-   Definiert die Winkel für Start (45 Grad) und Sweep (270 Grad).  
  
-   Zeichnet den elliptischen Bogen auf den Bildschirm.  
  
 Das Ergebnis ist eine partielle Ellipse, die ein Segment zwischen + und-45 Grad der x-Achse fehlt.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#8](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#8)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#8](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#8)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> ist gleich <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawArc">
      <MemberSignature Language="C#" Value="public void DrawArc (System.Drawing.Pen pen, int x, int y, int width, int height, int startAngle, int sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawArc(class System.Drawing.Pen pen, int32 x, int32 y, int32 width, int32 height, int32 startAngle, int32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawArc(System.Drawing.Pen,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawArc(System::Drawing::Pen ^ pen, int x, int y, int width, int height, int startAngle, int sweepAngle);" />
      <MemberSignature Language="F#" Value="member this.DrawArc : System.Drawing.Pen * int * int * int * int * int * int -&gt; unit" Usage="graphics.DrawArc (pen, x, y, width, height, startAngle, sweepAngle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
        <Parameter Name="startAngle" Type="System.Int32" />
        <Parameter Name="sweepAngle" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" />, der die Farbe, Breite und den Stil des Bogens bestimmt.</param>
        <param name="x">Die x-Koordinate der oberen linken Ecke des Rechtecks, das die Ellipse definiert.</param>
        <param name="y">Die y-Koordinate der oberen linken Ecke des Rechtecks, das die Ellipse definiert.</param>
        <param name="width">Breite des Rechtecks, das die Ellipse definiert.</param>
        <param name="height">Höhe des Rechtecks, das die Ellipse definiert.</param>
        <param name="startAngle">Zwischen der x-Achse und dem Anfangspunkt des Bogens im Uhrzeigersinn gemessener Winkel in Grad.</param>
        <param name="sweepAngle">Zwischen dem <paramref name="startAngle" />-Parameter und dem Endpunkt des Bogens im Uhrzeigersinn gemessener Winkel in Grad.</param>
        <summary>Zeichnet einen Bogen, der einen Teil einer Ellipse darstellt, die durch ein Koordinatenpaar, eine Breiten- und eine Höhenangabe angegeben ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zeichnet einen Bogen, der einen Teil des Umkreis Werts einer Ellipse ist. Die Ellipse wird durch die Begrenzungen eines Rechtecks definiert. Der Bogen ist der Teil des Umfangs `startAngle` der Ellipse zwischen dem-Parameter und den `startAngle`  +  `sweepAngle` Parametern.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen schwarzen Stift.  
  
-   Erstellt die Position und Größe eines Rechtecks, das eine Ellipse gebunden.  
  
-   Definiert die Winkel für Start (45 Grad) und Sweep (270 Grad).  
  
-   Zeichnet den elliptischen Bogen auf den Bildschirm.  
  
 Das Ergebnis ist eine partielle Ellipse, die ein Segment zwischen + und-45 Grad der x-Achse fehlt.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#9](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#9)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#9](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#9)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#9](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawArc">
      <MemberSignature Language="C#" Value="public void DrawArc (System.Drawing.Pen pen, float x, float y, float width, float height, float startAngle, float sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawArc(class System.Drawing.Pen pen, float32 x, float32 y, float32 width, float32 height, float32 startAngle, float32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawArc(System.Drawing.Pen,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawArc(System::Drawing::Pen ^ pen, float x, float y, float width, float height, float startAngle, float sweepAngle);" />
      <MemberSignature Language="F#" Value="member this.DrawArc : System.Drawing.Pen * single * single * single * single * single * single -&gt; unit" Usage="graphics.DrawArc (pen, x, y, width, height, startAngle, sweepAngle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="width" Type="System.Single" />
        <Parameter Name="height" Type="System.Single" />
        <Parameter Name="startAngle" Type="System.Single" />
        <Parameter Name="sweepAngle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" />, der die Farbe, Breite und den Stil des Bogens bestimmt.</param>
        <param name="x">Die x-Koordinate der oberen linken Ecke des Rechtecks, das die Ellipse definiert.</param>
        <param name="y">Die y-Koordinate der oberen linken Ecke des Rechtecks, das die Ellipse definiert.</param>
        <param name="width">Breite des Rechtecks, das die Ellipse definiert.</param>
        <param name="height">Höhe des Rechtecks, das die Ellipse definiert.</param>
        <param name="startAngle">Zwischen der x-Achse und dem Anfangspunkt des Bogens im Uhrzeigersinn gemessener Winkel in Grad.</param>
        <param name="sweepAngle">Zwischen dem <paramref name="startAngle" />-Parameter und dem Endpunkt des Bogens im Uhrzeigersinn gemessener Winkel in Grad.</param>
        <summary>Zeichnet einen Bogen, der einen Teil einer Ellipse darstellt, die durch ein Koordinatenpaar, eine Breiten- und eine Höhenangabe angegeben ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zeichnet einen Bogen, der einen Teil des Umkreis Werts einer Ellipse ist. Die Ellipse wird durch die Begrenzungen eines Rechtecks definiert. Der Bogen ist der Teil des Umfangs `startAngle` der Ellipse zwischen dem-Parameter und den `startAngle`  +  `sweepAngle` Parametern.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen schwarzen Stift.  
  
-   Erstellt die Position und Größe eines Rechtecks, das eine Ellipse gebunden.  
  
-   Definiert die Winkel für Start (45 Grad) und Sweep (270 Grad).  
  
-   Zeichnet den elliptischen Bogen auf den Bildschirm.  
  
 Das Ergebnis ist eine partielle Ellipse, die ein Segment zwischen + und-45 Grad der x-Achse fehlt.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#10](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#10)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#10](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#10)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#10](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawBezier">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zeichnet eine durch vier <see cref="T:System.Drawing.Point" />-Strukturen definierte Béziersplinekurve.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawBezier">
      <MemberSignature Language="C#" Value="public void DrawBezier (System.Drawing.Pen pen, System.Drawing.Point pt1, System.Drawing.Point pt2, System.Drawing.Point pt3, System.Drawing.Point pt4);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawBezier(class System.Drawing.Pen pen, valuetype System.Drawing.Point pt1, valuetype System.Drawing.Point pt2, valuetype System.Drawing.Point pt3, valuetype System.Drawing.Point pt4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawBezier(System.Drawing.Pen,System.Drawing.Point,System.Drawing.Point,System.Drawing.Point,System.Drawing.Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawBezier(System::Drawing::Pen ^ pen, System::Drawing::Point pt1, System::Drawing::Point pt2, System::Drawing::Point pt3, System::Drawing::Point pt4);" />
      <MemberSignature Language="F#" Value="member this.DrawBezier : System.Drawing.Pen * System.Drawing.Point * System.Drawing.Point * System.Drawing.Point * System.Drawing.Point -&gt; unit" Usage="graphics.DrawBezier (pen, pt1, pt2, pt3, pt4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="pt1" Type="System.Drawing.Point" />
        <Parameter Name="pt2" Type="System.Drawing.Point" />
        <Parameter Name="pt3" Type="System.Drawing.Point" />
        <Parameter Name="pt4" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" />-Struktur, die die Farbe, Breite und den Stil der Kurve bestimmt.</param>
        <param name="pt1"><see cref="T:System.Drawing.Point" />-Struktur, die den Anfangspunkt der Kurve darstellt.</param>
        <param name="pt2"><see cref="T:System.Drawing.Point" />-Struktur, die den ersten Kontrollpunkt für die Kurve darstellt.</param>
        <param name="pt3"><see cref="T:System.Drawing.Point" />-Struktur, die den zweiten Kontrollpunkt für die Kurve darstellt.</param>
        <param name="pt4"><see cref="T:System.Drawing.Point" />-Struktur, die den Endpunkt der Kurve darstellt.</param>
        <summary>Zeichnet eine durch vier <see cref="T:System.Drawing.Point" />-Strukturen definierte Béziersplinekurve.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Bézier-Kurve wird vom ersten Punkt bis zum vierten Punkt gezeichnet. Der zweite und der dritte Punkt sind Steuerungs Punkte, die die Form der Kurve bestimmen.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen schwarzen Stift.  
  
-   Erstellt die Start-, End-und zwei Steuerungs Punkte für die Kurve.  
  
-   Zeichnet die Bézier-Kurve auf den Bildschirm.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#11](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#11)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#11](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#11)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#11](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawBezier">
      <MemberSignature Language="C#" Value="public void DrawBezier (System.Drawing.Pen pen, System.Drawing.PointF pt1, System.Drawing.PointF pt2, System.Drawing.PointF pt3, System.Drawing.PointF pt4);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawBezier(class System.Drawing.Pen pen, valuetype System.Drawing.PointF pt1, valuetype System.Drawing.PointF pt2, valuetype System.Drawing.PointF pt3, valuetype System.Drawing.PointF pt4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawBezier(System.Drawing.Pen,System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawBezier(System::Drawing::Pen ^ pen, System::Drawing::PointF pt1, System::Drawing::PointF pt2, System::Drawing::PointF pt3, System::Drawing::PointF pt4);" />
      <MemberSignature Language="F#" Value="member this.DrawBezier : System.Drawing.Pen * System.Drawing.PointF * System.Drawing.PointF * System.Drawing.PointF * System.Drawing.PointF -&gt; unit" Usage="graphics.DrawBezier (pen, pt1, pt2, pt3, pt4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="pt1" Type="System.Drawing.PointF" />
        <Parameter Name="pt2" Type="System.Drawing.PointF" />
        <Parameter Name="pt3" Type="System.Drawing.PointF" />
        <Parameter Name="pt4" Type="System.Drawing.PointF" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" />, der die Farbe, Breite und den Stil der Kurve bestimmt.</param>
        <param name="pt1"><see cref="T:System.Drawing.PointF" />-Struktur, die den Anfangspunkt der Kurve darstellt.</param>
        <param name="pt2"><see cref="T:System.Drawing.PointF" />-Struktur, die den ersten Kontrollpunkt für die Kurve darstellt.</param>
        <param name="pt3"><see cref="T:System.Drawing.PointF" />-Struktur, die den zweiten Kontrollpunkt für die Kurve darstellt.</param>
        <param name="pt4"><see cref="T:System.Drawing.PointF" />-Struktur, die den Endpunkt der Kurve darstellt.</param>
        <summary>Zeichnet eine durch vier <see cref="T:System.Drawing.PointF" />-Strukturen definierte Béziersplinekurve.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Bézier-Spline wird vom ersten Punkt bis zum vierten Punkt gezeichnet. Der zweite und der dritte Punkt sind Steuerungs Punkte, die die Form der Kurve bestimmen.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen schwarzen Stift.  
  
-   Erstellt die Start-, End-und zwei Steuerungs Punkte für die Kurve.  
  
-   Zeichnet die Bézier-Kurve auf den Bildschirm.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#12](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#12)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#12](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#12)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#12](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawBezier">
      <MemberSignature Language="C#" Value="public void DrawBezier (System.Drawing.Pen pen, float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawBezier(class System.Drawing.Pen pen, float32 x1, float32 y1, float32 x2, float32 y2, float32 x3, float32 y3, float32 x4, float32 y4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawBezier(System.Drawing.Pen,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawBezier(System::Drawing::Pen ^ pen, float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4);" />
      <MemberSignature Language="F#" Value="member this.DrawBezier : System.Drawing.Pen * single * single * single * single * single * single * single * single -&gt; unit" Usage="graphics.DrawBezier (pen, x1, y1, x2, y2, x3, y3, x4, y4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="x1" Type="System.Single" />
        <Parameter Name="y1" Type="System.Single" />
        <Parameter Name="x2" Type="System.Single" />
        <Parameter Name="y2" Type="System.Single" />
        <Parameter Name="x3" Type="System.Single" />
        <Parameter Name="y3" Type="System.Single" />
        <Parameter Name="x4" Type="System.Single" />
        <Parameter Name="y4" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" />, der die Farbe, Breite und den Stil der Kurve bestimmt.</param>
        <param name="x1">Die x-Koordinate des Anfangspunkts der Kurve.</param>
        <param name="y1">Die y-Koordinate des Anfangspunkts der Kurve.</param>
        <param name="x2">Die x-Koordinate des ersten Kontrollpunkts der Kurve.</param>
        <param name="y2">Die y-Koordinate des ersten Kontrollpunkts der Kurve.</param>
        <param name="x3">Die x-Koordinate des zweiten Kontrollpunkts der Kurve.</param>
        <param name="y3">Die y-Koordinate des zweiten Kontrollpunkts der Kurve.</param>
        <param name="x4">Die x-Koordinate des Endpunkts der Kurve.</param>
        <param name="y4">Die y-Koordinate des Endpunkts der Kurve.</param>
        <summary>Zeichnet eine Béziersplinekurve, die durch vier geordnete Koordinatenpaare definiert ist, die Punkte darstellen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Bézier-Spline wird vom ersten Punkt bis zum vierten Punkt gezeichnet. Der zweite und der dritte Punkt sind Steuerungs Punkte, die die Form der Kurve bestimmen.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen schwarzen Stift.  
  
-   Erstellt die Koordinaten der Start-, End-und zwei Steuerungs Punkte für die Kurve.  
  
-   Zeichnet die Bézier-Kurve auf den Bildschirm.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#13](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#13)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#13](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#13)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#13](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawBeziers">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zeichnet eine Reihe von Béziersplinekurven aus einem Array von <see cref="T:System.Drawing.Point" />-Strukturen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawBeziers">
      <MemberSignature Language="C#" Value="public void DrawBeziers (System.Drawing.Pen pen, System.Drawing.Point[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawBeziers(class System.Drawing.Pen pen, valuetype System.Drawing.Point[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawBeziers(System.Drawing.Pen,System.Drawing.Point[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawBeziers(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::Point&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.DrawBeziers : System.Drawing.Pen * System.Drawing.Point[] -&gt; unit" Usage="graphics.DrawBeziers (pen, points)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="points" Type="System.Drawing.Point[]" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" />, der die Farbe, Breite und den Stil der Kurve bestimmt.</param>
        <param name="points">Ein Array von <see cref="T:System.Drawing.Point" />-Strukturen, die die Punkte für die Bestimmung des Kurvenverlaufs darstellen. Die Anzahl von Punkten im Array sollte ein Vielfaches von 3 + 1 sein, z. B. 4, 7 oder 10.</param>
        <summary>Zeichnet eine Reihe von Béziersplinekurven aus einem Array von <see cref="T:System.Drawing.Point" />-Strukturen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Anzahl der Punkte im Array sollte ein Vielfaches von 3 Plus 1 sein, da für den ersten Spline 4 Punkte erforderlich sind und alle anderen Splines jeweils 3 Punkte erfordern. Der erste Bézier-Spline wird vom ersten Punkt bis zum vierten Punkt im Punkt Array gezeichnet. Der zweite und der dritte Punkt sind Steuerungs Punkte, die die Form der Kurve bestimmen. Jede nachfolgende Kurve benötigt genau drei weitere Punkte: zwei weitere Steuerungs Punkte und ein Endpunkt. Der Endpunkt der vorherigen Kurve wird als Ausgangspunkt für jede weitere Kurve verwendet.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen schwarzen Stift.  
  
-   Erstellt die Start-, End-und zwei Steuerungs Punkte für eine erste Kurve und einen Endpunkt und zwei Kontrollpunkte für eine zweite Kurve.  
  
-   Zeichnet die aufeinander folgenden Bézier-Kurven auf den Bildschirm.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#14](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#14)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#14](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#14)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#14](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="points" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawBeziers">
      <MemberSignature Language="C#" Value="public void DrawBeziers (System.Drawing.Pen pen, System.Drawing.PointF[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawBeziers(class System.Drawing.Pen pen, valuetype System.Drawing.PointF[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawBeziers(System.Drawing.Pen,System.Drawing.PointF[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawBeziers(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::PointF&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.DrawBeziers : System.Drawing.Pen * System.Drawing.PointF[] -&gt; unit" Usage="graphics.DrawBeziers (pen, points)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" />, der die Farbe, Breite und den Stil der Kurve bestimmt.</param>
        <param name="points">Ein Array von <see cref="T:System.Drawing.PointF" />-Strukturen, die die Punkte für die Bestimmung des Kurvenverlaufs darstellen. Die Anzahl von Punkten im Array sollte ein Vielfaches von 3 + 1 sein, z. B. 4, 7 oder 10.</param>
        <summary>Zeichnet eine Reihe von Béziersplinekurven aus einem Array von <see cref="T:System.Drawing.PointF" />-Strukturen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Anzahl der Punkte im Array sollte ein Vielfaches von 3 Plus 1 sein, da für den ersten Spline 4 Punkte erforderlich sind und alle anderen Splines jeweils 3 Punkte erfordern. Die erste Bézier-Kurve wird vom ersten Punkt bis zum vierten Punkt im Punkt Array gezeichnet. Der zweite und der dritte Punkt sind Steuerungs Punkte, die die Form der Kurve bestimmen. Jede nachfolgende Kurve benötigt genau drei weitere Punkte: zwei weitere Steuerungs Punkte und ein Endpunkt. Der Endpunkt der vorherigen Kurve wird als Ausgangspunkt für jede weitere Kurve verwendet.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen schwarzen Stift.  
  
-   Erstellt die Start-, End-und zwei Steuerungs Punkte für eine erste Kurve und einen Endpunkt und zwei Kontrollpunkte für eine zweite Kurve.  
  
-   Zeichnet die aufeinander folgenden Bézier-Kurven auf den Bildschirm.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#15](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#15)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#15](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#15)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#15](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="points" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawClosedCurve">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zeichnet eine geschlossene Cardinal-Splinekurve, die durch ein Array von <see cref="T:System.Drawing.Point" />-Strukturen definiert ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawClosedCurve">
      <MemberSignature Language="C#" Value="public void DrawClosedCurve (System.Drawing.Pen pen, System.Drawing.Point[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawClosedCurve(class System.Drawing.Pen pen, valuetype System.Drawing.Point[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawClosedCurve(System.Drawing.Pen,System.Drawing.Point[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawClosedCurve(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::Point&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.DrawClosedCurve : System.Drawing.Pen * System.Drawing.Point[] -&gt; unit" Usage="graphics.DrawClosedCurve (pen, points)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="points" Type="System.Drawing.Point[]" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" />, der die Farbe, Breite und Höhe der Kurve bestimmt.</param>
        <param name="points">Array von <see cref="T:System.Drawing.Point" />-Strukturen, die die Splinekurve definieren.</param>
        <summary>Zeichnet eine geschlossene Cardinal-Splinekurve, die durch ein Array von <see cref="T:System.Drawing.Point" />-Strukturen definiert ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zeichnet einen geschlossenen kardinalspline, der die einzelnen Punkte im Array durchläuft. Wenn der letzte Punkt nicht mit dem ersten Punkt identisch ist, wird vom letzten Punkt zum ersten Punkt ein zusätzliches Kurven Segment hinzugefügt, um die Abbildung zu schließen.  
  
 Das Array der Punkte muss mindestens vier <xref:System.Drawing.Point> Strukturen enthalten.  
  
 Diese Methode verwendet eine Standardspannung von 0,5.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt rote und grüne Stifte.  
  
-   Erstellt sieben Punkte, um eine Kurve zu definieren.  
  
-   Zeichnet sieben rote Linien zwischen den sieben Punkten, um ein geschlossenes Polygon zu bilden.  
  
-   Zeichnet durch die sieben Punkte eine grüne geschlossene Kurve.  
  
 Die-Methode verwendet eine Standardspannung von 0,5.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#16](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#16)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#16](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#16)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#16](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="points" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawClosedCurve">
      <MemberSignature Language="C#" Value="public void DrawClosedCurve (System.Drawing.Pen pen, System.Drawing.PointF[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawClosedCurve(class System.Drawing.Pen pen, valuetype System.Drawing.PointF[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawClosedCurve(System.Drawing.Pen,System.Drawing.PointF[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawClosedCurve(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::PointF&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.DrawClosedCurve : System.Drawing.Pen * System.Drawing.PointF[] -&gt; unit" Usage="graphics.DrawClosedCurve (pen, points)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" />, der die Farbe, Breite und Höhe der Kurve bestimmt.</param>
        <param name="points">Array von <see cref="T:System.Drawing.PointF" />-Strukturen, die die Splinekurve definieren.</param>
        <summary>Zeichnet eine geschlossene Cardinal-Splinekurve, die durch ein Array von <see cref="T:System.Drawing.PointF" />-Strukturen definiert ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zeichnet einen geschlossenen kardinalspline, der die einzelnen Punkte im Array durchläuft. Wenn der letzte Punkt nicht mit dem ersten Punkt identisch ist, wird ein zusätzliches Kurven Segment vom letzten Punkt zum ersten Punkt hinzugefügt, um es zu schließen.  
  
 Das Array der Punkte muss mindestens vier <xref:System.Drawing.PointF> Strukturen enthalten.  
  
 Diese Methode verwendet eine Standardspannung von 0,5.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt rote und grüne Stifte.  
  
-   Erstellt sieben Punkte, um eine Kurve zu definieren.  
  
-   Zeichnet sieben rote Linien zwischen den sieben Punkten, um ein geschlossenes Polygon zu bilden.  
  
-   Zeichnet durch die sieben Punkte eine grüne geschlossene Kurve.  
  
 Die-Methode verwendet eine Standardspannung von 0,5.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#18](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#18)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#18](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#18)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#18](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="points" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawClosedCurve">
      <MemberSignature Language="C#" Value="public void DrawClosedCurve (System.Drawing.Pen pen, System.Drawing.Point[] points, float tension, System.Drawing.Drawing2D.FillMode fillmode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawClosedCurve(class System.Drawing.Pen pen, valuetype System.Drawing.Point[] points, float32 tension, valuetype System.Drawing.Drawing2D.FillMode fillmode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawClosedCurve(System.Drawing.Pen,System.Drawing.Point[],System.Single,System.Drawing.Drawing2D.FillMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawClosedCurve(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::Point&gt; ^ points, float tension, System::Drawing::Drawing2D::FillMode fillmode);" />
      <MemberSignature Language="F#" Value="member this.DrawClosedCurve : System.Drawing.Pen * System.Drawing.Point[] * single * System.Drawing.Drawing2D.FillMode -&gt; unit" Usage="graphics.DrawClosedCurve (pen, points, tension, fillmode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="points" Type="System.Drawing.Point[]" />
        <Parameter Name="tension" Type="System.Single" />
        <Parameter Name="fillmode" Type="System.Drawing.Drawing2D.FillMode" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" />, der die Farbe, Breite und Höhe der Kurve bestimmt.</param>
        <param name="points">Array von <see cref="T:System.Drawing.Point" />-Strukturen, die die Splinekurve definieren.</param>
        <param name="tension">Ein Wert größer oder gleich 0,0F, der die Spannung der Kurve angibt.</param>
        <param name="fillmode">Member der <see cref="T:System.Drawing.Drawing2D.FillMode" />-Enumeration, der bestimmt, wie die Kurve ausgefüllt wird. Dieser Parameter ist erforderlich, wird aber ignoriert.</param>
        <summary>Zeichnet unter Verwendung der angegebenen Spannung eine geschlossene Cardinal-Splinekurve, die durch ein Array von <see cref="T:System.Drawing.Point" />-Strukturen definiert ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zeichnet einen geschlossenen kardinalspline, der die einzelnen Punkte im Array durchläuft. Wenn der letzte Punkt nicht mit dem ersten Punkt identisch ist, wird ein zusätzliches Kurven Segment vom letzten Punkt zum ersten Punkt hinzugefügt, um es zu schließen.  
  
 Das Array der Punkte muss mindestens vier <xref:System.Drawing.Point> Strukturen enthalten.  
  
 Der `tension` -Parameter bestimmt die Form der Spline. Wenn der Wert des `tension` -Parameters 0,0 f ist, zeichnet diese Methode gerade Liniensegmente, um die Punkte zu verbinden. Normalerweise ist `tension` der-Parameter kleiner oder gleich 1.0 f. Werte über 1.0 f verursachen ungewöhnliche Ergebnisse.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt rote und grüne Stifte.  
  
-   Erstellt sieben Punkte, um die Kurve zu definieren.  
  
-   Zeichnet sieben rote Linien zwischen den sieben Punkten, um ein Polygon zu bilden.  
  
-   Erstellt Einstellungen für den Spannungs-und Füllmodus.  
  
-   Zeichnet durch die sieben Punkte eine grüne geschlossene Kurve.  
  
 Die-Methode verwendet eine Spannung von 1,0 und legt den Füll Modus `FillMode.Alternate`auf fest.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#17](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#17)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#17](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#17)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#17](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="points" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawClosedCurve">
      <MemberSignature Language="C#" Value="public void DrawClosedCurve (System.Drawing.Pen pen, System.Drawing.PointF[] points, float tension, System.Drawing.Drawing2D.FillMode fillmode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawClosedCurve(class System.Drawing.Pen pen, valuetype System.Drawing.PointF[] points, float32 tension, valuetype System.Drawing.Drawing2D.FillMode fillmode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawClosedCurve(System.Drawing.Pen,System.Drawing.PointF[],System.Single,System.Drawing.Drawing2D.FillMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawClosedCurve(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::PointF&gt; ^ points, float tension, System::Drawing::Drawing2D::FillMode fillmode);" />
      <MemberSignature Language="F#" Value="member this.DrawClosedCurve : System.Drawing.Pen * System.Drawing.PointF[] * single * System.Drawing.Drawing2D.FillMode -&gt; unit" Usage="graphics.DrawClosedCurve (pen, points, tension, fillmode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
        <Parameter Name="tension" Type="System.Single" />
        <Parameter Name="fillmode" Type="System.Drawing.Drawing2D.FillMode" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" />, der die Farbe, Breite und Höhe der Kurve bestimmt.</param>
        <param name="points">Array von <see cref="T:System.Drawing.PointF" />-Strukturen, die die Splinekurve definieren.</param>
        <param name="tension">Ein Wert größer oder gleich 0,0F, der die Spannung der Kurve angibt.</param>
        <param name="fillmode">Member der <see cref="T:System.Drawing.Drawing2D.FillMode" />-Enumeration, der bestimmt, wie die Kurve ausgefüllt wird. Dieser Parameter ist erforderlich, wird aber ignoriert.</param>
        <summary>Zeichnet unter Verwendung der angegebenen Spannung eine geschlossene Cardinal-Splinekurve, die durch ein Array von <see cref="T:System.Drawing.PointF" />-Strukturen definiert ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zeichnet einen geschlossenen kardinalspline, der die einzelnen Punkte im Array durchläuft. Wenn der letzte Punkt nicht mit dem ersten Punkt identisch ist, wird ein zusätzliches Kurven Segment vom letzten Punkt zum ersten Punkt hinzugefügt, um es zu schließen.  
  
 Das Array der Punkte muss mindestens vier <xref:System.Drawing.PointF> Strukturen enthalten.  
  
 Der `tension` -Parameter bestimmt die Form der Spline. Wenn der Wert des `tension` -Parameters 0,0 f ist, zeichnet diese Methode gerade Liniensegmente, um die Punkte zu verbinden. Normalerweise ist `tension` der-Parameter kleiner oder gleich 1.0 f. Werte über 1.0 f verursachen ungewöhnliche Ergebnisse.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt rote und grüne Stifte.  
  
-   Erstellt sieben Punkte, um die Kurve zu definieren.  
  
-   Zeichnet sieben rote Linien zwischen den sieben Punkten, um ein Polygon zu bilden.  
  
-   Erstellt Einstellungen für den Spannungs-und Füllmodus.  
  
-   Zeichnet durch die sieben Punkte eine grüne geschlossene Kurve.  
  
 Die-Methode verwendet eine Spannung von 1,0 und legt den Füll Modus `FillMode.Alternate`auf fest.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#19](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#19)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#19](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#19)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#19](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="points" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawCurve">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zeichnet eine Cardinal-Splinekurve durch ein angegebenes Array von <see cref="T:System.Drawing.Point" />-Strukturen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawCurve">
      <MemberSignature Language="C#" Value="public void DrawCurve (System.Drawing.Pen pen, System.Drawing.Point[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawCurve(class System.Drawing.Pen pen, valuetype System.Drawing.Point[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawCurve(System.Drawing.Pen,System.Drawing.Point[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawCurve(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::Point&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.DrawCurve : System.Drawing.Pen * System.Drawing.Point[] -&gt; unit" Usage="graphics.DrawCurve (pen, points)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="points" Type="System.Drawing.Point[]" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" />, der die Farbe, Breite und Höhe der Kurve bestimmt.</param>
        <param name="points">Array von <see cref="T:System.Drawing.Point" />-Strukturen, die die Splinekurve definieren.</param>
        <summary>Zeichnet eine Cardinal-Splinekurve durch ein angegebenes Array von <see cref="T:System.Drawing.Point" />-Strukturen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zeichnet einen kardinalspline, der die einzelnen Punkte im Array durchläuft.  
  
 Das Array von Punkten muss mindestens drei <xref:System.Drawing.Point> Strukturen enthalten, damit eine Kurve gezeichnet wird.  
  
 Diese Methode verwendet eine Standardspannung von 0,5.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt rote und grüne Stifte.  
  
-   Erstellt sieben Punkte, um eine Kurve zu definieren.  
  
-   Zeichnet sechs rote Linien zwischen den sieben Punkten, um ein unvollständiges Polygon zu bilden.  
  
-   Zeichnet eine offene grüne Kurve durch die sieben Punkte.  
  
 Die-Methode verwendet eine Standardspannung von 0,5.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#20](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#20)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#20](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#20)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#20](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="points" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawCurve">
      <MemberSignature Language="C#" Value="public void DrawCurve (System.Drawing.Pen pen, System.Drawing.PointF[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawCurve(class System.Drawing.Pen pen, valuetype System.Drawing.PointF[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawCurve(System.Drawing.Pen,System.Drawing.PointF[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawCurve(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::PointF&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.DrawCurve : System.Drawing.Pen * System.Drawing.PointF[] -&gt; unit" Usage="graphics.DrawCurve (pen, points)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" />, der die Farbe, Breite und den Stil der Kurve bestimmt.</param>
        <param name="points">Array von <see cref="T:System.Drawing.PointF" />-Strukturen, die die Splinekurve definieren.</param>
        <summary>Zeichnet eine Cardinal-Splinekurve durch ein angegebenes Array von <see cref="T:System.Drawing.PointF" />-Strukturen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zeichnet einen kardinalspline, der die einzelnen Punkte im Array durchläuft.  
  
 Das Array von Punkten muss mindestens drei <xref:System.Drawing.PointF> Strukturen enthalten, damit eine Kurve gezeichnet wird.  
  
 Diese Methode verwendet eine Standardspannung von 0,5.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt rote und grüne Stifte.  
  
-   Erstellt sieben Punkte, um eine Kurve zu definieren.  
  
-   Zeichnet sechs rote Linien zwischen den sieben Punkten, um ein unvollständiges Polygon zu bilden.  
  
-   Zeichnet eine offene grüne Kurve durch die sieben Punkte.  
  
 Die-Methode verwendet eine Standardspannung von 0,5.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#23](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#23)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#23](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#23)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#23](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="points" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawCurve">
      <MemberSignature Language="C#" Value="public void DrawCurve (System.Drawing.Pen pen, System.Drawing.Point[] points, float tension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawCurve(class System.Drawing.Pen pen, valuetype System.Drawing.Point[] points, float32 tension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawCurve(System.Drawing.Pen,System.Drawing.Point[],System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawCurve(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::Point&gt; ^ points, float tension);" />
      <MemberSignature Language="F#" Value="member this.DrawCurve : System.Drawing.Pen * System.Drawing.Point[] * single -&gt; unit" Usage="graphics.DrawCurve (pen, points, tension)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="points" Type="System.Drawing.Point[]" />
        <Parameter Name="tension" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" />, der die Farbe, Breite und den Stil der Kurve bestimmt.</param>
        <param name="points">Array von <see cref="T:System.Drawing.Point" />-Strukturen, die die Splinekurve definieren.</param>
        <param name="tension">Ein Wert größer oder gleich 0,0F, der die Spannung der Kurve angibt.</param>
        <summary>Zeichnet unter Verwendung der angegebenen Spannung eine Cardinal-Splinekurve durch ein angegebenes Array von <see cref="T:System.Drawing.Point" />-Strukturen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zeichnet einen kardinalspline, der die einzelnen Punkte im Array durchläuft.  
  
 Das Array von Punkten muss mindestens drei <xref:System.Drawing.Point> Strukturen enthalten, damit eine Kurve gezeichnet wird.  
  
 Der `tension` -Parameter bestimmt die Form der Spline. Wenn der Wert des `tension` -Parameters 0,0 f ist, zeichnet diese Methode gerade Liniensegmente, um die Punkte zu verbinden. Normalerweise ist `tension` der-Parameter kleiner oder gleich 1.0 f. Werte über 1.0 f verursachen ungewöhnliche Ergebnisse.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt rote und grüne Stifte.  
  
-   Erstellt sieben Punkte, um die Kurve zu definieren.  
  
-   Zeichnet sechs rote Linien zwischen den sieben Punkten, um ein unvollständiges Polygon zu bilden.  
  
-   Erstellt eine Spannungs Einstellung.  
  
-   Zeichnet eine offene grüne geschlossene Kurve durch die sieben Punkte.  
  
 Die-Methode verwendet eine Spannung von 1,0.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#22](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#22)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#22](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#22)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#22](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="points" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawCurve">
      <MemberSignature Language="C#" Value="public void DrawCurve (System.Drawing.Pen pen, System.Drawing.PointF[] points, float tension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawCurve(class System.Drawing.Pen pen, valuetype System.Drawing.PointF[] points, float32 tension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawCurve(System.Drawing.Pen,System.Drawing.PointF[],System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawCurve(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::PointF&gt; ^ points, float tension);" />
      <MemberSignature Language="F#" Value="member this.DrawCurve : System.Drawing.Pen * System.Drawing.PointF[] * single -&gt; unit" Usage="graphics.DrawCurve (pen, points, tension)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
        <Parameter Name="tension" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" />, der die Farbe, Breite und den Stil der Kurve bestimmt.</param>
        <param name="points">Array von <see cref="T:System.Drawing.PointF" />-Strukturen, die die Punkte für die Definition des Kurvenverlaufs darstellen.</param>
        <param name="tension">Ein Wert größer oder gleich 0,0F, der die Spannung der Kurve angibt.</param>
        <summary>Zeichnet unter Verwendung der angegebenen Spannung eine Cardinal-Splinekurve durch ein angegebenes Array von <see cref="T:System.Drawing.PointF" />-Strukturen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zeichnet einen kardinalspline, der die einzelnen Punkte im Array durchläuft.  
  
 Das Array von Punkten muss mindestens drei <xref:System.Drawing.PointF> Strukturen enthalten, damit eine Kurve gezeichnet wird.  
  
 Der `tension` -Parameter bestimmt die Form der Spline. Wenn der Wert des `tension` -Parameters 0,0 f ist, zeichnet diese Methode gerade Liniensegmente, um die Punkte zu verbinden. Normalerweise ist `tension` der-Parameter kleiner oder gleich 1.0 f. Werte über 1.0 f verursachen ungewöhnliche Ergebnisse.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt rote und grüne Stifte.  
  
-   Erstellt sieben Punkte, um die Kurve zu definieren.  
  
-   Zeichnet sechs rote Linien zwischen den sieben Punkten, um ein unvollständiges Polygon zu bilden.  
  
-   Erstellt eine Spannungs Einstellung.  
  
-   Zeichnet eine offene grüne geschlossene Kurve durch die sieben Punkte.  
  
 Die-Methode verwendet eine Spannung von 1,0.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#26](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#26)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#26](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#26)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#26](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#26)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="points" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawCurve">
      <MemberSignature Language="C#" Value="public void DrawCurve (System.Drawing.Pen pen, System.Drawing.PointF[] points, int offset, int numberOfSegments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawCurve(class System.Drawing.Pen pen, valuetype System.Drawing.PointF[] points, int32 offset, int32 numberOfSegments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawCurve(System.Drawing.Pen,System.Drawing.PointF[],System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawCurve(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::PointF&gt; ^ points, int offset, int numberOfSegments);" />
      <MemberSignature Language="F#" Value="member this.DrawCurve : System.Drawing.Pen * System.Drawing.PointF[] * int * int -&gt; unit" Usage="graphics.DrawCurve (pen, points, offset, numberOfSegments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="numberOfSegments" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" />, der die Farbe, Breite und den Stil der Kurve bestimmt.</param>
        <param name="points">Array von <see cref="T:System.Drawing.PointF" />-Strukturen, die die Splinekurve definieren.</param>
        <param name="offset">Offset vom ersten Element im Array des <paramref name="points" />-Parameters bis zum Anfangspunkt der Kurve.</param>
        <param name="numberOfSegments">Anzahl der Segmente nach dem Anfangspunkt, die in die Kurve aufgenommen werden sollen.</param>
        <summary>Zeichnet eine Cardinal-Splinekurve durch ein angegebenes Array von <see cref="T:System.Drawing.PointF" />-Strukturen. Die Zeichnung beginnt am Offset vom Anfang des Arrays.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zeichnet einen kardinalspline, der die einzelnen Punkte im Array durchläuft.  
  
 Das Array von Punkten muss mindestens drei <xref:System.Drawing.PointF> Strukturen enthalten, damit eine Kurve gezeichnet wird.  
  
 Der Wert des `offset` -Parameters gibt die Anzahl der Elemente an, die im Array übersprungen werden sollen. Das erste Element nach den übersprungenen Elementen stellt den Anfangspunkt der Kurve dar.  
  
 Der Wert des `numberOfSegments` -Parameters gibt an, wie viele Segmente nach dem Anfangspunkt in der Kurve gezeichnet werden. Der Wert des `numberOfSegments` -Parameters muss mindestens 1 betragen. Der Wert des `offset` -Parameters und der Wert `numberOfSegments` des-Parameters müssen kleiner als die Anzahl der Elemente `points` im-Array des-Parameters sein.  
  
 Diese Methode verwendet eine Standardspannung von 0,5.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt rote und grüne Stifte.  
  
-   Erstellt sieben Punkte, um eine Kurve zu definieren.  
  
-   Zeichnet sechs rote Linien zwischen den sieben Punkten, um ein unvollständiges Polygon zu bilden.  
  
-   Definiert den Anfangspunkt Offset und die Anzahl der Segmente.  
  
-   Zeichnet eine offene grüne Kurve (beginnend mit dem dritten Punkt) bis zu den letzten fünf Punkten.  
  
 Die-Methode verwendet eine Standardspannung von 0,5.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#24](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#24)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#24](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#24)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#24](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#24)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="points" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawCurve">
      <MemberSignature Language="C#" Value="public void DrawCurve (System.Drawing.Pen pen, System.Drawing.Point[] points, int offset, int numberOfSegments, float tension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawCurve(class System.Drawing.Pen pen, valuetype System.Drawing.Point[] points, int32 offset, int32 numberOfSegments, float32 tension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawCurve(System.Drawing.Pen,System.Drawing.Point[],System.Int32,System.Int32,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawCurve(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::Point&gt; ^ points, int offset, int numberOfSegments, float tension);" />
      <MemberSignature Language="F#" Value="member this.DrawCurve : System.Drawing.Pen * System.Drawing.Point[] * int * int * single -&gt; unit" Usage="graphics.DrawCurve (pen, points, offset, numberOfSegments, tension)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="points" Type="System.Drawing.Point[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="numberOfSegments" Type="System.Int32" />
        <Parameter Name="tension" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" />, der die Farbe, Breite und den Stil der Kurve bestimmt.</param>
        <param name="points">Array von <see cref="T:System.Drawing.Point" />-Strukturen, die die Splinekurve definieren.</param>
        <param name="offset">Offset vom ersten Element im Array des <paramref name="points" />-Parameters bis zum Anfangspunkt der Kurve.</param>
        <param name="numberOfSegments">Anzahl der Segmente nach dem Anfangspunkt, die in die Kurve aufgenommen werden sollen.</param>
        <param name="tension">Ein Wert größer oder gleich 0,0F, der die Spannung der Kurve angibt.</param>
        <summary>Zeichnet unter Verwendung der angegebenen Spannung eine Cardinal-Splinekurve durch ein angegebenes Array von <see cref="T:System.Drawing.Point" />-Strukturen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zeichnet einen kardinalspline, der die einzelnen Punkte im Array durchläuft.  
  
 Das Array von Punkten muss mindestens drei <xref:System.Drawing.Point> Strukturen enthalten, damit eine Kurve gezeichnet wird.  
  
 Der Wert des `offset` -Parameters gibt die Anzahl der Elemente an, die im Array übersprungen werden sollen. Das erste Element nach den übersprungenen Elementen stellt den Anfangspunkt der Kurve dar.  
  
 Der Wert des `numberOfSegments` -Parameters gibt an, wie viele Segmente nach dem Anfangspunkt in der Kurve gezeichnet werden. Der Wert des `numberOfSegments` -Parameters muss mindestens 1 betragen. Der Wert des `offset` -Parameters und der Wert `numberOfSegments` des-Parameters müssen kleiner als die Anzahl der Elemente `points` im-Array des-Parameters sein.  
  
 Der `tension` -Parameter bestimmt die Form der Spline. Wenn der Wert des `tension` -Parameters 0,0 f ist, zeichnet diese Methode gerade Liniensegmente, um die Punkte zu verbinden. Normalerweise ist `tension` der-Parameter kleiner oder gleich 1.0 f. Werte über 1.0 f verursachen ungewöhnliche Ergebnisse.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt rote und grüne Stifte.  
  
-   Erstellt sieben Punkte, um eine Kurve zu definieren.  
  
-   Zeichnet sechs rote Linien zwischen den sieben Punkten, um ein unvollständiges Polygon zu bilden.  
  
-   Definiert den Anfangspunkt Offset und die Anzahl der Segmente.  
  
-   Definiert die Spannung.  
  
-   Zeichnet eine offene grüne Kurve (beginnend mit dem dritten Punkt) bis zu den letzten fünf Punkten.  
  
 Die-Methode legt die Spannung auf 1,0 fest.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#21](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#21)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#21](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#21)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#21](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="points" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawCurve">
      <MemberSignature Language="C#" Value="public void DrawCurve (System.Drawing.Pen pen, System.Drawing.PointF[] points, int offset, int numberOfSegments, float tension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawCurve(class System.Drawing.Pen pen, valuetype System.Drawing.PointF[] points, int32 offset, int32 numberOfSegments, float32 tension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawCurve(System.Drawing.Pen,System.Drawing.PointF[],System.Int32,System.Int32,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawCurve(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::PointF&gt; ^ points, int offset, int numberOfSegments, float tension);" />
      <MemberSignature Language="F#" Value="member this.DrawCurve : System.Drawing.Pen * System.Drawing.PointF[] * int * int * single -&gt; unit" Usage="graphics.DrawCurve (pen, points, offset, numberOfSegments, tension)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="numberOfSegments" Type="System.Int32" />
        <Parameter Name="tension" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" />, der die Farbe, Breite und den Stil der Kurve bestimmt.</param>
        <param name="points">Array von <see cref="T:System.Drawing.PointF" />-Strukturen, die die Splinekurve definieren.</param>
        <param name="offset">Offset vom ersten Element im Array des <paramref name="points" />-Parameters bis zum Anfangspunkt der Kurve.</param>
        <param name="numberOfSegments">Anzahl der Segmente nach dem Anfangspunkt, die in die Kurve aufgenommen werden sollen.</param>
        <param name="tension">Ein Wert größer oder gleich 0,0F, der die Spannung der Kurve angibt.</param>
        <summary>Zeichnet unter Verwendung der angegebenen Spannung eine Cardinal-Splinekurve durch ein angegebenes Array von <see cref="T:System.Drawing.PointF" />-Strukturen. Die Zeichnung beginnt am Offset vom Anfang des Arrays.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zeichnet einen kardinalspline, der die einzelnen Punkte im Array durchläuft.  
  
 Das Array von Punkten muss mindestens drei <xref:System.Drawing.PointF> Strukturen enthalten, damit die Kurve gezeichnet wird.  
  
 Der Wert des `offset` -Parameters gibt die Anzahl der Elemente an, die im Array übersprungen werden sollen. Das erste Element nach den übersprungenen Elementen stellt den Anfangspunkt der Kurve dar.  
  
 Der Wert des `numberOfSegments` -Parameters gibt an, wie viele Segmente nach dem Anfangspunkt in der Kurve gezeichnet werden. Der Wert des `numberOfSegments` -Parameters muss mindestens 1 betragen. Der Wert des `offset` -Parameters und der Wert `numberOfSegments` des-Parameters müssen kleiner als die Anzahl der Elemente `points` im-Array des-Parameters sein.  
  
 Der `tension` -Parameter bestimmt die Form der Spline. Wenn der Wert des `tension` -Parameters 0,0 f ist, zeichnet diese Methode gerade Liniensegmente, um die Punkte zu verbinden. Normalerweise ist `tension` der-Parameter kleiner oder gleich 1.0 f. Werte über 1.0 f verursachen ungewöhnliche Ergebnisse.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt rote und grüne Stifte.  
  
-   Erstellt sieben Punkte, um eine Kurve zu definieren.  
  
-   Zeichnet sechs rote Linien zwischen den sieben Punkten, um ein unvollständiges Polygon zu bilden.  
  
-   Definiert den Anfangspunkt Offset und die Anzahl der Segmente.  
  
-   Definiert die Spannung.  
  
-   Zeichnet eine offene grüne Kurve (beginnend mit dem dritten Punkt) bis zu den letzten fünf Punkten.  
  
 Die-Methode legt die Spannung auf 1,0 fest.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#25](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#25)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#25](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#25)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#25](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="points" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawEllipse">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zeichnet eine Ellipse, die durch ein umschließendes Rechteck definiert ist, das durch ein Koordinatenpaar, eine Höhen- und eine Breitenangabe angegeben ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawEllipse">
      <MemberSignature Language="C#" Value="public void DrawEllipse (System.Drawing.Pen pen, System.Drawing.Rectangle rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawEllipse(class System.Drawing.Pen pen, valuetype System.Drawing.Rectangle rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawEllipse(System.Drawing.Pen,System.Drawing.Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawEllipse(System::Drawing::Pen ^ pen, System::Drawing::Rectangle rect);" />
      <MemberSignature Language="F#" Value="member this.DrawEllipse : System.Drawing.Pen * System.Drawing.Rectangle -&gt; unit" Usage="graphics.DrawEllipse (pen, rect)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" />, der die Farbe, Breite und den Stil der Ellipse bestimmt.</param>
        <param name="rect"><see cref="T:System.Drawing.Rectangle" />-Struktur, die die Begrenzungen der Ellipse definiert.</param>
        <summary>Zeichnet eine Ellipse, die durch eine umschließende <see cref="T:System.Drawing.Rectangle" />-Struktur angegeben ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zeichnet eine Ellipse, die durch das umgebende Rechteck definiert ist, das durch `rect` den-Parameter angegeben wird.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen schwarzen Stift.  
  
-   Erstellt ein Rechteck, um eine Ellipse zu binden.  
  
-   Zeichnet die Ellipse auf dem Bildschirm.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#27](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#27)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#27](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#27)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#27](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#27)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawEllipse">
      <MemberSignature Language="C#" Value="public void DrawEllipse (System.Drawing.Pen pen, System.Drawing.RectangleF rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawEllipse(class System.Drawing.Pen pen, valuetype System.Drawing.RectangleF rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawEllipse(System.Drawing.Pen,System.Drawing.RectangleF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawEllipse(System::Drawing::Pen ^ pen, System::Drawing::RectangleF rect);" />
      <MemberSignature Language="F#" Value="member this.DrawEllipse : System.Drawing.Pen * System.Drawing.RectangleF -&gt; unit" Usage="graphics.DrawEllipse (pen, rect)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="rect" Type="System.Drawing.RectangleF" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" />, der die Farbe, Breite und den Stil der Ellipse bestimmt.</param>
        <param name="rect"><see cref="T:System.Drawing.RectangleF" />-Struktur, die die Begrenzungen der Ellipse definiert.</param>
        <summary>Zeichnet eine Ellipse, die durch ein umschließendes <see cref="T:System.Drawing.RectangleF" /> definiert ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zeichnet eine Ellipse, die durch das umgebende Rechteck definiert ist, das durch `rect` den-Parameter angegeben wird.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen schwarzen Stift.  
  
-   Erstellt ein Rechteck, um eine Ellipse zu binden.  
  
-   Zeichnet die Ellipse auf dem Bildschirm.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#28](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#28)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#28](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#28)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#28](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawEllipse">
      <MemberSignature Language="C#" Value="public void DrawEllipse (System.Drawing.Pen pen, int x, int y, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawEllipse(class System.Drawing.Pen pen, int32 x, int32 y, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawEllipse(System.Drawing.Pen,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawEllipse(System::Drawing::Pen ^ pen, int x, int y, int width, int height);" />
      <MemberSignature Language="F#" Value="member this.DrawEllipse : System.Drawing.Pen * int * int * int * int -&gt; unit" Usage="graphics.DrawEllipse (pen, x, y, width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" />, der die Farbe, Breite und den Stil der Ellipse bestimmt.</param>
        <param name="x">Die x-Koordinate der oberen linken Ecke des umschließenden Rechtecks, das die Ellipse definiert.</param>
        <param name="y">Die y-Koordinate der oberen linken Ecke des umschließenden Rechtecks, das die Ellipse definiert.</param>
        <param name="width">Breite des umschließenden Rechtecks, das die Ellipse definiert.</param>
        <param name="height">Höhe des umschließenden Rechtecks, das die Ellipse definiert.</param>
        <summary>Zeichnet eine Ellipse, die durch ein umschließendes Rechteck definiert ist, das durch Koordinaten für die obere linke Ecke des Rechtecks, eine Höhen- und eine Breitenangabe angegeben ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zeichnet eine Ellipse, die durch das Begrenzungs Rechteck definiert ist, das `x`durch `y`die `width`Parameter, `height` , und beschrieben wird.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen schwarzen Stift.  
  
-   Erstellt die Position und Größe eines Rechtecks, das eine Ellipse gebunden.  
  
-   Zeichnet die Ellipse auf dem Bildschirm.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#29](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#29)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#29](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#29)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#29](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#29)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawEllipse">
      <MemberSignature Language="C#" Value="public void DrawEllipse (System.Drawing.Pen pen, float x, float y, float width, float height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawEllipse(class System.Drawing.Pen pen, float32 x, float32 y, float32 width, float32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawEllipse(System.Drawing.Pen,System.Single,System.Single,System.Single,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawEllipse(System::Drawing::Pen ^ pen, float x, float y, float width, float height);" />
      <MemberSignature Language="F#" Value="member this.DrawEllipse : System.Drawing.Pen * single * single * single * single -&gt; unit" Usage="graphics.DrawEllipse (pen, x, y, width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="width" Type="System.Single" />
        <Parameter Name="height" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" />, der die Farbe, Breite und den Stil der Ellipse bestimmt.</param>
        <param name="x">Die x-Koordinate der oberen linken Ecke des umschließenden Rechtecks, das die Ellipse definiert.</param>
        <param name="y">Die y-Koordinate der oberen linken Ecke des umschließenden Rechtecks, das die Ellipse definiert.</param>
        <param name="width">Breite des umschließenden Rechtecks, das die Ellipse definiert.</param>
        <param name="height">Höhe des umschließenden Rechtecks, das die Ellipse definiert.</param>
        <summary>Zeichnet eine Ellipse, die durch ein umschließendes Rechteck definiert ist, das durch ein Koordinatenpaar, eine Höhen- und eine Breitenangabe angegeben ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zeichnet eine Ellipse, die durch das Begrenzungs Rechteck definiert ist, das `x`durch `y`die `width`Parameter, `height` , und beschrieben wird.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen schwarzen Stift.  
  
-   Erstellt die Position und Größe eines Rechtecks, das eine Ellipse gebunden.  
  
-   Zeichnet die Ellipse auf dem Bildschirm.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#30](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#30)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#30](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#30)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#30](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#30)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawIcon">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zeichnet das durch das angegebene <see cref="T:System.Drawing.Icon" /> dargestellte Bild an den angegebenen Koordinaten.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawIcon">
      <MemberSignature Language="C#" Value="public void DrawIcon (System.Drawing.Icon icon, System.Drawing.Rectangle targetRect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawIcon(class System.Drawing.Icon icon, valuetype System.Drawing.Rectangle targetRect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawIcon(System.Drawing.Icon,System.Drawing.Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawIcon(System::Drawing::Icon ^ icon, System::Drawing::Rectangle targetRect);" />
      <MemberSignature Language="F#" Value="member this.DrawIcon : System.Drawing.Icon * System.Drawing.Rectangle -&gt; unit" Usage="graphics.DrawIcon (icon, targetRect)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="icon" Type="System.Drawing.Icon" />
        <Parameter Name="targetRect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="icon">Der zu zeichnende <see cref="T:System.Drawing.Icon" />.</param>
        <param name="targetRect"><see cref="T:System.Drawing.Rectangle" />-Struktur, die die Größe und Position des resultierenden Bildes auf der Anzeigeoberfläche angibt. Das Bild im <paramref name="icon" />-Parameter wird auf die Abmessungen dieses rechteckigen Bereichs skaliert.</param>
        <summary>Zeichnet das durch das angegebene <see cref="T:System.Drawing.Icon" /> dargestellte Bild innerhalb des von einer <see cref="T:System.Drawing.Rectangle" />-Struktur angegebenen Bereichs.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein Symbol aus einer standardmäßigen Windows-Symbol Datei SampIcon. ico im Beispiel Ordner.  
  
-   Erstellt ein Rechteck, in dem das Symbol gezeichnet wird.  
  
-   Zeichnet das Symbol auf dem Bildschirm.  
  
 Die Position des Rechtecks ermittelt das Symbol auf dem Bildschirm, und die Größe des Rechtecks bestimmt die Skalierung des gezeichneten Symbols.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#31](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#31)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#31](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#31)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#31](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#31)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="icon" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawIcon">
      <MemberSignature Language="C#" Value="public void DrawIcon (System.Drawing.Icon icon, int x, int y);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawIcon(class System.Drawing.Icon icon, int32 x, int32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawIcon(System.Drawing.Icon,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawIcon(System::Drawing::Icon ^ icon, int x, int y);" />
      <MemberSignature Language="F#" Value="member this.DrawIcon : System.Drawing.Icon * int * int -&gt; unit" Usage="graphics.DrawIcon (icon, x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="icon" Type="System.Drawing.Icon" />
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="icon">Der zu zeichnende <see cref="T:System.Drawing.Icon" />.</param>
        <param name="x">Die x-Koordinate der oberen linken Ecke des gezeichneten Bilds.</param>
        <param name="y">Die y-Koordinate der oberen linken Ecke des gezeichneten Bilds.</param>
        <summary>Zeichnet das durch das angegebene <see cref="T:System.Drawing.Icon" /> dargestellte Bild an den angegebenen Koordinaten.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein Symbol aus einer standardmäßigen Windows-Symbol Datei SampIcon. ico im Beispiel Ordner.  
  
-   Erstellt die Koordinaten der oberen linken Ecke, an der das Symbol gezeichnet werden soll.  
  
-   Zeichnet das Symbol auf dem Bildschirm.  
  
 Das gezeichnete Symbol ist nicht skaliert.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#32](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#32)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#32](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#32)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#32](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="icon" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawIconUnstretched">
      <MemberSignature Language="C#" Value="public void DrawIconUnstretched (System.Drawing.Icon icon, System.Drawing.Rectangle targetRect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawIconUnstretched(class System.Drawing.Icon icon, valuetype System.Drawing.Rectangle targetRect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawIconUnstretched(System.Drawing.Icon,System.Drawing.Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawIconUnstretched(System::Drawing::Icon ^ icon, System::Drawing::Rectangle targetRect);" />
      <MemberSignature Language="F#" Value="member this.DrawIconUnstretched : System.Drawing.Icon * System.Drawing.Rectangle -&gt; unit" Usage="graphics.DrawIconUnstretched (icon, targetRect)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="icon" Type="System.Drawing.Icon" />
        <Parameter Name="targetRect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="icon">Der zu zeichnende <see cref="T:System.Drawing.Icon" />.</param>
        <param name="targetRect"><see cref="T:System.Drawing.Rectangle" />-Struktur, die die Position und Größe des resultierenden Bildes angibt. Das Bild wird nicht skaliert, um in dieses Rechteck zu passen, sondern behält seine ursprüngliche Größe bei. Wenn das Bild größer als das Rechteck ist, wird das Bild zum Anpassen abgeschnitten.</param>
        <summary>Zeichnet das durch das angegebene <see cref="T:System.Drawing.Icon" /> dargestellte Bild, ohne das Bild zu skalieren.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein Symbol aus einer standardmäßigen Windows-Symbol Datei SampIcon. ico im Beispiel Ordner.  
  
-   Erstellt ein Rechteck, in dem das Symbol gezeichnet wird.  
  
-   Zeichnet das Symbol auf dem Bildschirm.  
  
 Die Position des Rechtecks sucht das Symbol auf dem Bildschirm, und das gezeichnete Symbol wird nicht skaliert und nicht abgeschnitten.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#33](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#33)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#33](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#33)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#33](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#33)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="icon" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawImage">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zeichnet das angegebene <see cref="T:System.Drawing.Image" /> an der angegebenen Position und in der ursprünglichen Größe.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.Point point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.Point point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, System::Drawing::Point point);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.Point -&gt; unit" Usage="graphics.DrawImage (image, point)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="point" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="image">Der zu zeichnende <see cref="T:System.Drawing.Image" />.</param>
        <param name="point"><see cref="T:System.Drawing.Point" />-Struktur, die die Position der oberen linken Ecke des gezeichneten Bildes darstellt.</param>
        <summary>Zeichnet das angegebene <see cref="T:System.Drawing.Image" /> in seiner ursprünglichen physischen Größe an der angegebenen Position.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Drawing.Image> speichert einen Wert für die Pixel Breite und einen Wert für die horizontale Auflösung (Punkte pro Zoll). Die physische Breite eines Bilds, gemessen in Zoll, ist die Pixel Breite dividiert durch die horizontale Auflösung. Beispielsweise hat ein Bild mit einer Pixel Breite von 216 und eine horizontale Auflösung von 72 Punkten pro Zoll eine physische Breite von 3 Zoll. Ähnliche Hinweise gelten für die Pixel Höhe und die physische Höhe.  
  
 Mit dieser Methode wird ein Bild mit der physischen Größe gezeichnet, sodass das Bild unabhängig von der Auflösung (Punkte pro Zoll) des Anzeige Geräts in Zoll korrekt ist. Angenommen, ein Bild hat eine Pixel Breite von 216 und eine horizontale Auflösung von 72 Punkten pro Zoll. Wenn Sie diese Methode zum Zeichnen des Bilds auf einem Gerät mit einer Auflösung von 96 Punkten pro Zoll aufrufen, ist die Pixel Breite des gerenderten Bilds (216/72) * 96 = 288.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein Bild aus einer JPEG-Datei "SampImag. jpg" im Ordner des Beispiels.  
  
-   Erstellt einen Punkt, an dem die obere linke Ecke des Bilds gezeichnet werden soll.  
  
-   Zeichnet das nicht skalierte Bild auf dem Bildschirm.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#34](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#34)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#34](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#34)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#34](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#34)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> ist <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.Point[] destPoints);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.Point[] destPoints) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Point[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, cli::array &lt;System::Drawing::Point&gt; ^ destPoints);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.Point[] -&gt; unit" Usage="graphics.DrawImage (image, destPoints)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destPoints" Type="System.Drawing.Point[]" />
      </Parameters>
      <Docs>
        <param name="image">Der zu zeichnende <see cref="T:System.Drawing.Image" />.</param>
        <param name="destPoints">Array von drei <see cref="T:System.Drawing.Point" />-Strukturen, die ein Parallelogramm definieren.</param>
        <summary>Zeichnet das angegebene <see cref="T:System.Drawing.Image" /> an der angegebenen Position und in der angegebenen Form und Größe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `destPoints` -Parameter gibt drei Punkte eines Parallelogramms an. Die drei <xref:System.Drawing.Point> -Strukturen stellen die oberen linken, oberen rechten und unteren linken Ecke des parallelograms dar. Der vierte Punkt wird von den ersten drei extrapoliert, um ein Parallelogram zu bilden.  
  
 Das durch den `image` -Parameter dargestellte Bild wird skaliert und mit der Form des parallelograms, das von den `destPoints` Parametern angegeben wird, angepasst.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein Bild aus einer JPEG-Datei "SampImag. jpg" im Ordner des Beispiels.  
  
-   Erstellt Punkte, die ein Parallelogramm definieren, in dem das Bild gezeichnet werden soll.  
  
-   Zeichnet das Bild auf dem Bildschirm.  
  
 Die Position des parallelograms ermittelt das Bild auf dem Bildschirm, und die Größe des ursprünglichen Bilds und die Größe und Form des parallelograms bestimmen das Skalieren und das Erstellen des gezeichneten Bilds.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#35](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#35)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#35](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#35)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#35](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> ist <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.PointF point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.PointF point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.PointF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, System::Drawing::PointF point);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.PointF -&gt; unit" Usage="graphics.DrawImage (image, point)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="point" Type="System.Drawing.PointF" />
      </Parameters>
      <Docs>
        <param name="image">Der zu zeichnende <see cref="T:System.Drawing.Image" />.</param>
        <param name="point"><see cref="T:System.Drawing.PointF" />-Struktur, die die obere linke Ecke des gezeichneten Bildes darstellt.</param>
        <summary>Zeichnet das angegebene <see cref="T:System.Drawing.Image" /> in seiner ursprünglichen physischen Größe an der angegebenen Position.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Drawing.Image> speichert einen Wert für die Pixel Breite und einen Wert für die horizontale Auflösung (Punkte pro Zoll). Die physische Breite eines Bilds, gemessen in Zoll, ist die Pixel Breite dividiert durch die horizontale Auflösung. Beispielsweise hat ein Bild mit einer Pixel Breite von 216 und eine horizontale Auflösung von 72 Punkten pro Zoll eine physische Breite von 3 Zoll. Ähnliche Hinweise gelten für die Pixel Höhe und die physische Höhe.  
  
 Mit dieser Methode wird ein Bild mit der physischen Größe gezeichnet, sodass das Bild unabhängig von der Auflösung (Punkte pro Zoll) des Anzeige Geräts in Zoll korrekt ist. Angenommen, ein Bild hat eine Pixel Breite von 216 und eine horizontale Auflösung von 72 Punkten pro Zoll. Wenn Sie diese Methode zum Zeichnen des Bilds auf einem Gerät mit einer Auflösung von 96 Punkten pro Zoll aufrufen, ist die Pixel Breite des gerenderten Bilds (216/72) * 96 = 288.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein Bild aus einer JPEG-Datei "SampImag. jpg" im Ordner des Beispiels.  
  
-   Erstellt einen Punkt, an dem die obere linke Ecke des Bilds gezeichnet werden soll.  
  
-   Zeichnet das nicht skalierte Bild auf dem Bildschirm.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#40](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#40)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#40](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#40)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#40](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#40)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> ist <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.PointF[] destPoints);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.PointF[] destPoints) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.PointF[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, cli::array &lt;System::Drawing::PointF&gt; ^ destPoints);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.PointF[] -&gt; unit" Usage="graphics.DrawImage (image, destPoints)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destPoints" Type="System.Drawing.PointF[]" />
      </Parameters>
      <Docs>
        <param name="image">Der zu zeichnende <see cref="T:System.Drawing.Image" />.</param>
        <param name="destPoints">Array von drei <see cref="T:System.Drawing.PointF" />-Strukturen, die ein Parallelogramm definieren.</param>
        <summary>Zeichnet das angegebene <see cref="T:System.Drawing.Image" /> an der angegebenen Position und in der angegebenen Form und Größe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `destPoints` -Parameter gibt drei Punkte eines Parallelogramms an. Die drei <xref:System.Drawing.PointF> -Strukturen stellen die oberen linken, oberen rechten und unteren linken Ecke des parallelograms dar. Der vierte Punkt wird von den ersten drei extrapoliert, um ein Parallelogram zu bilden.  
  
 Das Bild, das durch `image` das-Objekt dargestellt wird, wird skaliert und an die Form des durch den `destPoints` -Parameter angegebenen parallelograms angepasst.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein Bild aus einer JPEG-Datei "SampImag. jpg" im Ordner des Beispiels.  
  
-   Erstellt Punkte, die ein Parallelogramm definieren, in dem das Bild gezeichnet werden soll.  
  
-   Zeichnet das Bild auf dem Bildschirm.  
  
 Die Position des parallelograms ermittelt das Bild auf dem Bildschirm, und die Größe des ursprünglichen Bilds und die Größe und Form des parallelograms bestimmen das Skalieren und das Erstellen des gezeichneten Bilds.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#41](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#41)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#41](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#41)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#41](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> ist <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.Rectangle rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.Rectangle rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, System::Drawing::Rectangle rect);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.Rectangle -&gt; unit" Usage="graphics.DrawImage (image, rect)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="image">Der zu zeichnende <see cref="T:System.Drawing.Image" />.</param>
        <param name="rect"><see cref="T:System.Drawing.Rectangle" />-Struktur, die die Position und Größe des gezeichneten Bildes angibt.</param>
        <summary>Zeichnet das angegebene <see cref="T:System.Drawing.Image" /> in der angegebenen Größe an der angegebenen Position.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Bild, das durch `image` das-Objekt dargestellt wird, wird auf `rect` die Abmessungen des Rechtecks skaliert.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein Bild aus einer JPEG-Datei "SampImag. jpg" im Ordner des Beispiels.  
  
-   Erstellt ein Rechteck, in dem das Bild gezeichnet werden soll.  
  
-   Zeichnet das Bild auf dem Bildschirm.  
  
 Die Position des Rechtecks ermittelt das Bild auf dem Bildschirm, und die Größe des ursprünglichen Bilds und die Größe des Rechtecks bestimmen die Skalierung des gezeichneten Bilds.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#46](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#46)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#46](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#46)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#46](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#46)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> ist <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.RectangleF rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.RectangleF rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.RectangleF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, System::Drawing::RectangleF rect);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.RectangleF -&gt; unit" Usage="graphics.DrawImage (image, rect)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="rect" Type="System.Drawing.RectangleF" />
      </Parameters>
      <Docs>
        <param name="image">Der zu zeichnende <see cref="T:System.Drawing.Image" />.</param>
        <param name="rect"><see cref="T:System.Drawing.RectangleF" />-Struktur, die die Position und Größe des gezeichneten Bildes angibt.</param>
        <summary>Zeichnet das angegebene <see cref="T:System.Drawing.Image" /> in der angegebenen Größe an der angegebenen Position.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Bild, das durch `image` das-Objekt dargestellt wird, wird auf `rect` die Abmessungen des Rechtecks skaliert.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein Bild aus einer JPEG-Datei "SampImag. jpg" im Ordner des Beispiels.  
  
-   Erstellt ein Rechteck, in dem das Bild gezeichnet werden soll.  
  
-   Zeichnet das Bild auf dem Bildschirm.  
  
 Die Position des Rechtecks ermittelt das Bild auf dem Bildschirm, und die ursprüngliche Größe des Bilds und die Größe des Rechtecks bestimmen die Skalierung des gezeichneten Bilds.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#56](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#56)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#56](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#56)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#56](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#56)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> ist <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, int x, int y);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, int32 x, int32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, int x, int y);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * int * int -&gt; unit" Usage="graphics.DrawImage (image, x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="image">Der zu zeichnende <see cref="T:System.Drawing.Image" />.</param>
        <param name="x">Die x-Koordinate der oberen linken Ecke des gezeichneten Bilds.</param>
        <param name="y">Die y-Koordinate der oberen linken Ecke des gezeichneten Bilds.</param>
        <summary>Zeichnet das angegebene Bild in seiner ursprünglichen physischen Größe an der von einem Koordinatenpaar angegebenen Position.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Drawing.Image> speichert einen Wert für die Pixel Breite und einen Wert für die horizontale Auflösung (Punkte pro Zoll). Die physische Breite eines Bilds, gemessen in Zoll, ist die Pixel Breite dividiert durch die horizontale Auflösung. Beispielsweise hat ein Bild mit einer Pixel Breite von 216 und eine horizontale Auflösung von 72 Punkten pro Zoll eine physische Breite von 3 Zoll. Ähnliche Hinweise gelten für die Pixel Höhe und die physische Höhe.  
  
 Mit <xref:System.Drawing.Graphics.DrawImage%2A> der-Methode wird ein Bild mit der physischen Größe gezeichnet, sodass das Bild unabhängig von der Auflösung (Punkte pro Zoll) des Anzeige Geräts in Zoll korrekt ist. Angenommen, ein Bild hat eine Pixel Breite von 216 und eine horizontale Auflösung von 72 Punkten pro Zoll. Wenn Sie aufrufen <xref:System.Drawing.Graphics.DrawImage%2A> , um dieses Bild auf einem Gerät mit einer Auflösung von 96 Punkten pro Zoll zu zeichnen, ist die Pixel Breite des gerenderten Bilds (216/72) * 96 = 288.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein Bild aus einer JPEG-Datei "SampImag. jpg" im Ordner des Beispiels "SampImag. jpg" im Ordner des Beispiels.  
  
-   Erstellt die Koordinaten eines Punkts, an dem die obere linke Ecke des Bilds gezeichnet werden soll.  
  
-   Zeichnet das nicht skalierte Bild.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#58](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#58)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#58](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#58)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#58](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> ist <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, float x, float y);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, float32 x, float32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Single,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, float x, float y);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * single * single -&gt; unit" Usage="graphics.DrawImage (image, x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="image">Der zu zeichnende <see cref="T:System.Drawing.Image" />.</param>
        <param name="x">Die x-Koordinate der oberen linken Ecke des gezeichneten Bilds.</param>
        <param name="y">Die y-Koordinate der oberen linken Ecke des gezeichneten Bilds.</param>
        <summary>Zeichnet das angegebene <see cref="T:System.Drawing.Image" /> in seiner ursprünglichen physischen Größe an der angegebenen Position.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Drawing.Image> speichert einen Wert für die Pixel Breite und einen Wert für die horizontale Auflösung (Punkte pro Zoll). Die physische Breite eines Bilds, gemessen in Zoll, ist die Pixel Breite dividiert durch die horizontale Auflösung. Beispielsweise hat ein Bild mit einer Pixel Breite von 216 und eine horizontale Auflösung von 72 Punkten pro Zoll eine physische Breite von 3 Zoll. Ähnliche Hinweise gelten für die Pixel Höhe und die physische Höhe.  
  
 Mit dieser Methode wird ein Bild mit der physischen Größe gezeichnet, sodass das Bild unabhängig von der Auflösung (Punkte pro Zoll) des Anzeige Geräts in Zoll korrekt ist. Angenommen, ein Bild hat eine Pixel Breite von 216 und eine horizontale Auflösung von 72 Punkten pro Zoll. Wenn Sie diese Methode zum Zeichnen des Bilds auf einem Gerät mit einer Auflösung von 96 Punkten pro Zoll aufrufen, ist die Pixel Breite des gerenderten Bilds (216/72) * 96 = 288.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein Bild aus einer JPEG-Datei "SampImag. jpg" im Ordner des Beispiels.  
  
-   Erstellt die Koordinaten eines Punkts, an dem die obere linke Ecke des Bilds gezeichnet werden soll.  
  
-   Zeichnet das nicht skalierte Bild auf dem Bildschirm.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#61](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#61)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#61](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#61)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#61](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#61)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> ist <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.Point[] destPoints, System.Drawing.Rectangle srcRect, System.Drawing.GraphicsUnit srcUnit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.Point[] destPoints, valuetype System.Drawing.Rectangle srcRect, valuetype System.Drawing.GraphicsUnit srcUnit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Point[],System.Drawing.Rectangle,System.Drawing.GraphicsUnit)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, cli::array &lt;System::Drawing::Point&gt; ^ destPoints, System::Drawing::Rectangle srcRect, System::Drawing::GraphicsUnit srcUnit);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.Point[] * System.Drawing.Rectangle * System.Drawing.GraphicsUnit -&gt; unit" Usage="graphics.DrawImage (image, destPoints, srcRect, srcUnit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destPoints" Type="System.Drawing.Point[]" />
        <Parameter Name="srcRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
      </Parameters>
      <Docs>
        <param name="image">Der zu zeichnende <see cref="T:System.Drawing.Image" />.</param>
        <param name="destPoints">Array von drei <see cref="T:System.Drawing.Point" />-Strukturen, die ein Parallelogramm definieren.</param>
        <param name="srcRect"><see cref="T:System.Drawing.Rectangle" />-Struktur, die den zu zeichnenden Teil des <paramref name="image" />-Objekts angibt.</param>
        <param name="srcUnit">Member der <see cref="T:System.Drawing.GraphicsUnit" />-Enumeration, der die Maßeinheiten für den <paramref name="srcRect" />-Parameter angibt.</param>
        <summary>Zeichnet den angegebenen Bereich vom angegebenen <see cref="T:System.Drawing.Image" /> in der angegebenen Größe an der angegebenen Position.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `destPoints` -Parameter gibt drei Punkte eines Parallelogramms an. Die drei <xref:System.Drawing.Point> -Strukturen stellen die oberen linken, oberen rechten und unteren linken Ecke des parallelograms dar. Der vierte Punkt wird von den ersten drei extrapoliert, um ein Parallelogram zu bilden.  
  
 Der `srcRect` -Parameter gibt einen rechteckigen Teil `image` des zu zeichnenden Objekts an. Dieser Teil wird so skaliert, dass er in das durch den `destPoints` -Parameter angegebene Parallelogramm passt.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein Bild aus einer JPEG-Datei "SampImag. jpg" im Ordner des Beispiels.  
  
-   Erstellt Punkte, die ein Parallelogramm definieren, in dem das Bild gezeichnet werden soll.  
  
-   Erstellt ein Rechteck, um den zu zeichnenden Teil des Bilds auszuwählen.  
  
-   Legt die Grafik Zeichnungs Einheit auf Pixel fest.  
  
-   Zeichnet das Bild auf dem Bildschirm.  
  
 Die Position des parallelograms ermittelt das Bild auf dem Bildschirm, und die Größe des Rechtecks und die Größe und Form des parallelograms bestimmen das Skalieren und das Scheren des gezeichneten Bilds.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#36](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#36)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#36](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#36)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#36](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#36)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> ist <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.PointF[] destPoints, System.Drawing.RectangleF srcRect, System.Drawing.GraphicsUnit srcUnit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.PointF[] destPoints, valuetype System.Drawing.RectangleF srcRect, valuetype System.Drawing.GraphicsUnit srcUnit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.PointF[],System.Drawing.RectangleF,System.Drawing.GraphicsUnit)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, cli::array &lt;System::Drawing::PointF&gt; ^ destPoints, System::Drawing::RectangleF srcRect, System::Drawing::GraphicsUnit srcUnit);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.PointF[] * System.Drawing.RectangleF * System.Drawing.GraphicsUnit -&gt; unit" Usage="graphics.DrawImage (image, destPoints, srcRect, srcUnit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destPoints" Type="System.Drawing.PointF[]" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
      </Parameters>
      <Docs>
        <param name="image">Der zu zeichnende <see cref="T:System.Drawing.Image" />.</param>
        <param name="destPoints">Array von drei <see cref="T:System.Drawing.PointF" />-Strukturen, die ein Parallelogramm definieren.</param>
        <param name="srcRect"><see cref="T:System.Drawing.RectangleF" />-Struktur, die den zu zeichnenden Teil des <paramref name="image" />-Objekts angibt.</param>
        <param name="srcUnit">Member der <see cref="T:System.Drawing.GraphicsUnit" />-Enumeration, der die Maßeinheiten für den <paramref name="srcRect" />-Parameter angibt.</param>
        <summary>Zeichnet den angegebenen Bereich vom angegebenen <see cref="T:System.Drawing.Image" /> in der angegebenen Größe an der angegebenen Position.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `destPoints` -Parameter gibt drei Punkte eines Parallelogramms an. Die drei <xref:System.Drawing.PointF> -Strukturen stellen die oberen linken, oberen rechten und unteren linken Ecke des parallelograms dar. Der vierte Punkt wird von den ersten drei extrapoliert, um ein Parallelogram zu bilden.  
  
 Der `srcRect` -Parameter gibt einen rechteckigen Teil `image` des zu zeichnenden Objekts an. Dieser Teil wird so skaliert, dass er in das durch den `destPoints` -Parameter angegebene Parallelogramm passt.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein Bild aus einer JPEG-Datei "SampImag. jpg" im Ordner des Beispiels.  
  
-   Erstellt Punkte, die ein paralleles Ziel Gram definieren, in das das Bild gezeichnet werden soll.  
  
-   Erstellt ein Quell Rechteck, aus dem ein Teil des Bilds extrahiert werden soll.  
  
-   Legt die Maßeinheit des Quell Rechtecks auf Pixel fest.  
  
-   Zeichnet das Bild auf dem Bildschirm.  
  
 Die Position des Ziel parallelograms ermittelt das Bild auf dem Bildschirm, die Größe des Quell Rechtecks und die Größe und Form des Ziel-parallelograms die Skalierung und das Scheren des gezeichneten Bilds, und die Größe des Rechtecks bestimmt. der Teil des ursprünglichen Bilds, der auf dem Bildschirm gezeichnet wird.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#42](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#42)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#42](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#42)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#42](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> ist <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.Rectangle destRect, System.Drawing.Rectangle srcRect, System.Drawing.GraphicsUnit srcUnit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.Rectangle destRect, valuetype System.Drawing.Rectangle srcRect, valuetype System.Drawing.GraphicsUnit srcUnit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Rectangle,System.Drawing.Rectangle,System.Drawing.GraphicsUnit)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, System::Drawing::Rectangle destRect, System::Drawing::Rectangle srcRect, System::Drawing::GraphicsUnit srcUnit);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.Rectangle * System.Drawing.Rectangle * System.Drawing.GraphicsUnit -&gt; unit" Usage="graphics.DrawImage (image, destRect, srcRect, srcUnit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
      </Parameters>
      <Docs>
        <param name="image">Der zu zeichnende <see cref="T:System.Drawing.Image" />.</param>
        <param name="destRect"><see cref="T:System.Drawing.Rectangle" />-Struktur, die die Position und Größe des gezeichneten Bildes angibt. Das Bild wird skaliert, sodass es in das Rechteck passt.</param>
        <param name="srcRect"><see cref="T:System.Drawing.Rectangle" />-Struktur, die den zu zeichnenden Teil des <paramref name="image" />-Objekts angibt.</param>
        <param name="srcUnit">Member der <see cref="T:System.Drawing.GraphicsUnit" />-Enumeration, der die Maßeinheiten für den <paramref name="srcRect" />-Parameter angibt.</param>
        <summary>Zeichnet den angegebenen Bereich vom angegebenen <see cref="T:System.Drawing.Image" /> in der angegebenen Größe an der angegebenen Position.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `srcRect` -Parameter gibt einen rechteckigen Teil `image` des zu zeichnenden Objekts an. Dieser Teil wird so skaliert, dass er in das durch `destRect` den-Parameter angegebene Rechteck passt.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein Bild aus einer JPEG-Datei "SampImag. jpg" im Ordner des Beispiels.  
  
-   Erstellt ein Ziel Rechteck, in dem das Bild gezeichnet werden soll.  
  
-   Erstellt ein Quell Rechteck, aus dem ein Teil des Bilds extrahiert werden soll.  
  
-   Legt die Maßeinheit des Quell Rechtecks auf Pixel fest.  
  
-   Zeichnet das Bild auf dem Bildschirm.  
  
 Die Position des Ziel Rechtecks sucht das Bild auf dem Bildschirm, die Größe der Quell-und Ziel Rechtecke bestimmt die Skalierung des gezeichneten Bilds, und die Größe des Quell Rechtecks bestimmt, welcher Teil des ursprünglichen Bilds zum Schirmen.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#47](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#47)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#47](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#47)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#47](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#47)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> ist <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.RectangleF destRect, System.Drawing.RectangleF srcRect, System.Drawing.GraphicsUnit srcUnit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.RectangleF destRect, valuetype System.Drawing.RectangleF srcRect, valuetype System.Drawing.GraphicsUnit srcUnit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.RectangleF,System.Drawing.RectangleF,System.Drawing.GraphicsUnit)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, System::Drawing::RectangleF destRect, System::Drawing::RectangleF srcRect, System::Drawing::GraphicsUnit srcUnit);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.RectangleF * System.Drawing.RectangleF * System.Drawing.GraphicsUnit -&gt; unit" Usage="graphics.DrawImage (image, destRect, srcRect, srcUnit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
      </Parameters>
      <Docs>
        <param name="image">Der zu zeichnende <see cref="T:System.Drawing.Image" />.</param>
        <param name="destRect"><see cref="T:System.Drawing.RectangleF" />-Struktur, die die Position und Größe des gezeichneten Bildes angibt. Das Bild wird skaliert, sodass es in das Rechteck passt.</param>
        <param name="srcRect"><see cref="T:System.Drawing.RectangleF" />-Struktur, die den zu zeichnenden Teil des <paramref name="image" />-Objekts angibt.</param>
        <param name="srcUnit">Member der <see cref="T:System.Drawing.GraphicsUnit" />-Enumeration, der die Maßeinheiten für den <paramref name="srcRect" />-Parameter angibt.</param>
        <summary>Zeichnet den angegebenen Bereich vom angegebenen <see cref="T:System.Drawing.Image" /> in der angegebenen Größe an der angegebenen Position.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `srcRect` -Parameter gibt einen rechteckigen Teil `image` des zu zeichnenden Objekts an. Dieser Teil wird so skaliert, dass er in das durch `destRect` den-Parameter angegebene Rechteck passt.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein Bild aus einer JPEG-Datei "SampImag. jpg" im Ordner des Beispiels.  
  
-   Erstellt ein Ziel Rechteck, in dem das Bild gezeichnet werden soll.  
  
-   Erstellt ein Quell Rechteck, aus dem ein Teil des Bilds extrahiert werden soll.  
  
-   Legt die Maßeinheit des Quell Rechtecks auf Pixel fest.  
  
-   Zeichnet das Bild auf dem Bildschirm.  
  
 Die Position des Ziel Rechtecks sucht das Bild auf dem Bildschirm, die Größe der Quell-und Ziel Rechtecke bestimmt die Skalierung des gezeichneten Bilds, und die Größe des Quell Rechtecks bestimmt, welcher Teil des ursprünglichen Bilds zum Schirmen.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#57](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#57)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#57](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#57)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#57](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#57)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> ist <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.Point[] destPoints, System.Drawing.Rectangle srcRect, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Imaging.ImageAttributes imageAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.Point[] destPoints, valuetype System.Drawing.Rectangle srcRect, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Imaging.ImageAttributes imageAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Point[],System.Drawing.Rectangle,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, cli::array &lt;System::Drawing::Point&gt; ^ destPoints, System::Drawing::Rectangle srcRect, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Imaging::ImageAttributes ^ imageAttr);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.Point[] * System.Drawing.Rectangle * System.Drawing.GraphicsUnit * System.Drawing.Imaging.ImageAttributes -&gt; unit" Usage="graphics.DrawImage (image, destPoints, srcRect, srcUnit, imageAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destPoints" Type="System.Drawing.Point[]" />
        <Parameter Name="srcRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
      </Parameters>
      <Docs>
        <param name="image">Der zu zeichnende <see cref="T:System.Drawing.Image" />.</param>
        <param name="destPoints">Array von drei <see cref="T:System.Drawing.Point" />-Strukturen, die ein Parallelogramm definieren.</param>
        <param name="srcRect"><see cref="T:System.Drawing.Rectangle" />-Struktur, die den zu zeichnenden Teil des <paramref name="image" />-Objekts angibt.</param>
        <param name="srcUnit">Member der <see cref="T:System.Drawing.GraphicsUnit" />-Enumeration, der die Maßeinheiten für den <paramref name="srcRect" />-Parameter angibt.</param>
        <param name="imageAttr"><see cref="T:System.Drawing.Imaging.ImageAttributes" />, das Informationen über erneutes Einfärben und Gammainformationen für das <paramref name="image" />-Objekt angibt.</param>
        <summary>Zeichnet den angegebenen Teil vom angegebenen <see cref="T:System.Drawing.Image" /> an der angegebenen Position.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `destPoints` -Parameter gibt drei Punkte eines Parallelogramms an. Die drei <xref:System.Drawing.Point> -Strukturen stellen die oberen linken, oberen rechten und unteren linken Ecke des parallelograms dar. Der vierte Punkt wird von den ersten drei extrapoliert, um ein Parallelogram zu bilden.  
  
 Der `srcRect` -Parameter gibt einen rechteckigen Teil`image` des zu zeichnenden Objekts an. Dieser Teil wird so skaliert, dass er in das durch den `destPoints` -Parameter angegebene Parallelogramm passt.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein Bild aus einer JPEG-Datei "SampImag. jpg" im Ordner des Beispiels.  
  
-   Erstellt Punkte, die ein Parallelogramm definieren, in dem das Bild gezeichnet werden soll.  
  
-   Erstellt ein Rechteck, um den zu zeichnenden Teil des Bilds auszuwählen.  
  
-   Legt die Grafik Zeichnungs Einheit auf Pixel fest.  
  
-   Zeichnet das ursprüngliche Bild auf dem Bildschirm.  
  
-   Erstellt ein zusätzliches Parallelogramm, in dem ein angepasstes Bild gezeichnet werden soll.  
  
-   Erstellt und legt die Attribute des angepassten Bilds so fest, dass Sie über einen größeren, nicht üblichen Gamma Wert verfügen.  
  
-   Zeichnet das angepasste Bild auf dem Bildschirm.  
  
 Für das ursprüngliche, nicht angepasste Parallelogramm sucht die Position das Bild auf dem Bildschirm, und die Größe des Rechtecks und die Größe und Form des parallelograms bestimmen die Skalierung und das Scheren des gezeichneten Bilds.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#37](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#37)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#37](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#37)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#37](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#37)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> ist <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.PointF[] destPoints, System.Drawing.RectangleF srcRect, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Imaging.ImageAttributes imageAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.PointF[] destPoints, valuetype System.Drawing.RectangleF srcRect, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Imaging.ImageAttributes imageAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.PointF[],System.Drawing.RectangleF,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, cli::array &lt;System::Drawing::PointF&gt; ^ destPoints, System::Drawing::RectangleF srcRect, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Imaging::ImageAttributes ^ imageAttr);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.PointF[] * System.Drawing.RectangleF * System.Drawing.GraphicsUnit * System.Drawing.Imaging.ImageAttributes -&gt; unit" Usage="graphics.DrawImage (image, destPoints, srcRect, srcUnit, imageAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destPoints" Type="System.Drawing.PointF[]" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
      </Parameters>
      <Docs>
        <param name="image">Der zu zeichnende <see cref="T:System.Drawing.Image" />.</param>
        <param name="destPoints">Array von drei <see cref="T:System.Drawing.PointF" />-Strukturen, die ein Parallelogramm definieren.</param>
        <param name="srcRect"><see cref="T:System.Drawing.RectangleF" />-Struktur, die den zu zeichnenden Teil des <paramref name="image" />-Objekts angibt.</param>
        <param name="srcUnit">Member der <see cref="T:System.Drawing.GraphicsUnit" />-Enumeration, der die Maßeinheiten für den <paramref name="srcRect" />-Parameter angibt.</param>
        <param name="imageAttr"><see cref="T:System.Drawing.Imaging.ImageAttributes" />, das Informationen über erneutes Einfärben und Gammainformationen für das <paramref name="image" />-Objekt angibt.</param>
        <summary>Zeichnet den angegebenen Bereich vom angegebenen <see cref="T:System.Drawing.Image" /> in der angegebenen Größe an der angegebenen Position.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `destPoints` -Parameter gibt drei Punkte eines Parallelogramms an. Die drei <xref:System.Drawing.PointF> -Strukturen stellen die oberen linken, oberen rechten und unteren linken Ecke des parallelograms dar. Der vierte Punkt wird von den ersten drei extrapoliert, um ein Parallelogram zu bilden.  
  
 Der `srcRect` -Parameter gibt einen rechteckigen Teil `image` des zu zeichnenden Objekts an. Dieser Teil wird so skaliert, dass er in das durch den `destPoints` -Parameter angegebene Parallelogramm passt.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein Bild aus einer JPEG-Datei "SampImag. jpg" im Ordner des Beispiels.  
  
-   Erstellt Punkte, die ein paralleles Ziel Gram definieren, in das das Bild gezeichnet werden soll.  
  
-   Erstellt ein Quell Rechteck, aus dem ein Teil des Bilds extrahiert werden soll.  
  
-   Legt die Maßeinheit des Quell Rechtecks auf Pixel fest.  
  
-   Zeichnet das ursprüngliche Bild auf dem Bildschirm.  
  
-   Erstellt ein zusätzliches Parallelogramm, in dem ein angepasstes Bild gezeichnet werden soll.  
  
-   Erstellt und legt die Attribute des angepassten Bilds so fest, dass Sie über einen größeren, nicht üblichen Gamma Wert verfügen.  
  
-   Zeichnet das angepasste Bild auf dem Bildschirm.  
  
 Für das ursprüngliche, nicht angepasste Ziel Parallelogramm sucht die Position das Bild auf dem Bildschirm, die Größe des Quell Rechtecks und die Größe und Form des Ziel parallelograms die Skalierung und das Scheren des gezeichneten Bilds sowie die Größe des das Rechteck bestimmt, welcher Teil des ursprünglichen Bilds auf den Bildschirm gezeichnet wird.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#43](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#43)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#43](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#43)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#43](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#43)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> ist <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, int x, int y, System.Drawing.Rectangle srcRect, System.Drawing.GraphicsUnit srcUnit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, int32 x, int32 y, valuetype System.Drawing.Rectangle srcRect, valuetype System.Drawing.GraphicsUnit srcUnit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Int32,System.Int32,System.Drawing.Rectangle,System.Drawing.GraphicsUnit)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, int x, int y, System::Drawing::Rectangle srcRect, System::Drawing::GraphicsUnit srcUnit);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * int * int * System.Drawing.Rectangle * System.Drawing.GraphicsUnit -&gt; unit" Usage="graphics.DrawImage (image, x, y, srcRect, srcUnit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="srcRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
      </Parameters>
      <Docs>
        <param name="image">Der zu zeichnende <see cref="T:System.Drawing.Image" />.</param>
        <param name="x">Die x-Koordinate der oberen linken Ecke des gezeichneten Bilds.</param>
        <param name="y">Die y-Koordinate der oberen linken Ecke des gezeichneten Bilds.</param>
        <param name="srcRect"><see cref="T:System.Drawing.Rectangle" />-Struktur, die den zu zeichnenden Teil des <paramref name="image" />-Objekts angibt.</param>
        <param name="srcUnit">Member der <see cref="T:System.Drawing.GraphicsUnit" />-Enumeration, der die Maßeinheiten für den <paramref name="srcRect" />-Parameter angibt.</param>
        <summary>Zeichnet einen Teil eines Bildes an einer angegebenen Position.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Drawing.Image> speichert einen Wert für die Pixel Breite und einen Wert für die horizontale Auflösung (Punkte pro Zoll). Die physische Breite eines Bilds, gemessen in Zoll, ist die Pixel Breite dividiert durch die horizontale Auflösung. Beispielsweise hat ein Bild mit einer Pixel Breite von 360 und eine horizontale Auflösung von 72 Punkten pro Zoll eine physische Breite von 5 Zoll. Ähnliche Hinweise gelten für die Pixel Höhe und die physische Höhe.  
  
 Mit dieser Methode wird ein Teil eines Bilds unter Verwendung der physischen Größe gezeichnet, sodass der Bildteil unabhängig von der Auflösung (Punkte pro Zoll) des Anzeige Geräts in Zoll korrekt ist. Angenommen, ein bildreil hat eine Pixel Breite von 216 und eine horizontale Auflösung von 72 Punkten pro Zoll. Wenn Sie diese Methode zum Zeichnen dieses Bild Teils auf einem Gerät mit einer Auflösung von 96 Punkten pro Zoll aufrufen, ist die Pixel Breite des gerenderten Bilds (216/72) * 96 = 288.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein Bild aus einer JPEG-Datei "SampImag. jpg" im Ordner des Beispiels.  
  
-   Erstellt die Koordinaten, an denen die linke obere Ecke des Bilds gezeichnet werden soll.  
  
-   Erstellt ein Quell Rechteck, aus dem ein Teil des Bilds extrahiert werden soll.  
  
-   Legt die Maßeinheit des Quell Rechtecks auf Pixel fest.  
  
-   Zeichnet das Bild auf dem Bildschirm.  
  
 Die Größe des Quell Rechtecks bestimmt, welcher Teil des nicht skalierten ursprünglichen Bilds auf den Bildschirm gezeichnet wird.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#59](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#59)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#59](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#59)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#59](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#59)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> ist <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, int x, int y, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, int32 x, int32 y, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, int x, int y, int width, int height);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * int * int * int * int -&gt; unit" Usage="graphics.DrawImage (image, x, y, width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="image">Der zu zeichnende <see cref="T:System.Drawing.Image" />.</param>
        <param name="x">Die x-Koordinate der oberen linken Ecke des gezeichneten Bilds.</param>
        <param name="y">Die y-Koordinate der oberen linken Ecke des gezeichneten Bilds.</param>
        <param name="width">Breite des gezeichneten Bilds.</param>
        <param name="height">Höhe des gezeichneten Bilds.</param>
        <summary>Zeichnet das angegebene <see cref="T:System.Drawing.Image" /> in der angegebenen Größe an der angegebenen Position.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das durch die `x`Parameter, `y`, `width`und `height` definierte Rechteck bestimmt die Position und Größe des gezeichneten Bilds.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein Bild aus einer JPEG-Datei "SampImag. jpg" im Ordner des Beispiels.  
  
-   Erstellt die Position und Größe eines Rechtecks, in dem das Bild gezeichnet werden soll.  
  
-   Zeichnet das Bild auf dem Bildschirm.  
  
 Die Position des Rechtecks ermittelt das Bild auf dem Bildschirm, und die Größe des ursprünglichen Bilds und die Größe des Rechtecks bestimmen die Skalierung des gezeichneten Bilds.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#60](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#60)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#60](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#60)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#60](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#60)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> ist <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, float x, float y, System.Drawing.RectangleF srcRect, System.Drawing.GraphicsUnit srcUnit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, float32 x, float32 y, valuetype System.Drawing.RectangleF srcRect, valuetype System.Drawing.GraphicsUnit srcUnit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Single,System.Single,System.Drawing.RectangleF,System.Drawing.GraphicsUnit)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, float x, float y, System::Drawing::RectangleF srcRect, System::Drawing::GraphicsUnit srcUnit);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * single * single * System.Drawing.RectangleF * System.Drawing.GraphicsUnit -&gt; unit" Usage="graphics.DrawImage (image, x, y, srcRect, srcUnit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
      </Parameters>
      <Docs>
        <param name="image">Der zu zeichnende <see cref="T:System.Drawing.Image" />.</param>
        <param name="x">Die x-Koordinate der oberen linken Ecke des gezeichneten Bilds.</param>
        <param name="y">Die y-Koordinate der oberen linken Ecke des gezeichneten Bilds.</param>
        <param name="srcRect"><see cref="T:System.Drawing.RectangleF" />-Struktur, die den zu zeichnenden Teil vom <see cref="T:System.Drawing.Image" /> angibt.</param>
        <param name="srcUnit">Member der <see cref="T:System.Drawing.GraphicsUnit" />-Enumeration, der die Maßeinheiten für den <paramref name="srcRect" />-Parameter angibt.</param>
        <summary>Zeichnet einen Teil eines Bildes an einer angegebenen Position.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Drawing.Image> speichert einen Wert für die Pixel Breite und einen Wert für die horizontale Auflösung (Punkte pro Zoll). Die physische Breite eines Bilds, gemessen in Zoll, ist die Pixel Breite dividiert durch die horizontale Auflösung. Beispielsweise hat ein Bild mit einer Pixel Breite von 360 und eine horizontale Auflösung von 72 Punkten pro Zoll eine physische Breite von 5 Zoll. Ähnliche Hinweise gelten für die Pixel Höhe und die physische Höhe.  
  
 Mit dieser Methode wird ein Teil eines Bilds unter Verwendung der physischen Größe gezeichnet, sodass der Bildteil unabhängig von der Auflösung (Punkte pro Zoll) des Anzeige Geräts in Zoll korrekt ist. Angenommen, ein bildreil hat eine Pixel Breite von 216 und eine horizontale Auflösung von 72 Punkten pro Zoll. Wenn Sie diese Methode zum Zeichnen dieses Bild Teils auf einem Gerät mit einer Auflösung von 96 Punkten pro Zoll aufrufen, ist die Pixel Breite des gerenderten Bilds (216/72) * 96 = 288.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein Bild aus einer JPEG-Datei "SampImag. jpg" im Ordner des Beispiels.  
  
-   Erstellt die Koordinaten, an denen die linke obere Ecke des Bilds gezeichnet werden soll.  
  
-   Erstellt ein Quell Rechteck, aus dem ein Teil des Bilds extrahiert werden soll.  
  
-   Legt die Maßeinheit des Quell Rechtecks auf Pixel fest.  
  
-   Zeichnet das Bild auf dem Bildschirm.  
  
 Die Größe des Quell Rechtecks bestimmt, welcher Teil des nicht skalierten ursprünglichen Bilds auf den Bildschirm gezeichnet wird.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#62](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#62)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#62](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#62)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#62](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#62)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> ist <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, float x, float y, float width, float height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, float32 x, float32 y, float32 width, float32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Single,System.Single,System.Single,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, float x, float y, float width, float height);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * single * single * single * single -&gt; unit" Usage="graphics.DrawImage (image, x, y, width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="width" Type="System.Single" />
        <Parameter Name="height" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="image">Der zu zeichnende <see cref="T:System.Drawing.Image" />.</param>
        <param name="x">Die x-Koordinate der oberen linken Ecke des gezeichneten Bilds.</param>
        <param name="y">Die y-Koordinate der oberen linken Ecke des gezeichneten Bilds.</param>
        <param name="width">Breite des gezeichneten Bilds.</param>
        <param name="height">Höhe des gezeichneten Bilds.</param>
        <summary>Zeichnet das angegebene <see cref="T:System.Drawing.Image" /> in der angegebenen Größe an der angegebenen Position.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das durch die `x`Parameter, `y`, `width`und `height` definierte Rechteck bestimmt die Position und Größe des gezeichneten Bilds.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein Bild aus einer JPEG-Datei "SampImag. jpg" im Ordner des Beispiels.  
  
-   Erstellt die Position und Größe eines Rechtecks, in dem das Bild gezeichnet werden soll.  
  
-   Zeichnet das Bild auf dem Bildschirm.  
  
 Die Position des Rechtecks ermittelt das Bild auf dem Bildschirm, und die Größe des ursprünglichen Bilds und die Größe des Rechtecks bestimmen die Skalierung des gezeichneten Bilds.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#63](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#63)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#63](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#63)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#63](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#63)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> ist <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.Point[] destPoints, System.Drawing.Rectangle srcRect, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Imaging.ImageAttributes imageAttr, System.Drawing.Graphics.DrawImageAbort callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.Point[] destPoints, valuetype System.Drawing.Rectangle srcRect, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Imaging.ImageAttributes imageAttr, class System.Drawing.Graphics/DrawImageAbort callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Point[],System.Drawing.Rectangle,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, cli::array &lt;System::Drawing::Point&gt; ^ destPoints, System::Drawing::Rectangle srcRect, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Imaging::ImageAttributes ^ imageAttr, System::Drawing::Graphics::DrawImageAbort ^ callback);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.Point[] * System.Drawing.Rectangle * System.Drawing.GraphicsUnit * System.Drawing.Imaging.ImageAttributes * System.Drawing.Graphics.DrawImageAbort -&gt; unit" Usage="graphics.DrawImage (image, destPoints, srcRect, srcUnit, imageAttr, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destPoints" Type="System.Drawing.Point[]" />
        <Parameter Name="srcRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+DrawImageAbort" />
      </Parameters>
      <Docs>
        <param name="image">Der zu zeichnende <see cref="T:System.Drawing.Image" />.</param>
        <param name="destPoints">Array von drei <see cref="T:System.Drawing.PointF" />-Strukturen, die ein Parallelogramm definieren.</param>
        <param name="srcRect"><see cref="T:System.Drawing.Rectangle" />-Struktur, die den zu zeichnenden Teil des <paramref name="image" />-Objekts angibt.</param>
        <param name="srcUnit">Member der <see cref="T:System.Drawing.GraphicsUnit" />-Enumeration, der die Maßeinheiten für den <paramref name="srcRect" />-Parameter angibt.</param>
        <param name="imageAttr"><see cref="T:System.Drawing.Imaging.ImageAttributes" />, das Informationen über erneutes Einfärben und Gammainformationen für das <paramref name="image" />-Objekt angibt.</param>
        <param name="callback"><see cref="T:System.Drawing.Graphics.DrawImageAbort" />-Delegat, der eine Methode angibt, die während des Zeichnens des Bildes aufgerufen werden soll. Diese Methode wird häufig aufgerufen, um zu prüfen, ob die Ausführung der <see cref="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Point[],System.Drawing.Rectangle,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort)" />-Methode gemäß den durch die Anwendung bestimmten Kriterien abgebrochen werden soll.</param>
        <summary>Zeichnet den angegebenen Bereich vom angegebenen <see cref="T:System.Drawing.Image" /> in der angegebenen Größe an der angegebenen Position.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `destPoints` -Parameter gibt drei Punkte eines Parallelogramms an. Die drei <xref:System.Drawing.PointF> -Strukturen stellen die oberen linken, oberen rechten und unteren linken Ecke des parallelograms dar. Der vierte Punkt wird von den ersten drei extrapoliert, um ein Parallelogram zu bilden.  
  
 Der `srcRect` -Parameter gibt einen rechteckigen Teil `image` des zu zeichnenden Objekts an. Dieser Teil wird so skaliert, dass er in das durch den `destPoints` -Parameter angegebene Parallelogramm passt.  
  
 Diese Überladung mit `callback` dem-Parameter bietet die Möglichkeit, die Zeichnung eines Bilds zu beenden, sobald es gemäß den von der Anwendung festgelegten Kriterien gestartet wird. Beispielsweise könnte eine Anwendung mit dem Zeichnen eines großen Bilds beginnen, und der Benutzer kann den Bildlauf des Bilds durchführen. in diesem Fall kann die Anwendung die Zeichnung beenden.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code definiert zuerst eine Rückruf Methode für den <xref:System.Drawing.Graphics.DrawImageAbort> Delegaten; die Definition ist simpel und testet lediglich, ob die <xref:System.Drawing.Graphics.DrawImage%2A> Methode Sie mit einem NULL `callBackData` -Parameter aufruft. Der Hauptteil des Beispiels führt die folgenden Aktionen aus:  
  
-   Erstellt eine Instanz der <xref:System.Drawing.Graphics.DrawImageAbort> Rückruf Methode:  
  
-   Erstellt ein Bild aus einer JPEG-Datei "SampImag. jpg" im Ordner des Beispiels.  
  
-   Erstellt Punkte, die ein Parallelogramm definieren, in dem das Bild gezeichnet werden soll.  
  
-   Erstellt ein Rechteck, um den zu zeichnenden Teil des Bilds auszuwählen.  
  
-   Legt die Grafik Zeichnungs Einheit auf Pixel fest.  
  
-   Zeichnet das ursprüngliche Bild auf dem Bildschirm.  
  
-   Erstellt ein zusätzliches Parallelogramm, in dem ein angepasstes Bild gezeichnet werden soll.  
  
-   Erstellt und legt die Attribute des angepassten Bilds so fest, dass Sie über einen größeren, nicht üblichen Gamma Wert verfügen.  
  
-   Zeichnet das angepasste Bild auf dem Bildschirm.  
  
 Für das ursprüngliche, nicht angepasste Parallelogramm sucht die Position das Bild auf dem Bildschirm, und die Größe des Rechtecks und die Größe und Form des parallelograms bestimmen die Skalierung und das Scheren des gezeichneten Bilds.  
  
 Da in diesem Beispiel eine Überladung verwendet wird, die `callBackData` keinen-Parameter <xref:System.Drawing.Graphics.DrawImageAbort> übergibt, `true`gibt der Rückruf zurück <xref:System.Drawing.Graphics.DrawImage%2A> , wodurch die-Methode beendet wird. der Ausnahme Behandlungs Code, der im Beispiel enthalten ist, druckt den Ausnahme Text, anstatt das Bild zu zeichnen.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#38](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#38)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#38](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#38)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#38](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#38)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> ist <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.PointF[] destPoints, System.Drawing.RectangleF srcRect, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Imaging.ImageAttributes imageAttr, System.Drawing.Graphics.DrawImageAbort callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.PointF[] destPoints, valuetype System.Drawing.RectangleF srcRect, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Imaging.ImageAttributes imageAttr, class System.Drawing.Graphics/DrawImageAbort callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.PointF[],System.Drawing.RectangleF,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, cli::array &lt;System::Drawing::PointF&gt; ^ destPoints, System::Drawing::RectangleF srcRect, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Imaging::ImageAttributes ^ imageAttr, System::Drawing::Graphics::DrawImageAbort ^ callback);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.PointF[] * System.Drawing.RectangleF * System.Drawing.GraphicsUnit * System.Drawing.Imaging.ImageAttributes * System.Drawing.Graphics.DrawImageAbort -&gt; unit" Usage="graphics.DrawImage (image, destPoints, srcRect, srcUnit, imageAttr, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destPoints" Type="System.Drawing.PointF[]" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+DrawImageAbort" />
      </Parameters>
      <Docs>
        <param name="image">Der zu zeichnende <see cref="T:System.Drawing.Image" />.</param>
        <param name="destPoints">Array von drei <see cref="T:System.Drawing.PointF" />-Strukturen, die ein Parallelogramm definieren.</param>
        <param name="srcRect"><see cref="T:System.Drawing.RectangleF" />-Struktur, die den zu zeichnenden Teil des <paramref name="image" />-Objekts angibt.</param>
        <param name="srcUnit">Member der <see cref="T:System.Drawing.GraphicsUnit" />-Enumeration, der die Maßeinheiten für den <paramref name="srcRect" />-Parameter angibt.</param>
        <param name="imageAttr"><see cref="T:System.Drawing.Imaging.ImageAttributes" />, das Informationen über erneutes Einfärben und Gammainformationen für das <paramref name="image" />-Objekt angibt.</param>
        <param name="callback"><see cref="T:System.Drawing.Graphics.DrawImageAbort" />-Delegat, der eine Methode angibt, die während des Zeichnens des Bildes aufgerufen werden soll. Diese Methode wird häufig aufgerufen, um zu prüfen, ob die Ausführung der <see cref="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.PointF[],System.Drawing.RectangleF,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort)" />-Methode gemäß den durch die Anwendung bestimmten Kriterien abgebrochen werden soll.</param>
        <summary>Zeichnet den angegebenen Bereich vom angegebenen <see cref="T:System.Drawing.Image" /> in der angegebenen Größe an der angegebenen Position.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `destPoints` -Parameter gibt drei Punkte eines Parallelogramms an. Die drei <xref:System.Drawing.PointF> -Strukturen stellen die oberen linken, oberen rechten und unteren linken Ecke des parallelograms dar. Der vierte Punkt wird von den ersten drei extrapoliert, um ein Parallelogram zu bilden.  
  
 Der `srcRect` -Parameter gibt einen rechteckigen Teil `image` des zu zeichnenden Objekts an. Dieser Teil wird so skaliert, dass er in das durch den `destPoints` -Parameter angegebene Parallelogramm passt.  
  
 Diese Überladung mit `callback` dem-Parameter bietet die Möglichkeit, die Zeichnung eines Bilds zu beenden, sobald es gemäß den von der Anwendung festgelegten Kriterien gestartet wird. Beispielsweise könnte eine Anwendung mit dem Zeichnen eines großen Bilds beginnen, und der Benutzer kann den Bildlauf des Bilds durchführen. in diesem Fall kann die Anwendung die Zeichnung beenden.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code definiert zuerst eine Rückruf Methode für den <xref:System.Drawing.Graphics.DrawImageAbort> Delegaten; die Definition ist simpel und testet lediglich, ob die <xref:System.Drawing.Graphics.DrawImage%2A> Methode Sie mit einem NULL `callBackData` -Parameter aufruft. Der Hauptteil des Beispiels führt die folgenden Aktionen aus:  
  
-   Erstellt eine Instanz der <xref:System.Drawing.Graphics.DrawImageAbort> Rückruf Methode.  
  
-   Erstellt ein Bild aus einer JPEG-Datei "SampImag. jpg" im Ordner des Beispiels.  
  
-   Erstellt Punkte, die ein Parallelogramm definieren, in dem das Bild gezeichnet werden soll.  
  
-   Erstellt ein Rechteck, um den zu zeichnenden Teil des Bilds auszuwählen.  
  
-   Legt die Grafik Zeichnungs Einheit auf Pixel fest.  
  
-   Zeichnet das ursprüngliche Bild auf dem Bildschirm.  
  
-   Erstellt ein zusätzliches Parallelogramm, in dem ein angepasstes Bild gezeichnet werden soll.  
  
-   Erstellt und legt die Attribute des angepassten Bilds so fest, dass Sie über einen größeren, nicht üblichen Gamma Wert verfügen.  
  
-   Zeichnet das angepasste Bild auf dem Bildschirm.  
  
 Für das ursprüngliche, nicht angepasste Parallelogramm sucht die Position das Bild auf dem Bildschirm, und die Größe des Rechtecks und die Größe und Form des parallelograms bestimmen die Skalierung und das Scheren des gezeichneten Bilds.  
  
 Da in diesem Beispiel eine Überladung verwendet wird, die `callBackData` keinen-Parameter <xref:System.Drawing.Graphics.DrawImageAbort> übergibt, `true`gibt der Rückruf zurück <xref:System.Drawing.Graphics.DrawImage%2A> , wodurch die-Methode beendet wird. der Ausnahme Behandlungs Code, der im Beispiel enthalten ist, druckt den Ausnahme Text, anstatt das Bild zu zeichnen.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#44](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#44)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#44](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#44)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#44](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#44)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> ist <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.Point[] destPoints, System.Drawing.Rectangle srcRect, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Imaging.ImageAttributes imageAttr, System.Drawing.Graphics.DrawImageAbort callback, int callbackData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.Point[] destPoints, valuetype System.Drawing.Rectangle srcRect, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Imaging.ImageAttributes imageAttr, class System.Drawing.Graphics/DrawImageAbort callback, int32 callbackData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Point[],System.Drawing.Rectangle,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, cli::array &lt;System::Drawing::Point&gt; ^ destPoints, System::Drawing::Rectangle srcRect, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Imaging::ImageAttributes ^ imageAttr, System::Drawing::Graphics::DrawImageAbort ^ callback, int callbackData);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.Point[] * System.Drawing.Rectangle * System.Drawing.GraphicsUnit * System.Drawing.Imaging.ImageAttributes * System.Drawing.Graphics.DrawImageAbort * int -&gt; unit" Usage="graphics.DrawImage (image, destPoints, srcRect, srcUnit, imageAttr, callback, callbackData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destPoints" Type="System.Drawing.Point[]" />
        <Parameter Name="srcRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+DrawImageAbort" />
        <Parameter Name="callbackData" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="image">Der zu zeichnende <see cref="T:System.Drawing.Image" />.</param>
        <param name="destPoints">Array von drei <see cref="T:System.Drawing.PointF" />-Strukturen, die ein Parallelogramm definieren.</param>
        <param name="srcRect"><see cref="T:System.Drawing.Rectangle" />-Struktur, die den zu zeichnenden Teil des <paramref name="image" />-Objekts angibt.</param>
        <param name="srcUnit">Member der <see cref="T:System.Drawing.GraphicsUnit" />-Enumeration, der die Maßeinheiten für den <paramref name="srcRect" />-Parameter angibt.</param>
        <param name="imageAttr"><see cref="T:System.Drawing.Imaging.ImageAttributes" />, das Informationen über erneutes Einfärben und Gammainformationen für das <paramref name="image" />-Objekt angibt.</param>
        <param name="callback"><see cref="T:System.Drawing.Graphics.DrawImageAbort" />-Delegat, der eine Methode angibt, die während des Zeichnens des Bildes aufgerufen werden soll. Diese Methode wird häufig aufgerufen, um zu prüfen, ob die Ausführung der <see cref="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Point[],System.Drawing.Rectangle,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort,System.Int32)" />-Methode gemäß den durch die Anwendung bestimmten Kriterien abgebrochen werden soll.</param>
        <param name="callbackData">Ein Wert, der zusätzliche Daten angibt, mit denen der <see cref="T:System.Drawing.Graphics.DrawImageAbort" />-Delegat prüfen kann, ob die Ausführung der <see cref="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Point[],System.Drawing.Rectangle,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort,System.Int32)" />-Methode abgebrochen werden muss.</param>
        <summary>Zeichnet den angegebenen Bereich vom angegebenen <see cref="T:System.Drawing.Image" /> in der angegebenen Größe an der angegebenen Position.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `destPoints` -Parameter gibt drei Punkte eines Parallelogramms an. Die drei <xref:System.Drawing.PointF> -Strukturen stellen die oberen linken, oberen rechten und unteren linken Ecke des parallelograms dar. Der vierte Punkt wird von den ersten drei extrapoliert, um ein Parallelogram zu bilden.  
  
 Der `srcRect` -Parameter gibt einen rechteckigen Teil `image` des zu zeichnenden Objekts an. Dieser Teil wird so skaliert, dass er in das durch den `destPoints` -Parameter angegebene Parallelogramm passt.  
  
 Diese Überladung mit `callback` den `callbackData` Parametern und bietet die Möglichkeit, die Zeichnung eines Bilds zu beenden, nachdem es gemäß den von der Anwendung festgelegten Kriterien und Daten gestartet wurde. Beispielsweise könnte eine Anwendung mit dem Zeichnen eines großen Bilds beginnen, und der Benutzer kann den Bildlauf des Bilds durchführen. in diesem Fall kann die Anwendung die Zeichnung beenden.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code definiert zuerst eine Rückruf Methode für den <xref:System.Drawing.Graphics.DrawImageAbort> Delegaten; die Definition ist simpel und testet lediglich, ob die <xref:System.Drawing.Graphics.DrawImage%2A> Methode Sie mit einem NULL `callBackData` -Parameter aufruft. Der Hauptteil des Beispiels führt die folgenden Aktionen aus:  
  
-   Erstellt eine Instanz der <xref:System.Drawing.Graphics.DrawImageAbort> Rückruf Methode.  
  
-   Erstellt ein Bild aus einer JPEG-Datei "SampImag. jpg" im Ordner des Beispiels.  
  
-   Erstellt Punkte, die ein Parallelogramm definieren, in dem das Bild gezeichnet werden soll.  
  
-   Erstellt ein Rechteck, um den zu zeichnenden Teil des Bilds auszuwählen.  
  
-   Legt die Grafik Zeichnungs Einheit auf Pixel fest.  
  
-   Zeichnet das ursprüngliche Bild auf dem Bildschirm.  
  
-   Erstellt ein zusätzliches Parallelogramm, in dem ein angepasstes Bild gezeichnet werden soll.  
  
-   Erstellt und legt die Attribute des angepassten Bilds so fest, dass Sie über einen größeren, nicht üblichen Gamma Wert verfügen.  
  
-   Zeichnet das angepasste Bild auf dem Bildschirm.  
  
 Für das ursprüngliche, nicht angepasste Parallelogramm sucht die Position das Bild auf dem Bildschirm, und die Größe des Rechtecks und die Größe und Form des parallelograms bestimmen die Skalierung und das Scheren des gezeichneten Bilds.  
  
 Da in diesem Beispiel eine Überladung verwendet wird `callBackData` , die einen <xref:System.Drawing.Graphics.DrawImageAbort> -Parameter `false`übergibt, gibt der <xref:System.Drawing.Graphics.DrawImage%2A> Rückruf zurück, der bewirkt, dass die-Methode fortgesetzt wird. im Beispiel wird das angepasste Bild auf den Bildschirm gezeichnet.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#39](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#39)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#39](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#39)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#39](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#39)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.PointF[] destPoints, System.Drawing.RectangleF srcRect, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Imaging.ImageAttributes imageAttr, System.Drawing.Graphics.DrawImageAbort callback, int callbackData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.PointF[] destPoints, valuetype System.Drawing.RectangleF srcRect, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Imaging.ImageAttributes imageAttr, class System.Drawing.Graphics/DrawImageAbort callback, int32 callbackData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.PointF[],System.Drawing.RectangleF,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, cli::array &lt;System::Drawing::PointF&gt; ^ destPoints, System::Drawing::RectangleF srcRect, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Imaging::ImageAttributes ^ imageAttr, System::Drawing::Graphics::DrawImageAbort ^ callback, int callbackData);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.PointF[] * System.Drawing.RectangleF * System.Drawing.GraphicsUnit * System.Drawing.Imaging.ImageAttributes * System.Drawing.Graphics.DrawImageAbort * int -&gt; unit" Usage="graphics.DrawImage (image, destPoints, srcRect, srcUnit, imageAttr, callback, callbackData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destPoints" Type="System.Drawing.PointF[]" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+DrawImageAbort" />
        <Parameter Name="callbackData" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="image">Der zu zeichnende <see cref="T:System.Drawing.Image" />.</param>
        <param name="destPoints">Array von drei <see cref="T:System.Drawing.PointF" />-Strukturen, die ein Parallelogramm definieren.</param>
        <param name="srcRect"><see cref="T:System.Drawing.RectangleF" />-Struktur, die den zu zeichnenden Teil des <paramref name="image" />-Objekts angibt.</param>
        <param name="srcUnit">Member der <see cref="T:System.Drawing.GraphicsUnit" />-Enumeration, der die Maßeinheiten für den <paramref name="srcRect" />-Parameter angibt.</param>
        <param name="imageAttr"><see cref="T:System.Drawing.Imaging.ImageAttributes" />, das Informationen über erneutes Einfärben und Gammainformationen für das <paramref name="image" />-Objekt angibt.</param>
        <param name="callback"><see cref="T:System.Drawing.Graphics.DrawImageAbort" />-Delegat, der eine Methode angibt, die während des Zeichnens des Bildes aufgerufen werden soll. Diese Methode wird häufig aufgerufen, um zu prüfen, ob die Ausführung der <see cref="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.PointF[],System.Drawing.RectangleF,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort,System.Int32)" />-Methode gemäß den durch die Anwendung bestimmten Kriterien abgebrochen werden soll.</param>
        <param name="callbackData">Ein Wert, der zusätzliche Daten angibt, mit denen der <see cref="T:System.Drawing.Graphics.DrawImageAbort" />-Delegat prüfen kann, ob die Ausführung der <see cref="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.PointF[],System.Drawing.RectangleF,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort,System.Int32)" />-Methode abgebrochen werden muss.</param>
        <summary>Zeichnet den angegebenen Bereich vom angegebenen <see cref="T:System.Drawing.Image" /> in der angegebenen Größe an der angegebenen Position.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `destPoints` -Parameter gibt drei Punkte eines Parallelogramms an. Die drei <xref:System.Drawing.PointF> -Strukturen stellen die oberen linken, oberen rechten und unteren linken Ecke des parallelograms dar. Der vierte Punkt wird von den ersten drei extrapoliert, um ein Parallelogram zu bilden.  
  
 Der `srcRect` -Parameter gibt einen rechteckigen Teil `image` des zu zeichnenden Objekts an. Dieser Teil wird so skaliert, dass er in das durch den `destPoints` -Parameter angegebene Parallelogramm passt.  
  
 Diese Überladung mit `callback` den `callbackData` Parametern und bietet die Möglichkeit, die Zeichnung eines Bilds zu beenden, nachdem es gemäß den von der Anwendung festgelegten Kriterien und Daten gestartet wurde. Beispielsweise könnte eine Anwendung mit dem Zeichnen eines großen Bilds beginnen, und der Benutzer kann den Bildlauf des Bilds durchführen. in diesem Fall kann die Anwendung die Zeichnung beenden.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit <xref:System.Windows.Forms.PaintEventArgs>Windows Forms konzipiert und erfordert `e`, wobei es sich um einen Parameter des `Pa` - <xref:System.Windows.Forms.Control.Paint> Ereignis Handlers handelt. Der Code definiert zuerst eine Rückruf Methode für den <xref:System.Drawing.Graphics.DrawImageAbort> Delegaten; die Definition ist simpel und testet lediglich, ob die <xref:System.Drawing.Graphics.DrawImage%2A> Methode Sie mit einem NULL `callBackData` -Parameter aufruft. Der Hauptteil des Beispiels führt die folgenden Aktionen aus:  
  
-   Erstellt eine Instanz der <xref:System.Drawing.Graphics.DrawImageAbort> Rückruf Methode.  
  
-   Erstellt ein Bild aus einer JPEG-Datei "SampImag. jpg" im Ordner des Beispiels.  
  
-   Erstellt Punkte, die ein Parallelogramm definieren, in dem das Bild gezeichnet werden soll.  
  
-   Erstellt ein Rechteck, um den zu zeichnenden Teil des Bilds auszuwählen.  
  
-   Legt die Grafik Zeichnungs Einheit auf Pixel fest.  
  
-   Zeichnet das ursprüngliche Bild auf dem Bildschirm.  
  
-   Erstellt ein zusätzliches Parallelogramm, in dem ein angepasstes Bild gezeichnet werden soll.  
  
-   Erstellt und legt die Attribute des angepassten Bilds so fest, dass Sie über einen größeren, nicht üblichen Gamma Wert verfügen.  
  
-   Zeichnet das angepasste Bild auf dem Bildschirm.  
  
 Für das ursprüngliche, nicht angepasste Parallelogramm sucht die Position das Bild auf dem Bildschirm, und die Größe des Rechtecks und die Größe und Form des parallelograms bestimmen die Skalierung und das Scheren des gezeichneten Bilds.  
  
 Da in diesem Beispiel eine Überladung verwendet wird `callBackData` , die einen <xref:System.Drawing.Graphics.DrawImageAbort> -Parameter `false`übergibt, gibt der <xref:System.Drawing.Graphics.DrawImage%2A> Rückruf zurück, der bewirkt, dass die-Methode fortgesetzt wird. im Beispiel wird das angepasste Bild auf den Bildschirm gezeichnet.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#45](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#45)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#45](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#45)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#45](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#45)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> ist <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.Rectangle destRect, int srcX, int srcY, int srcWidth, int srcHeight, System.Drawing.GraphicsUnit srcUnit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.Rectangle destRect, int32 srcX, int32 srcY, int32 srcWidth, int32 srcHeight, valuetype System.Drawing.GraphicsUnit srcUnit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Rectangle,System.Int32,System.Int32,System.Int32,System.Int32,System.Drawing.GraphicsUnit)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, System::Drawing::Rectangle destRect, int srcX, int srcY, int srcWidth, int srcHeight, System::Drawing::GraphicsUnit srcUnit);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.Rectangle * int * int * int * int * System.Drawing.GraphicsUnit -&gt; unit" Usage="graphics.DrawImage (image, destRect, srcX, srcY, srcWidth, srcHeight, srcUnit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcX" Type="System.Int32" />
        <Parameter Name="srcY" Type="System.Int32" />
        <Parameter Name="srcWidth" Type="System.Int32" />
        <Parameter Name="srcHeight" Type="System.Int32" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
      </Parameters>
      <Docs>
        <param name="image">Der zu zeichnende <see cref="T:System.Drawing.Image" />.</param>
        <param name="destRect"><see cref="T:System.Drawing.Rectangle" />-Struktur, die die Position und Größe des gezeichneten Bildes angibt. Das Bild wird skaliert, sodass es in das Rechteck passt.</param>
        <param name="srcX">Die x-Koordinate der oberen linken Ecke des zu zeichnenden Bereichs des Quellbilds.</param>
        <param name="srcY">Die y-Koordinate der oberen linken Ecke des zu zeichnenden Bereichs des Quellbilds.</param>
        <param name="srcWidth">Breite des zu zeichnenden Bereichs des Quellbilds.</param>
        <param name="srcHeight">Höhe des zu zeichnenden Bereichs des Quellbilds.</param>
        <param name="srcUnit">Member der <see cref="T:System.Drawing.GraphicsUnit" />-Enumeration, der die Maßeinheiten angibt, mit denen das Quellrechteck bestimmt wird.</param>
        <summary>Zeichnet den angegebenen Bereich vom angegebenen <see cref="T:System.Drawing.Image" /> in der angegebenen Größe an der angegebenen Position.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `srcX`Parameter `srcY`, ,`srcWidth` `image` und gebeneinenrechteckigenTeildeszuzeichnendenObjektsan.`srcHeight` Das Rechteck ist relativ zur linken oberen Ecke des Quell Bilds. Dieser Teil wird so skaliert, dass er in das durch `destRect` den-Parameter angegebene Rechteck passt.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein Bild aus einer JPEG-Datei "SampImag. jpg" im Ordner des Beispiels.  
  
-   Erstellt ein Ziel Rechteck, in dem das Bild gezeichnet werden soll.  
  
-   Erstellt die Koordinaten eines Quell Rechtecks, aus dem ein Teil des Bilds extrahiert werden soll.  
  
-   Legt die Maßeinheit des Quell Rechtecks auf Pixel fest.  
  
-   Zeichnet das Bild auf dem Bildschirm.  
  
 Die Position des Ziel Rechtecks sucht das Bild auf dem Bildschirm, und die Größe der Quell-und Ziel Rechtecke bestimmt die Skalierung des gezeichneten Bilds, und die Größe des Quell Rechtecks bestimmt, welcher Teil des ursprünglichen Bilds zum Schirmen.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#48](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#48)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#48](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#48)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#48](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#48)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> ist <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.Rectangle destRect, float srcX, float srcY, float srcWidth, float srcHeight, System.Drawing.GraphicsUnit srcUnit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.Rectangle destRect, float32 srcX, float32 srcY, float32 srcWidth, float32 srcHeight, valuetype System.Drawing.GraphicsUnit srcUnit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Rectangle,System.Single,System.Single,System.Single,System.Single,System.Drawing.GraphicsUnit)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, System::Drawing::Rectangle destRect, float srcX, float srcY, float srcWidth, float srcHeight, System::Drawing::GraphicsUnit srcUnit);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.Rectangle * single * single * single * single * System.Drawing.GraphicsUnit -&gt; unit" Usage="graphics.DrawImage (image, destRect, srcX, srcY, srcWidth, srcHeight, srcUnit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcX" Type="System.Single" />
        <Parameter Name="srcY" Type="System.Single" />
        <Parameter Name="srcWidth" Type="System.Single" />
        <Parameter Name="srcHeight" Type="System.Single" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
      </Parameters>
      <Docs>
        <param name="image">Der zu zeichnende <see cref="T:System.Drawing.Image" />.</param>
        <param name="destRect"><see cref="T:System.Drawing.Rectangle" />-Struktur, die die Position und Größe des gezeichneten Bildes angibt. Das Bild wird skaliert, sodass es in das Rechteck passt.</param>
        <param name="srcX">Die x-Koordinate der oberen linken Ecke des zu zeichnenden Bereichs des Quellbilds.</param>
        <param name="srcY">Die y-Koordinate der oberen linken Ecke des zu zeichnenden Bereichs des Quellbilds.</param>
        <param name="srcWidth">Breite des zu zeichnenden Bereichs des Quellbilds.</param>
        <param name="srcHeight">Höhe des zu zeichnenden Bereichs des Quellbilds.</param>
        <param name="srcUnit">Member der <see cref="T:System.Drawing.GraphicsUnit" />-Enumeration, der die Maßeinheiten angibt, mit denen das Quellrechteck bestimmt wird.</param>
        <summary>Zeichnet den angegebenen Bereich vom angegebenen <see cref="T:System.Drawing.Image" /> in der angegebenen Größe an der angegebenen Position.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `srcX`Parameter `srcY`, ,`srcWidth` `image` und gebeneinenrechteckigenTeildeszuzeichnendenObjektsan.`srcHeight` Das Rechteck ist relativ zur linken oberen Ecke des Quell Bilds. Dieser Teil wird so skaliert, dass er in das durch `destRect` den-Parameter angegebene Rechteck passt.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein Bild aus einer JPEG-Datei "SampImag. jpg" im Ordner des Beispiels.  
  
-   Erstellt die Koordinaten eines Ziel Rechtecks, in dem das Bild gezeichnet werden soll.  
  
-   Erstellt ein Quell Rechteck, aus dem ein Teil des Bilds extrahiert werden soll.  
  
-   Legt die Maßeinheit des Quell Rechtecks auf Pixel fest.  
  
-   Zeichnet das Bild auf dem Bildschirm.  
  
 Die Position des Ziel Rechtecks sucht das Bild auf dem Bildschirm, die Größe der Quell-und Ziel Rechtecke bestimmt die Skalierung des gezeichneten Bilds, und die Größe des Quell Rechtecks bestimmt, welcher Teil des ursprünglichen Bilds zum Schirmen.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#52](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#52)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#52](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#52)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#52](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> ist <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.Rectangle destRect, int srcX, int srcY, int srcWidth, int srcHeight, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Imaging.ImageAttributes imageAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.Rectangle destRect, int32 srcX, int32 srcY, int32 srcWidth, int32 srcHeight, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Imaging.ImageAttributes imageAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Rectangle,System.Int32,System.Int32,System.Int32,System.Int32,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, System::Drawing::Rectangle destRect, int srcX, int srcY, int srcWidth, int srcHeight, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Imaging::ImageAttributes ^ imageAttr);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.Rectangle * int * int * int * int * System.Drawing.GraphicsUnit * System.Drawing.Imaging.ImageAttributes -&gt; unit" Usage="graphics.DrawImage (image, destRect, srcX, srcY, srcWidth, srcHeight, srcUnit, imageAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcX" Type="System.Int32" />
        <Parameter Name="srcY" Type="System.Int32" />
        <Parameter Name="srcWidth" Type="System.Int32" />
        <Parameter Name="srcHeight" Type="System.Int32" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
      </Parameters>
      <Docs>
        <param name="image">Der zu zeichnende <see cref="T:System.Drawing.Image" />.</param>
        <param name="destRect"><see cref="T:System.Drawing.Rectangle" />-Struktur, die die Position und Größe des gezeichneten Bildes angibt. Das Bild wird skaliert, sodass es in das Rechteck passt.</param>
        <param name="srcX">Die x-Koordinate der oberen linken Ecke des zu zeichnenden Bereichs des Quellbilds.</param>
        <param name="srcY">Die y-Koordinate der oberen linken Ecke des zu zeichnenden Bereichs des Quellbilds.</param>
        <param name="srcWidth">Breite des zu zeichnenden Bereichs des Quellbilds.</param>
        <param name="srcHeight">Höhe des zu zeichnenden Bereichs des Quellbilds.</param>
        <param name="srcUnit">Member der <see cref="T:System.Drawing.GraphicsUnit" />-Enumeration, der die Maßeinheiten angibt, mit denen das Quellrechteck bestimmt wird.</param>
        <param name="imageAttr"><see cref="T:System.Drawing.Imaging.ImageAttributes" />, das Informationen über erneutes Einfärben und Gammainformationen für das <paramref name="image" />-Objekt angibt.</param>
        <summary>Zeichnet den angegebenen Bereich vom angegebenen <see cref="T:System.Drawing.Image" /> in der angegebenen Größe an der angegebenen Position.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `srcX`Parameter `srcY`, ,`srcWidth` `image` und gebeneinenrechteckigenTeildeszuzeichnendenObjektsan.`srcHeight` Das Rechteck ist relativ zur linken oberen Ecke des Quell Bilds. Dieser Teil wird so skaliert, dass er in das durch `destRect` den-Parameter angegebene Rechteck passt.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein Bild aus einer JPEG-Datei "SampImag. jpg" im Ordner des Beispiels.  
  
-   Erstellt ein Ziel Rechteck, in dem das Bild gezeichnet werden soll.  
  
-   Erstellt die Koordinaten eines Quell Rechtecks, aus dem ein Teil des Bilds extrahiert werden soll.  
  
-   Legt die Maßeinheit des Quell Rechtecks auf Pixel fest.  
  
-   Zeichnet das ursprüngliche Bild auf dem Bildschirm.  
  
-   Erstellt ein zusätzliches Rechteck, in dem ein angepasstes Bild gezeichnet werden soll.  
  
-   Erstellt und legt die Attribute des angepassten Bilds so fest, dass Sie über einen größeren, nicht üblichen Gamma Wert verfügen.  
  
-   Zeichnet das angepasste Bild auf dem Bildschirm.  
  
 Bei der ursprünglichen, nicht angepassten Ziel Rechtecks sucht die Position das Bild auf dem Bildschirm, und die Größe der Quell-und Ziel Rechtecke bestimmt die Skalierung des gezeichneten Bilds, und die Größe des Quell Rechtecks bestimmt, welcher Teil des das ursprüngliche Bild wird auf dem Bildschirm gezeichnet.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#49](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#49)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#49](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#49)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#49](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#49)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> ist <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.Rectangle destRect, float srcX, float srcY, float srcWidth, float srcHeight, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Imaging.ImageAttributes imageAttrs);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.Rectangle destRect, float32 srcX, float32 srcY, float32 srcWidth, float32 srcHeight, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Imaging.ImageAttributes imageAttrs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Rectangle,System.Single,System.Single,System.Single,System.Single,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, System::Drawing::Rectangle destRect, float srcX, float srcY, float srcWidth, float srcHeight, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Imaging::ImageAttributes ^ imageAttrs);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.Rectangle * single * single * single * single * System.Drawing.GraphicsUnit * System.Drawing.Imaging.ImageAttributes -&gt; unit" Usage="graphics.DrawImage (image, destRect, srcX, srcY, srcWidth, srcHeight, srcUnit, imageAttrs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcX" Type="System.Single" />
        <Parameter Name="srcY" Type="System.Single" />
        <Parameter Name="srcWidth" Type="System.Single" />
        <Parameter Name="srcHeight" Type="System.Single" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="imageAttrs" Type="System.Drawing.Imaging.ImageAttributes" />
      </Parameters>
      <Docs>
        <param name="image">Der zu zeichnende <see cref="T:System.Drawing.Image" />.</param>
        <param name="destRect"><see cref="T:System.Drawing.Rectangle" />-Struktur, die die Position und Größe des gezeichneten Bildes angibt. Das Bild wird skaliert, sodass es in das Rechteck passt.</param>
        <param name="srcX">Die x-Koordinate der oberen linken Ecke des zu zeichnenden Bereichs des Quellbilds.</param>
        <param name="srcY">Die y-Koordinate der oberen linken Ecke des zu zeichnenden Bereichs des Quellbilds.</param>
        <param name="srcWidth">Breite des zu zeichnenden Bereichs des Quellbilds.</param>
        <param name="srcHeight">Höhe des zu zeichnenden Bereichs des Quellbilds.</param>
        <param name="srcUnit">Member der <see cref="T:System.Drawing.GraphicsUnit" />-Enumeration, der die Maßeinheiten angibt, mit denen das Quellrechteck bestimmt wird.</param>
        <param name="imageAttrs"><see cref="T:System.Drawing.Imaging.ImageAttributes" />, das Informationen über erneutes Einfärben und Gammainformationen für das <paramref name="image" />-Objekt angibt.</param>
        <summary>Zeichnet den angegebenen Bereich vom angegebenen <see cref="T:System.Drawing.Image" /> in der angegebenen Größe an der angegebenen Position.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `srcX`Parameter `srcY`, ,`srcWidth` `image` und gebeneinenrechteckigenTeildeszuzeichnendenObjektsan.`srcHeight` Das Rechteck ist relativ zur linken oberen Ecke des Quell Bilds. Dieser Teil wird so skaliert, dass er in das durch `destRect` den-Parameter angegebene Rechteck passt.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein Bild aus einer JPEG-Datei "SampImag. jpg" im Ordner des Beispiels.  
  
-   Erstellt ein Ziel Rechteck, in dem das Bild gezeichnet werden soll.  
  
-   Erstellt die Koordinaten eines Quell Rechtecks, aus dem ein Teil des Bilds extrahiert werden soll.  
  
-   Legt die Maßeinheit des Quell Rechtecks auf Pixel fest.  
  
-   Zeichnet das ursprüngliche Bild auf dem Bildschirm.  
  
-   Erstellt ein zusätzliches Rechteck, in dem ein angepasstes Bild gezeichnet werden soll.  
  
-   Erstellt und legt die Attribute des angepassten Bilds so fest, dass Sie über einen größeren, nicht üblichen Gamma Wert verfügen.  
  
-   Zeichnet das angepasste Bild auf dem Bildschirm.  
  
 Bei der ursprünglichen, nicht angepassten Ziel Rechtecks sucht die Position das Bild auf dem Bildschirm, und die Größe der Quell-und Ziel Rechtecke bestimmt die Skalierung des gezeichneten Bilds, und die Größe des Quell Rechtecks bestimmt, welcher Teil des das ursprüngliche Bild wird auf dem Bildschirm gezeichnet.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#53](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#53)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#53](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#53)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#53](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#53)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> ist <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.Rectangle destRect, int srcX, int srcY, int srcWidth, int srcHeight, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Imaging.ImageAttributes imageAttr, System.Drawing.Graphics.DrawImageAbort callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.Rectangle destRect, int32 srcX, int32 srcY, int32 srcWidth, int32 srcHeight, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Imaging.ImageAttributes imageAttr, class System.Drawing.Graphics/DrawImageAbort callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Rectangle,System.Int32,System.Int32,System.Int32,System.Int32,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, System::Drawing::Rectangle destRect, int srcX, int srcY, int srcWidth, int srcHeight, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Imaging::ImageAttributes ^ imageAttr, System::Drawing::Graphics::DrawImageAbort ^ callback);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.Rectangle * int * int * int * int * System.Drawing.GraphicsUnit * System.Drawing.Imaging.ImageAttributes * System.Drawing.Graphics.DrawImageAbort -&gt; unit" Usage="graphics.DrawImage (image, destRect, srcX, srcY, srcWidth, srcHeight, srcUnit, imageAttr, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcX" Type="System.Int32" />
        <Parameter Name="srcY" Type="System.Int32" />
        <Parameter Name="srcWidth" Type="System.Int32" />
        <Parameter Name="srcHeight" Type="System.Int32" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+DrawImageAbort" />
      </Parameters>
      <Docs>
        <param name="image">Der zu zeichnende <see cref="T:System.Drawing.Image" />.</param>
        <param name="destRect"><see cref="T:System.Drawing.Rectangle" />-Struktur, die die Position und Größe des gezeichneten Bildes angibt. Das Bild wird skaliert, sodass es in das Rechteck passt.</param>
        <param name="srcX">Die x-Koordinate der oberen linken Ecke des zu zeichnenden Bereichs des Quellbilds.</param>
        <param name="srcY">Die y-Koordinate der oberen linken Ecke des zu zeichnenden Bereichs des Quellbilds.</param>
        <param name="srcWidth">Breite des zu zeichnenden Bereichs des Quellbilds.</param>
        <param name="srcHeight">Höhe des zu zeichnenden Bereichs des Quellbilds.</param>
        <param name="srcUnit">Member der <see cref="T:System.Drawing.GraphicsUnit" />-Enumeration, der die Maßeinheiten angibt, mit denen das Quellrechteck bestimmt wird.</param>
        <param name="imageAttr"><see cref="T:System.Drawing.Imaging.ImageAttributes" />, das Neueinfärbungs- und Gammainformationen für <paramref name="image" /> angeben.</param>
        <param name="callback"><see cref="T:System.Drawing.Graphics.DrawImageAbort" />-Delegat, der eine Methode angibt, die während des Zeichnens des Bildes aufgerufen werden soll. Diese Methode wird häufig aufgerufen, um zu prüfen, ob die Ausführung der <see cref="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Rectangle,System.Int32,System.Int32,System.Int32,System.Int32,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort)" />-Methode gemäß den durch die Anwendung bestimmten Kriterien abgebrochen werden soll.</param>
        <summary>Zeichnet den angegebenen Bereich vom angegebenen <see cref="T:System.Drawing.Image" /> in der angegebenen Größe an der angegebenen Position.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `srcX`Parameter `srcY`, ,`srcWidth` `image` und gebeneinenrechteckigenTeildeszuzeichnendenObjektsan.`srcHeight` Das Rechteck ist relativ zur linken oberen Ecke des Quell Bilds. Dieser Teil wird so skaliert, dass er in das durch `destRect` das-Objekt angegebene Rechteck passt.  
  
 Diese Überladung mit `callback` dem-Parameter bietet die Möglichkeit, die Zeichnung eines Bilds zu beenden, sobald es gemäß den von der Anwendung festgelegten Kriterien gestartet wird. Beispielsweise könnte eine Anwendung mit dem Zeichnen eines großen Bilds beginnen, und der Benutzer kann den Bildlauf des Bilds durchführen. in diesem Fall kann die Anwendung die Zeichnung beenden.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code definiert zuerst eine Rückruf Methode für den <xref:System.Drawing.Graphics.DrawImageAbort> Delegaten; die Definition ist simpel und testet lediglich, ob die <xref:System.Drawing.Graphics.DrawImage%2A> Methode Sie mit einem NULL `callBackData` -Parameter aufruft. Der Hauptteil des Beispiels führt die folgenden Aktionen aus:  
  
-   Erstellt eine Instanz der <xref:System.Drawing.Graphics.DrawImageAbort> Rückruf Methode.  
  
-   Erstellt ein Bild aus einer JPEG-Datei "SampImag. jpg" im Ordner des Beispiels.  
  
-   Erstellt Punkte, die ein Ziel Rechteck definieren, in das das Bild gezeichnet werden soll.  
  
-   Erstellt ein Quell Rechteck, um den zu zeichnenden Teil des Bilds auszuwählen.  
  
-   Legt die Grafik Zeichnungs Einheit auf Pixel fest.  
  
-   Zeichnet das ursprüngliche Bild auf dem Bildschirm.  
  
-   Erstellt ein zusätzliches Ziel Rechteck, in dem ein angepasstes Bild gezeichnet werden soll.  
  
-   Erstellt und legt die Attribute des angepassten Bilds so fest, dass Sie über einen größeren, nicht üblichen Gamma Wert verfügen.  
  
-   Zeichnet das angepasste Bild auf dem Bildschirm.  
  
 Die Position des ursprünglichen, nicht angepassten Ziel Rechtecks sucht das Bild auf dem Bildschirm, und die Größe des Quell Rechtecks und die Größe und Form des Ziel Rechtecks bestimmen die Skalierung des gezeichneten Bilds.  
  
 Da in diesem Beispiel eine Überladung verwendet wird, die `callBackData` keinen-Parameter <xref:System.Drawing.Graphics.DrawImageAbort> übergibt, `true`gibt der Rückruf zurück <xref:System.Drawing.Graphics.DrawImage%2A> , wodurch die-Methode beendet wird. der Ausnahme Behandlungs Code, der im Beispiel enthalten ist, druckt den Ausnahme Text, anstatt das Bild zu zeichnen.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#50](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#50)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#50](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#50)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#50](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#50)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> ist <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.Rectangle destRect, float srcX, float srcY, float srcWidth, float srcHeight, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Imaging.ImageAttributes imageAttrs, System.Drawing.Graphics.DrawImageAbort callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.Rectangle destRect, float32 srcX, float32 srcY, float32 srcWidth, float32 srcHeight, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Imaging.ImageAttributes imageAttrs, class System.Drawing.Graphics/DrawImageAbort callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Rectangle,System.Single,System.Single,System.Single,System.Single,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, System::Drawing::Rectangle destRect, float srcX, float srcY, float srcWidth, float srcHeight, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Imaging::ImageAttributes ^ imageAttrs, System::Drawing::Graphics::DrawImageAbort ^ callback);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.Rectangle * single * single * single * single * System.Drawing.GraphicsUnit * System.Drawing.Imaging.ImageAttributes * System.Drawing.Graphics.DrawImageAbort -&gt; unit" Usage="graphics.DrawImage (image, destRect, srcX, srcY, srcWidth, srcHeight, srcUnit, imageAttrs, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcX" Type="System.Single" />
        <Parameter Name="srcY" Type="System.Single" />
        <Parameter Name="srcWidth" Type="System.Single" />
        <Parameter Name="srcHeight" Type="System.Single" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="imageAttrs" Type="System.Drawing.Imaging.ImageAttributes" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+DrawImageAbort" />
      </Parameters>
      <Docs>
        <param name="image">Der zu zeichnende <see cref="T:System.Drawing.Image" />.</param>
        <param name="destRect"><see cref="T:System.Drawing.Rectangle" />-Struktur, die die Position und Größe des gezeichneten Bildes angibt. Das Bild wird skaliert, sodass es in das Rechteck passt.</param>
        <param name="srcX">Die x-Koordinate der oberen linken Ecke des zu zeichnenden Bereichs des Quellbilds.</param>
        <param name="srcY">Die y-Koordinate der oberen linken Ecke des zu zeichnenden Bereichs des Quellbilds.</param>
        <param name="srcWidth">Breite des zu zeichnenden Bereichs des Quellbilds.</param>
        <param name="srcHeight">Höhe des zu zeichnenden Bereichs des Quellbilds.</param>
        <param name="srcUnit">Member der <see cref="T:System.Drawing.GraphicsUnit" />-Enumeration, der die Maßeinheiten angibt, mit denen das Quellrechteck bestimmt wird.</param>
        <param name="imageAttrs"><see cref="T:System.Drawing.Imaging.ImageAttributes" />, das Informationen über erneutes Einfärben und Gammainformationen für das <paramref name="image" />-Objekt angibt.</param>
        <param name="callback"><see cref="T:System.Drawing.Graphics.DrawImageAbort" />-Delegat, der eine Methode angibt, die während des Zeichnens des Bildes aufgerufen werden soll. Diese Methode wird häufig aufgerufen, um zu prüfen, ob die Ausführung der <see cref="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Rectangle,System.Single,System.Single,System.Single,System.Single,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort)" />-Methode gemäß den durch die Anwendung bestimmten Kriterien abgebrochen werden soll.</param>
        <summary>Zeichnet den angegebenen Bereich vom angegebenen <see cref="T:System.Drawing.Image" /> in der angegebenen Größe an der angegebenen Position.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `srcX`Parameter `srcY`, ,`srcWidth` `image` und gebeneinenrechteckigenTeildeszuzeichnendenObjektsan.`srcHeight` Das Rechteck ist relativ zur linken oberen Ecke des Quell Bilds. Dieser Teil wird so skaliert, dass er in das durch `destRect` den-Parameter angegebene Rechteck passt.  
  
 Diese Überladung mit `callback` dem-Parameter bietet die Möglichkeit, die Zeichnung eines Bilds zu beenden, sobald es gemäß den von der Anwendung festgelegten Kriterien gestartet wird. Beispielsweise könnte eine Anwendung mit dem Zeichnen eines großen Bilds beginnen, und der Benutzer kann den Bildlauf des Bilds durchführen. in diesem Fall kann die Anwendung die Zeichnung beenden.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code definiert zuerst eine Rückruf Methode für den <xref:System.Drawing.Graphics.DrawImageAbort> Delegaten; die Definition ist simpel und testet lediglich, ob die <xref:System.Drawing.Graphics.DrawImage%2A> Methode Sie mit einem NULL `callBackData` -Parameter aufruft. Der Hauptteil des Beispiels führt die folgenden Aktionen aus:  
  
-   Erstellt eine Instanz der <xref:System.Drawing.Graphics.DrawImageAbort> Rückruf Methode.  
  
-   Erstellt ein Bild aus einer JPEG-Datei "SampImag. jpg" im Ordner des Beispiels.  
  
-   Erstellt Punkte, die ein Ziel Rechteck definieren, in das das Bild gezeichnet werden soll.  
  
-   Erstellt ein Quell Rechteck, um den zu zeichnenden Teil des Bilds auszuwählen.  
  
-   Legt die Grafik Zeichnungs Einheit auf Pixel fest.  
  
-   Zeichnet das ursprüngliche Bild auf dem Bildschirm.  
  
-   Erstellt ein zusätzliches Ziel Rechteck, in dem ein angepasstes Bild gezeichnet werden soll.  
  
-   Erstellt und legt die Attribute des angepassten Bilds so fest, dass Sie über einen größeren, nicht üblichen Gamma Wert verfügen.  
  
-   Zeichnet das angepasste Bild auf dem Bildschirm.  
  
 Die Position des ursprünglichen, nicht angepassten Ziel Rechtecks sucht das Bild auf dem Bildschirm, und die Größe des Quell Rechtecks und die Größe und Form des Ziel Rechtecks bestimmen die Skalierung des gezeichneten Bilds.  
  
 Da in diesem Beispiel eine Überladung verwendet wird, die `callBackData` keinen-Parameter <xref:System.Drawing.Graphics.DrawImageAbort> übergibt, `true`gibt der Rückruf zurück <xref:System.Drawing.Graphics.DrawImage%2A> , wodurch die-Methode beendet wird. der Ausnahme Behandlungs Code, der im Beispiel enthalten ist, druckt den Ausnahme Text, anstatt das Bild zu zeichnen.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#54](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#54)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#54](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#54)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#54](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#54)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> ist <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.Rectangle destRect, int srcX, int srcY, int srcWidth, int srcHeight, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Imaging.ImageAttributes imageAttrs, System.Drawing.Graphics.DrawImageAbort callback, IntPtr callbackData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.Rectangle destRect, int32 srcX, int32 srcY, int32 srcWidth, int32 srcHeight, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Imaging.ImageAttributes imageAttrs, class System.Drawing.Graphics/DrawImageAbort callback, native int callbackData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Rectangle,System.Int32,System.Int32,System.Int32,System.Int32,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort,System.IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, System::Drawing::Rectangle destRect, int srcX, int srcY, int srcWidth, int srcHeight, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Imaging::ImageAttributes ^ imageAttrs, System::Drawing::Graphics::DrawImageAbort ^ callback, IntPtr callbackData);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.Rectangle * int * int * int * int * System.Drawing.GraphicsUnit * System.Drawing.Imaging.ImageAttributes * System.Drawing.Graphics.DrawImageAbort * nativeint -&gt; unit" Usage="graphics.DrawImage (image, destRect, srcX, srcY, srcWidth, srcHeight, srcUnit, imageAttrs, callback, callbackData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcX" Type="System.Int32" />
        <Parameter Name="srcY" Type="System.Int32" />
        <Parameter Name="srcWidth" Type="System.Int32" />
        <Parameter Name="srcHeight" Type="System.Int32" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="imageAttrs" Type="System.Drawing.Imaging.ImageAttributes" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+DrawImageAbort" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="image">Der zu zeichnende <see cref="T:System.Drawing.Image" />.</param>
        <param name="destRect"><see cref="T:System.Drawing.Rectangle" />-Struktur, die die Position und Größe des gezeichneten Bildes angibt. Das Bild wird skaliert, sodass es in das Rechteck passt.</param>
        <param name="srcX">Die x-Koordinate der oberen linken Ecke des zu zeichnenden Bereichs des Quellbilds.</param>
        <param name="srcY">Die y-Koordinate der oberen linken Ecke des zu zeichnenden Bereichs des Quellbilds.</param>
        <param name="srcWidth">Breite des zu zeichnenden Bereichs des Quellbilds.</param>
        <param name="srcHeight">Höhe des zu zeichnenden Bereichs des Quellbilds.</param>
        <param name="srcUnit">Member der <see cref="T:System.Drawing.GraphicsUnit" />-Enumeration, der die Maßeinheiten angibt, mit denen das Quellrechteck bestimmt wird.</param>
        <param name="imageAttrs"><see cref="T:System.Drawing.Imaging.ImageAttributes" />, das Informationen über erneutes Einfärben und Gammainformationen für das <paramref name="image" />-Objekt angibt.</param>
        <param name="callback"><see cref="T:System.Drawing.Graphics.DrawImageAbort" />-Delegat, der eine Methode angibt, die während des Zeichnens des Bildes aufgerufen werden soll. Diese Methode wird häufig aufgerufen, um zu prüfen, ob die Ausführung der <see cref="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Rectangle,System.Int32,System.Int32,System.Int32,System.Int32,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort,System.IntPtr)" />-Methode gemäß den durch die Anwendung bestimmten Kriterien abgebrochen werden soll.</param>
        <param name="callbackData">Ein Wert, der zusätzliche Daten angibt, mit denen der <see cref="T:System.Drawing.Graphics.DrawImageAbort" />-Delegat prüfen kann, ob die Ausführung der <see langword="DrawImage" />-Methode abgebrochen werden muss.</param>
        <summary>Zeichnet den angegebenen Bereich vom angegebenen <see cref="T:System.Drawing.Image" /> in der angegebenen Größe an der angegebenen Position.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `srcX`Parameter `srcY`, ,`srcWidth` `image` und gebeneinenrechteckigenTeildeszuzeichnendenObjektsan.`srcHeight` Das Rechteck ist relativ zur linken oberen Ecke des Quell Bilds. Dieser Teil wird so skaliert, dass er in das durch `destRect` den-Parameter angegebene Rechteck passt.  
  
 Diese Überladung mit `callback` den `callbackData` Parametern und bietet die Möglichkeit, die Zeichnung eines Bilds zu beenden, nachdem es gemäß den von der Anwendung festgelegten Kriterien und Daten gestartet wurde. Beispielsweise könnte eine Anwendung mit dem Zeichnen eines großen Bilds beginnen, und der Benutzer kann den Bildlauf des Bilds durchführen. in diesem Fall kann die Anwendung die Zeichnung beenden.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code definiert zuerst eine Rückruf Methode für den <xref:System.Drawing.Graphics.DrawImageAbort> Delegaten; die Definition ist simpel und testet lediglich, ob die <xref:System.Drawing.Graphics.DrawImage%2A> Methode Sie mit einem NULL `callBackData` -Parameter aufruft. Der Hauptteil des Beispiels führt die folgenden Aktionen aus:  
  
-   Erstellt eine Instanz der <xref:System.Drawing.Graphics.DrawImageAbort> Rückruf Methode.  
  
-   Erstellt ein Bild aus einer JPEG-Datei "SampImag. jpg" im Ordner des Beispiels.  
  
-   Erstellt Punkte, die ein Ziel Rechteck definieren, in das das Bild gezeichnet werden soll.  
  
-   Erstellt ein Quell Rechteck, um den zu zeichnenden Teil des Bilds auszuwählen.  
  
-   Legt die Grafik Zeichnungs Einheit auf Pixel fest.  
  
-   Zeichnet das ursprüngliche Bild auf dem Bildschirm.  
  
-   Erstellt ein zusätzliches Ziel Rechteck, in dem ein angepasstes Bild gezeichnet werden soll.  
  
-   Erstellt und legt die Attribute des angepassten Bilds so fest, dass Sie über einen größeren, nicht üblichen Gamma Wert verfügen.  
  
-   Zeichnet das angepasste Bild auf dem Bildschirm.  
  
 Die Position des ursprünglichen, nicht angepassten Ziel Rechtecks sucht das Bild auf dem Bildschirm, und die Größe des Quell Rechtecks und die Größe und Form des Ziel Rechtecks bestimmen die Skalierung des gezeichneten Bilds.  
  
 Da in diesem Beispiel eine Überladung verwendet wird `callBackData` , die einen <xref:System.Drawing.Graphics.DrawImageAbort> -Parameter `false`übergibt, gibt der <xref:System.Drawing.Graphics.DrawImage%2A> Rückruf zurück, der bewirkt, dass die-Methode fortgesetzt wird. im Beispiel wird das angepasste Bild auf den Bildschirm gezeichnet.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#51](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#51)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#51](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#51)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#51](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#51)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> ist <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.Rectangle destRect, float srcX, float srcY, float srcWidth, float srcHeight, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Imaging.ImageAttributes imageAttrs, System.Drawing.Graphics.DrawImageAbort callback, IntPtr callbackData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.Rectangle destRect, float32 srcX, float32 srcY, float32 srcWidth, float32 srcHeight, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Imaging.ImageAttributes imageAttrs, class System.Drawing.Graphics/DrawImageAbort callback, native int callbackData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Rectangle,System.Single,System.Single,System.Single,System.Single,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort,System.IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, System::Drawing::Rectangle destRect, float srcX, float srcY, float srcWidth, float srcHeight, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Imaging::ImageAttributes ^ imageAttrs, System::Drawing::Graphics::DrawImageAbort ^ callback, IntPtr callbackData);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.Rectangle * single * single * single * single * System.Drawing.GraphicsUnit * System.Drawing.Imaging.ImageAttributes * System.Drawing.Graphics.DrawImageAbort * nativeint -&gt; unit" Usage="graphics.DrawImage (image, destRect, srcX, srcY, srcWidth, srcHeight, srcUnit, imageAttrs, callback, callbackData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcX" Type="System.Single" />
        <Parameter Name="srcY" Type="System.Single" />
        <Parameter Name="srcWidth" Type="System.Single" />
        <Parameter Name="srcHeight" Type="System.Single" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="imageAttrs" Type="System.Drawing.Imaging.ImageAttributes" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+DrawImageAbort" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="image">Der zu zeichnende <see cref="T:System.Drawing.Image" />.</param>
        <param name="destRect"><see cref="T:System.Drawing.Rectangle" />-Struktur, die die Position und Größe des gezeichneten Bildes angibt. Das Bild wird skaliert, sodass es in das Rechteck passt.</param>
        <param name="srcX">Die x-Koordinate der oberen linken Ecke des zu zeichnenden Bereichs des Quellbilds.</param>
        <param name="srcY">Die y-Koordinate der oberen linken Ecke des zu zeichnenden Bereichs des Quellbilds.</param>
        <param name="srcWidth">Breite des zu zeichnenden Bereichs des Quellbilds.</param>
        <param name="srcHeight">Höhe des zu zeichnenden Bereichs des Quellbilds.</param>
        <param name="srcUnit">Member der <see cref="T:System.Drawing.GraphicsUnit" />-Enumeration, der die Maßeinheiten angibt, mit denen das Quellrechteck bestimmt wird.</param>
        <param name="imageAttrs"><see cref="T:System.Drawing.Imaging.ImageAttributes" />, das Informationen über erneutes Einfärben und Gammainformationen für das <paramref name="image" />-Objekt angibt.</param>
        <param name="callback"><see cref="T:System.Drawing.Graphics.DrawImageAbort" />-Delegat, der eine Methode angibt, die während des Zeichnens des Bildes aufgerufen werden soll. Diese Methode wird häufig aufgerufen, um zu prüfen, ob die Ausführung der <see cref="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Rectangle,System.Single,System.Single,System.Single,System.Single,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort,System.IntPtr)" />-Methode gemäß den durch die Anwendung bestimmten Kriterien abgebrochen werden soll.</param>
        <param name="callbackData">Ein Wert, der zusätzliche Daten angibt, mit denen der <see cref="T:System.Drawing.Graphics.DrawImageAbort" />-Delegat prüfen kann, ob die Ausführung der <see langword="DrawImage" />-Methode abgebrochen werden muss.</param>
        <summary>Zeichnet den angegebenen Bereich vom angegebenen <see cref="T:System.Drawing.Image" /> in der angegebenen Größe an der angegebenen Position.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `srcX`Parameter `srcY`, ,`srcWidth` `image` und gebeneinenrechteckigenTeildeszuzeichnendenObjektsan.`srcHeight` Das Rechteck ist relativ zur linken oberen Ecke des Quell Bilds. Dieser Teil wird so skaliert, dass er in das durch `destRect` den-Parameter angegebene Rechteck passt.  
  
 Diese Überladung mit `callback` den `callbackData` Parametern und bietet die Möglichkeit, die Zeichnung eines Bilds zu beenden, nachdem es gemäß den von der Anwendung festgelegten Kriterien und Daten gestartet wurde. Beispielsweise könnte eine Anwendung mit dem Zeichnen eines großen Bilds beginnen, und der Benutzer kann den Bildlauf des Bilds durchführen. in diesem Fall kann die Anwendung die Zeichnung beenden.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code definiert zuerst eine Rückruf Methode für den <xref:System.Drawing.Graphics.DrawImageAbort> Delegaten; die Definition ist simpel und testet lediglich, ob die <xref:System.Drawing.Graphics.DrawImage%2A> Methode Sie mit einem NULL `callBackData` -Parameter aufruft. Der Hauptteil des Beispiels führt die folgenden Aktionen aus:  
  
-   Erstellt eine Instanz der <xref:System.Drawing.Graphics.DrawImageAbort> Rückruf Methode.  
  
-   Erstellt ein Bild aus einer JPEG-Datei "SampImag. jpg" im Ordner des Beispiels.  
  
-   Erstellt Punkte, die ein Ziel Rechteck definieren, in das das Bild gezeichnet werden soll.  
  
-   Erstellt ein Quell Rechteck, um den zu zeichnenden Teil des Bilds auszuwählen.  
  
-   Legt die Grafik Zeichnungs Einheit auf Pixel fest.  
  
-   Zeichnet das ursprüngliche Bild auf dem Bildschirm.  
  
-   Erstellt ein zusätzliches Ziel Rechteck, in dem ein angepasstes Bild gezeichnet werden soll.  
  
-   Erstellt und legt die Attribute des angepassten Bilds so fest, dass Sie über einen größeren, nicht üblichen Gamma Wert verfügen.  
  
-   Zeichnet das angepasste Bild auf dem Bildschirm.  
  
 Die Position des ursprünglichen, nicht angepassten Ziel Rechtecks sucht das Bild auf dem Bildschirm, und die Größe des Quell Rechtecks und die Größe und Form des Ziel Rechtecks bestimmen die Skalierung des gezeichneten Bilds.  
  
 Da in diesem Beispiel eine Überladung verwendet wird `callBackData` , die einen <xref:System.Drawing.Graphics.DrawImageAbort> -Parameter `false`übergibt, gibt der <xref:System.Drawing.Graphics.DrawImage%2A> Rückruf zurück, der bewirkt, dass die-Methode fortgesetzt wird. im Beispiel wird das angepasste Bild auf den Bildschirm gezeichnet.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#55](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#55)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#55](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#55)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#55](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#55)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> ist <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawImageUnscaled">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zeichnet das angegebene Bild in seiner ursprünglichen physischen Größe an der von einem Koordinatenpaar angegebenen Position.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawImageUnscaled">
      <MemberSignature Language="C#" Value="public void DrawImageUnscaled (System.Drawing.Image image, System.Drawing.Point point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImageUnscaled(class System.Drawing.Image image, valuetype System.Drawing.Point point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImageUnscaled(System.Drawing.Image,System.Drawing.Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImageUnscaled(System::Drawing::Image ^ image, System::Drawing::Point point);" />
      <MemberSignature Language="F#" Value="member this.DrawImageUnscaled : System.Drawing.Image * System.Drawing.Point -&gt; unit" Usage="graphics.DrawImageUnscaled (image, point)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="point" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="image">Der zu zeichnende <see cref="T:System.Drawing.Image" />.</param>
        <param name="point"><see cref="T:System.Drawing.Point" />-Struktur, die die linke obere Ecke des gezeichneten Bildes angibt.</param>
        <summary>Zeichnet ein angegebenes Bild in seiner ursprünglichen physischen Größe an einer angegebenen Position.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Drawing.Image> speichert einen Wert für die Pixel Breite und einen Wert für die horizontale Auflösung (Punkte pro Zoll). Die physische Breite eines Bilds, gemessen in Zoll, ist die Pixel Breite dividiert durch die horizontale Auflösung. Beispielsweise hat ein Bild mit einer Pixel Breite von 216 und eine horizontale Auflösung von 72 Punkten pro Zoll eine physische Breite von 3 Zoll. Ähnliche Hinweise gelten für die Pixel Höhe und die physische Höhe.  
  
 Mit <xref:System.Drawing.Graphics.DrawImageUnscaled%2A> der-Methode wird ein Bild mit der physischen Größe gezeichnet, sodass das Bild unabhängig von der Auflösung (Punkte pro Zoll) des Anzeige Geräts in Zoll korrekt ist. Angenommen, ein Bild hat eine Pixel Breite von 216 und eine horizontale Auflösung von 72 Punkten pro Zoll. Wenn Sie aufrufen <xref:System.Drawing.Graphics.DrawImageUnscaled%2A> , um dieses Bild auf einem Gerät mit einer Auflösung von 96 Punkten pro Zoll zu zeichnen, ist die Pixel Breite des gerenderten Bilds (216/72) * 96 = 288.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein Bild aus einer JPEG-Datei "SampImag. jpg" im Ordner des Beispiels.  
  
-   Erstellt einen Punkt, an dem die obere linke Ecke des Bilds gezeichnet werden soll.  
  
-   Zeichnet das gesamte Bild mithilfe der physischen Größe.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#64](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#64)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#64](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#64)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#64](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#64)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawImageUnscaled">
      <MemberSignature Language="C#" Value="public void DrawImageUnscaled (System.Drawing.Image image, System.Drawing.Rectangle rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImageUnscaled(class System.Drawing.Image image, valuetype System.Drawing.Rectangle rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImageUnscaled(System.Drawing.Image,System.Drawing.Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImageUnscaled(System::Drawing::Image ^ image, System::Drawing::Rectangle rect);" />
      <MemberSignature Language="F#" Value="member this.DrawImageUnscaled : System.Drawing.Image * System.Drawing.Rectangle -&gt; unit" Usage="graphics.DrawImageUnscaled (image, rect)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="image">Der zu zeichnende <see cref="T:System.Drawing.Image" />.</param>
        <param name="rect"><see cref="T:System.Drawing.Rectangle" />-Struktur, die die linke obere Ecke des gezeichneten Bildes angibt. Die X-Eigenschaft und die Y-Eigenschaft des Rechtecks geben die linke obere Ecke an. Die Width-Eigenschaft und die Height-Eigenschaft werden ignoriert.</param>
        <summary>Zeichnet ein angegebenes Bild in seiner ursprünglichen physischen Größe an einer angegebenen Position.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Drawing.Image> speichert einen Wert für die Pixel Breite und einen Wert für die horizontale Auflösung (Punkte pro Zoll). Die physische Breite eines Bilds, gemessen in Zoll, ist die Pixel Breite dividiert durch die horizontale Auflösung. Beispielsweise hat ein Bild mit einer Pixel Breite von 216 und eine horizontale Auflösung von 72 Punkten pro Zoll eine physische Breite von 3 Zoll. Ähnliche Hinweise gelten für die Pixel Höhe und die physische Höhe.  
  
 Mit <xref:System.Drawing.Graphics.DrawImageUnscaled%2A> der-Methode wird ein Bild mit der physischen Größe gezeichnet, sodass das Bild unabhängig von der Auflösung (Punkte pro Zoll) des Anzeige Geräts in Zoll korrekt ist. Angenommen, ein Bild hat eine Pixel Breite von 216 und eine horizontale Auflösung von 72 Punkten pro Zoll. Wenn Sie aufrufen <xref:System.Drawing.Graphics.DrawImageUnscaled%2A> , um dieses Bild auf einem Gerät mit einer Auflösung von 96 Punkten pro Zoll zu zeichnen, ist die Pixel Breite des gerenderten Bilds (216/72) * 96 = 288.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawImageUnscaled">
      <MemberSignature Language="C#" Value="public void DrawImageUnscaled (System.Drawing.Image image, int x, int y);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImageUnscaled(class System.Drawing.Image image, int32 x, int32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImageUnscaled(System.Drawing.Image,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImageUnscaled(System::Drawing::Image ^ image, int x, int y);" />
      <MemberSignature Language="F#" Value="member this.DrawImageUnscaled : System.Drawing.Image * int * int -&gt; unit" Usage="graphics.DrawImageUnscaled (image, x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="image">Der zu zeichnende <see cref="T:System.Drawing.Image" />.</param>
        <param name="x">Die x-Koordinate der oberen linken Ecke des gezeichneten Bilds.</param>
        <param name="y">Die y-Koordinate der oberen linken Ecke des gezeichneten Bilds.</param>
        <summary>Zeichnet das angegebene Bild in seiner ursprünglichen physischen Größe an der von einem Koordinatenpaar angegebenen Position.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Drawing.Image> speichert einen Wert für die Pixel Breite und einen Wert für die horizontale Auflösung (Punkte pro Zoll). Die physische Breite eines Bilds, gemessen in Zoll, ist die Pixel Breite dividiert durch die horizontale Auflösung. Beispielsweise hat ein Bild mit einer Pixel Breite von 216 und eine horizontale Auflösung von 72 Punkten pro Zoll eine physische Breite von 3 Zoll. Ähnliche Hinweise gelten für die Pixel Höhe und die physische Höhe.  
  
 Mit <xref:System.Drawing.Graphics.DrawImageUnscaled%2A> der-Methode wird ein Bild mit der physischen Größe gezeichnet, sodass das Bild unabhängig von der Auflösung (Punkte pro Zoll) des Anzeige Geräts in Zoll korrekt ist. Angenommen, ein Bild hat eine Pixel Breite von 216 und eine horizontale Auflösung von 72 Punkten pro Zoll. Wenn Sie aufrufen <xref:System.Drawing.Graphics.DrawImageUnscaled%2A> , um dieses Bild auf einem Gerät mit einer Auflösung von 96 Punkten pro Zoll zu zeichnen, ist die Pixel Breite des gerenderten Bilds (216/72) * 96 = 288.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein Bild aus einer JPEG-Datei, SampImag. jpg, im Ordner des Beispiels.  
  
-   Erstellt einen Punkt, an dem die obere linke Ecke des Bilds gezeichnet werden soll.  
  
-   Zeichnet das gesamte Bild mithilfe der physischen Größe.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#65](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#65)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#65](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#65)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#65](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#65)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawImageUnscaled">
      <MemberSignature Language="C#" Value="public void DrawImageUnscaled (System.Drawing.Image image, int x, int y, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImageUnscaled(class System.Drawing.Image image, int32 x, int32 y, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImageUnscaled(System.Drawing.Image,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImageUnscaled(System::Drawing::Image ^ image, int x, int y, int width, int height);" />
      <MemberSignature Language="F#" Value="member this.DrawImageUnscaled : System.Drawing.Image * int * int * int * int -&gt; unit" Usage="graphics.DrawImageUnscaled (image, x, y, width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="image">Der zu zeichnende <see cref="T:System.Drawing.Image" />.</param>
        <param name="x">Die x-Koordinate der oberen linken Ecke des gezeichneten Bilds.</param>
        <param name="y">Die y-Koordinate der oberen linken Ecke des gezeichneten Bilds.</param>
        <param name="width">Nicht verwendet.</param>
        <param name="height">Nicht verwendet.</param>
        <summary>Zeichnet ein angegebenes Bild in seiner ursprünglichen physischen Größe an einer angegebenen Position.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Drawing.Image> speichert einen Wert für die Pixel Breite und einen Wert für die horizontale Auflösung (Punkte pro Zoll). Die physische Breite eines Bilds, gemessen in Zoll, ist die Pixel Breite dividiert durch die horizontale Auflösung. Beispielsweise hat ein Bild mit einer Pixel Breite von 216 und eine horizontale Auflösung von 72 Punkten pro Zoll eine physische Breite von 3 Zoll. Ähnliche Hinweise gelten für die Pixel Höhe und die physische Höhe.  
  
 Mit <xref:System.Drawing.Graphics.DrawImageUnscaled%2A> der-Methode wird ein Bild mit der physischen Größe gezeichnet, sodass das Bild unabhängig von der Auflösung (Punkte pro Zoll) des Anzeige Geräts in Zoll korrekt ist. Angenommen, ein Bild hat eine Pixel Breite von 216 und eine horizontale Auflösung von 72 Punkten pro Zoll. Wenn Sie aufrufen <xref:System.Drawing.Graphics.DrawImageUnscaled%2A> , um dieses Bild auf einem Gerät mit einer Auflösung von 96 Punkten pro Zoll zu zeichnen, ist die Pixel Breite des gerenderten Bilds (216/72) * 96 = 288.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawImageUnscaledAndClipped">
      <MemberSignature Language="C#" Value="public void DrawImageUnscaledAndClipped (System.Drawing.Image image, System.Drawing.Rectangle rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImageUnscaledAndClipped(class System.Drawing.Image image, valuetype System.Drawing.Rectangle rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImageUnscaledAndClipped(System.Drawing.Image,System.Drawing.Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImageUnscaledAndClipped(System::Drawing::Image ^ image, System::Drawing::Rectangle rect);" />
      <MemberSignature Language="F#" Value="member this.DrawImageUnscaledAndClipped : System.Drawing.Image * System.Drawing.Rectangle -&gt; unit" Usage="graphics.DrawImageUnscaledAndClipped (image, rect)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="rect" Type="System.Drawing.Rectangle" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="image">Das zu zeichnende <see cref="T:System.Drawing.Image" />.</param>
        <param name="rect">Das <see cref="T:System.Drawing.Rectangle" />, in dem das Bild gezeichnet werden soll.</param>
        <summary>Zeichnet das angegebene Bild ohne Skalierung und beschneidet es ggf. auf die Größe des angegebenen Rechtecks.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird die Verwendung der <xref:System.Drawing.Graphics.DrawImageUnscaledAndClipped%2A>-Methode veranschaulicht. Fügen Sie es in ein Windows Form ein, um dieses Beispiel auszuführen. Behandeln Sie das- <xref:System.Windows.Forms.Control.Paint> Ereignis des Formulars, `DrawImageUnscaled` und wenden Sie <xref:System.Windows.Forms.Control.Paint> die-Methode aus der Ereignis `e` Behandlungs <xref:System.Windows.Forms.PaintEventArgs>Methode an, indem Sie als übergeben.  
  
 [!code-csharp[System.Drawing.MiscWhidbeySnippets#8](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.MiscWhidbeySnippets/CS/Form1.cs#8)]
 [!code-vb[System.Drawing.MiscWhidbeySnippets#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.MiscWhidbeySnippets/VB/Form1.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawLine">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zeichnet eine verbindende Linie zwischen den beiden durch Koordinatenpaare angegebenen Punkten.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawLine">
      <MemberSignature Language="C#" Value="public void DrawLine (System.Drawing.Pen pen, System.Drawing.Point pt1, System.Drawing.Point pt2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawLine(class System.Drawing.Pen pen, valuetype System.Drawing.Point pt1, valuetype System.Drawing.Point pt2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawLine(System.Drawing.Pen,System.Drawing.Point,System.Drawing.Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawLine(System::Drawing::Pen ^ pen, System::Drawing::Point pt1, System::Drawing::Point pt2);" />
      <MemberSignature Language="F#" Value="member this.DrawLine : System.Drawing.Pen * System.Drawing.Point * System.Drawing.Point -&gt; unit" Usage="graphics.DrawLine (pen, pt1, pt2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="pt1" Type="System.Drawing.Point" />
        <Parameter Name="pt2" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" />, der die Farbe, Breite und den Stil der Linie bestimmt.</param>
        <param name="pt1"><see cref="T:System.Drawing.Point" />-Struktur, die den ersten zu verbindenden Punkt darstellt.</param>
        <param name="pt2"><see cref="T:System.Drawing.Point" />-Struktur, die den zweiten zu verbindenden Punkt darstellt.</param>
        <summary>Zeichnet eine verbindende Linie zwischen zwei <see cref="T:System.Drawing.Point" />-Strukturen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen schwarzen Stift.  
  
-   Erstellt Punkte für die Endpunkte der Zeile.  
  
-   Zeichnet die Linie auf dem Bildschirm.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#66](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#66)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#66](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#66)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#66](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#66)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> ist <see langword="null" />.</exception>
        <related type="Article" href="~/docs/framework/winforms/advanced/using-a-pen-to-draw-lines-and-shapes.md">Verwenden eines Stiftes zum Zeichnen von Linien und Formen</related>
      </Docs>
    </Member>
    <Member MemberName="DrawLine">
      <MemberSignature Language="C#" Value="public void DrawLine (System.Drawing.Pen pen, System.Drawing.PointF pt1, System.Drawing.PointF pt2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawLine(class System.Drawing.Pen pen, valuetype System.Drawing.PointF pt1, valuetype System.Drawing.PointF pt2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawLine(System.Drawing.Pen,System.Drawing.PointF,System.Drawing.PointF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawLine(System::Drawing::Pen ^ pen, System::Drawing::PointF pt1, System::Drawing::PointF pt2);" />
      <MemberSignature Language="F#" Value="member this.DrawLine : System.Drawing.Pen * System.Drawing.PointF * System.Drawing.PointF -&gt; unit" Usage="graphics.DrawLine (pen, pt1, pt2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="pt1" Type="System.Drawing.PointF" />
        <Parameter Name="pt2" Type="System.Drawing.PointF" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" />, der die Farbe, Breite und den Stil der Linie bestimmt.</param>
        <param name="pt1"><see cref="T:System.Drawing.PointF" />-Struktur, die den ersten zu verbindenden Punkt darstellt.</param>
        <param name="pt2"><see cref="T:System.Drawing.PointF" />-Struktur, die den zweiten zu verbindenden Punkt darstellt.</param>
        <summary>Zeichnet eine verbindende Linie zwischen zwei <see cref="T:System.Drawing.PointF" />-Strukturen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zeichnet eine Linie, die die beiden von den `pt1` `2` Parametern und angegebenen Punkte verbindet.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen schwarzen Stift.  
  
-   Erstellt Punkte für die Endpunkte der Zeile.  
  
-   Zeichnet die Linie auf dem Bildschirm.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#67](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#67)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#67](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#67)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#67](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#67)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> ist <see langword="null" />.</exception>
        <related type="Article" href="~/docs/framework/winforms/advanced/using-a-pen-to-draw-lines-and-shapes.md">Verwenden eines Stiftes zum Zeichnen von Linien und Formen</related>
      </Docs>
    </Member>
    <Member MemberName="DrawLine">
      <MemberSignature Language="C#" Value="public void DrawLine (System.Drawing.Pen pen, int x1, int y1, int x2, int y2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawLine(class System.Drawing.Pen pen, int32 x1, int32 y1, int32 x2, int32 y2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawLine(System.Drawing.Pen,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawLine(System::Drawing::Pen ^ pen, int x1, int y1, int x2, int y2);" />
      <MemberSignature Language="F#" Value="member this.DrawLine : System.Drawing.Pen * int * int * int * int -&gt; unit" Usage="graphics.DrawLine (pen, x1, y1, x2, y2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="x1" Type="System.Int32" />
        <Parameter Name="y1" Type="System.Int32" />
        <Parameter Name="x2" Type="System.Int32" />
        <Parameter Name="y2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" />, der die Farbe, Breite und den Stil der Linie bestimmt.</param>
        <param name="x1">Die x-Koordinate des ersten Punkts.</param>
        <param name="y1">Die y-Koordinate des ersten Punkts.</param>
        <param name="x2">Die x-Koordinate des zweiten Punkts.</param>
        <param name="y2">Die y-Koordinate des zweiten Punkts.</param>
        <summary>Zeichnet eine verbindende Linie zwischen den beiden durch Koordinatenpaare angegebenen Punkten.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zeichnet eine Linie, die die beiden von den `x1`Parametern, `x2` `y1`, und `y2` angegebenen Punkte verbindet.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen schwarzen Stift.  
  
-   Erstellt die Koordinaten der Endpunkte der Linie.  
  
-   Zeichnet die Linie auf dem Bildschirm.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#68](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#68)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#68](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#68)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#68](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> ist <see langword="null" />.</exception>
        <related type="Article" href="~/docs/framework/winforms/advanced/using-a-pen-to-draw-lines-and-shapes.md">Verwenden eines Stiftes zum Zeichnen von Linien und Formen</related>
      </Docs>
    </Member>
    <Member MemberName="DrawLine">
      <MemberSignature Language="C#" Value="public void DrawLine (System.Drawing.Pen pen, float x1, float y1, float x2, float y2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawLine(class System.Drawing.Pen pen, float32 x1, float32 y1, float32 x2, float32 y2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawLine(System.Drawing.Pen,System.Single,System.Single,System.Single,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawLine(System::Drawing::Pen ^ pen, float x1, float y1, float x2, float y2);" />
      <MemberSignature Language="F#" Value="member this.DrawLine : System.Drawing.Pen * single * single * single * single -&gt; unit" Usage="graphics.DrawLine (pen, x1, y1, x2, y2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="x1" Type="System.Single" />
        <Parameter Name="y1" Type="System.Single" />
        <Parameter Name="x2" Type="System.Single" />
        <Parameter Name="y2" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" />, der die Farbe, Breite und den Stil der Linie bestimmt.</param>
        <param name="x1">Die x-Koordinate des ersten Punkts.</param>
        <param name="y1">Die y-Koordinate des ersten Punkts.</param>
        <param name="x2">Die x-Koordinate des zweiten Punkts.</param>
        <param name="y2">Die y-Koordinate des zweiten Punkts.</param>
        <summary>Zeichnet eine verbindende Linie zwischen den beiden durch Koordinatenpaare angegebenen Punkten.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zeichnet eine Linie, die die beiden von den `x1`Parametern, `x2` `y1`, und `y2` angegebenen Punkte verbindet.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen schwarzen Stift.  
  
-   Erstellt die Koordinaten der Endpunkte der Linie.  
  
-   Zeichnet die Linie auf dem Bildschirm.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#69](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#69)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#69](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#69)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#69](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#69)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> ist <see langword="null" />.</exception>
        <related type="Article" href="~/docs/framework/winforms/advanced/using-a-pen-to-draw-lines-and-shapes.md">Verwenden eines Stiftes zum Zeichnen von Linien und Formen</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawLines">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zeichnet eine Reihe von Liniensegmenten, die ein Array von <see cref="T:System.Drawing.Point" />-Strukturen verbinden.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawLines">
      <MemberSignature Language="C#" Value="public void DrawLines (System.Drawing.Pen pen, System.Drawing.Point[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawLines(class System.Drawing.Pen pen, valuetype System.Drawing.Point[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawLines(System.Drawing.Pen,System.Drawing.Point[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawLines(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::Point&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.DrawLines : System.Drawing.Pen * System.Drawing.Point[] -&gt; unit" Usage="graphics.DrawLines (pen, points)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="points" Type="System.Drawing.Point[]" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" />, der die Farbe, Breite und den Stil der Linie bestimmt.</param>
        <param name="points">Array von <see cref="T:System.Drawing.Point" />-Strukturen, die die zu verbindenden Punkte darstellen.</param>
        <summary>Zeichnet eine Reihe von Liniensegmenten, die ein Array von <see cref="T:System.Drawing.Point" />-Strukturen verbinden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zeichnet eine Reihe von Zeilen, die ein Array von Endpunkten verbinden. Die ersten beiden Punkte im Array geben die erste Zeile an. Jeder zusätzliche Punkt gibt das Ende eines Linien Segments an, dessen Anfangspunkt der Endpunkt des vorherigen Linien Segments ist.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen schwarzen Stift.  
  
-   Erstellt ein Array von Punkten von Segmenten der Zeile.  
  
-   Zeichnet die verbundenen Liniensegmente mit dem Bildschirm.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#70](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#70)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#70](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#70)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#70](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#70)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="points" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawLines">
      <MemberSignature Language="C#" Value="public void DrawLines (System.Drawing.Pen pen, System.Drawing.PointF[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawLines(class System.Drawing.Pen pen, valuetype System.Drawing.PointF[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawLines(System.Drawing.Pen,System.Drawing.PointF[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawLines(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::PointF&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.DrawLines : System.Drawing.Pen * System.Drawing.PointF[] -&gt; unit" Usage="graphics.DrawLines (pen, points)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" />, der die Farbe, Breite und den Stil der Linie bestimmt.</param>
        <param name="points">Array von <see cref="T:System.Drawing.PointF" />-Strukturen, die die zu verbindenden Punkte darstellen.</param>
        <summary>Zeichnet eine Reihe von Liniensegmenten, die ein Array von <see cref="T:System.Drawing.PointF" />-Strukturen verbinden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zeichnet eine Reihe von Zeilen, die ein Array von Endpunkten verbinden. Die ersten beiden Punkte im Array geben die erste Zeile an. Jeder zusätzliche Punkt gibt das Ende eines Linien Segments an, dessen Anfangspunkt der Endpunkt des vorherigen Linien Segments ist.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Code erstellt einen schwarzen Stift.  
  
-   Erstellt ein Array von Punkten von Segmenten der Zeile.  
  
-   Zeichnet die verbundenen Liniensegmente mit dem Bildschirm.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#71](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#71)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#71](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#71)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#71](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#71)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="points" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawPath">
      <MemberSignature Language="C#" Value="public void DrawPath (System.Drawing.Pen pen, System.Drawing.Drawing2D.GraphicsPath path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawPath(class System.Drawing.Pen pen, class System.Drawing.Drawing2D.GraphicsPath path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawPath(System.Drawing.Pen,System.Drawing.Drawing2D.GraphicsPath)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawPath(System::Drawing::Pen ^ pen, System::Drawing::Drawing2D::GraphicsPath ^ path);" />
      <MemberSignature Language="F#" Value="member this.DrawPath : System.Drawing.Pen * System.Drawing.Drawing2D.GraphicsPath -&gt; unit" Usage="graphics.DrawPath (pen, path)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="path" Type="System.Drawing.Drawing2D.GraphicsPath" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" />, der die Farbe, Breite und den Stil des Pfads bestimmt.</param>
        <param name="path">Der zu zeichnende <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</param>
        <summary>Zeichnet einen <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die aktuelle Transformation im grafischen Kontext wird auf das <xref:System.Drawing.Drawing2D.GraphicsPath> angewendet, bevor Sie gezeichnet wird.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein Grafik Pfad Objekt und fügt ihm eine Ellipse hinzu.  
  
-   Erstellt einen schwarzen Stift.  
  
-   Zeichnet den Grafik Pfad auf dem Bildschirm.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#72](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#72)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#72](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#72)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#72](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#72)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="path" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawPie">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zeichnet eine durch eine Ellipse, die durch ein Koordinatenpaar, eine Breiten- und eine Höhenangabe und zwei Radien angegeben ist, definierte Kreisform.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawPie">
      <MemberSignature Language="C#" Value="public void DrawPie (System.Drawing.Pen pen, System.Drawing.Rectangle rect, float startAngle, float sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawPie(class System.Drawing.Pen pen, valuetype System.Drawing.Rectangle rect, float32 startAngle, float32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawPie(System.Drawing.Pen,System.Drawing.Rectangle,System.Single,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawPie(System::Drawing::Pen ^ pen, System::Drawing::Rectangle rect, float startAngle, float sweepAngle);" />
      <MemberSignature Language="F#" Value="member this.DrawPie : System.Drawing.Pen * System.Drawing.Rectangle * single * single -&gt; unit" Usage="graphics.DrawPie (pen, rect, startAngle, sweepAngle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
        <Parameter Name="startAngle" Type="System.Single" />
        <Parameter Name="sweepAngle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" />, der die Farbe, die Breite und den Stil der Kreisform bestimmt.</param>
        <param name="rect"><see cref="T:System.Drawing.Rectangle" />-Struktur, die das umschließende Rechteck darstellt, das die Ellipse definiert, aus der die Kreisform stammt.</param>
        <param name="startAngle">Zwischen der x-Achse und der ersten Seite der Kreisform im Uhrzeigersinn gemessener Winkel in Grad.</param>
        <param name="sweepAngle">Zwischen dem <paramref name="startAngle" />-Parameter und der zweiten Seite der Kreisform im Uhrzeigersinn gemessener Winkel in Grad.</param>
        <summary>Zeichnet eine Kreisform, die von einer Ellipse definiert wird, die ihrerseits durch eine <see cref="T:System.Drawing.Rectangle" />-Struktur und zwei Radien angegeben ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zeichnet eine Kreisform, die durch einen Bogen einer Ellipse definiert wird, und die beiden radialen Linien, die sich mit den Endpunkten des Bogens überschneiden. Die Ellipse wird durch das umgebende Rechteck definiert. Die Kreis Form besteht aus den beiden radialen Linien, die `startAngle` durch `sweepAngle` die Parameter und definiert werden, und dem Bogen zwischen den Schnittpunkten dieser radialen Linien und der Ellipse.  
  
 Wenn der `sweepAngle` -Parameter größer als 360 Grad oder kleiner als-360 Grad ist, wird er so behandelt, als wäre er 360 Grad bzw.-360 Grad.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen schwarzen Stift.  
  
-   Erstellt ein Rechteck, das eine komplette Ellipse umschließt.  
  
-   Definiert die Winkel, bei denen mit dem zeichnen begonnen werden soll (relativ zur x-Achse) und durch die gezeichnet werden soll (in Richtung des Uhrzeigersinn).  
  
-   Zeichnet das Kreis Segment auf dem Bildschirm.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#73](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#73)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#73](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#73)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#73](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#73)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawPie">
      <MemberSignature Language="C#" Value="public void DrawPie (System.Drawing.Pen pen, System.Drawing.RectangleF rect, float startAngle, float sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawPie(class System.Drawing.Pen pen, valuetype System.Drawing.RectangleF rect, float32 startAngle, float32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawPie(System.Drawing.Pen,System.Drawing.RectangleF,System.Single,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawPie(System::Drawing::Pen ^ pen, System::Drawing::RectangleF rect, float startAngle, float sweepAngle);" />
      <MemberSignature Language="F#" Value="member this.DrawPie : System.Drawing.Pen * System.Drawing.RectangleF * single * single -&gt; unit" Usage="graphics.DrawPie (pen, rect, startAngle, sweepAngle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="rect" Type="System.Drawing.RectangleF" />
        <Parameter Name="startAngle" Type="System.Single" />
        <Parameter Name="sweepAngle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" />, der die Farbe, die Breite und den Stil der Kreisform bestimmt.</param>
        <param name="rect"><see cref="T:System.Drawing.RectangleF" />-Struktur, die das umschließende Rechteck darstellt, das die Ellipse definiert, aus der die Kreisform stammt.</param>
        <param name="startAngle">Zwischen der x-Achse und der ersten Seite der Kreisform im Uhrzeigersinn gemessener Winkel in Grad.</param>
        <param name="sweepAngle">Zwischen dem <paramref name="startAngle" />-Parameter und der zweiten Seite der Kreisform im Uhrzeigersinn gemessener Winkel in Grad.</param>
        <summary>Zeichnet eine Kreisform, die von einer Ellipse definiert wird, die ihrerseits durch eine <see cref="T:System.Drawing.RectangleF" />-Struktur und zwei Radien angegeben ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zeichnet eine Kreisform, die durch einen Bogen einer Ellipse definiert wird, und die beiden radialen Linien, die sich mit den Endpunkten des Bogens überschneiden. Die Ellipse wird durch das umgebende Rechteck definiert. Die Kreis Form besteht aus den beiden radialen Linien, die `startAngle` durch `sweepAngle` die Parameter und definiert werden, und dem Bogen zwischen den Schnittpunkten dieser radialen Linien und der Ellipse.  
  
 Wenn der `sweepAngle` -Parameter größer als 360 Grad oder kleiner als-360 Grad ist, wird er so behandelt, als wäre er 360 Grad bzw.-360 Grad.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen schwarzen Stift.  
  
-   Erstellt ein Rechteck, das eine komplette Ellipse umschließt.  
  
-   Definiert die Winkel, bei denen mit dem zeichnen begonnen werden soll (relativ zur x-Achse) und durch die gezeichnet werden soll (in Richtung des Uhrzeigersinn).  
  
-   Zeichnet das Kreis Segment auf dem Bildschirm.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#74](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#74)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#74](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#74)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#74](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#74)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawPie">
      <MemberSignature Language="C#" Value="public void DrawPie (System.Drawing.Pen pen, int x, int y, int width, int height, int startAngle, int sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawPie(class System.Drawing.Pen pen, int32 x, int32 y, int32 width, int32 height, int32 startAngle, int32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawPie(System.Drawing.Pen,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawPie(System::Drawing::Pen ^ pen, int x, int y, int width, int height, int startAngle, int sweepAngle);" />
      <MemberSignature Language="F#" Value="member this.DrawPie : System.Drawing.Pen * int * int * int * int * int * int -&gt; unit" Usage="graphics.DrawPie (pen, x, y, width, height, startAngle, sweepAngle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
        <Parameter Name="startAngle" Type="System.Int32" />
        <Parameter Name="sweepAngle" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" />, der die Farbe, die Breite und den Stil der Kreisform bestimmt.</param>
        <param name="x">Die x-Koordinate der oberen linken Ecke des umschließenden Rechtecks, das die Ellipse definiert, aus der die Kreisform stammt.</param>
        <param name="y">Die y-Koordinate der oberen linken Ecke des umschließenden Rechtecks, das die Ellipse definiert, aus der die Kreisform stammt.</param>
        <param name="width">Breite des umschließenden Rechtecks, das die Ellipse definiert, aus der die Kreisform stammt.</param>
        <param name="height">Höhe des umschließenden Rechtecks, das die Ellipse definiert, aus der die Kreisform stammt.</param>
        <param name="startAngle">Zwischen der x-Achse und der ersten Seite der Kreisform im Uhrzeigersinn gemessener Winkel in Grad.</param>
        <param name="sweepAngle">Zwischen dem <paramref name="startAngle" />-Parameter und der zweiten Seite der Kreisform im Uhrzeigersinn gemessener Winkel in Grad.</param>
        <summary>Zeichnet eine durch eine Ellipse, die durch ein Koordinatenpaar, eine Breiten- und eine Höhenangabe und zwei Radien angegeben ist, definierte Kreisform.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zeichnet eine Kreisform, die durch einen Bogen einer Ellipse definiert wird, und die beiden radialen Linien, die sich mit den Endpunkten des Bogens überschneiden. Die Ellipse wird durch das Begrenzungs Rechteck definiert, das durch `x`die `y`Parameter `width`,, `height` und beschrieben wird. Die Kreis Form besteht aus den beiden radialen Linien, die `startAngle` durch `sweepAngle` die Parameter und definiert werden, und dem Bogen zwischen den Schnittpunkten dieser radialen Linien und der Ellipse.  
  
 Wenn der `sweepAngle` -Parameter größer als 360 Grad oder kleiner als-360 Grad ist, wird er so behandelt, als wäre er 360 Grad bzw.-360 Grad.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen schwarzen Stift.  
  
-   Erstellt die Position und Größe eines Rechtecks, das eine komplette Ellipse umschließt.  
  
-   Definiert die Winkel, bei denen mit dem zeichnen begonnen werden soll (relativ zur x-Achse) und durch die gezeichnet werden soll (in Richtung des Uhrzeigersinn).  
  
-   Zeichnet die Kreisform auf dem Bildschirm.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#75](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#75)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#75](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#75)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#75](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#75)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawPie">
      <MemberSignature Language="C#" Value="public void DrawPie (System.Drawing.Pen pen, float x, float y, float width, float height, float startAngle, float sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawPie(class System.Drawing.Pen pen, float32 x, float32 y, float32 width, float32 height, float32 startAngle, float32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawPie(System.Drawing.Pen,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawPie(System::Drawing::Pen ^ pen, float x, float y, float width, float height, float startAngle, float sweepAngle);" />
      <MemberSignature Language="F#" Value="member this.DrawPie : System.Drawing.Pen * single * single * single * single * single * single -&gt; unit" Usage="graphics.DrawPie (pen, x, y, width, height, startAngle, sweepAngle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="width" Type="System.Single" />
        <Parameter Name="height" Type="System.Single" />
        <Parameter Name="startAngle" Type="System.Single" />
        <Parameter Name="sweepAngle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" />, der die Farbe, die Breite und den Stil der Kreisform bestimmt.</param>
        <param name="x">Die x-Koordinate der oberen linken Ecke des umschließenden Rechtecks, das die Ellipse definiert, aus der die Kreisform stammt.</param>
        <param name="y">Die y-Koordinate der oberen linken Ecke des umschließenden Rechtecks, das die Ellipse definiert, aus der die Kreisform stammt.</param>
        <param name="width">Breite des umschließenden Rechtecks, das die Ellipse definiert, aus der die Kreisform stammt.</param>
        <param name="height">Höhe des umschließenden Rechtecks, das die Ellipse definiert, aus der die Kreisform stammt.</param>
        <param name="startAngle">Zwischen der x-Achse und der ersten Seite der Kreisform im Uhrzeigersinn gemessener Winkel in Grad.</param>
        <param name="sweepAngle">Zwischen dem <paramref name="startAngle" />-Parameter und der zweiten Seite der Kreisform im Uhrzeigersinn gemessener Winkel in Grad.</param>
        <summary>Zeichnet eine durch eine Ellipse, die durch ein Koordinatenpaar, eine Breiten- und eine Höhenangabe und zwei Radien angegeben ist, definierte Kreisform.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zeichnet eine Kreisform, die durch einen Bogen einer Ellipse definiert wird, und die beiden radialen Linien, die sich mit den Endpunkten des Bogens überschneiden. Die Ellipse wird durch das Begrenzungs Rechteck definiert, das durch `x`die `y`Parameter `width`,, `height` und beschrieben wird. Die Kreis Form besteht aus den beiden radialen Linien, die `startAngle` durch `sweepAngle` die Parameter und definiert werden, und dem Bogen zwischen den Schnittpunkten dieser radialen Linien und der Ellipse.  
  
 Wenn der `sweepAngle` -Parameter größer als 360 Grad oder kleiner als-360 Grad ist, wird er so behandelt, als wäre er 360 Grad bzw.-360 Grad.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen schwarzen Stift.  
  
-   Erstellt die Position und Größe eines Rechtecks, das eine komplette Ellipse umschließt.  
  
-   Definiert die Winkel, bei denen mit dem zeichnen begonnen werden soll (relativ zur x-Achse) und durch die gezeichnet werden soll (in Richtung des Uhrzeigersinn).  
  
-   Zeichnet das Kreis Segment auf dem Bildschirm.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#76](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#76)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#76](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#76)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#76](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#76)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawPolygon">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zeichnet ein Vieleck, das durch ein Array von <see cref="T:System.Drawing.Point" />-Strukturen definiert ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawPolygon">
      <MemberSignature Language="C#" Value="public void DrawPolygon (System.Drawing.Pen pen, System.Drawing.Point[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawPolygon(class System.Drawing.Pen pen, valuetype System.Drawing.Point[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawPolygon(System.Drawing.Pen,System.Drawing.Point[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawPolygon(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::Point&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.DrawPolygon : System.Drawing.Pen * System.Drawing.Point[] -&gt; unit" Usage="graphics.DrawPolygon (pen, points)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="points" Type="System.Drawing.Point[]" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" />, der die Farbe, Breite und den Stil des Vielecks bestimmt.</param>
        <param name="points">Array von <see cref="T:System.Drawing.Point" />-Strukturen, die die Eckpunkte des Vielecks darstellen.</param>
        <summary>Zeichnet ein Vieleck, das durch ein Array von <see cref="T:System.Drawing.Point" />-Strukturen definiert ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jedes Paar von zwei aufeinander folgenden Punkten im Array gibt eine Seite des Polygons an. Wenn der letzte Punkt und der erste Punkt des Arrays nicht übereinstimmen, wird außerdem die letzte Seite des Polygons angegeben.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen schwarzen Stift.  
  
-   Erstellt ein Array von sieben Punkten für die Scheitel Punkte des Polygons.  
  
-   Zeichnet das Polygon auf dem Bildschirm.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#78](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#78)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#78](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#78)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#78](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#78)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawPolygon">
      <MemberSignature Language="C#" Value="public void DrawPolygon (System.Drawing.Pen pen, System.Drawing.PointF[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawPolygon(class System.Drawing.Pen pen, valuetype System.Drawing.PointF[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawPolygon(System.Drawing.Pen,System.Drawing.PointF[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawPolygon(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::PointF&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.DrawPolygon : System.Drawing.Pen * System.Drawing.PointF[] -&gt; unit" Usage="graphics.DrawPolygon (pen, points)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" />, der die Farbe, Breite und den Stil des Vielecks bestimmt.</param>
        <param name="points">Array von <see cref="T:System.Drawing.PointF" />-Strukturen, die die Eckpunkte des Vielecks darstellen.</param>
        <summary>Zeichnet ein Vieleck, das durch ein Array von <see cref="T:System.Drawing.PointF" />-Strukturen definiert ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jedes Paar von zwei aufeinander folgenden Punkten im Array gibt eine Seite des Polygons an. Wenn der letzte Punkt und der erste des Array Punkts nicht übereinstimmen, wird außerdem die letzte Seite des Polygons angegeben.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen schwarzen Stift.  
  
-   Erstellt ein Array von sieben Punkten für die Scheitel Punkte des Polygons.  
  
-   Zeichnet das Polygon auf dem Bildschirm.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#77](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#77)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#77](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#77)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#77](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#77)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="points" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawRectangle">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zeichnet ein Rechteck, das durch ein Koordinatenpaar, eine Breiten- und eine Höhenangabe angegeben ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawRectangle">
      <MemberSignature Language="C#" Value="public void DrawRectangle (System.Drawing.Pen pen, System.Drawing.Rectangle rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawRectangle(class System.Drawing.Pen pen, valuetype System.Drawing.Rectangle rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawRectangle(System.Drawing.Pen,System.Drawing.Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawRectangle(System::Drawing::Pen ^ pen, System::Drawing::Rectangle rect);" />
      <MemberSignature Language="F#" Value="member this.DrawRectangle : System.Drawing.Pen * System.Drawing.Rectangle -&gt; unit" Usage="graphics.DrawRectangle (pen, rect)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="pen">Ein <see cref="T:System.Drawing.Pen" />, der die Farbe, Breite und den Stil des Rechtecks bestimmt.</param>
        <param name="rect">Eine <see cref="T:System.Drawing.Rectangle" />-Struktur, die das zu zeichnende Rechteck darstellt.</param>
        <summary>Zeichnet ein Rechteck, das von einer <see cref="T:System.Drawing.Rectangle" />-Struktur angegeben ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zum Zeichnen <xref:System.Drawing.RectangleF>von finden <xref:System.Drawing.Graphics.DrawRectangles%28System.Drawing.Pen%2CSystem.Drawing.RectangleF%5B%5D%29>Sie unter.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen schwarzen Stift.  
  
-   Erstellt ein Rechteck.  
  
-   Zeichnet das Rechteck auf dem Bildschirm.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#79](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#79)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#79](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#79)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#79](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#79)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawRectangle">
      <MemberSignature Language="C#" Value="public void DrawRectangle (System.Drawing.Pen pen, int x, int y, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawRectangle(class System.Drawing.Pen pen, int32 x, int32 y, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawRectangle(System.Drawing.Pen,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawRectangle(System::Drawing::Pen ^ pen, int x, int y, int width, int height);" />
      <MemberSignature Language="F#" Value="member this.DrawRectangle : System.Drawing.Pen * int * int * int * int -&gt; unit" Usage="graphics.DrawRectangle (pen, x, y, width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" />, der die Farbe, Breite und den Stil des Rechtecks bestimmt.</param>
        <param name="x">Die X-Koordinate der oberen linken Ecke des zu zeichnenden Rechtecks.</param>
        <param name="y">Die Y-Koordinate der oberen linken Ecke des zu zeichnenden Rechtecks.</param>
        <param name="width">Breite des zu zeichnenden Rechtecks.</param>
        <param name="height">Höhe des zu zeichnenden Rechtecks.</param>
        <summary>Zeichnet ein Rechteck, das durch ein Koordinatenpaar, eine Breiten- und eine Höhenangabe angegeben ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zum Zeichnen <xref:System.Drawing.RectangleF>von finden <xref:System.Drawing.Graphics.DrawRectangles%28System.Drawing.Pen%2CSystem.Drawing.RectangleF%5B%5D%29>Sie unter.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen schwarzen Stift.  
  
-   Erstellt die Position und Größe eines Rechtecks.  
  
-   Zeichnet das Rechteck auf dem Bildschirm.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#80](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#80)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#80](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#80)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#80](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#80)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawRectangle">
      <MemberSignature Language="C#" Value="public void DrawRectangle (System.Drawing.Pen pen, float x, float y, float width, float height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawRectangle(class System.Drawing.Pen pen, float32 x, float32 y, float32 width, float32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawRectangle(System.Drawing.Pen,System.Single,System.Single,System.Single,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawRectangle(System::Drawing::Pen ^ pen, float x, float y, float width, float height);" />
      <MemberSignature Language="F#" Value="member this.DrawRectangle : System.Drawing.Pen * single * single * single * single -&gt; unit" Usage="graphics.DrawRectangle (pen, x, y, width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="width" Type="System.Single" />
        <Parameter Name="height" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="pen">Ein <see cref="T:System.Drawing.Pen" />, der die Farbe, Breite und den Stil des Rechtecks bestimmt.</param>
        <param name="x">Die X-Koordinate der oberen linken Ecke des zu zeichnenden Rechtecks.</param>
        <param name="y">Die Y-Koordinate der oberen linken Ecke des zu zeichnenden Rechtecks.</param>
        <param name="width">Die Breite des zu zeichnenden Rechtecks.</param>
        <param name="height">Die Höhe des zu zeichnenden Rechtecks.</param>
        <summary>Zeichnet ein Rechteck, das durch ein Koordinatenpaar, eine Breiten- und eine Höhenangabe angegeben ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zum Zeichnen <xref:System.Drawing.RectangleF>von finden <xref:System.Drawing.Graphics.DrawRectangles%28System.Drawing.Pen%2CSystem.Drawing.RectangleF%5B%5D%29>Sie unter.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen schwarzen Stift.  
  
-   Erstellt die Position und Größe eines Rechtecks.  
  
-   Zeichnet das Rechteck auf dem Bildschirm.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#81](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#81)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#81](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#81)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#81](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#81)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawRectangles">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zeichnet eine Reihe von Rechtecken, die durch <see cref="T:System.Drawing.Rectangle" />-Strukturen angegeben sind.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawRectangles">
      <MemberSignature Language="C#" Value="public void DrawRectangles (System.Drawing.Pen pen, System.Drawing.Rectangle[] rects);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawRectangles(class System.Drawing.Pen pen, valuetype System.Drawing.Rectangle[] rects) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawRectangles(System.Drawing.Pen,System.Drawing.Rectangle[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawRectangles(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::Rectangle&gt; ^ rects);" />
      <MemberSignature Language="F#" Value="member this.DrawRectangles : System.Drawing.Pen * System.Drawing.Rectangle[] -&gt; unit" Usage="graphics.DrawRectangles (pen, rects)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="rects" Type="System.Drawing.Rectangle[]" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" />, der die Farbe, Breite und den Stil der Gliederungen der Rechtecke bestimmt.</param>
        <param name="rects">Array von <see cref="T:System.Drawing.Rectangle" />-Strukturen, die die zu zeichnenden Rechtecke darstellen.</param>
        <summary>Zeichnet eine Reihe von Rechtecken, die durch <see cref="T:System.Drawing.Rectangle" />-Strukturen angegeben sind.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen schwarzen Stift.  
  
-   Erstellt ein Array aus drei Rechtecke.  
  
-   Zeichnet die Rechtecke auf dem Bildschirm.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#82](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#82)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#82](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#82)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#82](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#82)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="rects" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="rects" /> ist ein Array der Länge 0 (null).</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawRectangles">
      <MemberSignature Language="C#" Value="public void DrawRectangles (System.Drawing.Pen pen, System.Drawing.RectangleF[] rects);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawRectangles(class System.Drawing.Pen pen, valuetype System.Drawing.RectangleF[] rects) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawRectangles(System.Drawing.Pen,System.Drawing.RectangleF[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawRectangles(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::RectangleF&gt; ^ rects);" />
      <MemberSignature Language="F#" Value="member this.DrawRectangles : System.Drawing.Pen * System.Drawing.RectangleF[] -&gt; unit" Usage="graphics.DrawRectangles (pen, rects)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="rects" Type="System.Drawing.RectangleF[]" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" />, der die Farbe, Breite und den Stil der Gliederungen der Rechtecke bestimmt.</param>
        <param name="rects">Array von <see cref="T:System.Drawing.RectangleF" />-Strukturen, die die zu zeichnenden Rechtecke darstellen.</param>
        <summary>Zeichnet eine Reihe von Rechtecken, die durch <see cref="T:System.Drawing.RectangleF" />-Strukturen angegeben sind.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen schwarzen Stift.  
  
-   Erstellt ein Array aus drei Rechtecke.  
  
-   Zeichnet die Rechtecke auf dem Bildschirm.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#83](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#83)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#83](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#83)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#83](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#83)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="rects" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="rects" /> ist ein Array der Länge 0 (null).</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawString">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zeichnet die angegebene Textzeichenfolge an der angegebenen Position mit dem angegebenen <see cref="T:System.Drawing.Brush" />-Objekt und dem angegebenen <see cref="T:System.Drawing.Font" />-Objekt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawString">
      <MemberSignature Language="C#" Value="public void DrawString (string s, System.Drawing.Font font, System.Drawing.Brush brush, System.Drawing.PointF point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawString(string s, class System.Drawing.Font font, class System.Drawing.Brush brush, valuetype System.Drawing.PointF point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawString(System.String,System.Drawing.Font,System.Drawing.Brush,System.Drawing.PointF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawString(System::String ^ s, System::Drawing::Font ^ font, System::Drawing::Brush ^ brush, System::Drawing::PointF point);" />
      <MemberSignature Language="F#" Value="member this.DrawString : string * System.Drawing.Font * System.Drawing.Brush * System.Drawing.PointF -&gt; unit" Usage="graphics.DrawString (s, font, brush, point)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="font" Type="System.Drawing.Font" />
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="point" Type="System.Drawing.PointF" />
      </Parameters>
      <Docs>
        <param name="s">Zu zeichnende Zeichenfolge.</param>
        <param name="font"><see cref="T:System.Drawing.Font" />, die das Textformat der Zeichenfolge definiert.</param>
        <param name="brush"><see cref="T:System.Drawing.Brush" />, der die Farbe und Struktur des gezeichneten Texts bestimmt.</param>
        <param name="point"><see cref="T:System.Drawing.PointF" />-Struktur, die die obere linke Ecke des gezeichneten Textes angibt.</param>
        <summary>Zeichnet die angegebene Textzeichenfolge an der angegebenen Position mit dem angegebenen <see cref="T:System.Drawing.Brush" />-Objekt und dem angegebenen <see cref="T:System.Drawing.Font" />-Objekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt eine Text Zeichenfolge, die gezeichnet werden soll.  
  
-   Definiert die Schriftart als Arial (16pt).  
  
-   Erstellt einen soliden, schwarzen Pinsel, mit dem gezeichnet werden soll.  
  
-   Erstellt einen Punkt für die obere linke Ecke, an der der Text gezeichnet werden soll.  
  
-   Zeichnet die Zeichenfolge mithilfe der Schriftart, des Pinsels und des Zielpunkts auf dem Bildschirm.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#84](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#84)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#84](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#84)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#84](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#84)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="s" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Forms.TextRenderer.DrawText(System.Drawing.IDeviceContext,System.String,System.Drawing.Font,System.Drawing.Point,System.Drawing.Color)" />
        <related type="Article" href="~/docs/framework/winforms/advanced/using-fonts-and-text.md">Verwenden von Schriftarten und Text</related>
      </Docs>
    </Member>
    <Member MemberName="DrawString">
      <MemberSignature Language="C#" Value="public void DrawString (string s, System.Drawing.Font font, System.Drawing.Brush brush, System.Drawing.RectangleF layoutRectangle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawString(string s, class System.Drawing.Font font, class System.Drawing.Brush brush, valuetype System.Drawing.RectangleF layoutRectangle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawString(System.String,System.Drawing.Font,System.Drawing.Brush,System.Drawing.RectangleF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawString(System::String ^ s, System::Drawing::Font ^ font, System::Drawing::Brush ^ brush, System::Drawing::RectangleF layoutRectangle);" />
      <MemberSignature Language="F#" Value="member this.DrawString : string * System.Drawing.Font * System.Drawing.Brush * System.Drawing.RectangleF -&gt; unit" Usage="graphics.DrawString (s, font, brush, layoutRectangle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="font" Type="System.Drawing.Font" />
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="layoutRectangle" Type="System.Drawing.RectangleF" />
      </Parameters>
      <Docs>
        <param name="s">Zu zeichnende Zeichenfolge.</param>
        <param name="font"><see cref="T:System.Drawing.Font" />, die das Textformat der Zeichenfolge definiert.</param>
        <param name="brush"><see cref="T:System.Drawing.Brush" />, der die Farbe und Struktur des gezeichneten Texts bestimmt.</param>
        <param name="layoutRectangle"><see cref="T:System.Drawing.RectangleF" />-Struktur, die die Position des gezeichneten Textes angibt.</param>
        <summary>Zeichnet die angegebene Textzeichenfolge in dem angegebenen Rechteck mit dem angegebenen <see cref="T:System.Drawing.Brush" />-Objekt und dem angegebenen <see cref="T:System.Drawing.Font" />-Objekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der durch den `s` -Parameter dargestellte Text wird innerhalb des durch den `layoutRectangle` -Parameter dargestellten Rechtecks gezeichnet. Wenn der Text nicht in das Rechteck passt, wird er am nächsten Wort abgeschnitten. Um die Art und Weise, wie die Zeichenfolge innerhalb des Rechtecks gezeichnet wird <xref:System.Drawing.StringFormat>, weiter zu verändern, verwenden Sie die <xref:System.Drawing.Graphics.DrawString%2A>  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt eine Text Zeichenfolge, die gezeichnet werden soll.  
  
-   Definiert die Schriftart als Arial (16pt).  
  
-   Erstellt einen soliden, schwarzen Pinsel, mit dem gezeichnet werden soll.  
  
-   Erstellt ein Rechteck, in dem der Text gezeichnet werden soll.  
  
-   Zeichnet das Rechteck auf dem Bildschirm.  
  
-   Zeichnet die Zeichenfolge mithilfe der Schriftart, des Pinsels und des Ziel Rechtecks auf dem Bildschirm.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#86](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#86)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#86](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#86)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#86](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#86)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="s" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Forms.TextRenderer.DrawText(System.Drawing.IDeviceContext,System.String,System.Drawing.Font,System.Drawing.Point,System.Drawing.Color)" />
        <related type="Article" href="~/docs/framework/winforms/advanced/using-fonts-and-text.md">Verwenden von Schriftarten und Text</related>
      </Docs>
    </Member>
    <Member MemberName="DrawString">
      <MemberSignature Language="C#" Value="public void DrawString (string s, System.Drawing.Font font, System.Drawing.Brush brush, System.Drawing.PointF point, System.Drawing.StringFormat format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawString(string s, class System.Drawing.Font font, class System.Drawing.Brush brush, valuetype System.Drawing.PointF point, class System.Drawing.StringFormat format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawString(System.String,System.Drawing.Font,System.Drawing.Brush,System.Drawing.PointF,System.Drawing.StringFormat)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawString(System::String ^ s, System::Drawing::Font ^ font, System::Drawing::Brush ^ brush, System::Drawing::PointF point, System::Drawing::StringFormat ^ format);" />
      <MemberSignature Language="F#" Value="member this.DrawString : string * System.Drawing.Font * System.Drawing.Brush * System.Drawing.PointF * System.Drawing.StringFormat -&gt; unit" Usage="graphics.DrawString (s, font, brush, point, format)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="font" Type="System.Drawing.Font" />
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="point" Type="System.Drawing.PointF" />
        <Parameter Name="format" Type="System.Drawing.StringFormat" />
      </Parameters>
      <Docs>
        <param name="s">Zu zeichnende Zeichenfolge.</param>
        <param name="font"><see cref="T:System.Drawing.Font" />, die das Textformat der Zeichenfolge definiert.</param>
        <param name="brush"><see cref="T:System.Drawing.Brush" />, der die Farbe und Struktur des gezeichneten Texts bestimmt.</param>
        <param name="point"><see cref="T:System.Drawing.PointF" />-Struktur, die die obere linke Ecke des gezeichneten Textes angibt.</param>
        <param name="format"><see cref="T:System.Drawing.StringFormat" />, das die Formatierungsattribute angibt, die auf den gezeichneten Text angewendet werden, z. B. Zeilenabstand und Ausrichtung.</param>
        <summary>Zeichnet die angegebene Zeichenfolge an der angegebenen Position mit dem angegebenen <see cref="T:System.Drawing.Brush" />-Objekt und dem angegebenen <see cref="T:System.Drawing.Font" />-Objekt unter Verwendung der Formatierungsattribute vom angegebenen <see cref="T:System.Drawing.StringFormat" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt eine Text Zeichenfolge, die gezeichnet werden soll.  
  
-   Definiert die Schriftart als Arial (16pt).  
  
-   Erstellt einen soliden, schwarzen Pinsel, mit dem gezeichnet werden soll.  
  
-   Erstellt einen Punkt für die obere linke Ecke, an der der Text gezeichnet werden soll.  
  
-   Legt das Format der Zeichenfolge fest, die vertikal gezeichnet werden soll.  
  
-   Zeichnet die Zeichenfolge mit der Schriftart, dem Pinsel, dem Zielpunkt und dem Format auf dem Bildschirm.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#85](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#85)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#85](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#85)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#85](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#85)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="s" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Forms.TextRenderer.DrawText(System.Drawing.IDeviceContext,System.String,System.Drawing.Font,System.Drawing.Point,System.Drawing.Color)" />
        <related type="Article" href="~/docs/framework/winforms/advanced/using-fonts-and-text.md">Verwenden von Schriftarten und Text</related>
      </Docs>
    </Member>
    <Member MemberName="DrawString">
      <MemberSignature Language="C#" Value="public void DrawString (string s, System.Drawing.Font font, System.Drawing.Brush brush, System.Drawing.RectangleF layoutRectangle, System.Drawing.StringFormat format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawString(string s, class System.Drawing.Font font, class System.Drawing.Brush brush, valuetype System.Drawing.RectangleF layoutRectangle, class System.Drawing.StringFormat format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawString(System.String,System.Drawing.Font,System.Drawing.Brush,System.Drawing.RectangleF,System.Drawing.StringFormat)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawString(System::String ^ s, System::Drawing::Font ^ font, System::Drawing::Brush ^ brush, System::Drawing::RectangleF layoutRectangle, System::Drawing::StringFormat ^ format);" />
      <MemberSignature Language="F#" Value="member this.DrawString : string * System.Drawing.Font * System.Drawing.Brush * System.Drawing.RectangleF * System.Drawing.StringFormat -&gt; unit" Usage="graphics.DrawString (s, font, brush, layoutRectangle, format)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="font" Type="System.Drawing.Font" />
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="layoutRectangle" Type="System.Drawing.RectangleF" />
        <Parameter Name="format" Type="System.Drawing.StringFormat" />
      </Parameters>
      <Docs>
        <param name="s">Zu zeichnende Zeichenfolge.</param>
        <param name="font"><see cref="T:System.Drawing.Font" />, die das Textformat der Zeichenfolge definiert.</param>
        <param name="brush"><see cref="T:System.Drawing.Brush" />, der die Farbe und Struktur des gezeichneten Texts bestimmt.</param>
        <param name="layoutRectangle"><see cref="T:System.Drawing.RectangleF" />-Struktur, die die Position des gezeichneten Textes angibt.</param>
        <param name="format"><see cref="T:System.Drawing.StringFormat" />, das die Formatierungsattribute angibt, die auf den gezeichneten Text angewendet werden, z. B. Zeilenabstand und Ausrichtung.</param>
        <summary>Zeichnet die angegebene Zeichenfolge im angegebenen Rechteck mit dem angegebenen <see cref="T:System.Drawing.Brush" />-Objekt und dem angegebenen <see cref="T:System.Drawing.Font" />-Objekt unter Verwendung der Formatierungsattribute vom angegebenen <see cref="T:System.Drawing.StringFormat" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der durch den `s` -Parameter dargestellte Text wird innerhalb des durch den `layoutRectangle` -Parameter dargestellten Rechtecks gezeichnet. Wenn der Text nicht in das Rechteck passt, wird er beim nächsten Wort abgeschnitten, sofern nicht anders mit dem `format` -Parameter angegeben.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt eine Text Zeichenfolge, die gezeichnet werden soll.  
  
-   Definiert die Schriftart als Arial (16pt).  
  
-   Erstellt einen soliden, schwarzen Pinsel, mit dem gezeichnet werden soll.  
  
-   Erstellt ein Rechteck, in dem der Text gezeichnet werden soll.  
  
-   Zeichnet das Rechteck auf dem Bildschirm.  
  
-   Legt das Format der Zeichenfolge fest, um diese innerhalb des Rechtecks zu zentrieren.  
  
-   Zeichnet die Zeichenfolge mithilfe der Schriftart, des Pinsels und des Ziel Rechtecks auf dem Bildschirm.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#87](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#87)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#87](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#87)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#87](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#87)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="s" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Forms.TextRenderer.DrawText(System.Drawing.IDeviceContext,System.String,System.Drawing.Font,System.Drawing.Point,System.Drawing.Color)" />
        <related type="Article" href="~/docs/framework/winforms/advanced/using-fonts-and-text.md">Verwenden von Schriftarten und Text</related>
      </Docs>
    </Member>
    <Member MemberName="DrawString">
      <MemberSignature Language="C#" Value="public void DrawString (string s, System.Drawing.Font font, System.Drawing.Brush brush, float x, float y);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawString(string s, class System.Drawing.Font font, class System.Drawing.Brush brush, float32 x, float32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawString(System.String,System.Drawing.Font,System.Drawing.Brush,System.Single,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawString(System::String ^ s, System::Drawing::Font ^ font, System::Drawing::Brush ^ brush, float x, float y);" />
      <MemberSignature Language="F#" Value="member this.DrawString : string * System.Drawing.Font * System.Drawing.Brush * single * single -&gt; unit" Usage="graphics.DrawString (s, font, brush, x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="font" Type="System.Drawing.Font" />
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="s">Zu zeichnende Zeichenfolge.</param>
        <param name="font"><see cref="T:System.Drawing.Font" />, die das Textformat der Zeichenfolge definiert.</param>
        <param name="brush"><see cref="T:System.Drawing.Brush" />, der die Farbe und Struktur des gezeichneten Texts bestimmt.</param>
        <param name="x">Die x-Koordinate der oberen linken Ecke des gezeichneten Texts.</param>
        <param name="y">Die y-Koordinate der oberen linken Ecke des gezeichneten Texts.</param>
        <summary>Zeichnet die angegebene Textzeichenfolge an der angegebenen Position mit dem angegebenen <see cref="T:System.Drawing.Brush" />-Objekt und dem angegebenen <see cref="T:System.Drawing.Font" />-Objekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt eine Text Zeichenfolge, die gezeichnet werden soll.  
  
-   Definiert die Schriftart als Arial (16pt).  
  
-   Erstellt einen voll tonpinsel, mit dem gezeichnet werden soll.  
  
-   Erstellt einen Punkt für die obere linke Ecke, an der der Text gezeichnet werden soll.  
  
-   Zeichnet die Zeichenfolge mithilfe der Schriftart, des Pinsels und des Zielpunkts auf dem Bildschirm.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#88](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#88)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#88](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#88)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#88](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#88)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="s" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Forms.TextRenderer.DrawText(System.Drawing.IDeviceContext,System.String,System.Drawing.Font,System.Drawing.Point,System.Drawing.Color)" />
        <related type="Article" href="~/docs/framework/winforms/advanced/using-fonts-and-text.md">Verwenden von Schriftarten und Text</related>
      </Docs>
    </Member>
    <Member MemberName="DrawString">
      <MemberSignature Language="C#" Value="public void DrawString (string s, System.Drawing.Font font, System.Drawing.Brush brush, float x, float y, System.Drawing.StringFormat format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawString(string s, class System.Drawing.Font font, class System.Drawing.Brush brush, float32 x, float32 y, class System.Drawing.StringFormat format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawString(System.String,System.Drawing.Font,System.Drawing.Brush,System.Single,System.Single,System.Drawing.StringFormat)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawString(System::String ^ s, System::Drawing::Font ^ font, System::Drawing::Brush ^ brush, float x, float y, System::Drawing::StringFormat ^ format);" />
      <MemberSignature Language="F#" Value="member this.DrawString : string * System.Drawing.Font * System.Drawing.Brush * single * single * System.Drawing.StringFormat -&gt; unit" Usage="graphics.DrawString (s, font, brush, x, y, format)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="font" Type="System.Drawing.Font" />
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="format" Type="System.Drawing.StringFormat" />
      </Parameters>
      <Docs>
        <param name="s">Zu zeichnende Zeichenfolge.</param>
        <param name="font"><see cref="T:System.Drawing.Font" />, die das Textformat der Zeichenfolge definiert.</param>
        <param name="brush"><see cref="T:System.Drawing.Brush" />, der die Farbe und Struktur des gezeichneten Texts bestimmt.</param>
        <param name="x">Die x-Koordinate der oberen linken Ecke des gezeichneten Texts.</param>
        <param name="y">Die y-Koordinate der oberen linken Ecke des gezeichneten Texts.</param>
        <param name="format"><see cref="T:System.Drawing.StringFormat" />, das die Formatierungsattribute angibt, die auf den gezeichneten Text angewendet werden, z. B. Zeilenabstand und Ausrichtung.</param>
        <summary>Zeichnet die angegebene Zeichenfolge an der angegebenen Position mit dem angegebenen <see cref="T:System.Drawing.Brush" />-Objekt und dem angegebenen <see cref="T:System.Drawing.Font" />-Objekt unter Verwendung der Formatierungsattribute vom angegebenen <see cref="T:System.Drawing.StringFormat" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt eine Text Zeichenfolge, die gezeichnet werden soll.  
  
-   Definiert die Schriftart als Arial (16pt).  
  
-   Erstellt einen soliden, schwarzen Pinsel, mit dem gezeichnet werden soll.  
  
-   Erstellt die Koordinaten eines Punkts für die obere linke Ecke, an der der Text gezeichnet werden soll.  
  
-   Legt das Format der Zeichenfolge fest, die vertikal gezeichnet werden soll.  
  
-   Zeichnet die Zeichenfolge mit der Schriftart, dem Pinsel, dem Zielpunkt und dem Format auf dem Bildschirm.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#89](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#89)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#89](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#89)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#89](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#89)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="s" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Forms.TextRenderer.DrawText(System.Drawing.IDeviceContext,System.String,System.Drawing.Font,System.Drawing.Point,System.Drawing.Color)" />
        <related type="Article" href="~/docs/framework/winforms/advanced/using-fonts-and-text.md">Verwenden von Schriftarten und Text</related>
      </Docs>
    </Member>
    <Member MemberName="EndContainer">
      <MemberSignature Language="C#" Value="public void EndContainer (System.Drawing.Drawing2D.GraphicsContainer container);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndContainer(class System.Drawing.Drawing2D.GraphicsContainer container) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EndContainer(System.Drawing.Drawing2D.GraphicsContainer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndContainer (container As GraphicsContainer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndContainer(System::Drawing::Drawing2D::GraphicsContainer ^ container);" />
      <MemberSignature Language="F#" Value="member this.EndContainer : System.Drawing.Drawing2D.GraphicsContainer -&gt; unit" Usage="graphics.EndContainer container" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="container" Type="System.Drawing.Drawing2D.GraphicsContainer" />
      </Parameters>
      <Docs>
        <param name="container"><see cref="T:System.Drawing.Drawing2D.GraphicsContainer" />, der den Container darstellt, den diese Methode wiederherstellt.</param>
        <summary>Schließt den aktuellen Grafikcontainer und stellt den Zustand dieses <see cref="T:System.Drawing.Graphics" /> wieder her, der durch einen Aufruf der <see cref="M:System.Drawing.Graphics.BeginContainer" />-Methode gespeichert wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode mit <xref:System.Drawing.Graphics.BeginContainer%2A> der-Methode, um die Erstellung von Netz eigenen Grafik Containern durchführen Grafik Container behalten den Grafik Zustand bei, z. b. Transformation, Clippingbereich und Renderingeigenschaften.  
  
 Wenn Sie die <xref:System.Drawing.Graphics.BeginContainer%2A> -Methode <xref:System.Drawing.Graphics>eines aufzurufen, <xref:System.Drawing.Graphics> wird ein Informationsblock, der den Zustand von enthält, in einen Stapel eingefügt. Die <xref:System.Drawing.Graphics.BeginContainer%2A> -Methode gibt <xref:System.Drawing.Drawing2D.GraphicsContainer> einen zurück, der diesen Informationsblock identifiziert. Wenn Sie das identifizier <xref:System.Drawing.Graphics.EndContainer%2A> <xref:System.Drawing.Graphics> Ende Objekt an die-Methode übergeben, wird der Informationsblock aus dem Stapel entfernt und verwendet, um die in dem Zustand wiederherzustellen, in dem Sie sich zum Zeitpunkt des MethodenAufrufensbefand.<xref:System.Drawing.Graphics.BeginContainer%2A>  
  
 Container können eingebettet werden. Das heißt, Sie können die <xref:System.Drawing.Graphics.BeginContainer%2A> -Methode mehrmals aufzurufen, bevor Sie die <xref:System.Drawing.Graphics.EndContainer%2A> -Methode aufzurufen. Jedes Mal, wenn Sie <xref:System.Drawing.Graphics.BeginContainer%2A> die-Methode aufzurufen, wird ein Informationsblock in den Stapel eingefügt, <xref:System.Drawing.Drawing2D.GraphicsContainer> und Sie erhalten eine für den Informationsblock. Wenn Sie eines dieser Objekte <xref:System.Drawing.Graphics.EndContainer%2A> an die-Methode übergeben, wird die an den Zustand zurückgegeben, in dem Sie sich <xref:System.Drawing.Graphics.BeginContainer%2A> zum Zeitpunkt des Methoden Aufrufes befand <xref:System.Drawing.Drawing2D.GraphicsContainer>, der <xref:System.Drawing.Graphics> diese bestimmte zurückgegeben hat. Der Informationsblock, der durch diesen <xref:System.Drawing.Graphics.BeginContainer%2A> Methoden Anruf auf dem Stapel abgelegt wird, wird aus dem Stapel entfernt, und alle Informationsblöcke, die nach diesem <xref:System.Drawing.Graphics.BeginContainer%2A> Methoden Anruf auf diesem Stapel platziert werden, werden ebenfalls entfernt.  
  
 Aufrufe der <xref:System.Drawing.Graphics.Save%2A> -Methode platzieren Informationsblöcke auf demselben Stapel wie Aufrufe der <xref:System.Drawing.Graphics.BeginContainer%2A> -Methode. Ebenso wie ein <xref:System.Drawing.Graphics.EndContainer%2A> Methoden aufrufpaar mit einem <xref:System.Drawing.Graphics.BeginContainer%2A> Methoden aufrufpaar <xref:System.Drawing.Graphics.Restore%2A> kombiniert wird, wird ein Methoden <xref:System.Drawing.Graphics.Save%2A> aufrufspaar einem Methoden aufzurufen.  
  
 <xref:System.Drawing.Graphics.EndContainer%2A> Wenn Sie die-Methode aufzurufen, werden alle Informationsblöcke, die auf dem <xref:System.Drawing.Graphics.Save%2A> Stapel abgelegt werden ( <xref:System.Drawing.Graphics.BeginContainer%2A> durch die-Methode oder die- <xref:System.Drawing.Graphics.BeginContainer%2A> Methode), nachdem der entsprechende aufrufungsaufrufungsmethode aus dem Stapel entfernt wurde. Ebenso <xref:System.Drawing.Graphics.Restore%2A> werden beim Abrufen der-Methode alle Informationsblöcke, die auf dem Stapel abgelegt werden (durch die <xref:System.Drawing.Graphics.Save%2A> -Methode <xref:System.Drawing.Graphics.BeginContainer%2A> oder die- <xref:System.Drawing.Graphics.Save%2A> Methode), nachdem der entsprechende aufrufungsaufrufder Methode aus dem Stapel entfernt wurde.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Öffnet einen neuen Grafik Container und speichert den alten Container.  
  
-   Übersetzt die Weltkoordinaten im Container.  
  
-   Füllt ein rotes Rechteck im (übersetzten Koordinaten des) neuen Containers.  
  
-   Schließt den neuen Container und stellt den gespeicherten Container wieder her.  
  
-   Füllt ein grünes Rechteck (mit den nicht übersetzten Koordinaten) des gespeicherten Containers.  
  
 Das Ergebnis ist ein grünes Rechteck, das ein rotes Rechteck derselben Größe überschreitet.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#90](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#90)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#90](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#90)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#90](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#90)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="EnumerateMetafile">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sendet die Datensätze im angegebenen <see cref="T:System.Drawing.Imaging.Metafile" /> einzeln an eine Rückrufmethode zum Anzeigen an einem bestimmten Punkt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.Point destPoint, System.Drawing.Graphics.EnumerateMetafileProc callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.Point destPoint, class System.Drawing.Graphics/EnumerateMetafileProc callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Point,System.Drawing.Graphics.EnumerateMetafileProc)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::Point destPoint, System::Drawing::Graphics::EnumerateMetafileProc ^ callback);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.Point * System.Drawing.Graphics.EnumerateMetafileProc -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoint, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoint" Type="System.Drawing.Point" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
      </Parameters>
      <Docs>
        <param name="metafile">Aufzulistendes<see cref="T:System.Drawing.Imaging.Metafile" /> .</param>
        <param name="destPoint"><see cref="T:System.Drawing.Point" />-Struktur, die die Position der oberen linken Ecke der gezeichneten Metadatei angibt.</param>
        <param name="callback"><see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" />-Delegat, der die Methode angibt, an die die Datensätze der Metadatei gesendet werden.</param>
        <summary>Sendet die Datensätze im angegebenen <see cref="T:System.Drawing.Imaging.Metafile" /> einzeln an eine Rückrufmethode zum Anzeigen an einem bestimmten Punkt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode listet die Datensätze auf, die in der angegebenen Metadatendatei enthalten sind. Jeder Datensatz wird einzeln an eine Rückruf Methode gesendet, die durch `callback` den-Parameter angegeben wird. In der Regel ruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> die Rückruf Methode die-Methode auf, um den Datensatz zu "wiedergeben" oder zu zeichnen.  
  
 Wenn die Rückruf Methode aufruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, muss Sie dies durch Aufrufen der <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> -Methode des spezifischen <xref:System.Drawing.Imaging.Metafile> tun, das aufgezählt wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Formular erstellt, das <xref:System.Drawing.Imaging.Metafile> über einen als einen seiner privaten Member verfügt. Die <xref:System.Windows.Forms.Control.OnPaint%2A> -Methode <xref:System.Drawing.Graphics.EnumerateMetafile%2A>Ruft auf, die die- `MetafileCallback` Methode des Formulars für jeden Datensatz in der Metadatei aufruft. Die `MetafileCallback`-Methode ruft die <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>-Methode auf. Beachten Sie, `MetafileCallback` dass die-Methode die Daten Satz <xref:System.IntPtr>Daten als empfängt <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> , aber die-Methode erwartet, dass die Daten Satz Daten ein Bytearray sind. Der- <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>Befehl kopiertdieDatendesDatensatzesineinBytearray,sodassesanden-Wertüber<xref:System.Runtime.InteropServices.Marshal.Copy%2A> mittelt werden kann.  
  
 [!code-csharp[System.Drawing.Graphics.EnumerateMetafile#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Graphics.EnumerateMetafile/CS/Form1.cs#1)]
 [!code-vb[System.Drawing.Graphics.EnumerateMetafile#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Graphics.EnumerateMetafile/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.Point[] destPoints, System.Drawing.Graphics.EnumerateMetafileProc callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.Point[] destPoints, class System.Drawing.Graphics/EnumerateMetafileProc callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Point[],System.Drawing.Graphics.EnumerateMetafileProc)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, cli::array &lt;System::Drawing::Point&gt; ^ destPoints, System::Drawing::Graphics::EnumerateMetafileProc ^ callback);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.Point[] * System.Drawing.Graphics.EnumerateMetafileProc -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoints, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoints" Type="System.Drawing.Point[]" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
      </Parameters>
      <Docs>
        <param name="metafile">Aufzulistendes <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
        <param name="destPoints">Array von drei <see cref="T:System.Drawing.Point" />-Strukturen, die ein Parallelogramm definieren, das die Größe und Position der gezeichneten Metadatei bestimmt.</param>
        <param name="callback"><see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" />-Delegat, der die Methode angibt, an die die Datensätze der Metadatei gesendet werden.</param>
        <summary>Sendet die Datensätze im angegebenen <see cref="T:System.Drawing.Imaging.Metafile" /> einzeln an eine Rückrufmethode zum Anzeigen in einem bestimmten Parallelogramm.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode listet die Datensätze auf, die in der angegebenen Metadatendatei enthalten sind. Jeder Datensatz wird einzeln an eine Rückruf Methode gesendet, die durch `callback` den-Parameter angegeben wird. In der Regel ruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> die Rückruf Methode die-Methode auf, um den Datensatz zu "wiedergeben" oder zu zeichnen.  
  
 Wenn die Rückruf Methode aufruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, muss Sie dies durch Aufrufen der <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> -Methode des spezifischen <xref:System.Drawing.Imaging.Metafile> tun, das aufgezählt wird.  
  
   
  
## Examples  
 Ein Codebeispiel finden Sie unter <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.PointF destPoint, System.Drawing.Graphics.EnumerateMetafileProc callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.PointF destPoint, class System.Drawing.Graphics/EnumerateMetafileProc callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.PointF,System.Drawing.Graphics.EnumerateMetafileProc)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::PointF destPoint, System::Drawing::Graphics::EnumerateMetafileProc ^ callback);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.PointF * System.Drawing.Graphics.EnumerateMetafileProc -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoint, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoint" Type="System.Drawing.PointF" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
      </Parameters>
      <Docs>
        <param name="metafile">Aufzulistendes <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
        <param name="destPoint"><see cref="T:System.Drawing.PointF" />-Struktur, die die Position der oberen linken Ecke der gezeichneten Metadatei angibt.</param>
        <param name="callback"><see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" />-Delegat, der die Methode angibt, an die die Datensätze der Metadatei gesendet werden.</param>
        <summary>Sendet die Datensätze im angegebenen <see cref="T:System.Drawing.Imaging.Metafile" /> einzeln an eine Rückrufmethode zum Anzeigen an einem bestimmten Punkt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode listet die Datensätze auf, die in der angegebenen Metadatendatei enthalten sind. Jeder Datensatz wird einzeln an eine Rückruf Methode gesendet, die durch `callback` den-Parameter angegeben wird. In der Regel ruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> die Rückruf Methode die-Methode auf, um den Datensatz zu "wiedergeben" oder zu zeichnen.  
  
 Wenn die Rückruf Methode aufruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, muss Sie dies durch Aufrufen der <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> -Methode des spezifischen <xref:System.Drawing.Imaging.Metafile> tun, das aufgezählt wird.  
  
   
  
## Examples  
 Ein Codebeispiel finden Sie unter <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.PointF[] destPoints, System.Drawing.Graphics.EnumerateMetafileProc callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.PointF[] destPoints, class System.Drawing.Graphics/EnumerateMetafileProc callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.PointF[],System.Drawing.Graphics.EnumerateMetafileProc)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, cli::array &lt;System::Drawing::PointF&gt; ^ destPoints, System::Drawing::Graphics::EnumerateMetafileProc ^ callback);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.PointF[] * System.Drawing.Graphics.EnumerateMetafileProc -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoints, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoints" Type="System.Drawing.PointF[]" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
      </Parameters>
      <Docs>
        <param name="metafile">Aufzulistendes <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
        <param name="destPoints">Array von drei <see cref="T:System.Drawing.PointF" />-Strukturen, die ein Parallelogramm definieren, das die Größe und Position der gezeichneten Metadatei bestimmt.</param>
        <param name="callback"><see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" />-Delegat, der die Methode angibt, an die die Datensätze der Metadatei gesendet werden.</param>
        <summary>Sendet die Datensätze im angegebenen <see cref="T:System.Drawing.Imaging.Metafile" /> einzeln an eine Rückrufmethode zum Anzeigen in einem bestimmten Parallelogramm.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode listet die Datensätze auf, die in der angegebenen Metadatendatei enthalten sind. Jeder Datensatz wird einzeln an eine Rückruf Methode gesendet, die durch `callback` den-Parameter angegeben wird. In der Regel ruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> die Rückruf Methode die-Methode auf, um den Datensatz zu "wiedergeben" oder zu zeichnen.  
  
 Wenn die Rückruf Methode aufruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, muss Sie dies durch Aufrufen der <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> -Methode des spezifischen <xref:System.Drawing.Imaging.Metafile> tun, das aufgezählt wird.  
  
 Der `destPoints` -Parameter gibt drei Punkte eines Parallelogramms an. Die drei <xref:System.Drawing.PointF> -Strukturen stellen die oberen linken, oberen rechten und unteren linken Ecke des parallelograms dar. Der vierte Punkt wird von den ersten drei extrapoliert, um ein Parallelogram zu bilden. Die gezeichnete Metadatendatei wird skaliert und an das Parallelogramm angepasst.  
  
   
  
## Examples  
 Ein Codebeispiel finden Sie unter <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.Rectangle destRect, System.Drawing.Graphics.EnumerateMetafileProc callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.Rectangle destRect, class System.Drawing.Graphics/EnumerateMetafileProc callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Rectangle,System.Drawing.Graphics.EnumerateMetafileProc)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::Rectangle destRect, System::Drawing::Graphics::EnumerateMetafileProc ^ callback);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.Rectangle * System.Drawing.Graphics.EnumerateMetafileProc -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destRect, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
      </Parameters>
      <Docs>
        <param name="metafile">Aufzulistendes <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
        <param name="destRect"><see cref="T:System.Drawing.Rectangle" />-Struktur, die die Position und Größe der gezeichneten Metadatei angibt.</param>
        <param name="callback"><see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" />-Delegat, der die Methode angibt, an die die Datensätze der Metadatei gesendet werden.</param>
        <summary>Sendet die Datensätze im angegebenen <see cref="T:System.Drawing.Imaging.Metafile" /> einzeln an eine Rückrufmethode zum Anzeigen in einem bestimmten Rechteck.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode listet die Datensätze auf, die in der angegebenen Metadatendatei enthalten sind. Jeder Datensatz wird einzeln an eine Rückruf Methode gesendet, die durch `callback` den-Parameter angegeben wird. In der Regel ruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> die Rückruf Methode die-Methode auf, um den Datensatz zu "wiedergeben" oder zu zeichnen.  
  
 Wenn die Rückruf Methode aufruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, muss Sie dies durch Aufrufen der <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> -Methode des spezifischen <xref:System.Drawing.Imaging.Metafile> tun, das aufgezählt wird.  
  
   
  
## Examples  
 Ein Codebeispiel finden Sie unter <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.RectangleF destRect, System.Drawing.Graphics.EnumerateMetafileProc callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.RectangleF destRect, class System.Drawing.Graphics/EnumerateMetafileProc callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.RectangleF,System.Drawing.Graphics.EnumerateMetafileProc)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::RectangleF destRect, System::Drawing::Graphics::EnumerateMetafileProc ^ callback);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.RectangleF * System.Drawing.Graphics.EnumerateMetafileProc -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destRect, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
      </Parameters>
      <Docs>
        <param name="metafile">Aufzulistendes <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
        <param name="destRect"><see cref="T:System.Drawing.RectangleF" />-Struktur, die die Position und Größe der gezeichneten Metadatei angibt.</param>
        <param name="callback"><see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" />-Delegat, der die Methode angibt, an die die Datensätze der Metadatei gesendet werden.</param>
        <summary>Sendet die Datensätze im angegebenen <see cref="T:System.Drawing.Imaging.Metafile" /> einzeln an eine Rückrufmethode zum Anzeigen in einem bestimmten Rechteck.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode listet die Datensätze auf, die in der angegebenen Metadatendatei enthalten sind. Jeder Datensatz wird einzeln an eine Rückruf Methode gesendet, die durch `callback` den-Parameter angegeben wird. In der Regel ruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> die Rückruf Methode die-Methode auf, um den Datensatz zu "wiedergeben" oder zu zeichnen.  
  
 Wenn die Rückruf Methode aufruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, muss Sie dies durch Aufrufen der <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> -Methode des spezifischen <xref:System.Drawing.Imaging.Metafile> tun, das aufgezählt wird.  
  
   
  
## Examples  
 Ein Codebeispiel finden Sie unter <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.Point destPoint, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.Point destPoint, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Point,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::Point destPoint, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.Point * System.Drawing.Graphics.EnumerateMetafileProc * nativeint -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoint, callback, callbackData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoint" Type="System.Drawing.Point" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="metafile">Aufzulistendes <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
        <param name="destPoint"><see cref="T:System.Drawing.Point" />-Struktur, die die Position der oberen linken Ecke der gezeichneten Metadatei angibt.</param>
        <param name="callback"><see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" />-Delegat, der die Methode angibt, an die die Datensätze der Metadatei gesendet werden.</param>
        <param name="callbackData">Interner Zeiger, der erforderlich ist, aber ignoriert wird. Für diesen Parameter kann <see cref="F:System.IntPtr.Zero" /> übergeben werden.</param>
        <summary>Sendet die Datensätze im angegebenen <see cref="T:System.Drawing.Imaging.Metafile" /> einzeln an eine Rückrufmethode zum Anzeigen an einem bestimmten Punkt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode listet die Datensätze auf, die in der angegebenen Metadatendatei enthalten sind. Jeder Datensatz wird einzeln an eine Rückruf Methode gesendet, die durch `callback` den-Parameter angegeben wird. In der Regel ruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> die Rückruf Methode die-Methode auf, um den Datensatz zu "wiedergeben" oder zu zeichnen.  
  
 Wenn die Rückruf Methode aufruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, muss Sie dies durch Aufrufen der <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> -Methode des spezifischen <xref:System.Drawing.Imaging.Metafile> tun, das aufgezählt wird.  
  
   
  
## Examples  
 Ein Codebeispiel finden Sie unter <xref:System.Drawing.Graphics.EnumerateMetafile%2A>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.Point[] destPoints, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.Point[] destPoints, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Point[],System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, cli::array &lt;System::Drawing::Point&gt; ^ destPoints, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.Point[] * System.Drawing.Graphics.EnumerateMetafileProc * nativeint -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoints, callback, callbackData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoints" Type="System.Drawing.Point[]" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="metafile">Aufzulistendes <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
        <param name="destPoints">Array von drei <see cref="T:System.Drawing.Point" />-Strukturen, die ein Parallelogramm definieren, das die Größe und Position der gezeichneten Metadatei bestimmt.</param>
        <param name="callback"><see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" />-Delegat, der die Methode angibt, an die die Datensätze der Metadatei gesendet werden.</param>
        <param name="callbackData">Interner Zeiger, der erforderlich ist, aber ignoriert wird. Für diesen Parameter kann <see cref="F:System.IntPtr.Zero" /> übergeben werden.</param>
        <summary>Sendet die Datensätze im angegebenen <see cref="T:System.Drawing.Imaging.Metafile" /> einzeln an eine Rückrufmethode zum Anzeigen in einem bestimmten Parallelogramm.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode listet die Datensätze auf, die in der angegebenen Metadatendatei enthalten sind. Jeder Datensatz wird einzeln an eine Rückruf Methode gesendet, die durch `callback` den-Parameter angegeben wird. In der Regel ruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> die Rückruf Methode die-Methode auf, um den Datensatz zu "wiedergeben" oder zu zeichnen.  
  
 Wenn die Rückruf Methode aufruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, muss Sie dies durch Aufrufen der <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> -Methode des spezifischen <xref:System.Drawing.Imaging.Metafile> tun, das aufgezählt wird.  
  
   
  
## Examples  
 Ein Codebeispiel finden Sie unter <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.PointF destPoint, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.PointF destPoint, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.PointF,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::PointF destPoint, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.PointF * System.Drawing.Graphics.EnumerateMetafileProc * nativeint -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoint, callback, callbackData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoint" Type="System.Drawing.PointF" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="metafile">Aufzulistendes <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
        <param name="destPoint"><see cref="T:System.Drawing.PointF" />-Struktur, die die Position der oberen linken Ecke der gezeichneten Metadatei angibt.</param>
        <param name="callback"><see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" />-Delegat, der die Methode angibt, an die die Datensätze der Metadatei gesendet werden.</param>
        <param name="callbackData">Interner Zeiger, der erforderlich ist, aber ignoriert wird. Für diesen Parameter kann <see cref="F:System.IntPtr.Zero" /> übergeben werden.</param>
        <summary>Sendet die Datensätze im angegebenen <see cref="T:System.Drawing.Imaging.Metafile" /> einzeln an eine Rückrufmethode zum Anzeigen an einem bestimmten Punkt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode listet die Datensätze auf, die in der angegebenen Metadatendatei enthalten sind. Jeder Datensatz wird einzeln an eine Rückruf Methode gesendet, die durch `callback` den-Parameter angegeben wird. In der Regel ruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> die Rückruf Methode die-Methode auf, um den Datensatz zu "wiedergeben" oder zu zeichnen.  
  
 Wenn die Rückruf Methode aufruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, muss Sie dies durch Aufrufen der <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> -Methode des spezifischen <xref:System.Drawing.Imaging.Metafile> tun, das aufgezählt wird.  
  
   
  
## Examples  
 Ein Codebeispiel finden Sie unter <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.PointF[] destPoints, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.PointF[] destPoints, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.PointF[],System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, cli::array &lt;System::Drawing::PointF&gt; ^ destPoints, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.PointF[] * System.Drawing.Graphics.EnumerateMetafileProc * nativeint -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoints, callback, callbackData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoints" Type="System.Drawing.PointF[]" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="metafile">Aufzulistendes <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
        <param name="destPoints">Array von drei <see cref="T:System.Drawing.PointF" />-Strukturen, die ein Parallelogramm definieren, das die Größe und Position der gezeichneten Metadatei bestimmt.</param>
        <param name="callback"><see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" />-Delegat, der die Methode angibt, an die die Datensätze der Metadatei gesendet werden.</param>
        <param name="callbackData">Interner Zeiger, der erforderlich ist, aber ignoriert wird. Für diesen Parameter kann <see cref="F:System.IntPtr.Zero" /> übergeben werden.</param>
        <summary>Sendet die Datensätze im angegebenen <see cref="T:System.Drawing.Imaging.Metafile" /> einzeln an eine Rückrufmethode zum Anzeigen in einem bestimmten Parallelogramm.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode listet die Datensätze auf, die in der angegebenen Metadatendatei enthalten sind. Jeder Datensatz wird einzeln an eine Rückruf Methode gesendet, die durch `callback` den-Parameter angegeben wird. In der Regel ruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> die Rückruf Methode die-Methode auf, um den Datensatz zu "wiedergeben" oder zu zeichnen.  
  
 Wenn die Rückruf Methode aufruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, muss Sie dies durch Aufrufen der <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> -Methode des spezifischen <xref:System.Drawing.Imaging.Metafile> tun, das aufgezählt wird.  
  
 Der `destPoints` -Parameter gibt drei Punkte eines Parallelogramms an. Die drei <xref:System.Drawing.PointF> -Strukturen stellen die oberen linken, oberen rechten und unteren linken Ecke des parallelograms dar. Der vierte Punkt wird von den ersten drei extrapoliert, um ein Parallelogram zu bilden. Die gezeichnete Metadatendatei wird skaliert und an das Parallelogramm angepasst.  
  
   
  
## Examples  
 Ein Codebeispiel finden Sie unter <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.Rectangle destRect, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.Rectangle destRect, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Rectangle,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::Rectangle destRect, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.Rectangle * System.Drawing.Graphics.EnumerateMetafileProc * nativeint -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destRect, callback, callbackData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="metafile">Aufzulistendes <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
        <param name="destRect"><see cref="T:System.Drawing.Rectangle" />-Struktur, die die Position und Größe der gezeichneten Metadatei angibt.</param>
        <param name="callback"><see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" />-Delegat, der die Methode angibt, an die die Datensätze der Metadatei gesendet werden.</param>
        <param name="callbackData">Interner Zeiger, der erforderlich ist, aber ignoriert wird. Für diesen Parameter kann <see cref="F:System.IntPtr.Zero" /> übergeben werden.</param>
        <summary>Sendet die Datensätze im angegebenen <see cref="T:System.Drawing.Imaging.Metafile" /> einzeln an eine Rückrufmethode zum Anzeigen in einem bestimmten Rechteck.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode listet die Datensätze auf, die in der angegebenen Metadatendatei enthalten sind. Jeder Datensatz wird einzeln an eine Rückruf Methode gesendet, die durch `callback` den-Parameter angegeben wird. In der Regel ruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> die Rückruf Methode die-Methode auf, um den Datensatz zu "wiedergeben" oder zu zeichnen.  
  
 Wenn die Rückruf Methode aufruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, muss Sie dies durch Aufrufen der <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> -Methode des spezifischen <xref:System.Drawing.Imaging.Metafile> tun, das aufgezählt wird.  
  
   
  
## Examples  
 Ein Codebeispiel finden Sie unter <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.RectangleF destRect, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.RectangleF destRect, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.RectangleF,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::RectangleF destRect, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.RectangleF * System.Drawing.Graphics.EnumerateMetafileProc * nativeint -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destRect, callback, callbackData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="metafile">Aufzulistendes <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
        <param name="destRect"><see cref="T:System.Drawing.RectangleF" />-Struktur, die die Position und Größe der gezeichneten Metadatei angibt.</param>
        <param name="callback"><see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" />-Delegat, der die Methode angibt, an die die Datensätze der Metadatei gesendet werden.</param>
        <param name="callbackData">Interner Zeiger, der erforderlich ist, aber ignoriert wird. Für diesen Parameter kann <see cref="F:System.IntPtr.Zero" /> übergeben werden.</param>
        <summary>Sendet die Datensätze im angegebenen <see cref="T:System.Drawing.Imaging.Metafile" /> einzeln an eine Rückrufmethode zum Anzeigen in einem bestimmten Rechteck.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode listet die Datensätze auf, die in der angegebenen Metadatendatei enthalten sind. Jeder Datensatz wird einzeln an eine Rückruf Methode gesendet, die durch `callback` den-Parameter angegeben wird. In der Regel ruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> die Rückruf Methode die-Methode auf, um den Datensatz zu "wiedergeben" oder zu zeichnen.  
  
 Wenn die Rückruf Methode aufruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, muss Sie dies durch Aufrufen der <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> -Methode des spezifischen <xref:System.Drawing.Imaging.Metafile> tun, das aufgezählt wird.  
  
   
  
## Examples  
 Ein Codebeispiel finden Sie unter <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.Point destPoint, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData, System.Drawing.Imaging.ImageAttributes imageAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.Point destPoint, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData, class System.Drawing.Imaging.ImageAttributes imageAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Point,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr,System.Drawing.Imaging.ImageAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::Point destPoint, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData, System::Drawing::Imaging::ImageAttributes ^ imageAttr);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.Point * System.Drawing.Graphics.EnumerateMetafileProc * nativeint * System.Drawing.Imaging.ImageAttributes -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoint, callback, callbackData, imageAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoint" Type="System.Drawing.Point" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
      </Parameters>
      <Docs>
        <param name="metafile">Aufzulistendes <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
        <param name="destPoint"><see cref="T:System.Drawing.Point" />-Struktur, die die Position der oberen linken Ecke der gezeichneten Metadatei angibt.</param>
        <param name="callback"><see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" />-Delegat, der die Methode angibt, an die die Datensätze der Metadatei gesendet werden.</param>
        <param name="callbackData">Interner Zeiger, der erforderlich ist, aber ignoriert wird. Für diesen Parameter kann <see cref="F:System.IntPtr.Zero" /> übergeben werden.</param>
        <param name="imageAttr"><see cref="T:System.Drawing.Imaging.ImageAttributes" />, das Informationen über Bildattribute für das gezeichnete Bild angibt.</param>
        <summary>Sendet die Datensätze des angegebenen <see cref="T:System.Drawing.Imaging.Metafile" /> jeweils einzeln an eine Rückrufmethode, um sie an einem angegebenen Punkt unter Verwendung von angegebenen Bildattributen anzuzeigen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode listet die Datensätze auf, die in der angegebenen Metadatendatei enthalten sind. Jeder Datensatz wird einzeln an eine Rückruf Methode gesendet, die durch `callback` den-Parameter angegeben wird. In der Regel ruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> die Rückruf Methode die-Methode auf, um den Datensatz zu "wiedergeben" oder zu zeichnen.  
  
 Wenn die Rückruf Methode aufruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, muss Sie dies durch Aufrufen der <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> -Methode des spezifischen <xref:System.Drawing.Imaging.Metafile> tun, das aufgezählt wird.  
  
   
  
## Examples  
 Ein Codebeispiel finden Sie unter <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.Point destPoint, System.Drawing.Rectangle srcRect, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Graphics.EnumerateMetafileProc callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.Point destPoint, valuetype System.Drawing.Rectangle srcRect, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Graphics/EnumerateMetafileProc callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Point,System.Drawing.Rectangle,System.Drawing.GraphicsUnit,System.Drawing.Graphics.EnumerateMetafileProc)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::Point destPoint, System::Drawing::Rectangle srcRect, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Graphics::EnumerateMetafileProc ^ callback);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.Point * System.Drawing.Rectangle * System.Drawing.GraphicsUnit * System.Drawing.Graphics.EnumerateMetafileProc -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoint, srcRect, srcUnit, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoint" Type="System.Drawing.Point" />
        <Parameter Name="srcRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
      </Parameters>
      <Docs>
        <param name="metafile">Aufzulistendes <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
        <param name="destPoint"><see cref="T:System.Drawing.Point" />-Struktur, die die Position der oberen linken Ecke der gezeichneten Metadatei angibt.</param>
        <param name="srcRect"><see cref="T:System.Drawing.Rectangle" />-Struktur, die den zu zeichnenden Teil der Metadatei relativ zur oberen linken Ecke angibt.</param>
        <param name="srcUnit">Member der <see cref="T:System.Drawing.GraphicsUnit" />-Enumeration, der die Maßeinheit angibt, mit der der Teil der Metadatei bestimmt wird, der in dem vom <paramref name="srcRect" />-Parameter angegebenen Rechteck enthalten ist.</param>
        <param name="callback"><see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" />-Delegat, der die Methode angibt, an die die Datensätze der Metadatei gesendet werden.</param>
        <summary>Sendet die Datensätze in einem ausgewählten Rechteck eines <see cref="T:System.Drawing.Imaging.Metafile" /> einzeln an eine Rückrufmethode zum Anzeigen an einem bestimmten Punkt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode listet die Datensätze auf, die in der angegebenen Metadatendatei enthalten sind. Jeder Datensatz wird einzeln an eine Rückruf Methode gesendet, die durch `callback` den-Parameter angegeben wird. In der Regel ruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> die Rückruf Methode die-Methode auf, um den Datensatz zu "wiedergeben" oder zu zeichnen.  
  
 Wenn die Rückruf Methode aufruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, muss Sie dies durch Aufrufen der <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> -Methode des spezifischen <xref:System.Drawing.Imaging.Metafile> tun, das aufgezählt wird.  
  
   
  
## Examples  
 Ein Codebeispiel finden Sie unter <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.Point[] destPoints, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData, System.Drawing.Imaging.ImageAttributes imageAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.Point[] destPoints, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData, class System.Drawing.Imaging.ImageAttributes imageAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Point[],System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr,System.Drawing.Imaging.ImageAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, cli::array &lt;System::Drawing::Point&gt; ^ destPoints, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData, System::Drawing::Imaging::ImageAttributes ^ imageAttr);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.Point[] * System.Drawing.Graphics.EnumerateMetafileProc * nativeint * System.Drawing.Imaging.ImageAttributes -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoints, callback, callbackData, imageAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoints" Type="System.Drawing.Point[]" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
      </Parameters>
      <Docs>
        <param name="metafile">Aufzulistendes <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
        <param name="destPoints">Array von drei <see cref="T:System.Drawing.Point" />-Strukturen, die ein Parallelogramm definieren, das die Größe und Position der gezeichneten Metadatei bestimmt.</param>
        <param name="callback"><see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" />-Delegat, der die Methode angibt, an die die Datensätze der Metadatei gesendet werden.</param>
        <param name="callbackData">Interner Zeiger, der erforderlich ist, aber ignoriert wird. Für diesen Parameter kann <see cref="F:System.IntPtr.Zero" /> übergeben werden.</param>
        <param name="imageAttr"><see cref="T:System.Drawing.Imaging.ImageAttributes" />, das Informationen über Bildattribute für das gezeichnete Bild angibt.</param>
        <summary>Sendet die Datensätze des angegebenen <see cref="T:System.Drawing.Imaging.Metafile" /> jeweils einzeln an eine Rückrufmethode, um sie in einem angegebenen Parallelogramm unter Verwendung von angegebenen Bildattributen anzuzeigen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode listet die Datensätze auf, die in der angegebenen Metadatendatei enthalten sind. Jeder Datensatz wird einzeln an eine Rückruf Methode gesendet, die durch `callback` den-Parameter angegeben wird. In der Regel ruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> die Rückruf Methode die-Methode auf, um den Datensatz zu "wiedergeben" oder zu zeichnen.  
  
 Wenn die Rückruf Methode aufruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, muss Sie dies durch Aufrufen der <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> -Methode des spezifischen <xref:System.Drawing.Imaging.Metafile> tun, das aufgezählt wird.  
  
 Der `destPoints` -Parameter gibt drei Punkte eines Parallelogramms an. Die drei <xref:System.Drawing.Point> -Strukturen stellen die oberen linken, oberen rechten und unteren linken Ecke des parallelograms dar. Der vierte Punkt wird von den ersten drei extrapoliert, um ein Parallelogram zu bilden. Die gezeichnete Metadatendatei wird skaliert und an das Parallelogramm angepasst.  
  
 Die durch den `imageAttr` -Parameter angegebenen Bildattribute ersetzen die beim Schreiben der Metadatendatei angegebenen.  
  
   
  
## Examples  
 Ein Codebeispiel finden Sie unter <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.Point[] destPoints, System.Drawing.Rectangle srcRect, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Graphics.EnumerateMetafileProc callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.Point[] destPoints, valuetype System.Drawing.Rectangle srcRect, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Graphics/EnumerateMetafileProc callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Point[],System.Drawing.Rectangle,System.Drawing.GraphicsUnit,System.Drawing.Graphics.EnumerateMetafileProc)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, cli::array &lt;System::Drawing::Point&gt; ^ destPoints, System::Drawing::Rectangle srcRect, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Graphics::EnumerateMetafileProc ^ callback);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.Point[] * System.Drawing.Rectangle * System.Drawing.GraphicsUnit * System.Drawing.Graphics.EnumerateMetafileProc -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoints, srcRect, srcUnit, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoints" Type="System.Drawing.Point[]" />
        <Parameter Name="srcRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
      </Parameters>
      <Docs>
        <param name="metafile">Aufzulistendes <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
        <param name="destPoints">Array von drei <see cref="T:System.Drawing.Point" />-Strukturen, die ein Parallelogramm definieren, das die Größe und Position der gezeichneten Metadatei bestimmt.</param>
        <param name="srcRect"><see cref="T:System.Drawing.Rectangle" />-Struktur, die den zu zeichnenden Teil der Metadatei relativ zur oberen linken Ecke angibt.</param>
        <param name="srcUnit">Member der <see cref="T:System.Drawing.GraphicsUnit" />-Enumeration, der die Maßeinheit angibt, mit der der Teil der Metadatei bestimmt wird, der in dem vom <paramref name="srcRect" />-Parameter angegebenen Rechteck enthalten ist.</param>
        <param name="callback"><see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" />-Delegat, der die Methode angibt, an die die Datensätze der Metadatei gesendet werden.</param>
        <summary>Sendet die Datensätze in einem ausgewählten Rechteck eines <see cref="T:System.Drawing.Imaging.Metafile" /> einzeln an eine Rückrufmethode zum Anzeigen in einem bestimmten Parallelogramm.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode listet die Datensätze auf, die in der angegebenen Metadatendatei enthalten sind. Jeder Datensatz wird einzeln an eine Rückruf Methode gesendet, die durch `callback` den-Parameter angegeben wird. In der Regel ruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> die Rückruf Methode die-Methode auf, um den Datensatz zu "wiedergeben" oder zu zeichnen.  
  
 Wenn die Rückruf Methode aufruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, muss Sie dies durch Aufrufen der <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> -Methode des spezifischen <xref:System.Drawing.Imaging.Metafile> tun, das aufgezählt wird.  
  
 Der `destPoints` -Parameter gibt drei Punkte eines Parallelogramms an. Die drei <xref:System.Drawing.Point> -Strukturen stellen die oberen linken, oberen rechten und unteren linken Ecke des parallelograms dar. Der vierte Punkt wird von den ersten drei extrapoliert, um ein Parallelogram zu bilden. Die gezeichnete Metadatendatei wird skaliert und an das Parallelogramm angepasst.  
  
 Jede Zeichnung, die außerhalb des durch den `srcRect` -Parameter angegebenen Rechtecks stattfindet, wird ignoriert.  
  
   
  
## Examples  
 Ein Codebeispiel finden Sie unter <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.PointF destPoint, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData, System.Drawing.Imaging.ImageAttributes imageAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.PointF destPoint, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData, class System.Drawing.Imaging.ImageAttributes imageAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.PointF,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr,System.Drawing.Imaging.ImageAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::PointF destPoint, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData, System::Drawing::Imaging::ImageAttributes ^ imageAttr);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.PointF * System.Drawing.Graphics.EnumerateMetafileProc * nativeint * System.Drawing.Imaging.ImageAttributes -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoint, callback, callbackData, imageAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoint" Type="System.Drawing.PointF" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
      </Parameters>
      <Docs>
        <param name="metafile">Aufzulistendes <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
        <param name="destPoint"><see cref="T:System.Drawing.PointF" />-Struktur, die die Position der oberen linken Ecke der gezeichneten Metadatei angibt.</param>
        <param name="callback"><see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" />-Delegat, der die Methode angibt, an die die Datensätze der Metadatei gesendet werden.</param>
        <param name="callbackData">Interner Zeiger, der erforderlich ist, aber ignoriert wird. Für diesen Parameter kann <see cref="F:System.IntPtr.Zero" /> übergeben werden.</param>
        <param name="imageAttr"><see cref="T:System.Drawing.Imaging.ImageAttributes" />, das Informationen über Bildattribute für das gezeichnete Bild angibt.</param>
        <summary>Sendet die Datensätze des angegebenen <see cref="T:System.Drawing.Imaging.Metafile" /> jeweils einzeln an eine Rückrufmethode, um sie an einem angegebenen Punkt unter Verwendung von angegebenen Bildattributen anzuzeigen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode listet die Datensätze auf, die in der angegebenen Metadatendatei enthalten sind. Jeder Datensatz wird einzeln an eine Rückruf Methode gesendet, die durch `callback` den-Parameter angegeben wird. In der Regel ruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> die Rückruf Methode die-Methode auf, um den Datensatz zu "wiedergeben" oder zu zeichnen.  
  
 Wenn die Rückruf Methode aufruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, muss Sie dies durch Aufrufen der-Methode des spezifischen <xref:System.Drawing.Imaging.Metafile> tun, das aufgezählt wird.  
  
 Die durch den `imageAttr` -Parameter angegebenen Bildattribute ersetzen die beim Schreiben der Metadatendatei angegebenen.  
  
   
  
## Examples  
 Ein Codebeispiel finden Sie unter <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.PointF destPoint, System.Drawing.RectangleF srcRect, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Graphics.EnumerateMetafileProc callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.PointF destPoint, valuetype System.Drawing.RectangleF srcRect, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Graphics/EnumerateMetafileProc callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.PointF,System.Drawing.RectangleF,System.Drawing.GraphicsUnit,System.Drawing.Graphics.EnumerateMetafileProc)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::PointF destPoint, System::Drawing::RectangleF srcRect, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Graphics::EnumerateMetafileProc ^ callback);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.PointF * System.Drawing.RectangleF * System.Drawing.GraphicsUnit * System.Drawing.Graphics.EnumerateMetafileProc -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoint, srcRect, srcUnit, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoint" Type="System.Drawing.PointF" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
      </Parameters>
      <Docs>
        <param name="metafile">Aufzulistendes <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
        <param name="destPoint"><see cref="T:System.Drawing.PointF" />-Struktur, die die Position der oberen linken Ecke der gezeichneten Metadatei angibt.</param>
        <param name="srcRect"><see cref="T:System.Drawing.RectangleF" />-Struktur, die den zu zeichnenden Teil der Metadatei relativ zur oberen linken Ecke angibt.</param>
        <param name="srcUnit">Member der <see cref="T:System.Drawing.GraphicsUnit" />-Enumeration, der die Maßeinheit angibt, mit der der Teil der Metadatei bestimmt wird, der in dem vom <paramref name="srcRect" />-Parameter angegebenen Rechteck enthalten ist.</param>
        <param name="callback"><see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" />-Delegat, der die Methode angibt, an die die Datensätze der Metadatei gesendet werden.</param>
        <summary>Sendet die Datensätze in einem ausgewählten Rechteck eines <see cref="T:System.Drawing.Imaging.Metafile" /> einzeln an eine Rückrufmethode zum Anzeigen an einem bestimmten Punkt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode listet die Datensätze auf, die in der angegebenen Metadatendatei enthalten sind. Jeder Datensatz wird einzeln an eine Rückruf Methode gesendet, die durch `callback` den-Parameter angegeben wird. In der Regel ruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> die Rückruf Methode die-Methode auf, um den Datensatz zu "wiedergeben" oder zu zeichnen.  
  
 Wenn die Rückruf Methode aufruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, muss Sie dies durch Aufrufen der <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> -Methode des spezifischen <xref:System.Drawing.Imaging.Metafile> tun, das aufgezählt wird.  
  
 Jede Zeichnung, die außerhalb des durch den `srcRect` -Parameter angegebenen Rechtecks stattfindet, wird ignoriert.  
  
   
  
## Examples  
 Ein Codebeispiel finden Sie unter <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.PointF[] destPoints, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData, System.Drawing.Imaging.ImageAttributes imageAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.PointF[] destPoints, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData, class System.Drawing.Imaging.ImageAttributes imageAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.PointF[],System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr,System.Drawing.Imaging.ImageAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, cli::array &lt;System::Drawing::PointF&gt; ^ destPoints, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData, System::Drawing::Imaging::ImageAttributes ^ imageAttr);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.PointF[] * System.Drawing.Graphics.EnumerateMetafileProc * nativeint * System.Drawing.Imaging.ImageAttributes -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoints, callback, callbackData, imageAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoints" Type="System.Drawing.PointF[]" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
      </Parameters>
      <Docs>
        <param name="metafile">Aufzulistendes <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
        <param name="destPoints">Array von drei <see cref="T:System.Drawing.PointF" />-Strukturen, die ein Parallelogramm definieren, das die Größe und Position der gezeichneten Metadatei bestimmt.</param>
        <param name="callback"><see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" />-Delegat, der die Methode angibt, an die die Datensätze der Metadatei gesendet werden.</param>
        <param name="callbackData">Interner Zeiger, der erforderlich ist, aber ignoriert wird. Für diesen Parameter kann <see cref="F:System.IntPtr.Zero" /> übergeben werden.</param>
        <param name="imageAttr"><see cref="T:System.Drawing.Imaging.ImageAttributes" />, das Informationen über Bildattribute für das gezeichnete Bild angibt.</param>
        <summary>Sendet die Datensätze des angegebenen <see cref="T:System.Drawing.Imaging.Metafile" /> jeweils einzeln an eine Rückrufmethode, um sie in einem angegebenen Parallelogramm unter Verwendung von angegebenen Bildattributen anzuzeigen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode listet die Datensätze auf, die in der angegebenen Metadatendatei enthalten sind. Jeder Datensatz wird einzeln an eine Rückruf Methode gesendet, die durch `callback` den-Parameter angegeben wird. In der Regel ruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> die Rückruf Methode die-Methode auf, um den Datensatz zu "wiedergeben" oder zu zeichnen.  
  
 Wenn die Rückruf Methode aufruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, muss Sie dies durch Aufrufen der <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> -Methode des spezifischen <xref:System.Drawing.Imaging.Metafile> tun, das aufgezählt wird.  
  
 Der `destPoints` -Parameter gibt drei Punkte eines Parallelogramms an. Die drei <xref:System.Drawing.PointF> -Strukturen stellen die oberen linken, oberen rechten und unteren linken Ecke des parallelograms dar. Der vierte Punkt wird von den ersten drei extrapoliert, um ein Parallelogram zu bilden. Die gezeichnete Metadatendatei wird skaliert und an das Parallelogramm angepasst.  
  
 Die durch den `imageAttr` -Parameter angegebenen Bildattribute ersetzen die beim Schreiben der Metadatendatei angegebenen.  
  
   
  
## Examples  
 Ein Codebeispiel finden Sie unter <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.PointF[] destPoints, System.Drawing.RectangleF srcRect, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Graphics.EnumerateMetafileProc callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.PointF[] destPoints, valuetype System.Drawing.RectangleF srcRect, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Graphics/EnumerateMetafileProc callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.PointF[],System.Drawing.RectangleF,System.Drawing.GraphicsUnit,System.Drawing.Graphics.EnumerateMetafileProc)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, cli::array &lt;System::Drawing::PointF&gt; ^ destPoints, System::Drawing::RectangleF srcRect, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Graphics::EnumerateMetafileProc ^ callback);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.PointF[] * System.Drawing.RectangleF * System.Drawing.GraphicsUnit * System.Drawing.Graphics.EnumerateMetafileProc -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoints, srcRect, srcUnit, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoints" Type="System.Drawing.PointF[]" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
      </Parameters>
      <Docs>
        <param name="metafile">Aufzulistendes <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
        <param name="destPoints">Array von drei <see cref="T:System.Drawing.PointF" />-Strukturen, die ein Parallelogramm definieren, das die Größe und Position der gezeichneten Metadatei bestimmt.</param>
        <param name="srcRect"><see cref="T:System.Drawing.RectangleF" />-Struktur, die den zu zeichnenden Teil der Metadatei relativ zur oberen linken Ecke angibt.</param>
        <param name="srcUnit">Member der <see cref="T:System.Drawing.GraphicsUnit" />-Enumeration, der die Maßeinheit angibt, mit der der Teil der Metadatei bestimmt wird, der in dem vom <paramref name="srcRect" />-Parameter angegebenen Rechteck enthalten ist.</param>
        <param name="callback"><see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" />-Delegat, der die Methode angibt, an die die Datensätze der Metadatei gesendet werden.</param>
        <summary>Sendet die Datensätze in einem ausgewählten Rechteck eines <see cref="T:System.Drawing.Imaging.Metafile" /> einzeln an eine Rückrufmethode zum Anzeigen in einem bestimmten Parallelogramm.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode listet die Datensätze auf, die in der angegebenen Metadatendatei enthalten sind. Jeder Datensatz wird einzeln an eine Rückruf Methode gesendet, die durch `callback` den-Parameter angegeben wird. In der Regel ruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> die Rückruf Methode die-Methode auf, um den Datensatz zu "wiedergeben" oder zu zeichnen.  
  
 Wenn die Rückruf Methode aufruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, muss Sie dies durch Aufrufen der <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> -Methode des spezifischen <xref:System.Drawing.Imaging.Metafile> tun, das aufgezählt wird.  
  
 Der `destPoints` -Parameter gibt drei Punkte eines Parallelogramms an. Die drei <xref:System.Drawing.Point> -Strukturen stellen die oberen linken, oberen rechten und unteren linken Ecke des parallelograms dar. Der vierte Punkt wird von den ersten drei extrapoliert, um ein Parallelogram zu bilden. Die gezeichnete Metadatendatei wird skaliert und an das Parallelogramm angepasst.  
  
 Jede Zeichnung, die außerhalb des durch den `srcRect` -Parameter angegebenen Rechtecks stattfindet, wird ignoriert.  
  
   
  
## Examples  
 Ein Codebeispiel finden Sie unter <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.Rectangle destRect, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData, System.Drawing.Imaging.ImageAttributes imageAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.Rectangle destRect, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData, class System.Drawing.Imaging.ImageAttributes imageAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Rectangle,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr,System.Drawing.Imaging.ImageAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::Rectangle destRect, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData, System::Drawing::Imaging::ImageAttributes ^ imageAttr);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.Rectangle * System.Drawing.Graphics.EnumerateMetafileProc * nativeint * System.Drawing.Imaging.ImageAttributes -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destRect, callback, callbackData, imageAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
      </Parameters>
      <Docs>
        <param name="metafile">Aufzulistendes <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
        <param name="destRect"><see cref="T:System.Drawing.Rectangle" />-Struktur, die die Position und Größe der gezeichneten Metadatei angibt.</param>
        <param name="callback"><see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" />-Delegat, der die Methode angibt, an die die Datensätze der Metadatei gesendet werden.</param>
        <param name="callbackData">Interner Zeiger, der erforderlich ist, aber ignoriert wird. Für diesen Parameter kann <see cref="F:System.IntPtr.Zero" /> übergeben werden.</param>
        <param name="imageAttr"><see cref="T:System.Drawing.Imaging.ImageAttributes" />, das Informationen über Bildattribute für das gezeichnete Bild angibt.</param>
        <summary>Sendet die Datensätze des angegebenen <see cref="T:System.Drawing.Imaging.Metafile" /> jeweils einzeln an eine Rückrufmethode, um sie in einem angegebenen Rechteck unter Verwendung von angegebenen Bildattributen anzuzeigen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode listet die Datensätze auf, die in der angegebenen Metadatendatei enthalten sind. Jeder Datensatz wird einzeln an eine Rückruf Methode gesendet, die durch `callback` den-Parameter angegeben wird. In der Regel ruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> die Rückruf Methode die-Methode auf, um den Datensatz zu "wiedergeben" oder zu zeichnen.  
  
 Wenn die Rückruf Methode aufruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, muss Sie dies durch Aufrufen der <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> -Methode des spezifischen <xref:System.Drawing.Imaging.Metafile> tun, das aufgezählt wird.  
  
 Die durch den `imageAttr` -Parameter angegebenen Bildattribute ersetzen die beim Schreiben der Metadatendatei angegebenen.  
  
   
  
## Examples  
 Ein Codebeispiel finden Sie unter <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.Rectangle destRect, System.Drawing.Rectangle srcRect, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Graphics.EnumerateMetafileProc callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.Rectangle destRect, valuetype System.Drawing.Rectangle srcRect, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Graphics/EnumerateMetafileProc callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Rectangle,System.Drawing.Rectangle,System.Drawing.GraphicsUnit,System.Drawing.Graphics.EnumerateMetafileProc)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::Rectangle destRect, System::Drawing::Rectangle srcRect, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Graphics::EnumerateMetafileProc ^ callback);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.Rectangle * System.Drawing.Rectangle * System.Drawing.GraphicsUnit * System.Drawing.Graphics.EnumerateMetafileProc -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destRect, srcRect, srcUnit, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
      </Parameters>
      <Docs>
        <param name="metafile">Aufzulistendes <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
        <param name="destRect"><see cref="T:System.Drawing.Rectangle" />-Struktur, die die Position und Größe der gezeichneten Metadatei angibt.</param>
        <param name="srcRect"><see cref="T:System.Drawing.Rectangle" />-Struktur, die den zu zeichnenden Teil der Metadatei relativ zur oberen linken Ecke angibt.</param>
        <param name="srcUnit">Member der <see cref="T:System.Drawing.GraphicsUnit" />-Enumeration, der die Maßeinheit angibt, mit der der Teil der Metadatei bestimmt wird, der in dem vom <paramref name="srcRect" />-Parameter angegebenen Rechteck enthalten ist.</param>
        <param name="callback"><see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" />-Delegat, der die Methode angibt, an die die Datensätze der Metadatei gesendet werden.</param>
        <summary>Sendet die Datensätze eines ausgewählten Rechtecks eines <see cref="T:System.Drawing.Imaging.Metafile" /> einzeln an eine Rückrufmethode zum Anzeigen in einem bestimmten Rechteck.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode listet die Datensätze auf, die in der angegebenen Metadatendatei enthalten sind. Jeder Datensatz wird einzeln an eine Rückruf Methode gesendet, die durch `callback` den-Parameter angegeben wird. In der Regel ruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> die Rückruf Methode die-Methode auf, um den Datensatz zu "wiedergeben" oder zu zeichnen.  
  
 Wenn die Rückruf Methode aufruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, muss Sie dies durch Aufrufen der <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> -Methode des spezifischen <xref:System.Drawing.Imaging.Metafile> tun, das aufgezählt wird.  
  
 Jede Zeichnung, die außerhalb des durch den `srcRect` -Parameter angegebenen Rechtecks stattfindet, wird ignoriert.  
  
   
  
## Examples  
 Ein Codebeispiel finden Sie unter <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.RectangleF destRect, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData, System.Drawing.Imaging.ImageAttributes imageAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.RectangleF destRect, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData, class System.Drawing.Imaging.ImageAttributes imageAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.RectangleF,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr,System.Drawing.Imaging.ImageAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::RectangleF destRect, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData, System::Drawing::Imaging::ImageAttributes ^ imageAttr);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.RectangleF * System.Drawing.Graphics.EnumerateMetafileProc * nativeint * System.Drawing.Imaging.ImageAttributes -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destRect, callback, callbackData, imageAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
      </Parameters>
      <Docs>
        <param name="metafile">Aufzulistendes <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
        <param name="destRect"><see cref="T:System.Drawing.RectangleF" />-Struktur, die die Position und Größe der gezeichneten Metadatei angibt.</param>
        <param name="callback"><see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" />-Delegat, der die Methode angibt, an die die Datensätze der Metadatei gesendet werden.</param>
        <param name="callbackData">Interner Zeiger, der erforderlich ist, aber ignoriert wird. Für diesen Parameter kann <see cref="F:System.IntPtr.Zero" /> übergeben werden.</param>
        <param name="imageAttr"><see cref="T:System.Drawing.Imaging.ImageAttributes" />, das Informationen über Bildattribute für das gezeichnete Bild angibt.</param>
        <summary>Sendet die Datensätze des angegebenen <see cref="T:System.Drawing.Imaging.Metafile" /> jeweils einzeln an eine Rückrufmethode, um sie in einem angegebenen Rechteck unter Verwendung von angegebenen Bildattributen anzuzeigen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode listet die Datensätze auf, die in der angegebenen Metadatendatei enthalten sind. Jeder Datensatz wird einzeln an eine Rückruf Methode gesendet, die durch `callback` den-Parameter angegeben wird. In der Regel ruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> die Rückruf Methode die-Methode auf, um den Datensatz zu "wiedergeben" oder zu zeichnen.  
  
 Wenn die Rückruf Methode aufruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, muss Sie dies durch Aufrufen der <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> -Methode des spezifischen <xref:System.Drawing.Imaging.Metafile> tun, das aufgezählt wird.  
  
 Die durch den `imageAttr` -Parameter angegebenen Bildattribute ersetzen die beim Schreiben der Metadatendatei angegebenen.  
  
   
  
## Examples  
 Ein Codebeispiel finden Sie unter <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.RectangleF destRect, System.Drawing.RectangleF srcRect, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Graphics.EnumerateMetafileProc callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.RectangleF destRect, valuetype System.Drawing.RectangleF srcRect, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Graphics/EnumerateMetafileProc callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.RectangleF,System.Drawing.RectangleF,System.Drawing.GraphicsUnit,System.Drawing.Graphics.EnumerateMetafileProc)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::RectangleF destRect, System::Drawing::RectangleF srcRect, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Graphics::EnumerateMetafileProc ^ callback);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.RectangleF * System.Drawing.RectangleF * System.Drawing.GraphicsUnit * System.Drawing.Graphics.EnumerateMetafileProc -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destRect, srcRect, srcUnit, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
      </Parameters>
      <Docs>
        <param name="metafile">Aufzulistendes <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
        <param name="destRect"><see cref="T:System.Drawing.RectangleF" />-Struktur, die die Position und Größe der gezeichneten Metadatei angibt.</param>
        <param name="srcRect"><see cref="T:System.Drawing.RectangleF" />-Struktur, die den zu zeichnenden Teil der Metadatei relativ zur oberen linken Ecke angibt.</param>
        <param name="srcUnit">Member der <see cref="T:System.Drawing.GraphicsUnit" />-Enumeration, der die Maßeinheit angibt, mit der der Teil der Metadatei bestimmt wird, der in dem vom <paramref name="srcRect" />-Parameter angegebenen Rechteck enthalten ist.</param>
        <param name="callback"><see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" />-Delegat, der die Methode angibt, an die die Datensätze der Metadatei gesendet werden.</param>
        <summary>Sendet die Datensätze eines ausgewählten Rechtecks eines <see cref="T:System.Drawing.Imaging.Metafile" /> einzeln an eine Rückrufmethode zum Anzeigen in einem bestimmten Rechteck.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode listet die Datensätze auf, die in der angegebenen Metadatendatei enthalten sind. Jeder Datensatz wird einzeln an eine Rückruf Methode gesendet, die durch `callback` den-Parameter angegeben wird. In der Regel ruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> die Rückruf Methode die-Methode auf, um den Datensatz zu "wiedergeben" oder zu zeichnen.  
  
 Wenn die Rückruf Methode aufruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, muss Sie dies durch Aufrufen der <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> -Methode des spezifischen <xref:System.Drawing.Imaging.Metafile> tun, das aufgezählt wird.  
  
 Jede Zeichnung, die außerhalb des durch den `srcRect` -Parameter angegebenen Rechtecks stattfindet, wird ignoriert.  
  
   
  
## Examples  
 Ein Codebeispiel finden Sie unter <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.Point destPoint, System.Drawing.Rectangle srcRect, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.Point destPoint, valuetype System.Drawing.Rectangle srcRect, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Point,System.Drawing.Rectangle,System.Drawing.GraphicsUnit,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::Point destPoint, System::Drawing::Rectangle srcRect, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.Point * System.Drawing.Rectangle * System.Drawing.GraphicsUnit * System.Drawing.Graphics.EnumerateMetafileProc * nativeint -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoint, srcRect, srcUnit, callback, callbackData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoint" Type="System.Drawing.Point" />
        <Parameter Name="srcRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="metafile">Aufzulistendes <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
        <param name="destPoint"><see cref="T:System.Drawing.Point" />-Struktur, die die Position der oberen linken Ecke der gezeichneten Metadatei angibt.</param>
        <param name="srcRect"><see cref="T:System.Drawing.Rectangle" />-Struktur, die den zu zeichnenden Teil der Metadatei relativ zur oberen linken Ecke angibt.</param>
        <param name="srcUnit">Member der <see cref="T:System.Drawing.GraphicsUnit" />-Enumeration, der die Maßeinheit angibt, mit der der Teil der Metadatei bestimmt wird, der in dem vom <paramref name="srcRect" />-Parameter angegebenen Rechteck enthalten ist.</param>
        <param name="callback"><see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" />-Delegat, der die Methode angibt, an die die Datensätze der Metadatei gesendet werden.</param>
        <param name="callbackData">Interner Zeiger, der erforderlich ist, aber ignoriert wird. Für diesen Parameter kann <see cref="F:System.IntPtr.Zero" /> übergeben werden.</param>
        <summary>Sendet die Datensätze in einem ausgewählten Rechteck eines <see cref="T:System.Drawing.Imaging.Metafile" /> einzeln an eine Rückrufmethode zum Anzeigen an einem bestimmten Punkt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode listet die Datensätze auf, die in der angegebenen Metadatendatei enthalten sind. Jeder Datensatz wird einzeln an eine Rückruf Methode gesendet, die durch `callback` den-Parameter angegeben wird. In der Regel ruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> die Rückruf Methode die-Methode auf, um den Datensatz zu "wiedergeben" oder zu zeichnen.  
  
 Wenn die Rückruf Methode aufruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, muss Sie dies durch Aufrufen der <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> -Methode des spezifischen <xref:System.Drawing.Imaging.Metafile> tun, das aufgezählt wird.  
  
   
  
## Examples  
 Ein Codebeispiel finden Sie unter <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.Point[] destPoints, System.Drawing.Rectangle srcRect, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.Point[] destPoints, valuetype System.Drawing.Rectangle srcRect, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Point[],System.Drawing.Rectangle,System.Drawing.GraphicsUnit,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, cli::array &lt;System::Drawing::Point&gt; ^ destPoints, System::Drawing::Rectangle srcRect, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.Point[] * System.Drawing.Rectangle * System.Drawing.GraphicsUnit * System.Drawing.Graphics.EnumerateMetafileProc * nativeint -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoints, srcRect, srcUnit, callback, callbackData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoints" Type="System.Drawing.Point[]" />
        <Parameter Name="srcRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="metafile">Aufzulistendes <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
        <param name="destPoints">Array von drei <see cref="T:System.Drawing.Point" />-Strukturen, die ein Parallelogramm definieren, das die Größe und Position der gezeichneten Metadatei bestimmt.</param>
        <param name="srcRect"><see cref="T:System.Drawing.Rectangle" />-Struktur, die den zu zeichnenden Teil der Metadatei relativ zur oberen linken Ecke angibt.</param>
        <param name="srcUnit">Member der <see cref="T:System.Drawing.GraphicsUnit" />-Enumeration, der die Maßeinheit angibt, mit der der Teil der Metadatei bestimmt wird, der in dem vom <paramref name="srcRect" />-Parameter angegebenen Rechteck enthalten ist.</param>
        <param name="callback"><see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" />-Delegat, der die Methode angibt, an die die Datensätze der Metadatei gesendet werden.</param>
        <param name="callbackData">Interner Zeiger, der erforderlich ist, aber ignoriert wird. Für diesen Parameter kann <see cref="F:System.IntPtr.Zero" /> übergeben werden.</param>
        <summary>Sendet die Datensätze in einem ausgewählten Rechteck eines <see cref="T:System.Drawing.Imaging.Metafile" /> einzeln an eine Rückrufmethode zum Anzeigen in einem bestimmten Parallelogramm.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode listet die Datensätze auf, die in der angegebenen Metadatendatei enthalten sind. Jeder Datensatz wird einzeln an eine Rückruf Methode gesendet, die durch `callback` den-Parameter angegeben wird. In der Regel ruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> die Rückruf Methode die-Methode auf, um den Datensatz zu "wiedergeben" oder zu zeichnen.  
  
 Wenn die Rückruf Methode aufruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, muss Sie dies durch Aufrufen der <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> -Methode des spezifischen <xref:System.Drawing.Imaging.Metafile> tun, das aufgezählt wird.  
  
 Der `destPoints` -Parameter gibt drei Punkte eines Parallelogramms an. Die drei <xref:System.Drawing.Point> -Strukturen stellen die oberen linken, oberen rechten und unteren linken Ecke des parallelograms dar. Der vierte Punkt wird von den ersten drei extrapoliert, um ein Parallelogram zu bilden. Die gezeichnete Metadatendatei wird skaliert und an das Parallelogramm angepasst.  
  
 Jede Zeichnung, die außerhalb des durch den `srcRect` -Parameter angegebenen Rechtecks stattfindet, wird ignoriert.  
  
   
  
## Examples  
 Ein Codebeispiel finden Sie unter <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.PointF destPoint, System.Drawing.RectangleF srcRect, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.PointF destPoint, valuetype System.Drawing.RectangleF srcRect, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.PointF,System.Drawing.RectangleF,System.Drawing.GraphicsUnit,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::PointF destPoint, System::Drawing::RectangleF srcRect, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.PointF * System.Drawing.RectangleF * System.Drawing.GraphicsUnit * System.Drawing.Graphics.EnumerateMetafileProc * nativeint -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoint, srcRect, srcUnit, callback, callbackData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoint" Type="System.Drawing.PointF" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="metafile">Aufzulistendes <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
        <param name="destPoint"><see cref="T:System.Drawing.PointF" />-Struktur, die die Position der oberen linken Ecke der gezeichneten Metadatei angibt.</param>
        <param name="srcRect"><see cref="T:System.Drawing.RectangleF" />-Struktur, die den zu zeichnenden Teil der Metadatei relativ zur oberen linken Ecke angibt.</param>
        <param name="srcUnit">Member der <see cref="T:System.Drawing.GraphicsUnit" />-Enumeration, der die Maßeinheit angibt, mit der der Teil der Metadatei bestimmt wird, der in dem vom <paramref name="srcRect" />-Parameter angegebenen Rechteck enthalten ist.</param>
        <param name="callback"><see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" />-Delegat, der die Methode angibt, an die die Datensätze der Metadatei gesendet werden.</param>
        <param name="callbackData">Interner Zeiger, der erforderlich ist, aber ignoriert wird. Für diesen Parameter kann <see cref="F:System.IntPtr.Zero" /> übergeben werden.</param>
        <summary>Sendet die Datensätze in einem ausgewählten Rechteck eines <see cref="T:System.Drawing.Imaging.Metafile" /> einzeln an eine Rückrufmethode zum Anzeigen an einem bestimmten Punkt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode listet die Datensätze auf, die in der angegebenen Metadatendatei enthalten sind. Jeder Datensatz wird einzeln an eine Rückruf Methode gesendet, die durch `callback` den-Parameter angegeben wird. In der Regel ruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> die Rückruf Methode die-Methode auf, um den Datensatz zu "wiedergeben" oder zu zeichnen.  
  
 Wenn die Rückruf Methode aufruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, muss Sie dies durch Aufrufen der <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> -Methode des spezifischen <xref:System.Drawing.Imaging.Metafile> tun, das aufgezählt wird.  
  
 Jede Zeichnung, die außerhalb des durch den `srcRect` -Parameter angegebenen Rechtecks stattfindet, wird ignoriert.  
  
   
  
## Examples  
 Ein Codebeispiel finden Sie unter <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.PointF[] destPoints, System.Drawing.RectangleF srcRect, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.PointF[] destPoints, valuetype System.Drawing.RectangleF srcRect, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.PointF[],System.Drawing.RectangleF,System.Drawing.GraphicsUnit,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, cli::array &lt;System::Drawing::PointF&gt; ^ destPoints, System::Drawing::RectangleF srcRect, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.PointF[] * System.Drawing.RectangleF * System.Drawing.GraphicsUnit * System.Drawing.Graphics.EnumerateMetafileProc * nativeint -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoints, srcRect, srcUnit, callback, callbackData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoints" Type="System.Drawing.PointF[]" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="metafile">Aufzulistendes <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
        <param name="destPoints">Array von drei <see cref="T:System.Drawing.PointF" />-Strukturen, die ein Parallelogramm definieren, das die Größe und Position der gezeichneten Metadatei bestimmt.</param>
        <param name="srcRect"><see cref="T:System.Drawing.RectangleF" />-Struktur, die den zu zeichnenden Teil der Metadatei relativ zur oberen linken Ecke angibt.</param>
        <param name="srcUnit">Member der <see cref="T:System.Drawing.GraphicsUnit" />-Enumeration, der die Maßeinheit angibt, mit der der Teil der Metadatei bestimmt wird, der in dem vom <paramref name="srcRect" />-Parameter angegebenen Rechteck enthalten ist.</param>
        <param name="callback"><see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" />-Delegat, der die Methode angibt, an die die Datensätze der Metadatei gesendet werden.</param>
        <param name="callbackData">Interner Zeiger, der erforderlich ist, aber ignoriert wird. Für diesen Parameter kann <see cref="F:System.IntPtr.Zero" /> übergeben werden.</param>
        <summary>Sendet die Datensätze in einem ausgewählten Rechteck eines <see cref="T:System.Drawing.Imaging.Metafile" /> einzeln an eine Rückrufmethode zum Anzeigen in einem bestimmten Parallelogramm.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode listet die Datensätze auf, die in der angegebenen Metadatendatei enthalten sind. Jeder Datensatz wird einzeln an eine Rückruf Methode gesendet, die durch `callback` den-Parameter angegeben wird. In der Regel ruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> die Rückruf Methode die-Methode auf, um den Datensatz zu "wiedergeben" oder zu zeichnen.  
  
 Wenn die Rückruf Methode aufruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, muss Sie dies durch Aufrufen der <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> -Methode des spezifischen <xref:System.Drawing.Imaging.Metafile> tun, das aufgezählt wird.  
  
 Der `destPoints` -Parameter gibt drei Punkte eines Parallelogramms an. Die drei <xref:System.Drawing.PointF> -Strukturen stellen die oberen linken, oberen rechten und unteren linken Ecke des parallelograms dar. Der vierte Punkt wird von den ersten drei extrapoliert, um ein Parallelogram zu bilden. Die gezeichnete Metadatendatei wird skaliert und an das Parallelogramm angepasst.  
  
 Jede Zeichnung, die außerhalb des durch den `srcRect` -Parameter angegebenen Rechtecks stattfindet, wird ignoriert.  
  
   
  
## Examples  
 Ein Codebeispiel finden Sie unter <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.Rectangle destRect, System.Drawing.Rectangle srcRect, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.Rectangle destRect, valuetype System.Drawing.Rectangle srcRect, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Rectangle,System.Drawing.Rectangle,System.Drawing.GraphicsUnit,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::Rectangle destRect, System::Drawing::Rectangle srcRect, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.Rectangle * System.Drawing.Rectangle * System.Drawing.GraphicsUnit * System.Drawing.Graphics.EnumerateMetafileProc * nativeint -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destRect, srcRect, srcUnit, callback, callbackData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="metafile">Aufzulistendes <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
        <param name="destRect"><see cref="T:System.Drawing.Rectangle" />-Struktur, die die Position und Größe der gezeichneten Metadatei angibt.</param>
        <param name="srcRect"><see cref="T:System.Drawing.Rectangle" />-Struktur, die den zu zeichnenden Teil der Metadatei relativ zur oberen linken Ecke angibt.</param>
        <param name="srcUnit">Member der <see cref="T:System.Drawing.GraphicsUnit" />-Enumeration, der die Maßeinheit angibt, mit der der Teil der Metadatei bestimmt wird, der in dem vom <paramref name="srcRect" />-Parameter angegebenen Rechteck enthalten ist.</param>
        <param name="callback"><see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" />-Delegat, der die Methode angibt, an die die Datensätze der Metadatei gesendet werden.</param>
        <param name="callbackData">Interner Zeiger, der erforderlich ist, aber ignoriert wird. Für diesen Parameter kann <see cref="F:System.IntPtr.Zero" /> übergeben werden.</param>
        <summary>Sendet die Datensätze eines ausgewählten Rechtecks eines <see cref="T:System.Drawing.Imaging.Metafile" /> einzeln an eine Rückrufmethode zum Anzeigen in einem bestimmten Rechteck.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode listet die Datensätze auf, die in der angegebenen Metadatendatei enthalten sind. Jeder Datensatz wird einzeln an eine Rückruf Methode gesendet, die durch `callback` den-Parameter angegeben wird. In der Regel ruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> die Rückruf Methode die-Methode auf, um den Datensatz zu "wiedergeben" oder zu zeichnen.  
  
 Wenn die Rückruf Methode aufruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, muss Sie dies durch Aufrufen der <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> -Methode des spezifischen <xref:System.Drawing.Imaging.Metafile> tun, das aufgezählt wird.  
  
 Jede Zeichnung, die außerhalb des durch den `srcRect` -Parameter angegebenen Rechtecks stattfindet, wird ignoriert.  
  
   
  
## Examples  
 Ein Codebeispiel finden Sie unter <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.RectangleF destRect, System.Drawing.RectangleF srcRect, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.RectangleF destRect, valuetype System.Drawing.RectangleF srcRect, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.RectangleF,System.Drawing.RectangleF,System.Drawing.GraphicsUnit,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::RectangleF destRect, System::Drawing::RectangleF srcRect, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.RectangleF * System.Drawing.RectangleF * System.Drawing.GraphicsUnit * System.Drawing.Graphics.EnumerateMetafileProc * nativeint -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destRect, srcRect, srcUnit, callback, callbackData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="metafile">Aufzulistendes <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
        <param name="destRect"><see cref="T:System.Drawing.RectangleF" />-Struktur, die die Position und Größe der gezeichneten Metadatei angibt.</param>
        <param name="srcRect"><see cref="T:System.Drawing.RectangleF" />-Struktur, die den zu zeichnenden Teil der Metadatei relativ zur oberen linken Ecke angibt.</param>
        <param name="srcUnit">Member der <see cref="T:System.Drawing.GraphicsUnit" />-Enumeration, der die Maßeinheit angibt, mit der der Teil der Metadatei bestimmt wird, der in dem vom <paramref name="srcRect" />-Parameter angegebenen Rechteck enthalten ist.</param>
        <param name="callback"><see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" />-Delegat, der die Methode angibt, an die die Datensätze der Metadatei gesendet werden.</param>
        <param name="callbackData">Interner Zeiger, der erforderlich ist, aber ignoriert wird. Für diesen Parameter kann <see cref="F:System.IntPtr.Zero" /> übergeben werden.</param>
        <summary>Sendet die Datensätze eines ausgewählten Rechtecks eines <see cref="T:System.Drawing.Imaging.Metafile" /> einzeln an eine Rückrufmethode zum Anzeigen in einem bestimmten Rechteck.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode listet die Datensätze auf, die in der angegebenen Metadatendatei enthalten sind. Jeder Datensatz wird einzeln an eine Rückruf Methode gesendet, die durch`callback` den-Parameter angegeben wird. In der Regel ruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> die Rückruf Methode die-Methode auf, um den Datensatz zu "wiedergeben" oder zu zeichnen.  
  
 Wenn die Rückruf Methode aufruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, muss Sie dies durch Aufrufen der <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> -Methode des spezifischen <xref:System.Drawing.Imaging.Metafile> tun, das aufgezählt wird.  
  
 Jede Zeichnung, die außerhalb des durch den `srcRect` -Parameter angegebenen Rechtecks stattfindet, wird ignoriert.  
  
   
  
## Examples  
 Ein Codebeispiel finden Sie unter <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.Point destPoint, System.Drawing.Rectangle srcRect, System.Drawing.GraphicsUnit unit, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData, System.Drawing.Imaging.ImageAttributes imageAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.Point destPoint, valuetype System.Drawing.Rectangle srcRect, valuetype System.Drawing.GraphicsUnit unit, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData, class System.Drawing.Imaging.ImageAttributes imageAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Point,System.Drawing.Rectangle,System.Drawing.GraphicsUnit,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr,System.Drawing.Imaging.ImageAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::Point destPoint, System::Drawing::Rectangle srcRect, System::Drawing::GraphicsUnit unit, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData, System::Drawing::Imaging::ImageAttributes ^ imageAttr);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.Point * System.Drawing.Rectangle * System.Drawing.GraphicsUnit * System.Drawing.Graphics.EnumerateMetafileProc * nativeint * System.Drawing.Imaging.ImageAttributes -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoint, srcRect, unit, callback, callbackData, imageAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoint" Type="System.Drawing.Point" />
        <Parameter Name="srcRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="unit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
      </Parameters>
      <Docs>
        <param name="metafile">Aufzulistendes <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
        <param name="destPoint"><see cref="T:System.Drawing.Point" />-Struktur, die die Position der oberen linken Ecke der gezeichneten Metadatei angibt.</param>
        <param name="srcRect"><see cref="T:System.Drawing.Rectangle" />-Struktur, die den zu zeichnenden Teil der Metadatei relativ zur oberen linken Ecke angibt.</param>
        <param name="unit">Member der <see cref="T:System.Drawing.GraphicsUnit" />-Enumeration, der die Maßeinheit angibt, mit der der Teil der Metadatei bestimmt wird, der in dem vom <paramref name="srcRect" />-Parameter angegebenen Rechteck enthalten ist.</param>
        <param name="callback"><see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" />-Delegat, der die Methode angibt, an die die Datensätze der Metadatei gesendet werden.</param>
        <param name="callbackData">Interner Zeiger, der erforderlich ist, aber ignoriert wird. Für diesen Parameter kann <see cref="F:System.IntPtr.Zero" /> übergeben werden.</param>
        <param name="imageAttr"><see cref="T:System.Drawing.Imaging.ImageAttributes" />, das Informationen über Bildattribute für das gezeichnete Bild angibt.</param>
        <summary>Sendet die Datensätze in einem ausgewählten Rechteck aus einem <see cref="T:System.Drawing.Imaging.Metafile" /> einzeln an eine Rückrufmethode, um sie unter Verwendung der angegebenen Bildattribute an einem angegebenen Punkt anzuzeigen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode listet die Datensätze auf, die in der angegebenen Metadatendatei enthalten sind. Jeder Datensatz wird einzeln an eine Rückruf Methode gesendet, die durch `callback` den-Parameter angegeben wird. In der Regel ruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> die Rückruf Methode die-Methode auf, um den Datensatz zu "wiedergeben" oder zu zeichnen.  
  
 Wenn die Rückruf Methode aufruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, muss Sie dies durch Aufrufen der <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> -Methode des spezifischen <xref:System.Drawing.Imaging.Metafile> tun, das aufgezählt wird.  
  
   
  
## Examples  
 Ein Codebeispiel finden Sie unter <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.Point[] destPoints, System.Drawing.Rectangle srcRect, System.Drawing.GraphicsUnit unit, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData, System.Drawing.Imaging.ImageAttributes imageAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.Point[] destPoints, valuetype System.Drawing.Rectangle srcRect, valuetype System.Drawing.GraphicsUnit unit, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData, class System.Drawing.Imaging.ImageAttributes imageAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Point[],System.Drawing.Rectangle,System.Drawing.GraphicsUnit,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr,System.Drawing.Imaging.ImageAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, cli::array &lt;System::Drawing::Point&gt; ^ destPoints, System::Drawing::Rectangle srcRect, System::Drawing::GraphicsUnit unit, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData, System::Drawing::Imaging::ImageAttributes ^ imageAttr);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.Point[] * System.Drawing.Rectangle * System.Drawing.GraphicsUnit * System.Drawing.Graphics.EnumerateMetafileProc * nativeint * System.Drawing.Imaging.ImageAttributes -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoints, srcRect, unit, callback, callbackData, imageAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoints" Type="System.Drawing.Point[]" />
        <Parameter Name="srcRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="unit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
      </Parameters>
      <Docs>
        <param name="metafile">Aufzulistendes <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
        <param name="destPoints">Array von drei <see cref="T:System.Drawing.Point" />-Strukturen, die ein Parallelogramm definieren, das die Größe und Position der gezeichneten Metadatei bestimmt.</param>
        <param name="srcRect"><see cref="T:System.Drawing.Rectangle" />-Struktur, die den zu zeichnenden Teil der Metadatei relativ zur oberen linken Ecke angibt.</param>
        <param name="unit">Member der <see cref="T:System.Drawing.GraphicsUnit" />-Enumeration, der die Maßeinheit angibt, mit der der Teil der Metadatei bestimmt wird, der in dem vom <paramref name="srcRect" />-Parameter angegebenen Rechteck enthalten ist.</param>
        <param name="callback"><see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" />-Delegat, der die Methode angibt, an die die Datensätze der Metadatei gesendet werden.</param>
        <param name="callbackData">Interner Zeiger, der erforderlich ist, aber ignoriert wird. Für diesen Parameter kann <see cref="F:System.IntPtr.Zero" /> übergeben werden.</param>
        <param name="imageAttr"><see cref="T:System.Drawing.Imaging.ImageAttributes" />, das Informationen über Bildattribute für das gezeichnete Bild angibt.</param>
        <summary>Sendet die Datensätze in einem ausgewählten Rechteck von einem <see cref="T:System.Drawing.Imaging.Metafile" /> einzeln an eine Rückrufmethode, um sie in einem angegebenen Parallelogramm unter Verwendung von angegebenen Bildattributen anzuzeigen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode listet die Datensätze auf, die in der angegebenen Metadatendatei enthalten sind. Jeder Datensatz wird einzeln an eine Rückruf Methode gesendet, die durch `callback` den-Parameter angegeben wird. In der Regel ruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> die Rückruf Methode die-Methode auf, um den Datensatz zu "wiedergeben" oder zu zeichnen.  
  
 Wenn die Rückruf Methode aufruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, muss Sie dies durch Aufrufen der <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> -Methode des spezifischen <xref:System.Drawing.Imaging.Metafile> tun, das aufgezählt wird.  
  
 Der `destPoints` -Parameter gibt drei Punkte eines Parallelogramms an. Die drei <xref:System.Drawing.Point> -Strukturen stellen die oberen linken, oberen rechten und unteren linken Ecke des parallelograms dar. Der vierte Punkt wird von den ersten drei extrapoliert, um ein Parallelogram zu bilden. Die gezeichnete Metadatendatei wird skaliert und an das Parallelogramm angepasst.  
  
 Jede Zeichnung, die außerhalb des durch den `srcRect` -Parameter angegebenen Rechtecks stattfindet, wird ignoriert.  
  
 Die durch den `imageAttr` -Parameter angegebenen Bildattribute ersetzen die beim Schreiben der Metadatendatei angegebenen.  
  
   
  
## Examples  
 Ein Codebeispiel finden Sie unter <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.PointF destPoint, System.Drawing.RectangleF srcRect, System.Drawing.GraphicsUnit unit, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData, System.Drawing.Imaging.ImageAttributes imageAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.PointF destPoint, valuetype System.Drawing.RectangleF srcRect, valuetype System.Drawing.GraphicsUnit unit, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData, class System.Drawing.Imaging.ImageAttributes imageAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.PointF,System.Drawing.RectangleF,System.Drawing.GraphicsUnit,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr,System.Drawing.Imaging.ImageAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::PointF destPoint, System::Drawing::RectangleF srcRect, System::Drawing::GraphicsUnit unit, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData, System::Drawing::Imaging::ImageAttributes ^ imageAttr);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.PointF * System.Drawing.RectangleF * System.Drawing.GraphicsUnit * System.Drawing.Graphics.EnumerateMetafileProc * nativeint * System.Drawing.Imaging.ImageAttributes -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoint, srcRect, unit, callback, callbackData, imageAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoint" Type="System.Drawing.PointF" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="unit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
      </Parameters>
      <Docs>
        <param name="metafile">Aufzulistendes <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
        <param name="destPoint"><see cref="T:System.Drawing.PointF" />-Struktur, die die Position der oberen linken Ecke der gezeichneten Metadatei angibt.</param>
        <param name="srcRect"><see cref="T:System.Drawing.RectangleF" />-Struktur, die den zu zeichnenden Teil der Metadatei relativ zur oberen linken Ecke angibt.</param>
        <param name="unit">Member der <see cref="T:System.Drawing.GraphicsUnit" />-Enumeration, der die Maßeinheit angibt, mit der der Teil der Metadatei bestimmt wird, der in dem vom <paramref name="srcRect" />-Parameter angegebenen Rechteck enthalten ist.</param>
        <param name="callback"><see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" />-Delegat, der die Methode angibt, an die die Datensätze der Metadatei gesendet werden.</param>
        <param name="callbackData">Interner Zeiger, der erforderlich ist, aber ignoriert wird. Für diesen Parameter kann <see cref="F:System.IntPtr.Zero" /> übergeben werden.</param>
        <param name="imageAttr"><see cref="T:System.Drawing.Imaging.ImageAttributes" />, das Informationen über Bildattribute für das gezeichnete Bild angibt.</param>
        <summary>Sendet die Datensätze in einem ausgewählten Rechteck aus einem <see cref="T:System.Drawing.Imaging.Metafile" /> einzeln an eine Rückrufmethode, um sie unter Verwendung der angegebenen Bildattribute an einem angegebenen Punkt anzuzeigen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode listet die Datensätze auf, die in der angegebenen Metadatendatei enthalten sind. Jeder Datensatz wird einzeln an eine Rückruf Methode gesendet, die durch `callback` den-Parameter angegeben wird. In der Regel ruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> die Rückruf Methode die-Methode auf, um den Datensatz zu "wiedergeben" oder zu zeichnen.  
  
 Wenn die Rückruf Methode aufruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, muss Sie dies durch Aufrufen der <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> -Methode des spezifischen <xref:System.Drawing.Imaging.Metafile> tun, das aufgezählt wird.  
  
 Jede Zeichnung, die außerhalb des durch den `srcRect` -Parameter angegebenen Rechtecks stattfindet, wird ignoriert.  
  
 Die durch den `imageAttr` -Parameter angegebenen Bildattribute ersetzen die beim Schreiben der Metadatendatei angegebenen.  
  
   
  
## Examples  
 Ein Codebeispiel finden Sie unter <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.PointF[] destPoints, System.Drawing.RectangleF srcRect, System.Drawing.GraphicsUnit unit, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData, System.Drawing.Imaging.ImageAttributes imageAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.PointF[] destPoints, valuetype System.Drawing.RectangleF srcRect, valuetype System.Drawing.GraphicsUnit unit, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData, class System.Drawing.Imaging.ImageAttributes imageAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.PointF[],System.Drawing.RectangleF,System.Drawing.GraphicsUnit,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr,System.Drawing.Imaging.ImageAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, cli::array &lt;System::Drawing::PointF&gt; ^ destPoints, System::Drawing::RectangleF srcRect, System::Drawing::GraphicsUnit unit, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData, System::Drawing::Imaging::ImageAttributes ^ imageAttr);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.PointF[] * System.Drawing.RectangleF * System.Drawing.GraphicsUnit * System.Drawing.Graphics.EnumerateMetafileProc * nativeint * System.Drawing.Imaging.ImageAttributes -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoints, srcRect, unit, callback, callbackData, imageAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoints" Type="System.Drawing.PointF[]" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="unit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
      </Parameters>
      <Docs>
        <param name="metafile">Aufzulistendes <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
        <param name="destPoints">Array von drei <see cref="T:System.Drawing.PointF" />-Strukturen, die ein Parallelogramm definieren, das die Größe und Position der gezeichneten Metadatei bestimmt.</param>
        <param name="srcRect"><see cref="T:System.Drawing.RectangleF" />-Struktur, die den zu zeichnenden Teil der Metadatei relativ zur oberen linken Ecke angibt.</param>
        <param name="unit">Member der <see cref="T:System.Drawing.GraphicsUnit" />-Enumeration, der die Maßeinheit angibt, mit der der Teil der Metadatei bestimmt wird, der in dem vom <paramref name="srcRect" />-Parameter angegebenen Rechteck enthalten ist.</param>
        <param name="callback"><see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" />-Delegat, der die Methode angibt, an die die Datensätze der Metadatei gesendet werden.</param>
        <param name="callbackData">Interner Zeiger, der erforderlich ist, aber ignoriert wird. Für diesen Parameter kann <see cref="F:System.IntPtr.Zero" /> übergeben werden.</param>
        <param name="imageAttr"><see cref="T:System.Drawing.Imaging.ImageAttributes" />, das Informationen über Bildattribute für das gezeichnete Bild angibt.</param>
        <summary>Sendet die Datensätze in einem ausgewählten Rechteck von einem <see cref="T:System.Drawing.Imaging.Metafile" /> einzeln an eine Rückrufmethode, um sie in einem angegebenen Parallelogramm unter Verwendung von angegebenen Bildattributen anzuzeigen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode listet die Datensätze auf, die in der angegebenen Metadatendatei enthalten sind. Jeder Datensatz wird einzeln an eine Rückruf Methode gesendet, die durch `callback` den-Parameter angegeben wird. In der Regel ruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> die Rückruf Methode die-Methode auf, um den Datensatz zu "wiedergeben" oder zu zeichnen.  
  
 Wenn die Rückruf Methode aufruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, muss Sie dies durch Aufrufen der <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> -Methode des spezifischen <xref:System.Drawing.Imaging.Metafile> tun, das aufgezählt wird.  
  
 Der `destPoints` -Parameter gibt drei Punkte eines Parallelogramms an. Die drei <xref:System.Drawing.PointF> -Strukturen stellen die oberen linken, oberen rechten und unteren linken Ecke des parallelograms dar. Der vierte Punkt wird von den ersten drei extrapoliert, um ein Parallelogram zu bilden. Die gezeichnete Metadatendatei wird skaliert und an das Parallelogramm angepasst.  
  
 Jede Zeichnung, die außerhalb des durch den `srcRect` -Parameter angegebenen Rechtecks stattfindet, wird ignoriert.  
  
 Die durch den `imageAttr` -Parameter angegebenen Bildattribute ersetzen die beim Schreiben der Metadatendatei angegebenen.  
  
   
  
## Examples  
 Ein Codebeispiel finden Sie unter <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.Rectangle destRect, System.Drawing.Rectangle srcRect, System.Drawing.GraphicsUnit unit, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData, System.Drawing.Imaging.ImageAttributes imageAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.Rectangle destRect, valuetype System.Drawing.Rectangle srcRect, valuetype System.Drawing.GraphicsUnit unit, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData, class System.Drawing.Imaging.ImageAttributes imageAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Rectangle,System.Drawing.Rectangle,System.Drawing.GraphicsUnit,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr,System.Drawing.Imaging.ImageAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::Rectangle destRect, System::Drawing::Rectangle srcRect, System::Drawing::GraphicsUnit unit, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData, System::Drawing::Imaging::ImageAttributes ^ imageAttr);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.Rectangle * System.Drawing.Rectangle * System.Drawing.GraphicsUnit * System.Drawing.Graphics.EnumerateMetafileProc * nativeint * System.Drawing.Imaging.ImageAttributes -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destRect, srcRect, unit, callback, callbackData, imageAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="unit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
      </Parameters>
      <Docs>
        <param name="metafile">Aufzulistendes <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
        <param name="destRect"><see cref="T:System.Drawing.Rectangle" />-Struktur, die die Position und Größe der gezeichneten Metadatei angibt.</param>
        <param name="srcRect"><see cref="T:System.Drawing.Rectangle" />-Struktur, die den zu zeichnenden Teil der Metadatei relativ zur oberen linken Ecke angibt.</param>
        <param name="unit">Member der <see cref="T:System.Drawing.GraphicsUnit" />-Enumeration, der die Maßeinheit angibt, mit der der Teil der Metadatei bestimmt wird, der in dem vom <paramref name="srcRect" />-Parameter angegebenen Rechteck enthalten ist.</param>
        <param name="callback"><see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" />-Delegat, der die Methode angibt, an die die Datensätze der Metadatei gesendet werden.</param>
        <param name="callbackData">Interner Zeiger, der erforderlich ist, aber ignoriert wird. Für diesen Parameter kann <see cref="F:System.IntPtr.Zero" /> übergeben werden.</param>
        <param name="imageAttr"><see cref="T:System.Drawing.Imaging.ImageAttributes" />, das Informationen über Bildattribute für das gezeichnete Bild angibt.</param>
        <summary>Sendet die Datensätze eines ausgewählten Rechtecks von einem <see cref="T:System.Drawing.Imaging.Metafile" /> einzeln an eine Rückrufmethode, um sie in einem angegebenen Rechteck unter Verwendung von angegebenen Bildattributen anzuzeigen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode listet die Datensätze auf, die in der angegebenen Metadatendatei enthalten sind. Jeder Datensatz wird einzeln an eine Rückruf Methode gesendet, die durch `callback` den-Parameter angegeben wird. In der Regel ruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> die Rückruf Methode die-Methode auf, um den Datensatz zu "wiedergeben" oder zu zeichnen.  
  
 Wenn die Rückruf Methode aufruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, muss Sie dies durch Aufrufen der <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> -Methode des spezifischen <xref:System.Drawing.Imaging.Metafile> tun, das aufgezählt wird.  
  
 Jede Zeichnung, die außerhalb des durch den `srcRect` -Parameter angegebenen Rechtecks stattfindet, wird ignoriert.  
  
 Die durch den `imageAttr` -Parameter angegebenen Bildattribute ersetzen die beim Schreiben der Metadatendatei angegebenen.  
  
   
  
## Examples  
 Ein Codebeispiel finden Sie unter <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.RectangleF destRect, System.Drawing.RectangleF srcRect, System.Drawing.GraphicsUnit unit, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData, System.Drawing.Imaging.ImageAttributes imageAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.RectangleF destRect, valuetype System.Drawing.RectangleF srcRect, valuetype System.Drawing.GraphicsUnit unit, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData, class System.Drawing.Imaging.ImageAttributes imageAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.RectangleF,System.Drawing.RectangleF,System.Drawing.GraphicsUnit,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr,System.Drawing.Imaging.ImageAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::RectangleF destRect, System::Drawing::RectangleF srcRect, System::Drawing::GraphicsUnit unit, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData, System::Drawing::Imaging::ImageAttributes ^ imageAttr);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.RectangleF * System.Drawing.RectangleF * System.Drawing.GraphicsUnit * System.Drawing.Graphics.EnumerateMetafileProc * nativeint * System.Drawing.Imaging.ImageAttributes -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destRect, srcRect, unit, callback, callbackData, imageAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="unit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
      </Parameters>
      <Docs>
        <param name="metafile">Aufzulistendes <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
        <param name="destRect"><see cref="T:System.Drawing.RectangleF" />-Struktur, die die Position und Größe der gezeichneten Metadatei angibt.</param>
        <param name="srcRect"><see cref="T:System.Drawing.RectangleF" />-Struktur, die den zu zeichnenden Teil der Metadatei relativ zur oberen linken Ecke angibt.</param>
        <param name="unit">Member der <see cref="T:System.Drawing.GraphicsUnit" />-Enumeration, der die Maßeinheit angibt, mit der der Teil der Metadatei bestimmt wird, der in dem vom <paramref name="srcRect" />-Parameter angegebenen Rechteck enthalten ist.</param>
        <param name="callback"><see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" />-Delegat, der die Methode angibt, an die die Datensätze der Metadatei gesendet werden.</param>
        <param name="callbackData">Interner Zeiger, der erforderlich ist, aber ignoriert wird. Für diesen Parameter kann <see cref="F:System.IntPtr.Zero" /> übergeben werden.</param>
        <param name="imageAttr"><see cref="T:System.Drawing.Imaging.ImageAttributes" />, das Informationen über Bildattribute für das gezeichnete Bild angibt.</param>
        <summary>Sendet die Datensätze eines ausgewählten Rechtecks von einem <see cref="T:System.Drawing.Imaging.Metafile" /> einzeln an eine Rückrufmethode, um sie in einem angegebenen Rechteck unter Verwendung von angegebenen Bildattributen anzuzeigen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode listet die Datensätze auf, die in der angegebenen Metadatendatei enthalten sind. Jeder Datensatz wird einzeln an eine Rückruf Methode gesendet, die durch `callback` den-Parameter angegeben wird. In der Regel ruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> die Rückruf Methode die-Methode auf, um den Datensatz zu "wiedergeben" oder zu zeichnen.  
  
 Wenn die Rückruf Methode aufruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, muss Sie dies durch Aufrufen der <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> -Methode des spezifischen <xref:System.Drawing.Imaging.Metafile> tun, das aufgezählt wird.  
  
 Jede Zeichnung, die außerhalb des durch den `srcRect` -Parameter angegebenen Rechtecks stattfindet, wird ignoriert.  
  
 Die durch den `imageAttr` -Parameter angegebenen Bildattribute ersetzen die beim Schreiben der Metadatendatei angegebenen.  
  
   
  
## Examples  
 Ein Codebeispiel finden Sie unter <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ExcludeClip">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Aktualisiert den Ausschneidebereich dieses <see cref="T:System.Drawing.Graphics" />, um den durch eine <see cref="T:System.Drawing.Rectangle" />-Struktur angegebenen Bereich auszuschließen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ExcludeClip">
      <MemberSignature Language="C#" Value="public void ExcludeClip (System.Drawing.Rectangle rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExcludeClip(valuetype System.Drawing.Rectangle rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.ExcludeClip(System.Drawing.Rectangle)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExcludeClip (rect As Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExcludeClip(System::Drawing::Rectangle rect);" />
      <MemberSignature Language="F#" Value="member this.ExcludeClip : System.Drawing.Rectangle -&gt; unit" Usage="graphics.ExcludeClip rect" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="rect"><see cref="T:System.Drawing.Rectangle" />-Struktur, die das Rechteck angibt, das aus dem Ausschneidebereich ausgeschlossen wird.</param>
        <summary>Aktualisiert den Ausschneidebereich dieses <see cref="T:System.Drawing.Graphics" />, um den durch eine <see cref="T:System.Drawing.Rectangle" />-Struktur angegebenen Bereich auszuschließen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode schließt den vom `rect` -Parameter angegebenen Bereich aus dem aktuellen Clip Bereich aus und weist der- <xref:System.Drawing.Graphics.Clip%2A> Eigenschaft dieses <xref:System.Drawing.Graphics>den resultierenden Bereich zu.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein 100 Pixel um 100 Pixel Rechteck, dessen obere linke Ecke an der Koordinate (100, 100) liegt.  
  
-   Erstellt einen durch das Rechteck definierten Bereich.  
  
-   Legt den Ausschneide Bereich so fest, dass der rechteckige Bereich ausgeschlossen wird.  
  
-   Füllt ein 300 Pixel nach 300 Pixel Rechteck aus, dessen obere linke Ecke bei der Koordinate (0,0) mit einem Pinsel mit festem blau ist.  
  
 Das Ergebnis ist ein blaues Rechteck, bei dem eine quadratische Region in der unteren rechten Ecke fehlt.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#92](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#92)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#92](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#92)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#92](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#92)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExcludeClip">
      <MemberSignature Language="C#" Value="public void ExcludeClip (System.Drawing.Region region);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExcludeClip(class System.Drawing.Region region) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.ExcludeClip(System.Drawing.Region)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExcludeClip(System::Drawing::Region ^ region);" />
      <MemberSignature Language="F#" Value="member this.ExcludeClip : System.Drawing.Region -&gt; unit" Usage="graphics.ExcludeClip region" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="region" Type="System.Drawing.Region" />
      </Parameters>
      <Docs>
        <param name="region"><see cref="T:System.Drawing.Region" />, der den Bereich angibt, der aus dem Ausschneidebereich ausgeschlossen werden soll.</param>
        <summary>Aktualisiert den Ausschneidebereich dieses <see cref="T:System.Drawing.Graphics" />, um den durch einen <see cref="T:System.Drawing.Region" /> angegebenen Bereich auszuschließen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode schließt den vom `region` -Parameter angegebenen Bereich aus dem aktuellen Clip Bereich aus und weist der- <xref:System.Drawing.Graphics.Clip%2A> Eigenschaft dieses <xref:System.Drawing.Graphics>den resultierenden Bereich zu.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein 100 Pixel um 100 Pixel Rechteck, dessen obere linke Ecke an der Koordinate (100, 100) liegt.  
  
-   Legt den Ausschneide Bereich fest, um das Rechteck auszuschließen.  
  
-   Füllt ein 300 Pixel nach 300 Pixel Rechteck aus, dessen obere linke Ecke bei der Koordinate (0,0) mit einem Pinsel mit festem blau ist.  
  
 Das Ergebnis ist ein blaues Rechteck mit einem quadratischen Bereich in der rechten unteren Ecke.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#91](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#91)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#91](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#91)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#91](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#91)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="FillClosedCurve">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Füllt das Innere einer geschlossenen Cardinal-Splinekurve, die durch ein Array von <see cref="T:System.Drawing.Point" />-Strukturen definiert ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FillClosedCurve">
      <MemberSignature Language="C#" Value="public void FillClosedCurve (System.Drawing.Brush brush, System.Drawing.Point[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillClosedCurve(class System.Drawing.Brush brush, valuetype System.Drawing.Point[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillClosedCurve(System.Drawing.Brush,System.Drawing.Point[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillClosedCurve(System::Drawing::Brush ^ brush, cli::array &lt;System::Drawing::Point&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.FillClosedCurve : System.Drawing.Brush * System.Drawing.Point[] -&gt; unit" Usage="graphics.FillClosedCurve (brush, points)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="points" Type="System.Drawing.Point[]" />
      </Parameters>
      <Docs>
        <param name="brush"><see cref="T:System.Drawing.Brush" />, der die Merkmale des Füllvorgangs bestimmt.</param>
        <param name="points">Array von <see cref="T:System.Drawing.Point" />-Strukturen, die die Splinekurve definieren.</param>
        <summary>Füllt das Innere einer geschlossenen Cardinal-Splinekurve, die durch ein Array von <see cref="T:System.Drawing.Point" />-Strukturen definiert ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode füllt das Innere einer geschlossenen Cardinal-Spline, die die einzelnen Punkte im Array durchläuft. Wenn der letzte Punkt nicht mit dem ersten Punkt identisch ist, wird ein zusätzliches Kurven Segment vom letzten Punkt zum ersten Punkt hinzugefügt, um es zu schließen.  
  
 Das Array der Punkte muss mindestens vier <xref:System.Drawing.Point> Strukturen enthalten.  
  
 Diese Methode verwendet eine Standardspannung von 0,5.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen voll tonroten Pinsel.  
  
-   Erstellt ein Array aus vier Punkten, um einen Spline zu definieren.  
  
-   Füllt die Kurve auf dem Bildschirm.  
  
 Die Kurve hat eine Standardspannung von 0,5.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#93](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#93)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#93](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#93)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#93](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#93)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="points" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FillClosedCurve">
      <MemberSignature Language="C#" Value="public void FillClosedCurve (System.Drawing.Brush brush, System.Drawing.PointF[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillClosedCurve(class System.Drawing.Brush brush, valuetype System.Drawing.PointF[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillClosedCurve(System.Drawing.Brush,System.Drawing.PointF[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillClosedCurve(System::Drawing::Brush ^ brush, cli::array &lt;System::Drawing::PointF&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.FillClosedCurve : System.Drawing.Brush * System.Drawing.PointF[] -&gt; unit" Usage="graphics.FillClosedCurve (brush, points)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
      </Parameters>
      <Docs>
        <param name="brush"><see cref="T:System.Drawing.Brush" />, der die Merkmale des Füllvorgangs bestimmt.</param>
        <param name="points">Array von <see cref="T:System.Drawing.PointF" />-Strukturen, die die Splinekurve definieren.</param>
        <summary>Füllt das Innere einer geschlossenen Cardinal-Splinekurve, die durch ein Array von <see cref="T:System.Drawing.PointF" />-Strukturen definiert ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode füllt das Innere einer geschlossenen Cardinal-Spline, die die einzelnen Punkte im Array durchläuft. Wenn der letzte Punkt nicht mit dem ersten Punkt identisch ist, wird ein zusätzliches Kurven Segment vom letzten Punkt zum ersten Punkt hinzugefügt, um es zu schließen.  
  
 Das Array der Punkte muss mindestens vier <xref:System.Drawing.PointF> Strukturen enthalten.  
  
 Diese Methode verwendet eine Standardspannung von 0,5.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen voll tonroten Pinsel.  
  
-   Erstellt ein Array aus vier Punkten, um einen Spline zu definieren.  
  
-   Füllt die Kurve auf dem Bildschirm.  
  
 Die Kurve hat eine Standardspannung von 0,5.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#96](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#96)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#96](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#96)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#96](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#96)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="points" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FillClosedCurve">
      <MemberSignature Language="C#" Value="public void FillClosedCurve (System.Drawing.Brush brush, System.Drawing.Point[] points, System.Drawing.Drawing2D.FillMode fillmode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillClosedCurve(class System.Drawing.Brush brush, valuetype System.Drawing.Point[] points, valuetype System.Drawing.Drawing2D.FillMode fillmode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillClosedCurve(System.Drawing.Brush,System.Drawing.Point[],System.Drawing.Drawing2D.FillMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillClosedCurve(System::Drawing::Brush ^ brush, cli::array &lt;System::Drawing::Point&gt; ^ points, System::Drawing::Drawing2D::FillMode fillmode);" />
      <MemberSignature Language="F#" Value="member this.FillClosedCurve : System.Drawing.Brush * System.Drawing.Point[] * System.Drawing.Drawing2D.FillMode -&gt; unit" Usage="graphics.FillClosedCurve (brush, points, fillmode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="points" Type="System.Drawing.Point[]" />
        <Parameter Name="fillmode" Type="System.Drawing.Drawing2D.FillMode" />
      </Parameters>
      <Docs>
        <param name="brush"><see cref="T:System.Drawing.Brush" />, der die Merkmale des Füllvorgangs bestimmt.</param>
        <param name="points">Array von <see cref="T:System.Drawing.Point" />-Strukturen, die die Splinekurve definieren.</param>
        <param name="fillmode">Member der <see cref="T:System.Drawing.Drawing2D.FillMode" />-Enumeration, der bestimmt, wie die Kurve ausgefüllt wird.</param>
        <summary>Füllt das Innere einer geschlossenen Cardinal-Splinekurve, die durch ein Array von <see cref="T:System.Drawing.Point" />-Strukturen definiert ist, im angegebenen Füllmodus aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode füllt das Innere einer geschlossenen Cardinal-Spline, die die einzelnen Punkte im Array durchläuft. Wenn der letzte Punkt nicht mit dem ersten Punkt identisch ist, wird ein zusätzliches Kurven Segment vom letzten Punkt zum ersten Punkt hinzugefügt, um es zu schließen.  
  
 Das Array der Punkte muss mindestens vier <xref:System.Drawing.Point> Strukturen enthalten.  
  
 Diese Methode verwendet eine Standardspannung von 0,5.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen voll tonroten Pinsel.  
  
-   Erstellt ein Array aus vier Punkten, um einen Spline zu definieren.  
  
-   Legt den Füll Modus auf <xref:System.Drawing.Drawing2D.FillMode.Winding>fest.  
  
-   Füllt die Kurve auf dem Bildschirm.  
  
 Die Kurve hat eine Standardspannung von 0,5.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#94](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#94)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#94](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#94)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#94](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#94)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="points" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FillClosedCurve">
      <MemberSignature Language="C#" Value="public void FillClosedCurve (System.Drawing.Brush brush, System.Drawing.PointF[] points, System.Drawing.Drawing2D.FillMode fillmode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillClosedCurve(class System.Drawing.Brush brush, valuetype System.Drawing.PointF[] points, valuetype System.Drawing.Drawing2D.FillMode fillmode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillClosedCurve(System.Drawing.Brush,System.Drawing.PointF[],System.Drawing.Drawing2D.FillMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillClosedCurve(System::Drawing::Brush ^ brush, cli::array &lt;System::Drawing::PointF&gt; ^ points, System::Drawing::Drawing2D::FillMode fillmode);" />
      <MemberSignature Language="F#" Value="member this.FillClosedCurve : System.Drawing.Brush * System.Drawing.PointF[] * System.Drawing.Drawing2D.FillMode -&gt; unit" Usage="graphics.FillClosedCurve (brush, points, fillmode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
        <Parameter Name="fillmode" Type="System.Drawing.Drawing2D.FillMode" />
      </Parameters>
      <Docs>
        <param name="brush"><see cref="T:System.Drawing.Brush" />, der die Merkmale des Füllvorgangs bestimmt.</param>
        <param name="points">Array von <see cref="T:System.Drawing.PointF" />-Strukturen, die die Splinekurve definieren.</param>
        <param name="fillmode">Member der <see cref="T:System.Drawing.Drawing2D.FillMode" />-Enumeration, der bestimmt, wie die Kurve ausgefüllt wird.</param>
        <summary>Füllt das Innere einer geschlossenen Cardinal-Splinekurve, die durch ein Array von <see cref="T:System.Drawing.PointF" />-Strukturen definiert ist, im angegebenen Füllmodus aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode füllt das Innere einer geschlossenen Cardinal-Spline, die die einzelnen Punkte im Array durchläuft. Wenn der letzte Punkt nicht mit dem ersten Punkt identisch ist, wird ein zusätzliches Kurven Segment vom letzten Punkt zum ersten Punkt hinzugefügt, um es zu schließen.  
  
 Das Array der Punkte muss mindestens vier <xref:System.Drawing.Point> Strukturen enthalten.  
  
 Diese Methode verwendet eine Standardspannung von 0,5.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen voll tonroten Pinsel.  
  
-   Erstellt ein Array aus vier Punkten, um einen Spline zu definieren.  
  
-   Legt den Füll Modus auf <xref:System.Drawing.Drawing2D.FillMode.Winding>fest.  
  
-   Füllt die Kurve auf dem Bildschirm.  
  
 Die Kurve hat eine Standardspannung von 0,5.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#97](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#97)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#97](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#97)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#97](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#97)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="points" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FillClosedCurve">
      <MemberSignature Language="C#" Value="public void FillClosedCurve (System.Drawing.Brush brush, System.Drawing.Point[] points, System.Drawing.Drawing2D.FillMode fillmode, float tension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillClosedCurve(class System.Drawing.Brush brush, valuetype System.Drawing.Point[] points, valuetype System.Drawing.Drawing2D.FillMode fillmode, float32 tension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillClosedCurve(System.Drawing.Brush,System.Drawing.Point[],System.Drawing.Drawing2D.FillMode,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillClosedCurve(System::Drawing::Brush ^ brush, cli::array &lt;System::Drawing::Point&gt; ^ points, System::Drawing::Drawing2D::FillMode fillmode, float tension);" />
      <MemberSignature Language="F#" Value="member this.FillClosedCurve : System.Drawing.Brush * System.Drawing.Point[] * System.Drawing.Drawing2D.FillMode * single -&gt; unit" Usage="graphics.FillClosedCurve (brush, points, fillmode, tension)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="points" Type="System.Drawing.Point[]" />
        <Parameter Name="fillmode" Type="System.Drawing.Drawing2D.FillMode" />
        <Parameter Name="tension" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="brush"><see cref="T:System.Drawing.Brush" />, der die Merkmale des Füllvorgangs bestimmt.</param>
        <param name="points">Array von <see cref="T:System.Drawing.Point" />-Strukturen, die die Splinekurve definieren.</param>
        <param name="fillmode">Member der <see cref="T:System.Drawing.Drawing2D.FillMode" />-Enumeration, der bestimmt, wie die Kurve ausgefüllt wird.</param>
        <param name="tension">Ein Wert größer oder gleich 0,0F, der die Spannung der Kurve angibt.</param>
        <summary>Füllt das Innere einer geschlossenen Cardinal-Splinekurve, die durch ein Array von <see cref="T:System.Drawing.Point" />-Strukturen definiert ist, im angegebenen Füllmodus und mit der angegebenen Spannung aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode füllt das Innere einer geschlossenen Cardinal-Spline, die die einzelnen Punkte im Array durchläuft. Wenn der letzte Punkt nicht mit dem ersten Punkt identisch ist, wird ein zusätzliches Kurven Segment vom letzten Punkt zum ersten Punkt hinzugefügt, um es zu schließen.  
  
 Das Array der Punkte muss mindestens vier <xref:System.Drawing.Point> Strukturen enthalten.  
  
 Der `tension` -Parameter bestimmt die Form der Spline. Wenn der Wert des `tension` -Parameters 0,0 f ist, zeichnet diese Methode gerade Liniensegmente, um die Punkte zu verbinden. Normalerweise ist `tension` der-Parameter kleiner oder gleich 1.0 f. Werte über 1.0 f verursachen ungewöhnliche Ergebnisse.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen voll tonroten Pinsel.  
  
-   Erstellt ein Array aus vier Punkten, um einen Spline zu definieren.  
  
-   Legt den Füll Modus auf <xref:System.Drawing.Drawing2D.FillMode.Winding>fest.  
  
-   Legt die Spannung auf 1,0 fest.  
  
-   Füllt die Kurve auf dem Bildschirm.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#95](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#95)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#95](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#95)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#95](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#95)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="points" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FillClosedCurve">
      <MemberSignature Language="C#" Value="public void FillClosedCurve (System.Drawing.Brush brush, System.Drawing.PointF[] points, System.Drawing.Drawing2D.FillMode fillmode, float tension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillClosedCurve(class System.Drawing.Brush brush, valuetype System.Drawing.PointF[] points, valuetype System.Drawing.Drawing2D.FillMode fillmode, float32 tension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillClosedCurve(System.Drawing.Brush,System.Drawing.PointF[],System.Drawing.Drawing2D.FillMode,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillClosedCurve(System::Drawing::Brush ^ brush, cli::array &lt;System::Drawing::PointF&gt; ^ points, System::Drawing::Drawing2D::FillMode fillmode, float tension);" />
      <MemberSignature Language="F#" Value="member this.FillClosedCurve : System.Drawing.Brush * System.Drawing.PointF[] * System.Drawing.Drawing2D.FillMode * single -&gt; unit" Usage="graphics.FillClosedCurve (brush, points, fillmode, tension)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
        <Parameter Name="fillmode" Type="System.Drawing.Drawing2D.FillMode" />
        <Parameter Name="tension" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="brush">Ein <see cref="T:System.Drawing.Brush" />, der die Merkmale des Füllvorgangs bestimmt.</param>
        <param name="points">Array von <see cref="T:System.Drawing.PointF" />-Strukturen, die die Splinekurve definieren.</param>
        <param name="fillmode">Member der <see cref="T:System.Drawing.Drawing2D.FillMode" />-Enumeration, der bestimmt, wie die Kurve ausgefüllt wird.</param>
        <param name="tension">Ein Wert größer oder gleich 0,0F, der die Spannung der Kurve angibt.</param>
        <summary>Füllt das Innere einer geschlossenen Cardinal-Splinekurve, die durch ein Array von <see cref="T:System.Drawing.PointF" />-Strukturen definiert ist, im angegebenen Füllmodus und mit der angegebenen Spannung aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode füllt das Innere einer geschlossenen Cardinal-Spline, die die einzelnen Punkte im Array durchläuft. Wenn der letzte Punkt nicht mit dem ersten Punkt identisch ist, wird ein zusätzliches Kurven Segment vom letzten Punkt zum ersten Punkt hinzugefügt, um es zu schließen.  
  
 Das Array der Punkte muss mindestens vier <xref:System.Drawing.Point> Strukturen enthalten.  
  
 Der `tension` -Parameter bestimmt die Form der Spline. Wenn der Wert des `tension` -Parameters 0,0 f ist, zeichnet diese Methode gerade Liniensegmente, um die Punkte zu verbinden. Normalerweise ist `tension` der-Parameter kleiner oder gleich 1.0 f. Werte über 1.0 f verursachen ungewöhnliche Ergebnisse.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen voll tonroten Pinsel.  
  
-   Erstellt ein Array aus vier Punkten, um einen Spline zu definieren.  
  
-   Legt den Füll Modus auf <xref:System.Drawing.Drawing2D.FillMode.Winding>fest.  
  
-   Legt die Spannung auf 1,0 fest.  
  
-   Füllt die Kurve auf dem Bildschirm.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#98](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#98)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#98](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#98)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#98](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="points" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="FillEllipse">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Füllt das Innere einer Ellipse, die durch ein umschließendes Rechteck definiert ist, das durch ein Koordinatenpaar, eine Höhen- und eine Breitenangabe angegeben ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FillEllipse">
      <MemberSignature Language="C#" Value="public void FillEllipse (System.Drawing.Brush brush, System.Drawing.Rectangle rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillEllipse(class System.Drawing.Brush brush, valuetype System.Drawing.Rectangle rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillEllipse(System.Drawing.Brush,System.Drawing.Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillEllipse(System::Drawing::Brush ^ brush, System::Drawing::Rectangle rect);" />
      <MemberSignature Language="F#" Value="member this.FillEllipse : System.Drawing.Brush * System.Drawing.Rectangle -&gt; unit" Usage="graphics.FillEllipse (brush, rect)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="brush"><see cref="T:System.Drawing.Brush" />, der die Merkmale des Füllvorgangs bestimmt.</param>
        <param name="rect"><see cref="T:System.Drawing.Rectangle" />-Struktur, die das umschließende Rechteck darstellt, das die Ellipse definiert.</param>
        <summary>Füllt das Innere einer Ellipse, die durch ein umschließendes Rechteck definiert ist, das durch eine <see cref="T:System.Drawing.Rectangle" />-Struktur angegeben ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode füllt das Innere einer Ellipse mit einem <xref:System.Drawing.Brush>. Die Ellipse wird durch das umgebende Rechteck definiert, das durch den `rect` -Parameter dargestellt wird.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen voll tonroten Pinsel.  
  
-   Erstellt ein Rechteck, das eine Ellipse umschließt.  
  
-   Füllt die Ellipse auf dem Bildschirm.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#99](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#99)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#99](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#99)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#99](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#99)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FillEllipse">
      <MemberSignature Language="C#" Value="public void FillEllipse (System.Drawing.Brush brush, System.Drawing.RectangleF rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillEllipse(class System.Drawing.Brush brush, valuetype System.Drawing.RectangleF rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillEllipse(System.Drawing.Brush,System.Drawing.RectangleF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillEllipse(System::Drawing::Brush ^ brush, System::Drawing::RectangleF rect);" />
      <MemberSignature Language="F#" Value="member this.FillEllipse : System.Drawing.Brush * System.Drawing.RectangleF -&gt; unit" Usage="graphics.FillEllipse (brush, rect)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="rect" Type="System.Drawing.RectangleF" />
      </Parameters>
      <Docs>
        <param name="brush"><see cref="T:System.Drawing.Brush" />, der die Merkmale des Füllvorgangs bestimmt.</param>
        <param name="rect"><see cref="T:System.Drawing.RectangleF" />-Struktur, die das umschließende Rechteck darstellt, das die Ellipse definiert.</param>
        <summary>Füllt das Innere einer Ellipse, die durch ein umschließendes Rechteck definiert ist, das durch eine <see cref="T:System.Drawing.RectangleF" />-Struktur angegeben ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode füllt das Innere einer Ellipse mit einem <xref:System.Drawing.Brush>. Die Ellipse wird durch das umgebende Rechteck definiert, das durch den `rect` -Parameter dargestellt wird.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen voll tonroten Pinsel.  
  
-   Erstellt ein Rechteck, das eine Ellipse umschließt.  
  
-   Füllt die Ellipse auf dem Bildschirm.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#100](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#100)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#100](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#100)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#100](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#100)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FillEllipse">
      <MemberSignature Language="C#" Value="public void FillEllipse (System.Drawing.Brush brush, int x, int y, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillEllipse(class System.Drawing.Brush brush, int32 x, int32 y, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillEllipse(System.Drawing.Brush,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillEllipse(System::Drawing::Brush ^ brush, int x, int y, int width, int height);" />
      <MemberSignature Language="F#" Value="member this.FillEllipse : System.Drawing.Brush * int * int * int * int -&gt; unit" Usage="graphics.FillEllipse (brush, x, y, width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="brush"><see cref="T:System.Drawing.Brush" />, der die Merkmale des Füllvorgangs bestimmt.</param>
        <param name="x">Die x-Koordinate der oberen linken Ecke des umschließenden Rechtecks, das die Ellipse definiert.</param>
        <param name="y">Die y-Koordinate der oberen linken Ecke des umschließenden Rechtecks, das die Ellipse definiert.</param>
        <param name="width">Breite des umschließenden Rechtecks, das die Ellipse definiert.</param>
        <param name="height">Höhe des umschließenden Rechtecks, das die Ellipse definiert.</param>
        <summary>Füllt das Innere einer Ellipse, die durch ein umschließendes Rechteck definiert ist, das durch ein Koordinatenpaar, eine Höhen- und eine Breitenangabe angegeben ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode füllt das Innere einer Ellipse mit einem <xref:System.Drawing.Brush>. Die Ellipse wird durch das Begrenzungs Rechteck definiert, das durch `x`die `y`Parameter `width`,, `height` und dargestellt wird.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen voll tonroten Pinsel.  
  
-   Erstellt die Position und Größe eines Rechtecks, das eine Ellipse umschließt.  
  
-   Füllt die Ellipse auf dem Bildschirm.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#101](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#101)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#101](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#101)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#101](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#101)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FillEllipse">
      <MemberSignature Language="C#" Value="public void FillEllipse (System.Drawing.Brush brush, float x, float y, float width, float height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillEllipse(class System.Drawing.Brush brush, float32 x, float32 y, float32 width, float32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillEllipse(System.Drawing.Brush,System.Single,System.Single,System.Single,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillEllipse(System::Drawing::Brush ^ brush, float x, float y, float width, float height);" />
      <MemberSignature Language="F#" Value="member this.FillEllipse : System.Drawing.Brush * single * single * single * single -&gt; unit" Usage="graphics.FillEllipse (brush, x, y, width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="width" Type="System.Single" />
        <Parameter Name="height" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="brush"><see cref="T:System.Drawing.Brush" />, der die Merkmale des Füllvorgangs bestimmt.</param>
        <param name="x">Die x-Koordinate der oberen linken Ecke des umschließenden Rechtecks, das die Ellipse definiert.</param>
        <param name="y">Die y-Koordinate der oberen linken Ecke des umschließenden Rechtecks, das die Ellipse definiert.</param>
        <param name="width">Breite des umschließenden Rechtecks, das die Ellipse definiert.</param>
        <param name="height">Höhe des umschließenden Rechtecks, das die Ellipse definiert.</param>
        <summary>Füllt das Innere einer Ellipse, die durch ein umschließendes Rechteck definiert ist, das durch ein Koordinatenpaar, eine Höhen- und eine Breitenangabe angegeben ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode füllt das Innere einer Ellipse mit einem <xref:System.Drawing.Brush>. Die Ellipse wird durch das Begrenzungs Rechteck definiert, das durch `x`die `y`Parameter `width`,, `height` und dargestellt wird.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen voll tonroten Pinsel.  
  
-   Erstellt die Position und Größe eines Rechtecks, das eine Ellipse umschließt.  
  
-   Füllt die Ellipse auf dem Bildschirm.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#102](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#102)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#102](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#102)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#102](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#102)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FillPath">
      <MemberSignature Language="C#" Value="public void FillPath (System.Drawing.Brush brush, System.Drawing.Drawing2D.GraphicsPath path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillPath(class System.Drawing.Brush brush, class System.Drawing.Drawing2D.GraphicsPath path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillPath(System.Drawing.Brush,System.Drawing.Drawing2D.GraphicsPath)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillPath(System::Drawing::Brush ^ brush, System::Drawing::Drawing2D::GraphicsPath ^ path);" />
      <MemberSignature Language="F#" Value="member this.FillPath : System.Drawing.Brush * System.Drawing.Drawing2D.GraphicsPath -&gt; unit" Usage="graphics.FillPath (brush, path)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="path" Type="System.Drawing.Drawing2D.GraphicsPath" />
      </Parameters>
      <Docs>
        <param name="brush"><see cref="T:System.Drawing.Brush" />, der die Merkmale des Füllvorgangs bestimmt.</param>
        <param name="path"><see cref="T:System.Drawing.Drawing2D.GraphicsPath" />, der den auszufüllenden Pfad darstellt.</param>
        <summary>Füllt das Innere von einem <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Drawing.Drawing2D.GraphicsPath> besteht aus einer Reihe von Linien-und Kurven Segmenten. Wenn der durch den `path` -Parameter dargestellte Pfad nicht geschlossen wird, wird vom letzten Punkt zum ersten Punkt ein zusätzliches Segment hinzugefügt, um den Pfad zu schließen.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen voll tonroten Pinsel.  
  
-   Erstellt ein Grafik Pfad Objekt.  
  
-   Fügt dem Grafik Pfad eine Ellipse hinzu.  
  
-   Füllt den Pfad auf dem Bildschirm aus.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#103](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#103)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#103](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#103)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#103](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#103)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="path" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="FillPie">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Füllt das Innere eines Kreisausschnitts, der durch eine Ellipse definiert wird, die durch ein Koordinatenpaar, eine Breiten- und eine Höhenangabe und zwei Radien angegeben ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FillPie">
      <MemberSignature Language="C#" Value="public void FillPie (System.Drawing.Brush brush, System.Drawing.Rectangle rect, float startAngle, float sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillPie(class System.Drawing.Brush brush, valuetype System.Drawing.Rectangle rect, float32 startAngle, float32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillPie(System.Drawing.Brush,System.Drawing.Rectangle,System.Single,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillPie(System::Drawing::Brush ^ brush, System::Drawing::Rectangle rect, float startAngle, float sweepAngle);" />
      <MemberSignature Language="F#" Value="member this.FillPie : System.Drawing.Brush * System.Drawing.Rectangle * single * single -&gt; unit" Usage="graphics.FillPie (brush, rect, startAngle, sweepAngle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
        <Parameter Name="startAngle" Type="System.Single" />
        <Parameter Name="sweepAngle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="brush"><see cref="T:System.Drawing.Brush" />, der die Merkmale des Füllvorgangs bestimmt.</param>
        <param name="rect"><see cref="T:System.Drawing.Rectangle" />-Struktur, die das umschließende Rechteck darstellt, das die Ellipse definiert, aus der der Kreisausschnitt stammt.</param>
        <param name="startAngle">Zwischen der x-Achse und der ersten Seite des Kreisausschnitts im Uhrzeigersinn gemessener Winkel in Grad.</param>
        <param name="sweepAngle">Zwischen dem <paramref name="startAngle" />-Parameter und der zweiten Seite des Kreisausschnitts im Uhrzeigersinn gemessener Winkel in Grad.</param>
        <summary>Füllt das Innere eines Kreisausschnitts, der durch eine Ellipse definiert ist, die durch eine <see cref="T:System.Drawing.RectangleF" />-Struktur und zwei Radien angegeben wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode füllt das Innere eines Kreis Abschnitts, der durch einen Bogen einer Ellipse definiert wird, und die beiden radialen Linien, die sich mit den Endpunkten des Bogens schneiden. Die Ellipse wird durch das umgebende Rechteck definiert. Der Kreis Abschnitt besteht aus den beiden radialen Linien, die `startAngle` durch `sweepAngle` den-Parameter und den-Parameter definiert werden, und dem Bogen zwischen den Schnittpunkten dieser radialen Linien und der Ellipse.  
  
 Wenn der `sweepAngle` -Parameter größer als 360 Grad oder kleiner als-360 Grad ist, wird er so behandelt, als wäre er 360 Grad bzw.-360 Grad.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen voll tonroten Pinsel.  
  
-   Erstellt ein Rechteck, das eine Ellipse umschließt.  
  
-   Definiert den Start Winkel (relativ zur x-Achse) und den Mittelpunktswinkel (in Richtung des Uhrzeigersinn).  
  
-   Füllt den kreisförmigen Bereich der Ellipse auf dem Bildschirm aus.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#104](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#104)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#104](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#104)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#104](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#104)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FillPie">
      <MemberSignature Language="C#" Value="public void FillPie (System.Drawing.Brush brush, int x, int y, int width, int height, int startAngle, int sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillPie(class System.Drawing.Brush brush, int32 x, int32 y, int32 width, int32 height, int32 startAngle, int32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillPie(System.Drawing.Brush,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillPie(System::Drawing::Brush ^ brush, int x, int y, int width, int height, int startAngle, int sweepAngle);" />
      <MemberSignature Language="F#" Value="member this.FillPie : System.Drawing.Brush * int * int * int * int * int * int -&gt; unit" Usage="graphics.FillPie (brush, x, y, width, height, startAngle, sweepAngle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
        <Parameter Name="startAngle" Type="System.Int32" />
        <Parameter Name="sweepAngle" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="brush"><see cref="T:System.Drawing.Brush" />, der die Merkmale des Füllvorgangs bestimmt.</param>
        <param name="x">Die x-Koordinate der oberen linken Ecke des umschließenden Rechtecks, das die Ellipse definiert, aus der der Kreisausschnitt stammt.</param>
        <param name="y">Die y-Koordinate der oberen linken Ecke des umschließenden Rechtecks, das die Ellipse definiert, aus der der Kreisausschnitt stammt.</param>
        <param name="width">Breite des umschließenden Rechtecks, das die Ellipse definiert, aus der der Kreisausschnitt stammt.</param>
        <param name="height">Höhe des umschließenden Rechtecks, das die Ellipse definiert, aus der der Kreisausschnitt stammt.</param>
        <param name="startAngle">Zwischen der x-Achse und der ersten Seite des Kreisausschnitts im Uhrzeigersinn gemessener Winkel in Grad.</param>
        <param name="sweepAngle">Zwischen dem <paramref name="startAngle" />-Parameter und der zweiten Seite des Kreisausschnitts im Uhrzeigersinn gemessener Winkel in Grad.</param>
        <summary>Füllt das Innere eines Kreisausschnitts, der durch eine Ellipse definiert wird, die durch ein Koordinatenpaar, eine Breiten- und eine Höhenangabe und zwei Radien angegeben ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode füllt das Innere eines Kreis Abschnitts, der durch einen Bogen einer Ellipse definiert wird, und die beiden radialen Linien, die sich mit den Endpunkten des Bogens schneiden. Die Ellipse wird durch das umgebende Rechteck definiert. Der Kreis Abschnitt besteht aus den beiden radialen Linien, die `startAngle` durch `sweepAngle` den-Parameter und den-Parameter definiert werden, und dem Bogen zwischen den Schnittpunkten dieser radialen Linien und der Ellipse.  
  
 Wenn der `sweepAngle` -Parameter größer als 360 Grad oder kleiner als-360 Grad ist, wird er so behandelt, als wäre er 360 Grad bzw.-360 Grad.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen voll tonroten Pinsel.  
  
-   Erstellt die Position und Größe eines Rechtecks, das eine Ellipse umschließt.  
  
-   Definiert den Start Winkel (relativ zur x-Achse) und den Mittelpunktswinkel (in Richtung des Uhrzeigersinn).  
  
-   Füllt den kreisförmigen Bereich der Ellipse auf dem Bildschirm aus.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#105](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#105)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#105](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#105)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#105](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#105)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FillPie">
      <MemberSignature Language="C#" Value="public void FillPie (System.Drawing.Brush brush, float x, float y, float width, float height, float startAngle, float sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillPie(class System.Drawing.Brush brush, float32 x, float32 y, float32 width, float32 height, float32 startAngle, float32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillPie(System.Drawing.Brush,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillPie(System::Drawing::Brush ^ brush, float x, float y, float width, float height, float startAngle, float sweepAngle);" />
      <MemberSignature Language="F#" Value="member this.FillPie : System.Drawing.Brush * single * single * single * single * single * single -&gt; unit" Usage="graphics.FillPie (brush, x, y, width, height, startAngle, sweepAngle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="width" Type="System.Single" />
        <Parameter Name="height" Type="System.Single" />
        <Parameter Name="startAngle" Type="System.Single" />
        <Parameter Name="sweepAngle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="brush"><see cref="T:System.Drawing.Brush" />, der die Merkmale des Füllvorgangs bestimmt.</param>
        <param name="x">Die x-Koordinate der oberen linken Ecke des umschließenden Rechtecks, das die Ellipse definiert, aus der der Kreisausschnitt stammt.</param>
        <param name="y">Die y-Koordinate der oberen linken Ecke des umschließenden Rechtecks, das die Ellipse definiert, aus der der Kreisausschnitt stammt.</param>
        <param name="width">Breite des umschließenden Rechtecks, das die Ellipse definiert, aus der der Kreisausschnitt stammt.</param>
        <param name="height">Höhe des umschließenden Rechtecks, das die Ellipse definiert, aus der der Kreisausschnitt stammt.</param>
        <param name="startAngle">Zwischen der x-Achse und der ersten Seite des Kreisausschnitts im Uhrzeigersinn gemessener Winkel in Grad.</param>
        <param name="sweepAngle">Zwischen dem <paramref name="startAngle" />-Parameter und der zweiten Seite des Kreisausschnitts im Uhrzeigersinn gemessener Winkel in Grad.</param>
        <summary>Füllt das Innere eines Kreisausschnitts, der durch eine Ellipse definiert wird, die durch ein Koordinatenpaar, eine Breiten- und eine Höhenangabe und zwei Radien angegeben ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode füllt das Innere eines Kreis Abschnitts, der durch einen Bogen einer Ellipse definiert wird, und die beiden radialen Linien, die sich mit den Endpunkten des Bogens schneiden. Die Ellipse wird durch das umgebende Rechteck definiert. Der Kreis Abschnitt besteht aus den beiden radialen Linien, die `startAngle` durch `sweepAngle` die Parameter und definiert werden, und dem Bogen zwischen den Schnittpunkten dieser radialen Linien und der Ellipse.  
  
 Wenn der `sweepAngle` -Parameter größer als 360 Grad oder kleiner als-360 Grad ist, wird er so behandelt, als wäre er 360 Grad bzw.-360 Grad.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen voll tonroten Pinsel.  
  
-   Erstellt die Position und Größe eines Rechtecks, das eine Ellipse umschließt.  
  
-   Definiert den Start Winkel (relativ zur x-Achse) und den Mittelpunktswinkel (in Richtung des Uhrzeigersinn).  
  
-   Füllt den kreisförmigen Bereich der Ellipse auf dem Bildschirm aus.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#106](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#106)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#106](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#106)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#106](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#106)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="FillPolygon">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Füllt das Innere eines Vielecks, das durch ein Array von Punkten definiert ist, das durch <see cref="T:System.Drawing.Point" />-Strukturen angegeben ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FillPolygon">
      <MemberSignature Language="C#" Value="public void FillPolygon (System.Drawing.Brush brush, System.Drawing.Point[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillPolygon(class System.Drawing.Brush brush, valuetype System.Drawing.Point[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillPolygon(System.Drawing.Brush,System.Drawing.Point[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillPolygon(System::Drawing::Brush ^ brush, cli::array &lt;System::Drawing::Point&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.FillPolygon : System.Drawing.Brush * System.Drawing.Point[] -&gt; unit" Usage="graphics.FillPolygon (brush, points)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="points" Type="System.Drawing.Point[]" />
      </Parameters>
      <Docs>
        <param name="brush"><see cref="T:System.Drawing.Brush" />, der die Merkmale des Füllvorgangs bestimmt.</param>
        <param name="points">Array von <see cref="T:System.Drawing.Point" />-Strukturen, die die Eckpunkte des zu füllenden Vielecks darstellen.</param>
        <summary>Füllt das Innere eines Vielecks, das durch ein Array von Punkten definiert ist, das durch <see cref="T:System.Drawing.Point" />-Strukturen angegeben ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alle zwei aufeinander folgenden Punkte im Array geben eine Seite des Polygons an. Wenn der letzte Punkt und der erste Punkt nicht übereinstimmen, wird außerdem die schließende Seite des Polygons angegeben.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen vollblau-Pinsel.  
  
-   Erstellt ein Array von sieben Punkten, um ein Polygon zu definieren.  
  
-   Füllt den polygonalen Bereich auf dem Bildschirm aus.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#107](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#107)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#107](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#107)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#107](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#107)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="points" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FillPolygon">
      <MemberSignature Language="C#" Value="public void FillPolygon (System.Drawing.Brush brush, System.Drawing.PointF[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillPolygon(class System.Drawing.Brush brush, valuetype System.Drawing.PointF[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillPolygon(System.Drawing.Brush,System.Drawing.PointF[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillPolygon(System::Drawing::Brush ^ brush, cli::array &lt;System::Drawing::PointF&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.FillPolygon : System.Drawing.Brush * System.Drawing.PointF[] -&gt; unit" Usage="graphics.FillPolygon (brush, points)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
      </Parameters>
      <Docs>
        <param name="brush"><see cref="T:System.Drawing.Brush" />, der die Merkmale des Füllvorgangs bestimmt.</param>
        <param name="points">Array von <see cref="T:System.Drawing.PointF" />-Strukturen, die die Eckpunkte des zu füllenden Vielecks darstellen.</param>
        <summary>Füllt das Innere eines Vielecks, das durch ein Array von Punkten definiert ist, das durch <see cref="T:System.Drawing.PointF" />-Strukturen angegeben ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alle zwei aufeinander folgenden Punkte im Array geben eine Seite des Polygons an. Wenn der letzte Punkt und der erste Punkt nicht übereinstimmen, wird außerdem die schließende Seite des Polygons angegeben.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen vollblau-Pinsel.  
  
-   Erstellt ein Array von sieben Punkten, um ein Polygon zu definieren.  
  
-   Füllt den polygonalen Bereich auf dem Bildschirm aus.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#109](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#109)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#109](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#109)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#109](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#109)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="points" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FillPolygon">
      <MemberSignature Language="C#" Value="public void FillPolygon (System.Drawing.Brush brush, System.Drawing.Point[] points, System.Drawing.Drawing2D.FillMode fillMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillPolygon(class System.Drawing.Brush brush, valuetype System.Drawing.Point[] points, valuetype System.Drawing.Drawing2D.FillMode fillMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillPolygon(System.Drawing.Brush,System.Drawing.Point[],System.Drawing.Drawing2D.FillMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillPolygon(System::Drawing::Brush ^ brush, cli::array &lt;System::Drawing::Point&gt; ^ points, System::Drawing::Drawing2D::FillMode fillMode);" />
      <MemberSignature Language="F#" Value="member this.FillPolygon : System.Drawing.Brush * System.Drawing.Point[] * System.Drawing.Drawing2D.FillMode -&gt; unit" Usage="graphics.FillPolygon (brush, points, fillMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="points" Type="System.Drawing.Point[]" />
        <Parameter Name="fillMode" Type="System.Drawing.Drawing2D.FillMode" />
      </Parameters>
      <Docs>
        <param name="brush"><see cref="T:System.Drawing.Brush" />, der die Merkmale des Füllvorgangs bestimmt.</param>
        <param name="points">Array von <see cref="T:System.Drawing.Point" />-Strukturen, die die Eckpunkte des zu füllenden Vielecks darstellen.</param>
        <param name="fillMode">Member der <see cref="T:System.Drawing.Drawing2D.FillMode" />-Enumeration, der den Stil für den Füllvorgang bestimmt.</param>
        <summary>Füllt das Innere eines Vielecks, das durch ein Array von Punkten definiert ist, das durch <see cref="T:System.Drawing.Point" />-Strukturen angegeben ist, wobei der angegebene Füllmodus verwendet wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alle zwei aufeinander folgenden Punkte im Array geben eine Seite des Polygons an. Wenn der letzte Punkt und der erste Punkt nicht übereinstimmen, wird außerdem die schließende Seite des Polygons angegeben.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen vollblau-Pinsel.  
  
-   Erstellt ein Array von sieben Punkten, um ein Polygon zu definieren.  
  
-   Legt den Füll Modus auf <xref:System.Drawing.Drawing2D.FillMode.Winding>fest.  
  
-   Füllt den polygonalen Bereich auf dem Bildschirm aus.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#108](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#108)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#108](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#108)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#108](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#108)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="points" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FillPolygon">
      <MemberSignature Language="C#" Value="public void FillPolygon (System.Drawing.Brush brush, System.Drawing.PointF[] points, System.Drawing.Drawing2D.FillMode fillMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillPolygon(class System.Drawing.Brush brush, valuetype System.Drawing.PointF[] points, valuetype System.Drawing.Drawing2D.FillMode fillMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillPolygon(System.Drawing.Brush,System.Drawing.PointF[],System.Drawing.Drawing2D.FillMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillPolygon(System::Drawing::Brush ^ brush, cli::array &lt;System::Drawing::PointF&gt; ^ points, System::Drawing::Drawing2D::FillMode fillMode);" />
      <MemberSignature Language="F#" Value="member this.FillPolygon : System.Drawing.Brush * System.Drawing.PointF[] * System.Drawing.Drawing2D.FillMode -&gt; unit" Usage="graphics.FillPolygon (brush, points, fillMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
        <Parameter Name="fillMode" Type="System.Drawing.Drawing2D.FillMode" />
      </Parameters>
      <Docs>
        <param name="brush"><see cref="T:System.Drawing.Brush" />, der die Merkmale des Füllvorgangs bestimmt.</param>
        <param name="points">Array von <see cref="T:System.Drawing.PointF" />-Strukturen, die die Eckpunkte des zu füllenden Vielecks darstellen.</param>
        <param name="fillMode">Member der <see cref="T:System.Drawing.Drawing2D.FillMode" />-Enumeration, der den Stil für den Füllvorgang bestimmt.</param>
        <summary>Füllt das Innere eines Vielecks, das durch ein Array von Punkten definiert ist, das durch <see cref="T:System.Drawing.PointF" />-Strukturen angegeben ist, wobei der angegebene Füllmodus verwendet wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alle zwei aufeinander folgenden Punkte im Array geben eine Seite des Polygons an. Wenn der letzte Punkt und der erste Punkt nicht übereinstimmen, wird außerdem die schließende Seite des Polygons angegeben.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgende Aktion aus:  
  
-   Erstellt einen vollblau-Pinsel.  
  
-   Erstellt ein Array von sieben Punkten, um ein Polygon zu definieren.  
  
-   Legt den Füll Modus auf <xref:System.Drawing.Drawing2D.FillMode.Winding>fest.  
  
-   Füllt den polygonalen Bereich auf dem Bildschirm aus.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#110](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#110)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#110](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#110)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#110](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#110)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="points" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="FillRectangle">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Füllt das Innere eines Rechtecks, das durch ein Koordinatenpaar, eine Höhen- und eine Breitenangabe angegeben ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FillRectangle">
      <MemberSignature Language="C#" Value="public void FillRectangle (System.Drawing.Brush brush, System.Drawing.Rectangle rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillRectangle(class System.Drawing.Brush brush, valuetype System.Drawing.Rectangle rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillRectangle(System.Drawing.Brush,System.Drawing.Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillRectangle(System::Drawing::Brush ^ brush, System::Drawing::Rectangle rect);" />
      <MemberSignature Language="F#" Value="member this.FillRectangle : System.Drawing.Brush * System.Drawing.Rectangle -&gt; unit" Usage="graphics.FillRectangle (brush, rect)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="brush"><see cref="T:System.Drawing.Brush" />, der die Merkmale des Füllvorgangs bestimmt.</param>
        <param name="rect"><see cref="T:System.Drawing.Rectangle" />-Struktur, die das zu füllende Rechteck darstellt.</param>
        <summary>Füllt das Innere eines durch eine <see cref="T:System.Drawing.Rectangle" />-Struktur angegebenen Rechtecks.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode füllt das Innere des Rechtecks, das `rect` durch den-Parameter definiert wird, einschließlich der angegebenen oberen linken Ecke und bis zum berechneten unteren und unteren Rand.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgende Aktion aus:  
  
-   Erstellt einen vollblau-Pinsel.  
  
-   Erstellt ein Rechteck.  
  
-   Füllt den rechteckigen Bereich auf dem Bildschirm aus.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#111](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#111)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#111](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#111)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#111](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#111)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FillRectangle">
      <MemberSignature Language="C#" Value="public void FillRectangle (System.Drawing.Brush brush, System.Drawing.RectangleF rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillRectangle(class System.Drawing.Brush brush, valuetype System.Drawing.RectangleF rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillRectangle(System.Drawing.Brush,System.Drawing.RectangleF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillRectangle(System::Drawing::Brush ^ brush, System::Drawing::RectangleF rect);" />
      <MemberSignature Language="F#" Value="member this.FillRectangle : System.Drawing.Brush * System.Drawing.RectangleF -&gt; unit" Usage="graphics.FillRectangle (brush, rect)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="rect" Type="System.Drawing.RectangleF" />
      </Parameters>
      <Docs>
        <param name="brush"><see cref="T:System.Drawing.Brush" />, der die Merkmale des Füllvorgangs bestimmt.</param>
        <param name="rect"><see cref="T:System.Drawing.RectangleF" />-Struktur, die das zu füllende Rechteck darstellt.</param>
        <summary>Füllt das Innere eines durch eine <see cref="T:System.Drawing.RectangleF" />-Struktur angegebenen Rechtecks.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode füllt das Innere des Rechtecks, das `rect` durch den-Parameter definiert wird, einschließlich der angegebenen oberen linken Ecke und bis zum berechneten unteren und unteren Rand.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgende Aktion aus:  
  
-   Erstellt einen vollblau-Pinsel.  
  
-   Erstellt ein Rechteck.  
  
-   Füllt den rechteckigen Bereich auf dem Bildschirm aus.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#112](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#112)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#112](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#112)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#112](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#112)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FillRectangle">
      <MemberSignature Language="C#" Value="public void FillRectangle (System.Drawing.Brush brush, int x, int y, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillRectangle(class System.Drawing.Brush brush, int32 x, int32 y, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillRectangle(System.Drawing.Brush,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillRectangle(System::Drawing::Brush ^ brush, int x, int y, int width, int height);" />
      <MemberSignature Language="F#" Value="member this.FillRectangle : System.Drawing.Brush * int * int * int * int -&gt; unit" Usage="graphics.FillRectangle (brush, x, y, width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="brush"><see cref="T:System.Drawing.Brush" />, der die Merkmale des Füllvorgangs bestimmt.</param>
        <param name="x">Die x-Koordinate der oberen linken Ecke des zu füllenden Rechtecks.</param>
        <param name="y">Die y-Koordinate der oberen linken Ecke des zu füllenden Rechtecks.</param>
        <param name="width">Breite des zu füllenden Rechtecks.</param>
        <param name="height">Höhe des zu füllenden Rechtecks.</param>
        <summary>Füllt das Innere eines Rechtecks, das durch ein Koordinatenpaar, eine Höhen- und eine Breitenangabe angegeben ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode füllt das Innere des Rechtecks, das`x`durch `y`die `width`Parameter, `height` , und definiert wird, einschließlich der angegebenen oberen linken Ecke und bis zum berechneten unteren und unteren Rand.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgende Aktion aus:  
  
-   Erstellt einen vollblau-Pinsel.  
  
-   Erstellt die Position und Größe eines Rechtecks.  
  
-   Füllt den rechteckigen Bereich auf dem Bildschirm aus.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#113](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#113)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#113](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#113)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#113](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#113)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FillRectangle">
      <MemberSignature Language="C#" Value="public void FillRectangle (System.Drawing.Brush brush, float x, float y, float width, float height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillRectangle(class System.Drawing.Brush brush, float32 x, float32 y, float32 width, float32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillRectangle(System.Drawing.Brush,System.Single,System.Single,System.Single,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillRectangle(System::Drawing::Brush ^ brush, float x, float y, float width, float height);" />
      <MemberSignature Language="F#" Value="member this.FillRectangle : System.Drawing.Brush * single * single * single * single -&gt; unit" Usage="graphics.FillRectangle (brush, x, y, width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="width" Type="System.Single" />
        <Parameter Name="height" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="brush"><see cref="T:System.Drawing.Brush" />, der die Merkmale des Füllvorgangs bestimmt.</param>
        <param name="x">Die x-Koordinate der oberen linken Ecke des zu füllenden Rechtecks.</param>
        <param name="y">Die y-Koordinate der oberen linken Ecke des zu füllenden Rechtecks.</param>
        <param name="width">Breite des zu füllenden Rechtecks.</param>
        <param name="height">Höhe des zu füllenden Rechtecks.</param>
        <summary>Füllt das Innere eines Rechtecks, das durch ein Koordinatenpaar, eine Höhen- und eine Breitenangabe angegeben ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode füllt das Innere des Rechtecks, das `x`durch `y`die `width`Parameter, `height` , und definiert wird, einschließlich der angegebenen oberen linken Ecke und bis zum berechneten unteren und unteren Rand.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgende Aktion aus:  
  
-   Erstellt einen vollblau-Pinsel.  
  
-   Erstellt die Position und Größe eines Rechtecks.  
  
-   Füllt den rechteckigen Bereich auf dem Bildschirm aus.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#114](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#114)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#114](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#114)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#114](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#114)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="FillRectangles">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Füllt das Innere einer Reihe von Rechtecken, die durch <see cref="T:System.Drawing.Rectangle" />-Strukturen angegeben sind.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FillRectangles">
      <MemberSignature Language="C#" Value="public void FillRectangles (System.Drawing.Brush brush, System.Drawing.Rectangle[] rects);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillRectangles(class System.Drawing.Brush brush, valuetype System.Drawing.Rectangle[] rects) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillRectangles(System.Drawing.Brush,System.Drawing.Rectangle[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillRectangles(System::Drawing::Brush ^ brush, cli::array &lt;System::Drawing::Rectangle&gt; ^ rects);" />
      <MemberSignature Language="F#" Value="member this.FillRectangles : System.Drawing.Brush * System.Drawing.Rectangle[] -&gt; unit" Usage="graphics.FillRectangles (brush, rects)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="rects" Type="System.Drawing.Rectangle[]" />
      </Parameters>
      <Docs>
        <param name="brush"><see cref="T:System.Drawing.Brush" />, der die Merkmale des Füllvorgangs bestimmt.</param>
        <param name="rects">Array von <see cref="T:System.Drawing.Rectangle" />-Strukturen, die die zu füllenden Rechtecke darstellen.</param>
        <summary>Füllt das Innere einer Reihe von Rechtecken, die durch <see cref="T:System.Drawing.Rectangle" />-Strukturen angegeben sind.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgende Aktion aus:  
  
-   Erstellt einen vollblau-Pinsel.  
  
-   Erstellt ein Array aus drei Rechtecke.  
  
-   Füllt die drei rechteckigen Bereiche auf dem Bildschirm aus.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#115](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#115)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#115](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#115)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#115](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#115)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="rects" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="rects" /> ist ein Array der Länge 0 (null).</exception>
      </Docs>
    </Member>
    <Member MemberName="FillRectangles">
      <MemberSignature Language="C#" Value="public void FillRectangles (System.Drawing.Brush brush, System.Drawing.RectangleF[] rects);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillRectangles(class System.Drawing.Brush brush, valuetype System.Drawing.RectangleF[] rects) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillRectangles(System.Drawing.Brush,System.Drawing.RectangleF[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillRectangles(System::Drawing::Brush ^ brush, cli::array &lt;System::Drawing::RectangleF&gt; ^ rects);" />
      <MemberSignature Language="F#" Value="member this.FillRectangles : System.Drawing.Brush * System.Drawing.RectangleF[] -&gt; unit" Usage="graphics.FillRectangles (brush, rects)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="rects" Type="System.Drawing.RectangleF[]" />
      </Parameters>
      <Docs>
        <param name="brush"><see cref="T:System.Drawing.Brush" />, der die Merkmale des Füllvorgangs bestimmt.</param>
        <param name="rects">Array von <see cref="T:System.Drawing.RectangleF" />-Strukturen, die die zu füllenden Rechtecke darstellen.</param>
        <summary>Füllt das Innere einer Reihe von Rechtecken, die durch <see cref="T:System.Drawing.RectangleF" />-Strukturen angegeben sind.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgende Aktion aus:  
  
-   Erstellt einen vollblau-Pinsel.  
  
-   Erstellt ein Array aus drei Rechtecke.  
  
-   Füllt die drei rechteckigen Bereiche auf dem Bildschirm aus.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#116](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#116)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#116](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#116)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#116](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#116)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="rects" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="Rects" /> ist ein Array der Länge 0 (null).</exception>
      </Docs>
    </Member>
    <Member MemberName="FillRegion">
      <MemberSignature Language="C#" Value="public void FillRegion (System.Drawing.Brush brush, System.Drawing.Region region);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillRegion(class System.Drawing.Brush brush, class System.Drawing.Region region) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillRegion(System.Drawing.Brush,System.Drawing.Region)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillRegion(System::Drawing::Brush ^ brush, System::Drawing::Region ^ region);" />
      <MemberSignature Language="F#" Value="member this.FillRegion : System.Drawing.Brush * System.Drawing.Region -&gt; unit" Usage="graphics.FillRegion (brush, region)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="region" Type="System.Drawing.Region" />
      </Parameters>
      <Docs>
        <param name="brush"><see cref="T:System.Drawing.Brush" />, der die Merkmale des Füllvorgangs bestimmt.</param>
        <param name="region"><see cref="T:System.Drawing.Region" />, der den auszufüllenden Bereich darstellt.</param>
        <summary>Füllt das Innere von einem <see cref="T:System.Drawing.Region" /> aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Drawing.Region> besteht aus Rechtecke und Pfaden. Wenn der Bereich nicht geschlossen ist, wird ein zusätzliches Segment vom letzten Punkt zum ersten Punkt hinzugefügt, um es zu schließen.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgende Aktion aus:  
  
-   Erstellt einen vollblau-Pinsel.  
  
-   Erstellt ein Rechteck.  
  
-   Erstellt einen rechteckigen Bereich.  
  
-   Füllt den rechteckigen Bereich auf dem Bildschirm aus.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#117](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#117)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#117](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#117)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#117](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#117)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="region" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Graphics ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Graphics ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="graphics.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einem Objekt Gelegenheit zu dem Versuch, Ressourcen freizugeben und andere Bereinigungen durchzuführen, bevor es von der Garbage Collection freigegeben wird.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Flush">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erzwingt die Ausführung aller ausstehenden Grafikoperationen und wird umgehend beendet, wobei das Abschließen der Operationen nicht abgewartet wird.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Flush();" />
      <MemberSignature Language="F#" Value="member this.Flush : unit -&gt; unit" Usage="graphics.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erzwingt die Ausführung aller ausstehenden Grafikoperationen und wird umgehend beendet, wobei das Abschließen der Operationen nicht abgewartet wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode startet eine Leerung und wird sofort zurückgegeben, ohne darauf zu warten, dass derzeit ausgeführte Grafik Vorgänge abgeschlossen werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public void Flush (System.Drawing.Drawing2D.FlushIntention intention);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Flush(valuetype System.Drawing.Drawing2D.FlushIntention intention) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.Flush(System.Drawing.Drawing2D.FlushIntention)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Flush (intention As FlushIntention)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Flush(System::Drawing::Drawing2D::FlushIntention intention);" />
      <MemberSignature Language="F#" Value="member this.Flush : System.Drawing.Drawing2D.FlushIntention -&gt; unit" Usage="graphics.Flush intention" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="intention" Type="System.Drawing.Drawing2D.FlushIntention" />
      </Parameters>
      <Docs>
        <param name="intention">Member der <see cref="T:System.Drawing.Drawing2D.FlushIntention" />-Enumeration, der angibt, ob die Methode sofort beendet oder der Abschluss aller vorhandenen Operationen abgewartet wird.</param>
        <summary>Erzwingt die Ausführung aller ausstehenden Grafikoperationen, wobei angegeben werden kann, ob für das Beenden der Methode auf das Abschließen der Operationen gewartet werden soll.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert <xref:System.Drawing.Drawing2D.FlushIntention.Flush> für den `intention` -Parameter gibt an, dass die Methode sofort nach dem Start der Leerung zurückgegeben <xref:System.Drawing.Drawing2D.FlushIntention.Sync> wird, und der Wert gibt an, dass die Methode vor dem zurückkehren wartet, bis vorhandene Vorgänge abgeschlossen sind.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="FromHdc">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt ein neues <see cref="T:System.Drawing.Graphics" /> aus dem angegebenen Handle für einen Gerätekontext.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FromHdc">
      <MemberSignature Language="C#" Value="public static System.Drawing.Graphics FromHdc (IntPtr hdc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Drawing.Graphics FromHdc(native int hdc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FromHdc(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromHdc (hdc As IntPtr) As Graphics" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Drawing::Graphics ^ FromHdc(IntPtr hdc);" />
      <MemberSignature Language="F#" Value="static member FromHdc : nativeint -&gt; System.Drawing.Graphics" Usage="System.Drawing.Graphics.FromHdc hdc" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netcore-2.1;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Graphics</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hdc" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="hdc">Handle für einen Gerätekontext.</param>
        <summary>Erstellt ein neues <see cref="T:System.Drawing.Graphics" /> aus dem angegebenen Handle für einen Gerätekontext.</summary>
        <returns>Diese Methode gibt ein neues <see cref="T:System.Drawing.Graphics" /> für den angegebenen Gerätekontext zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie sollten immer die <xref:System.Drawing.Graphics.Dispose%2A> -Methode aufzurufen, um die <xref:System.Drawing.Graphics> von der <xref:System.Drawing.Graphics.FromHdc%2A> -Methode erstellten und zugehörigen Ressourcen freizugeben.  
  
 Auch wenn das Anzeigegerät über ein zugeordnetes ICM- [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] Farbprofil verfügt, wird dieses Profil von nicht standardmäßig verwendet. Wenn Sie ICM für ein <xref:System.Drawing.Graphics>aktivieren möchten, <xref:System.Drawing.Graphics> erstellen Sie das aus einem hdc, nachdem Sie den hdc (und ICM_ON `SetICMMode` ) an die Funktion übergeben haben. Anschließend <xref:System.Drawing.Graphics> wird jede von durchgeführte Zeichnung entsprechend dem ICM-Profil angepasst, das dem Anzeigegerät zugeordnet ist. Das Aktivieren von ICM führt zu einer langsameren Leistung.  
  
 Der Status des Geräte Kontexts (Zustellungs Modus, logische Einheit usw.) zum Zeitpunkt des Aufrufes <xref:System.Drawing.Graphics.FromHdc%2A> kann sich auf das <xref:System.Drawing.Graphics>von durchgeführte Rendering auswirken.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgende Aktion aus:  
  
-   Erstellt eine interne Zeigertyp `hdc` Variable und legt Sie auf das Handle für den Gerätekontext des Grafik Objekts des Formulars fest.  
  
-   Erstellt mithilfe `hdc`von ein neues Grafik Objekt.  
  
-   Zeichnet ein Rechteck mit dem neuen Grafik Objekt (auf dem Bildschirm).  
  
-   Gibt das neue Grafik Objekt mithilfe `hdc`von frei.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#118](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#118)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#118](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#118)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#118](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#118)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromHdc">
      <MemberSignature Language="C#" Value="public static System.Drawing.Graphics FromHdc (IntPtr hdc, IntPtr hdevice);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Drawing.Graphics FromHdc(native int hdc, native int hdevice) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FromHdc(System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromHdc (hdc As IntPtr, hdevice As IntPtr) As Graphics" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Drawing::Graphics ^ FromHdc(IntPtr hdc, IntPtr hdevice);" />
      <MemberSignature Language="F#" Value="static member FromHdc : nativeint * nativeint -&gt; System.Drawing.Graphics" Usage="System.Drawing.Graphics.FromHdc (hdc, hdevice)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netcore-2.1;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Graphics</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hdc" Type="System.IntPtr" />
        <Parameter Name="hdevice" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="hdc">Handle für einen Gerätekontext.</param>
        <param name="hdevice">Handle für ein Gerät.</param>
        <summary>Erstellt ein neues <see cref="T:System.Drawing.Graphics" /> aus dem angegebenen Handle für einen Gerätekontext und einem Handle für ein Gerät.</summary>
        <returns>Diese Methode gibt ein neues <see cref="T:System.Drawing.Graphics" /> für den angegebenen Gerätekontext und das angegebene Gerät zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie sollten immer die <xref:System.Drawing.Graphics.Dispose%2A> -Methode aufzurufen, um die <xref:System.Drawing.Graphics> von der <xref:System.Drawing.Graphics.FromHdc%2A> -Methode erstellten und zugehörigen Ressourcen freizugeben.  
  
 Auch wenn das Anzeigegerät über ein zugeordnetes ICM- [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] Farbprofil verfügt, wird dieses Profil von nicht standardmäßig verwendet. Wenn Sie ICM für ein <xref:System.Drawing.Graphics>aktivieren möchten, <xref:System.Drawing.Graphics> erstellen Sie das aus einem hdc, nachdem Sie den hdc (und ICM_ON `SetICMMode` ) an die Funktion übergeben haben. Anschließend <xref:System.Drawing.Graphics> wird jede von durchgeführte Zeichnung entsprechend dem ICM-Profil angepasst, das dem Anzeigegerät zugeordnet ist. Das Aktivieren von ICM führt zu einer langsameren Leistung.  
  
 Der Status des Geräte Kontexts (Zustellungs Modus, logische Einheit usw.) zum Zeitpunkt des Aufrufes <xref:System.Drawing.Graphics.FromHdc%2A> kann sich auf das <xref:System.Drawing.Graphics>von durchgeführte Rendering auswirken.  
  
 Das Geräte Handle wird normalerweise verwendet, um bestimmte Druckerfunktionen abzufragen.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff auf nicht verwalteten Code. Verwandte Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="FromHdcInternal">
      <MemberSignature Language="C#" Value="public static System.Drawing.Graphics FromHdcInternal (IntPtr hdc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Drawing.Graphics FromHdcInternal(native int hdc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FromHdcInternal(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromHdcInternal (hdc As IntPtr) As Graphics" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Drawing::Graphics ^ FromHdcInternal(IntPtr hdc);" />
      <MemberSignature Language="F#" Value="static member FromHdcInternal : nativeint -&gt; System.Drawing.Graphics" Usage="System.Drawing.Graphics.FromHdcInternal hdc" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netcore-2.1;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Graphics</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hdc" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="hdc">Handle für einen Gerätekontext.</param>
        <summary>Gibt ein <see cref="T:System.Drawing.Graphics" /> für den angegebenen Gerätekontext zurück.</summary>
        <returns>Ein <see cref="T:System.Drawing.Graphics" /> für den angegebenen Gerätekontext.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode sollte nicht verwendet werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromHwnd">
      <MemberSignature Language="C#" Value="public static System.Drawing.Graphics FromHwnd (IntPtr hwnd);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Drawing.Graphics FromHwnd(native int hwnd) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FromHwnd(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromHwnd (hwnd As IntPtr) As Graphics" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Drawing::Graphics ^ FromHwnd(IntPtr hwnd);" />
      <MemberSignature Language="F#" Value="static member FromHwnd : nativeint -&gt; System.Drawing.Graphics" Usage="System.Drawing.Graphics.FromHwnd hwnd" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netcore-2.1;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Graphics</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hwnd" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="hwnd">Handle für ein Fenster.</param>
        <summary>Erstellt ein neues <see cref="T:System.Drawing.Graphics" /> aus dem angegebenen Handle für ein Fenster.</summary>
        <returns>Diese Methode gibt ein neues <see cref="T:System.Drawing.Graphics" /> für das angegebene Fensterhandle zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie sollten immer die <xref:System.Drawing.Graphics.Dispose%2A> -Methode aufzurufen, um die <xref:System.Drawing.Graphics> von der <xref:System.Drawing.Graphics.FromHwnd%2A> -Methode erstellten und zugehörigen Ressourcen freizugeben.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert <xref:System.Windows.Forms.PaintEventArgs>und erfordert `e`, ein Parameter des <xref:System.Windows.Forms.Control.Paint> <xref:System.Windows.Forms.Form> Ereignis Handlers sowie `thisForm`, für das Beispiel. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt eine neue interne Zeiger Variable `hwnd` und legt Sie auf das Handle der Form des Beispiels fest.  
  
-   Erstellt ein neues <xref:System.Drawing.Graphics> aus dem handle.  
  
-   Zeichnet ein Rechteck mithilfe eines roten <xref:System.Drawing.Graphics> Stifts in den neuen.  
  
-   Gibt den neuen <xref:System.Drawing.Graphics>frei.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#119](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#119)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#119](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#119)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#119](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#119)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff auf nicht verwalteten Code. Verwandte Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="FromHwndInternal">
      <MemberSignature Language="C#" Value="public static System.Drawing.Graphics FromHwndInternal (IntPtr hwnd);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Drawing.Graphics FromHwndInternal(native int hwnd) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FromHwndInternal(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromHwndInternal (hwnd As IntPtr) As Graphics" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Drawing::Graphics ^ FromHwndInternal(IntPtr hwnd);" />
      <MemberSignature Language="F#" Value="static member FromHwndInternal : nativeint -&gt; System.Drawing.Graphics" Usage="System.Drawing.Graphics.FromHwndInternal hwnd" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netcore-2.1;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Graphics</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hwnd" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="hwnd">Handle für ein Fenster.</param>
        <summary>Erstellt ein neues <see cref="T:System.Drawing.Graphics" /> für das angegebene Fensterhandle.</summary>
        <returns>Ein <see cref="T:System.Drawing.Graphics" /> für das angegebene Fensterhandle.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode sollte nicht verwendet werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromImage">
      <MemberSignature Language="C#" Value="public static System.Drawing.Graphics FromImage (System.Drawing.Image image);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Drawing.Graphics FromImage(class System.Drawing.Image image) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FromImage(System.Drawing.Image)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Drawing::Graphics ^ FromImage(System::Drawing::Image ^ image);" />
      <MemberSignature Language="F#" Value="static member FromImage : System.Drawing.Image -&gt; System.Drawing.Graphics" Usage="System.Drawing.Graphics.FromImage image" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Graphics</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
      </Parameters>
      <Docs>
        <param name="image"><see cref="T:System.Drawing.Image" />, aus dem das neue <see cref="T:System.Drawing.Graphics" /> erstellt werden soll.</param>
        <summary>Erstellt ein neues <see cref="T:System.Drawing.Graphics" /> aus dem angegebenen <see cref="T:System.Drawing.Image" />.</summary>
        <returns>Diese Methode gibt ein neues <see cref="T:System.Drawing.Graphics" /> für das angegebene <see cref="T:System.Drawing.Image" />-Objekt zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn das Bild ein indiziertes Pixel Format aufweist, löst diese Methode eine Ausnahme mit der Meldung "ein Grafik Objekt kann nicht aus einem Bild mit einem indizierten Pixel Format erstellt werden" aus. Die indizierten Pixel Formate werden in der folgenden Liste angezeigt.  
  
-   <xref:System.Drawing.Imaging.PixelFormat.Format1bppIndexed>  
  
-   <xref:System.Drawing.Imaging.PixelFormat.Format4bppIndexed>  
  
-   <xref:System.Drawing.Imaging.PixelFormat.Format8bppIndexed>  
  
 Sie können das indizierte Bild in einem anderen Format speichern, <xref:System.Drawing.Image.Save%28System.String%2CSystem.Drawing.Imaging.ImageFormat%29> indem Sie die-Methode <xref:System.Drawing.Graphics> verwenden und dann ein-Objekt für das neue Image abrufen.  
  
 Diese Methode löst auch eine Ausnahme aus, wenn das Image eines der folgenden Pixel Formate aufweist.  
  
-   <xref:System.Drawing.Imaging.PixelFormat.Undefined>  
  
-   <xref:System.Drawing.Imaging.PixelFormat.DontCare>  
  
-   <xref:System.Drawing.Imaging.PixelFormat.Format16bppArgb1555>  
  
-   <xref:System.Drawing.Imaging.PixelFormat.Format16bppGrayScale>  
  
 Sie sollten immer die <xref:System.Drawing.Graphics.Dispose%2A> -Methode aufzurufen, um die <xref:System.Drawing.Graphics> von der <xref:System.Drawing.Graphics.FromImage%2A> -Methode erstellten und zugehörigen Ressourcen freizugeben.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgende Aktion aus:  
  
-   Erstellt ein <xref:System.Drawing.Image> aus einer Grafikdatei "SampImag. jpg" im Beispiel Ordner.  
  
-   Erstellt eine <xref:System.Drawing.Graphics> aus dem <xref:System.Drawing.Image>.  
  
-   Ändert das Bild, indem es ein Rechteck darin füllt.  
  
-   Zeichnet das <xref:System.Drawing.Image> auf dem Bildschirm.  
  
-   Gibt die erstellte <xref:System.Drawing.Graphics>frei.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#120](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#120)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#120](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#120)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#120](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#120)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Exception"><paramref name="image" /> besitzt ein indiziertes Pixelformat, oder sein Format ist nicht definiert.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/737bae30-e599-4e1d-bf30-bab8280b32be">Gewusst wie: Erstellen einer Bitmap zur Laufzeit</related>
        <related type="Article" href="https://msdn.microsoft.com/library/a626d701-bd99-4fd8-b92f-7b8f794e042b">Arbeiten mit Bildern, Bitmaps, Symbolen und Metadateien</related>
        <related type="Article" href="https://msdn.microsoft.com/library/162861f9-f050-445e-8abb-b2c43a918b8b">Gewusst wie: Erstellen von Graphics-Objekten zum Zeichnen</related>
      </Docs>
    </Member>
    <Member MemberName="GetContextInfo">
      <MemberSignature Language="C#" Value="public object GetContextInfo ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetContextInfo() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.GetContextInfo" />
      <MemberSignature Language="VB.NET" Value="Public Function GetContextInfo () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetContextInfo();" />
      <MemberSignature Language="F#" Value="member this.GetContextInfo : unit -&gt; obj" Usage="graphics.GetContextInfo " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netcore-2.1;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft den kumulierten Grafikkontext ab.</summary>
        <returns>Ein <see cref="T:System.Object" />, das den kumulierten Grafikkontext darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Rückgabewert ist ein Objekt Array, bei dem das erste Element den kumulativen Ausschneide Bereich enthält und das zweite Element die kumulative Translation/Transform-Matrix enthält.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHalftonePalette">
      <MemberSignature Language="C#" Value="public static IntPtr GetHalftonePalette ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetHalftonePalette() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.GetHalftonePalette" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetHalftonePalette () As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr GetHalftonePalette();" />
      <MemberSignature Language="F#" Value="static member GetHalftonePalette : unit -&gt; nativeint" Usage="System.Drawing.Graphics.GetHalftonePalette " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft ein Handle für die aktuelle Windows-Halbtonpalette ab.</summary>
        <returns>Interner Zeiger, der das Handle für die Palette angibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Zweck <xref:System.Drawing.Graphics.GetHalftonePalette%2A> der-Methode ist es [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] , eine bessere Qualität zu erzielen, wenn in der Anzeige 8 Bits pro Pixel verwendet werden. Verwenden Sie das folgende Verfahren, um ein Bild mithilfe der Halbton-Palette anzuzeigen.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Definiert Interoperabilitäts <xref:System.Runtime.InteropServices.DllImportAttribute> Attribute für die Windows-DLL-Datei gdi32. dll, [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] die die erforderlichen Funktionen enthält.  
  
-   Definiert die `SelectPalette` Funktionen `RealizePalette` und in dieser DLL als extern.  
  
-   Erstellt ein Bild aus einer vorhandenen Bilddatei "SampImag. jpg" (die sich im gleichen Ordner wie die Beispielcode Datei befinden muss) und zeichnet das Bild auf dem Bildschirm.  
  
-   Erstellt interne Zeigertyp Variablen und legt ihre Werte auf das Handle für das Grafik Objekt und die aktuelle Windows-halbftone-Palette fest.  
  
-   Wählt die halbftone-Palette aus und erkennt Sie.  
  
-   Erstellt ein neues Grafik Objekt mithilfe des `hdc` -Parameters.  
  
-   Zeichnet das Bild erneut.  
  
-   Gibt das Handle für den Gerätekontext frei.  
  
 Das Ergebnis sind zwei Renderings des Beispiel Bilds: eine mit der 16-Bit-Palette und eine mit der 8-Bit-Palette.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#121](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#121)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#121](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#121)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#121](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#121)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHdc">
      <MemberSignature Language="C#" Value="public IntPtr GetHdc ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance native int GetHdc() cil managed" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.GetHdc" />
      <MemberSignature Language="VB.NET" Value="Public Function GetHdc () As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IntPtr GetHdc();" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="F#" Value="abstract member GetHdc : unit -&gt; nativeint&#xA;override this.GetHdc : unit -&gt; nativeint" Usage="graphics.GetHdc " FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance native int GetHdc() cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IntPtr GetHdc();" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="F#" Value="member this.GetHdc : unit -&gt; nativeint" Usage="graphics.GetHdc " FrameworkAlternate="netframework-1.1" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Drawing.IDeviceContext.GetHdc</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft das Handle für den Gerätekontext ab, der diesem <see cref="T:System.Drawing.Graphics" /> zugeordnet ist.</summary>
        <returns>Handle für den Gerätekontext, der diesem <see cref="T:System.Drawing.Graphics" /> zugeordnet ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Gerätekontext ist eine auf [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] basierende Windows-Struktur, die einen Satz grafischer Objekte und ihre zugeordneten Attribute sowie die grafischen Modi, die die Ausgabe beeinflussen, definiert. Diese Methode gibt den Gerätekontext mit Ausnahme einer Schriftart zurück. Da keine Schriftart ausgewählt ist, schlagen Aufrufe der <xref:System.Drawing.Font.FromHdc%2A> -Methode mithilfe eines Handles fehl, das von der <xref:System.Drawing.Graphics.GetHdc%2A> -Methode zurückgegeben wird.  
  
 Aufrufe der- <xref:System.Drawing.Graphics.GetHdc%2A> Methode <xref:System.Drawing.Graphics.ReleaseHdc%2A> und der-Methode müssen paarweise angezeigt werden. Während des Gültigkeits Bereichs <xref:System.Drawing.Graphics.GetHdc%2A> eines <xref:System.Drawing.Graphics.ReleaseHdc%2A> -und-Methoden Paars werden [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] in der Regel nur Aufrufe von-Funktionen durchführen. Aufrufe in diesem Bereich, die [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] <xref:System.Drawing.Graphics> an Methoden von vorgenommen wurden, `hdc` die den-Parameter `ObjectBusy` erzeugt haben, schlagen mit einem Fehler fehl. Ignoriert außerdem [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] alle Zustandsänderungen, die an der <xref:System.Drawing.Graphics> des `hdc` -Parameters in nachfolgenden Vorgängen vorgenommen werden.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Das Beispiel veranschaulicht das Aufrufen einer [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] Windows-Funktion, um dieselbe Aufgabe wie [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] eine <xref:System.Drawing.Graphics> Methode auszuführen. Der Code führt die folgenden Aktionen aus:  
  
-   Definiert das Interoperabilitäts <xref:System.Runtime.InteropServices.DllImportAttribute> Attribut für die Windows-DLL-Datei gdi32. dll. Diese DLL enthält die gewünschte [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] Funktion.  
  
-   Definiert die <xref:System.Drawing.Rectangle> Funktion in dieser DLL als extern.  
  
-   Erstellt einen roten Stift.  
  
-   Mit dem Stift zeichnet ein Rechteck mithilfe der [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] <xref:System.Drawing.Graphics.DrawRectangle%2A> -Methode auf dem Bildschirm.  
  
-   Definiert eine interne Zeigertyp `hdc` Variable und legt ihren Wert auf das Handle für den Gerätekontext des Formulars fest.  
  
-   Zeichnet ein Rechteck mithilfe der [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] <xref:System.Drawing.Rectangle> -Funktion auf dem Bildschirm.  
  
-   Gibt den Gerätekontext frei, der `hdc` durch den-Parameter dargestellt wird.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#122](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#122)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#122](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#122)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#122](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#122)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff auf nicht verwalteten Code. Verwandte Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetNearestColor">
      <MemberSignature Language="C#" Value="public System.Drawing.Color GetNearestColor (System.Drawing.Color color);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.Color GetNearestColor(valuetype System.Drawing.Color color) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.GetNearestColor(System.Drawing.Color)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::Color GetNearestColor(System::Drawing::Color color);" />
      <MemberSignature Language="F#" Value="member this.GetNearestColor : System.Drawing.Color -&gt; System.Drawing.Color" Usage="graphics.GetNearestColor color" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="color" Type="System.Drawing.Color" />
      </Parameters>
      <Docs>
        <param name="color"><see cref="T:System.Drawing.Color" />-Struktur, für die eine Übereinstimmung gesucht werden soll.</param>
        <summary>Ruft die der angegebenen <see cref="T:System.Drawing.Color" />-Struktur nächstgelegene Farbe ab.</summary>
        <returns>Eine <see cref="T:System.Drawing.Color" />-Struktur, die die nächstgelegene Farbe für die durch den <paramref name="color" />-Parameter angegebene Farbe darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt eine beliebige Farbe mit ARGB-Koordinaten (255, 165, 63, 136).  
  
-   Erstellt einen Pinsel mit voll Tonfarbe und legt seine Farbe auf die angegebene Farbe fest.  
  
-   Füllt eine Ellipse mithilfe der beliebigen Farbe aus.  
  
-   Erstellt eine zweite Farbe und legt ihren Wert auf die nächste System ARGB-Farbe fest.  
  
-   Füllt eine zweite Ellipse mit dieser Farbe.  
  
 Das Ergebnis sind zwei Ellipsen: das erste, das mit der beliebigen angegebenen Farbe gezeichnet wird, und das zweite mit der System Farbe, die der angegebenen Farbe am nächsten liegt.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#123](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#123)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#123](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#123)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#123](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#123)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InterpolationMode">
      <MemberSignature Language="C#" Value="public System.Drawing.Drawing2D.InterpolationMode InterpolationMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Drawing2D.InterpolationMode InterpolationMode" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Graphics.InterpolationMode" />
      <MemberSignature Language="VB.NET" Value="Public Property InterpolationMode As InterpolationMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Drawing2D::InterpolationMode InterpolationMode { System::Drawing::Drawing2D::InterpolationMode get(); void set(System::Drawing::Drawing2D::InterpolationMode value); };" />
      <MemberSignature Language="F#" Value="member this.InterpolationMode : System.Drawing.Drawing2D.InterpolationMode with get, set" Usage="System.Drawing.Graphics.InterpolationMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Drawing2D.InterpolationMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Interpolationsmodus ab, der diesem <see cref="T:System.Drawing.Graphics" /> zugeordnet ist, oder legt diesen fest.</summary>
        <value>Einer der <see cref="T:System.Drawing.Drawing2D.InterpolationMode" />-Werte.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Interpolations Modus bestimmt, wie Zwischenwerte zwischen zwei Endpunkten berechnet werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IntersectClip">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Aktualisiert den Ausschneidebereich von diesem <see cref="T:System.Drawing.Graphics" /> auf die Schnittmenge des aktuellen Ausschneidebereichs und der angegebenen <see cref="T:System.Drawing.Rectangle" />-Struktur.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IntersectClip">
      <MemberSignature Language="C#" Value="public void IntersectClip (System.Drawing.Rectangle rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void IntersectClip(valuetype System.Drawing.Rectangle rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.IntersectClip(System.Drawing.Rectangle)" />
      <MemberSignature Language="VB.NET" Value="Public Sub IntersectClip (rect As Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void IntersectClip(System::Drawing::Rectangle rect);" />
      <MemberSignature Language="F#" Value="member this.IntersectClip : System.Drawing.Rectangle -&gt; unit" Usage="graphics.IntersectClip rect" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="rect"><see cref="T:System.Drawing.Rectangle" />-Struktur, die den aktuellen Ausschneidebereich schneiden soll.</param>
        <summary>Aktualisiert den Ausschneidebereich von diesem <see cref="T:System.Drawing.Graphics" /> auf die Schnittmenge des aktuellen Ausschneidebereichs und der angegebenen <see cref="T:System.Drawing.Rectangle" />-Struktur.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode weist der- <xref:System.Drawing.Graphics.Clip%2A> Eigenschaft dieses <xref:System.Drawing.Graphics> den Bereich zu, der durch die Schnittmenge des aktuellen Ausschneide Bereichs und des durch den `rect` -Parameter angegebenen Rechtecks dargestellt wird.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein Rechteck mit der oberen linken Ecke bei (0,0) und legt den Clippingbereich auf dieses Rechteck fest.  
  
-   Erstellt ein zweites Rechteck mit der oberen linken Ecke um (100, 100) und legt den Clippingbereich auf die Schnittmenge dieses Rechtecks und des aktuellen Clippingbereichs (das erste Rechteck) fest.  
  
-   Füllt ein großes Rechteck aus, das beide vorangehenden Rechtecke mit einem Pinsel mit festem blau enthält.  
  
-   Setzt den Clippingbereich auf unendlich zurück.  
  
-   Zeichnet Rechtecke um die beiden Clippingbereiche. Dabei wird ein schwarzer Stift für das erste Clippingrechteck und ein roter Stift für den zweiten Clippingbereich verwendet.  
  
 Das Ergebnis ist, dass nur die Schnittmenge der beiden Rechtecke mit blau gefüllt wird.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#124](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#124)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#124](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#124)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#124](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#124)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IntersectClip">
      <MemberSignature Language="C#" Value="public void IntersectClip (System.Drawing.RectangleF rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void IntersectClip(valuetype System.Drawing.RectangleF rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.IntersectClip(System.Drawing.RectangleF)" />
      <MemberSignature Language="VB.NET" Value="Public Sub IntersectClip (rect As RectangleF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void IntersectClip(System::Drawing::RectangleF rect);" />
      <MemberSignature Language="F#" Value="member this.IntersectClip : System.Drawing.RectangleF -&gt; unit" Usage="graphics.IntersectClip rect" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.RectangleF" />
      </Parameters>
      <Docs>
        <param name="rect"><see cref="T:System.Drawing.RectangleF" />-Struktur, die den aktuellen Ausschneidebereich schneiden soll.</param>
        <summary>Aktualisiert den Ausschneidebereich von diesem <see cref="T:System.Drawing.Graphics" /> auf die Schnittmenge des aktuellen Ausschneidebereichs und der angegebenen <see cref="T:System.Drawing.RectangleF" />-Struktur.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode weist der- <xref:System.Drawing.Graphics.Clip%2A> Eigenschaft dieses <xref:System.Drawing.Graphics> den Bereich zu, der durch die Schnittmenge des aktuellen Ausschneide Bereichs und des durch den `rect` -Parameter angegebenen Rechtecks dargestellt wird.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein Rechteck mit der oberen linken Ecke bei (0,0) und legt den Clippingbereich auf dieses Rechteck fest.  
  
-   Erstellt ein zweites Rechteck mit der oberen linken Ecke um (100, 100) und legt den Clippingbereich auf die Schnittmenge dieses Rechtecks und des aktuellen Clippingbereichs (das erste Rechteck) fest.  
  
-   Füllt ein großes Rechteck aus, das beide vorangehenden Rechtecke mit einem Pinsel mit festem blau enthält.  
  
-   Setzt den Clippingbereich auf unendlich zurück.  
  
-   Zeichnet Rechtecke um die beiden Clippingbereiche. Dabei wird ein schwarzer Stift für das erste Clippingrechteck und ein roter Stift für den zweiten Clippingbereich verwendet.  
  
 Das Ergebnis ist, dass nur die Schnittmenge der beiden Rechtecke mit blau gefüllt wird.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#125](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#125)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#125](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#125)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#125](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#125)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IntersectClip">
      <MemberSignature Language="C#" Value="public void IntersectClip (System.Drawing.Region region);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void IntersectClip(class System.Drawing.Region region) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.IntersectClip(System.Drawing.Region)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void IntersectClip(System::Drawing::Region ^ region);" />
      <MemberSignature Language="F#" Value="member this.IntersectClip : System.Drawing.Region -&gt; unit" Usage="graphics.IntersectClip region" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="region" Type="System.Drawing.Region" />
      </Parameters>
      <Docs>
        <param name="region"><see cref="T:System.Drawing.Region" />, dessen Schnittmenge mit dem aktuellen Bereich gebildet werden soll.</param>
        <summary>Aktualisiert den Ausschneidebereich dieses <see cref="T:System.Drawing.Graphics" /> auf die Schnittmenge des aktuellen Ausschneidebereichs und dem angegebenen <see cref="T:System.Drawing.Region" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode weist der- <xref:System.Drawing.Graphics.Clip%2A> Eigenschaft dieses <xref:System.Drawing.Graphics> den Bereich zu, der durch die Schnittmenge des aktuellen Ausschneide Bereichs und durch `region` den-Parameter angegeben wird.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein Rechteck mit der oberen linken Ecke bei (0,0).  
  
-   Erstellt einen Bereich und legt ihn auf das Rechteck fest und legt den Clippingbereich auf diesen Bereich fest.  
  
-   Erstellt ein zweites Rechteck mit der oberen linken Ecke um (100, 100).  
  
-   Erstellt einen Bereich und legt ihn auf das zweite Rechteck fest und legt den Clippingbereich auf die Schnittmenge dieses Bereichs und den aktuellen Clippingbereich (das erste Rechteck) mithilfe eines kombinierungsmodus von <xref:System.Drawing.Drawing2D.CombineMode.Replace>fest.  
  
-   Füllt ein großes Rechteck, das beide vorherigen Bereiche enthält, mit einem Pinsel mit ausgefülltem blauen Pinsel.  
  
-   Setzt den Clippingbereich auf unendlich zurück.  
  
-   Zeichnet Rechtecke um die beiden Clippingbereiche. Dabei wird ein schwarzer Stift für den ersten Clippingbereich und ein roter Stift für den zweiten Clippingbereich verwendet.  
  
 Das Ergebnis ist, dass nur die Schnittmenge der beiden Bereiche blau gefüllt ist.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#126](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#126)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#126](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#126)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#126](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#126)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClipEmpty">
      <MemberSignature Language="C#" Value="public bool IsClipEmpty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClipEmpty" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Graphics.IsClipEmpty" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsClipEmpty As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsClipEmpty { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsClipEmpty : bool" Usage="System.Drawing.Graphics.IsClipEmpty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Ausschneidebereich dieses <see cref="T:System.Drawing.Graphics" /> leer ist.</summary>
        <value><see langword="true" />, falls der Ausschneidebereich dieses <see cref="T:System.Drawing.Graphics" /> leer ist, andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsVisible">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt an, ob der durch ein Koordinatenpaar angegebene Punkt im sichtbaren Ausschneidebereich von diesem <see cref="T:System.Drawing.Graphics" /> enthalten ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (System.Drawing.Point point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(valuetype System.Drawing.Point point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.IsVisible(System.Drawing.Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(System::Drawing::Point point);" />
      <MemberSignature Language="F#" Value="member this.IsVisible : System.Drawing.Point -&gt; bool" Usage="graphics.IsVisible point" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="point"><see cref="T:System.Drawing.Point" />-Struktur, die auf Sichtbarkeit geprüft werden soll.</param>
        <summary>Gibt an, ob die angegebene <see cref="T:System.Drawing.Point" />-Struktur innerhalb des sichtbaren Ausschneidebereichs dieses <see cref="T:System.Drawing.Graphics" /> enthalten ist.</summary>
        <returns><see langword="true" />, falls der durch den <paramref name="point" />-Parameter angegebene Punkt innerhalb des sichtbaren Ausschneidebereichs dieses <see cref="T:System.Drawing.Graphics" /> enthalten ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen rechteckigen Clippingbereich und legt ihn mithilfe <xref:System.Drawing.Drawing2D.CombineMode.Replace>von als Clippingbereich für das Grafik Objekt des Formulars fest.  
  
-   Erstellt zwei Punkte, eine innerhalb des Clippingbereichs und eine externe.  
  
-   Testet jeden der Punkte auf Sichtbarkeit und zeichnet nur den sichtbaren.  
  
 Das Ergebnis ist ein kleiner roter Kreis, der sich innerhalb des Clip Bereichs befindet.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#127](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#127)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#127](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#127)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#127](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#127)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (System.Drawing.PointF point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(valuetype System.Drawing.PointF point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.IsVisible(System.Drawing.PointF)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsVisible (point As PointF) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(System::Drawing::PointF point);" />
      <MemberSignature Language="F#" Value="member this.IsVisible : System.Drawing.PointF -&gt; bool" Usage="graphics.IsVisible point" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Drawing.PointF" />
      </Parameters>
      <Docs>
        <param name="point"><see cref="T:System.Drawing.PointF" />-Struktur, die auf Sichtbarkeit geprüft werden soll.</param>
        <summary>Gibt an, ob die angegebene <see cref="T:System.Drawing.PointF" />-Struktur innerhalb des sichtbaren Ausschneidebereichs dieses <see cref="T:System.Drawing.Graphics" /> enthalten ist.</summary>
        <returns><see langword="true" />, falls der durch den <paramref name="point" />-Parameter angegebene Punkt innerhalb des sichtbaren Ausschneidebereichs dieses <see cref="T:System.Drawing.Graphics" /> enthalten ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen rechteckigen Clippingbereich und legt ihn mithilfe <xref:System.Drawing.Drawing2D.CombineMode.Replace>von als Clippingbereich für die Grafiken des Formulars fest.  
  
-   Erstellt zwei Punkte, eine innerhalb des Clippingbereichs und eine externe.  
  
-   Testet jeden der Punkte auf Sichtbarkeit und zeichnet nur den sichtbaren.  
  
 Das Ergebnis ist ein kleiner roter Kreis, der sich innerhalb des Clip Bereichs befindet.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#128](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#128)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#128](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#128)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#128](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#128)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (System.Drawing.Rectangle rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(valuetype System.Drawing.Rectangle rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.IsVisible(System.Drawing.Rectangle)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsVisible (rect As Rectangle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(System::Drawing::Rectangle rect);" />
      <MemberSignature Language="F#" Value="member this.IsVisible : System.Drawing.Rectangle -&gt; bool" Usage="graphics.IsVisible rect" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="rect"><see cref="T:System.Drawing.Rectangle" />-Struktur, die auf Sichtbarkeit geprüft werden soll.</param>
        <summary>Gibt an, ob das durch eine <see cref="T:System.Drawing.Rectangle" />-Struktur angegebene Rechteck innerhalb des sichtbaren Ausschneidebereichs dieses <see cref="T:System.Drawing.Graphics" /> enthalten ist.</summary>
        <returns><see langword="true" />, falls das durch den <paramref name="rect" />-Parameter angegebene Rechteck innerhalb des sichtbaren Ausschneidebereichs dieses <see cref="T:System.Drawing.Graphics" /> enthalten ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen rechteckigen Clippingbereich und legt ihn mithilfe <xref:System.Drawing.Drawing2D.CombineMode.Replace>von als Clippingbereich für das Grafik Objekt des Formulars fest.  
  
-   Erstellt die Position und die Größe von zwei Rechtecke, eine im Clippingbereich und eine externe.  
  
-   Testet jeden der Rechtecke auf Sichtbarkeit und zeichnet nur den sichtbaren.  
  
 Das Ergebnis ist ein kleines rotes Rechteck, das sich innerhalb des Clip Bereichs befindet.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#129](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#129)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#129](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#129)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#129](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#129)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (System.Drawing.RectangleF rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(valuetype System.Drawing.RectangleF rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.IsVisible(System.Drawing.RectangleF)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsVisible (rect As RectangleF) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(System::Drawing::RectangleF rect);" />
      <MemberSignature Language="F#" Value="member this.IsVisible : System.Drawing.RectangleF -&gt; bool" Usage="graphics.IsVisible rect" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.RectangleF" />
      </Parameters>
      <Docs>
        <param name="rect"><see cref="T:System.Drawing.RectangleF" />-Struktur, die auf Sichtbarkeit geprüft werden soll.</param>
        <summary>Gibt an, ob das durch eine <see cref="T:System.Drawing.RectangleF" />-Struktur angegebene Rechteck innerhalb des sichtbaren Ausschneidebereichs dieses <see cref="T:System.Drawing.Graphics" /> enthalten ist.</summary>
        <returns><see langword="true" />, falls das durch den <paramref name="rect" />-Parameter angegebene Rechteck innerhalb des sichtbaren Ausschneidebereichs dieses <see cref="T:System.Drawing.Graphics" /> enthalten ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen rechteckigen Clippingbereich und legt ihn mithilfe <xref:System.Drawing.Drawing2D.CombineMode.Replace>von als Clippingbereich für das Grafik Objekt des Formulars fest.  
  
-   Erstellt zwei Rechtecke, eine im Clippingbereich und eine externe.  
  
-   Testet jeden der Rechtecke auf Sichtbarkeit und zeichnet nur den sichtbaren.  
  
 Das Ergebnis ist ein kleines rotes Rechteck, das sich innerhalb des Clip Bereichs befindet.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#130](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#130)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#130](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#130)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#130](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#130)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (int x, int y);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(int32 x, int32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.IsVisible(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsVisible (x As Integer, y As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(int x, int y);" />
      <MemberSignature Language="F#" Value="member this.IsVisible : int * int -&gt; bool" Usage="graphics.IsVisible (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">Die x-Koordinate des Punkts, der auf Sichtbarkeit getestet werden soll.</param>
        <param name="y">Die y-Koordinate des Punkts, der auf Sichtbarkeit getestet werden soll.</param>
        <summary>Gibt an, ob der durch ein Koordinatenpaar angegebene Punkt im sichtbaren Ausschneidebereich von diesem <see cref="T:System.Drawing.Graphics" /> enthalten ist.</summary>
        <returns><see langword="true" />, falls der durch den <paramref name="x" />-Parameter und den <paramref name="y" />-Parameter definierte Punkt innerhalb des sichtbaren Ausschneidebereichs dieses <see cref="T:System.Drawing.Graphics" /> enthalten ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen rechteckigen Clippingbereich und legt ihn mithilfe <xref:System.Drawing.Drawing2D.CombineMode.Replace>von als Clippingbereich für das Grafik Objekt des Formulars fest.  
  
-   Erstellt zwei Punkte, eine innerhalb des Clippingbereichs und eine externe.  
  
-   Testet jeden der Punkte auf Sichtbarkeit und zeichnet nur den sichtbaren.  
  
 Das Ergebnis ist ein kleiner roter Kreis, der sich innerhalb des Clip Bereichs befindet.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#131](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#131)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#131](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#131)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#131](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#131)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (float x, float y);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(float32 x, float32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.IsVisible(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsVisible (x As Single, y As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(float x, float y);" />
      <MemberSignature Language="F#" Value="member this.IsVisible : single * single -&gt; bool" Usage="graphics.IsVisible (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Die x-Koordinate des Punkts, der auf Sichtbarkeit getestet werden soll.</param>
        <param name="y">Die y-Koordinate des Punkts, der auf Sichtbarkeit getestet werden soll.</param>
        <summary>Gibt an, ob der durch ein Koordinatenpaar angegebene Punkt im sichtbaren Ausschneidebereich von diesem <see cref="T:System.Drawing.Graphics" /> enthalten ist.</summary>
        <returns><see langword="true" />, falls der durch den <paramref name="x" />-Parameter und den <paramref name="y" />-Parameter definierte Punkt innerhalb des sichtbaren Ausschneidebereichs dieses <see cref="T:System.Drawing.Graphics" /> enthalten ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen rechteckigen Clippingbereich und legt ihn mithilfe <xref:System.Drawing.Drawing2D.CombineMode.Replace>von als Clippingbereich für das Grafik Objekt des Formulars fest.  
  
-   Erstellt zwei Punkte, eine innerhalb des Clippingbereichs und eine externe.  
  
-   Testet jeden der Punkte auf Sichtbarkeit und zeichnet nur den sichtbaren.  
  
 Das Ergebnis ist ein kleiner roter Kreis, der sich innerhalb des Clip Bereichs befindet.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#133](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#133)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#133](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#133)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#133](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#133)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (int x, int y, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(int32 x, int32 y, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.IsVisible(System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsVisible (x As Integer, y As Integer, width As Integer, height As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(int x, int y, int width, int height);" />
      <MemberSignature Language="F#" Value="member this.IsVisible : int * int * int * int -&gt; bool" Usage="graphics.IsVisible (x, y, width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">Die x-Koordinate der oberen linken Ecke des Rechtecks, das auf Sichtbarkeit getestet werden soll.</param>
        <param name="y">Die y-Koordinate der oberen linken Ecke des Rechtecks, das auf Sichtbarkeit getestet werden soll.</param>
        <param name="width">Breite des Rechtecks, das auf Sichtbarkeit getestet werden soll.</param>
        <param name="height">Höhe des Rechtecks, das auf Sichtbarkeit getestet werden soll.</param>
        <summary>Gibt an, ob das Rechteck, das durch ein Koordinatenpaar, eine Breite und eine Höhe angegeben wird, im sichtbaren Ausschneidebereich dieses <see cref="T:System.Drawing.Graphics" /> enthalten ist.</summary>
        <returns><see langword="true" />, falls das durch die Parameter <paramref name="x" />, <paramref name="y" />, <paramref name="width" /> und <paramref name="height" /> definierte Rechteck innerhalb des sichtbaren Ausschneidebereichs dieses <see cref="T:System.Drawing.Graphics" /> enthalten ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen rechteckigen Clippingbereich und legt ihn mithilfe <xref:System.Drawing.Drawing2D.CombineMode.Replace>von als Clippingbereich für das Grafik Objekt des Formulars fest.  
  
-   Erstellt die Position und die Größe von zwei Rechtecke, eine im Clippingbereich und eine externe.  
  
-   Testet jeden der Rechtecke auf Sichtbarkeit und zeichnet nur den sichtbaren.  
  
 Das Ergebnis ist ein kleines rotes Rechteck, das sich innerhalb des Clip Bereichs befindet.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#132](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#132)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#132](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#132)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#132](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#132)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (float x, float y, float width, float height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(float32 x, float32 y, float32 width, float32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.IsVisible(System.Single,System.Single,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsVisible (x As Single, y As Single, width As Single, height As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(float x, float y, float width, float height);" />
      <MemberSignature Language="F#" Value="member this.IsVisible : single * single * single * single -&gt; bool" Usage="graphics.IsVisible (x, y, width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="width" Type="System.Single" />
        <Parameter Name="height" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Die x-Koordinate der oberen linken Ecke des Rechtecks, das auf Sichtbarkeit getestet werden soll.</param>
        <param name="y">Die y-Koordinate der oberen linken Ecke des Rechtecks, das auf Sichtbarkeit getestet werden soll.</param>
        <param name="width">Breite des Rechtecks, das auf Sichtbarkeit getestet werden soll.</param>
        <param name="height">Höhe des Rechtecks, das auf Sichtbarkeit getestet werden soll.</param>
        <summary>Gibt an, ob das Rechteck, das durch ein Koordinatenpaar, eine Breite und eine Höhe angegeben wird, im sichtbaren Ausschneidebereich dieses <see cref="T:System.Drawing.Graphics" /> enthalten ist.</summary>
        <returns><see langword="true" />, falls das durch die Parameter <paramref name="x" />, <paramref name="y" />, <paramref name="width" /> und <paramref name="height" /> definierte Rechteck innerhalb des sichtbaren Ausschneidebereichs dieses <see cref="T:System.Drawing.Graphics" /> enthalten ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen rechteckigen Clippingbereich und legt ihn mithilfe <xref:System.Drawing.Drawing2D.CombineMode.Replace>von als Clippingbereich für das Grafik Objekt des Formulars fest.  
  
-   Erstellt die Position und die Größe von zwei Rechtecke, eine im Clippingbereich und eine externe.  
  
-   Testet jeden der Rechtecke auf Sichtbarkeit und zeichnet nur den sichtbaren.  
  
 Das Ergebnis ist ein kleines rotes Rechteck, das sich innerhalb des Clip Bereichs befindet.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#134](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#134)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#134](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#134)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#134](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#134)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisibleClipEmpty">
      <MemberSignature Language="C#" Value="public bool IsVisibleClipEmpty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVisibleClipEmpty" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Graphics.IsVisibleClipEmpty" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsVisibleClipEmpty As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsVisibleClipEmpty { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsVisibleClipEmpty : bool" Usage="System.Drawing.Graphics.IsVisibleClipEmpty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der sichtbare Ausschneidebereich dieses <see cref="T:System.Drawing.Graphics" /> leer ist.</summary>
        <value><see langword="true" />, falls der sichtbare Teil des Ausschneidebereichs dieses <see cref="T:System.Drawing.Graphics" /> leer ist; andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der sichtbare Ausschneide Bereich ist die Schnittmenge des Clippingbereichs dieses `Graphics` und des Clippingbereichs des Fensters.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MeasureCharacterRanges">
      <MemberSignature Language="C#" Value="public System.Drawing.Region[] MeasureCharacterRanges (string text, System.Drawing.Font font, System.Drawing.RectangleF layoutRect, System.Drawing.StringFormat stringFormat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Drawing.Region[] MeasureCharacterRanges(string text, class System.Drawing.Font font, valuetype System.Drawing.RectangleF layoutRect, class System.Drawing.StringFormat stringFormat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.MeasureCharacterRanges(System.String,System.Drawing.Font,System.Drawing.RectangleF,System.Drawing.StringFormat)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Drawing::Region ^&gt; ^ MeasureCharacterRanges(System::String ^ text, System::Drawing::Font ^ font, System::Drawing::RectangleF layoutRect, System::Drawing::StringFormat ^ stringFormat);" />
      <MemberSignature Language="F#" Value="member this.MeasureCharacterRanges : string * System.Drawing.Font * System.Drawing.RectangleF * System.Drawing.StringFormat -&gt; System.Drawing.Region[]" Usage="graphics.MeasureCharacterRanges (text, font, layoutRect, stringFormat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Region[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="font" Type="System.Drawing.Font" />
        <Parameter Name="layoutRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="stringFormat" Type="System.Drawing.StringFormat" />
      </Parameters>
      <Docs>
        <param name="text">Zu messende Zeichenfolge.</param>
        <param name="font"><see cref="T:System.Drawing.Font" />, die das Textformat der Zeichenfolge definiert.</param>
        <param name="layoutRect"><see cref="T:System.Drawing.RectangleF" />-Struktur, die das Layoutrechteck für die Zeichenfolge angibt.</param>
        <param name="stringFormat"><see cref="T:System.Drawing.StringFormat" />, das Formatierungsinformationen für die Zeichenfolge darstellt, z. B. Zeilenabstand.</param>
        <summary>Ruft ein Array von <see cref="T:System.Drawing.Region" />-Objekten ab, von denen jedes einen Bereich von Zeichenpositionen in der angegebenen Zeichenfolge umschließt.</summary>
        <returns>Diese Methode gibt ein Array von <see cref="T:System.Drawing.Region" />-Objekten zurück, von denen jedes einen Bereich von Zeichenpositionen in der angegebenen Zeichenfolge umschließt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die von dieser Methode zurückgegebenen Regionen sind Auflösungs abhängig. Daher kann es zu einem geringfügigen Genauigkeits Verlust kommen, wenn Zeichen folgen in einer Metadatei mit einer Auflösung aufgezeichnet und später in einer anderen Auflösung wiedergegeben werden.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Legt die Zeichenfolge "First und Second Range" und eine Schriftart für die Anzeige der Zeichenfolge ("Times New Roman", 16 Point) fest.  
  
-   Legt zwei Zeichen Bereiche innerhalb der Zeichenfolge fest (die den Wörtern "First" und "Second" entsprechen).  
  
-   Erstellt ein Rechteck, in dem die Zeichenfolge angezeigt werden soll.  
  
-   Legt die Formatierung der Zeichenfolge 3/4 einschließlich der beiden Zeichen Bereiche fest.  
  
-   Zeichnet die Zeichenfolge auf dem Bildschirm.  
  
-   Misst die Zeichen Bereiche, bestimmt Rechtecke, die die beiden angegebenen Bereiche gebunden haben.  
  
-   Zeichnet die zwei Rechtecke auf dem Bildschirm.  
  
 Das Ergebnis ist die angezeigte Zeichenfolge, bei der der erste Bereich ("First") durch ein rotes Rechteck und den zweiten Bereich ("Second"), der durch ein blaues Rechteck begrenzt ist, begrenzt ist.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#135](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#135)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#135](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#135)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#135](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#135)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Drawing.Graphics.MeasureString(System.String,System.Drawing.Font)" />
        <altmember cref="M:System.Windows.Forms.TextRenderer.MeasureText(System.Drawing.IDeviceContext,System.String,System.Drawing.Font,System.Drawing.Size,System.Windows.Forms.TextFormatFlags)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="MeasureString">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Misst die angegebene Zeichenfolge, wenn diese mit der angegebenen <see cref="T:System.Drawing.Font" /> gezeichnet wird.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MeasureString">
      <MemberSignature Language="C#" Value="public System.Drawing.SizeF MeasureString (string text, System.Drawing.Font font);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.SizeF MeasureString(string text, class System.Drawing.Font font) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.MeasureString(System.String,System.Drawing.Font)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::SizeF MeasureString(System::String ^ text, System::Drawing::Font ^ font);" />
      <MemberSignature Language="F#" Value="member this.MeasureString : string * System.Drawing.Font -&gt; System.Drawing.SizeF" Usage="graphics.MeasureString (text, font)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="font" Type="System.Drawing.Font" />
      </Parameters>
      <Docs>
        <param name="text">Zu messende Zeichenfolge.</param>
        <param name="font"><see cref="T:System.Drawing.Font" />, die das Textformat der Zeichenfolge definiert.</param>
        <summary>Misst die angegebene Zeichenfolge, wenn diese mit der angegebenen <see cref="T:System.Drawing.Font" /> gezeichnet wird.</summary>
        <returns>Diese Methode gibt eine <see cref="T:System.Drawing.SizeF" />-Struktur zurück, die die Größe der durch den <paramref name="text" />-Parameter angegebenen Zeichenfolge in der durch die <see cref="P:System.Drawing.Graphics.PageUnit" />-Eigenschaft angegebenen Einheit darstellt, wenn diese mit dem <paramref name="font" />-Parameter gezeichnet wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Drawing.Graphics.MeasureString%2A> -Methode ist für die Verwendung mit einzelnen Zeichen folgen konzipiert und umfasst eine kleine Menge zusätzlichen Leerraums vor und nach der Zeichenfolge, um überhängende Symbole zuzulassen. Außerdem passt die <xref:System.Drawing.Graphics.DrawString%2A> Methode Symbol Punkte an, um die Anzeigequalität zu optimieren, und zeigt möglicherweise eine Zeichen <xref:System.Drawing.Graphics.MeasureString%2A>Folge an, die kleiner als der von gemeldete Zum Abrufen von Metriken, die für angrenzende Zeichen folgen im Layout geeignet sind (z. b. bei <xref:System.Drawing.Graphics.MeasureCharacterRanges%2A> der Implementierung von formatiertem <xref:System.Drawing.Graphics.MeasureString%2A> Text), verwenden Sie die- <xref:System.Drawing.StringFormat.GenericTypographic%2A>Methode oder eine der-Methoden, die einen <xref:System.Drawing.StringFormat>annimmt und übergeben Stellen Sie außerdem sicher <xref:System.Drawing.Graphics.TextRenderingHint%2A> , dass <xref:System.Drawing.Graphics> für <xref:System.Drawing.Text.TextRenderingHint.AntiAlias>den den Wert hat.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt eine zu messende Zeichenfolge.  
  
-   Erstellt ein Schriftart Objekt und legt es auf Arial (16 Punkt) fest.  
  
-   Erstellt ein Size-Objekt und verwendet dieses und das Schriftart Objekt, um die Größe der Zeichenfolge zu messen.  
  
-   Zeichnet ein rotes Rechteck mit der gemessenen Größe der Zeichenfolge.  
  
-   Zeichnet die Zeichenfolge innerhalb des gezeichneten Rechtecks.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#136](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#136)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#136](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#136)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#136](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#136)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="font" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Forms.TextRenderer.MeasureText(System.Drawing.IDeviceContext,System.String,System.Drawing.Font,System.Drawing.Size,System.Windows.Forms.TextFormatFlags)" />
        <altmember cref="M:System.Drawing.Graphics.MeasureCharacterRanges(System.String,System.Drawing.Font,System.Drawing.RectangleF,System.Drawing.StringFormat)" />
        <related type="Article" href="~/docs/framework/winforms/advanced/using-fonts-and-text.md">Verwenden von Schriftarten und Text</related>
      </Docs>
    </Member>
    <Member MemberName="MeasureString">
      <MemberSignature Language="C#" Value="public System.Drawing.SizeF MeasureString (string text, System.Drawing.Font font, System.Drawing.SizeF layoutArea);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.SizeF MeasureString(string text, class System.Drawing.Font font, valuetype System.Drawing.SizeF layoutArea) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.MeasureString(System.String,System.Drawing.Font,System.Drawing.SizeF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::SizeF MeasureString(System::String ^ text, System::Drawing::Font ^ font, System::Drawing::SizeF layoutArea);" />
      <MemberSignature Language="F#" Value="member this.MeasureString : string * System.Drawing.Font * System.Drawing.SizeF -&gt; System.Drawing.SizeF" Usage="graphics.MeasureString (text, font, layoutArea)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="font" Type="System.Drawing.Font" />
        <Parameter Name="layoutArea" Type="System.Drawing.SizeF" />
      </Parameters>
      <Docs>
        <param name="text">Zu messende Zeichenfolge.</param>
        <param name="font"><see cref="T:System.Drawing.Font" />, die das Textformat der Zeichenfolge definiert.</param>
        <param name="layoutArea"><see cref="T:System.Drawing.SizeF" />-Struktur, die den maximalen Layoutbereich für den Text angibt.</param>
        <summary>Misst die angegebene Zeichenfolge wenn diese mit der angegebenen <see cref="T:System.Drawing.Font" /> innerhalb des angegebenen Layoutbereichs gezeichnet wird.</summary>
        <returns>Diese Methode gibt eine <see cref="T:System.Drawing.SizeF" />-Struktur zurück, die die Größe der durch den <paramref name="text" />-Parameter angegebenen Zeichenfolge in der durch die <see cref="P:System.Drawing.Graphics.PageUnit" />-Eigenschaft angegebenen Einheit darstellt, wenn diese mit dem <paramref name="font" />-Parameter gezeichnet wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Drawing.Graphics.MeasureString%2A> -Methode ist für die Verwendung mit einzelnen Zeichen folgen konzipiert und umfasst eine kleine Menge zusätzlichen Leerraums vor und nach der Zeichenfolge, um überhängende Symbole zuzulassen. Außerdem passt die <xref:System.Drawing.Graphics.DrawString%2A> Methode Symbol Punkte an, um die Anzeigequalität zu optimieren, und zeigt möglicherweise eine Zeichen <xref:System.Drawing.Graphics.MeasureString%2A>Folge an, die kleiner als der von gemeldete Zum Abrufen von Metriken, die für angrenzende Zeichen folgen im Layout geeignet sind (z. b. bei <xref:System.Drawing.Graphics.MeasureCharacterRanges%2A> der Implementierung von formatiertem <xref:System.Drawing.Graphics.MeasureString%2A> Text), verwenden Sie die- <xref:System.Drawing.StringFormat.GenericTypographic%2A>Methode oder eine der-Methoden, die einen <xref:System.Drawing.StringFormat>annimmt und übergeben Stellen Sie außerdem sicher <xref:System.Drawing.Graphics.TextRenderingHint%2A> , dass <xref:System.Drawing.Graphics> für <xref:System.Drawing.Text.TextRenderingHint.AntiAlias>den den Wert hat.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt eine zu messende Zeichenfolge und ein Font-Objekt, das auf Arial (16 Punkt) festgelegt ist.  
  
-   Legt die maximale Layoutgröße der Zeichenfolge fest.  
  
-   Erstellt ein Size-Objekt und verwendet es, das Schriftart Objekt und die maximale Layoutgröße, um die Größe der Zeichenfolge zu messen.  
  
-   Zeichnet ein rotes Rechteck mit der gemessenen Größe der Zeichenfolge.  
  
-   Zeichnet die Zeichenfolge innerhalb des gezeichneten Rechtecks.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#138](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#138)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#138](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#138)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#138](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#138)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="font" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Forms.TextRenderer.MeasureText(System.Drawing.IDeviceContext,System.String,System.Drawing.Font,System.Drawing.Size,System.Windows.Forms.TextFormatFlags)" />
        <altmember cref="M:System.Drawing.Graphics.MeasureCharacterRanges(System.String,System.Drawing.Font,System.Drawing.RectangleF,System.Drawing.StringFormat)" />
        <related type="Article" href="~/docs/framework/winforms/advanced/using-fonts-and-text.md">Verwenden von Schriftarten und Text</related>
      </Docs>
    </Member>
    <Member MemberName="MeasureString">
      <MemberSignature Language="C#" Value="public System.Drawing.SizeF MeasureString (string text, System.Drawing.Font font, int width);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.SizeF MeasureString(string text, class System.Drawing.Font font, int32 width) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.MeasureString(System.String,System.Drawing.Font,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::SizeF MeasureString(System::String ^ text, System::Drawing::Font ^ font, int width);" />
      <MemberSignature Language="F#" Value="member this.MeasureString : string * System.Drawing.Font * int -&gt; System.Drawing.SizeF" Usage="graphics.MeasureString (text, font, width)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="font" Type="System.Drawing.Font" />
        <Parameter Name="width" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="text">Zu messende Zeichenfolge.</param>
        <param name="font"><see cref="T:System.Drawing.Font" />, die das Format der Zeichenfolge definiert.</param>
        <param name="width">Maximale Breite der Zeichenfolge in Pixel.</param>
        <summary>Misst die angegebene Zeichenfolge, wenn diese mit der angegebenen <see cref="T:System.Drawing.Font" /> gezeichnet wird.</summary>
        <returns>Diese Methode gibt eine <see cref="T:System.Drawing.SizeF" />-Struktur zurück, die die Größe der durch den <paramref name="text" />-Parameter angegebenen Zeichenfolge in der durch die <see cref="P:System.Drawing.Graphics.PageUnit" />-Eigenschaft angegebenen Einheit darstellt, wenn diese mit dem <paramref name="font" />-Parameter gezeichnet wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `width` -Parameter gibt den maximalen Wert der Width-Komponente der zurück <xref:System.Drawing.SizeF> gegebenen-<xref:System.Drawing.SizeF.Width%2A>Struktur an (). Wenn der `width` -Parameter kleiner als die tatsächliche Breite der Zeichenfolge ist, wird <xref:System.Drawing.SizeF.Width%2A> die zurückgegebene Komponente auf einen Wert gekürzt, der die maximale Anzahl von Zeichen darstellt, die in die angegebene Breite passen. Um die gesamte Zeichenfolge anzupassen, wird <xref:System.Drawing.SizeF.Height%2A> die zurückgegebene Komponente an einen Wert angepasst, der die Anzeige der Zeichenfolge mit dem Zeichen Umbruch ermöglicht.  
  
 Die <xref:System.Drawing.Graphics.MeasureString%2A> -Methode ist für die Verwendung mit einzelnen Zeichen folgen konzipiert und umfasst eine kleine Menge zusätzlichen Leerraums vor und nach der Zeichenfolge, um überhängende Symbole zuzulassen. Außerdem passt die <xref:System.Drawing.Graphics.DrawString%2A> Methode Symbol Punkte an, um die Anzeigequalität zu optimieren, und zeigt möglicherweise eine Zeichen <xref:System.Drawing.Graphics.MeasureString%2A>Folge an, die kleiner als der von gemeldete Zum Abrufen von Metriken, die für angrenzende Zeichen folgen im Layout geeignet sind (z. b. bei <xref:System.Drawing.Graphics.MeasureCharacterRanges%2A> der Implementierung von formatiertem <xref:System.Drawing.Graphics.MeasureString%2A> Text), verwenden Sie die- <xref:System.Drawing.StringFormat.GenericTypographic%2A>Methode oder eine der-Methoden, die einen <xref:System.Drawing.StringFormat>annimmt und übergeben Stellen Sie außerdem sicher <xref:System.Drawing.Graphics.TextRenderingHint%2A> , dass <xref:System.Drawing.Graphics> für <xref:System.Drawing.Text.TextRenderingHint.AntiAlias>den den Wert hat.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt eine zu messende Zeichenfolge und ein Font-Objekt, das auf Arial (16 Punkt) festgelegt ist.  
  
-   Legt die maximale Breite der Zeichenfolge fest.  
  
-   Erstellt ein Size-Objekt und verwendet es, das Schriftart Objekt und die maximale Zeichen folgen Breite, um die Größe der Zeichenfolge zu messen.  
  
-   Zeichnet ein rotes Rechteck mit der gemessenen Größe der Zeichenfolge.  
  
-   Zeichnet die Zeichenfolge innerhalb des gezeichneten Rechtecks.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#141](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#141)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#141](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#141)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#141](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#141)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="font" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Forms.TextRenderer.MeasureText(System.Drawing.IDeviceContext,System.String,System.Drawing.Font,System.Drawing.Size,System.Windows.Forms.TextFormatFlags)" />
        <altmember cref="M:System.Drawing.Graphics.MeasureCharacterRanges(System.String,System.Drawing.Font,System.Drawing.RectangleF,System.Drawing.StringFormat)" />
        <related type="Article" href="~/docs/framework/winforms/advanced/using-fonts-and-text.md">Verwenden von Schriftarten und Text</related>
      </Docs>
    </Member>
    <Member MemberName="MeasureString">
      <MemberSignature Language="C#" Value="public System.Drawing.SizeF MeasureString (string text, System.Drawing.Font font, System.Drawing.PointF origin, System.Drawing.StringFormat stringFormat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.SizeF MeasureString(string text, class System.Drawing.Font font, valuetype System.Drawing.PointF origin, class System.Drawing.StringFormat stringFormat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.MeasureString(System.String,System.Drawing.Font,System.Drawing.PointF,System.Drawing.StringFormat)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::SizeF MeasureString(System::String ^ text, System::Drawing::Font ^ font, System::Drawing::PointF origin, System::Drawing::StringFormat ^ stringFormat);" />
      <MemberSignature Language="F#" Value="member this.MeasureString : string * System.Drawing.Font * System.Drawing.PointF * System.Drawing.StringFormat -&gt; System.Drawing.SizeF" Usage="graphics.MeasureString (text, font, origin, stringFormat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="font" Type="System.Drawing.Font" />
        <Parameter Name="origin" Type="System.Drawing.PointF" />
        <Parameter Name="stringFormat" Type="System.Drawing.StringFormat" />
      </Parameters>
      <Docs>
        <param name="text">Zu messende Zeichenfolge.</param>
        <param name="font"><see cref="T:System.Drawing.Font" />, die das Textformat der Zeichenfolge definiert.</param>
        <param name="origin"><see cref="T:System.Drawing.PointF" />-Struktur, die die obere linke Ecke der Zeichenfolge darstellt.</param>
        <param name="stringFormat"><see cref="T:System.Drawing.StringFormat" />, das Formatierungsinformationen für die Zeichenfolge darstellt, z. B. Zeilenabstand.</param>
        <summary>Misst die angegebene Zeichenfolge, wenn diese mit der angegebenen <see cref="T:System.Drawing.Font" /> gezeichnet und mit dem angegebenen <see cref="T:System.Drawing.StringFormat" /> formatiert wird.</summary>
        <returns>Diese Methode gibt eine <see cref="T:System.Drawing.SizeF" />-Struktur zurück, die die Größe der durch den <paramref name="text" />-Parameter angegebenen Zeichenfolge in der durch die <see cref="P:System.Drawing.Graphics.PageUnit" />-Eigenschaft angegebenen Einheit darstellt, wenn diese mit dem <paramref name="font" />-Parameter und dem <paramref name="stringFormat" />-Parameter gezeichnet wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Drawing.Graphics.MeasureString%2A> -Methode ist für die Verwendung mit einzelnen Zeichen folgen konzipiert und umfasst eine kleine Menge zusätzlichen Leerraums vor und nach der Zeichenfolge, um überhängende Symbole zuzulassen. Außerdem passt die <xref:System.Drawing.Graphics.DrawString%2A> Methode Symbol Punkte an, um die Anzeigequalität zu optimieren, und zeigt möglicherweise eine Zeichen <xref:System.Drawing.Graphics.MeasureString%2A>Folge an, die kleiner als der von gemeldete Zum Abrufen von Metriken, die für angrenzende Zeichen folgen im Layout geeignet sind (z. b. bei <xref:System.Drawing.Graphics.MeasureCharacterRanges%2A> der Implementierung von formatiertem <xref:System.Drawing.Graphics.MeasureString%2A> Text), verwenden Sie die- <xref:System.Drawing.StringFormat.GenericTypographic%2A>Methode oder eine der-Methoden, die einen <xref:System.Drawing.StringFormat>annimmt und übergeben Stellen Sie außerdem sicher <xref:System.Drawing.Graphics.TextRenderingHint%2A> , dass <xref:System.Drawing.Graphics> für <xref:System.Drawing.Text.TextRenderingHint.AntiAlias>den den Wert hat.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt eine zu messende Zeichenfolge und ein Schriftart Objekt, das auf Arial (16 Punkt) festgelegt ist.  
  
-   Erstellt einen Punkt, um die linke obere Ecke der Zeichenfolge zu suchen.  
  
-   Erstellt ein Zeichen folgen Format Objekt und legt seine Formatflags <xref:System.Drawing.StringFormatFlags.DirectionVertical>auf fest.  
  
-   Erstellt ein Size-Objekt zum Messen der Zeichenfolge.  
  
-   Misst die Größe der Zeichenfolge mithilfe der Zeichenfolge, des Schriftart Objekts, des suchen Punkts und des Zeichen folgen Formats.  
  
-   Zeichnet ein rotes Rechteck mithilfe des suchen Punkts und der gemessenen Größe der Zeichenfolge.  
  
-   Zeichnet die Zeichenfolge innerhalb des gezeichneten Rechtecks.  
  
 Das Ergebnis ist ein vertikales Rechteck, das eine vertikale Zeichenfolge einschließt.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#137](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#137)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#137](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#137)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#137](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#137)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="font" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Forms.TextRenderer.MeasureText(System.Drawing.IDeviceContext,System.String,System.Drawing.Font,System.Drawing.Size,System.Windows.Forms.TextFormatFlags)" />
        <altmember cref="M:System.Drawing.Graphics.MeasureCharacterRanges(System.String,System.Drawing.Font,System.Drawing.RectangleF,System.Drawing.StringFormat)" />
        <related type="Article" href="~/docs/framework/winforms/advanced/using-fonts-and-text.md">Verwenden von Schriftarten und Text</related>
      </Docs>
    </Member>
    <Member MemberName="MeasureString">
      <MemberSignature Language="C#" Value="public System.Drawing.SizeF MeasureString (string text, System.Drawing.Font font, System.Drawing.SizeF layoutArea, System.Drawing.StringFormat stringFormat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.SizeF MeasureString(string text, class System.Drawing.Font font, valuetype System.Drawing.SizeF layoutArea, class System.Drawing.StringFormat stringFormat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.MeasureString(System.String,System.Drawing.Font,System.Drawing.SizeF,System.Drawing.StringFormat)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::SizeF MeasureString(System::String ^ text, System::Drawing::Font ^ font, System::Drawing::SizeF layoutArea, System::Drawing::StringFormat ^ stringFormat);" />
      <MemberSignature Language="F#" Value="member this.MeasureString : string * System.Drawing.Font * System.Drawing.SizeF * System.Drawing.StringFormat -&gt; System.Drawing.SizeF" Usage="graphics.MeasureString (text, font, layoutArea, stringFormat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="font" Type="System.Drawing.Font" />
        <Parameter Name="layoutArea" Type="System.Drawing.SizeF" />
        <Parameter Name="stringFormat" Type="System.Drawing.StringFormat" />
      </Parameters>
      <Docs>
        <param name="text">Zu messende Zeichenfolge.</param>
        <param name="font"><see cref="T:System.Drawing.Font" />, die das Textformat der Zeichenfolge definiert.</param>
        <param name="layoutArea"><see cref="T:System.Drawing.SizeF" />-Struktur, die den maximalen Layoutbereich für den Text angibt.</param>
        <param name="stringFormat"><see cref="T:System.Drawing.StringFormat" />, das Formatierungsinformationen für die Zeichenfolge darstellt, z. B. Zeilenabstand.</param>
        <summary>Misst die angegebene Zeichenfolge, wenn diese mit der angegebenen <see cref="T:System.Drawing.Font" /> gezeichnet und mit dem angegebenen <see cref="T:System.Drawing.StringFormat" /> formatiert wird.</summary>
        <returns>Diese Methode gibt eine <see cref="T:System.Drawing.SizeF" />-Struktur zurück, die die Größe der durch den <paramref name="text" />-Parameter angegebenen Zeichenfolge in der durch die <see cref="P:System.Drawing.Graphics.PageUnit" />-Eigenschaft angegebenen Einheit darstellt, wenn diese mit dem <paramref name="font" />-Parameter und dem <paramref name="stringFormat" />-Parameter gezeichnet wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Drawing.Graphics.MeasureString%2A> -Methode ist für die Verwendung mit einzelnen Zeichen folgen konzipiert und umfasst eine kleine Menge zusätzlichen Leerraums vor und nach der Zeichenfolge, um überhängende Symbole zuzulassen. Außerdem passt die <xref:System.Drawing.Graphics.DrawString%2A> Methode Symbol Punkte an, um die Anzeigequalität zu optimieren, und zeigt möglicherweise eine Zeichen <xref:System.Drawing.Graphics.MeasureString%2A>Folge an, die kleiner als der von gemeldete Zum Abrufen von Metriken, die für angrenzende Zeichen folgen im Layout geeignet sind (z. b. bei <xref:System.Drawing.Graphics.MeasureCharacterRanges%2A> der Implementierung von formatiertem <xref:System.Drawing.Graphics.MeasureString%2A> Text), verwenden Sie die- <xref:System.Drawing.StringFormat.GenericTypographic%2A>Methode oder eine der-Methoden, die einen <xref:System.Drawing.StringFormat>annimmt und übergeben Stellen Sie außerdem sicher <xref:System.Drawing.Graphics.TextRenderingHint%2A> , dass <xref:System.Drawing.Graphics> für <xref:System.Drawing.Text.TextRenderingHint.AntiAlias>den den Wert hat.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt eine zu messende Zeichenfolge und ein Font-Objekt, das auf Arial (16 Punkt) festgelegt ist.  
  
-   Legt die maximale Layoutgröße der Zeichenfolge fest, wobei ein Size-Objekt zum Messen der Zeichenfolge erstellt wird.  
  
-   Erstellt ein Zeichen folgen Format Objekt und legt seine Formatflags <xref:System.Drawing.StringFormatFlags.DirectionVertical>auf fest.  
  
-   Misst die Größe der Zeichenfolge, indem die Zeichenfolge, das Schriftart Objekt, die maximale Layoutgröße und das Zeichen folgen Format verwendet werden.  
  
-   Zeichnet ein rotes Rechteck mit der gemessenen Größe der Zeichenfolge.  
  
-   Zeichnet die Zeichenfolge innerhalb des gezeichneten Rechtecks.  
  
 Das Ergebnis ist ein vertikales Rechteck, das eine vertikale Zeichenfolge einschließt.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#139](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#139)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#139](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#139)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#139](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#139)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="font" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Forms.TextRenderer.MeasureText(System.Drawing.IDeviceContext,System.String,System.Drawing.Font,System.Drawing.Size,System.Windows.Forms.TextFormatFlags)" />
        <altmember cref="M:System.Drawing.Graphics.MeasureCharacterRanges(System.String,System.Drawing.Font,System.Drawing.RectangleF,System.Drawing.StringFormat)" />
        <related type="Article" href="~/docs/framework/winforms/advanced/using-fonts-and-text.md">Verwenden von Schriftarten und Text</related>
      </Docs>
    </Member>
    <Member MemberName="MeasureString">
      <MemberSignature Language="C#" Value="public System.Drawing.SizeF MeasureString (string text, System.Drawing.Font font, int width, System.Drawing.StringFormat format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.SizeF MeasureString(string text, class System.Drawing.Font font, int32 width, class System.Drawing.StringFormat format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.MeasureString(System.String,System.Drawing.Font,System.Int32,System.Drawing.StringFormat)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::SizeF MeasureString(System::String ^ text, System::Drawing::Font ^ font, int width, System::Drawing::StringFormat ^ format);" />
      <MemberSignature Language="F#" Value="member this.MeasureString : string * System.Drawing.Font * int * System.Drawing.StringFormat -&gt; System.Drawing.SizeF" Usage="graphics.MeasureString (text, font, width, format)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="font" Type="System.Drawing.Font" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="format" Type="System.Drawing.StringFormat" />
      </Parameters>
      <Docs>
        <param name="text">Zu messende Zeichenfolge.</param>
        <param name="font"><see cref="T:System.Drawing.Font" />, die das Textformat der Zeichenfolge definiert.</param>
        <param name="width">Maximale Breite der Zeichenfolge.</param>
        <param name="format"><see cref="T:System.Drawing.StringFormat" />, das Formatierungsinformationen für die Zeichenfolge darstellt, z. B. Zeilenabstand.</param>
        <summary>Misst die angegebene Zeichenfolge, wenn diese mit der angegebenen <see cref="T:System.Drawing.Font" /> gezeichnet und mit dem angegebenen <see cref="T:System.Drawing.StringFormat" /> formatiert wird.</summary>
        <returns>Diese Methode gibt eine <see cref="T:System.Drawing.SizeF" />-Struktur zurück, die die Größe der durch den <paramref name="text" />-Parameter angegebenen Zeichenfolge in der durch die <see cref="P:System.Drawing.Graphics.PageUnit" />-Eigenschaft angegebenen Einheit darstellt, wenn diese mit dem <paramref name="font" />-Parameter und dem <paramref name="stringFormat" />-Parameter gezeichnet wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Drawing.Graphics.MeasureString%2A> -Methode ist für die Verwendung mit einzelnen Zeichen folgen konzipiert und umfasst eine kleine Menge zusätzlichen Leerraums vor und nach der Zeichenfolge, um überhängende Symbole zuzulassen. Außerdem passt die <xref:System.Drawing.Graphics.DrawString%2A> Methode Symbol Punkte an, um die Anzeigequalität zu optimieren, und zeigt möglicherweise eine Zeichen <xref:System.Drawing.Graphics.MeasureString%2A>Folge an, die kleiner als der von gemeldete Zum Abrufen von Metriken, die für angrenzende Zeichen folgen im Layout geeignet sind (z. b. bei <xref:System.Drawing.Graphics.MeasureCharacterRanges%2A> der Implementierung von formatiertem <xref:System.Drawing.Graphics.MeasureString%2A> Text), verwenden Sie die- <xref:System.Drawing.StringFormat.GenericTypographic%2A>Methode oder eine der-Methoden, die einen <xref:System.Drawing.StringFormat>annimmt und übergeben Stellen Sie außerdem sicher <xref:System.Drawing.Graphics.TextRenderingHint%2A> , dass <xref:System.Drawing.Graphics> für <xref:System.Drawing.Text.TextRenderingHint.AntiAlias>den den Wert hat.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt eine zu messende Zeichenfolge und ein Font-Objekt wird auf Arial (16 Punkt) festgelegt.  
  
-   Legt die maximale Breite der Zeichenfolge fest.  
  
-   Erstellt ein Zeichen folgen Format Objekt und legt seine Formatflags <xref:System.Drawing.StringFormatFlags.DirectionVertical>auf fest.  
  
-   Erstellt ein Size-Objekt zum Messen der Zeichenfolge.  
  
-   Misst die Größe der Zeichenfolge unter Verwendung der Zeichenfolge, des Schriftart Objekts, der maximalen Breite und des Zeichen folgen Formats.  
  
-   Zeichnet ein rotes Rechteck mit der gemessenen Größe der Zeichenfolge.  
  
-   Zeichnet die Zeichenfolge innerhalb des gezeichneten Rechtecks.  
  
 Das Ergebnis ist ein vertikales Rechteck, das eine vertikale Zeichenfolge einschließt.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#142](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#142)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#142](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#142)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#142](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#142)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="font" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Forms.TextRenderer.MeasureText(System.Drawing.IDeviceContext,System.String,System.Drawing.Font,System.Drawing.Size,System.Windows.Forms.TextFormatFlags)" />
        <altmember cref="M:System.Drawing.Graphics.MeasureCharacterRanges(System.String,System.Drawing.Font,System.Drawing.RectangleF,System.Drawing.StringFormat)" />
        <related type="Article" href="~/docs/framework/winforms/advanced/using-fonts-and-text.md">Verwenden von Schriftarten und Text</related>
      </Docs>
    </Member>
    <Member MemberName="MeasureString">
      <MemberSignature Language="C#" Value="public System.Drawing.SizeF MeasureString (string text, System.Drawing.Font font, System.Drawing.SizeF layoutArea, System.Drawing.StringFormat stringFormat, out int charactersFitted, out int linesFilled);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.SizeF MeasureString(string text, class System.Drawing.Font font, valuetype System.Drawing.SizeF layoutArea, class System.Drawing.StringFormat stringFormat, [out] int32&amp; charactersFitted, [out] int32&amp; linesFilled) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.MeasureString(System.String,System.Drawing.Font,System.Drawing.SizeF,System.Drawing.StringFormat,System.Int32@,System.Int32@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::SizeF MeasureString(System::String ^ text, System::Drawing::Font ^ font, System::Drawing::SizeF layoutArea, System::Drawing::StringFormat ^ stringFormat, [Runtime::InteropServices::Out] int % charactersFitted, [Runtime::InteropServices::Out] int % linesFilled);" />
      <MemberSignature Language="F#" Value="member this.MeasureString : string * System.Drawing.Font * System.Drawing.SizeF * System.Drawing.StringFormat * int * int -&gt; System.Drawing.SizeF" Usage="graphics.MeasureString (text, font, layoutArea, stringFormat, charactersFitted, linesFilled)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="font" Type="System.Drawing.Font" />
        <Parameter Name="layoutArea" Type="System.Drawing.SizeF" />
        <Parameter Name="stringFormat" Type="System.Drawing.StringFormat" />
        <Parameter Name="charactersFitted" Type="System.Int32" RefType="out" />
        <Parameter Name="linesFilled" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="text">Zu messende Zeichenfolge.</param>
        <param name="font"><see cref="T:System.Drawing.Font" />, die das Textformat der Zeichenfolge definiert.</param>
        <param name="layoutArea"><see cref="T:System.Drawing.SizeF" />-Struktur, die den maximalen Layoutbereich für den Text angibt.</param>
        <param name="stringFormat"><see cref="T:System.Drawing.StringFormat" />, das Formatierungsinformationen für die Zeichenfolge darstellt, z. B. Zeilenabstand.</param>
        <param name="charactersFitted">Anzahl der Zeichen in der Zeichenfolge.</param>
        <param name="linesFilled">Anzahl der Textzeilen in der Zeichenfolge.</param>
        <summary>Misst die angegebene Zeichenfolge, wenn diese mit der angegebenen <see cref="T:System.Drawing.Font" /> gezeichnet und mit dem angegebenen <see cref="T:System.Drawing.StringFormat" /> formatiert wird.</summary>
        <returns>Diese Methode gibt eine <see cref="T:System.Drawing.SizeF" />-Struktur zurück, die die Größe der Zeichenfolge des <paramref name="text" />-Parameters in der durch die <see cref="P:System.Drawing.Graphics.PageUnit" />-Eigenschaft angegebenen Einheit darstellt, wenn diese mit dem <paramref name="font" />-Parameter und dem <paramref name="stringFormat" />-Parameter gezeichnet wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Drawing.Graphics.MeasureString%2A> -Methode ist für die Verwendung mit einzelnen Zeichen folgen konzipiert und umfasst eine kleine Menge zusätzlichen Leerraums vor und nach der Zeichenfolge, um überhängende Symbole zuzulassen. Außerdem passt die <xref:System.Drawing.Graphics.DrawString%2A> Methode Symbol Punkte an, um die Anzeigequalität zu optimieren, und zeigt möglicherweise eine Zeichen <xref:System.Drawing.Graphics.MeasureString%2A>Folge an, die kleiner als der von gemeldete Verwenden Sie zum Abrufen von Metriken, die für angrenzende Zeichen folgen im Layout geeignet sind (z. b <xref:System.Drawing.Graphics.MeasureCharacterRanges%2A> . bei der Implementierung von <xref:System.Drawing.Graphics.MeasureString%2A> formatiertem Text), die <xref:System.Drawing.StringFormat.GenericTypographic%2A>-Methode oder eine der-Methoden, die einen <xref:System.Drawing.StringFormat> -Wert Stellen Sie außerdem <xref:System.Drawing.Graphics.TextRenderingHint%2A> sicher, <xref:System.Drawing.Graphics> dass <xref:System.Drawing.Text.TextRenderingHint.AntiAlias>für den ist.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt eine zu messende Zeichenfolge und ein Schriftart Objekt, das auf Arial (16 Punkt) festgelegt ist.  
  
-   Legt die maximale Layoutgröße der Zeichenfolge fest.  
  
-   Erstellt ein Zeichen folgen Format Objekt und legt seine Formatflags <xref:System.Drawing.StringFormatFlags.DirectionVertical>auf fest.  
  
-   Erstellt die ganzzahligen `linesFilled` Variablen `charactersFitted` und und ein Size-Objekt, um die Zeichenfolge zu messen.  
  
-   Misst die Größe der Zeichenfolge und bestimmt die Anzahl von Zeichen, die mit der Zeichenfolge, dem Schriftart Objekt, der maximalen Layoutgröße und dem Zeichen folgen Format eingefügt werden.  
  
-   Zeichnet ein rotes Rechteck mit der gemessenen Größe der Zeichenfolge.  
  
-   Zeichnet die Zeichenfolge innerhalb des gezeichneten Rechtecks.  
  
-   Zeichnet die Werte für die Anzahl der eingefügt Zeichen und die ausgefüllten Zeilen.  
  
 Das Ergebnis ist ein vertikales Rechteck, das eine vertikale Zeichenfolge einschließt.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#140](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#140)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#140](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#140)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#140](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#140)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="font" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Forms.TextRenderer.MeasureText(System.Drawing.IDeviceContext,System.String,System.Drawing.Font,System.Drawing.Size,System.Windows.Forms.TextFormatFlags)" />
        <altmember cref="M:System.Drawing.Graphics.MeasureCharacterRanges(System.String,System.Drawing.Font,System.Drawing.RectangleF,System.Drawing.StringFormat)" />
        <related type="Article" href="~/docs/framework/winforms/advanced/using-fonts-and-text.md">Verwenden von Schriftarten und Text</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="MultiplyTransform">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Multipliziert die globale Transformation für dieses <see cref="T:System.Drawing.Graphics" /> und die angegebene <see cref="T:System.Drawing.Drawing2D.Matrix" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MultiplyTransform">
      <MemberSignature Language="C#" Value="public void MultiplyTransform (System.Drawing.Drawing2D.Matrix matrix);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MultiplyTransform(class System.Drawing.Drawing2D.Matrix matrix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.MultiplyTransform(System.Drawing.Drawing2D.Matrix)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MultiplyTransform(System::Drawing::Drawing2D::Matrix ^ matrix);" />
      <MemberSignature Language="F#" Value="member this.MultiplyTransform : System.Drawing.Drawing2D.Matrix -&gt; unit" Usage="graphics.MultiplyTransform matrix" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="matrix" Type="System.Drawing.Drawing2D.Matrix" />
      </Parameters>
      <Docs>
        <param name="matrix">4x4 <see cref="T:System.Drawing.Drawing2D.Matrix" />, die die globale Transformation multipliziert.</param>
        <summary>Multipliziert die globale Transformation für dieses <see cref="T:System.Drawing.Graphics" /> und die angegebene <see cref="T:System.Drawing.Drawing2D.Matrix" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit dieser Methode wird die durch den `matrix` -Parameter angegebene Matrix vorangestellt, sodass das Ergebnis x World-Transformation ist. `matrix`  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt eine `transformMatrix` Matrix (zwei durch zwei Identitätsmatrix und einen Vektor mit NULL Übersetzung).  
  
-   Übersetzt die Transformationsmatrix durch einen Vektor (200, 100).  
  
-   Rotiert die World Transformation Matrix des Windows Forms um 30 Grad und stellt der Transformationsmatrix des Formulars die Rotations Matrix für 30 Grad voran.  
  
-   Multipliziert die gedrehte World-Transformationsmatrix mit der `transformMatrix`übersetzten und stellt der `transformMatrix` Transformationsmatrix der Welt einen vorangestellt.  
  
-   Zeichnet eine gedrehte, übersetzte Ellipse.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#143](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#143)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#143](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#143)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#143](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#143)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/0659fe00-9e0c-41c4-9118-016f2404c905">Matrixdarstellung von Transformationen</related>
      </Docs>
    </Member>
    <Member MemberName="MultiplyTransform">
      <MemberSignature Language="C#" Value="public void MultiplyTransform (System.Drawing.Drawing2D.Matrix matrix, System.Drawing.Drawing2D.MatrixOrder order);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MultiplyTransform(class System.Drawing.Drawing2D.Matrix matrix, valuetype System.Drawing.Drawing2D.MatrixOrder order) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.MultiplyTransform(System.Drawing.Drawing2D.Matrix,System.Drawing.Drawing2D.MatrixOrder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MultiplyTransform(System::Drawing::Drawing2D::Matrix ^ matrix, System::Drawing::Drawing2D::MatrixOrder order);" />
      <MemberSignature Language="F#" Value="member this.MultiplyTransform : System.Drawing.Drawing2D.Matrix * System.Drawing.Drawing2D.MatrixOrder -&gt; unit" Usage="graphics.MultiplyTransform (matrix, order)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="matrix" Type="System.Drawing.Drawing2D.Matrix" />
        <Parameter Name="order" Type="System.Drawing.Drawing2D.MatrixOrder" />
      </Parameters>
      <Docs>
        <param name="matrix">4x4 <see cref="T:System.Drawing.Drawing2D.Matrix" />, die die globale Transformation multipliziert.</param>
        <param name="order">Member der <see cref="T:System.Drawing.Drawing2D.MatrixOrder" />-Enumeration, der die Reihenfolge der Multiplikation bestimmt.</param>
        <summary>Multipliziert die globale Transformation dieses <see cref="T:System.Drawing.Graphics" /> und die angegebene <see cref="T:System.Drawing.Drawing2D.Matrix" /> in der angegebenen Reihenfolge.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert <xref:System.Drawing.Drawing2D.MatrixOrder.Prepend> für den `order` -Parameter gibt an, dass die Reihenfolge der `matrix` Multiplikation x World-Transformation ist. Der Wert <xref:System.Drawing.Drawing2D.MatrixOrder.Append> für `order` gibt an, dass die Reihenfolge der Multiplikation World Transformation `matrix`x ist.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt eine `transformMatrix` Matrix (zwei durch zwei Identitätsmatrix und einen Vektor mit NULL Übersetzung).  
  
-   Übersetzt die Transformationsmatrix durch einen Vektor (200, 100).  
  
-   Rotiert die World Transformation Matrix des Windows Forms um 30 Grad, wobei die Rotations Matrix für 30 Grad der Transformationsmatrix des Formulars vorangestellt wird.  
  
-   Multipliziert die gedrehte globale Transformationsmatrix durch das über `transformMatrix`setzte, wobei der `transformMatrix` an die Transformationsmatrix der Welt angehängt wird.  
  
-   Zeichnet eine gedrehte, übersetzte Ellipse.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#144](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#144)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#144](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#144)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#144](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#144)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/0659fe00-9e0c-41c4-9118-016f2404c905">Matrixdarstellung von Transformationen</related>
      </Docs>
    </Member>
    <Member MemberName="PageScale">
      <MemberSignature Language="C#" Value="public float PageScale { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float32 PageScale" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Graphics.PageScale" />
      <MemberSignature Language="VB.NET" Value="Public Property PageScale As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property float PageScale { float get(); void set(float value); };" />
      <MemberSignature Language="F#" Value="member this.PageScale : single with get, set" Usage="System.Drawing.Graphics.PageScale" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Skalierung zwischen globalen Einheiten und Seiteneinheiten für dieses <see cref="T:System.Drawing.Graphics" /> ab, oder legt diese fest.</summary>
        <value>Diese Eigenschaft gibt einen Wert für die Skalierung zwischen globalen Einheiten und Seiteneinheiten für dieses <see cref="T:System.Drawing.Graphics" /> an.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.Drawing.Graphics.PageScale%2A> - <xref:System.Drawing.Graphics.TranslateTransform%2A> und-Member verwendet werden, um die Skala und den Ursprung beim Zeichnen eines Rechtecks zu ändern.  
  
 Dieses Beispiel ist für die Verwendung mit Windows Forms konzipiert. Fügen Sie den Code in ein Formular ein, `ChangePageScaleAndTranslateTransform` und nennen Sie die-Methode <xref:System.Windows.Forms.Control.Paint> , wenn Sie das <xref:System.Windows.Forms.PaintEventArgs>-Ereignis des Formulars verarbeiten und als übergeben `e` .  
  
 [!code-cpp[System.Drawing.GraphicsProperties#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.GraphicsProperties/CPP/form1.cpp#2)]
 [!code-csharp[System.Drawing.GraphicsProperties#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.GraphicsProperties/CS/form1.cs#2)]
 [!code-vb[System.Drawing.GraphicsProperties#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.GraphicsProperties/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/c61ff50a-eb1d-4e6c-83cd-f7e9764cfa9f">Typen von Koordinatensystemen</related>
      </Docs>
    </Member>
    <Member MemberName="PageUnit">
      <MemberSignature Language="C#" Value="public System.Drawing.GraphicsUnit PageUnit { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.GraphicsUnit PageUnit" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Graphics.PageUnit" />
      <MemberSignature Language="VB.NET" Value="Public Property PageUnit As GraphicsUnit" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::GraphicsUnit PageUnit { System::Drawing::GraphicsUnit get(); void set(System::Drawing::GraphicsUnit value); };" />
      <MemberSignature Language="F#" Value="member this.PageUnit : System.Drawing.GraphicsUnit with get, set" Usage="System.Drawing.Graphics.PageUnit" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.GraphicsUnit</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die in diesem <see cref="T:System.Drawing.Graphics" /> für Seitenkoordinaten verwendete Maßeinheit ab, oder legt diese fest.</summary>
        <value>Einer der <see cref="T:System.Drawing.GraphicsUnit" />-Werte, der nicht <see cref="F:System.Drawing.GraphicsUnit.World" /> ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Grafikeinheit ist die Maßeinheit, die in diesem <xref:System.Drawing.Graphics>für Seiten Koordinaten verwendet wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden die Auswirkungen der Änderung der <xref:System.Drawing.Graphics.PageUnit%2A> -Eigenschaft veranschaulicht.  
  
 Dieses Beispiel ist für die Verwendung mit Windows Forms konzipiert. Fügen Sie den Code in ein Formular ein, `ChangePageUnit` und nennen Sie die-Methode <xref:System.Windows.Forms.Control.Paint> , wenn Sie das <xref:System.Windows.Forms.PaintEventArgs>-Ereignis des Formulars verarbeiten und als übergeben `e` .  
  
 [!code-cpp[System.Drawing.GraphicsProperties#3](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.GraphicsProperties/CPP/form1.cpp#3)]
 [!code-csharp[System.Drawing.GraphicsProperties#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.GraphicsProperties/CS/form1.cs#3)]
 [!code-vb[System.Drawing.GraphicsProperties#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.GraphicsProperties/VB/form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><see cref="P:System.Drawing.Graphics.PageUnit" /> wird auf die nicht physische Einheit <see cref="F:System.Drawing.GraphicsUnit.World" /> festgelegt.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/c61ff50a-eb1d-4e6c-83cd-f7e9764cfa9f">Typen von Koordinatensystemen</related>
      </Docs>
    </Member>
    <Member MemberName="PixelOffsetMode">
      <MemberSignature Language="C#" Value="public System.Drawing.Drawing2D.PixelOffsetMode PixelOffsetMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Drawing2D.PixelOffsetMode PixelOffsetMode" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Graphics.PixelOffsetMode" />
      <MemberSignature Language="VB.NET" Value="Public Property PixelOffsetMode As PixelOffsetMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Drawing2D::PixelOffsetMode PixelOffsetMode { System::Drawing::Drawing2D::PixelOffsetMode get(); void set(System::Drawing::Drawing2D::PixelOffsetMode value); };" />
      <MemberSignature Language="F#" Value="member this.PixelOffsetMode : System.Drawing.Drawing2D.PixelOffsetMode with get, set" Usage="System.Drawing.Graphics.PixelOffsetMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Drawing2D.PixelOffsetMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, wie Pixel beim Rendering dieses <see cref="T:System.Drawing.Graphics" />-Objekts ausgeglichen werden, oder legt diesen fest.</summary>
        <value>Diese Eigenschaft gibt einen Member der <see cref="T:System.Drawing.Drawing2D.PixelOffsetMode" />-Enumeration an.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Eigenschaft, um eine höhere Qualität, ein langsameres Rendering oder eine niedrigere Qualität anzugeben, wodurch sich der <xref:System.Drawing.Graphics> Inhalt dieses Objekts schneller rendert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReleaseHdc">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt ein Handle für einen Gerätekontext frei, das bei einem vorherigen Aufruf der <see cref="M:System.Drawing.Graphics.GetHdc" />-Methode von diesem <see cref="T:System.Drawing.Graphics" /> abgerufen wurde.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReleaseHdc">
      <MemberSignature Language="C#" Value="public void ReleaseHdc ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReleaseHdc() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.ReleaseHdc" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseHdc ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ReleaseHdc();" />
      <MemberSignature Language="F#" Value="abstract member ReleaseHdc : unit -&gt; unit&#xA;override this.ReleaseHdc : unit -&gt; unit" Usage="graphics.ReleaseHdc " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Drawing.IDeviceContext.ReleaseHdc</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt ein Handle für einen Gerätekontext frei, das bei einem vorherigen Aufruf der <see cref="M:System.Drawing.Graphics.GetHdc" />-Methode von diesem <see cref="T:System.Drawing.Graphics" /> abgerufen wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Drawing.Graphics.GetHdc%2A>und <xref:System.Drawing.Graphics.ReleaseHdc%2A> sind zwei Methoden, mit denen Sie das Handle für ein Windows-Gerät erhalten und freigeben können. Wenn Sie mit dem Windows-Handle <xref:System.Drawing.Graphics.GetHdc%2A> fertig sind, sollten Sie immer einen-Aufrufvorgang ausführen. <xref:System.Drawing.Graphics.ReleaseHdc%2A>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff auf nicht verwalteten Code. Verwandte Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
        <altmember cref="T:System.Drawing.IDeviceContext" />
      </Docs>
    </Member>
    <Member MemberName="ReleaseHdc">
      <MemberSignature Language="C#" Value="public void ReleaseHdc (IntPtr hdc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReleaseHdc(native int hdc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.ReleaseHdc(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseHdc (hdc As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReleaseHdc(IntPtr hdc);" />
      <MemberSignature Language="F#" Value="member this.ReleaseHdc : nativeint -&gt; unit" Usage="graphics.ReleaseHdc hdc" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netcore-2.1;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hdc" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="hdc">Handle für einen Gerätekontext, der durch einen vorherigen Aufruf der <see cref="M:System.Drawing.Graphics.GetHdc" />-Methode dieses <see cref="T:System.Drawing.Graphics" /> abgerufen wurde.</param>
        <summary>Gibt ein Handle für einen Gerätekontext frei, das bei einem vorherigen Aufruf der <see cref="M:System.Drawing.Graphics.GetHdc" />-Methode von diesem <see cref="T:System.Drawing.Graphics" /> abgerufen wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Gerätekontext ist eine auf [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] basierende Windows-Struktur, die einen Satz grafischer Objekte und ihre zugeordneten Attribute sowie die grafischen Modi, die die Ausgabe beeinflussen, definiert.  
  
 Aufrufe der- <xref:System.Drawing.Graphics.GetHdc%2A> Methode <xref:System.Drawing.Graphics.ReleaseHdc%2A> und der-Methode müssen paarweise angezeigt werden. Während des Gültigkeits Bereichs <xref:System.Drawing.Graphics.GetHdc%2A> eines <xref:System.Drawing.Graphics.ReleaseHdc%2A> -und-Methoden Paars werden [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] in der Regel nur-Funktionen aufgerufen. Aufrufe in diesem Bereich, die [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] <xref:System.Drawing.Graphics> an Methoden von vorgenommen wurden, `hdc` die den-Parameter `ObjectBusy` erzeugt haben, schlagen mit einem Fehler fehl. Ignoriert außerdem [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] alle Zustandsänderungen, die an der <xref:System.Drawing.Graphics> des `hdc` -Parameters in nachfolgenden Vorgängen vorgenommen werden.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Das Beispiel veranschaulicht das Aufrufen einer [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] Windows-Funktion, um dieselbe Aufgabe wie [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] eine <xref:System.Drawing.Graphics> Methode auszuführen. Der Code führt die folgenden Aktionen aus:  
  
-   Definiert das Interoperabilitäts <xref:System.Runtime.InteropServices.DllImportAttribute> Attribut für die Windows-DLL-Datei gdi32. dll. Diese DLL enthält die gewünschte [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] Funktion und definiert die <xref:System.Drawing.Rectangle> Funktion in dieser DLL als extern.  
  
-   Erstellt einen roten Stift.  
  
-   Mit dem Stift zeichnet ein Rechteck mithilfe der [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] <xref:System.Drawing.Graphics.DrawRectangle%2A> -Methode auf dem Bildschirm.  
  
-   Definiert eine interne Zeigertyp `hdc` Variable und legt ihren Wert auf das Handle für den Gerätekontext des Formulars fest.  
  
-   Zeichnet ein Rechteck mithilfe der [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] <xref:System.Drawing.Rectangle> -Funktion auf dem Bildschirm.  
  
-   Gibt den Gerätekontext frei, der `hdc` durch den-Parameter dargestellt wird.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#145](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#145)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#145](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#145)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#145](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#145)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff auf nicht verwalteten Code. Verwandte Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ReleaseHdcInternal">
      <MemberSignature Language="C#" Value="public void ReleaseHdcInternal (IntPtr hdc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReleaseHdcInternal(native int hdc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.ReleaseHdcInternal(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseHdcInternal (hdc As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReleaseHdcInternal(IntPtr hdc);" />
      <MemberSignature Language="F#" Value="member this.ReleaseHdcInternal : nativeint -&gt; unit" Usage="graphics.ReleaseHdcInternal hdc" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netcore-2.1;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hdc" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="hdc">Handle für einen Gerätekontext.</param>
        <summary>Gibt ein Handle für einen Gerätekontext frei.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff auf nicht verwalteten Code. Verwandte Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="RenderingOrigin">
      <MemberSignature Language="C#" Value="public System.Drawing.Point RenderingOrigin { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Point RenderingOrigin" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Graphics.RenderingOrigin" />
      <MemberSignature Language="VB.NET" Value="Public Property RenderingOrigin As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Point RenderingOrigin { System::Drawing::Point get(); void set(System::Drawing::Point value); };" />
      <MemberSignature Language="F#" Value="member this.RenderingOrigin : System.Drawing.Point with get, set" Usage="System.Drawing.Graphics.RenderingOrigin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Renderingursprung dieses <see cref="T:System.Drawing.Graphics" /> für Dithering und Schraffurpinsel ab, oder legt diesen fest.</summary>
        <value>Eine <see cref="T:System.Drawing.Point" />-Struktur, die den Ursprung für das Dithering mit 8 Bits pro Pixel und 16 Bits pro Pixel darstellt und auch für das Festlegen des Ursprungs für Schraffurpinsel verwendet wird.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetClip">
      <MemberSignature Language="C#" Value="public void ResetClip ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetClip() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.ResetClip" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetClip ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetClip();" />
      <MemberSignature Language="F#" Value="member this.ResetClip : unit -&gt; unit" Usage="graphics.ResetClip " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Setzt den Ausschneidebereich dieses <see cref="T:System.Drawing.Graphics" /> auf einen unendlichen Bereich zurück.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Clippingbereich <xref:System.Drawing.Graphics> eines unendlich ist, werden die Elemente <xref:System.Drawing.Graphics> , die dieser zeichnet, nicht abgeschnitten.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein Rechteck mit der oberen linken Ecke bei (0,0) und legt den Clippingbereich auf dieses Rechteck fest.  
  
-   Erstellt ein zweites Rechteck mit der oberen linken Ecke um (100, 100) und legt den Clippingbereich auf die Schnittmenge dieses Rechtecks und des aktuellen Clippingbereichs (das erste Rechteck) fest.  
  
-   Füllt ein großes Rechteck aus, das beide vorangehenden Rechtecke mit einem Pinsel mit festem blau enthält.  
  
-   Setzt den Clippingbereich auf unendlich zurück.  
  
-   Zeichnet Rechtecke um die beiden Clippingbereiche. Dabei wird ein schwarzer Stift für das erste Clippingrechteck und ein roter Stift für den zweiten Clippingbereich verwendet.  
  
 Das Ergebnis ist, dass nur die Schnittmenge der beiden Rechtecke mit blau gefüllt wird.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#146](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#146)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#146](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#146)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#146](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#146)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetTransform">
      <MemberSignature Language="C#" Value="public void ResetTransform ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetTransform() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.ResetTransform" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetTransform ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetTransform();" />
      <MemberSignature Language="F#" Value="member this.ResetTransform : unit -&gt; unit" Usage="graphics.ResetTransform " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Setzt die globale Transformationsmatrix dieses <see cref="T:System.Drawing.Graphics" /> auf die Identitätsmatrix zurück.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Identitätsmatrix stellt eine Transformation ohne Skalierung, Drehung oder Übersetzung dar. Das Zurücksetzen der weltweiten Transformation <xref:System.Drawing.Graphics> dieses auf die Identitätsmatrix bedeutet, dass die globale Transformation nicht die Geometrie transformierter Elemente ändert.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Übersetzt die Welt Transformation von Windows Form durch einen Vektor (100, 0).  
  
-   Speichert den Grafik Zustand des Formulars.  
  
-   Setzt die globale Transformation des Formulars auf eine Identität zurück und füllt ein Rechteck mit einem soliden roten Pinsel.  
  
-   Stellt den übersetzten Grafik Zustand wieder her und füllt ein Rechteck mit einem Pinsel mit ausgefülltem blauen Pinsel.  
  
 Das Ergebnis ist ein nicht übersetztes, rot ausgefülltes Rechteck und ein über setztes blau auffülltes Rechteck.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#147](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#147)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#147](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#147)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#147](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#147)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Restore">
      <MemberSignature Language="C#" Value="public void Restore (System.Drawing.Drawing2D.GraphicsState gstate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Restore(class System.Drawing.Drawing2D.GraphicsState gstate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.Restore(System.Drawing.Drawing2D.GraphicsState)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Restore (gstate As GraphicsState)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Restore(System::Drawing::Drawing2D::GraphicsState ^ gstate);" />
      <MemberSignature Language="F#" Value="member this.Restore : System.Drawing.Drawing2D.GraphicsState -&gt; unit" Usage="graphics.Restore gstate" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="gstate" Type="System.Drawing.Drawing2D.GraphicsState" />
      </Parameters>
      <Docs>
        <param name="gstate"><see cref="T:System.Drawing.Drawing2D.GraphicsState" />, der den Zustand darstellt, der für dieses <see cref="T:System.Drawing.Graphics" /> wiederhergestellt werden soll.</param>
        <summary>Stellt den Zustand dieses <see cref="T:System.Drawing.Graphics" /> wieder her, der durch einen <see cref="T:System.Drawing.Drawing2D.GraphicsState" /> dargestellt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie die <xref:System.Drawing.Graphics.Save%2A> -Methode <xref:System.Drawing.Graphics>eines aufzurufen, <xref:System.Drawing.Graphics> wird ein Informationsblock, der den Zustand von enthält, in einen Stapel eingefügt. Die <xref:System.Drawing.Graphics.Save%2A> -Methode gibt <xref:System.Drawing.Drawing2D.GraphicsState> einen zurück, der diesen Informationsblock identifiziert. <xref:System.Drawing.Drawing2D.GraphicsState> Wenn Sie das identifizierende an die <xref:System.Drawing.Graphics.Restore%2A> -Methode übergeben, wird der Informationsblock aus dem Stapel entfernt und verwendet, um die <xref:System.Drawing.Graphics> in dem Zustand wiederherzustellen, in dem <xref:System.Drawing.Graphics.Save%2A> Sie sich zum Zeitpunkt des Methoden Aufrufens befand. Beachten Sie, <xref:System.Drawing.Drawing2D.GraphicsState> dass der, der von einem gegebenen <xref:System.Drawing.Graphics.Save%2A> -Methoden Rückruf zurückgegeben wurde, nur `Restore` einmal an die-Methode übergeben werden kann.  
  
 Aufrufe der- <xref:System.Drawing.Graphics.Save%2A> Methode können mit einem anderen Aufruf erfolgen, d. h., <xref:System.Drawing.Graphics.Save%2A> Sie können die-Methode mehrmals aufrufen <xref:System.Drawing.Graphics.Restore%2A> , bevor Sie die-Methode aufrufen. Jedes Mal, wenn Sie <xref:System.Drawing.Graphics.Save%2A> die-Methode aufzurufen, wird ein Informationsblock in den Stapel eingefügt, <xref:System.Drawing.Drawing2D.GraphicsState> und Sie erhalten eine für den Informationsblock. Wenn Sie eines dieser Objekte <xref:System.Drawing.Graphics.Restore%2A> an die-Methode übergeben, wird die an den Zustand zurückgegeben, in dem Sie sich <xref:System.Drawing.Graphics.Save%2A> zum Zeitpunkt des Methoden Aufrufes befand <xref:System.Drawing.Drawing2D.GraphicsState>, der <xref:System.Drawing.Graphics> diese bestimmte zurückgegeben hat. Der Informationsblock, der durch diesen <xref:System.Drawing.Graphics.Save%2A> Methoden Anruf auf dem Stapel abgelegt wird, wird aus dem Stapel entfernt, und alle Informationsblöcke, die nach diesem <xref:System.Drawing.Graphics.Save%2A> Methoden Anruf auf diesem Stapel platziert werden, werden ebenfalls entfernt.  
  
 Aufrufe der <xref:System.Drawing.Graphics.BeginContainer%2A> -Methode platzieren Informationsblöcke auf demselben Stapel wie Aufrufe der <xref:System.Drawing.Graphics.Save%2A> -Methode. Ebenso wie ein <xref:System.Drawing.Graphics.Restore%2A> -Befehl mit einem <xref:System.Drawing.Graphics.Save%2A> -Befehl gekoppelt wird <xref:System.Drawing.Graphics.EndContainer%2A> , wird ein Methoden aufrufspaar einem <xref:System.Drawing.Graphics.BeginContainer%2A> Methoden aufzurufen.  
  
 <xref:System.Drawing.Graphics.Restore%2A> Wenn Sie die-Methode aufzurufen, werden alle Informationsblöcke, die auf dem <xref:System.Drawing.Graphics.Save%2A> Stapel abgelegt werden ( <xref:System.Drawing.Graphics.BeginContainer%2A> durch die-Methode oder die- <xref:System.Drawing.Graphics.Save%2A> Methode), nachdem der entsprechende aufrufungsaufrufungsmethode aus dem Stapel entfernt wurde. Ebenso <xref:System.Drawing.Graphics.EndContainer%2A> werden beim Abrufen der-Methode alle Informationsblöcke, die auf dem Stapel abgelegt werden (durch die <xref:System.Drawing.Graphics.Save%2A> -Methode <xref:System.Drawing.Graphics.BeginContainer%2A> oder die- <xref:System.Drawing.Graphics.BeginContainer%2A> Methode), nachdem der entsprechende aufrufungsaufrufder Methode aus dem Stapel entfernt wurde.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Übersetzt die Welt Transformation von Windows Form durch einen Vektor (100, 0).  
  
-   Speichert den Grafik Zustand des Formulars.  
  
-   Setzt die globale Transformation des Formulars auf eine Identität zurück und füllt ein Rechteck mit einem soliden roten Pinsel.  
  
-   Stellt den übersetzten Grafik Zustand wieder her und füllt ein zweites Rechteck mit einem Pinsel mit festem blau.  
  
 Das Ergebnis ist ein nicht übersetztes, rot ausgefülltes Rechteck und ein über setztes blau auffülltes Rechteck.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#148](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#148)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#148](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#148)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#148](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#148)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RotateTransform">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wendet die angegebene Drehung auf die Transformationsmatrix dieses <see cref="T:System.Drawing.Graphics" /> an.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RotateTransform">
      <MemberSignature Language="C#" Value="public void RotateTransform (float angle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RotateTransform(float32 angle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.RotateTransform(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RotateTransform (angle As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RotateTransform(float angle);" />
      <MemberSignature Language="F#" Value="member this.RotateTransform : single -&gt; unit" Usage="graphics.RotateTransform angle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="angle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="angle">Drehungswinkel in Grad.</param>
        <summary>Wendet die angegebene Drehung auf die Transformationsmatrix dieses <see cref="T:System.Drawing.Graphics" /> an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Drehungs Vorgang besteht aus der Multiplikation der Transformationsmatrix mit einer Matrix, deren Elemente `angle` vom-Parameter abgeleitet werden. Diese Methode wendet die Drehung an, indem Sie der Transformationsmatrix vorangestellt wird.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Übersetzt die World Transformation Matrix von Windows Form durch den Vektor (100, 0).  
  
-   Rotiert die Welt Transformation um einen Winkel von 30 Grad, wobei die Rotations Matrix der Transformationsmatrix der Welt vorangestellt wird.  
  
-   Zeichnet eine gedrehte, übersetzte Ellipse mit einem blauen Stift.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#149](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#149)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#149](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#149)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#149](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#149)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RotateTransform">
      <MemberSignature Language="C#" Value="public void RotateTransform (float angle, System.Drawing.Drawing2D.MatrixOrder order);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RotateTransform(float32 angle, valuetype System.Drawing.Drawing2D.MatrixOrder order) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.RotateTransform(System.Single,System.Drawing.Drawing2D.MatrixOrder)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RotateTransform (angle As Single, order As MatrixOrder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RotateTransform(float angle, System::Drawing::Drawing2D::MatrixOrder order);" />
      <MemberSignature Language="F#" Value="member this.RotateTransform : single * System.Drawing.Drawing2D.MatrixOrder -&gt; unit" Usage="graphics.RotateTransform (angle, order)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="angle" Type="System.Single" />
        <Parameter Name="order" Type="System.Drawing.Drawing2D.MatrixOrder" />
      </Parameters>
      <Docs>
        <param name="angle">Drehungswinkel in Grad.</param>
        <param name="order">Member der <see cref="T:System.Drawing.Drawing2D.MatrixOrder" />-Enumeration, der angibt, ob die Drehung an die Matrixtransformation angehängt oder dieser vorangestellt wird.</param>
        <summary>Wendet die angegebene Drehung auf die Transformationsmatrix dieses <see cref="T:System.Drawing.Graphics" /> in der angegebenen Reihenfolge an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Drehungs Vorgang besteht aus der Multiplikation der Transformationsmatrix mit einer Matrix, deren Elemente `angle` vom-Parameter abgeleitet werden. Diese Methode stellt der-Transformationsmatrix entsprechend dem <xref:System.Drawing.Graphics> `order` -Parameter einen vorangestellt oder fügt die Transformationsmatrix von der Rotations Matrix an.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Übersetzt die World Transformation Matrix von Windows Form durch den Vektor (100, 0).  
  
-   Rotiert die globale Transformation um einen Winkel von 30 Grad, wobei die Rotations Matrix an die Transformationsmatrix der Welt <xref:System.Drawing.Drawing2D.MatrixOrder.Append>mit angehängt wird.  
  
-   Zeichnet eine übersetzte, gedrehte Ellipse mit einem blauen Stift.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#150](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#150)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#150](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#150)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#150](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#150)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public System.Drawing.Drawing2D.GraphicsState Save ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Drawing.Drawing2D.GraphicsState Save() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.Save" />
      <MemberSignature Language="VB.NET" Value="Public Function Save () As GraphicsState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::Drawing2D::GraphicsState ^ Save();" />
      <MemberSignature Language="F#" Value="member this.Save : unit -&gt; System.Drawing.Drawing2D.GraphicsState" Usage="graphics.Save " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Drawing2D.GraphicsState</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Speichert den aktuellen Zustand dieses <see cref="T:System.Drawing.Graphics" /> und identifiziert den gespeicherten Zustand mit einem <see cref="T:System.Drawing.Drawing2D.GraphicsState" />.</summary>
        <returns>Diese Methode gibt einen <see cref="T:System.Drawing.Drawing2D.GraphicsState" /> zurück, der den gespeicherten Zustand dieses <see cref="T:System.Drawing.Graphics" /> darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie die <xref:System.Drawing.Graphics.Save%2A> -Methode <xref:System.Drawing.Graphics>eines aufzurufen, <xref:System.Drawing.Graphics> wird ein Informationsblock, der den Zustand von enthält, in einen Stapel eingefügt. Die <xref:System.Drawing.Graphics.Save%2A> -Methode gibt <xref:System.Drawing.Drawing2D.GraphicsState> einen zurück, der diesen Informationsblock identifiziert. <xref:System.Drawing.Drawing2D.GraphicsState> Wenn Sie das identifizierende an die <xref:System.Drawing.Graphics.Restore%2A> -Methode übergeben, wird der Informationsblock aus dem Stapel entfernt und verwendet, um die <xref:System.Drawing.Graphics> in dem Zustand wiederherzustellen, in dem <xref:System.Drawing.Graphics.Save%2A> Sie sich zum Zeitpunkt des Methoden Aufrufens befand. Beachten Sie, <xref:System.Drawing.Drawing2D.GraphicsState> dass der, der von einem gegebenen <xref:System.Drawing.Graphics.Save%2A> -Methoden Rückruf zurückgegeben wurde, nur <xref:System.Drawing.Graphics.Restore%2A> einmal an die-Methode übergeben werden kann.  
  
 Aufrufe der- <xref:System.Drawing.Graphics.Save%2A> Methode können mit einem anderen Aufruf erfolgen, d. h., <xref:System.Drawing.Graphics.Save%2A> Sie können die-Methode mehrmals aufrufen <xref:System.Drawing.Graphics.Restore%2A> , bevor Sie die-Methode aufrufen. Jedes Mal, wenn Sie <xref:System.Drawing.Graphics.Save%2A> die-Methode aufzurufen, wird ein Informationsblock in den Stapel eingefügt, <xref:System.Drawing.Drawing2D.GraphicsState> und Sie erhalten eine für den Informationsblock. Wenn Sie eines dieser Objekte <xref:System.Drawing.Graphics.Restore%2A> an die-Methode übergeben, wird die an den Zustand zurückgegeben, in dem Sie sich <xref:System.Drawing.Graphics.Save%2A> zum Zeitpunkt des Methoden Aufrufes befand <xref:System.Drawing.Drawing2D.GraphicsState>, der <xref:System.Drawing.Graphics> diese bestimmte zurückgegeben hat. Der Informationsblock, der durch diesen <xref:System.Drawing.Graphics.Save%2A> Methoden Anruf auf dem Stapel abgelegt wird, wird aus dem Stapel entfernt, und alle Informationsblöcke, die nach diesem <xref:System.Drawing.Graphics.Save%2A> Methoden Anruf auf diesem Stapel platziert werden, werden ebenfalls entfernt.  
  
 Aufrufe der <xref:System.Drawing.Graphics.BeginContainer%2A> -Methode platzieren Informationsblöcke auf demselben Stapel wie Aufrufe der <xref:System.Drawing.Graphics.Save%2A> -Methode. Ebenso wie ein <xref:System.Drawing.Graphics.Restore%2A> -Befehl mit einem <xref:System.Drawing.Graphics.Save%2A> -Befehl gekoppelt wird <xref:System.Drawing.Graphics.EndContainer%2A> , wird ein Methoden aufrufspaar einem <xref:System.Drawing.Graphics.BeginContainer%2A> Methoden aufzurufen.  
  
 <xref:System.Drawing.Graphics.Restore%2A> Wenn Sie die-Methode aufzurufen, werden alle Informationsblöcke, die auf dem <xref:System.Drawing.Graphics.Save%2A> Stapel abgelegt werden ( <xref:System.Drawing.Graphics.BeginContainer%2A> durch die-Methode oder die- <xref:System.Drawing.Graphics.Save%2A> Methode), nachdem der entsprechende aufrufungsaufrufungsmethode aus dem Stapel entfernt wurde. Ebenso <xref:System.Drawing.Graphics.EndContainer%2A> werden beim Abrufen der-Methode alle Informationsblöcke, die auf dem Stapel abgelegt werden (durch die <xref:System.Drawing.Graphics.Save%2A> -Methode <xref:System.Drawing.Graphics.BeginContainer%2A> oder die- <xref:System.Drawing.Graphics.BeginContainer%2A> Methode), nachdem der entsprechende aufrufungsaufrufder Methode aus dem Stapel entfernt wurde.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Übersetzt die Welt Transformation von Windows Form durch einen Vektor (100, 0).  
  
-   Speichert den Grafik Zustand des Formulars.  
  
-   Setzt die globale Transformation des Formulars auf eine Identität (2x2-Identitätsmatrix plus eine NULL Vektor Übersetzung) zurück und füllt ein Rechteck mit einem voll tonroten Pinsel.  
  
-   Stellt den übersetzten Grafik Zustand wieder her und füllt ein Rechteck mit einem Pinsel mit ausgefülltem blauen Pinsel.  
  
 Das Ergebnis ist ein nicht übersetztes, rot ausgefülltes Rechteck auf der linken Seite und ein über setztes blau auffülltes Rechteck auf der rechten Seite des Formulars.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#151](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#151)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#151](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#151)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#151](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#151)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ScaleTransform">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wendet die angegebene Skalierungsoperation auf die Transformationsmatrix dieses <see cref="T:System.Drawing.Graphics" /> an, indem diese der Transformationsmatrix des Objekts vorangestellt wird.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ScaleTransform">
      <MemberSignature Language="C#" Value="public void ScaleTransform (float sx, float sy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ScaleTransform(float32 sx, float32 sy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.ScaleTransform(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ScaleTransform (sx As Single, sy As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ScaleTransform(float sx, float sy);" />
      <MemberSignature Language="F#" Value="member this.ScaleTransform : single * single -&gt; unit" Usage="graphics.ScaleTransform (sx, sy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sx" Type="System.Single" />
        <Parameter Name="sy" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="sx">Skalierungsfaktor in der x-Richtung.</param>
        <param name="sy">Skalierungsfaktor in der y-Richtung.</param>
        <summary>Wendet die angegebene Skalierungsoperation auf die Transformationsmatrix dieses <see cref="T:System.Drawing.Graphics" /> an, indem diese der Transformationsmatrix des Objekts vorangestellt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Skalierungs Vorgang besteht aus der Multiplikation der Transformationsmatrix mit einer Diagonalen Matrix`sx`, `sy`deren Elemente (,, 1) sind. <xref:System.Drawing.Graphics> Mit dieser Methode wird die Transformationsmatrix von der Skalierungs Matrix vorangestellt.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Rotiert die World Transformation Matrix des Windows Forms um 30 Grad.  
  
-   Skaliert diese Matrix um den Faktor 3 in der x-Richtung und den Faktor 1 in der y-Richtung, indem die Skalierungs Transformation vorangestellt wird.  
  
-   Zeichnet ein skaliertes, gedrehtes Rechteck mit einem blauen Stift.  
  
 Das Ergebnis ist nach wie vor ein Rechteck.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#152](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#152)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#152](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#152)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#152](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#152)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScaleTransform">
      <MemberSignature Language="C#" Value="public void ScaleTransform (float sx, float sy, System.Drawing.Drawing2D.MatrixOrder order);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ScaleTransform(float32 sx, float32 sy, valuetype System.Drawing.Drawing2D.MatrixOrder order) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.ScaleTransform(System.Single,System.Single,System.Drawing.Drawing2D.MatrixOrder)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ScaleTransform (sx As Single, sy As Single, order As MatrixOrder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ScaleTransform(float sx, float sy, System::Drawing::Drawing2D::MatrixOrder order);" />
      <MemberSignature Language="F#" Value="member this.ScaleTransform : single * single * System.Drawing.Drawing2D.MatrixOrder -&gt; unit" Usage="graphics.ScaleTransform (sx, sy, order)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sx" Type="System.Single" />
        <Parameter Name="sy" Type="System.Single" />
        <Parameter Name="order" Type="System.Drawing.Drawing2D.MatrixOrder" />
      </Parameters>
      <Docs>
        <param name="sx">Skalierungsfaktor in der x-Richtung.</param>
        <param name="sy">Skalierungsfaktor in der y-Richtung.</param>
        <param name="order">Member der <see cref="T:System.Drawing.Drawing2D.MatrixOrder" />-Enumeration, der angibt, ob die Skalierungsoperation an die Transformationsmatrix angehängt oder dieser vorangestellt wird.</param>
        <summary>Wendet den angegebenen Skalierungsvorgang auf die Transformationsmatrix dieses <see cref="T:System.Drawing.Graphics" /> in der angegebenen Reihenfolge an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Skalierungs Vorgang besteht aus der Multiplikation der Transformationsmatrix mit einer Diagonalen Matrix`sx`, `sy`deren Elemente (,, 1) sind. Diese Methode stellt der Skalierungs Matrix entsprechend dem <xref:System.Drawing.Graphics> `order` -Parameter einen vorangestellt oder fügt die Transformationsmatrix von der Skalierungs Matrix hinzu.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Rotiert die World Transformation Matrix des Windows Forms um 30 Grad.  
  
-   Skaliert diese Matrix um den Faktor 3 in der x-Richtung und den Faktor 1 in der y-Richtung, indem die Skalierungs Transformation an <xref:System.Drawing.Drawing2D.MatrixOrder.Append> den Member angehängt wird.  
  
-   Zeichnet ein gedrehtes, skaliertes Rechteck mit einem blauen Stift.  
  
 Das Ergebnis ist ein Parallelogramm.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#153](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#153)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#153](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#153)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#153](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#153)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetClip">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Legt den Ausschneidebereich dieses <see cref="T:System.Drawing.Graphics" /> auf die <see langword="Clip" />-Eigenschaft des angegebenen <see cref="T:System.Drawing.Graphics" /> fest.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetClip">
      <MemberSignature Language="C#" Value="public void SetClip (System.Drawing.Drawing2D.GraphicsPath path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetClip(class System.Drawing.Drawing2D.GraphicsPath path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.SetClip(System.Drawing.Drawing2D.GraphicsPath)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetClip (path As GraphicsPath)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetClip(System::Drawing::Drawing2D::GraphicsPath ^ path);" />
      <MemberSignature Language="F#" Value="member this.SetClip : System.Drawing.Drawing2D.GraphicsPath -&gt; unit" Usage="graphics.SetClip path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.Drawing.Drawing2D.GraphicsPath" />
      </Parameters>
      <Docs>
        <param name="path"><see cref="T:System.Drawing.Drawing2D.GraphicsPath" />, der den neuen Ausschneidebereich darstellt.</param>
        <summary>Legt den Ausschneidebereich dieses <see cref="T:System.Drawing.Graphics" /> auf den angegebenen <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der durch den `path` -Parameter dargestellte Grafik Pfad nicht geschlossen wird, wird vom letzten Punkt zum ersten Punkt ein zusätzliches Segment hinzugefügt, um den Pfad zu schließen.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen Grafik Pfad und fügt dem Pfad eine Ellipse hinzu.  
  
-   Legt den Clippingbereich auf den elliptischen Pfad fest.  
  
-   Füllt ein großes Rechteck mit einem soliden schwarzen Pinsel.  
  
 Das Ergebnis ist eine gefüllte, schwarze Ellipse.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#154](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#154)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#154](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#154)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#154](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#154)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetClip">
      <MemberSignature Language="C#" Value="public void SetClip (System.Drawing.Graphics g);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetClip(class System.Drawing.Graphics g) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.SetClip(System.Drawing.Graphics)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetClip (g As Graphics)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetClip(System::Drawing::Graphics ^ g);" />
      <MemberSignature Language="F#" Value="member this.SetClip : System.Drawing.Graphics -&gt; unit" Usage="graphics.SetClip g" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="g" Type="System.Drawing.Graphics" />
      </Parameters>
      <Docs>
        <param name="g"><see cref="T:System.Drawing.Graphics" />, von dem der neue Ausschneidebereich übernommen werden soll.</param>
        <summary>Legt den Ausschneidebereich dieses <see cref="T:System.Drawing.Graphics" /> auf die <see langword="Clip" />-Eigenschaft des angegebenen <see cref="T:System.Drawing.Graphics" /> fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert <xref:System.Windows.Forms.PaintEventArgs>und erfordert `e`, ein Parameter des <xref:System.Windows.Forms.Control.Paint> <xref:System.Windows.Forms.Form> Ereignis Handlers sowie `thisForm`, für das Beispiel. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein temporäres <xref:System.Drawing.Graphics> aus `thisForm` dem <xref:System.Windows.Forms.Form> des Beispiels.  
  
-   Legt den Ausschneide Bereich des temporären <xref:System.Drawing.Graphics> auf ein kleines Quadrat fest.  
  
-   Aktualisiert den Ausschneide Bereich des Grafik Objekts des Formulars auf den des temporären <xref:System.Drawing.Graphics>.  
  
-   Füllt ein großes Rechteck mit einem soliden schwarzen Pinsel.  
  
 Das Ergebnis ist ein kleines, ausgefülltes, schwarzes Quadrat.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#156](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#156)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#156](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#156)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#156](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#156)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetClip">
      <MemberSignature Language="C#" Value="public void SetClip (System.Drawing.Rectangle rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetClip(valuetype System.Drawing.Rectangle rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.SetClip(System.Drawing.Rectangle)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetClip (rect As Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetClip(System::Drawing::Rectangle rect);" />
      <MemberSignature Language="F#" Value="member this.SetClip : System.Drawing.Rectangle -&gt; unit" Usage="graphics.SetClip rect" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="rect"><see cref="T:System.Drawing.Rectangle" />-Struktur, die den neuen Ausschneidebereich darstellt.</param>
        <summary>Legt den Ausschneidebereich dieses <see cref="T:System.Drawing.Graphics" /> auf das Rechteck fest, das durch eine <see cref="T:System.Drawing.Rectangle" />-Struktur angegeben wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein kleines Rechteck für den Clippingbereich.  
  
-   Legt den Clippingbereich auf das Rechteck fest.  
  
-   Füllt ein großes Rechteck mit einem soliden schwarzen Pinsel.  
  
 Das Ergebnis ist ein kleines, ausgefülltes, schwarzes Rechteck.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#158](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#158)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#158](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#158)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#158](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#158)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetClip">
      <MemberSignature Language="C#" Value="public void SetClip (System.Drawing.RectangleF rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetClip(valuetype System.Drawing.RectangleF rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.SetClip(System.Drawing.RectangleF)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetClip (rect As RectangleF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetClip(System::Drawing::RectangleF rect);" />
      <MemberSignature Language="F#" Value="member this.SetClip : System.Drawing.RectangleF -&gt; unit" Usage="graphics.SetClip rect" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.RectangleF" />
      </Parameters>
      <Docs>
        <param name="rect"><see cref="T:System.Drawing.RectangleF" />-Struktur, die den neuen Ausschneidebereich darstellt.</param>
        <summary>Legt den Ausschneidebereich dieses <see cref="T:System.Drawing.Graphics" /> auf das Rechteck fest, das durch eine <see cref="T:System.Drawing.RectangleF" />-Struktur angegeben wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein kleines Rechteck für den Clippingbereich.  
  
-   Legt den Clippingbereich auf das Rechteck fest.  
  
-   Füllt ein großes Rechteck mit einem soliden schwarzen Pinsel.  
  
 Das Ergebnis ist ein kleines, ausgefülltes, schwarzes Rechteck.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#160](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#160)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#160](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#160)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#160](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#160)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetClip">
      <MemberSignature Language="C#" Value="public void SetClip (System.Drawing.Drawing2D.GraphicsPath path, System.Drawing.Drawing2D.CombineMode combineMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetClip(class System.Drawing.Drawing2D.GraphicsPath path, valuetype System.Drawing.Drawing2D.CombineMode combineMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.SetClip(System.Drawing.Drawing2D.GraphicsPath,System.Drawing.Drawing2D.CombineMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetClip(System::Drawing::Drawing2D::GraphicsPath ^ path, System::Drawing::Drawing2D::CombineMode combineMode);" />
      <MemberSignature Language="F#" Value="member this.SetClip : System.Drawing.Drawing2D.GraphicsPath * System.Drawing.Drawing2D.CombineMode -&gt; unit" Usage="graphics.SetClip (path, combineMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.Drawing.Drawing2D.GraphicsPath" />
        <Parameter Name="combineMode" Type="System.Drawing.Drawing2D.CombineMode" />
      </Parameters>
      <Docs>
        <param name="path">Zu kombinierender <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</param>
        <param name="combineMode">Member der <see cref="T:System.Drawing.Drawing2D.CombineMode" />-Enumeration, der die zu verwendende Operation zum Kombinieren angibt.</param>
        <summary>Legt den Ausschneidebereich dieses <see cref="T:System.Drawing.Graphics" /> auf das Ergebnis des angegebenen Vorgangs fest, indem der aktuelle Ausschneidebereich und der angegebene <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> kombiniert werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der durch den `path` -Parameter dargestellte Grafik Pfad nicht geschlossen wird, wird vom letzten Punkt zum ersten Punkt ein zusätzliches Segment hinzugefügt, um den Pfad zu schließen.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen Grafik Pfad und fügt dem Pfad eine Ellipse hinzu.  
  
-   Legt den Clippingbereich auf den Ellipsen Pfad <xref:System.Drawing.Drawing2D.CombineMode.Replace> mit dem-Member fest.  
  
-   Füllt ein großes Rechteck mit einem soliden schwarzen Pinsel.  
  
 Das Ergebnis ist eine gefüllte, schwarze Ellipse.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#155](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#155)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#155](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#155)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#155](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#155)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetClip">
      <MemberSignature Language="C#" Value="public void SetClip (System.Drawing.Graphics g, System.Drawing.Drawing2D.CombineMode combineMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetClip(class System.Drawing.Graphics g, valuetype System.Drawing.Drawing2D.CombineMode combineMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.SetClip(System.Drawing.Graphics,System.Drawing.Drawing2D.CombineMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetClip(System::Drawing::Graphics ^ g, System::Drawing::Drawing2D::CombineMode combineMode);" />
      <MemberSignature Language="F#" Value="member this.SetClip : System.Drawing.Graphics * System.Drawing.Drawing2D.CombineMode -&gt; unit" Usage="graphics.SetClip (g, combineMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="g" Type="System.Drawing.Graphics" />
        <Parameter Name="combineMode" Type="System.Drawing.Drawing2D.CombineMode" />
      </Parameters>
      <Docs>
        <param name="g"><see cref="T:System.Drawing.Graphics" />, das den zu kombinierenden Ausschneidebereich angibt.</param>
        <param name="combineMode">Member der <see cref="T:System.Drawing.Drawing2D.CombineMode" />-Enumeration, der die zu verwendende Operation zum Kombinieren angibt.</param>
        <summary>Legt den Ausschneidebereich dieses <see cref="T:System.Drawing.Graphics" /> auf das Ergebnis der angegebenen Kombinierung des aktuellen Ausschneidebereichs und der <see cref="P:System.Drawing.Graphics.Clip" />-Eigenschaft des angegebenen <see cref="T:System.Drawing.Graphics" /> fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert <xref:System.Windows.Forms.PaintEventArgs>und erfordert `e`, ein Parameter des <xref:System.Windows.Forms.Control.Paint> <xref:System.Windows.Forms.Form> Ereignis Handlers sowie `thisForm`, für das Beispiel. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein temporäres <xref:System.Drawing.Graphics> aus `thisForm` dem <xref:System.Windows.Forms.Form> des Beispiels.  
  
-   Legt den Ausschneide Bereich des temporären <xref:System.Drawing.Graphics> auf ein kleines Quadrat fest.  
  
-   Aktualisiert den Clippingbereich des Grafik Objekts des Formulars auf den des neuen <xref:System.Drawing.Graphics> mit dem <xref:System.Drawing.Drawing2D.CombineMode.Replace> -Member.  
  
-   Füllt ein großes Rechteck mit einem soliden schwarzen Pinsel.  
  
 Das Ergebnis ist ein kleines, ausgefülltes, schwarzes Quadrat.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#157](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#157)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#157](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#157)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#157](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#157)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetClip">
      <MemberSignature Language="C#" Value="public void SetClip (System.Drawing.Rectangle rect, System.Drawing.Drawing2D.CombineMode combineMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetClip(valuetype System.Drawing.Rectangle rect, valuetype System.Drawing.Drawing2D.CombineMode combineMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.SetClip(System.Drawing.Rectangle,System.Drawing.Drawing2D.CombineMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetClip(System::Drawing::Rectangle rect, System::Drawing::Drawing2D::CombineMode combineMode);" />
      <MemberSignature Language="F#" Value="member this.SetClip : System.Drawing.Rectangle * System.Drawing.Drawing2D.CombineMode -&gt; unit" Usage="graphics.SetClip (rect, combineMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
        <Parameter Name="combineMode" Type="System.Drawing.Drawing2D.CombineMode" />
      </Parameters>
      <Docs>
        <param name="rect">Zu kombinierende <see cref="T:System.Drawing.Rectangle" />-Struktur.</param>
        <param name="combineMode">Member der <see cref="T:System.Drawing.Drawing2D.CombineMode" />-Enumeration, der die zu verwendende Operation zum Kombinieren angibt.</param>
        <summary>Legt den Ausschneidebereich dieses <see cref="T:System.Drawing.Graphics" /> auf das Ergebnis des angegebenen Vorgangs fest, indem der aktuelle Ausschneidebereich und das Rechteck, das durch eine <see cref="T:System.Drawing.Rectangle" />-Struktur angegeben wird, kombiniert werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein kleines Rechteck für den Clippingbereich.  
  
-   Legt den Clippingbereich auf das Rechteck mit <xref:System.Drawing.Drawing2D.CombineMode.Replace> dem Element fest.  
  
-   Füllt ein großes Rechteck mit einem soliden schwarzen Pinsel.  
  
 Das Ergebnis ist ein kleines, ausgefülltes, schwarzes Rechteck.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#159](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#159)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#159](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#159)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#159](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#159)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetClip">
      <MemberSignature Language="C#" Value="public void SetClip (System.Drawing.RectangleF rect, System.Drawing.Drawing2D.CombineMode combineMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetClip(valuetype System.Drawing.RectangleF rect, valuetype System.Drawing.Drawing2D.CombineMode combineMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.SetClip(System.Drawing.RectangleF,System.Drawing.Drawing2D.CombineMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetClip(System::Drawing::RectangleF rect, System::Drawing::Drawing2D::CombineMode combineMode);" />
      <MemberSignature Language="F#" Value="member this.SetClip : System.Drawing.RectangleF * System.Drawing.Drawing2D.CombineMode -&gt; unit" Usage="graphics.SetClip (rect, combineMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.RectangleF" />
        <Parameter Name="combineMode" Type="System.Drawing.Drawing2D.CombineMode" />
      </Parameters>
      <Docs>
        <param name="rect">Zu kombinierende <see cref="T:System.Drawing.RectangleF" />-Struktur.</param>
        <param name="combineMode">Member der <see cref="T:System.Drawing.Drawing2D.CombineMode" />-Enumeration, der die zu verwendende Operation zum Kombinieren angibt.</param>
        <summary>Legt den Ausschneidebereich dieses <see cref="T:System.Drawing.Graphics" /> auf das Ergebnis des angegebenen Vorgangs fest, indem der aktuelle Ausschneidebereich und das Rechteck, das durch eine <see cref="T:System.Drawing.RectangleF" />-Struktur angegeben wird, kombiniert werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein kleines Rechteck für den Clippingbereich.  
  
-   Legt den Clippingbereich auf das Rechteck mit <xref:System.Drawing.Drawing2D.CombineMode.Replace> dem Element fest.  
  
-   Füllt ein großes Rechteck mit einem soliden schwarzen Pinsel.  
  
 Das Ergebnis ist ein kleines, ausgefülltes, schwarzes Rechteck.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#161](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#161)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#161](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#161)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#161](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#161)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetClip">
      <MemberSignature Language="C#" Value="public void SetClip (System.Drawing.Region region, System.Drawing.Drawing2D.CombineMode combineMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetClip(class System.Drawing.Region region, valuetype System.Drawing.Drawing2D.CombineMode combineMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.SetClip(System.Drawing.Region,System.Drawing.Drawing2D.CombineMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetClip(System::Drawing::Region ^ region, System::Drawing::Drawing2D::CombineMode combineMode);" />
      <MemberSignature Language="F#" Value="member this.SetClip : System.Drawing.Region * System.Drawing.Drawing2D.CombineMode -&gt; unit" Usage="graphics.SetClip (region, combineMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="region" Type="System.Drawing.Region" />
        <Parameter Name="combineMode" Type="System.Drawing.Drawing2D.CombineMode" />
      </Parameters>
      <Docs>
        <param name="region">Zu kombinierender <see cref="T:System.Drawing.Region" />.</param>
        <param name="combineMode">Member der <see cref="T:System.Drawing.Drawing2D.CombineMode" />-Enumeration, der die zu verwendende Operation zum Kombinieren angibt.</param>
        <summary>Legt den Ausschneidebereich dieses <see cref="T:System.Drawing.Graphics" /> auf das Ergebnis des angegebenen Vorgangs fest, indem der aktuelle Ausschneidebereich und der angegebene <see cref="T:System.Drawing.Region" /> kombiniert werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein kleines Rechteck für den Clippingbereich.  
  
-   Legt den Clippingbereich auf das Rechteck mit <xref:System.Drawing.Drawing2D.CombineMode.Replace> dem Element fest.  
  
-   Füllt ein großes Rechteck mit einem soliden schwarzen Pinsel.  
  
 Das Ergebnis ist ein kleines, ausgefülltes, schwarzes Rechteck.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#162](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#162)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#162](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#162)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#162](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#162)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SmoothingMode">
      <MemberSignature Language="C#" Value="public System.Drawing.Drawing2D.SmoothingMode SmoothingMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Drawing2D.SmoothingMode SmoothingMode" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Graphics.SmoothingMode" />
      <MemberSignature Language="VB.NET" Value="Public Property SmoothingMode As SmoothingMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Drawing2D::SmoothingMode SmoothingMode { System::Drawing::Drawing2D::SmoothingMode get(); void set(System::Drawing::Drawing2D::SmoothingMode value); };" />
      <MemberSignature Language="F#" Value="member this.SmoothingMode : System.Drawing.Drawing2D.SmoothingMode with get, set" Usage="System.Drawing.Graphics.SmoothingMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Drawing2D.SmoothingMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Renderqualität für dieses <see cref="T:System.Drawing.Graphics" /> ab, oder legt diese fest.</summary>
        <value>Einer der <see cref="T:System.Drawing.Drawing2D.SmoothingMode" />-Werte.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Glättungs Modus gibt an, ob Linien, Kurven und Ränder von gefüllten Bereichen Glättung (auch als Antialiasing bezeichnet) verwenden. Eine Ausnahme ist, dass die Pfad Farbverlaufs Pinsel den Glättungs Modus nicht einhalten. Bereiche, die mit <xref:System.Drawing.Drawing2D.PathGradientBrush> einem ausgefüllt werden, werden unabhängig von der <xref:System.Drawing.Graphics.SmoothingMode%2A> -Eigenschaft auf die gleiche Weise (Alias) gerendert.  
  
   
  
## Examples  
 Die folgende Methode veranschaulicht die Auswirkungen der Festlegung <xref:System.Drawing.Pen.DashCap%2A>der <xref:System.Drawing.Pen.DashPattern%2A>Eigenschaften, <xref:System.Drawing.Graphics.SmoothingMode%2A> und. Die Ausgabe des Beispiels ist in der folgenden Abbildung dargestellt.  
  
 ![Zeilen mit und ohne Glättung werden angewendet.] (~/add/media/gdi-smoothingmode.png "Zeilen mit und ohne Glättung werden angewendet.")  
  
 Dieses Beispiel ist für die Verwendung mit Windows Forms konzipiert. Fügen Sie den Code in ein Formular ein, `ShowPensAndSmoothingMode` und nennen Sie die-Methode <xref:System.Windows.Forms.Control.Paint> , wenn Sie das <xref:System.Windows.Forms.PaintEventArgs>-Ereignis des Formulars verarbeiten und als übergeben `e` .  
  
 [!code-cpp[System.Drawing.PensExample#3](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.PensExample/CPP/form1.cpp#3)]
 [!code-csharp[System.Drawing.PensExample#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.PensExample/CS/form1.cs#3)]
 [!code-vb[System.Drawing.PensExample#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.PensExample/VB/form1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextContrast">
      <MemberSignature Language="C#" Value="public int TextContrast { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 TextContrast" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Graphics.TextContrast" />
      <MemberSignature Language="VB.NET" Value="Public Property TextContrast As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int TextContrast { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.TextContrast : int with get, set" Usage="System.Drawing.Graphics.TextContrast" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Gammakorrekturwert für die Darstellung von Text ab oder legt diesen fest.</summary>
        <value>Der Gammakorrekturwert, der für das Rendern von Anitaliasing- und ClearType-Text verwendet wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Gammakorrektur Wert muss zwischen 0 und 12 liegen. Der Standardwert ist 4.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung <xref:System.Drawing.Graphics.TextRenderingHint%2A> der-Eigenschaft und der- <xref:System.Drawing.Graphics.TextContrast%2A> Eigenschaft veranschaulicht.  
  
 Dieses Beispiel ist für die Verwendung mit Windows Forms konzipiert. Fügen Sie den Code in ein Formular ein, `ChangeTextRenderingHintAndTextContrast` und nennen Sie die-Methode <xref:System.Windows.Forms.Control.Paint> , wenn Sie das <xref:System.Windows.Forms.PaintEventArgs>-Ereignis des Formulars verarbeiten und als übergeben `e` .  
  
 [!code-cpp[System.Drawing.GraphicsProperties#5](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.GraphicsProperties/CPP/form1.cpp#5)]
 [!code-csharp[System.Drawing.GraphicsProperties#5](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.GraphicsProperties/CS/form1.cs#5)]
 [!code-vb[System.Drawing.GraphicsProperties#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.GraphicsProperties/VB/form1.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextRenderingHint">
      <MemberSignature Language="C#" Value="public System.Drawing.Text.TextRenderingHint TextRenderingHint { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Text.TextRenderingHint TextRenderingHint" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Graphics.TextRenderingHint" />
      <MemberSignature Language="VB.NET" Value="Public Property TextRenderingHint As TextRenderingHint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Text::TextRenderingHint TextRenderingHint { System::Drawing::Text::TextRenderingHint get(); void set(System::Drawing::Text::TextRenderingHint value); };" />
      <MemberSignature Language="F#" Value="member this.TextRenderingHint : System.Drawing.Text.TextRenderingHint with get, set" Usage="System.Drawing.Graphics.TextRenderingHint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Text.TextRenderingHint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Renderingmodus für Text ab, der diesem <see cref="T:System.Drawing.Graphics" /> zugeordnet ist, oder legt diesen fest.</summary>
        <value>Einer der <see cref="T:System.Drawing.Text.TextRenderingHint" />-Werte.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Text Rendering-Hinweis gibt an, ob Text mit Antialiasing gerendert wird.  
  
> [!NOTE]
>  Sie sollten den <xref:System.Drawing.Graphics.CompositingMode%2A> -Eigenschafts <xref:System.Drawing.Drawing2D.CompositingMode.SourceCopy> Wert nicht verwenden, <xref:System.Drawing.Graphics.TextRenderingHint%2A> wenn die-Eigenschaft <xref:System.Drawing.Text.TextRenderingHint.ClearTypeGridFit>auf festgelegt ist. Eine Ausnahme kann auftreten, oder das Bild wird möglicherweise nicht ordnungsgemäß wiedergegeben.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung <xref:System.Drawing.Graphics.TextRenderingHint%2A> der-Eigenschaft und der- <xref:System.Drawing.Graphics.TextContrast%2A> Eigenschaft veranschaulicht.  
  
 Dieses Beispiel ist für die Verwendung mit Windows Forms konzipiert. Fügen Sie den Code in ein Formular ein, `ChangeTextRenderingHintAndTextContrast` und nennen Sie die-Methode <xref:System.Windows.Forms.Control.Paint> , wenn Sie das <xref:System.Windows.Forms.PaintEventArgs>-Ereignis des Formulars verarbeiten und als übergeben `e` .  
  
 [!code-cpp[System.Drawing.GraphicsProperties#5](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.GraphicsProperties/CPP/form1.cpp#5)]
 [!code-csharp[System.Drawing.GraphicsProperties#5](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.GraphicsProperties/CS/form1.cs#5)]
 [!code-vb[System.Drawing.GraphicsProperties#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.GraphicsProperties/VB/form1.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Transform">
      <MemberSignature Language="C#" Value="public System.Drawing.Drawing2D.Matrix Transform { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Drawing2D.Matrix Transform" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Graphics.Transform" />
      <MemberSignature Language="VB.NET" Value="Public Property Transform As Matrix" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Drawing2D::Matrix ^ Transform { System::Drawing::Drawing2D::Matrix ^ get(); void set(System::Drawing::Drawing2D::Matrix ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Transform : System.Drawing.Drawing2D.Matrix with get, set" Usage="System.Drawing.Graphics.Transform" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Drawing2D.Matrix</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Kopie der geometrischen globalen Transformation für dieses <see cref="T:System.Drawing.Graphics" /> ab oder legt diese fest.</summary>
        <value>Eine Kopie von <see cref="T:System.Drawing.Drawing2D.Matrix" />, die die geometrische globale Transformation für dieses <see cref="T:System.Drawing.Graphics" /> darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 GDI+ verwendet drei Koordinaten Bereiche: "World", "page" und "Device". Globale Koordinaten sind die Koordinaten, die verwendet werden, um eine bestimmte Grafik Welt zu modellieren, und sind die Koordinaten, die Sie an Methoden in der .NET Framework übergeben. Seiten Koordinaten verweisen auf das Koordinatensystem, das von einer Zeichen Oberfläche verwendet wird, z. b. ein Formular oder ein Steuerelement. Geräte Koordinaten sind die Koordinaten, die vom physischen Gerät verwendet werden, auf dem Sie gezeichnet werden, z. b. ein Bildschirm oder ein Drucker. Die <xref:System.Drawing.Graphics.Transform%2A> -Eigenschaft stellt die World-Transformation dar, die globale Koordinaten zu Seiten Koordinaten zuordnet.  
  
 Da die von der <xref:System.Drawing.Graphics.Transform%2A> -Eigenschaft zurückgegebene Matrix eine Kopie der geometrischen Transformation ist, sollten Sie die Matrix verwerfen, wenn Sie Sie nicht mehr benötigen.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/c61ff50a-eb1d-4e6c-83cd-f7e9764cfa9f">Typen von Koordinatensystemen</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TransformPoints">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Transformiert ein Array von Punkten unter Verwendung der aktuellen globalen Transformation und der Seitentransformation dieses <see cref="T:System.Drawing.Graphics" /> aus einem Koordinatenbereich in einen anderen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TransformPoints">
      <MemberSignature Language="C#" Value="public void TransformPoints (System.Drawing.Drawing2D.CoordinateSpace destSpace, System.Drawing.Drawing2D.CoordinateSpace srcSpace, System.Drawing.Point[] pts);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransformPoints(valuetype System.Drawing.Drawing2D.CoordinateSpace destSpace, valuetype System.Drawing.Drawing2D.CoordinateSpace srcSpace, valuetype System.Drawing.Point[] pts) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.TransformPoints(System.Drawing.Drawing2D.CoordinateSpace,System.Drawing.Drawing2D.CoordinateSpace,System.Drawing.Point[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransformPoints (destSpace As CoordinateSpace, srcSpace As CoordinateSpace, pts As Point())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransformPoints(System::Drawing::Drawing2D::CoordinateSpace destSpace, System::Drawing::Drawing2D::CoordinateSpace srcSpace, cli::array &lt;System::Drawing::Point&gt; ^ pts);" />
      <MemberSignature Language="F#" Value="member this.TransformPoints : System.Drawing.Drawing2D.CoordinateSpace * System.Drawing.Drawing2D.CoordinateSpace * System.Drawing.Point[] -&gt; unit" Usage="graphics.TransformPoints (destSpace, srcSpace, pts)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destSpace" Type="System.Drawing.Drawing2D.CoordinateSpace" />
        <Parameter Name="srcSpace" Type="System.Drawing.Drawing2D.CoordinateSpace" />
        <Parameter Name="pts" Type="System.Drawing.Point[]" />
      </Parameters>
      <Docs>
        <param name="destSpace">Member der <see cref="T:System.Drawing.Drawing2D.CoordinateSpace" />-Enumeration, der den Zielkoordinatenbereich angibt.</param>
        <param name="srcSpace">Member der <see cref="T:System.Drawing.Drawing2D.CoordinateSpace" />-Enumeration, der den Quellkoordinatenbereich angibt.</param>
        <param name="pts">Array von <see cref="T:System.Drawing.Point" />-Strukturen, die die zu transformierenden Punkte darstellen.</param>
        <summary>Transformiert ein Array von Punkten unter Verwendung der aktuellen globalen Transformation und der Seitentransformation dieses <see cref="T:System.Drawing.Graphics" /> aus einem Koordinatenbereich in einen anderen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt zwei Punkte und zeichnet eine blaue Linie zwischen Ihnen.  
  
-   Legt die globale Transformation so fest, dass Sie durch Beträge 40 in der x-Richtung und 30 in der y-Richtung übersetzt wird.  
  
-   Transformiert die Punkte von den Weltkoordinaten<xref:System.Drawing.Drawing2D.CoordinateSpace.World>() in Seiten Koordinaten<xref:System.Drawing.Drawing2D.CoordinateSpace.Page>().  
  
-   Setzt die Welt Transformation auf die Identität zurück.  
  
-   Zeichnet eine rote Linie zwischen den transformierten Punkten.  
  
 Das Ergebnis ist eine blaue Linie und eine übersetzte rote Linie darunter.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#163](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#163)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#163](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#163)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#163](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#163)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TransformPoints">
      <MemberSignature Language="C#" Value="public void TransformPoints (System.Drawing.Drawing2D.CoordinateSpace destSpace, System.Drawing.Drawing2D.CoordinateSpace srcSpace, System.Drawing.PointF[] pts);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransformPoints(valuetype System.Drawing.Drawing2D.CoordinateSpace destSpace, valuetype System.Drawing.Drawing2D.CoordinateSpace srcSpace, valuetype System.Drawing.PointF[] pts) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.TransformPoints(System.Drawing.Drawing2D.CoordinateSpace,System.Drawing.Drawing2D.CoordinateSpace,System.Drawing.PointF[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransformPoints (destSpace As CoordinateSpace, srcSpace As CoordinateSpace, pts As PointF())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransformPoints(System::Drawing::Drawing2D::CoordinateSpace destSpace, System::Drawing::Drawing2D::CoordinateSpace srcSpace, cli::array &lt;System::Drawing::PointF&gt; ^ pts);" />
      <MemberSignature Language="F#" Value="member this.TransformPoints : System.Drawing.Drawing2D.CoordinateSpace * System.Drawing.Drawing2D.CoordinateSpace * System.Drawing.PointF[] -&gt; unit" Usage="graphics.TransformPoints (destSpace, srcSpace, pts)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destSpace" Type="System.Drawing.Drawing2D.CoordinateSpace" />
        <Parameter Name="srcSpace" Type="System.Drawing.Drawing2D.CoordinateSpace" />
        <Parameter Name="pts" Type="System.Drawing.PointF[]" />
      </Parameters>
      <Docs>
        <param name="destSpace">Member der <see cref="T:System.Drawing.Drawing2D.CoordinateSpace" />-Enumeration, der den Zielkoordinatenbereich angibt.</param>
        <param name="srcSpace">Member der <see cref="T:System.Drawing.Drawing2D.CoordinateSpace" />-Enumeration, der den Quellkoordinatenbereich angibt.</param>
        <param name="pts">Array von <see cref="T:System.Drawing.PointF" />-Strukturen, die die zu transformierenden Punkte darstellen.</param>
        <summary>Transformiert ein Array von Punkten unter Verwendung der aktuellen globalen Transformation und der Seitentransformation dieses <see cref="T:System.Drawing.Graphics" /> aus einem Koordinatenbereich in einen anderen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt zwei Punkte und zeichnet eine blaue Linie zwischen Ihnen.  
  
-   Legt die globale Transformation so fest, dass Sie durch Beträge 40 in der x-Richtung und 30 in der y-Richtung übersetzt wird.  
  
-   Transformiert die Punkte von den Weltkoordinaten<xref:System.Drawing.Drawing2D.CoordinateSpace.World>() in Seiten Koordinaten<xref:System.Drawing.Drawing2D.CoordinateSpace.Page>().  
  
-   Setzt die Welt Transformation auf die Identität zurück und zeichnet eine rote Linie zwischen den transformierten Punkten.  
  
 Das Ergebnis ist eine blaue Linie und eine übersetzte rote Linie darunter.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#164](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#164)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#164](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#164)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#164](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#164)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TranslateClip">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Verschiebt den Ausschneidebereich dieses <see cref="T:System.Drawing.Graphics" /> horizontal und vertikal um die angegebenen Werte.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TranslateClip">
      <MemberSignature Language="C#" Value="public void TranslateClip (int dx, int dy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TranslateClip(int32 dx, int32 dy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.TranslateClip(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TranslateClip (dx As Integer, dy As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TranslateClip(int dx, int dy);" />
      <MemberSignature Language="F#" Value="member this.TranslateClip : int * int -&gt; unit" Usage="graphics.TranslateClip (dx, dy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dx" Type="System.Int32" />
        <Parameter Name="dy" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dx">Die x-Koordinate der Verschiebung.</param>
        <param name="dy">Die y-Koordinate der Verschiebung.</param>
        <summary>Verschiebt den Ausschneidebereich dieses <see cref="T:System.Drawing.Graphics" /> horizontal und vertikal um die angegebenen Werte.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein Rechteck für den Clippingbereich.  
  
-   Legt den Clippingbereich auf das Rechteck fest.  
  
-   Übersetzt den Clippingbereich durch einen Vektor (50, 50).  
  
-   Füllt ein großes Rechteck mit einem soliden schwarzen Pinsel.  
  
 Das Ergebnis ist ein übersetzt, kleines, schwarzes Rechteck.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#165](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#165)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#165](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#165)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#165](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#165)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TranslateClip">
      <MemberSignature Language="C#" Value="public void TranslateClip (float dx, float dy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TranslateClip(float32 dx, float32 dy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.TranslateClip(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TranslateClip (dx As Single, dy As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TranslateClip(float dx, float dy);" />
      <MemberSignature Language="F#" Value="member this.TranslateClip : single * single -&gt; unit" Usage="graphics.TranslateClip (dx, dy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dx" Type="System.Single" />
        <Parameter Name="dy" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="dx">Die x-Koordinate der Verschiebung.</param>
        <param name="dy">Die y-Koordinate der Verschiebung.</param>
        <summary>Verschiebt den Ausschneidebereich dieses <see cref="T:System.Drawing.Graphics" /> horizontal und vertikal um die angegebenen Werte.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein Rechteck für den Clippingbereich.  
  
-   Legt den Clippingbereich auf das Rechteck fest.  
  
-   Übersetzt den Clippingbereich durch einen Vektor (50,0 f, 50,0 f).  
  
-   Füllt ein großes Rechteck mit einem soliden schwarzen Pinsel.  
  
 Das Ergebnis ist ein übersetzt, kleines, schwarzes Rechteck.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#166](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#166)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#166](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#166)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#166](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#166)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TranslateTransform">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ändert den Ursprung der Koordinaten, indem die angegebene Verschiebung der Transformationsmatrix dieses <see cref="T:System.Drawing.Graphics" /> vorangestellt wird.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TranslateTransform">
      <MemberSignature Language="C#" Value="public void TranslateTransform (float dx, float dy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TranslateTransform(float32 dx, float32 dy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.TranslateTransform(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TranslateTransform (dx As Single, dy As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TranslateTransform(float dx, float dy);" />
      <MemberSignature Language="F#" Value="member this.TranslateTransform : single * single -&gt; unit" Usage="graphics.TranslateTransform (dx, dy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dx" Type="System.Single" />
        <Parameter Name="dy" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="dx">Die x-Koordinate der Verschiebung.</param>
        <param name="dy">Die y-Koordinate der Verschiebung.</param>
        <summary>Ändert den Ursprung der Koordinaten, indem die angegebene Verschiebung der Transformationsmatrix dieses <see cref="T:System.Drawing.Graphics" /> vorangestellt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Ursprung ist in der Regel die linke obere Ecke der Zeichen Oberfläche.  Der Übersetzungs Vorgang besteht aus der Multiplikation der Transformationsmatrix mit einer Matrix, deren Übersetzungs `dx` Teil `dy` dem-Parameter und dem-Parameter entspricht. Diese Methode wendet die Übersetzung an, indem die Übersetzungs Matrix der Transformationsmatrix vorangestellt wird.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Rotiert die World Transformation Matrix des Windows Forms um 30,0 f Grad.  
  
-   Verschiebt den Ursprung des Grafik Objekts, indem aufgerufen <xref:System.Drawing.Graphics.TranslateTransform%2A>wird, wobei die Übersetzung der Transformationsmatrix vorangestellt wird.  
  
-   Zeichnet eine übersetzte, gedrehte Ellipse mit einem blauen Stift.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#167](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#167)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#167](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#167)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#167](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#167)]  
  
 Die folgende Abbildung zeigt die Ausgabe der Ausführung des vorherigen Code Beispiels.  
  
 Über ![setzte und transformierte Ellipse] Über (~/add/media/ndp-tranlatetransform.png "setzte und transformierte Ellipse")  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/9fef7451-bddf-4c68-9350-400d1f1f25a3">Koordinatensysteme und Transformationen</related>
        <related type="Article" href="https://msdn.microsoft.com/library/1f8e18d3-d2f5-460e-a8e3-2da891c301de">Verwenden von Transformationen in Managed GDI+</related>
      </Docs>
    </Member>
    <Member MemberName="TranslateTransform">
      <MemberSignature Language="C#" Value="public void TranslateTransform (float dx, float dy, System.Drawing.Drawing2D.MatrixOrder order);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TranslateTransform(float32 dx, float32 dy, valuetype System.Drawing.Drawing2D.MatrixOrder order) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.TranslateTransform(System.Single,System.Single,System.Drawing.Drawing2D.MatrixOrder)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TranslateTransform (dx As Single, dy As Single, order As MatrixOrder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TranslateTransform(float dx, float dy, System::Drawing::Drawing2D::MatrixOrder order);" />
      <MemberSignature Language="F#" Value="member this.TranslateTransform : single * single * System.Drawing.Drawing2D.MatrixOrder -&gt; unit" Usage="graphics.TranslateTransform (dx, dy, order)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dx" Type="System.Single" />
        <Parameter Name="dy" Type="System.Single" />
        <Parameter Name="order" Type="System.Drawing.Drawing2D.MatrixOrder" />
      </Parameters>
      <Docs>
        <param name="dx">Die x-Koordinate der Verschiebung.</param>
        <param name="dy">Die y-Koordinate der Verschiebung.</param>
        <param name="order">Member der <see cref="T:System.Drawing.Drawing2D.MatrixOrder" />-Enumeration, der angibt, ob die Verschiebung an die Transformationsmatrix angehängt oder dieser vorangestellt wird.</param>
        <summary>Ändert den Ursprung des Koordinatensystems, indem die angegebene Verschiebung zur Transformationsmatrix dieses <see cref="T:System.Drawing.Graphics" /> in der angegebenen Reihenfolge angewendet wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Übersetzungs Vorgang besteht aus der Multiplikation der Transformationsmatrix mit einer Matrix, deren Übersetzungs `dx` Teil `dy` dem-Parameter und dem-Parameter entspricht. Diese Methode stellt die Transformationsmatrix von <xref:System.Drawing.Graphics> der Übersetzungs Matrix entsprechend dem `order` -Parameter voran oder fügt Sie an.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, wobei es sich um einen Parameter des <xref:System.Windows.Forms.Control.Paint> -Ereignis Handlers handelt. Der Code führt die folgenden Aktionen aus:  
  
-   Rotiert die World Transformation Matrix des Windows Forms um 30,0 f Grad.  
  
-   Verschiebt den Ursprung des Grafik Objekts durch Aufrufen <xref:System.Drawing.Graphics.TranslateTransform%2A>von, wobei die Übersetzung an die Transformationsmatrix der Welt angehängt wird.  
  
-   Zeichnet eine gedrehte, übersetzte Ellipse mit einem blauen Stift.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#168](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#168)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#168](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#168)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#168](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#168)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/9fef7451-bddf-4c68-9350-400d1f1f25a3">Koordinatensysteme und Transformationen</related>
        <related type="Article" href="https://msdn.microsoft.com/library/1f8e18d3-d2f5-460e-a8e3-2da891c301de">Verwenden von Transformationen in Managed GDI+</related>
      </Docs>
    </Member>
    <Member MemberName="VisibleClipBounds">
      <MemberSignature Language="C#" Value="public System.Drawing.RectangleF VisibleClipBounds { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.RectangleF VisibleClipBounds" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Graphics.VisibleClipBounds" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property VisibleClipBounds As RectangleF" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::RectangleF VisibleClipBounds { System::Drawing::RectangleF get(); };" />
      <MemberSignature Language="F#" Value="member this.VisibleClipBounds : System.Drawing.RectangleF" Usage="System.Drawing.Graphics.VisibleClipBounds" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.RectangleF</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das umschließende Rechteck des sichtbaren Ausschneidebereichs dieses <see cref="T:System.Drawing.Graphics" /> ab.</summary>
        <value>Eine <see cref="T:System.Drawing.RectangleF" />-Struktur, die ein umschließendes Rechteck für den sichtbaren Ausschneidebereich dieses <see cref="T:System.Drawing.Graphics" /> darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Einheit für das resultierende Rechteck wird von der <xref:System.Drawing.Graphics.PageUnit%2A> -Eigenschaft bestimmt. Die Standardeinheit ist Pixel. Ein <xref:System.Drawing.Graphics> ist in der Regel mit einem-Steuerelement verknüpft, und der Ursprung des Rechtecks ist relativ zum Client Bereich des Steuer Elements.  
  
 Der sichtbare Ausschneide Bereich ist die Schnittmenge des Clippingbereichs dieses <xref:System.Drawing.Graphics> und des Clippingbereichs des Fensters.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
