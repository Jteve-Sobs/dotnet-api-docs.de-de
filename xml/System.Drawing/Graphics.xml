<Type Name="Graphics" FullName="System.Drawing.Graphics">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="b0944419571131264e1f8f0a3e873aa975d078a8" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52255574" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Graphics : MarshalByRefObject, IDisposable, System.Drawing.IDeviceContext" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Graphics extends System.MarshalByRefObject implements class System.Drawing.IDeviceContext, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Drawing.Graphics" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Graphics&#xA;Inherits MarshalByRefObject&#xA;Implements IDeviceContext, IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Graphics sealed : MarshalByRefObject, IDisposable, System::Drawing::IDeviceContext" />
  <TypeSignature Language="F#" Value="type Graphics = class&#xA;    inherit MarshalByRefObject&#xA;    interface IDisposable&#xA;    interface IDeviceContext" />
  <AssemblyInfo>
    <AssemblyName>System.Drawing</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Drawing.Common</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Drawing.IDeviceContext</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Kapselt eine GDI+-Zeichenoberfläche. Diese Klasse kann nicht vererbt werden.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Drawing.Graphics> -Klasse stellt Methoden zum Zeichnen von Objekten auf dem Anzeigegerät bereit. Ein <xref:System.Drawing.Graphics> mit einem bestimmten Gerätekontext zugeordnet ist.  
  
 Sie erhalten eine <xref:System.Drawing.Graphics> -Objekt durch Aufrufen der <xref:System.Windows.Forms.Control.CreateGraphics%2A?displayProperty=nameWithType> Methode für ein Objekt, das von erbt <xref:System.Windows.Forms.Control?displayProperty=nameWithType>, oder durch das Behandeln eines Steuerelements <xref:System.Windows.Forms.Control.Paint?displayProperty=nameWithType> Ereignis und den Zugriff auf die <xref:System.Windows.Forms.PaintEventArgs.Graphics%2A> Eigenschaft der <xref:System.Windows.Forms.PaintEventArgs?displayProperty=nameWithType> Klasse. Sie können auch erstellen, eine <xref:System.Drawing.Graphics> Objekt aus einem Image mithilfe der <xref:System.Drawing.Graphics.FromImage%2A> Methode. Weitere Informationen zum Erstellen einer <xref:System.Drawing.Graphics> Objekt, finden Sie unter [Vorgehensweise: Erstellen von Grafikobjekten zum Zeichnen](~/docs/framework/winforms/advanced/how-to-create-graphics-objects-for-drawing.md).  
  
 Sie können viele verschiedene Formen und Linien zeichnen, mithilfe einer <xref:System.Drawing.Graphics> Objekt. Weitere Informationen über das Zeichnen von Linien und Formen finden Sie in der entsprechenden `Draw` *Grafikelement* -Methode für die Linie oder Form, die Sie zeichnen möchten. Dazu gehören das <xref:System.Drawing.Graphics.DrawLine%2A>, <xref:System.Drawing.Graphics.DrawArc%2A>, <xref:System.Drawing.Graphics.DrawClosedCurve%2A>, <xref:System.Drawing.Graphics.DrawPolygon%2A>, und <xref:System.Drawing.Graphics.DrawRectangle%2A>. Weitere Informationen über das Zeichnen von Linien und Formen finden Sie unter [Verwenden eines Stiftes zum Zeichnen von Linien und Formen](~/docs/framework/winforms/advanced/using-a-pen-to-draw-lines-and-shapes.md) und [Verwenden eines Pinsels zum Ausfüllen von Formen](~/docs/framework/winforms/advanced/using-a-brush-to-fill-shapes.md).  
  
 Sie können auch die Bilder und Symbole zeichnen, mit der <xref:System.Drawing.Graphics.DrawImage%2A> und <xref:System.Drawing.Graphics.DrawIcon%2A> Methoden bzw. Zum Ausführen von einen Bitblocktransfer der Farbdaten vom Bildschirm auf die Zeichenoberfläche des der <xref:System.Drawing.Graphics> Objekt, finden Sie unter <xref:System.Drawing.Graphics.CopyFromScreen%2A>. Weitere Informationen über das Zeichnen von Bildern mit einer <xref:System.Drawing.Graphics> Objekt, finden Sie unter [arbeiten mit Bildern, Bitmaps, Symbolen und Metadateien](~/docs/framework/winforms/advanced/working-with-images-bitmaps-icons-and-metafiles.md).  
  
 Darüber hinaus können Sie das Koordinatensystem, die verwendet werden, durch Ändern der <xref:System.Drawing.Graphics> Objekt. Weitere Informationen zu das Koordinatensystem und wie Sie es bearbeiten, finden Sie unter [Koordinatensysteme und Transformationen](~/docs/framework/winforms/advanced/coordinate-systems-and-transformations.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms vorgesehen und erfordert eine <xref:System.Windows.Forms.PaintEventArgs> Objekt. Die <xref:System.Windows.Forms.PaintEventArgs> Objekt mit dem Namen `e` und einen Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein Image aus einem JPEG-Datei an. Die Datei heißt SampImag.jpg und befindet sich im Ordner "des Beispiels".  
  
-   Erstellt einen Punkt, an dem der oberen linken Ecke des Bilds gezeichnet werden soll.  
  
-   Zeichnet das Bild auf dem Bildschirm mit einer <xref:System.Drawing.Graphics> Objekt.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#40](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#40)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#40](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#40)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#40](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#40)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="https://msdn.microsoft.com/library/162861f9-f050-445e-8abb-b2c43a918b8b">Gewusst wie: Erstellen von Graphics-Objekten zum Zeichnen</related>
    <related type="Article" href="https://msdn.microsoft.com/library/eb0f6d6f-9e52-4167-9592-ff4b82fb5869">Erste Schritte mit der Grafikprogrammierung</related>
    <related type="Article" href="https://msdn.microsoft.com/library/6207cad1-7a34-4bd6-bfc1-db823ca7a73e">Verwalten des Zustands eines Graphics-Objekts</related>
  </Docs>
  <Members>
    <Member MemberName="AddMetafileComment">
      <MemberSignature Language="C#" Value="public void AddMetafileComment (byte[] data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddMetafileComment(unsigned int8[] data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.AddMetafileComment(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddMetafileComment (data As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddMetafileComment(cli::array &lt;System::Byte&gt; ^ data);" />
      <MemberSignature Language="F#" Value="member this.AddMetafileComment : byte[] -&gt; unit" Usage="graphics.AddMetafileComment data" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="data">Bytearray, das den Kommentar enthält.</param>
        <summary>Fügt der aktuellen <see cref="T:System.Drawing.Imaging.Metafile" /> einen Kommentar hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist nur gültig, wenn diese <xref:System.Drawing.Graphics> zugeordnet ist eine <xref:System.Drawing.Imaging.Metafile>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler als auch `thisForm`, <xref:System.Windows.Forms.Form> für das Beispiel. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt eine temporäre <xref:System.Drawing.Graphics> zum Erstellen der Metadatei und ruft eine `hdc`, ein Handle für den Gerätekontext.  
  
-   Erstellt eine neue Metadatei mit der `hdc`.  
  
-   Erstellt eine <xref:System.Drawing.Graphics> für die Anzeige der Metadatei aus der <xref:System.Drawing.Imaging.Metafile>.  
  
-   Zeichnet ein Rechteck auf die Metadatei an.  
  
-   Der Metadatei hinzugefügt ein Kommentar.  
  
-   Löscht die <xref:System.Drawing.Graphics> für die Metadatei-die Metadatei schließt.  
  
-   Verwirft die Metadatei.  
  
-   Gibt den temporären `hdc`.  
  
-   Löscht die temporäre <xref:System.Drawing.Graphics>.  
  
-   Erstellt eine zweite Metadatei aus der zuvor erstellte Datei an.  
  
-   Zeichnet die Metadatei auf dem Bildschirm an.  
  
-   Verwirft die Metadatei.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#1)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#1)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginContainer">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Speichert einen Grafikcontainer mit dem aktuellen Zustand dieses <see cref="T:System.Drawing.Graphics" /> und öffnet und verwendet einen neuen Grafikcontainer.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginContainer">
      <MemberSignature Language="C#" Value="public System.Drawing.Drawing2D.GraphicsContainer BeginContainer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Drawing.Drawing2D.GraphicsContainer BeginContainer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.BeginContainer" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginContainer () As GraphicsContainer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::Drawing2D::GraphicsContainer ^ BeginContainer();" />
      <MemberSignature Language="F#" Value="member this.BeginContainer : unit -&gt; System.Drawing.Drawing2D.GraphicsContainer" Usage="graphics.BeginContainer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Drawing2D.GraphicsContainer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Speichert einen Grafikcontainer mit dem aktuellen Zustand dieses <see cref="T:System.Drawing.Graphics" /> und öffnet und verwendet einen neuen Grafikcontainer.</summary>
        <returns>Diese Methode gibt einen <see cref="T:System.Drawing.Drawing2D.GraphicsContainer" /> zurück, der den Zustand dieses <see cref="T:System.Drawing.Graphics" /> zum Zeitpunkt des Methodenaufrufs darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode mit dem <xref:System.Drawing.Graphics.EndContainer%2A> Methode zum Erstellen von geschachtelter Grafikcontainer. Grafikcontainer behalten Grafikstatus, z. B. die Transformation, Ausschneidebereich und Renderingeigenschaften.  
  
 Beim Aufrufen der <xref:System.Drawing.Graphics.BeginContainer%2A> -Methode der ein <xref:System.Drawing.Graphics>, ein Informationsblock mit den Status des der <xref:System.Drawing.Graphics> auf einem Stapel abgelegt. Die <xref:System.Drawing.Graphics.BeginContainer%2A> Methode gibt eine <xref:System.Drawing.Drawing2D.GraphicsContainer> , die den Informationsblock identifiziert. Wenn Sie das zu identifizierende Objekt übergeben die <xref:System.Drawing.Graphics.EndContainer%2A> -Methode der Informationsblock wird aus dem Stapel entfernt und wird verwendet, um die Wiederherstellung der <xref:System.Drawing.Graphics> in den Zustand zum Zeitpunkt der war die <xref:System.Drawing.Graphics.BeginContainer%2A> Methodenaufruf.  
  
 Container können geschachtelt werden. d. h., rufen Sie die <xref:System.Drawing.Graphics.BeginContainer%2A> Methode mehrmals vor dem Aufruf der <xref:System.Drawing.Graphics.EndContainer%2A> Methode. Bei jedem Aufruf der <xref:System.Drawing.Graphics.BeginContainer%2A> -Methode, ein Informationsblock ist auf dem Stapel abgelegt, und Sie erhalten eine <xref:System.Drawing.Drawing2D.GraphicsContainer> für den Informationsblock. Wenn Sie eines dieser Objekte zu übergeben die <xref:System.Drawing.Graphics.EndContainer%2A> -Methode, die <xref:System.Drawing.Graphics> wird zurückgegeben, um den Zustand zum Zeitpunkt der war die <xref:System.Drawing.Graphics.BeginContainer%2A> Methodenaufruf, der das bestimmte zurückgegeben <xref:System.Drawing.Drawing2D.GraphicsContainer>. Der Informationsblock auf dem Stapel abgelegt werden, von der <xref:System.Drawing.Graphics.BeginContainer%2A> Methodenaufruf wird aus dem Stapel entfernt, und alle Informationsblöcke, die nach, die auf diesem Stapel abgelegt <xref:System.Drawing.Graphics.BeginContainer%2A> Methodenaufruf werden ebenfalls entfernt.  
  
 Aufrufe von der <xref:System.Drawing.Graphics.Save%2A> Methode Informationsblöcke auf demselben Stapel als Aufrufe an die <xref:System.Drawing.Graphics.BeginContainer%2A> Methode. Ebenso wie eine <xref:System.Drawing.Graphics.EndContainer%2A> -Methodenaufruf zugeordnet ist eine <xref:System.Drawing.Graphics.BeginContainer%2A> -Methodenaufruf, einen <xref:System.Drawing.Graphics.Restore%2A> -Methodenaufruf zugeordnet ist eine <xref:System.Drawing.Graphics.Save%2A> Methodenaufruf.  
  
 Beim Aufrufen der <xref:System.Drawing.Graphics.EndContainer%2A> -Methode, alle Informationsblöcke, die auf dem Stapel abgelegt (durch die <xref:System.Drawing.Graphics.Save%2A> Methode oder der <xref:System.Drawing.Graphics.BeginContainer%2A> Methode) nach dem entsprechenden Aufruf von der <xref:System.Drawing.Graphics.BeginContainer%2A> -Methode aus dem Stapel entfernt werden. Wenn rufen Sie dementsprechend die <xref:System.Drawing.Graphics.Restore%2A> -Methode, alle Informationsblöcke, die auf dem Stapel abgelegt (von der <xref:System.Drawing.Graphics.Save%2A> Methode oder durch die <xref:System.Drawing.Graphics.BeginContainer%2A> Methode) nach dem entsprechenden Aufruf von der <xref:System.Drawing.Graphics.Save%2A> -Methode aus dem Stapel entfernt werden.  
  
 Status der Grafik hergestellt, indem die <xref:System.Drawing.Graphics.BeginContainer%2A> Methode enthält, der Rendering-Qualitäten des Standardzustands Grafiken; Renderqualität Zustandsänderungen vorhandenen, wenn die Methode aufgerufen wird, werden auf die Standardwerte zurückgesetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Öffnet einen neuen Grafikcontainer und speichert den alten Container.  
  
-   Übersetzt die globalen Koordinaten im Container.  
  
-   Füllt ein rotes Rechteck die (Koordinaten des übersetzt die) neuen Container.  
  
-   Schließt den neuen Container und die gespeicherten Container wiederhergestellt.  
  
-   Füllt ein grünes Rechteck (um die nicht übersetzten Koordinaten) des Containers gespeichert.  
  
 Das Ergebnis ist ein grünes Rechteck, das unter dem ein rotes Rechteck mit derselben Größe sich befindet.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#2)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#2)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginContainer">
      <MemberSignature Language="C#" Value="public System.Drawing.Drawing2D.GraphicsContainer BeginContainer (System.Drawing.Rectangle dstrect, System.Drawing.Rectangle srcrect, System.Drawing.GraphicsUnit unit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Drawing.Drawing2D.GraphicsContainer BeginContainer(valuetype System.Drawing.Rectangle dstrect, valuetype System.Drawing.Rectangle srcrect, valuetype System.Drawing.GraphicsUnit unit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.BeginContainer(System.Drawing.Rectangle,System.Drawing.Rectangle,System.Drawing.GraphicsUnit)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginContainer (dstrect As Rectangle, srcrect As Rectangle, unit As GraphicsUnit) As GraphicsContainer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::Drawing2D::GraphicsContainer ^ BeginContainer(System::Drawing::Rectangle dstrect, System::Drawing::Rectangle srcrect, System::Drawing::GraphicsUnit unit);" />
      <MemberSignature Language="F#" Value="member this.BeginContainer : System.Drawing.Rectangle * System.Drawing.Rectangle * System.Drawing.GraphicsUnit -&gt; System.Drawing.Drawing2D.GraphicsContainer" Usage="graphics.BeginContainer (dstrect, srcrect, unit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Drawing2D.GraphicsContainer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dstrect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcrect" Type="System.Drawing.Rectangle" />
        <Parameter Name="unit" Type="System.Drawing.GraphicsUnit" />
      </Parameters>
      <Docs>
        <param name="dstrect">
          <see cref="T:System.Drawing.Rectangle" />-Struktur, die gemeinsam mit dem <paramref name="srcrect" />-Parameter eine Skalierungstransformation für den Container angibt.</param>
        <param name="srcrect">
          <see cref="T:System.Drawing.Rectangle" />-Struktur, die gemeinsam mit dem <paramref name="dstrect" />-Parameter eine Skalierungstransformation für den Container angibt.</param>
        <param name="unit">Member der <see cref="T:System.Drawing.GraphicsUnit" />-Enumeration, die die Maßeinheit für den Container angibt.</param>
        <summary>Speichert einen Grafikcontainer mit dem aktuellen Zustand dieses <see cref="T:System.Drawing.Graphics" /> und öffnet und verwendet einen neuen Grafikcontainer mit der angegebenen Skalierungstransformation.</summary>
        <returns>Diese Methode gibt einen <see cref="T:System.Drawing.Drawing2D.GraphicsContainer" /> zurück, der den Zustand dieses <see cref="T:System.Drawing.Graphics" /> zum Zeitpunkt des Methodenaufrufs darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode mit dem <xref:System.Drawing.Graphics.EndContainer%2A> Methode zum Erstellen von geschachtelter Grafikcontainer. Grafikcontainer behalten Grafikstatus, z. B. die Transformation, Ausschneidebereich und Renderingeigenschaften.  
  
 Beim Aufrufen der <xref:System.Drawing.Graphics.BeginContainer%2A> -Methode der ein <xref:System.Drawing.Graphics>, ein Informationsblock mit den Status des der <xref:System.Drawing.Graphics> auf einem Stapel abgelegt. Die <xref:System.Drawing.Graphics.BeginContainer%2A> Methode gibt eine <xref:System.Drawing.Drawing2D.GraphicsContainer> , die den Informationsblock identifiziert. Wenn Sie das zu identifizierende Objekt übergeben die <xref:System.Drawing.Graphics.EndContainer%2A> -Methode der Informationsblock wird aus dem Stapel entfernt und wird verwendet, um die Wiederherstellung der <xref:System.Drawing.Graphics> in den Zustand zum Zeitpunkt der war die <xref:System.Drawing.Graphics.BeginContainer%2A> Methodenaufruf.  
  
 Container können geschachtelt werden. d. h., rufen Sie die <xref:System.Drawing.Graphics.BeginContainer%2A> Methode mehrmals vor dem Aufruf der <xref:System.Drawing.Graphics.EndContainer%2A> Methode. Bei jedem Aufruf der <xref:System.Drawing.Graphics.BeginContainer%2A> -Methode, ein Informationsblock ist auf dem Stapel abgelegt, und Sie erhalten eine <xref:System.Drawing.Drawing2D.GraphicsContainer> für den Informationsblock. Wenn Sie eines dieser Objekte zu übergeben die <xref:System.Drawing.Graphics.EndContainer%2A> -Methode, die <xref:System.Drawing.Graphics> wird zurückgegeben, um den Zustand zum Zeitpunkt der war die <xref:System.Drawing.Graphics.BeginContainer%2A> Methodenaufruf, der das bestimmte zurückgegeben <xref:System.Drawing.Drawing2D.GraphicsContainer>. Der Informationsblock auf dem Stapel abgelegt werden, von der <xref:System.Drawing.Graphics.BeginContainer%2A> Methodenaufruf wird aus dem Stapel entfernt, und alle Informationsblöcke, die nach, die auf diesem Stapel abgelegt <xref:System.Drawing.Graphics.BeginContainer%2A> Methodenaufruf werden ebenfalls entfernt.  
  
 Aufrufe von der <xref:System.Drawing.Graphics.Save%2A> Methode Informationsblöcke auf demselben Stapel als Aufrufe an die <xref:System.Drawing.Graphics.BeginContainer%2A> Methode. Ebenso wie eine <xref:System.Drawing.Graphics.EndContainer%2A> -Methodenaufruf zugeordnet ist eine <xref:System.Drawing.Graphics.BeginContainer%2A> -Methodenaufruf, einen <xref:System.Drawing.Graphics.Restore%2A> -Methodenaufruf zugeordnet ist eine <xref:System.Drawing.Graphics.Save%2A> Methodenaufruf.  
  
 Beim Aufrufen der <xref:System.Drawing.Graphics.EndContainer%2A> -Methode, alle Informationsblöcke, die auf dem Stapel abgelegt (durch die <xref:System.Drawing.Graphics.Save%2A> Methode oder der <xref:System.Drawing.Graphics.BeginContainer%2A> Methode) nach dem entsprechenden Aufruf von der <xref:System.Drawing.Graphics.BeginContainer%2A> -Methode aus dem Stapel entfernt werden. Wenn rufen Sie dementsprechend die <xref:System.Drawing.Graphics.Restore%2A> -Methode, alle Informationsblöcke, die auf dem Stapel abgelegt (von der <xref:System.Drawing.Graphics.Save%2A> Methode oder durch die <xref:System.Drawing.Graphics.BeginContainer%2A> Methode) nach dem entsprechenden Aufruf von der <xref:System.Drawing.Graphics.Save%2A> -Methode aus dem Stapel entfernt werden.  
  
 Diese Methode gibt eine Skalierungstransformation für den neuen Grafikcontainer mit dem `dstrect` und `srcrect` Parameter. Die Skalierung der Transformation entspricht, die bei Anwendung auf `srcrect`, führt zu `dstrect`.  
  
 Status der Grafik hergestellt, indem die <xref:System.Drawing.Graphics.BeginContainer%2A> Methode enthält, der Rendering-Qualitäten des Standardzustands Grafiken; Renderqualität Zustandsänderungen vorhandenen, wenn die Methode aufgerufen wird, werden auf die Standardwerte zurückgesetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt zwei Rechtecke, um eine Skalierungstransformation für den neuen Container angeben.  
  
-   Öffnet den neuen Grafikcontainer und speichert den alten Container.  
  
-   Füllt ein rotes Rechteck die (skalierten Koordinaten der) neuen Container.  
  
-   Schließt den neuen Container und die gespeicherten Container wiederhergestellt.  
  
-   Füllt ein grünes Rechteck (zu den-Koordinaten) des Containers gespeichert.  
  
 Das Ergebnis ist ein grünes Rechteck, das unter dem ein kleineres rotes Rechteck sich befindet.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#3](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#3)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#3)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginContainer">
      <MemberSignature Language="C#" Value="public System.Drawing.Drawing2D.GraphicsContainer BeginContainer (System.Drawing.RectangleF dstrect, System.Drawing.RectangleF srcrect, System.Drawing.GraphicsUnit unit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Drawing.Drawing2D.GraphicsContainer BeginContainer(valuetype System.Drawing.RectangleF dstrect, valuetype System.Drawing.RectangleF srcrect, valuetype System.Drawing.GraphicsUnit unit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.BeginContainer(System.Drawing.RectangleF,System.Drawing.RectangleF,System.Drawing.GraphicsUnit)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginContainer (dstrect As RectangleF, srcrect As RectangleF, unit As GraphicsUnit) As GraphicsContainer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::Drawing2D::GraphicsContainer ^ BeginContainer(System::Drawing::RectangleF dstrect, System::Drawing::RectangleF srcrect, System::Drawing::GraphicsUnit unit);" />
      <MemberSignature Language="F#" Value="member this.BeginContainer : System.Drawing.RectangleF * System.Drawing.RectangleF * System.Drawing.GraphicsUnit -&gt; System.Drawing.Drawing2D.GraphicsContainer" Usage="graphics.BeginContainer (dstrect, srcrect, unit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Drawing2D.GraphicsContainer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dstrect" Type="System.Drawing.RectangleF" />
        <Parameter Name="srcrect" Type="System.Drawing.RectangleF" />
        <Parameter Name="unit" Type="System.Drawing.GraphicsUnit" />
      </Parameters>
      <Docs>
        <param name="dstrect">
          <see cref="T:System.Drawing.RectangleF" />-Struktur, die gemeinsam mit dem <paramref name="srcrect" />-Parameter eine Skalierungstransformation für den neuen Grafikcontainer angibt.</param>
        <param name="srcrect">
          <see cref="T:System.Drawing.RectangleF" />-Struktur, die gemeinsam mit dem <paramref name="dstrect" />-Parameter eine Skalierungstransformation für den neuen Grafikcontainer angibt.</param>
        <param name="unit">Member der <see cref="T:System.Drawing.GraphicsUnit" />-Enumeration, die die Maßeinheit für den Container angibt.</param>
        <summary>Speichert einen Grafikcontainer mit dem aktuellen Zustand dieses <see cref="T:System.Drawing.Graphics" /> und öffnet und verwendet einen neuen Grafikcontainer mit der angegebenen Skalierungstransformation.</summary>
        <returns>Diese Methode gibt einen <see cref="T:System.Drawing.Drawing2D.GraphicsContainer" /> zurück, der den Zustand dieses <see cref="T:System.Drawing.Graphics" /> zum Zeitpunkt des Methodenaufrufs darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode mit dem <xref:System.Drawing.Graphics.EndContainer%2A> Methode zum Erstellen von geschachtelter Grafikcontainer. Grafikcontainer behalten Grafikstatus, z. B. die Transformation, Ausschneidebereich und Renderingeigenschaften.  
  
 Beim Aufrufen der <xref:System.Drawing.Graphics.BeginContainer%2A> -Methode der ein <xref:System.Drawing.Graphics>, ein Informationsblock mit den Status des der <xref:System.Drawing.Graphics> auf einem Stapel abgelegt. Die <xref:System.Drawing.Graphics.BeginContainer%2A> Methode gibt eine <xref:System.Drawing.Drawing2D.GraphicsContainer> , die den Informationsblock identifiziert. Wenn Sie das zu identifizierende Objekt übergeben die <xref:System.Drawing.Graphics.EndContainer%2A> -Methode der Informationsblock wird aus dem Stapel entfernt und wird verwendet, um die Wiederherstellung der <xref:System.Drawing.Graphics> in den Zustand zum Zeitpunkt der war die <xref:System.Drawing.Graphics.BeginContainer%2A> Methodenaufruf.  
  
 Container können geschachtelt werden. d. h., rufen Sie die <xref:System.Drawing.Graphics.BeginContainer%2A> Methode mehrmals vor dem Aufruf der <xref:System.Drawing.Graphics.EndContainer%2A> Methode. Bei jedem Aufruf der <xref:System.Drawing.Graphics.BeginContainer%2A> -Methode, ein Informationsblock ist auf dem Stapel abgelegt, und Sie erhalten eine <xref:System.Drawing.Drawing2D.GraphicsContainer> für den Informationsblock. Wenn Sie eines dieser Objekte zu übergeben die <xref:System.Drawing.Graphics.EndContainer%2A> -Methode, die <xref:System.Drawing.Graphics> wird zurückgegeben, um den Zustand zum Zeitpunkt der war die <xref:System.Drawing.Graphics.BeginContainer%2A> Methodenaufruf, der das bestimmte zurückgegeben <xref:System.Drawing.Drawing2D.GraphicsContainer>. Der Informationsblock auf dem Stapel abgelegt werden, von der <xref:System.Drawing.Graphics.BeginContainer%2A> Methodenaufruf wird aus dem Stapel entfernt, und alle Informationsblöcke, die nach, die auf diesem Stapel abgelegt <xref:System.Drawing.Graphics.BeginContainer%2A> Methodenaufruf werden ebenfalls entfernt.  
  
 Aufrufe von der <xref:System.Drawing.Graphics.Save%2A> Methode Informationsblöcke auf demselben Stapel als Aufrufe an die <xref:System.Drawing.Graphics.BeginContainer%2A> Methode. Ebenso wie eine <xref:System.Drawing.Graphics.EndContainer%2A> -Methodenaufruf zugeordnet ist eine <xref:System.Drawing.Graphics.BeginContainer%2A> -Methodenaufruf, einen <xref:System.Drawing.Graphics.Restore%2A> -Methodenaufruf zugeordnet ist eine <xref:System.Drawing.Graphics.Save%2A> Methodenaufruf.  
  
 Beim Aufrufen der <xref:System.Drawing.Graphics.EndContainer%2A> -Methode, alle Informationsblöcke, die auf dem Stapel abgelegt (durch die `Save` Methode oder der <xref:System.Drawing.Graphics.BeginContainer%2A> Methode) nach dem entsprechenden Aufruf von der <xref:System.Drawing.Graphics.BeginContainer%2A> -Methode aus dem Stapel entfernt werden. Wenn rufen Sie dementsprechend die <xref:System.Drawing.Graphics.Restore%2A> -Methode, alle Informationsblöcke, die auf dem Stapel abgelegt (von der <xref:System.Drawing.Graphics.Save%2A> Methode oder durch die <xref:System.Drawing.Graphics.BeginContainer%2A> Methode) nach dem entsprechenden Aufruf von der <xref:System.Drawing.Graphics.Save%2A> -Methode aus dem Stapel entfernt werden.  
  
 Diese Methode gibt eine Skalierungstransformation für den neuen Grafikcontainer mit dem `dstrect` und `srcrect` Parameter. Die Skalierung der Transformation entspricht, die bei Anwendung auf `srcrect`, führt zu `dstrect`.  
  
 Status der Grafik hergestellt, indem die <xref:System.Drawing.Graphics.BeginContainer%2A> Methode enthält, der Rendering-Qualitäten des Standardzustands Grafiken; Renderqualität Zustandsänderungen vorhandenen, wenn die Methode aufgerufen wird, werden auf die Standardwerte zurückgesetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt zwei Rechtecke, um eine Skalierungstransformation für den neuen Container angeben.  
  
-   Öffnet den neuen Grafikcontainer und speichert den alten Container.  
  
-   Füllt ein rotes Rechteck die (skalierten Koordinaten der) neuen Container.  
  
-   Schließt den neuen Container und die gespeicherten Container wiederhergestellt.  
  
-   Füllt ein grünes Rechteck (zu den-Koordinaten) des Containers gespeichert.  
  
 Das Ergebnis ist ein grünes Rechteck, das unter dem ein kleineres rotes Rechteck sich befindet.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#4](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#4)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#4)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear (System.Drawing.Color color);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear(valuetype System.Drawing.Color color) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.Clear(System.Drawing.Color)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear(System::Drawing::Color color);" />
      <MemberSignature Language="F#" Value="member this.Clear : System.Drawing.Color -&gt; unit" Usage="graphics.Clear color" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="color" Type="System.Drawing.Color" />
      </Parameters>
      <Docs>
        <param name="color">
          <see cref="T:System.Drawing.Color" />-Struktur, die die Hintergrundfarbe der Zeichenoberfläche darstellt.</param>
        <summary>Löscht die gesamte Zeichenoberfläche und füllt sie mit der angegebenen Hintergrundfarbe aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Drawing.Graphics.Clear%2A> Methode löscht den Zustand des Graphics-Objekts und sollte nicht aufgerufen werden, wenn das Graphics-Objekt kann nicht aktualisiert werden. Z. B. wenn die <xref:System.Drawing.Graphics.Clear%2A> Methode wird aufgerufen, auf einen sicheren Desktop in einer Terminalserver-Sitzung ein <xref:System.Runtime.InteropServices.ExternalException> auftreten, wenn die <xref:System.Drawing.Graphics> Objekt in einem inkonsistenten Zustand.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code löscht die Zeichenoberfläche des der <xref:System.Drawing.Graphics> und legt die Hintergrundfarbe, die vom System vorgegebene blaugrüner Farbe fest.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#5](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#5)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#5](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#5)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clip">
      <MemberSignature Language="C#" Value="public System.Drawing.Region Clip { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Region Clip" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Graphics.Clip" />
      <MemberSignature Language="VB.NET" Value="Public Property Clip As Region" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Region ^ Clip { System::Drawing::Region ^ get(); void set(System::Drawing::Region ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Clip : System.Drawing.Region with get, set" Usage="System.Drawing.Graphics.Clip" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Region</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen <see cref="T:System.Drawing.Region" /> ab, der den Zeichnungsbereich dieses <see cref="T:System.Drawing.Graphics" /> einschränkt, oder legt diesen fest.</summary>
        <value>Ein <see cref="T:System.Drawing.Region" />, der den Teil dieses <see cref="T:System.Drawing.Graphics" /> einschränkt, der gerade für das Zeichnen verfügbar ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ändern der <xref:System.Drawing.Region> zurückgegebenes Objekt der <xref:System.Drawing.Graphics.Clip%2A> Eigenschaft wirkt sich nicht auf nachfolgende Zeichnungen für die <xref:System.Drawing.Graphics> Objekt. Um die Clip-Bereich zu ändern, ersetzen die <xref:System.Drawing.Graphics.Clip%2A> Eigenschaftswert mit einem neuen <xref:System.Drawing.Region> Objekt. Um zu bestimmen, ob der Ausschneidebereich unendlich ist, rufen die <xref:System.Drawing.Graphics.Clip%2A> -Eigenschaft, und rufen die <xref:System.Drawing.Region.IsInfinite%2A> Methode.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung des <xref:System.Drawing.Graphics.Clip%2A>-Attributs veranschaulicht. In diesem Beispiel wird mit Windows Forms verwendet werden soll. Fügen Sie den Code in ein Formular, und rufen die `SetAndFillClip` Methode bei der Behandlung des Formulars <xref:System.Windows.Forms.Control.Paint> Ereignis, und übergeben `e` als <xref:System.Windows.Forms.PaintEventArgs>.  
  
 [!code-cpp[System.Drawing.GraphicsProperties#4](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.GraphicsProperties/CPP/form1.cpp#4)]
 [!code-csharp[System.Drawing.GraphicsProperties#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.GraphicsProperties/CS/form1.cs#4)]
 [!code-vb[System.Drawing.GraphicsProperties#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.GraphicsProperties/VB/form1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClipBounds">
      <MemberSignature Language="C#" Value="public System.Drawing.RectangleF ClipBounds { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.RectangleF ClipBounds" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Graphics.ClipBounds" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ClipBounds As RectangleF" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::RectangleF ClipBounds { System::Drawing::RectangleF get(); };" />
      <MemberSignature Language="F#" Value="member this.ClipBounds : System.Drawing.RectangleF" Usage="System.Drawing.Graphics.ClipBounds" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.RectangleF</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine <see cref="T:System.Drawing.RectangleF" />-Struktur ab, die den Ausschneidebereich dieses <see cref="T:System.Drawing.Graphics" /> begrenzt.</summary>
        <value>Eine <see cref="T:System.Drawing.RectangleF" />-Struktur, die ein umschließendes Rechteck für den Ausschneidebereich dieses <see cref="T:System.Drawing.Graphics" /> darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Einheit für die sich ergebende Rechteck wird festgelegt, durch die <xref:System.Drawing.Graphics.PageUnit%2A> Eigenschaft. Die Standardeinheit ist Pixel. Ein <xref:System.Drawing.Graphics> in der Regel mit einem Steuerelement zugeordnet ist und der Ursprung des Rechtecks wird relativ zum Clientbereich des Steuerelements.  
  
 Falls der Ausschneidebereich unendlich ist, ist die <xref:System.Drawing.Graphics.ClipBounds%2A> Eigenschaft gibt ein bedeutungsloses großes Rechteck zurück. Um zu bestimmen, ob der Ausschneidebereich unendlich ist, rufen die <xref:System.Drawing.Graphics.Clip%2A> -Eigenschaft, und rufen die <xref:System.Drawing.Region.IsInfinite%2A> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompositingMode">
      <MemberSignature Language="C#" Value="public System.Drawing.Drawing2D.CompositingMode CompositingMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Drawing2D.CompositingMode CompositingMode" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Graphics.CompositingMode" />
      <MemberSignature Language="VB.NET" Value="Public Property CompositingMode As CompositingMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Drawing2D::CompositingMode CompositingMode { System::Drawing::Drawing2D::CompositingMode get(); void set(System::Drawing::Drawing2D::CompositingMode value); };" />
      <MemberSignature Language="F#" Value="member this.CompositingMode : System.Drawing.Drawing2D.CompositingMode with get, set" Usage="System.Drawing.Graphics.CompositingMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Drawing2D.CompositingMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, wie zusammengesetzte Bilder zu diesem <see cref="T:System.Drawing.Graphics" /> gezeichnet werden.</summary>
        <value>Diese Eigenschaft gibt einen Member der <see cref="T:System.Drawing.Drawing2D.CompositingMode" />-Enumeration an. Der Standardwert ist <see cref="F:System.Drawing.Drawing2D.CompositingMode.SourceOver" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Mischmodus bestimmt, ob Pixel aus einem Quellbild überschreiben oder mit Hintergrund Pixel zusammen.  
  
> [!NOTE]
>  Verwenden Sie keine <xref:System.Drawing.Graphics.CompositingMode%2A> Eigenschaftswert, der <xref:System.Drawing.Drawing2D.CompositingMode.SourceCopy> beim der <xref:System.Drawing.Graphics.TextRenderingHint%2A> -Eigenschaftensatz auf <xref:System.Drawing.Text.TextRenderingHint.ClearTypeGridFit>. Eine Ausnahme auftreten, oder das Bild möglicherweise nicht ordnungsgemäß gerendert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompositingQuality">
      <MemberSignature Language="C#" Value="public System.Drawing.Drawing2D.CompositingQuality CompositingQuality { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Drawing2D.CompositingQuality CompositingQuality" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Graphics.CompositingQuality" />
      <MemberSignature Language="VB.NET" Value="Public Property CompositingQuality As CompositingQuality" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Drawing2D::CompositingQuality CompositingQuality { System::Drawing::Drawing2D::CompositingQuality get(); void set(System::Drawing::Drawing2D::CompositingQuality value); };" />
      <MemberSignature Language="F#" Value="member this.CompositingQuality : System.Drawing.Drawing2D.CompositingQuality with get, set" Usage="System.Drawing.Graphics.CompositingQuality" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Drawing2D.CompositingQuality</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Renderqualität von zusammengesetzten Bildern ab, die zu diesem <see cref="T:System.Drawing.Graphics" /> gezeichnet wurden, oder legt diese fest.</summary>
        <value>Diese Eigenschaft gibt einen Member der <see cref="T:System.Drawing.Drawing2D.CompositingQuality" />-Enumeration an. Der Standardwert ist <see cref="F:System.Drawing.Drawing2D.CompositingQuality.Default" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Zusammensetzung Qualität bestimmt die Qualität der Darstellung von zusammengesetzten Bildern.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyFromScreen">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Führt einen Bitblocktransfer der Farbdaten vom Bildschirm auf die Zeichenoberfläche des <see cref="T:System.Drawing.Graphics" /> aus.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyFromScreen">
      <MemberSignature Language="C#" Value="public void CopyFromScreen (System.Drawing.Point upperLeftSource, System.Drawing.Point upperLeftDestination, System.Drawing.Size blockRegionSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyFromScreen(valuetype System.Drawing.Point upperLeftSource, valuetype System.Drawing.Point upperLeftDestination, valuetype System.Drawing.Size blockRegionSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.CopyFromScreen(System.Drawing.Point,System.Drawing.Point,System.Drawing.Size)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyFromScreen (upperLeftSource As Point, upperLeftDestination As Point, blockRegionSize As Size)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyFromScreen(System::Drawing::Point upperLeftSource, System::Drawing::Point upperLeftDestination, System::Drawing::Size blockRegionSize);" />
      <MemberSignature Language="F#" Value="member this.CopyFromScreen : System.Drawing.Point * System.Drawing.Point * System.Drawing.Size -&gt; unit" Usage="graphics.CopyFromScreen (upperLeftSource, upperLeftDestination, blockRegionSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="upperLeftSource" Type="System.Drawing.Point" />
        <Parameter Name="upperLeftDestination" Type="System.Drawing.Point" />
        <Parameter Name="blockRegionSize" Type="System.Drawing.Size" />
      </Parameters>
      <Docs>
        <param name="upperLeftSource">Der Punkt in der linken oberen Ecke des Quellrechtecks.</param>
        <param name="upperLeftDestination">Der Punkt in der linken oberen Ecke des Zielrechtecks.</param>
        <param name="blockRegionSize">Die Größe des Bereichs, der übertragen werden soll.</param>
        <summary>Führt entsprechend einem Rechteck aus Pixeln einen Bitblocktransfer der Farbdaten vom Bildschirm auf die Zeichenoberfläche des <see cref="T:System.Drawing.Graphics" /> aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Drawing.Graphics.CopyFromScreen%2A> Methoden sind hilfreich für die Überlagerung eines Bildes mit einem anderen Bild. Um anzugeben, wie die Quelle und Ziel-Farben-Kontrastwerten auftreten, gehen Sie die <xref:System.Drawing.Graphics.CopyFromScreen%2A> Methoden, bei denen eine <xref:System.Drawing.CopyPixelOperation> Parameter.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung der <xref:System.Drawing.Graphics.CopyFromScreen%2A>-Methode veranschaulicht. Um dieses Beispiel auszuführen, fügen Sie ihn in ein Windows Form aus. Behandeln Sie das <xref:System.Windows.Forms.Control.Paint> Ereignis, und rufen die `CopyPixels1` Methode aus der <xref:System.Windows.Forms.Control.Paint> Ereignisbehandlungsmethode, übergeben `e` als <xref:System.Windows.Forms.PaintEventArgs>.  
  
 [!code-csharp[System.Drawing.MiscWhidbeySnippets#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.MiscWhidbeySnippets/CS/Form1.cs#4)]
 [!code-vb[System.Drawing.MiscWhidbeySnippets#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.MiscWhidbeySnippets/VB/Form1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Fehler bei diesem Vorgang.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">für den Zugriff auf alle Fenster. Im Zusammenhang Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" />.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/c8dff5f8-f56a-4c07-ae31-64643b31f8fc">Gewusst wie: Drucken eines Windows Form</related>
        <related type="Article" href="https://msdn.microsoft.com/library/33b76910-13a3-4521-be98-5c097341ae3b">Vorgehensweise: Kopieren von Pixeln zum Vermindern des Flackerns in Windows Forms</related>
      </Docs>
    </Member>
    <Member MemberName="CopyFromScreen">
      <MemberSignature Language="C#" Value="public void CopyFromScreen (System.Drawing.Point upperLeftSource, System.Drawing.Point upperLeftDestination, System.Drawing.Size blockRegionSize, System.Drawing.CopyPixelOperation copyPixelOperation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyFromScreen(valuetype System.Drawing.Point upperLeftSource, valuetype System.Drawing.Point upperLeftDestination, valuetype System.Drawing.Size blockRegionSize, valuetype System.Drawing.CopyPixelOperation copyPixelOperation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.CopyFromScreen(System.Drawing.Point,System.Drawing.Point,System.Drawing.Size,System.Drawing.CopyPixelOperation)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyFromScreen(System::Drawing::Point upperLeftSource, System::Drawing::Point upperLeftDestination, System::Drawing::Size blockRegionSize, System::Drawing::CopyPixelOperation copyPixelOperation);" />
      <MemberSignature Language="F#" Value="member this.CopyFromScreen : System.Drawing.Point * System.Drawing.Point * System.Drawing.Size * System.Drawing.CopyPixelOperation -&gt; unit" Usage="graphics.CopyFromScreen (upperLeftSource, upperLeftDestination, blockRegionSize, copyPixelOperation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="upperLeftSource" Type="System.Drawing.Point" />
        <Parameter Name="upperLeftDestination" Type="System.Drawing.Point" />
        <Parameter Name="blockRegionSize" Type="System.Drawing.Size" />
        <Parameter Name="copyPixelOperation" Type="System.Drawing.CopyPixelOperation" />
      </Parameters>
      <Docs>
        <param name="upperLeftSource">Der Punkt in der linken oberen Ecke des Quellrechtecks.</param>
        <param name="upperLeftDestination">Der Punkt in der linken oberen Ecke des Zielrechtecks.</param>
        <param name="blockRegionSize">Die Größe des Bereichs, der übertragen werden soll.</param>
        <param name="copyPixelOperation">Einer der <see cref="T:System.Drawing.CopyPixelOperation" />-Werte.</param>
        <summary>Führt entsprechend einem Rechteck aus Pixeln einen Bitblocktransfer der Farbdaten vom Bildschirm auf die Zeichenoberfläche des <see cref="T:System.Drawing.Graphics" /> aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Drawing.Graphics.CopyFromScreen%2A> Methoden sind hilfreich für die Überlagerung eines Bildes mit einem anderen Bild. Die `copyPixelOperation` Parameter können Sie angeben, ob und wie die Farben einer Quelle mit den Farben im Zielbereich gemischt werden sollen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung der <xref:System.Drawing.Graphics.CopyFromScreen%2A>-Methode veranschaulicht. Um dieses Beispiel auszuführen, fügen Sie ihn in ein Windows Form aus. Behandeln Sie das <xref:System.Windows.Forms.Control.Paint> Ereignis, und rufen die `CopyPixels2` Methode aus der <xref:System.Windows.Forms.Control.Paint> Ereignisbehandlungsmethode, übergeben `e` als <xref:System.Windows.Forms.PaintEventArgs>.  
  
 [!code-csharp[System.Drawing.MiscWhidbeySnippets#5](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.MiscWhidbeySnippets/CS/Form1.cs#5)]
 [!code-vb[System.Drawing.MiscWhidbeySnippets#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.MiscWhidbeySnippets/VB/Form1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="copyPixelOperation" /> ist kein Member von <see cref="T:System.Drawing.CopyPixelOperation" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Fehler bei diesem Vorgang.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">für den Zugriff auf alle Fenster. Im Zusammenhang Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" />.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/c8dff5f8-f56a-4c07-ae31-64643b31f8fc">Gewusst wie: Drucken eines Windows Form</related>
        <related type="Article" href="https://msdn.microsoft.com/library/33b76910-13a3-4521-be98-5c097341ae3b">Vorgehensweise: Kopieren von Pixeln zum Vermindern des Flackerns in Windows Forms</related>
      </Docs>
    </Member>
    <Member MemberName="CopyFromScreen">
      <MemberSignature Language="C#" Value="public void CopyFromScreen (int sourceX, int sourceY, int destinationX, int destinationY, System.Drawing.Size blockRegionSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyFromScreen(int32 sourceX, int32 sourceY, int32 destinationX, int32 destinationY, valuetype System.Drawing.Size blockRegionSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.CopyFromScreen(System.Int32,System.Int32,System.Int32,System.Int32,System.Drawing.Size)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyFromScreen (sourceX As Integer, sourceY As Integer, destinationX As Integer, destinationY As Integer, blockRegionSize As Size)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyFromScreen(int sourceX, int sourceY, int destinationX, int destinationY, System::Drawing::Size blockRegionSize);" />
      <MemberSignature Language="F#" Value="member this.CopyFromScreen : int * int * int * int * System.Drawing.Size -&gt; unit" Usage="graphics.CopyFromScreen (sourceX, sourceY, destinationX, destinationY, blockRegionSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceX" Type="System.Int32" />
        <Parameter Name="sourceY" Type="System.Int32" />
        <Parameter Name="destinationX" Type="System.Int32" />
        <Parameter Name="destinationY" Type="System.Int32" />
        <Parameter Name="blockRegionSize" Type="System.Drawing.Size" />
      </Parameters>
      <Docs>
        <param name="sourceX">Die x-Koordinate des Punktes in der linken oberen Ecke des Quellrechtecks.</param>
        <param name="sourceY">Die y-Koordinate des Punktes in der linken oberen Ecke des Quellrechtecks.</param>
        <param name="destinationX">Die x-Koordinate des Punktes in der linken oberen Ecke des Zielrechtecks.</param>
        <param name="destinationY">Die y-Koordinate des Punktes in der linken oberen Ecke des Zielrechtecks.</param>
        <param name="blockRegionSize">Die Größe des Bereichs, der übertragen werden soll.</param>
        <summary>Führt entsprechend einem Rechteck aus Pixeln einen Bitblocktransfer der Farbdaten vom Bildschirm auf die Zeichenoberfläche des <see cref="T:System.Drawing.Graphics" /> aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Drawing.Graphics.CopyFromScreen%2A> Methoden sind hilfreich für die Überlagerung eines Bildes mit einem anderen Bild. Um anzugeben, wie die Quelle und Ziel-Farben-Kontrastwerten auftreten, gehen Sie die <xref:System.Drawing.Graphics.CopyFromScreen%2A> Methoden, bei denen eine <xref:System.Drawing.CopyPixelOperation> Parameter.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie Sie mit der <xref:System.Drawing.Graphics.CopyFromScreen%2A> zum Drucken einer Kopie des aktuellen Formulars.  
  
 [!code-csharp[System.Drawing.Graphics.CopyFromScreen#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Graphics.CopyFromScreen/CS/Form1.cs#1)]
 [!code-vb[System.Drawing.Graphics.CopyFromScreen#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Graphics.CopyFromScreen/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Fehler bei diesem Vorgang.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">für den Zugriff auf alle Fenster. Im Zusammenhang Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" />.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/c8dff5f8-f56a-4c07-ae31-64643b31f8fc">Gewusst wie: Drucken eines Windows Form</related>
        <related type="Article" href="https://msdn.microsoft.com/library/33b76910-13a3-4521-be98-5c097341ae3b">Vorgehensweise: Kopieren von Pixeln zum Vermindern des Flackerns in Windows Forms</related>
      </Docs>
    </Member>
    <Member MemberName="CopyFromScreen">
      <MemberSignature Language="C#" Value="public void CopyFromScreen (int sourceX, int sourceY, int destinationX, int destinationY, System.Drawing.Size blockRegionSize, System.Drawing.CopyPixelOperation copyPixelOperation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyFromScreen(int32 sourceX, int32 sourceY, int32 destinationX, int32 destinationY, valuetype System.Drawing.Size blockRegionSize, valuetype System.Drawing.CopyPixelOperation copyPixelOperation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.CopyFromScreen(System.Int32,System.Int32,System.Int32,System.Int32,System.Drawing.Size,System.Drawing.CopyPixelOperation)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyFromScreen(int sourceX, int sourceY, int destinationX, int destinationY, System::Drawing::Size blockRegionSize, System::Drawing::CopyPixelOperation copyPixelOperation);" />
      <MemberSignature Language="F#" Value="member this.CopyFromScreen : int * int * int * int * System.Drawing.Size * System.Drawing.CopyPixelOperation -&gt; unit" Usage="graphics.CopyFromScreen (sourceX, sourceY, destinationX, destinationY, blockRegionSize, copyPixelOperation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceX" Type="System.Int32" />
        <Parameter Name="sourceY" Type="System.Int32" />
        <Parameter Name="destinationX" Type="System.Int32" />
        <Parameter Name="destinationY" Type="System.Int32" />
        <Parameter Name="blockRegionSize" Type="System.Drawing.Size" />
        <Parameter Name="copyPixelOperation" Type="System.Drawing.CopyPixelOperation" />
      </Parameters>
      <Docs>
        <param name="sourceX">Die x-Koordinate des Punktes in der linken oberen Ecke des Quellrechtecks.</param>
        <param name="sourceY">Die y-Koordinate des Punktes in der linken oberen Ecke des Quellrechtecks.</param>
        <param name="destinationX">Die x-Koordinate des Punktes in der linken oberen Ecke des Zielrechtecks.</param>
        <param name="destinationY">Die y-Koordinate des Punktes in der linken oberen Ecke des Zielrechtecks.</param>
        <param name="blockRegionSize">Die Größe des Bereichs, der übertragen werden soll.</param>
        <param name="copyPixelOperation">Einer der <see cref="T:System.Drawing.CopyPixelOperation" />-Werte.</param>
        <summary>Führt entsprechend einem Rechteck aus Pixeln einen Bitblocktransfer der Farbdaten vom Bildschirm auf die Zeichenoberfläche des <see cref="T:System.Drawing.Graphics" /> aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Drawing.Graphics.CopyFromScreen%2A> Methoden sind hilfreich für die Überlagerung eines Bildes mit einem anderen Bild. Die `copyPixelOperation` Parameter können Sie angeben, ob und wie die Farben einer Quelle mit den Farben im Zielbereich gemischt werden sollen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung der <xref:System.Drawing.Graphics.CopyFromScreen%2A>-Methode veranschaulicht. Um dieses Beispiel auszuführen, fügen Sie ihn in ein Windows Form aus. Behandeln Sie das <xref:System.Windows.Forms.Control.Paint> Ereignis, und rufen die `CopyPixels4` Methode aus der <xref:System.Windows.Forms.Control.Paint> Ereignisbehandlungsmethode, übergeben `e` als <xref:System.Windows.Forms.PaintEventArgs>.  
  
 [!code-csharp[System.Drawing.MiscWhidbeySnippets#7](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.MiscWhidbeySnippets/CS/Form1.cs#7)]
 [!code-vb[System.Drawing.MiscWhidbeySnippets#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.MiscWhidbeySnippets/VB/Form1.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="copyPixelOperation" /> ist kein Member von <see cref="T:System.Drawing.CopyPixelOperation" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Fehler bei diesem Vorgang.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">für den Zugriff auf alle Fenster. Im Zusammenhang Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" />.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/c8dff5f8-f56a-4c07-ae31-64643b31f8fc">Gewusst wie: Drucken eines Windows Form</related>
        <related type="Article" href="https://msdn.microsoft.com/library/33b76910-13a3-4521-be98-5c097341ae3b">Vorgehensweise: Kopieren von Pixeln zum Vermindern des Flackerns in Windows Forms</related>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="graphics.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt alle von dieser <see cref="T:System.Drawing.Graphics" /> verwendeten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufrufen von <xref:System.Drawing.Graphics.Dispose%2A> können die von diesem verwendeten Ressourcen <xref:System.Drawing.Graphics> , für andere Zwecke verschoben werden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt eine <xref:System.Drawing.Image> von eine SampImag.jpg-Datei im Beispielverzeichnis.  
  
-   Erstellt eine <xref:System.Drawing.Graphics> aus der <xref:System.Drawing.Image>.  
  
-   Ändert das Image durch Ausfüllen eines Rechtecks darin an.  
  
-   Zeichnet die <xref:System.Drawing.Image> auf dem Bildschirm.  
  
-   Gibt das erstellte <xref:System.Drawing.Graphics>.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#6](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#6)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#6)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DpiX">
      <MemberSignature Language="C#" Value="public float DpiX { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float32 DpiX" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Graphics.DpiX" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DpiX As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property float DpiX { float get(); };" />
      <MemberSignature Language="F#" Value="member this.DpiX : single" Usage="System.Drawing.Graphics.DpiX" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die horizontale Auflösung dieses <see cref="T:System.Drawing.Graphics" /> ab.</summary>
        <value>Der Wert in dpi (Punkte pro Zoll) für die horizontale Auflösung, die durch dieses <see cref="T:System.Drawing.Graphics" /> unterstützt wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zum Erstellen von Anwendungen mit hoher Auflösung finden Sie unter  
  
 [Hohe DPI-Werte](https://go.microsoft.com/fwlink/?LinkId=159804).  
  
   
  
## Examples  
 Das folgende Beispiel zeigt der Verwendung der <xref:System.Drawing.Graphics.DpiX%2A> und <xref:System.Drawing.Graphics.DpiY%2A> Eigenschaften. In diesem Beispiel dient zur Verwendung mit einem Windows Form. Um dieses Beispiel auszuführen, fügen Sie ihn in ein Formular, enthält eine <xref:System.Windows.Forms.ListBox> mit dem Namen listBox1 und rufen Sie diese Methode den Konstruktor des Formulars.  
  
 [!code-cpp[System.Drawing.MiscExamples#4](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.MiscExamples/CPP/form1.cpp#4)]
 [!code-csharp[System.Drawing.MiscExamples#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.MiscExamples/CS/form1.cs#4)]
 [!code-vb[System.Drawing.MiscExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.MiscExamples/VB/form1.vb#4)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=159804">Hohe DPI-Werte</related>
      </Docs>
    </Member>
    <Member MemberName="DpiY">
      <MemberSignature Language="C#" Value="public float DpiY { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float32 DpiY" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Graphics.DpiY" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DpiY As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property float DpiY { float get(); };" />
      <MemberSignature Language="F#" Value="member this.DpiY : single" Usage="System.Drawing.Graphics.DpiY" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die vertikale Auflösung dieses <see cref="T:System.Drawing.Graphics" /> ab.</summary>
        <value>Der Wert in dpi (Punkte pro Zoll) für die vertikale Auflösung, die durch dieses <see cref="T:System.Drawing.Graphics" /> unterstützt wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zum Erstellen von Anwendungen mit hoher Auflösung finden Sie unter  
  
 [Hohe DPI-Werte](https://go.microsoft.com/fwlink/?LinkId=159804).  
  
   
  
## Examples  
 Das folgende Beispiel zeigt der Verwendung der <xref:System.Drawing.Graphics.DpiX%2A> und <xref:System.Drawing.Graphics.DpiY%2A> Eigenschaften. In diesem Beispiel dient zur Verwendung mit einem Windows Form. Um dieses Beispiel auszuführen, fügen Sie ihn in ein Formular, enthält eine <xref:System.Windows.Forms.ListBox> mit dem Namen listBox1 und rufen Sie diese Methode den Konstruktor des Formulars.  
  
 [!code-cpp[System.Drawing.MiscExamples#4](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.MiscExamples/CPP/form1.cpp#4)]
 [!code-csharp[System.Drawing.MiscExamples#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.MiscExamples/CS/form1.cs#4)]
 [!code-vb[System.Drawing.MiscExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.MiscExamples/VB/form1.vb#4)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=159804">Hohe DPI-Werte</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawArc">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zeichnet einen Bogen, der einen Teil einer Ellipse darstellt, die durch ein Koordinatenpaar, eine Breiten- und eine Höhenangabe angegeben ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawArc">
      <MemberSignature Language="C#" Value="public void DrawArc (System.Drawing.Pen pen, System.Drawing.Rectangle rect, float startAngle, float sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawArc(class System.Drawing.Pen pen, valuetype System.Drawing.Rectangle rect, float32 startAngle, float32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawArc(System.Drawing.Pen,System.Drawing.Rectangle,System.Single,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawArc(System::Drawing::Pen ^ pen, System::Drawing::Rectangle rect, float startAngle, float sweepAngle);" />
      <MemberSignature Language="F#" Value="member this.DrawArc : System.Drawing.Pen * System.Drawing.Rectangle * single * single -&gt; unit" Usage="graphics.DrawArc (pen, rect, startAngle, sweepAngle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
        <Parameter Name="startAngle" Type="System.Single" />
        <Parameter Name="sweepAngle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" />, der die Farbe, Breite und den Stil des Bogens bestimmt.</param>
        <param name="rect">
          <see cref="T:System.Drawing.RectangleF" />-Struktur, die die Begrenzungen der Ellipse definiert.</param>
        <param name="startAngle">Zwischen der x-Achse und dem Anfangspunkt des Bogens im Uhrzeigersinn gemessener Winkel in Grad.</param>
        <param name="sweepAngle">Zwischen dem <paramref name="startAngle" />-Parameter und dem Endpunkt des Bogens im Uhrzeigersinn gemessener Winkel in Grad.</param>
        <summary>Zeichnet einen Bogen, der einen Teil einer durch eine <see cref="T:System.Drawing.Rectangle" />-Struktur angegebenen Ellipse darstellt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zeichnet einen Bogen, der ein Teil der Umkreis einer Ellipse ist. Die Ellipse wird durch die Grenzen eines Rechtecks definiert. Der Bogen ist der Teil des Umfangs der Ellipse zwischen der `startAngle` Parameter und die `startAngle`  +  `sweepAngle` Parameter.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen schwarzen Stift.  
  
-   Erstellt ein Rechteck, um eine Ellipse gebunden.  
  
-   Definiert die starten (45 Grad) und ein Sweep (270 Grad) Winkel.  
  
-   Zeichnet elliptischen Bogens auf dem Bildschirm an.  
  
 Das Ergebnis ist eine partielle Ellipse fehlt ein Segment zwischen + 45 Grad und der x-Achse an.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#7](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#7)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#7](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#7)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pen" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawArc">
      <MemberSignature Language="C#" Value="public void DrawArc (System.Drawing.Pen pen, System.Drawing.RectangleF rect, float startAngle, float sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawArc(class System.Drawing.Pen pen, valuetype System.Drawing.RectangleF rect, float32 startAngle, float32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawArc(System.Drawing.Pen,System.Drawing.RectangleF,System.Single,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawArc(System::Drawing::Pen ^ pen, System::Drawing::RectangleF rect, float startAngle, float sweepAngle);" />
      <MemberSignature Language="F#" Value="member this.DrawArc : System.Drawing.Pen * System.Drawing.RectangleF * single * single -&gt; unit" Usage="graphics.DrawArc (pen, rect, startAngle, sweepAngle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="rect" Type="System.Drawing.RectangleF" />
        <Parameter Name="startAngle" Type="System.Single" />
        <Parameter Name="sweepAngle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" />, der die Farbe, Breite und den Stil des Bogens bestimmt.</param>
        <param name="rect">
          <see cref="T:System.Drawing.RectangleF" />-Struktur, die die Begrenzungen der Ellipse definiert.</param>
        <param name="startAngle">Zwischen der x-Achse und dem Anfangspunkt des Bogens im Uhrzeigersinn gemessener Winkel in Grad.</param>
        <param name="sweepAngle">Zwischen dem <paramref name="startAngle" />-Parameter und dem Endpunkt des Bogens im Uhrzeigersinn gemessener Winkel in Grad.</param>
        <summary>Zeichnet einen Bogen, der einen Teil einer durch eine <see cref="T:System.Drawing.RectangleF" />-Struktur angegebenen Ellipse darstellt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zeichnet einen Bogen, der ein Teil der Umkreis einer Ellipse ist. Die Ellipse wird durch die Grenzen eines Rechtecks definiert. Der Bogen ist der Teil des Umfangs der Ellipse zwischen der `startAngle` Parameter und die `startAngle`  +  `sweepAngle` Parameter.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen schwarzen Stift.  
  
-   Erstellt ein Rechteck, um eine Ellipse gebunden.  
  
-   Definiert die starten (45 Grad) und ein Sweep (270 Grad) Winkel.  
  
-   Zeichnet elliptischen Bogens auf dem Bildschirm an.  
  
 Das Ergebnis ist eine partielle Ellipse fehlt ein Segment zwischen + 45 Grad und der x-Achse an.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#8](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#8)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#8](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#8)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pen" /> ist gleich <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawArc">
      <MemberSignature Language="C#" Value="public void DrawArc (System.Drawing.Pen pen, int x, int y, int width, int height, int startAngle, int sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawArc(class System.Drawing.Pen pen, int32 x, int32 y, int32 width, int32 height, int32 startAngle, int32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawArc(System.Drawing.Pen,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawArc(System::Drawing::Pen ^ pen, int x, int y, int width, int height, int startAngle, int sweepAngle);" />
      <MemberSignature Language="F#" Value="member this.DrawArc : System.Drawing.Pen * int * int * int * int * int * int -&gt; unit" Usage="graphics.DrawArc (pen, x, y, width, height, startAngle, sweepAngle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
        <Parameter Name="startAngle" Type="System.Int32" />
        <Parameter Name="sweepAngle" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" />, der die Farbe, Breite und den Stil des Bogens bestimmt.</param>
        <param name="x">Die x-Koordinate der oberen linken Ecke des Rechtecks, das die Ellipse definiert.</param>
        <param name="y">Die y-Koordinate der oberen linken Ecke des Rechtecks, das die Ellipse definiert.</param>
        <param name="width">Breite des Rechtecks, das die Ellipse definiert.</param>
        <param name="height">Höhe des Rechtecks, das die Ellipse definiert.</param>
        <param name="startAngle">Zwischen der x-Achse und dem Anfangspunkt des Bogens im Uhrzeigersinn gemessener Winkel in Grad.</param>
        <param name="sweepAngle">Zwischen dem <paramref name="startAngle" />-Parameter und dem Endpunkt des Bogens im Uhrzeigersinn gemessener Winkel in Grad.</param>
        <summary>Zeichnet einen Bogen, der einen Teil einer Ellipse darstellt, die durch ein Koordinatenpaar, eine Breiten- und eine Höhenangabe angegeben ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zeichnet einen Bogen, der ein Teil der Umkreis einer Ellipse ist. Die Ellipse wird durch die Grenzen eines Rechtecks definiert. Der Bogen ist der Teil des Umfangs der Ellipse zwischen der `startAngle` Parameter und die `startAngle`  +  `sweepAngle` Parameter.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen schwarzen Stift.  
  
-   Erstellt die Position und Größe eines Rechtecks an eine Ellipse gebunden.  
  
-   Definiert die starten (45 Grad) und ein Sweep (270 Grad) Winkel.  
  
-   Zeichnet elliptischen Bogens auf dem Bildschirm an.  
  
 Das Ergebnis ist eine partielle Ellipse fehlt ein Segment zwischen + 45 Grad und der x-Achse an.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#9](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#9)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#9](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#9)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#9](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rects" /> ist ein Array der Länge 0 (null).</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawArc">
      <MemberSignature Language="C#" Value="public void DrawArc (System.Drawing.Pen pen, float x, float y, float width, float height, float startAngle, float sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawArc(class System.Drawing.Pen pen, float32 x, float32 y, float32 width, float32 height, float32 startAngle, float32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawArc(System.Drawing.Pen,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawArc(System::Drawing::Pen ^ pen, float x, float y, float width, float height, float startAngle, float sweepAngle);" />
      <MemberSignature Language="F#" Value="member this.DrawArc : System.Drawing.Pen * single * single * single * single * single * single -&gt; unit" Usage="graphics.DrawArc (pen, x, y, width, height, startAngle, sweepAngle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="width" Type="System.Single" />
        <Parameter Name="height" Type="System.Single" />
        <Parameter Name="startAngle" Type="System.Single" />
        <Parameter Name="sweepAngle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" />, der die Farbe, Breite und den Stil des Bogens bestimmt.</param>
        <param name="x">Die x-Koordinate der oberen linken Ecke des Rechtecks, das die Ellipse definiert.</param>
        <param name="y">Die y-Koordinate der oberen linken Ecke des Rechtecks, das die Ellipse definiert.</param>
        <param name="width">Breite des Rechtecks, das die Ellipse definiert.</param>
        <param name="height">Höhe des Rechtecks, das die Ellipse definiert.</param>
        <param name="startAngle">Zwischen der x-Achse und dem Anfangspunkt des Bogens im Uhrzeigersinn gemessener Winkel in Grad.</param>
        <param name="sweepAngle">Zwischen dem <paramref name="startAngle" />-Parameter und dem Endpunkt des Bogens im Uhrzeigersinn gemessener Winkel in Grad.</param>
        <summary>Zeichnet einen Bogen, der einen Teil einer Ellipse darstellt, die durch ein Koordinatenpaar, eine Breiten- und eine Höhenangabe angegeben ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zeichnet einen Bogen, der ein Teil der Umkreis einer Ellipse ist. Die Ellipse wird durch die Grenzen eines Rechtecks definiert. Der Bogen ist der Teil des Umfangs der Ellipse zwischen der `startAngle` Parameter und die `startAngle`  +  `sweepAngle` Parameter.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen schwarzen Stift.  
  
-   Erstellt die Position und Größe eines Rechtecks an eine Ellipse gebunden.  
  
-   Definiert die starten (45 Grad) und ein Sweep (270 Grad) Winkel.  
  
-   Zeichnet elliptischen Bogens auf dem Bildschirm an.  
  
 Das Ergebnis ist eine partielle Ellipse fehlt ein Segment zwischen + 45 Grad und der x-Achse an.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#10](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#10)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#10](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#10)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#10](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pen" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawBezier">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zeichnet eine durch vier <see cref="T:System.Drawing.Point" />-Strukturen definierte Béziersplinekurve.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawBezier">
      <MemberSignature Language="C#" Value="public void DrawBezier (System.Drawing.Pen pen, System.Drawing.Point pt1, System.Drawing.Point pt2, System.Drawing.Point pt3, System.Drawing.Point pt4);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawBezier(class System.Drawing.Pen pen, valuetype System.Drawing.Point pt1, valuetype System.Drawing.Point pt2, valuetype System.Drawing.Point pt3, valuetype System.Drawing.Point pt4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawBezier(System.Drawing.Pen,System.Drawing.Point,System.Drawing.Point,System.Drawing.Point,System.Drawing.Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawBezier(System::Drawing::Pen ^ pen, System::Drawing::Point pt1, System::Drawing::Point pt2, System::Drawing::Point pt3, System::Drawing::Point pt4);" />
      <MemberSignature Language="F#" Value="member this.DrawBezier : System.Drawing.Pen * System.Drawing.Point * System.Drawing.Point * System.Drawing.Point * System.Drawing.Point -&gt; unit" Usage="graphics.DrawBezier (pen, pt1, pt2, pt3, pt4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="pt1" Type="System.Drawing.Point" />
        <Parameter Name="pt2" Type="System.Drawing.Point" />
        <Parameter Name="pt3" Type="System.Drawing.Point" />
        <Parameter Name="pt4" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" />-Struktur, die die Farbe, Breite und den Stil der Kurve bestimmt.</param>
        <param name="pt1">
          <see cref="T:System.Drawing.Point" />-Struktur, die den Anfangspunkt der Kurve darstellt.</param>
        <param name="pt2">
          <see cref="T:System.Drawing.Point" />-Struktur, die den ersten Kontrollpunkt für die Kurve darstellt.</param>
        <param name="pt3">
          <see cref="T:System.Drawing.Point" />-Struktur, die den zweiten Kontrollpunkt für die Kurve darstellt.</param>
        <param name="pt4">
          <see cref="T:System.Drawing.Point" />-Struktur, die den Endpunkt der Kurve darstellt.</param>
        <summary>Zeichnet eine durch vier <see cref="T:System.Drawing.Point" />-Strukturen definierte Béziersplinekurve.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Bézierkurve wird von den ersten Punkt bis zum vierten Punkt gezeichnet. Der zweite und dritte Punkt sind die Steuerpunkte, die die Form der Kurve bestimmt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen schwarzen Stift.  
  
-   Erstellt den Start, Ende und zwei Punkte für die Kurve.  
  
-   Zeichnet die Bézierkurve auf dem Bildschirm an.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#11](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#11)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#11](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#11)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#11](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pen" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawBezier">
      <MemberSignature Language="C#" Value="public void DrawBezier (System.Drawing.Pen pen, System.Drawing.PointF pt1, System.Drawing.PointF pt2, System.Drawing.PointF pt3, System.Drawing.PointF pt4);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawBezier(class System.Drawing.Pen pen, valuetype System.Drawing.PointF pt1, valuetype System.Drawing.PointF pt2, valuetype System.Drawing.PointF pt3, valuetype System.Drawing.PointF pt4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawBezier(System.Drawing.Pen,System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawBezier(System::Drawing::Pen ^ pen, System::Drawing::PointF pt1, System::Drawing::PointF pt2, System::Drawing::PointF pt3, System::Drawing::PointF pt4);" />
      <MemberSignature Language="F#" Value="member this.DrawBezier : System.Drawing.Pen * System.Drawing.PointF * System.Drawing.PointF * System.Drawing.PointF * System.Drawing.PointF -&gt; unit" Usage="graphics.DrawBezier (pen, pt1, pt2, pt3, pt4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="pt1" Type="System.Drawing.PointF" />
        <Parameter Name="pt2" Type="System.Drawing.PointF" />
        <Parameter Name="pt3" Type="System.Drawing.PointF" />
        <Parameter Name="pt4" Type="System.Drawing.PointF" />
      </Parameters>
      <Docs>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" />, der die Farbe, Breite und den Stil der Kurve bestimmt.</param>
        <param name="pt1">
          <see cref="T:System.Drawing.PointF" />-Struktur, die den Anfangspunkt der Kurve darstellt.</param>
        <param name="pt2">
          <see cref="T:System.Drawing.PointF" />-Struktur, die den ersten Kontrollpunkt für die Kurve darstellt.</param>
        <param name="pt3">
          <see cref="T:System.Drawing.PointF" />-Struktur, die den zweiten Kontrollpunkt für die Kurve darstellt.</param>
        <param name="pt4">
          <see cref="T:System.Drawing.PointF" />-Struktur, die den Endpunkt der Kurve darstellt.</param>
        <summary>Zeichnet eine durch vier <see cref="T:System.Drawing.PointF" />-Strukturen definierte Béziersplinekurve.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Béziersplinekurve wird vom ersten Punkt bis zum vierten Punkt gezeichnet. Der zweite und dritte Punkt sind die Steuerpunkte, die die Form der Kurve bestimmt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen schwarzen Stift.  
  
-   Erstellt den Start, Ende und zwei Punkte für die Kurve.  
  
-   Zeichnet die Bézierkurve auf dem Bildschirm an.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#12](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#12)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#12](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#12)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#12](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pen" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawBezier">
      <MemberSignature Language="C#" Value="public void DrawBezier (System.Drawing.Pen pen, float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawBezier(class System.Drawing.Pen pen, float32 x1, float32 y1, float32 x2, float32 y2, float32 x3, float32 y3, float32 x4, float32 y4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawBezier(System.Drawing.Pen,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawBezier(System::Drawing::Pen ^ pen, float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4);" />
      <MemberSignature Language="F#" Value="member this.DrawBezier : System.Drawing.Pen * single * single * single * single * single * single * single * single -&gt; unit" Usage="graphics.DrawBezier (pen, x1, y1, x2, y2, x3, y3, x4, y4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="x1" Type="System.Single" />
        <Parameter Name="y1" Type="System.Single" />
        <Parameter Name="x2" Type="System.Single" />
        <Parameter Name="y2" Type="System.Single" />
        <Parameter Name="x3" Type="System.Single" />
        <Parameter Name="y3" Type="System.Single" />
        <Parameter Name="x4" Type="System.Single" />
        <Parameter Name="y4" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" />, der die Farbe, Breite und den Stil der Kurve bestimmt.</param>
        <param name="x1">Die x-Koordinate des Anfangspunkts der Kurve.</param>
        <param name="y1">Die y-Koordinate des Anfangspunkts der Kurve.</param>
        <param name="x2">Die x-Koordinate des ersten Kontrollpunkts der Kurve.</param>
        <param name="y2">Die y-Koordinate des ersten Kontrollpunkts der Kurve.</param>
        <param name="x3">Die x-Koordinate des zweiten Kontrollpunkts der Kurve.</param>
        <param name="y3">Die y-Koordinate des zweiten Kontrollpunkts der Kurve.</param>
        <param name="x4">Die x-Koordinate des Endpunkts der Kurve.</param>
        <param name="y4">Die y-Koordinate des Endpunkts der Kurve.</param>
        <summary>Zeichnet eine Béziersplinekurve, die durch vier geordnete Koordinatenpaare definiert ist, die Punkte darstellen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Béziersplinekurve wird vom ersten Punkt bis zum vierten Punkt gezeichnet. Der zweite und dritte Punkt sind die Steuerpunkte, die die Form der Kurve bestimmt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen schwarzen Stift.  
  
-   Erstellt die Koordinaten der Anfang, Ende und zwei Kontrollpunkte für die Kurve.  
  
-   Zeichnet die Bézierkurve auf dem Bildschirm an.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#13](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#13)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#13](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#13)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#13](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pen" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawBeziers">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zeichnet eine Reihe von Béziersplinekurven aus einem Array von <see cref="T:System.Drawing.Point" />-Strukturen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawBeziers">
      <MemberSignature Language="C#" Value="public void DrawBeziers (System.Drawing.Pen pen, System.Drawing.Point[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawBeziers(class System.Drawing.Pen pen, valuetype System.Drawing.Point[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawBeziers(System.Drawing.Pen,System.Drawing.Point[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawBeziers(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::Point&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.DrawBeziers : System.Drawing.Pen * System.Drawing.Point[] -&gt; unit" Usage="graphics.DrawBeziers (pen, points)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="points" Type="System.Drawing.Point[]" />
      </Parameters>
      <Docs>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" />, der die Farbe, Breite und den Stil der Kurve bestimmt.</param>
        <param name="points">Array von <see cref="T:System.Drawing.Point" />-Strukturen, die Punkte darstellen, die die Kurve bestimmen. Die Anzahl von Punkten im Array sollte ein Vielfaches von 3 + 1 sein, z. B. 4, 7 oder 10.</param>
        <summary>Zeichnet eine Reihe von Béziersplinekurven aus einem Array von <see cref="T:System.Drawing.Point" />-Strukturen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Anzahl der Punkte im Array muss ein Vielfaches von 3 + 1, da der erste Spline 4 Punkte und alle anderen Splines jeweils 3 Punkte erfordern. Die erste Béziersplinekurve wird vom ersten Punkt bis zum vierten Punkt in dem Array von Punkten gezeichnet. Der zweite und dritte Punkt sind die Steuerpunkte, die die Form der Kurve bestimmt. Jede nachfolgende Kurve benötigt genau drei weitere Punkte: zwei weitere Punkte und einen Endpunkt zu steuern. Der Endpunkt der vorherigen Kurve dient als Ausgangspunkt für jede weitere Kurve.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen schwarzen Stift.  
  
-   Erstellt den Start, Ende und zwei Kontrollpunkte für eine erste Kurve und Endpunkt und die beiden Steuerpunkte für eine zweite Kurve.  
  
-   Zeichnet die aufeinander folgenden Bézierkurven auf dem Bildschirm an.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#14](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#14)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#14](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#14)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#14](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pen" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="points" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawBeziers">
      <MemberSignature Language="C#" Value="public void DrawBeziers (System.Drawing.Pen pen, System.Drawing.PointF[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawBeziers(class System.Drawing.Pen pen, valuetype System.Drawing.PointF[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawBeziers(System.Drawing.Pen,System.Drawing.PointF[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawBeziers(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::PointF&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.DrawBeziers : System.Drawing.Pen * System.Drawing.PointF[] -&gt; unit" Usage="graphics.DrawBeziers (pen, points)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
      </Parameters>
      <Docs>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" />, der die Farbe, Breite und den Stil der Kurve bestimmt.</param>
        <param name="points">Array von <see cref="T:System.Drawing.PointF" />-Strukturen, die Punkte darstellen, die die Kurve bestimmen. Die Anzahl von Punkten im Array sollte ein Vielfaches von 3 + 1 sein, z. B. 4, 7 oder 10.</param>
        <summary>Zeichnet eine Reihe von Béziersplinekurven aus einem Array von <see cref="T:System.Drawing.PointF" />-Strukturen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Anzahl der Punkte im Array muss ein Vielfaches von 3 + 1, da der erste Spline 4 Punkte und alle anderen Splines jeweils 3 Punkte erfordern. Die erste Bézierkurve wird von den ersten Punkt bis zum vierten Punkt in dem Array von Punkten gezeichnet. Der zweite und dritte Punkt sind die Steuerpunkte, die die Form der Kurve bestimmt. Jede nachfolgende Kurve benötigt genau drei weitere Punkte: zwei weitere Punkte und einen Endpunkt zu steuern. Der Endpunkt der vorherigen Kurve dient als Ausgangspunkt für jede weitere Kurve.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen schwarzen Stift.  
  
-   Erstellt den Start, Ende und zwei Kontrollpunkte für eine erste Kurve und Endpunkt und die beiden Steuerpunkte für eine zweite Kurve.  
  
-   Zeichnet die aufeinander folgenden Bézierkurven auf dem Bildschirm an.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#15](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#15)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#15](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#15)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#15](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pen" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="points" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawClosedCurve">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zeichnet eine geschlossene Cardinal-Splinekurve, die durch ein Array von <see cref="T:System.Drawing.Point" />-Strukturen definiert ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawClosedCurve">
      <MemberSignature Language="C#" Value="public void DrawClosedCurve (System.Drawing.Pen pen, System.Drawing.Point[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawClosedCurve(class System.Drawing.Pen pen, valuetype System.Drawing.Point[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawClosedCurve(System.Drawing.Pen,System.Drawing.Point[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawClosedCurve(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::Point&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.DrawClosedCurve : System.Drawing.Pen * System.Drawing.Point[] -&gt; unit" Usage="graphics.DrawClosedCurve (pen, points)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="points" Type="System.Drawing.Point[]" />
      </Parameters>
      <Docs>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" />, der die Farbe, Breite und Höhe der Kurve bestimmt.</param>
        <param name="points">Array von <see cref="T:System.Drawing.Point" />-Strukturen, die die Splinekurve definieren.</param>
        <summary>Zeichnet eine geschlossene Cardinal-Splinekurve, die durch ein Array von <see cref="T:System.Drawing.Point" />-Strukturen definiert ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zeichnet eine geschlossene cardinal-Splinekurve, die jedem Punkt im Array durchlaufen. Wenn der letzte Punkt nicht den ersten Punkt übereinstimmt, wird ein zusätzliches Kurvensegment wichtiger Punkt, schließen Sie in der Abbildung vom letzten Punkt hinzugefügt.  
  
 Das Punktarray muss mindestens vier enthalten <xref:System.Drawing.Point> Strukturen.  
  
 Diese Methode verwendet eine Standard-Spannung von 0,5.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Roten und grünen Stifte wird erstellt.  
  
-   Erstellt die sieben Punkte, die eine Kurve zu definieren.  
  
-   Zeichnet sieben rote gerade Linien zwischen den sieben Punkten, um ein geschlossenes Polygon zu bilden.  
  
-   Zeichnet eine grüne geschlossene Kurve durch die sieben Punkte.  
  
 Die Methode verwendet eine Standard-Spannung von 0,5.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#16](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#16)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#16](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#16)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#16](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pen" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="points" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawClosedCurve">
      <MemberSignature Language="C#" Value="public void DrawClosedCurve (System.Drawing.Pen pen, System.Drawing.PointF[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawClosedCurve(class System.Drawing.Pen pen, valuetype System.Drawing.PointF[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawClosedCurve(System.Drawing.Pen,System.Drawing.PointF[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawClosedCurve(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::PointF&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.DrawClosedCurve : System.Drawing.Pen * System.Drawing.PointF[] -&gt; unit" Usage="graphics.DrawClosedCurve (pen, points)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
      </Parameters>
      <Docs>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" />, der die Farbe, Breite und Höhe der Kurve bestimmt.</param>
        <param name="points">Array von <see cref="T:System.Drawing.PointF" />-Strukturen, die die Splinekurve definieren.</param>
        <summary>Zeichnet eine geschlossene Cardinal-Splinekurve, die durch ein Array von <see cref="T:System.Drawing.PointF" />-Strukturen definiert ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zeichnet eine geschlossene cardinal-Splinekurve, die jedem Punkt im Array durchlaufen. Wenn der letzte Punkt nicht den ersten Punkt übereinstimmt, wird ein zusätzliches Kurvensegment vom letzten Punkt und dem ersten Punkt, um es zu schließen hinzugefügt.  
  
 Das Punktarray muss mindestens vier enthalten <xref:System.Drawing.PointF> Strukturen.  
  
 Diese Methode verwendet eine Standard-Spannung von 0,5.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Roten und grünen Stifte wird erstellt.  
  
-   Erstellt die sieben Punkte, die eine Kurve zu definieren.  
  
-   Zeichnet sieben rote gerade Linien zwischen den sieben Punkten, um ein geschlossenes Polygon zu bilden.  
  
-   Zeichnet eine grüne geschlossene Kurve durch die sieben Punkte.  
  
 Die Methode verwendet eine Standard-Spannung von 0,5.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#18](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#18)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#18](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#18)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#18](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pen" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="points" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawClosedCurve">
      <MemberSignature Language="C#" Value="public void DrawClosedCurve (System.Drawing.Pen pen, System.Drawing.Point[] points, float tension, System.Drawing.Drawing2D.FillMode fillmode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawClosedCurve(class System.Drawing.Pen pen, valuetype System.Drawing.Point[] points, float32 tension, valuetype System.Drawing.Drawing2D.FillMode fillmode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawClosedCurve(System.Drawing.Pen,System.Drawing.Point[],System.Single,System.Drawing.Drawing2D.FillMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawClosedCurve(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::Point&gt; ^ points, float tension, System::Drawing::Drawing2D::FillMode fillmode);" />
      <MemberSignature Language="F#" Value="member this.DrawClosedCurve : System.Drawing.Pen * System.Drawing.Point[] * single * System.Drawing.Drawing2D.FillMode -&gt; unit" Usage="graphics.DrawClosedCurve (pen, points, tension, fillmode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="points" Type="System.Drawing.Point[]" />
        <Parameter Name="tension" Type="System.Single" />
        <Parameter Name="fillmode" Type="System.Drawing.Drawing2D.FillMode" />
      </Parameters>
      <Docs>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" />, der die Farbe, Breite und Höhe der Kurve bestimmt.</param>
        <param name="points">Array von <see cref="T:System.Drawing.Point" />-Strukturen, die die Splinekurve definieren.</param>
        <param name="tension">Ein Wert größer oder gleich 0,0F, der die Spannung der Kurve angibt.</param>
        <param name="fillmode">Member der <see cref="T:System.Drawing.Drawing2D.FillMode" />-Enumeration, der bestimmt, wie die Kurve ausgefüllt wird. Dieser Parameter ist erforderlich, wird aber ignoriert.</param>
        <summary>Zeichnet unter Verwendung der angegebenen Spannung eine geschlossene Cardinal-Splinekurve, die durch ein Array von <see cref="T:System.Drawing.Point" />-Strukturen definiert ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zeichnet eine geschlossene cardinal-Splinekurve, die jedem Punkt im Array durchlaufen. Wenn der letzte Punkt nicht den ersten Punkt übereinstimmt, wird ein zusätzliches Kurvensegment vom letzten Punkt und dem ersten Punkt, um es zu schließen hinzugefügt.  
  
 Das Punktarray muss mindestens vier enthalten <xref:System.Drawing.Point> Strukturen.  
  
 Die `tension` -Parameter bestimmt die Form des Splines. Wenn der Wert des der `tension` -Parameter ist 0, 0F, diese Methode zeichnet gerade Liniensegmente um miteinander zu verbinden. In der Regel die `tension` -Parameter ist kleiner als oder gleich 1. 0f. Werte über 1. 0f zu ungewöhnliche Ergebnissen führen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Roten und grünen Stifte wird erstellt.  
  
-   Erstellt die sieben Punkte, die Definition der Kurve.  
  
-   Zeichnet sieben rote gerade Linien zwischen den sieben Punkten, um ein Polygon zu bilden.  
  
-   Erstellt die Spannung und den füllen.  
  
-   Zeichnet eine grüne geschlossene Kurve durch die sieben Punkte.  
  
 Die Methode verwendet die Spannung 1.0 und legt die Füllmodus auf `FillMode.Alternate`.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#17](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#17)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#17](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#17)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#17](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pen" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="points" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawClosedCurve">
      <MemberSignature Language="C#" Value="public void DrawClosedCurve (System.Drawing.Pen pen, System.Drawing.PointF[] points, float tension, System.Drawing.Drawing2D.FillMode fillmode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawClosedCurve(class System.Drawing.Pen pen, valuetype System.Drawing.PointF[] points, float32 tension, valuetype System.Drawing.Drawing2D.FillMode fillmode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawClosedCurve(System.Drawing.Pen,System.Drawing.PointF[],System.Single,System.Drawing.Drawing2D.FillMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawClosedCurve(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::PointF&gt; ^ points, float tension, System::Drawing::Drawing2D::FillMode fillmode);" />
      <MemberSignature Language="F#" Value="member this.DrawClosedCurve : System.Drawing.Pen * System.Drawing.PointF[] * single * System.Drawing.Drawing2D.FillMode -&gt; unit" Usage="graphics.DrawClosedCurve (pen, points, tension, fillmode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
        <Parameter Name="tension" Type="System.Single" />
        <Parameter Name="fillmode" Type="System.Drawing.Drawing2D.FillMode" />
      </Parameters>
      <Docs>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" />, der die Farbe, Breite und Höhe der Kurve bestimmt.</param>
        <param name="points">Array von <see cref="T:System.Drawing.PointF" />-Strukturen, die die Splinekurve definieren.</param>
        <param name="tension">Ein Wert größer oder gleich 0,0F, der die Spannung der Kurve angibt.</param>
        <param name="fillmode">Member der <see cref="T:System.Drawing.Drawing2D.FillMode" />-Enumeration, der bestimmt, wie die Kurve ausgefüllt wird. Dieser Parameter ist erforderlich, wird aber ignoriert.</param>
        <summary>Zeichnet unter Verwendung der angegebenen Spannung eine geschlossene Cardinal-Splinekurve, die durch ein Array von <see cref="T:System.Drawing.PointF" />-Strukturen definiert ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zeichnet eine geschlossene cardinal-Splinekurve, die jedem Punkt im Array durchlaufen. Wenn der letzte Punkt nicht den ersten Punkt übereinstimmt, wird ein zusätzliches Kurvensegment vom letzten Punkt und dem ersten Punkt, um es zu schließen hinzugefügt.  
  
 Das Punktarray muss mindestens vier enthalten <xref:System.Drawing.PointF> Strukturen.  
  
 Die `tension` -Parameter bestimmt die Form des Splines. Wenn der Wert des der `tension` -Parameter ist 0, 0F, diese Methode zeichnet gerade Liniensegmente um miteinander zu verbinden. In der Regel die `tension` -Parameter ist kleiner als oder gleich 1. 0f. Werte über 1. 0f zu ungewöhnliche Ergebnissen führen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Roten und grünen Stifte wird erstellt.  
  
-   Erstellt die sieben Punkte, die Definition der Kurve.  
  
-   Zeichnet sieben rote gerade Linien zwischen den sieben Punkten, um ein Polygon zu bilden.  
  
-   Erstellt die Spannung und den füllen.  
  
-   Zeichnet eine grüne geschlossene Kurve durch die sieben Punkte.  
  
 Die Methode verwendet die Spannung 1.0 und legt die Füllmodus auf `FillMode.Alternate`.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#19](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#19)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#19](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#19)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#19](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pen" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="points" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawCurve">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zeichnet eine Cardinal-Splinekurve durch ein angegebenes Array von <see cref="T:System.Drawing.Point" />-Strukturen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawCurve">
      <MemberSignature Language="C#" Value="public void DrawCurve (System.Drawing.Pen pen, System.Drawing.Point[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawCurve(class System.Drawing.Pen pen, valuetype System.Drawing.Point[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawCurve(System.Drawing.Pen,System.Drawing.Point[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawCurve(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::Point&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.DrawCurve : System.Drawing.Pen * System.Drawing.Point[] -&gt; unit" Usage="graphics.DrawCurve (pen, points)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="points" Type="System.Drawing.Point[]" />
      </Parameters>
      <Docs>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" />, der die Farbe, Breite und Höhe der Kurve bestimmt.</param>
        <param name="points">Array von <see cref="T:System.Drawing.Point" />-Strukturen, die die Splinekurve definieren.</param>
        <summary>Zeichnet eine Cardinal-Splinekurve durch ein angegebenes Array von <see cref="T:System.Drawing.Point" />-Strukturen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zeichnet eine cardinal-Splinekurve, die jedem Punkt im Array durchlaufen.  
  
 Das Punktarray muss mindestens drei enthalten <xref:System.Drawing.Point> Strukturen für eine Kurve gezeichnet werden soll.  
  
 Diese Methode verwendet eine Standard-Spannung von 0,5.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Roten und grünen Stifte wird erstellt.  
  
-   Erstellt die sieben Punkte, die eine Kurve zu definieren.  
  
-   Zeichnet sechs rote gerade Linien zwischen den sieben Punkten, um einen unvollständigen Polygon zu bilden.  
  
-   Zeichnet eine grüne offene Kurve durch die sieben Punkte.  
  
 Die Methode verwendet eine Standard-Spannung von 0,5.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#20](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#20)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#20](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#20)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#20](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pen" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="points" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawCurve">
      <MemberSignature Language="C#" Value="public void DrawCurve (System.Drawing.Pen pen, System.Drawing.PointF[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawCurve(class System.Drawing.Pen pen, valuetype System.Drawing.PointF[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawCurve(System.Drawing.Pen,System.Drawing.PointF[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawCurve(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::PointF&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.DrawCurve : System.Drawing.Pen * System.Drawing.PointF[] -&gt; unit" Usage="graphics.DrawCurve (pen, points)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
      </Parameters>
      <Docs>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" />, der die Farbe, Breite und den Stil der Kurve bestimmt.</param>
        <param name="points">Array von <see cref="T:System.Drawing.PointF" />-Strukturen, die die Splinekurve definieren.</param>
        <summary>Zeichnet eine Cardinal-Splinekurve durch ein angegebenes Array von <see cref="T:System.Drawing.PointF" />-Strukturen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zeichnet eine cardinal-Splinekurve, die jedem Punkt im Array durchlaufen.  
  
 Das Punktarray muss mindestens drei enthalten <xref:System.Drawing.PointF> Strukturen für eine Kurve gezeichnet werden soll.  
  
 Diese Methode verwendet eine Standard-Spannung von 0,5.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Roten und grünen Stifte wird erstellt.  
  
-   Erstellt die sieben Punkte, die eine Kurve zu definieren.  
  
-   Zeichnet sechs rote gerade Linien zwischen den sieben Punkten, um einen unvollständigen Polygon zu bilden.  
  
-   Zeichnet eine grüne offene Kurve durch die sieben Punkte.  
  
 Die Methode verwendet eine Standard-Spannung von 0,5.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#23](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#23)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#23](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#23)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#23](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pen" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="points" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawCurve">
      <MemberSignature Language="C#" Value="public void DrawCurve (System.Drawing.Pen pen, System.Drawing.Point[] points, float tension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawCurve(class System.Drawing.Pen pen, valuetype System.Drawing.Point[] points, float32 tension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawCurve(System.Drawing.Pen,System.Drawing.Point[],System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawCurve(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::Point&gt; ^ points, float tension);" />
      <MemberSignature Language="F#" Value="member this.DrawCurve : System.Drawing.Pen * System.Drawing.Point[] * single -&gt; unit" Usage="graphics.DrawCurve (pen, points, tension)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="points" Type="System.Drawing.Point[]" />
        <Parameter Name="tension" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" />, der die Farbe, Breite und den Stil der Kurve bestimmt.</param>
        <param name="points">Array von <see cref="T:System.Drawing.Point" />-Strukturen, die die Splinekurve definieren.</param>
        <param name="tension">Ein Wert größer oder gleich 0,0F, der die Spannung der Kurve angibt.</param>
        <summary>Zeichnet unter Verwendung der angegebenen Spannung eine Cardinal-Splinekurve durch ein angegebenes Array von <see cref="T:System.Drawing.Point" />-Strukturen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zeichnet eine cardinal-Splinekurve, die jedem Punkt im Array durchlaufen.  
  
 Das Punktarray muss mindestens drei enthalten <xref:System.Drawing.Point> Strukturen für eine Kurve gezeichnet werden soll.  
  
 Die `tension` -Parameter bestimmt die Form des Splines. Wenn der Wert des der `tension` -Parameter ist 0, 0F, diese Methode zeichnet gerade Liniensegmente um miteinander zu verbinden. In der Regel die `tension` -Parameter ist kleiner als oder gleich 1. 0f. Werte über 1. 0f zu ungewöhnliche Ergebnissen führen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Roten und grünen Stifte wird erstellt.  
  
-   Erstellt die sieben Punkte, die Definition der Kurve.  
  
-   Zeichnet sechs rote gerade Linien zwischen den sieben Punkten, um einen unvollständigen Polygon zu bilden.  
  
-   Erstellt eine Einstellung für die Spannung an.  
  
-   Zeichnet eine grüne offene Kurve durch die sieben Punkte.  
  
 Die Methode verwendet die Spannung 1,0.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#22](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#22)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#22](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#22)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#22](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pen" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="points" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawCurve">
      <MemberSignature Language="C#" Value="public void DrawCurve (System.Drawing.Pen pen, System.Drawing.PointF[] points, float tension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawCurve(class System.Drawing.Pen pen, valuetype System.Drawing.PointF[] points, float32 tension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawCurve(System.Drawing.Pen,System.Drawing.PointF[],System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawCurve(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::PointF&gt; ^ points, float tension);" />
      <MemberSignature Language="F#" Value="member this.DrawCurve : System.Drawing.Pen * System.Drawing.PointF[] * single -&gt; unit" Usage="graphics.DrawCurve (pen, points, tension)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
        <Parameter Name="tension" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" />, der die Farbe, Breite und den Stil der Kurve bestimmt.</param>
        <param name="points">Array von <see cref="T:System.Drawing.PointF" />-Strukturen, die die Punkte für die Definition des Kurvenverlaufs darstellen.</param>
        <param name="tension">Ein Wert größer oder gleich 0,0F, der die Spannung der Kurve angibt.</param>
        <summary>Zeichnet unter Verwendung der angegebenen Spannung eine Cardinal-Splinekurve durch ein angegebenes Array von <see cref="T:System.Drawing.PointF" />-Strukturen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zeichnet eine cardinal-Splinekurve, die jedem Punkt im Array durchlaufen.  
  
 Das Punktarray muss mindestens drei enthalten <xref:System.Drawing.PointF> Strukturen für eine Kurve gezeichnet werden soll.  
  
 Die `tension` -Parameter bestimmt die Form des Splines. Wenn der Wert des der `tension` -Parameter ist 0, 0F, diese Methode zeichnet gerade Liniensegmente um miteinander zu verbinden. In der Regel die `tension` -Parameter ist kleiner als oder gleich 1. 0f. Werte über 1. 0f zu ungewöhnliche Ergebnissen führen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Roten und grünen Stifte wird erstellt.  
  
-   Erstellt die sieben Punkte, die Definition der Kurve.  
  
-   Zeichnet sechs rote gerade Linien zwischen den sieben Punkten, um einen unvollständigen Polygon zu bilden.  
  
-   Erstellt eine Einstellung für die Spannung an.  
  
-   Zeichnet eine grüne offene Kurve durch die sieben Punkte.  
  
 Die Methode verwendet die Spannung 1,0.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#26](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#26)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#26](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#26)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#26](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#26)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pen" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="points" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawCurve">
      <MemberSignature Language="C#" Value="public void DrawCurve (System.Drawing.Pen pen, System.Drawing.PointF[] points, int offset, int numberOfSegments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawCurve(class System.Drawing.Pen pen, valuetype System.Drawing.PointF[] points, int32 offset, int32 numberOfSegments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawCurve(System.Drawing.Pen,System.Drawing.PointF[],System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawCurve(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::PointF&gt; ^ points, int offset, int numberOfSegments);" />
      <MemberSignature Language="F#" Value="member this.DrawCurve : System.Drawing.Pen * System.Drawing.PointF[] * int * int -&gt; unit" Usage="graphics.DrawCurve (pen, points, offset, numberOfSegments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="numberOfSegments" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" />, der die Farbe, Breite und den Stil der Kurve bestimmt.</param>
        <param name="points">Array von <see cref="T:System.Drawing.PointF" />-Strukturen, die die Splinekurve definieren.</param>
        <param name="offset">Offset vom ersten Element im Array des <paramref name="points" />-Parameters bis zum Anfangspunkt der Kurve.</param>
        <param name="numberOfSegments">Anzahl der Segmente nach dem Anfangspunkt, die in die Kurve aufgenommen werden sollen.</param>
        <summary>Zeichnet eine Cardinal-Splinekurve durch ein angegebenes Array von <see cref="T:System.Drawing.PointF" />-Strukturen. Die Zeichnung beginnt am Offset vom Anfang des Arrays.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zeichnet eine cardinal-Splinekurve, die jedem Punkt im Array durchlaufen.  
  
 Das Punktarray muss mindestens drei enthalten <xref:System.Drawing.PointF> Strukturen für eine Kurve gezeichnet werden soll.  
  
 Der Wert des der `offset` Parameter gibt die Anzahl der Elemente in das Array übersprungen werden sollen. Das erste Element nach den übersprungenen Elementen stellt den Anfangspunkt der Kurve dar.  
  
 Der Wert des der `numberOfSegments` Parameter gibt die Anzahl der Segmente, nach dem Anfangspunkt der Kurve zu zeichnen. Der Wert des der `numberOfSegments` -Parameter muss mindestens 1 sein. Der Wert des der `offset` Parameter und der Wert der die `numberOfSegments` Parameter muss kleiner sein als die Anzahl der Elemente im Array von der `points` Parameter.  
  
 Diese Methode verwendet eine Standard-Spannung von 0,5.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Roten und grünen Stifte wird erstellt.  
  
-   Erstellt die sieben Punkte, die eine Kurve zu definieren.  
  
-   Zeichnet sechs rote gerade Linien zwischen den sieben Punkten, um einen unvollständigen Polygon zu bilden.  
  
-   Definiert den angegebenen Punkt-Offset und Anzahl von Segmenten.  
  
-   Zeichnet eine grüne offene Kurve (beginnend mit dem dritten Punkt) über die letzten fünf Punkte.  
  
 Die Methode verwendet eine Standard-Spannung von 0,5.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#24](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#24)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#24](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#24)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#24](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#24)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pen" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="points" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawCurve">
      <MemberSignature Language="C#" Value="public void DrawCurve (System.Drawing.Pen pen, System.Drawing.Point[] points, int offset, int numberOfSegments, float tension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawCurve(class System.Drawing.Pen pen, valuetype System.Drawing.Point[] points, int32 offset, int32 numberOfSegments, float32 tension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawCurve(System.Drawing.Pen,System.Drawing.Point[],System.Int32,System.Int32,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawCurve(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::Point&gt; ^ points, int offset, int numberOfSegments, float tension);" />
      <MemberSignature Language="F#" Value="member this.DrawCurve : System.Drawing.Pen * System.Drawing.Point[] * int * int * single -&gt; unit" Usage="graphics.DrawCurve (pen, points, offset, numberOfSegments, tension)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="points" Type="System.Drawing.Point[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="numberOfSegments" Type="System.Int32" />
        <Parameter Name="tension" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" />, der die Farbe, Breite und den Stil der Kurve bestimmt.</param>
        <param name="points">Array von <see cref="T:System.Drawing.Point" />-Strukturen, die die Splinekurve definieren.</param>
        <param name="offset">Offset vom ersten Element im Array des <paramref name="points" />-Parameters bis zum Anfangspunkt der Kurve.</param>
        <param name="numberOfSegments">Anzahl der Segmente nach dem Anfangspunkt, die in die Kurve aufgenommen werden sollen.</param>
        <param name="tension">Ein Wert größer oder gleich 0,0F, der die Spannung der Kurve angibt.</param>
        <summary>Zeichnet unter Verwendung der angegebenen Spannung eine Cardinal-Splinekurve durch ein angegebenes Array von <see cref="T:System.Drawing.Point" />-Strukturen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zeichnet eine cardinal-Splinekurve, die jedem Punkt im Array durchlaufen.  
  
 Das Punktarray muss mindestens drei enthalten <xref:System.Drawing.Point> Strukturen für eine Kurve gezeichnet werden soll.  
  
 Der Wert des der `offset` Parameter gibt die Anzahl der Elemente in das Array übersprungen werden sollen. Das erste Element nach den übersprungenen Elementen stellt den Anfangspunkt der Kurve dar.  
  
 Der Wert des der `numberOfSegments` Parameter gibt die Anzahl der Segmente, nach dem Anfangspunkt der Kurve zu zeichnen. Der Wert des der `numberOfSegments` -Parameter muss mindestens 1 sein. Der Wert des der `offset` Parameter und der Wert der die `numberOfSegments` Parameter muss kleiner sein als die Anzahl der Elemente im Array von der `points` Parameter.  
  
 Die `tension` -Parameter bestimmt die Form des Splines. Wenn der Wert des der `tension` -Parameter ist 0, 0F, diese Methode zeichnet gerade Liniensegmente um miteinander zu verbinden. In der Regel die `tension` -Parameter ist kleiner als oder gleich 1. 0f. Werte über 1. 0f zu ungewöhnliche Ergebnissen führen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Roten und grünen Stifte wird erstellt.  
  
-   Erstellt die sieben Punkte, die eine Kurve zu definieren.  
  
-   Zeichnet sechs rote gerade Linien zwischen den sieben Punkten, um einen unvollständigen Polygon zu bilden.  
  
-   Definiert den angegebenen Punkt-Offset und Anzahl von Segmenten.  
  
-   Definiert die Spannung an.  
  
-   Zeichnet eine grüne offene Kurve (beginnend mit dem dritten Punkt) über die letzten fünf Punkte.  
  
 Die-Methode legt die Spannung zu 1.0.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#21](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#21)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#21](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#21)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#21](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pen" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="points" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawCurve">
      <MemberSignature Language="C#" Value="public void DrawCurve (System.Drawing.Pen pen, System.Drawing.PointF[] points, int offset, int numberOfSegments, float tension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawCurve(class System.Drawing.Pen pen, valuetype System.Drawing.PointF[] points, int32 offset, int32 numberOfSegments, float32 tension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawCurve(System.Drawing.Pen,System.Drawing.PointF[],System.Int32,System.Int32,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawCurve(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::PointF&gt; ^ points, int offset, int numberOfSegments, float tension);" />
      <MemberSignature Language="F#" Value="member this.DrawCurve : System.Drawing.Pen * System.Drawing.PointF[] * int * int * single -&gt; unit" Usage="graphics.DrawCurve (pen, points, offset, numberOfSegments, tension)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="numberOfSegments" Type="System.Int32" />
        <Parameter Name="tension" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" />, der die Farbe, Breite und den Stil der Kurve bestimmt.</param>
        <param name="points">Array von <see cref="T:System.Drawing.PointF" />-Strukturen, die die Splinekurve definieren.</param>
        <param name="offset">Offset vom ersten Element im Array des <paramref name="points" />-Parameters bis zum Anfangspunkt der Kurve.</param>
        <param name="numberOfSegments">Anzahl der Segmente nach dem Anfangspunkt, die in die Kurve aufgenommen werden sollen.</param>
        <param name="tension">Ein Wert größer oder gleich 0,0F, der die Spannung der Kurve angibt.</param>
        <summary>Zeichnet unter Verwendung der angegebenen Spannung eine Cardinal-Splinekurve durch ein angegebenes Array von <see cref="T:System.Drawing.PointF" />-Strukturen. Die Zeichnung beginnt am Offset vom Anfang des Arrays.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zeichnet eine cardinal-Splinekurve, die jedem Punkt im Array durchlaufen.  
  
 Das Punktarray muss mindestens drei enthalten <xref:System.Drawing.PointF> Strukturen für die Kurve gezeichnet wird.  
  
 Der Wert des der `offset` Parameter gibt die Anzahl der Elemente in das Array übersprungen werden sollen. Das erste Element nach den übersprungenen Elementen stellt den Anfangspunkt der Kurve dar.  
  
 Der Wert des der `numberOfSegments` Parameter gibt die Anzahl der Segmente, nach dem Anfangspunkt der Kurve zu zeichnen. Der Wert des der `numberOfSegments` -Parameter muss mindestens 1 sein. Der Wert des der `offset` Parameter und der Wert der die `numberOfSegments` Parameter muss kleiner sein als die Anzahl der Elemente im Array von der `points` Parameter.  
  
 Die `tension` -Parameter bestimmt die Form des Splines. Wenn der Wert des der `tension` -Parameter ist 0, 0F, diese Methode zeichnet gerade Liniensegmente um miteinander zu verbinden. In der Regel die `tension` -Parameter ist kleiner als oder gleich 1. 0f. Werte über 1. 0f zu ungewöhnliche Ergebnissen führen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Roten und grünen Stifte wird erstellt.  
  
-   Erstellt die sieben Punkte, die eine Kurve zu definieren.  
  
-   Zeichnet sechs rote gerade Linien zwischen den sieben Punkten, um einen unvollständigen Polygon zu bilden.  
  
-   Definiert den angegebenen Punkt-Offset und Anzahl von Segmenten.  
  
-   Definiert die Spannung an.  
  
-   Zeichnet eine grüne offene Kurve (beginnend mit dem dritten Punkt) über die letzten fünf Punkte.  
  
 Die-Methode legt die Spannung zu 1.0.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#25](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#25)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#25](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#25)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#25](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pen" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="points" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawEllipse">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zeichnet eine Ellipse, die durch ein umschließendes Rechteck definiert ist, das durch ein Koordinatenpaar, eine Höhen- und eine Breitenangabe angegeben ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawEllipse">
      <MemberSignature Language="C#" Value="public void DrawEllipse (System.Drawing.Pen pen, System.Drawing.Rectangle rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawEllipse(class System.Drawing.Pen pen, valuetype System.Drawing.Rectangle rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawEllipse(System.Drawing.Pen,System.Drawing.Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawEllipse(System::Drawing::Pen ^ pen, System::Drawing::Rectangle rect);" />
      <MemberSignature Language="F#" Value="member this.DrawEllipse : System.Drawing.Pen * System.Drawing.Rectangle -&gt; unit" Usage="graphics.DrawEllipse (pen, rect)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" />, der die Farbe, Breite und den Stil der Ellipse bestimmt.</param>
        <param name="rect">
          <see cref="T:System.Drawing.Rectangle" />-Struktur, die die Begrenzungen der Ellipse definiert.</param>
        <summary>Zeichnet eine Ellipse, die durch eine umschließende <see cref="T:System.Drawing.Rectangle" />-Struktur angegeben ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zeichnet eine Ellipse, die durch das umschließende Rechteck gemäß definiert ist die `rect` Parameter.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen schwarzen Stift.  
  
-   Erstellt ein Rechteck, um eine Ellipse gebunden.  
  
-   Zeichnet die Ellipse auf dem Bildschirm an.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#27](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#27)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#27](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#27)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#27](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#27)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pen" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawEllipse">
      <MemberSignature Language="C#" Value="public void DrawEllipse (System.Drawing.Pen pen, System.Drawing.RectangleF rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawEllipse(class System.Drawing.Pen pen, valuetype System.Drawing.RectangleF rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawEllipse(System.Drawing.Pen,System.Drawing.RectangleF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawEllipse(System::Drawing::Pen ^ pen, System::Drawing::RectangleF rect);" />
      <MemberSignature Language="F#" Value="member this.DrawEllipse : System.Drawing.Pen * System.Drawing.RectangleF -&gt; unit" Usage="graphics.DrawEllipse (pen, rect)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="rect" Type="System.Drawing.RectangleF" />
      </Parameters>
      <Docs>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" />, der die Farbe, Breite und den Stil der Ellipse bestimmt.</param>
        <param name="rect">
          <see cref="T:System.Drawing.RectangleF" />-Struktur, die die Begrenzungen der Ellipse definiert.</param>
        <summary>Zeichnet eine Ellipse, die durch ein umschließendes <see cref="T:System.Drawing.RectangleF" /> definiert ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zeichnet eine Ellipse, die durch das umschließende Rechteck gemäß definiert ist die `rect` Parameter.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen schwarzen Stift.  
  
-   Erstellt ein Rechteck, um eine Ellipse gebunden.  
  
-   Zeichnet die Ellipse auf dem Bildschirm an.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#28](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#28)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#28](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#28)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#28](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pen" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawEllipse">
      <MemberSignature Language="C#" Value="public void DrawEllipse (System.Drawing.Pen pen, int x, int y, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawEllipse(class System.Drawing.Pen pen, int32 x, int32 y, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawEllipse(System.Drawing.Pen,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawEllipse(System::Drawing::Pen ^ pen, int x, int y, int width, int height);" />
      <MemberSignature Language="F#" Value="member this.DrawEllipse : System.Drawing.Pen * int * int * int * int -&gt; unit" Usage="graphics.DrawEllipse (pen, x, y, width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" />, der die Farbe, Breite und den Stil der Ellipse bestimmt.</param>
        <param name="x">Die x-Koordinate der oberen linken Ecke des umschließenden Rechtecks, das die Ellipse definiert.</param>
        <param name="y">Die y-Koordinate der oberen linken Ecke des umschließenden Rechtecks, das die Ellipse definiert.</param>
        <param name="width">Breite des umschließenden Rechtecks, das die Ellipse definiert.</param>
        <param name="height">Höhe des umschließenden Rechtecks, das die Ellipse definiert.</param>
        <summary>Zeichnet eine Ellipse, die durch ein umschließendes Rechteck definiert ist, das durch Koordinaten für die obere linke Ecke des Rechtecks, eine Höhen- und eine Breitenangabe angegeben ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zeichnet eine Ellipse, die durch das umschließende Rechteck durch beschrieben definiert ist diese Methode die `x`, `y`, `width`, und `height` Parameter.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen schwarzen Stift.  
  
-   Erstellt die Position und Größe eines Rechtecks an eine Ellipse gebunden.  
  
-   Zeichnet die Ellipse auf dem Bildschirm an.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#29](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#29)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#29](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#29)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#29](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#29)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pen" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawEllipse">
      <MemberSignature Language="C#" Value="public void DrawEllipse (System.Drawing.Pen pen, float x, float y, float width, float height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawEllipse(class System.Drawing.Pen pen, float32 x, float32 y, float32 width, float32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawEllipse(System.Drawing.Pen,System.Single,System.Single,System.Single,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawEllipse(System::Drawing::Pen ^ pen, float x, float y, float width, float height);" />
      <MemberSignature Language="F#" Value="member this.DrawEllipse : System.Drawing.Pen * single * single * single * single -&gt; unit" Usage="graphics.DrawEllipse (pen, x, y, width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="width" Type="System.Single" />
        <Parameter Name="height" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" />, der die Farbe, Breite und den Stil der Ellipse bestimmt.</param>
        <param name="x">Die x-Koordinate der oberen linken Ecke des umschließenden Rechtecks, das die Ellipse definiert.</param>
        <param name="y">Die y-Koordinate der oberen linken Ecke des umschließenden Rechtecks, das die Ellipse definiert.</param>
        <param name="width">Breite des umschließenden Rechtecks, das die Ellipse definiert.</param>
        <param name="height">Höhe des umschließenden Rechtecks, das die Ellipse definiert.</param>
        <summary>Zeichnet eine Ellipse, die durch ein umschließendes Rechteck definiert ist, das durch ein Koordinatenpaar, eine Höhen- und eine Breitenangabe angegeben ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zeichnet eine Ellipse, die durch das umschließende Rechteck durch beschrieben definiert ist diese Methode die `x`, `y`, `width`, und `height` Parameter.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen schwarzen Stift.  
  
-   Erstellt die Position und Größe eines Rechtecks an eine Ellipse gebunden.  
  
-   Zeichnet die Ellipse auf dem Bildschirm an.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#30](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#30)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#30](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#30)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#30](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#30)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pen" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawIcon">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zeichnet das durch das angegebene <see cref="T:System.Drawing.Icon" /> dargestellte Bild an den angegebenen Koordinaten.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawIcon">
      <MemberSignature Language="C#" Value="public void DrawIcon (System.Drawing.Icon icon, System.Drawing.Rectangle targetRect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawIcon(class System.Drawing.Icon icon, valuetype System.Drawing.Rectangle targetRect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawIcon(System.Drawing.Icon,System.Drawing.Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawIcon(System::Drawing::Icon ^ icon, System::Drawing::Rectangle targetRect);" />
      <MemberSignature Language="F#" Value="member this.DrawIcon : System.Drawing.Icon * System.Drawing.Rectangle -&gt; unit" Usage="graphics.DrawIcon (icon, targetRect)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="icon" Type="System.Drawing.Icon" />
        <Parameter Name="targetRect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="icon">Der zu zeichnende <see cref="T:System.Drawing.Icon" />.</param>
        <param name="targetRect">
          <see cref="T:System.Drawing.Rectangle" />-Struktur, die die Größe und Position des resultierenden Bildes auf der Anzeigeoberfläche angibt. Das Bild im <paramref name="icon" />-Parameter wird auf die Abmessungen dieses rechteckigen Bereichs skaliert.</param>
        <summary>Zeichnet das durch das angegebene <see cref="T:System.Drawing.Icon" /> dargestellte Bild innerhalb des von einer <see cref="T:System.Drawing.Rectangle" />-Struktur angegebenen Bereichs.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein Symbol aus eine standardmäßige Windows-Symboldatei SampIcon.ico im Ordner "Beispiel".  
  
-   Erstellt ein Rechteck, in dem das Symbol gezeichnet werden soll.  
  
-   Zeichnet das Symbol auf dem Bildschirm an.  
  
 Die Position des Rechtecks sucht das Symbol auf dem Bildschirm und die Größe des Rechtecks bestimmt die Skalierung der das gezeichnete Symbol.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#31](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#31)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#31](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#31)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#31](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#31)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="icon" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawIcon">
      <MemberSignature Language="C#" Value="public void DrawIcon (System.Drawing.Icon icon, int x, int y);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawIcon(class System.Drawing.Icon icon, int32 x, int32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawIcon(System.Drawing.Icon,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawIcon(System::Drawing::Icon ^ icon, int x, int y);" />
      <MemberSignature Language="F#" Value="member this.DrawIcon : System.Drawing.Icon * int * int -&gt; unit" Usage="graphics.DrawIcon (icon, x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="icon" Type="System.Drawing.Icon" />
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="icon">Der zu zeichnende <see cref="T:System.Drawing.Icon" />.</param>
        <param name="x">Die x-Koordinate der oberen linken Ecke des gezeichneten Bilds.</param>
        <param name="y">Die y-Koordinate der oberen linken Ecke des gezeichneten Bilds.</param>
        <summary>Zeichnet das durch das angegebene <see cref="T:System.Drawing.Icon" /> dargestellte Bild an den angegebenen Koordinaten.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein Symbol aus eine standardmäßige Windows-Symboldatei SampIcon.ico im Ordner "Beispiel".  
  
-   Erstellt die Koordinaten der oberen linken Ecke auf dem das Symbol gezeichnet werden soll.  
  
-   Zeichnet das Symbol auf dem Bildschirm an.  
  
 Das gezeichnete Symbol ist nicht skaliert.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#32](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#32)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#32](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#32)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#32](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="icon" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawIconUnstretched">
      <MemberSignature Language="C#" Value="public void DrawIconUnstretched (System.Drawing.Icon icon, System.Drawing.Rectangle targetRect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawIconUnstretched(class System.Drawing.Icon icon, valuetype System.Drawing.Rectangle targetRect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawIconUnstretched(System.Drawing.Icon,System.Drawing.Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawIconUnstretched(System::Drawing::Icon ^ icon, System::Drawing::Rectangle targetRect);" />
      <MemberSignature Language="F#" Value="member this.DrawIconUnstretched : System.Drawing.Icon * System.Drawing.Rectangle -&gt; unit" Usage="graphics.DrawIconUnstretched (icon, targetRect)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="icon" Type="System.Drawing.Icon" />
        <Parameter Name="targetRect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="icon">Der zu zeichnende <see cref="T:System.Drawing.Icon" />.</param>
        <param name="targetRect">
          <see cref="T:System.Drawing.Rectangle" />-Struktur, die die Position und Größe des resultierenden Bildes angibt. Das Bild wird nicht skaliert, um in dieses Rechteck zu passen, sondern behält seine ursprüngliche Größe bei. Wenn das Bild größer als das Rechteck ist, wird das Bild zum Anpassen abgeschnitten.</param>
        <summary>Zeichnet das durch das angegebene <see cref="T:System.Drawing.Icon" /> dargestellte Bild, ohne das Bild zu skalieren.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein Symbol aus eine standardmäßige Windows-Symboldatei SampIcon.ico im Ordner "Beispiel".  
  
-   Erstellt ein Rechteck, in dem das Symbol gezeichnet werden soll.  
  
-   Zeichnet das Symbol auf dem Bildschirm an.  
  
 Die Position des Rechtecks sucht das Symbol auf dem Bildschirm und das gezeichnete Symbol ist weder skaliert und nicht abgeschnitten.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#33](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#33)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#33](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#33)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#33](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#33)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="icon" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawImage">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zeichnet das angegebene <see cref="T:System.Drawing.Image" /> an der angegebenen Position und in der ursprünglichen Größe.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.Point point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.Point point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, System::Drawing::Point point);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.Point -&gt; unit" Usage="graphics.DrawImage (image, point)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="point" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="image">Der zu zeichnende <see cref="T:System.Drawing.Image" />.</param>
        <param name="point">
          <see cref="T:System.Drawing.Point" />-Struktur, die die Position der oberen linken Ecke des gezeichneten Bildes darstellt.</param>
        <summary>Zeichnet das angegebene <see cref="T:System.Drawing.Image" /> in seiner ursprünglichen physischen Größe an der angegebenen Position.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Drawing.Image> speichert einen Wert für die Breite in Pixel und einen Wert für die horizontale Auflösung (dpi). Die physische Breite, gemessen in Zoll eines Bilds wird geteilt durch die horizontale Auflösung Breite in Pixel. Ein Bild mit einer Breite von 216 Pixel und einer horizontalen Auflösung von 72 Punkte pro Zoll hat z. B. eine physische Breite von 3 Zoll. Ähnliche Hinweise gelten für die Höhe in Pixel und die physische Höhe.  
  
 Diese Methode zeichnet ein Bild in seiner physischen Größe hat also das Image die richtige Größe in Zoll, unabhängig von der Auflösung (dpi) des Anzeigegeräts. Nehmen wir beispielsweise an, dass ein Bild einer Breite von 216 Pixel und einer horizontalen Auflösung von 72 Punkte pro Zoll sind. Wenn Sie diese Methode rufen, um das Image auf einem Gerät zu zeichnen, die eine Auflösung von 96 DPI-Wert aufweist, werden die Pixelbreite des gerenderten Bilds (216/72 Zoll) * 96 = 288.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein Image aus einem JPEG-Datei SampImag.jpg im Ordner "des Beispiels".  
  
-   Erstellt einen Punkt, an dem der oberen linken Ecke des Bilds gezeichnet werden soll.  
  
-   Zeichnet das Bild auf dem Bildschirm an.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#34](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#34)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#34](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#34)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#34](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#34)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="image" /> ist <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.Point[] destPoints);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.Point[] destPoints) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Point[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, cli::array &lt;System::Drawing::Point&gt; ^ destPoints);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.Point[] -&gt; unit" Usage="graphics.DrawImage (image, destPoints)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destPoints" Type="System.Drawing.Point[]" />
      </Parameters>
      <Docs>
        <param name="image">Der zu zeichnende <see cref="T:System.Drawing.Image" />.</param>
        <param name="destPoints">Array von drei <see cref="T:System.Drawing.Point" />-Strukturen, die ein Parallelogramm definieren.</param>
        <summary>Zeichnet das angegebene <see cref="T:System.Drawing.Image" /> an der angegebenen Position und in der angegebenen Form und Größe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `destPoints` Parameter gibt die drei Punkte eines Parallelogramms an. Die drei <xref:System.Drawing.Point> -Strukturen stellen die oberen linken, oberen rechten und unteren linken Ecke des Parallelogramms. Der vierte Punkt ist über die ersten drei zu einem Parallelogramm extrapoliert.  
  
 Das Bild, dargestellt durch die `image` Parameter skaliert und entsprechend den vom angegebenen Parallelogramm verbogen ist die `destPoints` Parameter.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein Image aus einem JPEG-Datei SampImag.jpg im Ordner "des Beispiels".  
  
-   Erstellt die Punkte, die ein Parallelogramm in der zum Zeichnen des Bilds zu definieren.  
  
-   Zeichnet das Bild auf dem Bildschirm an.  
  
 Die Position des Parallelogramms sucht das Bild auf dem Bildschirm und die Größe des ursprünglichen Bilds sowie die Größe und Form des Parallelogramms bestimmt die Skalierung des gezeichneten Bilds.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#35](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#35)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#35](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#35)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#35](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="image" /> ist <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.PointF point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.PointF point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.PointF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, System::Drawing::PointF point);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.PointF -&gt; unit" Usage="graphics.DrawImage (image, point)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="point" Type="System.Drawing.PointF" />
      </Parameters>
      <Docs>
        <param name="image">Der zu zeichnende <see cref="T:System.Drawing.Image" />.</param>
        <param name="point">
          <see cref="T:System.Drawing.PointF" />-Struktur, die die obere linke Ecke des gezeichneten Bildes darstellt.</param>
        <summary>Zeichnet das angegebene <see cref="T:System.Drawing.Image" /> in seiner ursprünglichen physischen Größe an der angegebenen Position.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Drawing.Image> speichert einen Wert für die Breite in Pixel und einen Wert für die horizontale Auflösung (dpi). Die physische Breite, gemessen in Zoll eines Bilds wird geteilt durch die horizontale Auflösung Breite in Pixel. Ein Bild mit einer Breite von 216 Pixel und einer horizontalen Auflösung von 72 Punkte pro Zoll hat z. B. eine physische Breite von 3 Zoll. Ähnliche Hinweise gelten für die Höhe in Pixel und die physische Höhe.  
  
 Diese Methode zeichnet ein Bild in seiner physischen Größe hat also das Image die richtige Größe in Zoll, unabhängig von der Auflösung (dpi) des Anzeigegeräts. Nehmen wir beispielsweise an, dass ein Bild einer Breite von 216 Pixel und einer horizontalen Auflösung von 72 Punkte pro Zoll sind. Wenn Sie diese Methode rufen, um das Image auf einem Gerät zu zeichnen, die eine Auflösung von 96 DPI-Wert aufweist, werden die Pixelbreite des gerenderten Bilds (216/72 Zoll) * 96 = 288.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein Image aus einem JPEG-Datei SampImag.jpg im Ordner "des Beispiels".  
  
-   Erstellt einen Punkt, an dem der oberen linken Ecke des Bilds gezeichnet werden soll.  
  
-   Zeichnet das Bild auf dem Bildschirm an.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#40](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#40)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#40](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#40)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#40](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#40)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="image" /> ist <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.PointF[] destPoints);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.PointF[] destPoints) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.PointF[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, cli::array &lt;System::Drawing::PointF&gt; ^ destPoints);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.PointF[] -&gt; unit" Usage="graphics.DrawImage (image, destPoints)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destPoints" Type="System.Drawing.PointF[]" />
      </Parameters>
      <Docs>
        <param name="image">Der zu zeichnende <see cref="T:System.Drawing.Image" />.</param>
        <param name="destPoints">Array von drei <see cref="T:System.Drawing.PointF" />-Strukturen, die ein Parallelogramm definieren.</param>
        <summary>Zeichnet das angegebene <see cref="T:System.Drawing.Image" /> an der angegebenen Position und in der angegebenen Form und Größe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `destPoints` Parameter gibt die drei Punkte eines Parallelogramms an. Die drei <xref:System.Drawing.PointF> -Strukturen stellen die oberen linken, oberen rechten und unteren linken Ecke des Parallelogramms. Der vierte Punkt ist über die ersten drei zu einem Parallelogramm extrapoliert.  
  
 Das Bild, dargestellt durch die `image` Objekt ist skaliert und entsprechend den vom angegebenen Parallelogramm verbogen der `destPoints` Parameter.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein Image aus einem JPEG-Datei SampImag.jpg im Ordner "des Beispiels".  
  
-   Erstellt die Punkte, die ein Parallelogramm in der zum Zeichnen des Bilds zu definieren.  
  
-   Zeichnet das Bild auf dem Bildschirm an.  
  
 Die Position des Parallelogramms sucht das Bild auf dem Bildschirm und die Größe des ursprünglichen Bilds sowie die Größe und Form des Parallelogramms bestimmt die Skalierung des gezeichneten Bilds.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#41](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#41)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#41](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#41)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#41](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="image" /> ist <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.Rectangle rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.Rectangle rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, System::Drawing::Rectangle rect);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.Rectangle -&gt; unit" Usage="graphics.DrawImage (image, rect)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="image">Der zu zeichnende <see cref="T:System.Drawing.Image" />.</param>
        <param name="rect">
          <see cref="T:System.Drawing.Rectangle" />-Struktur, die die Position und Größe des gezeichneten Bildes angibt.</param>
        <summary>Zeichnet das angegebene <see cref="T:System.Drawing.Image" /> in der angegebenen Größe an der angegebenen Position.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Bild, dargestellt durch die `image` Objekt wird an die Abmessungen des skaliert die `rect` Rechteck.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein Image aus einem JPEG-Datei SampImag.jpg im Ordner "des Beispiels".  
  
-   Erstellt ein Rechteck, in dem das Bild gezeichnet werden soll.  
  
-   Zeichnet das Bild auf dem Bildschirm an.  
  
 Die Position des Rechtecks sucht das Bild auf dem Bildschirm, und die Größe des ursprünglichen Bilds und die Größe des Rechtecks bestimmt die Skalierung des gezeichneten Bilds.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#46](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#46)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#46](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#46)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#46](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#46)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="image" /> ist <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.RectangleF rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.RectangleF rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.RectangleF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, System::Drawing::RectangleF rect);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.RectangleF -&gt; unit" Usage="graphics.DrawImage (image, rect)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="rect" Type="System.Drawing.RectangleF" />
      </Parameters>
      <Docs>
        <param name="image">Der zu zeichnende <see cref="T:System.Drawing.Image" />.</param>
        <param name="rect">
          <see cref="T:System.Drawing.RectangleF" />-Struktur, die die Position und Größe des gezeichneten Bildes angibt.</param>
        <summary>Zeichnet das angegebene <see cref="T:System.Drawing.Image" /> in der angegebenen Größe an der angegebenen Position.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Bild, dargestellt durch die `image` Objekt wird an die Abmessungen des skaliert die `rect` Rechteck.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein Image aus einem JPEG-Datei SampImag.jpg im Ordner "des Beispiels".  
  
-   Erstellt ein Rechteck, in dem das Bild gezeichnet werden soll.  
  
-   Zeichnet das Bild auf dem Bildschirm an.  
  
 Die Position des Rechtecks sucht das Bild auf dem Bildschirm, und die ursprüngliche Größe des Abbilds und die Größe des Rechtecks bestimmt die Skalierung des gezeichneten Bilds.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#56](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#56)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#56](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#56)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#56](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#56)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="image" /> ist <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, int x, int y);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, int32 x, int32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, int x, int y);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * int * int -&gt; unit" Usage="graphics.DrawImage (image, x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="image">Der zu zeichnende <see cref="T:System.Drawing.Image" />.</param>
        <param name="x">Die x-Koordinate der oberen linken Ecke des gezeichneten Bilds.</param>
        <param name="y">Die y-Koordinate der oberen linken Ecke des gezeichneten Bilds.</param>
        <summary>Zeichnet das angegebene Bild in seiner ursprünglichen physischen Größe an der von einem Koordinatenpaar angegebenen Position.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Drawing.Image> speichert einen Wert für die Breite in Pixel und einen Wert für die horizontale Auflösung (dpi). Die physische Breite, gemessen in Zoll eines Bilds wird geteilt durch die horizontale Auflösung Breite in Pixel. Ein Bild mit einer Breite von 216 Pixel und einer horizontalen Auflösung von 72 Punkte pro Zoll hat z. B. eine physische Breite von 3 Zoll. Ähnliche Hinweise gelten für die Höhe in Pixel und die physische Höhe.  
  
 Die <xref:System.Drawing.Graphics.DrawImage%2A> Methode zeichnet ein Bild in seiner physischen Größe hat also das Image die richtige Größe in Zoll, unabhängig von der Auflösung (dpi) des Anzeigegeräts. Nehmen wir beispielsweise an, dass ein Bild einer Breite von 216 Pixel und einer horizontalen Auflösung von 72 Punkte pro Zoll sind. Wenn Sie aufrufen <xref:System.Drawing.Graphics.DrawImage%2A> um dieses Image auf einem Gerät zu zeichnen, die eine Auflösung von 96 DPI-Wert aufweist, werden die Pixelbreite des gerenderten Bilds (216/72 Zoll) * 96 = 288.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein Image aus einem JPEG-Datei SampImag.jpg im Ordner "des Beispiels SampImag.jpg im Ordner des Beispiels".  
  
-   Erstellt die Koordinaten eines Punkts, an der die linke obere Ecke des Bilds gezeichnet.  
  
-   Zeichnet das Bild.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#58](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#58)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#58](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#58)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#58](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="image" /> ist <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, float x, float y);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, float32 x, float32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Single,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, float x, float y);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * single * single -&gt; unit" Usage="graphics.DrawImage (image, x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="image">Der zu zeichnende <see cref="T:System.Drawing.Image" />.</param>
        <param name="x">Die x-Koordinate der oberen linken Ecke des gezeichneten Bilds.</param>
        <param name="y">Die y-Koordinate der oberen linken Ecke des gezeichneten Bilds.</param>
        <summary>Zeichnet das angegebene <see cref="T:System.Drawing.Image" /> in seiner ursprünglichen physischen Größe an der angegebenen Position.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Drawing.Image> speichert einen Wert für die Breite in Pixel und einen Wert für die horizontale Auflösung (dpi). Die physische Breite, gemessen in Zoll eines Bilds wird geteilt durch die horizontale Auflösung Breite in Pixel. Ein Bild mit einer Breite von 216 Pixel und einer horizontalen Auflösung von 72 Punkte pro Zoll hat z. B. eine physische Breite von 3 Zoll. Ähnliche Hinweise gelten für die Höhe in Pixel und die physische Höhe.  
  
 Diese Methode zeichnet ein Bild in seiner physischen Größe hat also das Image die richtige Größe in Zoll, unabhängig von der Auflösung (dpi) des Anzeigegeräts. Nehmen wir beispielsweise an, dass ein Bild einer Breite von 216 Pixel und einer horizontalen Auflösung von 72 Punkte pro Zoll sind. Wenn Sie diese Methode rufen, um das Image auf einem Gerät zu zeichnen, die eine Auflösung von 96 DPI-Wert aufweist, werden die Pixelbreite des gerenderten Bilds (216/72 Zoll) * 96 = 288.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein Image aus einem JPEG-Datei SampImag.jpg im Ordner "des Beispiels".  
  
-   Erstellt die Koordinaten eines Punkts, an der die linke obere Ecke des Bilds gezeichnet.  
  
-   Zeichnet das Bild auf dem Bildschirm an.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#61](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#61)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#61](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#61)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#61](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#61)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="image" /> ist <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.Point[] destPoints, System.Drawing.Rectangle srcRect, System.Drawing.GraphicsUnit srcUnit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.Point[] destPoints, valuetype System.Drawing.Rectangle srcRect, valuetype System.Drawing.GraphicsUnit srcUnit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Point[],System.Drawing.Rectangle,System.Drawing.GraphicsUnit)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, cli::array &lt;System::Drawing::Point&gt; ^ destPoints, System::Drawing::Rectangle srcRect, System::Drawing::GraphicsUnit srcUnit);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.Point[] * System.Drawing.Rectangle * System.Drawing.GraphicsUnit -&gt; unit" Usage="graphics.DrawImage (image, destPoints, srcRect, srcUnit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destPoints" Type="System.Drawing.Point[]" />
        <Parameter Name="srcRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
      </Parameters>
      <Docs>
        <param name="image">Der zu zeichnende <see cref="T:System.Drawing.Image" />.</param>
        <param name="destPoints">Array von drei <see cref="T:System.Drawing.Point" />-Strukturen, die ein Parallelogramm definieren.</param>
        <param name="srcRect">
          <see cref="T:System.Drawing.Rectangle" />-Struktur, die den zu zeichnenden Teil des <paramref name="image" />-Objekts angibt.</param>
        <param name="srcUnit">Member der <see cref="T:System.Drawing.GraphicsUnit" />-Enumeration, der die Maßeinheiten für den <paramref name="srcRect" />-Parameter angibt.</param>
        <summary>Zeichnet den angegebenen Bereich vom angegebenen <see cref="T:System.Drawing.Image" /> in der angegebenen Größe an der angegebenen Position.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `destPoints` Parameter gibt die drei Punkte eines Parallelogramms an. Die drei <xref:System.Drawing.Point> -Strukturen stellen die oberen linken, oberen rechten und unteren linken Ecke des Parallelogramms. Der vierte Punkt ist über die ersten drei zu einem Parallelogramm extrapoliert.  
  
 Die `srcRect` Parameter gibt an, einen rechteckigen Bereich des der `image` Objekt, das gezeichnet werden soll. Dieser Teil wird skaliert und entsprechend in das angegebene vom Parallelogramm verbogen der `destPoints` Parameter.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein Image aus einem JPEG-Datei SampImag.jpg im Ordner "des Beispiels".  
  
-   Erstellt die Punkte, die ein Parallelogramm in der zum Zeichnen des Bilds zu definieren.  
  
-   Erstellt ein Rechteck um den Teil der zu zeichnende Bild auszuwählen.  
  
-   Legt fest, die Grafiken, Einheit und Pixel zeichnen.  
  
-   Zeichnet das Bild auf dem Bildschirm an.  
  
 Die Position des Parallelogramms sucht das Bild auf dem Bildschirm und die Größe des Rechtecks und der Größe und Form des Parallelogramms bestimmt die Skalierung des gezeichneten Bilds.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#36](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#36)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#36](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#36)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#36](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#36)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="image" /> ist <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.PointF[] destPoints, System.Drawing.RectangleF srcRect, System.Drawing.GraphicsUnit srcUnit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.PointF[] destPoints, valuetype System.Drawing.RectangleF srcRect, valuetype System.Drawing.GraphicsUnit srcUnit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.PointF[],System.Drawing.RectangleF,System.Drawing.GraphicsUnit)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, cli::array &lt;System::Drawing::PointF&gt; ^ destPoints, System::Drawing::RectangleF srcRect, System::Drawing::GraphicsUnit srcUnit);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.PointF[] * System.Drawing.RectangleF * System.Drawing.GraphicsUnit -&gt; unit" Usage="graphics.DrawImage (image, destPoints, srcRect, srcUnit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destPoints" Type="System.Drawing.PointF[]" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
      </Parameters>
      <Docs>
        <param name="image">Der zu zeichnende <see cref="T:System.Drawing.Image" />.</param>
        <param name="destPoints">Array von drei <see cref="T:System.Drawing.PointF" />-Strukturen, die ein Parallelogramm definieren.</param>
        <param name="srcRect">
          <see cref="T:System.Drawing.RectangleF" />-Struktur, die den zu zeichnenden Teil des <paramref name="image" />-Objekts angibt.</param>
        <param name="srcUnit">Member der <see cref="T:System.Drawing.GraphicsUnit" />-Enumeration, der die Maßeinheiten für den <paramref name="srcRect" />-Parameter angibt.</param>
        <summary>Zeichnet den angegebenen Bereich vom angegebenen <see cref="T:System.Drawing.Image" /> in der angegebenen Größe an der angegebenen Position.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `destPoints` Parameter gibt die drei Punkte eines Parallelogramms an. Die drei <xref:System.Drawing.PointF> -Strukturen stellen die oberen linken, oberen rechten und unteren linken Ecke des Parallelogramms. Der vierte Punkt ist über die ersten drei zu einem Parallelogramm extrapoliert.  
  
 Die `srcRect` Parameter gibt an, einen rechteckigen Bereich des der `image` Objekt, das gezeichnet werden soll. Dieser Teil wird skaliert und entsprechend in das angegebene vom Parallelogramm verbogen der `destPoints` Parameter.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein Image aus einem JPEG-Datei SampImag.jpg im Ordner "des Beispiels".  
  
-   Erstellt die Punkte, die ein Zielparallelogramm in der zum Zeichnen des Bilds zu definieren.  
  
-   Erstellt ein Quellrechteck, aus denen einen Teil des Bilds extrahiert.  
  
-   Die Maßeinheit des Quellrechtecks festgelegt auf Pixel.  
  
-   Zeichnet das Bild auf dem Bildschirm an.  
  
 Die Position des Zielparallelogramms sucht das Bild auf dem Bildschirm, die Größe des Quellrechtecks sowie die Größe und Form des Zielparallelogramms bestimmt die Skalierung des gezeichneten Bildes und die Größe des Rechtecks bestimmt. welcher Teil des ursprünglichen Bilds auf dem Bildschirm gezeichnet wird.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#42](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#42)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#42](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#42)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#42](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="image" /> ist <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.Rectangle destRect, System.Drawing.Rectangle srcRect, System.Drawing.GraphicsUnit srcUnit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.Rectangle destRect, valuetype System.Drawing.Rectangle srcRect, valuetype System.Drawing.GraphicsUnit srcUnit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Rectangle,System.Drawing.Rectangle,System.Drawing.GraphicsUnit)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, System::Drawing::Rectangle destRect, System::Drawing::Rectangle srcRect, System::Drawing::GraphicsUnit srcUnit);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.Rectangle * System.Drawing.Rectangle * System.Drawing.GraphicsUnit -&gt; unit" Usage="graphics.DrawImage (image, destRect, srcRect, srcUnit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
      </Parameters>
      <Docs>
        <param name="image">Der zu zeichnende <see cref="T:System.Drawing.Image" />.</param>
        <param name="destRect">
          <see cref="T:System.Drawing.Rectangle" />-Struktur, die die Position und Größe des gezeichneten Bildes angibt. Das Bild wird skaliert, sodass es in das Rechteck passt.</param>
        <param name="srcRect">
          <see cref="T:System.Drawing.Rectangle" />-Struktur, die den zu zeichnenden Teil des <paramref name="image" />-Objekts angibt.</param>
        <param name="srcUnit">Member der <see cref="T:System.Drawing.GraphicsUnit" />-Enumeration, der die Maßeinheiten für den <paramref name="srcRect" />-Parameter angibt.</param>
        <summary>Zeichnet den angegebenen Bereich vom angegebenen <see cref="T:System.Drawing.Image" /> in der angegebenen Größe an der angegebenen Position.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `srcRect` Parameter gibt an, einen rechteckigen Bereich des der `image` Objekt, das gezeichnet werden soll. In diesem Teil wird skaliert, um in das vom angegebenen Rechteck passt die `destRect` Parameter.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein Image aus einem JPEG-Datei SampImag.jpg im Ordner "des Beispiels".  
  
-   Erstellt ein Zielrechteck, in dem das Bild gezeichnet werden soll.  
  
-   Erstellt ein Quellrechteck, aus denen einen Teil des Bilds extrahiert.  
  
-   Die Maßeinheit des Quellrechtecks festgelegt auf Pixel.  
  
-   Zeichnet das Bild auf dem Bildschirm an.  
  
 Die Position des Zielrechtecks sucht das Bild auf dem Bildschirm, den Größen der Rechtecke Quelle und Ziel zu bestimmen, die Skalierung des gezeichneten Bildes und die Größe des Quellrechtecks bestimmt, welcher Teil des ursprünglichen Bilds gezeichnet wird, um die der Bildschirm.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#47](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#47)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#47](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#47)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#47](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#47)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="image" /> ist <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.RectangleF destRect, System.Drawing.RectangleF srcRect, System.Drawing.GraphicsUnit srcUnit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.RectangleF destRect, valuetype System.Drawing.RectangleF srcRect, valuetype System.Drawing.GraphicsUnit srcUnit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.RectangleF,System.Drawing.RectangleF,System.Drawing.GraphicsUnit)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, System::Drawing::RectangleF destRect, System::Drawing::RectangleF srcRect, System::Drawing::GraphicsUnit srcUnit);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.RectangleF * System.Drawing.RectangleF * System.Drawing.GraphicsUnit -&gt; unit" Usage="graphics.DrawImage (image, destRect, srcRect, srcUnit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
      </Parameters>
      <Docs>
        <param name="image">Der zu zeichnende <see cref="T:System.Drawing.Image" />.</param>
        <param name="destRect">
          <see cref="T:System.Drawing.RectangleF" />-Struktur, die die Position und Größe des gezeichneten Bildes angibt. Das Bild wird skaliert, sodass es in das Rechteck passt.</param>
        <param name="srcRect">
          <see cref="T:System.Drawing.RectangleF" />-Struktur, die den zu zeichnenden Teil des <paramref name="image" />-Objekts angibt.</param>
        <param name="srcUnit">Member der <see cref="T:System.Drawing.GraphicsUnit" />-Enumeration, der die Maßeinheiten für den <paramref name="srcRect" />-Parameter angibt.</param>
        <summary>Zeichnet den angegebenen Bereich vom angegebenen <see cref="T:System.Drawing.Image" /> in der angegebenen Größe an der angegebenen Position.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `srcRect` Parameter gibt an, einen rechteckigen Bereich des der `image` Objekt, das gezeichnet werden soll. In diesem Teil wird skaliert, um in das vom angegebenen Rechteck passt die `destRect` Parameter.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein Image aus einem JPEG-Datei SampImag.jpg im Ordner "des Beispiels".  
  
-   Erstellt ein Zielrechteck, in dem das Bild gezeichnet werden soll.  
  
-   Erstellt ein Quellrechteck, aus denen einen Teil des Bilds extrahiert.  
  
-   Die Maßeinheit des Quellrechtecks festgelegt auf Pixel.  
  
-   Zeichnet das Bild auf dem Bildschirm an.  
  
 Die Position des Zielrechtecks sucht das Bild auf dem Bildschirm, den Größen der Rechtecke Quelle und Ziel zu bestimmen, die Skalierung des gezeichneten Bildes und die Größe des Quellrechtecks bestimmt, welcher Teil des ursprünglichen Bilds gezeichnet wird, um die der Bildschirm.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#57](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#57)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#57](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#57)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#57](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#57)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="image" /> ist <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.Point[] destPoints, System.Drawing.Rectangle srcRect, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Imaging.ImageAttributes imageAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.Point[] destPoints, valuetype System.Drawing.Rectangle srcRect, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Imaging.ImageAttributes imageAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Point[],System.Drawing.Rectangle,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, cli::array &lt;System::Drawing::Point&gt; ^ destPoints, System::Drawing::Rectangle srcRect, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Imaging::ImageAttributes ^ imageAttr);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.Point[] * System.Drawing.Rectangle * System.Drawing.GraphicsUnit * System.Drawing.Imaging.ImageAttributes -&gt; unit" Usage="graphics.DrawImage (image, destPoints, srcRect, srcUnit, imageAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destPoints" Type="System.Drawing.Point[]" />
        <Parameter Name="srcRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
      </Parameters>
      <Docs>
        <param name="image">Der zu zeichnende <see cref="T:System.Drawing.Image" />.</param>
        <param name="destPoints">Array von drei <see cref="T:System.Drawing.Point" />-Strukturen, die ein Parallelogramm definieren.</param>
        <param name="srcRect">
          <see cref="T:System.Drawing.Rectangle" />-Struktur, die den zu zeichnenden Teil des <paramref name="image" />-Objekts angibt.</param>
        <param name="srcUnit">Member der <see cref="T:System.Drawing.GraphicsUnit" />-Enumeration, der die Maßeinheiten für den <paramref name="srcRect" />-Parameter angibt.</param>
        <param name="imageAttr">
          <see cref="T:System.Drawing.Imaging.ImageAttributes" />, das Informationen über erneutes Einfärben und Gammainformationen für das <paramref name="image" />-Objekt angibt.</param>
        <summary>Zeichnet den angegebenen Teil vom angegebenen <see cref="T:System.Drawing.Image" /> an der angegebenen Position.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `destPoints` Parameter gibt die drei Punkte eines Parallelogramms an. Die drei <xref:System.Drawing.Point> -Strukturen stellen die oberen linken, oberen rechten und unteren linken Ecke des Parallelogramms. Der vierte Punkt ist über die ersten drei zu einem Parallelogramm extrapoliert.  
  
 Die `srcRect` Parameter gibt an, einen rechteckigen Bereich des der`image` Objekt, das gezeichnet werden soll. Dieser Teil wird skaliert und entsprechend in das angegebene vom Parallelogramm verbogen der `destPoints` Parameter.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein Image aus einem JPEG-Datei SampImag.jpg im Ordner "des Beispiels".  
  
-   Erstellt die Punkte, die ein Parallelogramm in der zum Zeichnen des Bilds zu definieren.  
  
-   Erstellt ein Rechteck um den Teil der zu zeichnende Bild auszuwählen.  
  
-   Legt fest, die Grafiken, Einheit und Pixel zeichnen.  
  
-   Zeichnet das ursprüngliche Bild auf dem Bildschirm an.  
  
-   Erstellt ein zusätzliches Parallelogramm in der ein angepasstes Bild gezeichnet werden soll.  
  
-   Erstellt und legt die Attribute des Bildes, das größer als üblich Gamma Wert angepasst.  
  
-   Zeichnet das angepasste Bild auf dem Bildschirm an.  
  
 Für die ursprünglichen, nicht angepassten Parallelogramm die Position sucht das Bild auf dem Bildschirm und die Größe des Rechtecks und der Größe und Form des Parallelogramms bestimmt die Skalierung des gezeichneten Bilds.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#37](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#37)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#37](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#37)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#37](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#37)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="image" /> ist <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.PointF[] destPoints, System.Drawing.RectangleF srcRect, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Imaging.ImageAttributes imageAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.PointF[] destPoints, valuetype System.Drawing.RectangleF srcRect, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Imaging.ImageAttributes imageAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.PointF[],System.Drawing.RectangleF,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, cli::array &lt;System::Drawing::PointF&gt; ^ destPoints, System::Drawing::RectangleF srcRect, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Imaging::ImageAttributes ^ imageAttr);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.PointF[] * System.Drawing.RectangleF * System.Drawing.GraphicsUnit * System.Drawing.Imaging.ImageAttributes -&gt; unit" Usage="graphics.DrawImage (image, destPoints, srcRect, srcUnit, imageAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destPoints" Type="System.Drawing.PointF[]" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
      </Parameters>
      <Docs>
        <param name="image">Der zu zeichnende <see cref="T:System.Drawing.Image" />.</param>
        <param name="destPoints">Array von drei <see cref="T:System.Drawing.PointF" />-Strukturen, die ein Parallelogramm definieren.</param>
        <param name="srcRect">
          <see cref="T:System.Drawing.RectangleF" />-Struktur, die den zu zeichnenden Teil des <paramref name="image" />-Objekts angibt.</param>
        <param name="srcUnit">Member der <see cref="T:System.Drawing.GraphicsUnit" />-Enumeration, der die Maßeinheiten für den <paramref name="srcRect" />-Parameter angibt.</param>
        <param name="imageAttr">
          <see cref="T:System.Drawing.Imaging.ImageAttributes" />, das Informationen über erneutes Einfärben und Gammainformationen für das <paramref name="image" />-Objekt angibt.</param>
        <summary>Zeichnet den angegebenen Bereich vom angegebenen <see cref="T:System.Drawing.Image" /> in der angegebenen Größe an der angegebenen Position.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `destPoints` Parameter gibt die drei Punkte eines Parallelogramms an. Die drei <xref:System.Drawing.PointF> -Strukturen stellen die oberen linken, oberen rechten und unteren linken Ecke des Parallelogramms. Der vierte Punkt ist über die ersten drei zu einem Parallelogramm extrapoliert.  
  
 Die `srcRect` Parameter gibt an, einen rechteckigen Bereich des der `image` Objekt, das gezeichnet werden soll. Dieser Teil wird skaliert und entsprechend in das angegebene vom Parallelogramm verbogen der `destPoints` Parameter.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein Image aus einem JPEG-Datei SampImag.jpg im Ordner "des Beispiels".  
  
-   Erstellt die Punkte, die ein Zielparallelogramm in der zum Zeichnen des Bilds zu definieren.  
  
-   Erstellt ein Quellrechteck, aus denen einen Teil des Bilds extrahiert.  
  
-   Die Maßeinheit des Quellrechtecks festgelegt auf Pixel.  
  
-   Zeichnet das ursprüngliche Bild auf dem Bildschirm an.  
  
-   Erstellt ein zusätzliches Parallelogramm in der ein angepasstes Bild gezeichnet werden soll.  
  
-   Erstellt und legt die Attribute des Bildes, das größer als üblich Gamma Wert angepasst.  
  
-   Zeichnet das angepasste Bild auf dem Bildschirm an.  
  
 Für die ursprünglichen, nicht angepassten Parallelogramm, sucht die Position des Images auf dem Bildschirm, die Größe des Quellrechtecks und die Größe und das Ziel Parallelogramm bestimmt die Skalierung des gezeichneten Bildes und der Größe der der Rechteck bestimmt, welcher Teil des ursprünglichen Bilds auf dem Bildschirm gezeichnet wird.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#43](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#43)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#43](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#43)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#43](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#43)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="image" /> ist <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, int x, int y, System.Drawing.Rectangle srcRect, System.Drawing.GraphicsUnit srcUnit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, int32 x, int32 y, valuetype System.Drawing.Rectangle srcRect, valuetype System.Drawing.GraphicsUnit srcUnit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Int32,System.Int32,System.Drawing.Rectangle,System.Drawing.GraphicsUnit)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, int x, int y, System::Drawing::Rectangle srcRect, System::Drawing::GraphicsUnit srcUnit);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * int * int * System.Drawing.Rectangle * System.Drawing.GraphicsUnit -&gt; unit" Usage="graphics.DrawImage (image, x, y, srcRect, srcUnit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="srcRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
      </Parameters>
      <Docs>
        <param name="image">Der zu zeichnende <see cref="T:System.Drawing.Image" />.</param>
        <param name="x">Die x-Koordinate der oberen linken Ecke des gezeichneten Bilds.</param>
        <param name="y">Die y-Koordinate der oberen linken Ecke des gezeichneten Bilds.</param>
        <param name="srcRect">
          <see cref="T:System.Drawing.Rectangle" />-Struktur, die den zu zeichnenden Teil des <paramref name="image" />-Objekts angibt.</param>
        <param name="srcUnit">Member der <see cref="T:System.Drawing.GraphicsUnit" />-Enumeration, der die Maßeinheiten für den <paramref name="srcRect" />-Parameter angibt.</param>
        <summary>Zeichnet einen Teil eines Bildes an einer angegebenen Position.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Drawing.Image> speichert einen Wert für die Breite in Pixel und einen Wert für die horizontale Auflösung (dpi). Die physische Breite, gemessen in Zoll eines Bilds wird geteilt durch die horizontale Auflösung Breite in Pixel. Ein Bild mit einer Breite von 360 Pixel und einer horizontalen Auflösung von 72 Punkte pro Zoll hat z. B. eine physische Breite von 5 Zoll. Ähnliche Hinweise gelten für die Höhe in Pixel und die physische Höhe.  
  
 Diese Methode zeichnet einen Teil eines Abbilds mithilfe von der physischen Größe hat also der Teil des Image die richtige Größe in Zoll, unabhängig von der Auflösung (dpi) des Anzeigegeräts. Nehmen wir beispielsweise an, dass ein Teil eines Bildes eine Breite von 216 Pixel und einer horizontalen Auflösung von 72 Punkte pro Zoll sind. Wenn Sie diese Methode rufen, um diesen Teil des Image auf einem Gerät zu zeichnen, die eine Auflösung von 96 DPI-Wert aufweist, werden die Pixelbreite des gerenderten Bilds Teils (216/72 Zoll) * 96 = 288.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein Image aus einem JPEG-Datei SampImag.jpg im Ordner "des Beispiels".  
  
-   Erstellt die Koordinaten, an der die linke obere Ecke des Bilds gezeichnet.  
  
-   Erstellt ein Quellrechteck, aus denen einen Teil des Bilds extrahiert.  
  
-   Die Maßeinheit des Quellrechtecks festgelegt auf Pixel.  
  
-   Zeichnet das Bild auf dem Bildschirm an.  
  
 Die Größe des Quellrechtecks bestimmt, welcher Teil des ursprünglichen Bilds auf dem Bildschirm gezeichnet wird.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#59](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#59)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#59](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#59)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#59](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#59)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="image" /> ist <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, int x, int y, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, int32 x, int32 y, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, int x, int y, int width, int height);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * int * int * int * int -&gt; unit" Usage="graphics.DrawImage (image, x, y, width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="image">Der zu zeichnende <see cref="T:System.Drawing.Image" />.</param>
        <param name="x">Die x-Koordinate der oberen linken Ecke des gezeichneten Bilds.</param>
        <param name="y">Die y-Koordinate der oberen linken Ecke des gezeichneten Bilds.</param>
        <param name="width">Breite des gezeichneten Bilds.</param>
        <param name="height">Höhe des gezeichneten Bilds.</param>
        <summary>Zeichnet das angegebene <see cref="T:System.Drawing.Image" /> in der angegebenen Größe an der angegebenen Position.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Rechteck definiert, durch die `x`, `y`, `width`, und `height` Parameter bestimmt die Position und Größe des gezeichneten Bilds.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein Image aus einem JPEG-Datei SampImag.jpg im Ordner "des Beispiels".  
  
-   Erstellt die Position und Größe eines Rechtecks, in dem das Bild gezeichnet werden soll.  
  
-   Zeichnet das Bild auf dem Bildschirm an.  
  
 Die Position des Rechtecks sucht das Bild auf dem Bildschirm, und die Größe des ursprünglichen Bilds und die Größe des Rechtecks bestimmt die Skalierung des gezeichneten Bilds.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#60](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#60)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#60](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#60)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#60](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#60)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="image" /> ist <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, float x, float y, System.Drawing.RectangleF srcRect, System.Drawing.GraphicsUnit srcUnit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, float32 x, float32 y, valuetype System.Drawing.RectangleF srcRect, valuetype System.Drawing.GraphicsUnit srcUnit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Single,System.Single,System.Drawing.RectangleF,System.Drawing.GraphicsUnit)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, float x, float y, System::Drawing::RectangleF srcRect, System::Drawing::GraphicsUnit srcUnit);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * single * single * System.Drawing.RectangleF * System.Drawing.GraphicsUnit -&gt; unit" Usage="graphics.DrawImage (image, x, y, srcRect, srcUnit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
      </Parameters>
      <Docs>
        <param name="image">Der zu zeichnende <see cref="T:System.Drawing.Image" />.</param>
        <param name="x">Die x-Koordinate der oberen linken Ecke des gezeichneten Bilds.</param>
        <param name="y">Die y-Koordinate der oberen linken Ecke des gezeichneten Bilds.</param>
        <param name="srcRect">
          <see cref="T:System.Drawing.RectangleF" />-Struktur, die den zu zeichnenden Teil vom <see cref="T:System.Drawing.Image" /> angibt.</param>
        <param name="srcUnit">Member der <see cref="T:System.Drawing.GraphicsUnit" />-Enumeration, der die Maßeinheiten für den <paramref name="srcRect" />-Parameter angibt.</param>
        <summary>Zeichnet einen Teil eines Bildes an einer angegebenen Position.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Drawing.Image> speichert einen Wert für die Breite in Pixel und einen Wert für die horizontale Auflösung (dpi). Die physische Breite, gemessen in Zoll eines Bilds wird geteilt durch die horizontale Auflösung Breite in Pixel. Ein Bild mit einer Breite von 360 Pixel und einer horizontalen Auflösung von 72 Punkte pro Zoll hat z. B. eine physische Breite von 5 Zoll. Ähnliche Hinweise gelten für die Höhe in Pixel und die physische Höhe.  
  
 Diese Methode zeichnet einen Teil eines Abbilds mithilfe von der physischen Größe hat also der Teil des Image die richtige Größe in Zoll, unabhängig von der Auflösung (dpi) des Anzeigegeräts. Nehmen wir beispielsweise an, dass ein Teil eines Bildes eine Breite von 216 Pixel und einer horizontalen Auflösung von 72 Punkte pro Zoll sind. Wenn Sie diese Methode rufen, um diesen Teil des Image auf einem Gerät zu zeichnen, die eine Auflösung von 96 DPI-Wert aufweist, werden die Pixelbreite des gerenderten Bilds Teils (216/72 Zoll) * 96 = 288.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein Image aus einem JPEG-Datei SampImag.jpg im Ordner "des Beispiels".  
  
-   Erstellt die Koordinaten, an der die linke obere Ecke des Bilds gezeichnet.  
  
-   Erstellt ein Quellrechteck, aus denen einen Teil des Bilds extrahiert.  
  
-   Die Maßeinheit des Quellrechtecks festgelegt auf Pixel.  
  
-   Zeichnet das Bild auf dem Bildschirm an.  
  
 Die Größe des Quellrechtecks bestimmt, welcher Teil des ursprünglichen Bilds auf dem Bildschirm gezeichnet wird.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#62](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#62)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#62](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#62)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#62](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#62)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="image" /> ist <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, float x, float y, float width, float height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, float32 x, float32 y, float32 width, float32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Single,System.Single,System.Single,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, float x, float y, float width, float height);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * single * single * single * single -&gt; unit" Usage="graphics.DrawImage (image, x, y, width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="width" Type="System.Single" />
        <Parameter Name="height" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="image">Der zu zeichnende <see cref="T:System.Drawing.Image" />.</param>
        <param name="x">Die x-Koordinate der oberen linken Ecke des gezeichneten Bilds.</param>
        <param name="y">Die y-Koordinate der oberen linken Ecke des gezeichneten Bilds.</param>
        <param name="width">Breite des gezeichneten Bilds.</param>
        <param name="height">Höhe des gezeichneten Bilds.</param>
        <summary>Zeichnet das angegebene <see cref="T:System.Drawing.Image" /> in der angegebenen Größe an der angegebenen Position.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Rechteck definiert, durch die `x`, `y`, `width`, und `height` Parameter bestimmt die Position und Größe des gezeichneten Bilds.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein Image aus einem JPEG-Datei SampImag.jpg im Ordner "des Beispiels".  
  
-   Erstellt die Position und Größe eines Rechtecks, in dem das Bild gezeichnet werden soll.  
  
-   Zeichnet das Bild auf dem Bildschirm an.  
  
 Die Position des Rechtecks sucht das Bild auf dem Bildschirm, und die Größe des ursprünglichen Bilds und die Größe des Rechtecks bestimmt die Skalierung des gezeichneten Bilds.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#63](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#63)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#63](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#63)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#63](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#63)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="image" /> ist <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.Point[] destPoints, System.Drawing.Rectangle srcRect, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Imaging.ImageAttributes imageAttr, System.Drawing.Graphics.DrawImageAbort callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.Point[] destPoints, valuetype System.Drawing.Rectangle srcRect, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Imaging.ImageAttributes imageAttr, class System.Drawing.Graphics/DrawImageAbort callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Point[],System.Drawing.Rectangle,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, cli::array &lt;System::Drawing::Point&gt; ^ destPoints, System::Drawing::Rectangle srcRect, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Imaging::ImageAttributes ^ imageAttr, System::Drawing::Graphics::DrawImageAbort ^ callback);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.Point[] * System.Drawing.Rectangle * System.Drawing.GraphicsUnit * System.Drawing.Imaging.ImageAttributes * System.Drawing.Graphics.DrawImageAbort -&gt; unit" Usage="graphics.DrawImage (image, destPoints, srcRect, srcUnit, imageAttr, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destPoints" Type="System.Drawing.Point[]" />
        <Parameter Name="srcRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+DrawImageAbort" />
      </Parameters>
      <Docs>
        <param name="image">Der zu zeichnende <see cref="T:System.Drawing.Image" />.</param>
        <param name="destPoints">Array von drei <see cref="T:System.Drawing.PointF" />-Strukturen, die ein Parallelogramm definieren.</param>
        <param name="srcRect">
          <see cref="T:System.Drawing.Rectangle" />-Struktur, die den zu zeichnenden Teil des <paramref name="image" />-Objekts angibt.</param>
        <param name="srcUnit">Member der <see cref="T:System.Drawing.GraphicsUnit" />-Enumeration, der die Maßeinheiten für den <paramref name="srcRect" />-Parameter angibt.</param>
        <param name="imageAttr">
          <see cref="T:System.Drawing.Imaging.ImageAttributes" />, das Informationen über erneutes Einfärben und Gammainformationen für das <paramref name="image" />-Objekt angibt.</param>
        <param name="callback">
          <see cref="T:System.Drawing.Graphics.DrawImageAbort" />-Delegat, der eine Methode angibt, die während des Zeichnens des Bildes aufgerufen werden soll. Diese Methode wird häufig aufgerufen, um zu prüfen, ob die Ausführung der <see cref="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Point[],System.Drawing.Rectangle,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort)" />-Methode gemäß den durch die Anwendung bestimmten Kriterien abgebrochen werden soll.</param>
        <summary>Zeichnet den angegebenen Bereich vom angegebenen <see cref="T:System.Drawing.Image" /> in der angegebenen Größe an der angegebenen Position.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `destPoints` Parameter gibt die drei Punkte eines Parallelogramms an. Die drei <xref:System.Drawing.PointF> -Strukturen stellen die oberen linken, oberen rechten und unteren linken Ecke des Parallelogramms. Der vierte Punkt ist über die ersten drei zu einem Parallelogramm extrapoliert.  
  
 Die `srcRect` Parameter gibt an, einen rechteckigen Bereich des der `image` Objekt, das gezeichnet werden soll. Dieser Teil wird skaliert und entsprechend in das angegebene vom Parallelogramm verbogen der `destPoints` Parameter.  
  
 Diese Überladung mit den `callback` Parameter bietet die Möglichkeit, die das Zeichnen eines Bilds zu beenden, sobald es gemäß den Kriterien, die von der Anwendung festgelegte gestartet wird. Z. B. Starten einer Anwendung kann ein großes Bild zu zeichnen, und der Benutzer kann das Image aus dem Bildschirm, in dem Fall die Anwendung die Zeichnung Anhalten konnte scrollen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code definiert zuerst eine Rückrufmethode für die <xref:System.Drawing.Graphics.DrawImageAbort> Delegaten; die Definition ist einfach und prüft lediglich, ob die <xref:System.Drawing.Graphics.DrawImage%2A> Methode ruft es mit einer Null- `callBackData` Parameter. Der Hauptteil des Beispiels führt folgende Aktionen aus:  
  
-   Erstellt eine Instanz der <xref:System.Drawing.Graphics.DrawImageAbort> Callback-Methode:  
  
-   Erstellt ein Image aus einem JPEG-Datei SampImag.jpg im Ordner "des Beispiels".  
  
-   Erstellt die Punkte, die ein Parallelogramm in der zum Zeichnen des Bilds zu definieren.  
  
-   Erstellt ein Rechteck um den Teil der zu zeichnende Bild auszuwählen.  
  
-   Legt fest, die Grafiken, Einheit und Pixel zeichnen.  
  
-   Zeichnet das ursprüngliche Bild auf dem Bildschirm an.  
  
-   Erstellt ein zusätzliches Parallelogramm in der ein angepasstes Bild gezeichnet werden soll.  
  
-   Erstellt und legt die Attribute des Bildes, das größer als üblich Gamma Wert angepasst.  
  
-   Zeichnet das angepasste Bild auf dem Bildschirm an.  
  
 Für die ursprünglichen, nicht angepassten Parallelogramm die Position sucht das Bild auf dem Bildschirm und die Größe des Rechtecks und der Größe und Form des Parallelogramms bestimmt die Skalierung des gezeichneten Bilds.  
  
 Da in diesem Beispiel wird eine Überladung verwendet, die nicht bestanden hat eine `callBackData` -Parameter der <xref:System.Drawing.Graphics.DrawImageAbort> des Rückrufs `true`, bewirkt, dass die <xref:System.Drawing.Graphics.DrawImage%2A> Methode to-End und der Code zur Ausnahmebehandlung im Beispielcode enthalten, gibt die Text der Ausnahme und nicht als das Bild zu zeichnen.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#38](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#38)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#38](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#38)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#38](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#38)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="image" /> ist <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.PointF[] destPoints, System.Drawing.RectangleF srcRect, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Imaging.ImageAttributes imageAttr, System.Drawing.Graphics.DrawImageAbort callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.PointF[] destPoints, valuetype System.Drawing.RectangleF srcRect, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Imaging.ImageAttributes imageAttr, class System.Drawing.Graphics/DrawImageAbort callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.PointF[],System.Drawing.RectangleF,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, cli::array &lt;System::Drawing::PointF&gt; ^ destPoints, System::Drawing::RectangleF srcRect, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Imaging::ImageAttributes ^ imageAttr, System::Drawing::Graphics::DrawImageAbort ^ callback);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.PointF[] * System.Drawing.RectangleF * System.Drawing.GraphicsUnit * System.Drawing.Imaging.ImageAttributes * System.Drawing.Graphics.DrawImageAbort -&gt; unit" Usage="graphics.DrawImage (image, destPoints, srcRect, srcUnit, imageAttr, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destPoints" Type="System.Drawing.PointF[]" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+DrawImageAbort" />
      </Parameters>
      <Docs>
        <param name="image">Der zu zeichnende <see cref="T:System.Drawing.Image" />.</param>
        <param name="destPoints">Array von drei <see cref="T:System.Drawing.PointF" />-Strukturen, die ein Parallelogramm definieren.</param>
        <param name="srcRect">
          <see cref="T:System.Drawing.RectangleF" />-Struktur, die den zu zeichnenden Teil des <paramref name="image" />-Objekts angibt.</param>
        <param name="srcUnit">Member der <see cref="T:System.Drawing.GraphicsUnit" />-Enumeration, der die Maßeinheiten für den <paramref name="srcRect" />-Parameter angibt.</param>
        <param name="imageAttr">
          <see cref="T:System.Drawing.Imaging.ImageAttributes" />, das Informationen über erneutes Einfärben und Gammainformationen für das <paramref name="image" />-Objekt angibt.</param>
        <param name="callback">
          <see cref="T:System.Drawing.Graphics.DrawImageAbort" />-Delegat, der eine Methode angibt, die während des Zeichnens des Bildes aufgerufen werden soll. Diese Methode wird häufig aufgerufen, um zu prüfen, ob die Ausführung der <see cref="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.PointF[],System.Drawing.RectangleF,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort)" />-Methode gemäß den durch die Anwendung bestimmten Kriterien abgebrochen werden soll.</param>
        <summary>Zeichnet den angegebenen Bereich vom angegebenen <see cref="T:System.Drawing.Image" /> in der angegebenen Größe an der angegebenen Position.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `destPoints` Parameter gibt die drei Punkte eines Parallelogramms an. Die drei <xref:System.Drawing.PointF> -Strukturen stellen die oberen linken, oberen rechten und unteren linken Ecke des Parallelogramms. Der vierte Punkt ist über die ersten drei zu einem Parallelogramm extrapoliert.  
  
 Die `srcRect` Parameter gibt an, einen rechteckigen Bereich des der `image` Objekt, das gezeichnet werden soll. Dieser Teil wird skaliert und entsprechend in das angegebene vom Parallelogramm verbogen der `destPoints` Parameter.  
  
 Diese Überladung mit den `callback` Parameter bietet die Möglichkeit, die das Zeichnen eines Bilds zu beenden, sobald es gemäß den Kriterien, die von der Anwendung festgelegte gestartet wird. Z. B. Starten einer Anwendung kann ein großes Bild zu zeichnen, und der Benutzer kann das Image aus dem Bildschirm, in dem Fall die Anwendung die Zeichnung Anhalten konnte scrollen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code definiert zuerst eine Rückrufmethode für die <xref:System.Drawing.Graphics.DrawImageAbort> Delegaten; die Definition ist einfach und prüft lediglich, ob die <xref:System.Drawing.Graphics.DrawImage%2A> Methode ruft es mit einer Null- `callBackData` Parameter. Der Hauptteil des Beispiels führt folgende Aktionen aus:  
  
-   Erstellt eine Instanz der <xref:System.Drawing.Graphics.DrawImageAbort> Callback-Methode.  
  
-   Erstellt ein Image aus einem JPEG-Datei SampImag.jpg im Ordner "des Beispiels".  
  
-   Erstellt die Punkte, die ein Parallelogramm in der zum Zeichnen des Bilds zu definieren.  
  
-   Erstellt ein Rechteck um den Teil der zu zeichnende Bild auszuwählen.  
  
-   Legt fest, die Grafiken, Einheit und Pixel zeichnen.  
  
-   Zeichnet das ursprüngliche Bild auf dem Bildschirm an.  
  
-   Erstellt ein zusätzliches Parallelogramm in der ein angepasstes Bild gezeichnet werden soll.  
  
-   Erstellt und legt die Attribute des Bildes, das größer als üblich Gamma Wert angepasst.  
  
-   Zeichnet das angepasste Bild auf dem Bildschirm an.  
  
 Für die ursprünglichen, nicht angepassten Parallelogramm die Position sucht das Bild auf dem Bildschirm und die Größe des Rechtecks und der Größe und Form des Parallelogramms bestimmt die Skalierung des gezeichneten Bilds.  
  
 Da in diesem Beispiel wird eine Überladung verwendet, die nicht bestanden hat eine `callBackData` -Parameter der <xref:System.Drawing.Graphics.DrawImageAbort> des Rückrufs `true`, bewirkt, dass die <xref:System.Drawing.Graphics.DrawImage%2A> Methode to-End und der Code zur Ausnahmebehandlung im Beispielcode enthalten, gibt die Text der Ausnahme und nicht als das Bild zu zeichnen.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#44](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#44)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#44](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#44)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#44](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#44)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="image" /> ist <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.Point[] destPoints, System.Drawing.Rectangle srcRect, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Imaging.ImageAttributes imageAttr, System.Drawing.Graphics.DrawImageAbort callback, int callbackData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.Point[] destPoints, valuetype System.Drawing.Rectangle srcRect, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Imaging.ImageAttributes imageAttr, class System.Drawing.Graphics/DrawImageAbort callback, int32 callbackData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Point[],System.Drawing.Rectangle,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, cli::array &lt;System::Drawing::Point&gt; ^ destPoints, System::Drawing::Rectangle srcRect, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Imaging::ImageAttributes ^ imageAttr, System::Drawing::Graphics::DrawImageAbort ^ callback, int callbackData);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.Point[] * System.Drawing.Rectangle * System.Drawing.GraphicsUnit * System.Drawing.Imaging.ImageAttributes * System.Drawing.Graphics.DrawImageAbort * int -&gt; unit" Usage="graphics.DrawImage (image, destPoints, srcRect, srcUnit, imageAttr, callback, callbackData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destPoints" Type="System.Drawing.Point[]" />
        <Parameter Name="srcRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+DrawImageAbort" />
        <Parameter Name="callbackData" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="image">Der zu zeichnende <see cref="T:System.Drawing.Image" />.</param>
        <param name="destPoints">Array von drei <see cref="T:System.Drawing.PointF" />-Strukturen, die ein Parallelogramm definieren.</param>
        <param name="srcRect">
          <see cref="T:System.Drawing.Rectangle" />-Struktur, die den zu zeichnenden Teil des <paramref name="image" />-Objekts angibt.</param>
        <param name="srcUnit">Member der <see cref="T:System.Drawing.GraphicsUnit" />-Enumeration, der die Maßeinheiten für den <paramref name="srcRect" />-Parameter angibt.</param>
        <param name="imageAttr">
          <see cref="T:System.Drawing.Imaging.ImageAttributes" />, das Informationen über erneutes Einfärben und Gammainformationen für das <paramref name="image" />-Objekt angibt.</param>
        <param name="callback">
          <see cref="T:System.Drawing.Graphics.DrawImageAbort" />-Delegat, der eine Methode angibt, die während des Zeichnens des Bildes aufgerufen werden soll. Diese Methode wird häufig aufgerufen, um zu prüfen, ob die Ausführung der <see cref="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Point[],System.Drawing.Rectangle,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort,System.Int32)" />-Methode gemäß den durch die Anwendung bestimmten Kriterien abgebrochen werden soll.</param>
        <param name="callbackData">Ein Wert, der zusätzliche Daten angibt, mit denen der <see cref="T:System.Drawing.Graphics.DrawImageAbort" />-Delegat prüfen kann, ob die Ausführung der <see cref="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Point[],System.Drawing.Rectangle,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort,System.Int32)" />-Methode abgebrochen werden muss.</param>
        <summary>Zeichnet den angegebenen Bereich vom angegebenen <see cref="T:System.Drawing.Image" /> in der angegebenen Größe an der angegebenen Position.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `destPoints` Parameter gibt die drei Punkte eines Parallelogramms an. Die drei <xref:System.Drawing.PointF> -Strukturen stellen die oberen linken, oberen rechten und unteren linken Ecke des Parallelogramms. Der vierte Punkt ist über die ersten drei zu einem Parallelogramm extrapoliert.  
  
 Die `srcRect` Parameter gibt an, einen rechteckigen Bereich des der `image` Objekt, das gezeichnet werden soll. Dieser Teil wird skaliert und entsprechend in das angegebene vom Parallelogramm verbogen der `destPoints` Parameter.  
  
 Diese Überladung mit den `callback` und `callbackData` Parameter bietet die Möglichkeit, beenden das Zeichnen eines Bilds gemäß von Kriterien und Daten, die von der Anwendung bestimmt. Z. B. Starten einer Anwendung kann ein großes Bild zu zeichnen, und der Benutzer kann das Image aus dem Bildschirm, in dem Fall die Anwendung die Zeichnung Anhalten konnte scrollen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code definiert zuerst eine Rückrufmethode für die <xref:System.Drawing.Graphics.DrawImageAbort> Delegaten; die Definition ist einfach und prüft lediglich, ob die <xref:System.Drawing.Graphics.DrawImage%2A> Methode ruft es mit einer Null- `callBackData` Parameter. Der Hauptteil des Beispiels führt folgende Aktionen aus:  
  
-   Erstellt eine Instanz der <xref:System.Drawing.Graphics.DrawImageAbort> Callback-Methode.  
  
-   Erstellt ein Image aus einem JPEG-Datei SampImag.jpg im Ordner "des Beispiels".  
  
-   Erstellt die Punkte, die ein Parallelogramm in der zum Zeichnen des Bilds zu definieren.  
  
-   Erstellt ein Rechteck um den Teil der zu zeichnende Bild auszuwählen.  
  
-   Legt fest, die Grafiken, Einheit und Pixel zeichnen.  
  
-   Zeichnet das ursprüngliche Bild auf dem Bildschirm an.  
  
-   Erstellt ein zusätzliches Parallelogramm in der ein angepasstes Bild gezeichnet werden soll.  
  
-   Erstellt und legt die Attribute des Bildes, das größer als üblich Gamma Wert angepasst.  
  
-   Zeichnet das angepasste Bild auf dem Bildschirm an.  
  
 Für die ursprünglichen, nicht angepassten Parallelogramm die Position sucht das Bild auf dem Bildschirm und die Größe des Rechtecks und der Größe und Form des Parallelogramms bestimmt die Skalierung des gezeichneten Bilds.  
  
 Da in diesem Beispiel wird eine Überladung verwendet, die erfolgreich eine `callBackData` -Parameter der <xref:System.Drawing.Graphics.DrawImageAbort> des Rückrufs `false`, bewirkt, dass die <xref:System.Drawing.Graphics.DrawImage%2A> Methode, um den Vorgang fortzusetzen, und das Beispiel zeichnet Sie das angepasste Bild auf dem Bildschirm.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#39](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#39)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#39](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#39)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#39](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#39)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.PointF[] destPoints, System.Drawing.RectangleF srcRect, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Imaging.ImageAttributes imageAttr, System.Drawing.Graphics.DrawImageAbort callback, int callbackData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.PointF[] destPoints, valuetype System.Drawing.RectangleF srcRect, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Imaging.ImageAttributes imageAttr, class System.Drawing.Graphics/DrawImageAbort callback, int32 callbackData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.PointF[],System.Drawing.RectangleF,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, cli::array &lt;System::Drawing::PointF&gt; ^ destPoints, System::Drawing::RectangleF srcRect, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Imaging::ImageAttributes ^ imageAttr, System::Drawing::Graphics::DrawImageAbort ^ callback, int callbackData);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.PointF[] * System.Drawing.RectangleF * System.Drawing.GraphicsUnit * System.Drawing.Imaging.ImageAttributes * System.Drawing.Graphics.DrawImageAbort * int -&gt; unit" Usage="graphics.DrawImage (image, destPoints, srcRect, srcUnit, imageAttr, callback, callbackData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destPoints" Type="System.Drawing.PointF[]" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+DrawImageAbort" />
        <Parameter Name="callbackData" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="image">Der zu zeichnende <see cref="T:System.Drawing.Image" />.</param>
        <param name="destPoints">Array von drei <see cref="T:System.Drawing.PointF" />-Strukturen, die ein Parallelogramm definieren.</param>
        <param name="srcRect">
          <see cref="T:System.Drawing.RectangleF" />-Struktur, die den zu zeichnenden Teil des <paramref name="image" />-Objekts angibt.</param>
        <param name="srcUnit">Member der <see cref="T:System.Drawing.GraphicsUnit" />-Enumeration, der die Maßeinheiten für den <paramref name="srcRect" />-Parameter angibt.</param>
        <param name="imageAttr">
          <see cref="T:System.Drawing.Imaging.ImageAttributes" />, das Informationen über erneutes Einfärben und Gammainformationen für das <paramref name="image" />-Objekt angibt.</param>
        <param name="callback">
          <see cref="T:System.Drawing.Graphics.DrawImageAbort" />-Delegat, der eine Methode angibt, die während des Zeichnens des Bildes aufgerufen werden soll. Diese Methode wird häufig aufgerufen, um zu prüfen, ob die Ausführung der <see cref="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.PointF[],System.Drawing.RectangleF,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort,System.Int32)" />-Methode gemäß den durch die Anwendung bestimmten Kriterien abgebrochen werden soll.</param>
        <param name="callbackData">Ein Wert, der zusätzliche Daten angibt, mit denen der <see cref="T:System.Drawing.Graphics.DrawImageAbort" />-Delegat prüfen kann, ob die Ausführung der <see cref="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.PointF[],System.Drawing.RectangleF,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort,System.Int32)" />-Methode abgebrochen werden muss.</param>
        <summary>Zeichnet den angegebenen Bereich vom angegebenen <see cref="T:System.Drawing.Image" /> in der angegebenen Größe an der angegebenen Position.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `destPoints` Parameter gibt die drei Punkte eines Parallelogramms an. Die drei <xref:System.Drawing.PointF> -Strukturen stellen die oberen linken, oberen rechten und unteren linken Ecke des Parallelogramms. Der vierte Punkt ist über die ersten drei zu einem Parallelogramm extrapoliert.  
  
 Die `srcRect` Parameter gibt an, einen rechteckigen Bereich des der `image` Objekt, das gezeichnet werden soll. Dieser Teil wird skaliert und entsprechend in das angegebene vom Parallelogramm verbogen der `destPoints` Parameter.  
  
 Diese Überladung mit den `callback` und `callbackData` Parameter bietet die Möglichkeit, beenden das Zeichnen eines Bilds gemäß von Kriterien und Daten, die von der Anwendung bestimmt. Z. B. Starten einer Anwendung kann ein großes Bild zu zeichnen, und der Benutzer kann das Image aus dem Bildschirm, in dem Fall die Anwendung die Zeichnung Anhalten konnte scrollen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der `Pa` <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code definiert zuerst eine Rückrufmethode für die <xref:System.Drawing.Graphics.DrawImageAbort> Delegaten; die Definition ist einfach und prüft lediglich, ob die <xref:System.Drawing.Graphics.DrawImage%2A> Methode ruft es mit einer Null- `callBackData` Parameter. Der Hauptteil des Beispiels führt folgende Aktionen aus:  
  
-   Erstellt eine Instanz der <xref:System.Drawing.Graphics.DrawImageAbort> Callback-Methode.  
  
-   Erstellt ein Image aus einem JPEG-Datei SampImag.jpg im Ordner "des Beispiels".  
  
-   Erstellt die Punkte, die ein Parallelogramm in der zum Zeichnen des Bilds zu definieren.  
  
-   Erstellt ein Rechteck um den Teil der zu zeichnende Bild auszuwählen.  
  
-   Legt fest, die Grafiken, Einheit und Pixel zeichnen.  
  
-   Zeichnet das ursprüngliche Bild auf dem Bildschirm an.  
  
-   Erstellt ein zusätzliches Parallelogramm in der ein angepasstes Bild gezeichnet werden soll.  
  
-   Erstellt und legt die Attribute des Bildes, das größer als üblich Gamma Wert angepasst.  
  
-   Zeichnet das angepasste Bild auf dem Bildschirm an.  
  
 Für die ursprünglichen, nicht angepassten Parallelogramm die Position sucht das Bild auf dem Bildschirm und die Größe des Rechtecks und der Größe und Form des Parallelogramms bestimmt die Skalierung des gezeichneten Bilds.  
  
 Da in diesem Beispiel wird eine Überladung verwendet, die erfolgreich eine `callBackData` -Parameter der <xref:System.Drawing.Graphics.DrawImageAbort> des Rückrufs `false`, bewirkt, dass die <xref:System.Drawing.Graphics.DrawImage%2A> Methode, um den Vorgang fortzusetzen, und das Beispiel zeichnet Sie das angepasste Bild auf dem Bildschirm.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#45](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#45)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#45](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#45)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#45](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#45)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="image" /> ist <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.Rectangle destRect, int srcX, int srcY, int srcWidth, int srcHeight, System.Drawing.GraphicsUnit srcUnit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.Rectangle destRect, int32 srcX, int32 srcY, int32 srcWidth, int32 srcHeight, valuetype System.Drawing.GraphicsUnit srcUnit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Rectangle,System.Int32,System.Int32,System.Int32,System.Int32,System.Drawing.GraphicsUnit)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, System::Drawing::Rectangle destRect, int srcX, int srcY, int srcWidth, int srcHeight, System::Drawing::GraphicsUnit srcUnit);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.Rectangle * int * int * int * int * System.Drawing.GraphicsUnit -&gt; unit" Usage="graphics.DrawImage (image, destRect, srcX, srcY, srcWidth, srcHeight, srcUnit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcX" Type="System.Int32" />
        <Parameter Name="srcY" Type="System.Int32" />
        <Parameter Name="srcWidth" Type="System.Int32" />
        <Parameter Name="srcHeight" Type="System.Int32" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
      </Parameters>
      <Docs>
        <param name="image">Der zu zeichnende <see cref="T:System.Drawing.Image" />.</param>
        <param name="destRect">
          <see cref="T:System.Drawing.Rectangle" />-Struktur, die die Position und Größe des gezeichneten Bildes angibt. Das Bild wird skaliert, sodass es in das Rechteck passt.</param>
        <param name="srcX">Die x-Koordinate der oberen linken Ecke des zu zeichnenden Bereichs des Quellbilds.</param>
        <param name="srcY">Die y-Koordinate der oberen linken Ecke des zu zeichnenden Bereichs des Quellbilds.</param>
        <param name="srcWidth">Breite des zu zeichnenden Bereichs des Quellbilds.</param>
        <param name="srcHeight">Höhe des zu zeichnenden Bereichs des Quellbilds.</param>
        <param name="srcUnit">Member der <see cref="T:System.Drawing.GraphicsUnit" />-Enumeration, der die Maßeinheiten angibt, mit denen das Quellrechteck bestimmt wird.</param>
        <summary>Zeichnet den angegebenen Bereich vom angegebenen <see cref="T:System.Drawing.Image" /> in der angegebenen Größe an der angegebenen Position.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `srcX`, `srcY`, `srcWidth`, und `srcHeight` Parameter geben einen rechteckigen Bereich, der die `image` Objekt, das gezeichnet werden soll. Das Rechteck ist relativ zu der oberen linken Ecke des Quellbilds. In diesem Teil wird skaliert, um in das vom angegebenen Rechteck passt die `destRect` Parameter.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein Image aus einem JPEG-Datei SampImag.jpg im Ordner "des Beispiels".  
  
-   Erstellt ein Zielrechteck, in dem das Bild gezeichnet werden soll.  
  
-   Erstellt die Koordinaten eines Rechtecks Quelle, aus denen einen Teil des Bilds extrahiert.  
  
-   Die Maßeinheit des Quellrechtecks festgelegt auf Pixel.  
  
-   Zeichnet das Bild auf dem Bildschirm an.  
  
 Die Position des Zielrechtecks sucht das Bild auf dem Bildschirm und den Größen der Rechtecke Quelle und Ziel zu bestimmen, die Skalierung des gezeichneten Bildes und die Größe des Quellrechtecks bestimmt, welcher Teil des ursprünglichen Bilds gezeichnet wird, um die der Bildschirm.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#48](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#48)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#48](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#48)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#48](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#48)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="image" /> ist <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.Rectangle destRect, float srcX, float srcY, float srcWidth, float srcHeight, System.Drawing.GraphicsUnit srcUnit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.Rectangle destRect, float32 srcX, float32 srcY, float32 srcWidth, float32 srcHeight, valuetype System.Drawing.GraphicsUnit srcUnit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Rectangle,System.Single,System.Single,System.Single,System.Single,System.Drawing.GraphicsUnit)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, System::Drawing::Rectangle destRect, float srcX, float srcY, float srcWidth, float srcHeight, System::Drawing::GraphicsUnit srcUnit);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.Rectangle * single * single * single * single * System.Drawing.GraphicsUnit -&gt; unit" Usage="graphics.DrawImage (image, destRect, srcX, srcY, srcWidth, srcHeight, srcUnit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcX" Type="System.Single" />
        <Parameter Name="srcY" Type="System.Single" />
        <Parameter Name="srcWidth" Type="System.Single" />
        <Parameter Name="srcHeight" Type="System.Single" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
      </Parameters>
      <Docs>
        <param name="image">Der zu zeichnende <see cref="T:System.Drawing.Image" />.</param>
        <param name="destRect">
          <see cref="T:System.Drawing.Rectangle" />-Struktur, die die Position und Größe des gezeichneten Bildes angibt. Das Bild wird skaliert, sodass es in das Rechteck passt.</param>
        <param name="srcX">Die x-Koordinate der oberen linken Ecke des zu zeichnenden Bereichs des Quellbilds.</param>
        <param name="srcY">Die y-Koordinate der oberen linken Ecke des zu zeichnenden Bereichs des Quellbilds.</param>
        <param name="srcWidth">Breite des zu zeichnenden Bereichs des Quellbilds.</param>
        <param name="srcHeight">Höhe des zu zeichnenden Bereichs des Quellbilds.</param>
        <param name="srcUnit">Member der <see cref="T:System.Drawing.GraphicsUnit" />-Enumeration, der die Maßeinheiten angibt, mit denen das Quellrechteck bestimmt wird.</param>
        <summary>Zeichnet den angegebenen Bereich vom angegebenen <see cref="T:System.Drawing.Image" /> in der angegebenen Größe an der angegebenen Position.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `srcX`, `srcY`, `srcWidth`, und `srcHeight` Parameter geben einen rechteckigen Bereich, der die `image` Objekt, das gezeichnet werden soll. Das Rechteck ist relativ zu der oberen linken Ecke des Quellbilds. In diesem Teil wird skaliert, um in das vom angegebenen Rechteck passt die `destRect` Parameter.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein Image aus einem JPEG-Datei SampImag.jpg im Ordner "des Beispiels".  
  
-   Erstellt die Koordinaten eines Rechtecks Ziel, in dem das Bild gezeichnet werden soll.  
  
-   Erstellt ein Quellrechteck, aus denen einen Teil des Bilds extrahiert.  
  
-   Die Maßeinheit des Quellrechtecks festgelegt auf Pixel.  
  
-   Zeichnet das Bild auf dem Bildschirm an.  
  
 Die Position des Zielrechtecks sucht das Bild auf dem Bildschirm, den Größen der Rechtecke Quelle und Ziel zu bestimmen, die Skalierung des gezeichneten Bildes und die Größe des Quellrechtecks bestimmt, welcher Teil des ursprünglichen Bilds gezeichnet wird, um die der Bildschirm.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#52](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#52)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#52](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#52)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#52](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="image" /> ist <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.Rectangle destRect, int srcX, int srcY, int srcWidth, int srcHeight, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Imaging.ImageAttributes imageAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.Rectangle destRect, int32 srcX, int32 srcY, int32 srcWidth, int32 srcHeight, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Imaging.ImageAttributes imageAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Rectangle,System.Int32,System.Int32,System.Int32,System.Int32,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, System::Drawing::Rectangle destRect, int srcX, int srcY, int srcWidth, int srcHeight, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Imaging::ImageAttributes ^ imageAttr);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.Rectangle * int * int * int * int * System.Drawing.GraphicsUnit * System.Drawing.Imaging.ImageAttributes -&gt; unit" Usage="graphics.DrawImage (image, destRect, srcX, srcY, srcWidth, srcHeight, srcUnit, imageAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcX" Type="System.Int32" />
        <Parameter Name="srcY" Type="System.Int32" />
        <Parameter Name="srcWidth" Type="System.Int32" />
        <Parameter Name="srcHeight" Type="System.Int32" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
      </Parameters>
      <Docs>
        <param name="image">Der zu zeichnende <see cref="T:System.Drawing.Image" />.</param>
        <param name="destRect">
          <see cref="T:System.Drawing.Rectangle" />-Struktur, die die Position und Größe des gezeichneten Bildes angibt. Das Bild wird skaliert, sodass es in das Rechteck passt.</param>
        <param name="srcX">Die x-Koordinate der oberen linken Ecke des zu zeichnenden Bereichs des Quellbilds.</param>
        <param name="srcY">Die y-Koordinate der oberen linken Ecke des zu zeichnenden Bereichs des Quellbilds.</param>
        <param name="srcWidth">Breite des zu zeichnenden Bereichs des Quellbilds.</param>
        <param name="srcHeight">Höhe des zu zeichnenden Bereichs des Quellbilds.</param>
        <param name="srcUnit">Member der <see cref="T:System.Drawing.GraphicsUnit" />-Enumeration, der die Maßeinheiten angibt, mit denen das Quellrechteck bestimmt wird.</param>
        <param name="imageAttr">
          <see cref="T:System.Drawing.Imaging.ImageAttributes" />, das Informationen über erneutes Einfärben und Gammainformationen für das <paramref name="image" />-Objekt angibt.</param>
        <summary>Zeichnet den angegebenen Bereich vom angegebenen <see cref="T:System.Drawing.Image" /> in der angegebenen Größe an der angegebenen Position.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `srcX`, `srcY`, `srcWidth`, und `srcHeight` Parameter geben einen rechteckigen Bereich, der die `image` Objekt, das gezeichnet werden soll. Das Rechteck ist relativ zu der oberen linken Ecke des Quellbilds. In diesem Teil wird skaliert, um in das vom angegebenen Rechteck passt die `destRect` Parameter.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein Image aus einem JPEG-Datei SampImag.jpg im Ordner "des Beispiels".  
  
-   Erstellt ein Zielrechteck, in dem das Bild gezeichnet werden soll.  
  
-   Erstellt die Koordinaten eines Rechtecks Quelle, aus denen einen Teil des Bilds extrahiert.  
  
-   Die Maßeinheit des Quellrechtecks festgelegt auf Pixel.  
  
-   Zeichnet das ursprüngliche Bild auf dem Bildschirm an.  
  
-   Erstellt ein zusätzliches Rechteck in der ein angepasstes Bild gezeichnet werden soll.  
  
-   Erstellt und legt die Attribute des Bildes, das größer als üblich Gamma Wert angepasst.  
  
-   Zeichnet das angepasste Bild auf dem Bildschirm an.  
  
 Für die ursprünglichen, nicht angepassten Zielrechteck, sucht die Position der Abbildung auf dem Bildschirm und die Größen der Quelle und Ziel Rechtecke zu bestimmen, die Skalierung des gezeichneten Bildes und die Größe des Quellrechtecks bestimmt, welcher Teil der Originalbild wird auf dem Bildschirm gezeichnet.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#49](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#49)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#49](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#49)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#49](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#49)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="image" /> ist <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.Rectangle destRect, float srcX, float srcY, float srcWidth, float srcHeight, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Imaging.ImageAttributes imageAttrs);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.Rectangle destRect, float32 srcX, float32 srcY, float32 srcWidth, float32 srcHeight, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Imaging.ImageAttributes imageAttrs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Rectangle,System.Single,System.Single,System.Single,System.Single,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, System::Drawing::Rectangle destRect, float srcX, float srcY, float srcWidth, float srcHeight, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Imaging::ImageAttributes ^ imageAttrs);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.Rectangle * single * single * single * single * System.Drawing.GraphicsUnit * System.Drawing.Imaging.ImageAttributes -&gt; unit" Usage="graphics.DrawImage (image, destRect, srcX, srcY, srcWidth, srcHeight, srcUnit, imageAttrs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcX" Type="System.Single" />
        <Parameter Name="srcY" Type="System.Single" />
        <Parameter Name="srcWidth" Type="System.Single" />
        <Parameter Name="srcHeight" Type="System.Single" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="imageAttrs" Type="System.Drawing.Imaging.ImageAttributes" />
      </Parameters>
      <Docs>
        <param name="image">Der zu zeichnende <see cref="T:System.Drawing.Image" />.</param>
        <param name="destRect">
          <see cref="T:System.Drawing.Rectangle" />-Struktur, die die Position und Größe des gezeichneten Bildes angibt. Das Bild wird skaliert, sodass es in das Rechteck passt.</param>
        <param name="srcX">Die x-Koordinate der oberen linken Ecke des zu zeichnenden Bereichs des Quellbilds.</param>
        <param name="srcY">Die y-Koordinate der oberen linken Ecke des zu zeichnenden Bereichs des Quellbilds.</param>
        <param name="srcWidth">Breite des zu zeichnenden Bereichs des Quellbilds.</param>
        <param name="srcHeight">Höhe des zu zeichnenden Bereichs des Quellbilds.</param>
        <param name="srcUnit">Member der <see cref="T:System.Drawing.GraphicsUnit" />-Enumeration, der die Maßeinheiten angibt, mit denen das Quellrechteck bestimmt wird.</param>
        <param name="imageAttrs">
          <see cref="T:System.Drawing.Imaging.ImageAttributes" />, das Informationen über erneutes Einfärben und Gammainformationen für das <paramref name="image" />-Objekt angibt.</param>
        <summary>Zeichnet den angegebenen Bereich vom angegebenen <see cref="T:System.Drawing.Image" /> in der angegebenen Größe an der angegebenen Position.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `srcX`, `srcY`, `srcWidth`, und `srcHeight` Parameter geben einen rechteckigen Bereich, der die `image` Objekt, das gezeichnet werden soll. Das Rechteck ist relativ zu der oberen linken Ecke des Quellbilds. In diesem Teil wird skaliert, um in das vom angegebenen Rechteck passt die `destRect` Parameter.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein Image aus einem JPEG-Datei SampImag.jpg im Ordner "des Beispiels".  
  
-   Erstellt ein Zielrechteck, in dem das Bild gezeichnet werden soll.  
  
-   Erstellt die Koordinaten eines Rechtecks Quelle, aus denen einen Teil des Bilds extrahiert.  
  
-   Die Maßeinheit des Quellrechtecks festgelegt auf Pixel.  
  
-   Zeichnet das ursprüngliche Bild auf dem Bildschirm an.  
  
-   Erstellt ein zusätzliches Rechteck in der ein angepasstes Bild gezeichnet werden soll.  
  
-   Erstellt und legt die Attribute des Bildes, das größer als üblich Gamma Wert angepasst.  
  
-   Zeichnet das angepasste Bild auf dem Bildschirm an.  
  
 Für die ursprünglichen, nicht angepassten Zielrechteck, sucht die Position der Abbildung auf dem Bildschirm und die Größen der Quelle und Ziel Rechtecke zu bestimmen, die Skalierung des gezeichneten Bildes und die Größe des Quellrechtecks bestimmt, welcher Teil der Originalbild wird auf dem Bildschirm gezeichnet.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#53](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#53)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#53](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#53)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#53](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#53)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="image" /> ist <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.Rectangle destRect, int srcX, int srcY, int srcWidth, int srcHeight, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Imaging.ImageAttributes imageAttr, System.Drawing.Graphics.DrawImageAbort callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.Rectangle destRect, int32 srcX, int32 srcY, int32 srcWidth, int32 srcHeight, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Imaging.ImageAttributes imageAttr, class System.Drawing.Graphics/DrawImageAbort callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Rectangle,System.Int32,System.Int32,System.Int32,System.Int32,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, System::Drawing::Rectangle destRect, int srcX, int srcY, int srcWidth, int srcHeight, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Imaging::ImageAttributes ^ imageAttr, System::Drawing::Graphics::DrawImageAbort ^ callback);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.Rectangle * int * int * int * int * System.Drawing.GraphicsUnit * System.Drawing.Imaging.ImageAttributes * System.Drawing.Graphics.DrawImageAbort -&gt; unit" Usage="graphics.DrawImage (image, destRect, srcX, srcY, srcWidth, srcHeight, srcUnit, imageAttr, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcX" Type="System.Int32" />
        <Parameter Name="srcY" Type="System.Int32" />
        <Parameter Name="srcWidth" Type="System.Int32" />
        <Parameter Name="srcHeight" Type="System.Int32" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+DrawImageAbort" />
      </Parameters>
      <Docs>
        <param name="image">Der zu zeichnende <see cref="T:System.Drawing.Image" />.</param>
        <param name="destRect">
          <see cref="T:System.Drawing.Rectangle" />-Struktur, die die Position und Größe des gezeichneten Bildes angibt. Das Bild wird skaliert, sodass es in das Rechteck passt.</param>
        <param name="srcX">Die x-Koordinate der oberen linken Ecke des zu zeichnenden Bereichs des Quellbilds.</param>
        <param name="srcY">Die y-Koordinate der oberen linken Ecke des zu zeichnenden Bereichs des Quellbilds.</param>
        <param name="srcWidth">Breite des zu zeichnenden Bereichs des Quellbilds.</param>
        <param name="srcHeight">Höhe des zu zeichnenden Bereichs des Quellbilds.</param>
        <param name="srcUnit">Member der <see cref="T:System.Drawing.GraphicsUnit" />-Enumeration, der die Maßeinheiten angibt, mit denen das Quellrechteck bestimmt wird.</param>
        <param name="imageAttr">
          <see cref="T:System.Drawing.Imaging.ImageAttributes" />, das Neueinfärbungs- und Gammainformationen für <paramref name="image" /> angibt.</param>
        <param name="callback">
          <see cref="T:System.Drawing.Graphics.DrawImageAbort" />-Delegat, der eine Methode angibt, die während des Zeichnens des Bildes aufgerufen werden soll. Diese Methode wird häufig aufgerufen, um zu prüfen, ob die Ausführung der <see cref="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Rectangle,System.Int32,System.Int32,System.Int32,System.Int32,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort)" />-Methode gemäß den durch die Anwendung bestimmten Kriterien abgebrochen werden soll.</param>
        <summary>Zeichnet den angegebenen Bereich vom angegebenen <see cref="T:System.Drawing.Image" /> in der angegebenen Größe an der angegebenen Position.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `srcX`, `srcY`, `srcWidth`, und `srcHeight` Parameter geben einen rechteckigen Bereich, der die `image` Objekt, das gezeichnet werden soll. Das Rechteck ist relativ zu der oberen linken Ecke des Quellbilds. In diesem Teil wird skaliert, um in das vom angegebenen Rechteck passt die `destRect` Objekt.  
  
 Diese Überladung mit den `callback` Parameter bietet die Möglichkeit, die das Zeichnen eines Bilds zu beenden, sobald es gemäß den Kriterien, die von der Anwendung festgelegte gestartet wird. Z. B. Starten einer Anwendung kann ein großes Bild zu zeichnen, und der Benutzer kann das Image aus dem Bildschirm, in dem Fall die Anwendung die Zeichnung Anhalten konnte scrollen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code definiert zuerst eine Rückrufmethode für die <xref:System.Drawing.Graphics.DrawImageAbort> Delegaten; die Definition ist einfach und prüft lediglich, ob die <xref:System.Drawing.Graphics.DrawImage%2A> Methode ruft es mit einer Null- `callBackData` Parameter. Der Hauptteil des Beispiels führt folgende Aktionen aus:  
  
-   Erstellt eine Instanz der <xref:System.Drawing.Graphics.DrawImageAbort> Callback-Methode.  
  
-   Erstellt ein Image aus einem JPEG-Datei SampImag.jpg im Ordner "des Beispiels".  
  
-   Erstellt die Punkte, die ein Zielrechteck, in der zum Zeichnen des Bilds zu definieren.  
  
-   Erstellt ein Quellrechteck, um den Teil der zu zeichnende Bild auszuwählen.  
  
-   Legt fest, die Grafiken, Einheit und Pixel zeichnen.  
  
-   Zeichnet das ursprüngliche Bild auf dem Bildschirm an.  
  
-   Erstellt ein zusätzliches Zielrechteck, in dem ein angepasstes Bild gezeichnet werden soll.  
  
-   Erstellt und legt die Attribute des Bildes, das größer als üblich Gamma Wert angepasst.  
  
-   Zeichnet das angepasste Bild auf dem Bildschirm an.  
  
 Für die ursprünglichen, nicht angepassten Zielrechteck die Position sucht das Bild auf dem Bildschirm und die Größe des Quellrechtecks sowie die Größe und Form des Zielrechtecks bestimmt die Skalierung des gezeichneten Bilds.  
  
 Da in diesem Beispiel wird eine Überladung verwendet, die nicht bestanden hat eine `callBackData` -Parameter der <xref:System.Drawing.Graphics.DrawImageAbort> des Rückrufs `true`, bewirkt, dass die <xref:System.Drawing.Graphics.DrawImage%2A> Methode to-End und der Code zur Ausnahmebehandlung im Beispielcode enthalten, gibt die Text der Ausnahme und nicht als das Bild zu zeichnen.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#50](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#50)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#50](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#50)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#50](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#50)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="image" /> ist <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.Rectangle destRect, float srcX, float srcY, float srcWidth, float srcHeight, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Imaging.ImageAttributes imageAttrs, System.Drawing.Graphics.DrawImageAbort callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.Rectangle destRect, float32 srcX, float32 srcY, float32 srcWidth, float32 srcHeight, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Imaging.ImageAttributes imageAttrs, class System.Drawing.Graphics/DrawImageAbort callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Rectangle,System.Single,System.Single,System.Single,System.Single,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, System::Drawing::Rectangle destRect, float srcX, float srcY, float srcWidth, float srcHeight, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Imaging::ImageAttributes ^ imageAttrs, System::Drawing::Graphics::DrawImageAbort ^ callback);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.Rectangle * single * single * single * single * System.Drawing.GraphicsUnit * System.Drawing.Imaging.ImageAttributes * System.Drawing.Graphics.DrawImageAbort -&gt; unit" Usage="graphics.DrawImage (image, destRect, srcX, srcY, srcWidth, srcHeight, srcUnit, imageAttrs, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcX" Type="System.Single" />
        <Parameter Name="srcY" Type="System.Single" />
        <Parameter Name="srcWidth" Type="System.Single" />
        <Parameter Name="srcHeight" Type="System.Single" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="imageAttrs" Type="System.Drawing.Imaging.ImageAttributes" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+DrawImageAbort" />
      </Parameters>
      <Docs>
        <param name="image">Der zu zeichnende <see cref="T:System.Drawing.Image" />.</param>
        <param name="destRect">
          <see cref="T:System.Drawing.Rectangle" />-Struktur, die die Position und Größe des gezeichneten Bildes angibt. Das Bild wird skaliert, sodass es in das Rechteck passt.</param>
        <param name="srcX">Die x-Koordinate der oberen linken Ecke des zu zeichnenden Bereichs des Quellbilds.</param>
        <param name="srcY">Die y-Koordinate der oberen linken Ecke des zu zeichnenden Bereichs des Quellbilds.</param>
        <param name="srcWidth">Breite des zu zeichnenden Bereichs des Quellbilds.</param>
        <param name="srcHeight">Höhe des zu zeichnenden Bereichs des Quellbilds.</param>
        <param name="srcUnit">Member der <see cref="T:System.Drawing.GraphicsUnit" />-Enumeration, der die Maßeinheiten angibt, mit denen das Quellrechteck bestimmt wird.</param>
        <param name="imageAttrs">
          <see cref="T:System.Drawing.Imaging.ImageAttributes" />, das Informationen über erneutes Einfärben und Gammainformationen für das <paramref name="image" />-Objekt angibt.</param>
        <param name="callback">
          <see cref="T:System.Drawing.Graphics.DrawImageAbort" />-Delegat, der eine Methode angibt, die während des Zeichnens des Bildes aufgerufen werden soll. Diese Methode wird häufig aufgerufen, um zu prüfen, ob die Ausführung der <see cref="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Rectangle,System.Single,System.Single,System.Single,System.Single,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort)" />-Methode gemäß den durch die Anwendung bestimmten Kriterien abgebrochen werden soll.</param>
        <summary>Zeichnet den angegebenen Bereich vom angegebenen <see cref="T:System.Drawing.Image" /> in der angegebenen Größe an der angegebenen Position.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `srcX`, `srcY`, `srcWidth`, und `srcHeight` Parameter geben einen rechteckigen Bereich, der die `image` Objekt, das gezeichnet werden soll. Das Rechteck ist relativ zu der oberen linken Ecke des Quellbilds. In diesem Teil wird skaliert, um in das vom angegebenen Rechteck passt die `destRect` Parameter.  
  
 Diese Überladung mit den `callback` Parameter bietet die Möglichkeit, die das Zeichnen eines Bilds zu beenden, sobald es gemäß den Kriterien, die von der Anwendung festgelegte gestartet wird. Z. B. Starten einer Anwendung kann ein großes Bild zu zeichnen, und der Benutzer kann das Image aus dem Bildschirm, in dem Fall die Anwendung die Zeichnung Anhalten konnte scrollen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code definiert zuerst eine Rückrufmethode für die <xref:System.Drawing.Graphics.DrawImageAbort> Delegaten; die Definition ist einfach und prüft lediglich, ob die <xref:System.Drawing.Graphics.DrawImage%2A> Methode ruft es mit einer Null- `callBackData` Parameter. Der Hauptteil des Beispiels führt folgende Aktionen aus:  
  
-   Erstellt eine Instanz der <xref:System.Drawing.Graphics.DrawImageAbort> Callback-Methode.  
  
-   Erstellt ein Image aus einem JPEG-Datei SampImag.jpg im Ordner "des Beispiels".  
  
-   Erstellt die Punkte, die ein Zielrechteck, in der zum Zeichnen des Bilds zu definieren.  
  
-   Erstellt ein Quellrechteck, um den Teil der zu zeichnende Bild auszuwählen.  
  
-   Legt fest, die Grafiken, Einheit und Pixel zeichnen.  
  
-   Zeichnet das ursprüngliche Bild auf dem Bildschirm an.  
  
-   Erstellt ein zusätzliches Zielrechteck, in dem ein angepasstes Bild gezeichnet werden soll.  
  
-   Erstellt und legt die Attribute des Bildes, das größer als üblich Gamma Wert angepasst.  
  
-   Zeichnet das angepasste Bild auf dem Bildschirm an.  
  
 Für die ursprünglichen, nicht angepassten Zielrechteck die Position sucht das Bild auf dem Bildschirm und die Größe des Quellrechtecks sowie die Größe und Form des Zielrechtecks bestimmt die Skalierung des gezeichneten Bilds.  
  
 Da in diesem Beispiel wird eine Überladung verwendet, die nicht bestanden hat eine `callBackData` -Parameter der <xref:System.Drawing.Graphics.DrawImageAbort> des Rückrufs `true`, bewirkt, dass die <xref:System.Drawing.Graphics.DrawImage%2A> Methode to-End und der Code zur Ausnahmebehandlung im Beispielcode enthalten, gibt die Text der Ausnahme und nicht als das Bild zu zeichnen.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#54](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#54)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#54](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#54)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#54](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#54)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="image" /> ist <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.Rectangle destRect, int srcX, int srcY, int srcWidth, int srcHeight, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Imaging.ImageAttributes imageAttrs, System.Drawing.Graphics.DrawImageAbort callback, IntPtr callbackData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.Rectangle destRect, int32 srcX, int32 srcY, int32 srcWidth, int32 srcHeight, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Imaging.ImageAttributes imageAttrs, class System.Drawing.Graphics/DrawImageAbort callback, native int callbackData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Rectangle,System.Int32,System.Int32,System.Int32,System.Int32,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort,System.IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, System::Drawing::Rectangle destRect, int srcX, int srcY, int srcWidth, int srcHeight, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Imaging::ImageAttributes ^ imageAttrs, System::Drawing::Graphics::DrawImageAbort ^ callback, IntPtr callbackData);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.Rectangle * int * int * int * int * System.Drawing.GraphicsUnit * System.Drawing.Imaging.ImageAttributes * System.Drawing.Graphics.DrawImageAbort * nativeint -&gt; unit" Usage="graphics.DrawImage (image, destRect, srcX, srcY, srcWidth, srcHeight, srcUnit, imageAttrs, callback, callbackData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcX" Type="System.Int32" />
        <Parameter Name="srcY" Type="System.Int32" />
        <Parameter Name="srcWidth" Type="System.Int32" />
        <Parameter Name="srcHeight" Type="System.Int32" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="imageAttrs" Type="System.Drawing.Imaging.ImageAttributes" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+DrawImageAbort" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="image">Der zu zeichnende <see cref="T:System.Drawing.Image" />.</param>
        <param name="destRect">
          <see cref="T:System.Drawing.Rectangle" />-Struktur, die die Position und Größe des gezeichneten Bildes angibt. Das Bild wird skaliert, sodass es in das Rechteck passt.</param>
        <param name="srcX">Die x-Koordinate der oberen linken Ecke des zu zeichnenden Bereichs des Quellbilds.</param>
        <param name="srcY">Die y-Koordinate der oberen linken Ecke des zu zeichnenden Bereichs des Quellbilds.</param>
        <param name="srcWidth">Breite des zu zeichnenden Bereichs des Quellbilds.</param>
        <param name="srcHeight">Höhe des zu zeichnenden Bereichs des Quellbilds.</param>
        <param name="srcUnit">Member der <see cref="T:System.Drawing.GraphicsUnit" />-Enumeration, der die Maßeinheiten angibt, mit denen das Quellrechteck bestimmt wird.</param>
        <param name="imageAttrs">
          <see cref="T:System.Drawing.Imaging.ImageAttributes" />, das Informationen über erneutes Einfärben und Gammainformationen für das <paramref name="image" />-Objekt angibt.</param>
        <param name="callback">
          <see cref="T:System.Drawing.Graphics.DrawImageAbort" />-Delegat, der eine Methode angibt, die während des Zeichnens des Bildes aufgerufen werden soll. Diese Methode wird häufig aufgerufen, um zu prüfen, ob die Ausführung der <see cref="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Rectangle,System.Int32,System.Int32,System.Int32,System.Int32,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort,System.IntPtr)" />-Methode gemäß den durch die Anwendung bestimmten Kriterien abgebrochen werden soll.</param>
        <param name="callbackData">Ein Wert, der zusätzliche Daten angibt, mit denen der <see cref="T:System.Drawing.Graphics.DrawImageAbort" />-Delegat prüfen kann, ob die Ausführung der <see langword="DrawImage" />-Methode abgebrochen werden muss.</param>
        <summary>Zeichnet den angegebenen Bereich vom angegebenen <see cref="T:System.Drawing.Image" /> in der angegebenen Größe an der angegebenen Position.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `srcX`, `srcY`, `srcWidth`, und `srcHeight` Parameter geben einen rechteckigen Bereich, der die `image` Objekt, das gezeichnet werden soll. Das Rechteck ist relativ zu der oberen linken Ecke des Quellbilds. In diesem Teil wird skaliert, um in das vom angegebenen Rechteck passt die `destRect` Parameter.  
  
 Diese Überladung mit den `callback` und `callbackData` Parameter bietet die Möglichkeit, beenden das Zeichnen eines Bilds gemäß von Kriterien und Daten, die von der Anwendung bestimmt. Z. B. Starten einer Anwendung kann ein großes Bild zu zeichnen, und der Benutzer kann das Image aus dem Bildschirm, in dem Fall die Anwendung die Zeichnung Anhalten konnte scrollen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code definiert zuerst eine Rückrufmethode für die <xref:System.Drawing.Graphics.DrawImageAbort> Delegaten; die Definition ist einfach und prüft lediglich, ob die <xref:System.Drawing.Graphics.DrawImage%2A> Methode ruft es mit einer Null- `callBackData` Parameter. Der Hauptteil des Beispiels führt folgende Aktionen aus:  
  
-   Erstellt eine Instanz der <xref:System.Drawing.Graphics.DrawImageAbort> Callback-Methode.  
  
-   Erstellt ein Image aus einem JPEG-Datei SampImag.jpg im Ordner "des Beispiels".  
  
-   Erstellt die Punkte, die ein Zielrechteck, in der zum Zeichnen des Bilds zu definieren.  
  
-   Erstellt ein Quellrechteck, um den Teil der zu zeichnende Bild auszuwählen.  
  
-   Legt fest, die Grafiken, Einheit und Pixel zeichnen.  
  
-   Zeichnet das ursprüngliche Bild auf dem Bildschirm an.  
  
-   Erstellt ein zusätzliches Zielrechteck, in dem ein angepasstes Bild gezeichnet werden soll.  
  
-   Erstellt und legt die Attribute des Bildes, das größer als üblich Gamma Wert angepasst.  
  
-   Zeichnet das angepasste Bild auf dem Bildschirm an.  
  
 Für die ursprünglichen, nicht angepassten Zielrechteck die Position sucht das Bild auf dem Bildschirm und die Größe des Quellrechtecks sowie die Größe und Form des Zielrechtecks bestimmt die Skalierung des gezeichneten Bilds.  
  
 Da in diesem Beispiel wird eine Überladung verwendet, die erfolgreich eine `callBackData` -Parameter der <xref:System.Drawing.Graphics.DrawImageAbort> des Rückrufs `false`, bewirkt, dass die <xref:System.Drawing.Graphics.DrawImage%2A> Methode, um den Vorgang fortzusetzen, und das Beispiel zeichnet Sie das angepasste Bild auf dem Bildschirm.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#51](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#51)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#51](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#51)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#51](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#51)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="image" /> ist <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.Rectangle destRect, float srcX, float srcY, float srcWidth, float srcHeight, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Imaging.ImageAttributes imageAttrs, System.Drawing.Graphics.DrawImageAbort callback, IntPtr callbackData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.Rectangle destRect, float32 srcX, float32 srcY, float32 srcWidth, float32 srcHeight, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Imaging.ImageAttributes imageAttrs, class System.Drawing.Graphics/DrawImageAbort callback, native int callbackData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Rectangle,System.Single,System.Single,System.Single,System.Single,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort,System.IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, System::Drawing::Rectangle destRect, float srcX, float srcY, float srcWidth, float srcHeight, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Imaging::ImageAttributes ^ imageAttrs, System::Drawing::Graphics::DrawImageAbort ^ callback, IntPtr callbackData);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.Rectangle * single * single * single * single * System.Drawing.GraphicsUnit * System.Drawing.Imaging.ImageAttributes * System.Drawing.Graphics.DrawImageAbort * nativeint -&gt; unit" Usage="graphics.DrawImage (image, destRect, srcX, srcY, srcWidth, srcHeight, srcUnit, imageAttrs, callback, callbackData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcX" Type="System.Single" />
        <Parameter Name="srcY" Type="System.Single" />
        <Parameter Name="srcWidth" Type="System.Single" />
        <Parameter Name="srcHeight" Type="System.Single" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="imageAttrs" Type="System.Drawing.Imaging.ImageAttributes" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+DrawImageAbort" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="image">Der zu zeichnende <see cref="T:System.Drawing.Image" />.</param>
        <param name="destRect">
          <see cref="T:System.Drawing.Rectangle" />-Struktur, die die Position und Größe des gezeichneten Bildes angibt. Das Bild wird skaliert, sodass es in das Rechteck passt.</param>
        <param name="srcX">Die x-Koordinate der oberen linken Ecke des zu zeichnenden Bereichs des Quellbilds.</param>
        <param name="srcY">Die y-Koordinate der oberen linken Ecke des zu zeichnenden Bereichs des Quellbilds.</param>
        <param name="srcWidth">Breite des zu zeichnenden Bereichs des Quellbilds.</param>
        <param name="srcHeight">Höhe des zu zeichnenden Bereichs des Quellbilds.</param>
        <param name="srcUnit">Member der <see cref="T:System.Drawing.GraphicsUnit" />-Enumeration, der die Maßeinheiten angibt, mit denen das Quellrechteck bestimmt wird.</param>
        <param name="imageAttrs">
          <see cref="T:System.Drawing.Imaging.ImageAttributes" />, das Informationen über erneutes Einfärben und Gammainformationen für das <paramref name="image" />-Objekt angibt.</param>
        <param name="callback">
          <see cref="T:System.Drawing.Graphics.DrawImageAbort" />-Delegat, der eine Methode angibt, die während des Zeichnens des Bildes aufgerufen werden soll. Diese Methode wird häufig aufgerufen, um zu prüfen, ob die Ausführung der <see cref="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Rectangle,System.Single,System.Single,System.Single,System.Single,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort,System.IntPtr)" />-Methode gemäß den durch die Anwendung bestimmten Kriterien abgebrochen werden soll.</param>
        <param name="callbackData">Ein Wert, der zusätzliche Daten angibt, mit denen der <see cref="T:System.Drawing.Graphics.DrawImageAbort" />-Delegat prüfen kann, ob die Ausführung der <see langword="DrawImage" />-Methode abgebrochen werden muss.</param>
        <summary>Zeichnet den angegebenen Bereich vom angegebenen <see cref="T:System.Drawing.Image" /> in der angegebenen Größe an der angegebenen Position.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `srcX`, `srcY`, `srcWidth`, und `srcHeight` Parameter geben einen rechteckigen Bereich, der die `image` Objekt, das gezeichnet werden soll. Das Rechteck ist relativ zu der oberen linken Ecke des Quellbilds. In diesem Teil wird skaliert, um in das vom angegebenen Rechteck passt die `destRect` Parameter.  
  
 Diese Überladung mit den `callback` und `callbackData` Parameter bietet die Möglichkeit, beenden das Zeichnen eines Bilds gemäß von Kriterien und Daten, die von der Anwendung bestimmt. Z. B. Starten einer Anwendung kann ein großes Bild zu zeichnen, und der Benutzer kann das Image aus dem Bildschirm, in dem Fall die Anwendung die Zeichnung Anhalten konnte scrollen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code definiert zuerst eine Rückrufmethode für die <xref:System.Drawing.Graphics.DrawImageAbort> Delegaten; die Definition ist einfach und prüft lediglich, ob die <xref:System.Drawing.Graphics.DrawImage%2A> Methode ruft es mit einer Null- `callBackData` Parameter. Der Hauptteil des Beispiels führt folgende Aktionen aus:  
  
-   Erstellt eine Instanz der <xref:System.Drawing.Graphics.DrawImageAbort> Callback-Methode.  
  
-   Erstellt ein Image aus einem JPEG-Datei SampImag.jpg im Ordner "des Beispiels".  
  
-   Erstellt die Punkte, die ein Zielrechteck, in der zum Zeichnen des Bilds zu definieren.  
  
-   Erstellt ein Quellrechteck, um den Teil der zu zeichnende Bild auszuwählen.  
  
-   Legt fest, die Grafiken, Einheit und Pixel zeichnen.  
  
-   Zeichnet das ursprüngliche Bild auf dem Bildschirm an.  
  
-   Erstellt ein zusätzliches Zielrechteck, in dem ein angepasstes Bild gezeichnet werden soll.  
  
-   Erstellt und legt die Attribute des Bildes, das größer als üblich Gamma Wert angepasst.  
  
-   Zeichnet das angepasste Bild auf dem Bildschirm an.  
  
 Für die ursprünglichen, nicht angepassten Zielrechteck die Position sucht das Bild auf dem Bildschirm und die Größe des Quellrechtecks sowie die Größe und Form des Zielrechtecks bestimmt die Skalierung des gezeichneten Bilds.  
  
 Da in diesem Beispiel wird eine Überladung verwendet, die erfolgreich eine `callBackData` -Parameter der <xref:System.Drawing.Graphics.DrawImageAbort> des Rückrufs `false`, bewirkt, dass die <xref:System.Drawing.Graphics.DrawImage%2A> Methode, um den Vorgang fortzusetzen, und das Beispiel zeichnet Sie das angepasste Bild auf dem Bildschirm.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#55](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#55)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#55](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#55)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#55](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#55)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="image" /> ist <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawImageUnscaled">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zeichnet das angegebene Bild in seiner ursprünglichen physischen Größe an der von einem Koordinatenpaar angegebenen Position.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawImageUnscaled">
      <MemberSignature Language="C#" Value="public void DrawImageUnscaled (System.Drawing.Image image, System.Drawing.Point point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImageUnscaled(class System.Drawing.Image image, valuetype System.Drawing.Point point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImageUnscaled(System.Drawing.Image,System.Drawing.Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImageUnscaled(System::Drawing::Image ^ image, System::Drawing::Point point);" />
      <MemberSignature Language="F#" Value="member this.DrawImageUnscaled : System.Drawing.Image * System.Drawing.Point -&gt; unit" Usage="graphics.DrawImageUnscaled (image, point)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="point" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="image">Der zu zeichnende <see cref="T:System.Drawing.Image" />.</param>
        <param name="point">
          <see cref="T:System.Drawing.Point" />-Struktur, die die linke obere Ecke des gezeichneten Bildes angibt.</param>
        <summary>Zeichnet ein angegebenes Bild in seiner ursprünglichen physischen Größe an einer angegebenen Position.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Drawing.Image> speichert einen Wert für die Breite in Pixel und einen Wert für die horizontale Auflösung (dpi). Die physische Breite, gemessen in Zoll eines Bilds wird geteilt durch die horizontale Auflösung Breite in Pixel. Ein Bild mit einer Breite von 216 Pixel und einer horizontalen Auflösung von 72 Punkte pro Zoll hat z. B. eine physische Breite von 3 Zoll. Ähnliche Hinweise gelten für die Höhe in Pixel und die physische Höhe.  
  
 Die <xref:System.Drawing.Graphics.DrawImageUnscaled%2A> Methode zeichnet ein Bild in seiner physischen Größe hat also das Image die richtige Größe in Zoll, unabhängig von der Auflösung (dpi) des Anzeigegeräts. Nehmen wir beispielsweise an, dass ein Bild einer Breite von 216 Pixel und einer horizontalen Auflösung von 72 Punkte pro Zoll sind. Wenn Sie aufrufen <xref:System.Drawing.Graphics.DrawImageUnscaled%2A> um dieses Image auf einem Gerät zu zeichnen, die eine Auflösung von 96 DPI-Wert aufweist, werden die Pixelbreite des gerenderten Bilds (216/72 Zoll) * 96 = 288.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein Image aus einem JPEG-Datei SampImag.jpg im Ordner "des Beispiels".  
  
-   Erstellt einen Punkt, an dem der oberen linken Ecke des Bilds gezeichnet werden soll.  
  
-   Zeichnet das gesamte Bild in seiner physischen Größe an.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#64](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#64)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#64](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#64)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#64](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#64)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="image" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawImageUnscaled">
      <MemberSignature Language="C#" Value="public void DrawImageUnscaled (System.Drawing.Image image, System.Drawing.Rectangle rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImageUnscaled(class System.Drawing.Image image, valuetype System.Drawing.Rectangle rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImageUnscaled(System.Drawing.Image,System.Drawing.Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImageUnscaled(System::Drawing::Image ^ image, System::Drawing::Rectangle rect);" />
      <MemberSignature Language="F#" Value="member this.DrawImageUnscaled : System.Drawing.Image * System.Drawing.Rectangle -&gt; unit" Usage="graphics.DrawImageUnscaled (image, rect)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="image">Der zu zeichnende <see cref="T:System.Drawing.Image" />.</param>
        <param name="rect">
          <see cref="T:System.Drawing.Rectangle" />-Struktur, die die linke obere Ecke des gezeichneten Bildes angibt. Die X-Eigenschaft und die Y-Eigenschaft des Rechtecks geben die linke obere Ecke an. Die Width-Eigenschaft und die Height-Eigenschaft werden ignoriert.</param>
        <summary>Zeichnet ein angegebenes Bild in seiner ursprünglichen physischen Größe an einer angegebenen Position.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Drawing.Image> speichert einen Wert für die Breite in Pixel und einen Wert für die horizontale Auflösung (dpi). Die physische Breite, gemessen in Zoll eines Bilds wird geteilt durch die horizontale Auflösung Breite in Pixel. Ein Bild mit einer Breite von 216 Pixel und einer horizontalen Auflösung von 72 Punkte pro Zoll hat z. B. eine physische Breite von 3 Zoll. Ähnliche Hinweise gelten für die Höhe in Pixel und die physische Höhe.  
  
 Die <xref:System.Drawing.Graphics.DrawImageUnscaled%2A> Methode zeichnet ein Bild in seiner physischen Größe hat also das Image die richtige Größe in Zoll, unabhängig von der Auflösung (dpi) des Anzeigegeräts. Nehmen wir beispielsweise an, dass ein Bild einer Breite von 216 Pixel und einer horizontalen Auflösung von 72 Punkte pro Zoll sind. Wenn Sie aufrufen <xref:System.Drawing.Graphics.DrawImageUnscaled%2A> um dieses Image auf einem Gerät zu zeichnen, die eine Auflösung von 96 DPI-Wert aufweist, werden die Pixelbreite des gerenderten Bilds (216/72 Zoll) * 96 = 288.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="image" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawImageUnscaled">
      <MemberSignature Language="C#" Value="public void DrawImageUnscaled (System.Drawing.Image image, int x, int y);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImageUnscaled(class System.Drawing.Image image, int32 x, int32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImageUnscaled(System.Drawing.Image,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImageUnscaled(System::Drawing::Image ^ image, int x, int y);" />
      <MemberSignature Language="F#" Value="member this.DrawImageUnscaled : System.Drawing.Image * int * int -&gt; unit" Usage="graphics.DrawImageUnscaled (image, x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="image">Der zu zeichnende <see cref="T:System.Drawing.Image" />.</param>
        <param name="x">Die x-Koordinate der oberen linken Ecke des gezeichneten Bilds.</param>
        <param name="y">Die y-Koordinate der oberen linken Ecke des gezeichneten Bilds.</param>
        <summary>Zeichnet das angegebene Bild in seiner ursprünglichen physischen Größe an der von einem Koordinatenpaar angegebenen Position.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Drawing.Image> speichert einen Wert für die Breite in Pixel und einen Wert für die horizontale Auflösung (dpi). Die physische Breite, gemessen in Zoll eines Bilds wird geteilt durch die horizontale Auflösung Breite in Pixel. Ein Bild mit einer Breite von 216 Pixel und einer horizontalen Auflösung von 72 Punkte pro Zoll hat z. B. eine physische Breite von 3 Zoll. Ähnliche Hinweise gelten für die Höhe in Pixel und die physische Höhe.  
  
 Die <xref:System.Drawing.Graphics.DrawImageUnscaled%2A> Methode zeichnet ein Bild in seiner physischen Größe hat also das Image die richtige Größe in Zoll, unabhängig von der Auflösung (dpi) des Anzeigegeräts. Nehmen wir beispielsweise an, dass ein Bild einer Breite von 216 Pixel und einer horizontalen Auflösung von 72 Punkte pro Zoll sind. Wenn Sie aufrufen <xref:System.Drawing.Graphics.DrawImageUnscaled%2A> um dieses Image auf einem Gerät zu zeichnen, die eine Auflösung von 96 DPI-Wert aufweist, werden die Pixelbreite des gerenderten Bilds (216/72 Zoll) * 96 = 288.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein Image aus einer JPEG-Datei, SampImag.jpg, im Ordner "des Beispiels".  
  
-   Erstellt einen Punkt, an dem der oberen linken Ecke des Bilds gezeichnet werden soll.  
  
-   Zeichnet das gesamte Bild in seiner physischen Größe an.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#65](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#65)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#65](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#65)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#65](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#65)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="image" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawImageUnscaled">
      <MemberSignature Language="C#" Value="public void DrawImageUnscaled (System.Drawing.Image image, int x, int y, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImageUnscaled(class System.Drawing.Image image, int32 x, int32 y, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImageUnscaled(System.Drawing.Image,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImageUnscaled(System::Drawing::Image ^ image, int x, int y, int width, int height);" />
      <MemberSignature Language="F#" Value="member this.DrawImageUnscaled : System.Drawing.Image * int * int * int * int -&gt; unit" Usage="graphics.DrawImageUnscaled (image, x, y, width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="image">Der zu zeichnende <see cref="T:System.Drawing.Image" />.</param>
        <param name="x">Die x-Koordinate der oberen linken Ecke des gezeichneten Bilds.</param>
        <param name="y">Die y-Koordinate der oberen linken Ecke des gezeichneten Bilds.</param>
        <param name="width">Nicht verwendet.</param>
        <param name="height">Nicht verwendet.</param>
        <summary>Zeichnet ein angegebenes Bild in seiner ursprünglichen physischen Größe an einer angegebenen Position.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Drawing.Image> speichert einen Wert für die Breite in Pixel und einen Wert für die horizontale Auflösung (dpi). Die physische Breite, gemessen in Zoll eines Bilds wird geteilt durch die horizontale Auflösung Breite in Pixel. Ein Bild mit einer Breite von 216 Pixel und einer horizontalen Auflösung von 72 Punkte pro Zoll hat z. B. eine physische Breite von 3 Zoll. Ähnliche Hinweise gelten für die Höhe in Pixel und die physische Höhe.  
  
 Die <xref:System.Drawing.Graphics.DrawImageUnscaled%2A> Methode zeichnet ein Bild in seiner physischen Größe hat also das Image die richtige Größe in Zoll, unabhängig von der Auflösung (dpi) des Anzeigegeräts. Nehmen wir beispielsweise an, dass ein Bild einer Breite von 216 Pixel und einer horizontalen Auflösung von 72 Punkte pro Zoll sind. Wenn Sie aufrufen <xref:System.Drawing.Graphics.DrawImageUnscaled%2A> um dieses Image auf einem Gerät zu zeichnen, die eine Auflösung von 96 DPI-Wert aufweist, werden die Pixelbreite des gerenderten Bilds (216/72 Zoll) * 96 = 288.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="image" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawImageUnscaledAndClipped">
      <MemberSignature Language="C#" Value="public void DrawImageUnscaledAndClipped (System.Drawing.Image image, System.Drawing.Rectangle rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImageUnscaledAndClipped(class System.Drawing.Image image, valuetype System.Drawing.Rectangle rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImageUnscaledAndClipped(System.Drawing.Image,System.Drawing.Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImageUnscaledAndClipped(System::Drawing::Image ^ image, System::Drawing::Rectangle rect);" />
      <MemberSignature Language="F#" Value="member this.DrawImageUnscaledAndClipped : System.Drawing.Image * System.Drawing.Rectangle -&gt; unit" Usage="graphics.DrawImageUnscaledAndClipped (image, rect)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="image">Das zu zeichnende <see cref="T:System.Drawing.Image" />.</param>
        <param name="rect">Das <see cref="T:System.Drawing.Rectangle" />, in dem das Bild gezeichnet werden soll.</param>
        <summary>Zeichnet das angegebene Bild ohne Skalierung und beschneidet es ggf. auf die Größe des angegebenen Rechtecks.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird die Verwendung der <xref:System.Drawing.Graphics.DrawImageUnscaledAndClipped%2A>-Methode veranschaulicht. Um dieses Beispiel auszuführen, fügen Sie ihn in ein Windows Form aus. Behandeln Sie das <xref:System.Windows.Forms.Control.Paint> Ereignis, und rufen die `DrawImageUnscaled` Methode aus der <xref:System.Windows.Forms.Control.Paint> Ereignisbehandlungsmethode, übergeben `e` als <xref:System.Windows.Forms.PaintEventArgs>.  
  
 [!code-csharp[System.Drawing.MiscWhidbeySnippets#8](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.MiscWhidbeySnippets/CS/Form1.cs#8)]
 [!code-vb[System.Drawing.MiscWhidbeySnippets#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.MiscWhidbeySnippets/VB/Form1.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="image" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawLine">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zeichnet eine verbindende Linie zwischen den beiden durch Koordinatenpaare angegebenen Punkten.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawLine">
      <MemberSignature Language="C#" Value="public void DrawLine (System.Drawing.Pen pen, System.Drawing.Point pt1, System.Drawing.Point pt2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawLine(class System.Drawing.Pen pen, valuetype System.Drawing.Point pt1, valuetype System.Drawing.Point pt2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawLine(System.Drawing.Pen,System.Drawing.Point,System.Drawing.Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawLine(System::Drawing::Pen ^ pen, System::Drawing::Point pt1, System::Drawing::Point pt2);" />
      <MemberSignature Language="F#" Value="member this.DrawLine : System.Drawing.Pen * System.Drawing.Point * System.Drawing.Point -&gt; unit" Usage="graphics.DrawLine (pen, pt1, pt2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="pt1" Type="System.Drawing.Point" />
        <Parameter Name="pt2" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" />, der die Farbe, Breite und den Stil der Linie bestimmt.</param>
        <param name="pt1">
          <see cref="T:System.Drawing.Point" />-Struktur, die den ersten zu verbindenden Punkt darstellt.</param>
        <param name="pt2">
          <see cref="T:System.Drawing.Point" />-Struktur, die den zweiten zu verbindenden Punkt darstellt.</param>
        <summary>Zeichnet eine verbindende Linie zwischen zwei <see cref="T:System.Drawing.Point" />-Strukturen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen schwarzen Stift.  
  
-   Erstellt die Punkte für die Endpunkte der Linie.  
  
-   Zeichnet die Linie auf dem Bildschirm an.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#66](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#66)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#66](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#66)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#66](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#66)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pen" /> ist <see langword="null" />.</exception>
        <related type="Article" href="~/docs/framework/winforms/advanced/using-a-pen-to-draw-lines-and-shapes.md">Verwenden eines Stiftes zum Zeichnen von Linien und Formen</related>
      </Docs>
    </Member>
    <Member MemberName="DrawLine">
      <MemberSignature Language="C#" Value="public void DrawLine (System.Drawing.Pen pen, System.Drawing.PointF pt1, System.Drawing.PointF pt2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawLine(class System.Drawing.Pen pen, valuetype System.Drawing.PointF pt1, valuetype System.Drawing.PointF pt2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawLine(System.Drawing.Pen,System.Drawing.PointF,System.Drawing.PointF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawLine(System::Drawing::Pen ^ pen, System::Drawing::PointF pt1, System::Drawing::PointF pt2);" />
      <MemberSignature Language="F#" Value="member this.DrawLine : System.Drawing.Pen * System.Drawing.PointF * System.Drawing.PointF -&gt; unit" Usage="graphics.DrawLine (pen, pt1, pt2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="pt1" Type="System.Drawing.PointF" />
        <Parameter Name="pt2" Type="System.Drawing.PointF" />
      </Parameters>
      <Docs>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" />, der die Farbe, Breite und den Stil der Linie bestimmt.</param>
        <param name="pt1">
          <see cref="T:System.Drawing.PointF" />-Struktur, die den ersten zu verbindenden Punkt darstellt.</param>
        <param name="pt2">
          <see cref="T:System.Drawing.PointF" />-Struktur, die den zweiten zu verbindenden Punkt darstellt.</param>
        <summary>Zeichnet eine verbindende Linie zwischen zwei <see cref="T:System.Drawing.PointF" />-Strukturen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zeichnet eine verbindende Linie zwischen die beiden Punkten, die gemäß der `pt1` und p`2` Parameter.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen schwarzen Stift.  
  
-   Erstellt die Punkte für die Endpunkte der Linie.  
  
-   Zeichnet die Linie auf dem Bildschirm an.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#67](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#67)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#67](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#67)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#67](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#67)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pen" /> ist <see langword="null" />.</exception>
        <related type="Article" href="~/docs/framework/winforms/advanced/using-a-pen-to-draw-lines-and-shapes.md">Verwenden eines Stiftes zum Zeichnen von Linien und Formen</related>
      </Docs>
    </Member>
    <Member MemberName="DrawLine">
      <MemberSignature Language="C#" Value="public void DrawLine (System.Drawing.Pen pen, int x1, int y1, int x2, int y2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawLine(class System.Drawing.Pen pen, int32 x1, int32 y1, int32 x2, int32 y2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawLine(System.Drawing.Pen,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawLine(System::Drawing::Pen ^ pen, int x1, int y1, int x2, int y2);" />
      <MemberSignature Language="F#" Value="member this.DrawLine : System.Drawing.Pen * int * int * int * int -&gt; unit" Usage="graphics.DrawLine (pen, x1, y1, x2, y2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="x1" Type="System.Int32" />
        <Parameter Name="y1" Type="System.Int32" />
        <Parameter Name="x2" Type="System.Int32" />
        <Parameter Name="y2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" />, der die Farbe, Breite und den Stil der Linie bestimmt.</param>
        <param name="x1">Die x-Koordinate des ersten Punkts.</param>
        <param name="y1">Die y-Koordinate des ersten Punkts.</param>
        <param name="x2">Die x-Koordinate des zweiten Punkts.</param>
        <param name="y2">Die y-Koordinate des zweiten Punkts.</param>
        <summary>Zeichnet eine verbindende Linie zwischen den beiden durch Koordinatenpaare angegebenen Punkten.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zeichnet eine verbindende Linie zwischen die beiden Punkten, die gemäß der `x1`, `y1`, `x2`, und `y2` Parameter.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen schwarzen Stift.  
  
-   Erstellt die Koordinaten der Endpunkte der Linie.  
  
-   Zeichnet die Linie auf dem Bildschirm an.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#68](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#68)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#68](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#68)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#68](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pen" /> ist <see langword="null" />.</exception>
        <related type="Article" href="~/docs/framework/winforms/advanced/using-a-pen-to-draw-lines-and-shapes.md">Verwenden eines Stiftes zum Zeichnen von Linien und Formen</related>
      </Docs>
    </Member>
    <Member MemberName="DrawLine">
      <MemberSignature Language="C#" Value="public void DrawLine (System.Drawing.Pen pen, float x1, float y1, float x2, float y2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawLine(class System.Drawing.Pen pen, float32 x1, float32 y1, float32 x2, float32 y2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawLine(System.Drawing.Pen,System.Single,System.Single,System.Single,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawLine(System::Drawing::Pen ^ pen, float x1, float y1, float x2, float y2);" />
      <MemberSignature Language="F#" Value="member this.DrawLine : System.Drawing.Pen * single * single * single * single -&gt; unit" Usage="graphics.DrawLine (pen, x1, y1, x2, y2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="x1" Type="System.Single" />
        <Parameter Name="y1" Type="System.Single" />
        <Parameter Name="x2" Type="System.Single" />
        <Parameter Name="y2" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" />, der die Farbe, Breite und den Stil der Linie bestimmt.</param>
        <param name="x1">Die x-Koordinate des ersten Punkts.</param>
        <param name="y1">Die y-Koordinate des ersten Punkts.</param>
        <param name="x2">Die x-Koordinate des zweiten Punkts.</param>
        <param name="y2">Die y-Koordinate des zweiten Punkts.</param>
        <summary>Zeichnet eine verbindende Linie zwischen den beiden durch Koordinatenpaare angegebenen Punkten.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zeichnet eine verbindende Linie zwischen die beiden Punkten, die gemäß der `x1`, `y1`, `x2`, und `y2` Parameter.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen schwarzen Stift.  
  
-   Erstellt die Koordinaten der Endpunkte der Linie.  
  
-   Zeichnet die Linie auf dem Bildschirm an.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#69](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#69)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#69](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#69)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#69](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#69)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pen" /> ist <see langword="null" />.</exception>
        <related type="Article" href="~/docs/framework/winforms/advanced/using-a-pen-to-draw-lines-and-shapes.md">Verwenden eines Stiftes zum Zeichnen von Linien und Formen</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawLines">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zeichnet eine Reihe von Liniensegmenten, die ein Array von <see cref="T:System.Drawing.Point" />-Strukturen verbinden.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawLines">
      <MemberSignature Language="C#" Value="public void DrawLines (System.Drawing.Pen pen, System.Drawing.Point[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawLines(class System.Drawing.Pen pen, valuetype System.Drawing.Point[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawLines(System.Drawing.Pen,System.Drawing.Point[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawLines(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::Point&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.DrawLines : System.Drawing.Pen * System.Drawing.Point[] -&gt; unit" Usage="graphics.DrawLines (pen, points)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="points" Type="System.Drawing.Point[]" />
      </Parameters>
      <Docs>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" />, der die Farbe, Breite und den Stil der Linie bestimmt.</param>
        <param name="points">Array von <see cref="T:System.Drawing.Point" />-Strukturen, die die zu verbindenden Punkte darstellen.</param>
        <summary>Zeichnet eine Reihe von Liniensegmenten, die ein Array von <see cref="T:System.Drawing.Point" />-Strukturen verbinden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zeichnet eine Reihe von Linien, die ein Array von Endpunkten verbinden. Geben Sie die ersten beiden Punkte im Array die erste Zeile. Jede zusätzlicher Punkt angibt, das Ende eines Liniensegments, dessen Startpunkt den Endpunkt des vorherigen Zeilensegments darstellt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen schwarzen Stift.  
  
-   Erstellt ein Array von Punkten von Segmenten der Linie.  
  
-   Zeichnet die verbundener Liniensegmente auf dem Bildschirm an.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#70](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#70)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#70](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#70)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#70](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#70)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pen" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="points" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawLines">
      <MemberSignature Language="C#" Value="public void DrawLines (System.Drawing.Pen pen, System.Drawing.PointF[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawLines(class System.Drawing.Pen pen, valuetype System.Drawing.PointF[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawLines(System.Drawing.Pen,System.Drawing.PointF[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawLines(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::PointF&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.DrawLines : System.Drawing.Pen * System.Drawing.PointF[] -&gt; unit" Usage="graphics.DrawLines (pen, points)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
      </Parameters>
      <Docs>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" />, der die Farbe, Breite und den Stil der Linie bestimmt.</param>
        <param name="points">Array von <see cref="T:System.Drawing.PointF" />-Strukturen, die die zu verbindenden Punkte darstellen.</param>
        <summary>Zeichnet eine Reihe von Liniensegmenten, die ein Array von <see cref="T:System.Drawing.PointF" />-Strukturen verbinden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zeichnet eine Reihe von Linien, die ein Array von Endpunkten verbinden. Geben Sie die ersten beiden Punkte im Array die erste Zeile. Jede zusätzlicher Punkt angibt, das Ende eines Liniensegments, dessen Startpunkt den Endpunkt des vorherigen Zeilensegments darstellt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Code wird einen schwarzen Stift erstellt.  
  
-   Erstellt ein Array von Punkten von Segmenten der Linie.  
  
-   Zeichnet die verbundener Liniensegmente auf dem Bildschirm an.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#71](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#71)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#71](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#71)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#71](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#71)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pen" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="points" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawPath">
      <MemberSignature Language="C#" Value="public void DrawPath (System.Drawing.Pen pen, System.Drawing.Drawing2D.GraphicsPath path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawPath(class System.Drawing.Pen pen, class System.Drawing.Drawing2D.GraphicsPath path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawPath(System.Drawing.Pen,System.Drawing.Drawing2D.GraphicsPath)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawPath(System::Drawing::Pen ^ pen, System::Drawing::Drawing2D::GraphicsPath ^ path);" />
      <MemberSignature Language="F#" Value="member this.DrawPath : System.Drawing.Pen * System.Drawing.Drawing2D.GraphicsPath -&gt; unit" Usage="graphics.DrawPath (pen, path)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="path" Type="System.Drawing.Drawing2D.GraphicsPath" />
      </Parameters>
      <Docs>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" />, der die Farbe, Breite und den Stil des Pfads bestimmt.</param>
        <param name="path">Der zu zeichnende <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</param>
        <summary>Zeichnet einen <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die aktuelle Transformation im Grafikkontext gilt, an die <xref:System.Drawing.Drawing2D.GraphicsPath> bevor es gezeichnet wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein Grafikobjekt-Pfad und eine Ellipse hinzugefügt.  
  
-   Erstellt einen schwarzen Stift.  
  
-   Zeichnet den Grafikpfad auf dem Bildschirm an.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#72](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#72)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#72](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#72)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#72](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#72)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pen" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="path" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawPie">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zeichnet eine durch eine Ellipse, die durch ein Koordinatenpaar, eine Breiten- und eine Höhenangabe und zwei Radien angegeben ist, definierte Kreisform.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawPie">
      <MemberSignature Language="C#" Value="public void DrawPie (System.Drawing.Pen pen, System.Drawing.Rectangle rect, float startAngle, float sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawPie(class System.Drawing.Pen pen, valuetype System.Drawing.Rectangle rect, float32 startAngle, float32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawPie(System.Drawing.Pen,System.Drawing.Rectangle,System.Single,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawPie(System::Drawing::Pen ^ pen, System::Drawing::Rectangle rect, float startAngle, float sweepAngle);" />
      <MemberSignature Language="F#" Value="member this.DrawPie : System.Drawing.Pen * System.Drawing.Rectangle * single * single -&gt; unit" Usage="graphics.DrawPie (pen, rect, startAngle, sweepAngle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
        <Parameter Name="startAngle" Type="System.Single" />
        <Parameter Name="sweepAngle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" />, der die Farbe, die Breite und den Stil der Kreisform bestimmt.</param>
        <param name="rect">
          <see cref="T:System.Drawing.Rectangle" />-Struktur, die das umschließende Rechteck darstellt, das die Ellipse definiert, aus der die Kreisform stammt.</param>
        <param name="startAngle">Zwischen der x-Achse und der ersten Seite der Kreisform im Uhrzeigersinn gemessener Winkel in Grad.</param>
        <param name="sweepAngle">Zwischen dem <paramref name="startAngle" />-Parameter und der zweiten Seite der Kreisform im Uhrzeigersinn gemessener Winkel in Grad.</param>
        <summary>Zeichnet eine Kreisform, die von einer Ellipse definiert wird, die ihrerseits durch eine <see cref="T:System.Drawing.Rectangle" />-Struktur und zwei Radien angegeben ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zeichnet eine Kreisform, die durch einen Bogen einer Ellipse und die zwei Radien, die sich überschneiden, mit den Endpunkten des Bogens definiert. Die Ellipse wird durch das umschließende Rechteck definiert. Kreisform besteht aus den zwei Radien von definiert die `startAngle` und `sweepAngle` Parameter und den Bogen zwischen den Schnittmengen von dieser Radien mit der Ellipse.  
  
 Wenn die `sweepAngle` -Parameter ist größer als 360 Grad oder kleiner als-360 Grad, es wird behandelt, als wäre es 360 Grad oder-360 Grad bzw.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen schwarzen Stift.  
  
-   Erstellt ein Rechteck, das eine vollständige Ellipse umschließt.  
  
-   Definiert den Winkel an dem die Zeichnung (in Bezug auf die x-Achse) beginnen und über dem gezeichnet werden soll (beide im Uhrzeigersinn).  
  
-   Zeichnet das Segment des Kreisdiagramms auf dem Bildschirm an.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#73](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#73)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#73](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#73)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#73](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#73)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pen" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawPie">
      <MemberSignature Language="C#" Value="public void DrawPie (System.Drawing.Pen pen, System.Drawing.RectangleF rect, float startAngle, float sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawPie(class System.Drawing.Pen pen, valuetype System.Drawing.RectangleF rect, float32 startAngle, float32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawPie(System.Drawing.Pen,System.Drawing.RectangleF,System.Single,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawPie(System::Drawing::Pen ^ pen, System::Drawing::RectangleF rect, float startAngle, float sweepAngle);" />
      <MemberSignature Language="F#" Value="member this.DrawPie : System.Drawing.Pen * System.Drawing.RectangleF * single * single -&gt; unit" Usage="graphics.DrawPie (pen, rect, startAngle, sweepAngle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="rect" Type="System.Drawing.RectangleF" />
        <Parameter Name="startAngle" Type="System.Single" />
        <Parameter Name="sweepAngle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" />, der die Farbe, die Breite und den Stil der Kreisform bestimmt.</param>
        <param name="rect">
          <see cref="T:System.Drawing.RectangleF" />-Struktur, die das umschließende Rechteck darstellt, das die Ellipse definiert, aus der die Kreisform stammt.</param>
        <param name="startAngle">Zwischen der x-Achse und der ersten Seite der Kreisform im Uhrzeigersinn gemessener Winkel in Grad.</param>
        <param name="sweepAngle">Zwischen dem <paramref name="startAngle" />-Parameter und der zweiten Seite der Kreisform im Uhrzeigersinn gemessener Winkel in Grad.</param>
        <summary>Zeichnet eine Kreisform, die von einer Ellipse definiert wird, die ihrerseits durch eine <see cref="T:System.Drawing.RectangleF" />-Struktur und zwei Radien angegeben ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zeichnet eine Kreisform, die durch einen Bogen einer Ellipse und die zwei Radien, die sich überschneiden, mit den Endpunkten des Bogens definiert. Die Ellipse wird durch das umschließende Rechteck definiert. Kreisform besteht aus den zwei Radien von definiert die `startAngle` und `sweepAngle` Parameter und den Bogen zwischen den Schnittmengen von dieser Radien mit der Ellipse.  
  
 Wenn die `sweepAngle` -Parameter ist größer als 360 Grad oder kleiner als-360 Grad, es wird behandelt, als wäre es 360 Grad oder-360 Grad bzw.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen schwarzen Stift.  
  
-   Erstellt ein Rechteck, das eine vollständige Ellipse umschließt.  
  
-   Definiert den Winkel an dem die Zeichnung (in Bezug auf die x-Achse) beginnen und über dem gezeichnet werden soll (beide im Uhrzeigersinn).  
  
-   Zeichnet das Segment des Kreisdiagramms auf dem Bildschirm an.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#74](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#74)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#74](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#74)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#74](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#74)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pen" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawPie">
      <MemberSignature Language="C#" Value="public void DrawPie (System.Drawing.Pen pen, int x, int y, int width, int height, int startAngle, int sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawPie(class System.Drawing.Pen pen, int32 x, int32 y, int32 width, int32 height, int32 startAngle, int32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawPie(System.Drawing.Pen,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawPie(System::Drawing::Pen ^ pen, int x, int y, int width, int height, int startAngle, int sweepAngle);" />
      <MemberSignature Language="F#" Value="member this.DrawPie : System.Drawing.Pen * int * int * int * int * int * int -&gt; unit" Usage="graphics.DrawPie (pen, x, y, width, height, startAngle, sweepAngle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
        <Parameter Name="startAngle" Type="System.Int32" />
        <Parameter Name="sweepAngle" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" />, der die Farbe, die Breite und den Stil der Kreisform bestimmt.</param>
        <param name="x">Die x-Koordinate der oberen linken Ecke des umschließenden Rechtecks, das die Ellipse definiert, aus der die Kreisform stammt.</param>
        <param name="y">Die y-Koordinate der oberen linken Ecke des umschließenden Rechtecks, das die Ellipse definiert, aus der die Kreisform stammt.</param>
        <param name="width">Breite des umschließenden Rechtecks, das die Ellipse definiert, aus der die Kreisform stammt.</param>
        <param name="height">Höhe des umschließenden Rechtecks, das die Ellipse definiert, aus der die Kreisform stammt.</param>
        <param name="startAngle">Zwischen der x-Achse und der ersten Seite der Kreisform im Uhrzeigersinn gemessener Winkel in Grad.</param>
        <param name="sweepAngle">Zwischen dem <paramref name="startAngle" />-Parameter und der zweiten Seite der Kreisform im Uhrzeigersinn gemessener Winkel in Grad.</param>
        <summary>Zeichnet eine durch eine Ellipse, die durch ein Koordinatenpaar, eine Breiten- und eine Höhenangabe und zwei Radien angegeben ist, definierte Kreisform.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zeichnet eine Kreisform, die durch einen Bogen einer Ellipse und die zwei Radien, die sich überschneiden, mit den Endpunkten des Bogens definiert. Die Ellipse wird durch das umschließende Rechteck durch beschrieben definiert die `x`, `y`, `width`, und `height` Parameter. Kreisform besteht aus den zwei Radien von definiert die `startAngle` und `sweepAngle` Parameter und den Bogen zwischen den Schnittmengen von dieser Radien mit der Ellipse.  
  
 Wenn die `sweepAngle` -Parameter ist größer als 360 Grad oder kleiner als-360 Grad, es wird behandelt, als wäre es 360 Grad oder-360 Grad bzw.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen schwarzen Stift.  
  
-   Erstellt die Position und Größe eines Rechtecks, das eine vollständige Ellipse umschließt.  
  
-   Definiert den Winkel an dem die Zeichnung (in Bezug auf die x-Achse) beginnen und über dem gezeichnet werden soll (beide im Uhrzeigersinn).  
  
-   Zeichnet die Kreisform auf dem Bildschirm an.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#75](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#75)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#75](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#75)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#75](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#75)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pen" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawPie">
      <MemberSignature Language="C#" Value="public void DrawPie (System.Drawing.Pen pen, float x, float y, float width, float height, float startAngle, float sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawPie(class System.Drawing.Pen pen, float32 x, float32 y, float32 width, float32 height, float32 startAngle, float32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawPie(System.Drawing.Pen,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawPie(System::Drawing::Pen ^ pen, float x, float y, float width, float height, float startAngle, float sweepAngle);" />
      <MemberSignature Language="F#" Value="member this.DrawPie : System.Drawing.Pen * single * single * single * single * single * single -&gt; unit" Usage="graphics.DrawPie (pen, x, y, width, height, startAngle, sweepAngle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="width" Type="System.Single" />
        <Parameter Name="height" Type="System.Single" />
        <Parameter Name="startAngle" Type="System.Single" />
        <Parameter Name="sweepAngle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" />, der die Farbe, die Breite und den Stil der Kreisform bestimmt.</param>
        <param name="x">Die x-Koordinate der oberen linken Ecke des umschließenden Rechtecks, das die Ellipse definiert, aus der die Kreisform stammt.</param>
        <param name="y">Die y-Koordinate der oberen linken Ecke des umschließenden Rechtecks, das die Ellipse definiert, aus der die Kreisform stammt.</param>
        <param name="width">Breite des umschließenden Rechtecks, das die Ellipse definiert, aus der die Kreisform stammt.</param>
        <param name="height">Höhe des umschließenden Rechtecks, das die Ellipse definiert, aus der die Kreisform stammt.</param>
        <param name="startAngle">Zwischen der x-Achse und der ersten Seite der Kreisform im Uhrzeigersinn gemessener Winkel in Grad.</param>
        <param name="sweepAngle">Zwischen dem <paramref name="startAngle" />-Parameter und der zweiten Seite der Kreisform im Uhrzeigersinn gemessener Winkel in Grad.</param>
        <summary>Zeichnet eine durch eine Ellipse, die durch ein Koordinatenpaar, eine Breiten- und eine Höhenangabe und zwei Radien angegeben ist, definierte Kreisform.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zeichnet eine Kreisform, die durch einen Bogen einer Ellipse und die zwei Radien, die sich überschneiden, mit den Endpunkten des Bogens definiert. Die Ellipse wird durch das umschließende Rechteck durch beschrieben definiert die `x`, `y`, `width`, und `height` Parameter. Kreisform besteht aus den zwei Radien von definiert die `startAngle` und `sweepAngle` Parameter und den Bogen zwischen den Schnittmengen von dieser Radien mit der Ellipse.  
  
 Wenn die `sweepAngle` -Parameter ist größer als 360 Grad oder kleiner als-360 Grad, es wird behandelt, als wäre es 360 Grad oder-360 Grad bzw.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen schwarzen Stift.  
  
-   Erstellt die Position und Größe eines Rechtecks, das eine vollständige Ellipse umschließt.  
  
-   Definiert den Winkel an dem die Zeichnung (in Bezug auf die x-Achse) beginnen und über dem gezeichnet werden soll (beide im Uhrzeigersinn).  
  
-   Zeichnet das Segment des Kreisdiagramms auf dem Bildschirm an.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#76](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#76)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#76](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#76)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#76](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#76)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pen" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawPolygon">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zeichnet ein Vieleck, das durch ein Array von <see cref="T:System.Drawing.Point" />-Strukturen definiert ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawPolygon">
      <MemberSignature Language="C#" Value="public void DrawPolygon (System.Drawing.Pen pen, System.Drawing.Point[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawPolygon(class System.Drawing.Pen pen, valuetype System.Drawing.Point[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawPolygon(System.Drawing.Pen,System.Drawing.Point[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawPolygon(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::Point&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.DrawPolygon : System.Drawing.Pen * System.Drawing.Point[] -&gt; unit" Usage="graphics.DrawPolygon (pen, points)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="points" Type="System.Drawing.Point[]" />
      </Parameters>
      <Docs>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" />, der die Farbe, Breite und den Stil des Vielecks bestimmt.</param>
        <param name="points">Array von <see cref="T:System.Drawing.Point" />-Strukturen, die die Eckpunkte des Vielecks darstellen.</param>
        <summary>Zeichnet ein Vieleck, das durch ein Array von <see cref="T:System.Drawing.Point" />-Strukturen definiert ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jedes Paar von zwei aufeinander folgenden Punkten im Array gibt an, eine Seite des Polygons. Wenn der letzte Punkt und der erste Punkt des Arrays nicht übereinstimmen, geben sie darüber hinaus die letzten Seite des Polygons.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen schwarzen Stift.  
  
-   Erstellt ein Array der sieben Punkte für die Scheitelpunkte des Polygons.  
  
-   Zeichnet das Polygon auf dem Bildschirm an.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#78](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#78)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#78](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#78)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#78](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#78)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pen" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawPolygon">
      <MemberSignature Language="C#" Value="public void DrawPolygon (System.Drawing.Pen pen, System.Drawing.PointF[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawPolygon(class System.Drawing.Pen pen, valuetype System.Drawing.PointF[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawPolygon(System.Drawing.Pen,System.Drawing.PointF[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawPolygon(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::PointF&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.DrawPolygon : System.Drawing.Pen * System.Drawing.PointF[] -&gt; unit" Usage="graphics.DrawPolygon (pen, points)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
      </Parameters>
      <Docs>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" />, der die Farbe, Breite und den Stil des Vielecks bestimmt.</param>
        <param name="points">Array von <see cref="T:System.Drawing.PointF" />-Strukturen, die die Eckpunkte des Vielecks darstellen.</param>
        <summary>Zeichnet ein Vieleck, das durch ein Array von <see cref="T:System.Drawing.PointF" />-Strukturen definiert ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jedes Paar von zwei aufeinander folgenden Punkten im Array gibt an, eine Seite des Polygons. Wenn der letzte Punkt und dem ersten Punkt im Array nicht übereinstimmen, geben sie darüber hinaus die letzten Seite des Polygons.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen schwarzen Stift.  
  
-   Erstellt ein Array der sieben Punkte für die Scheitelpunkte des Polygons.  
  
-   Zeichnet das Polygon auf dem Bildschirm an.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#77](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#77)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#77](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#77)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#77](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#77)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pen" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="points" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawRectangle">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zeichnet ein Rechteck, das durch ein Koordinatenpaar, eine Breiten- und eine Höhenangabe angegeben ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawRectangle">
      <MemberSignature Language="C#" Value="public void DrawRectangle (System.Drawing.Pen pen, System.Drawing.Rectangle rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawRectangle(class System.Drawing.Pen pen, valuetype System.Drawing.Rectangle rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawRectangle(System.Drawing.Pen,System.Drawing.Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawRectangle(System::Drawing::Pen ^ pen, System::Drawing::Rectangle rect);" />
      <MemberSignature Language="F#" Value="member this.DrawRectangle : System.Drawing.Pen * System.Drawing.Rectangle -&gt; unit" Usage="graphics.DrawRectangle (pen, rect)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="pen">Ein <see cref="T:System.Drawing.Pen" />, der die Farbe, Breite und den Stil des Rechtecks bestimmt.</param>
        <param name="rect">Eine <see cref="T:System.Drawing.Rectangle" />-Struktur, die das zu zeichnende Rechteck darstellt.</param>
        <summary>Zeichnet ein Rechteck, das von einer <see cref="T:System.Drawing.Rectangle" />-Struktur angegeben ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Informationen zum Zeichnen einer <xref:System.Drawing.RectangleF>, finden Sie unter <xref:System.Drawing.Graphics.DrawRectangles%28System.Drawing.Pen%2CSystem.Drawing.RectangleF%5B%5D%29>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen schwarzen Stift.  
  
-   Erstellt ein Rechteck.  
  
-   Zeichnet das Rechteck auf dem Bildschirm an.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#79](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#79)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#79](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#79)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#79](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#79)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pen" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawRectangle">
      <MemberSignature Language="C#" Value="public void DrawRectangle (System.Drawing.Pen pen, int x, int y, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawRectangle(class System.Drawing.Pen pen, int32 x, int32 y, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawRectangle(System.Drawing.Pen,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawRectangle(System::Drawing::Pen ^ pen, int x, int y, int width, int height);" />
      <MemberSignature Language="F#" Value="member this.DrawRectangle : System.Drawing.Pen * int * int * int * int -&gt; unit" Usage="graphics.DrawRectangle (pen, x, y, width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" />, der die Farbe, Breite und den Stil des Rechtecks bestimmt.</param>
        <param name="x">Die X-Koordinate der oberen linken Ecke des zu zeichnenden Rechtecks.</param>
        <param name="y">Die Y-Koordinate der oberen linken Ecke des zu zeichnenden Rechtecks.</param>
        <param name="width">Breite des zu zeichnenden Rechtecks.</param>
        <param name="height">Höhe des zu zeichnenden Rechtecks.</param>
        <summary>Zeichnet ein Rechteck, das durch ein Koordinatenpaar, eine Breiten- und eine Höhenangabe angegeben ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Informationen zum Zeichnen einer <xref:System.Drawing.RectangleF>, finden Sie unter <xref:System.Drawing.Graphics.DrawRectangles%28System.Drawing.Pen%2CSystem.Drawing.RectangleF%5B%5D%29>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen schwarzen Stift.  
  
-   Erstellt die Position und Größe eines Rechtecks an.  
  
-   Zeichnet das Rechteck auf dem Bildschirm an.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#80](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#80)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#80](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#80)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#80](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#80)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pen" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawRectangle">
      <MemberSignature Language="C#" Value="public void DrawRectangle (System.Drawing.Pen pen, float x, float y, float width, float height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawRectangle(class System.Drawing.Pen pen, float32 x, float32 y, float32 width, float32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawRectangle(System.Drawing.Pen,System.Single,System.Single,System.Single,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawRectangle(System::Drawing::Pen ^ pen, float x, float y, float width, float height);" />
      <MemberSignature Language="F#" Value="member this.DrawRectangle : System.Drawing.Pen * single * single * single * single -&gt; unit" Usage="graphics.DrawRectangle (pen, x, y, width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="width" Type="System.Single" />
        <Parameter Name="height" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="pen">Ein <see cref="T:System.Drawing.Pen" />, der die Farbe, Breite und den Stil des Rechtecks bestimmt.</param>
        <param name="x">Die X-Koordinate der oberen linken Ecke des zu zeichnenden Rechtecks.</param>
        <param name="y">Die Y-Koordinate der oberen linken Ecke des zu zeichnenden Rechtecks.</param>
        <param name="width">Die Breite des zu zeichnenden Rechtecks.</param>
        <param name="height">Die Höhe des zu zeichnenden Rechtecks.</param>
        <summary>Zeichnet ein Rechteck, das durch ein Koordinatenpaar, eine Breiten- und eine Höhenangabe angegeben ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Informationen zum Zeichnen einer <xref:System.Drawing.RectangleF>, finden Sie unter <xref:System.Drawing.Graphics.DrawRectangles%28System.Drawing.Pen%2CSystem.Drawing.RectangleF%5B%5D%29>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen schwarzen Stift.  
  
-   Erstellt die Position und Größe eines Rechtecks an.  
  
-   Zeichnet das Rechteck auf dem Bildschirm an.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#81](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#81)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#81](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#81)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#81](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#81)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pen" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawRectangles">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zeichnet eine Reihe von Rechtecken, die durch <see cref="T:System.Drawing.Rectangle" />-Strukturen angegeben sind.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawRectangles">
      <MemberSignature Language="C#" Value="public void DrawRectangles (System.Drawing.Pen pen, System.Drawing.Rectangle[] rects);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawRectangles(class System.Drawing.Pen pen, valuetype System.Drawing.Rectangle[] rects) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawRectangles(System.Drawing.Pen,System.Drawing.Rectangle[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawRectangles(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::Rectangle&gt; ^ rects);" />
      <MemberSignature Language="F#" Value="member this.DrawRectangles : System.Drawing.Pen * System.Drawing.Rectangle[] -&gt; unit" Usage="graphics.DrawRectangles (pen, rects)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="rects" Type="System.Drawing.Rectangle[]" />
      </Parameters>
      <Docs>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" />, der die Farbe, Breite und den Stil der Gliederungen der Rechtecke bestimmt.</param>
        <param name="rects">Array von <see cref="T:System.Drawing.Rectangle" />-Strukturen, die die zu zeichnenden Rechtecke darstellen.</param>
        <summary>Zeichnet eine Reihe von Rechtecken, die durch <see cref="T:System.Drawing.Rectangle" />-Strukturen angegeben sind.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen schwarzen Stift.  
  
-   Erstellt ein Array mit drei Rechtecken.  
  
-   Zeichnet die Rechtecke auf dem Bildschirm an.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#82](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#82)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#82](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#82)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#82](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#82)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pen" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="rects" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="rects" /> ist ein Array der Länge 0 (null).</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawRectangles">
      <MemberSignature Language="C#" Value="public void DrawRectangles (System.Drawing.Pen pen, System.Drawing.RectangleF[] rects);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawRectangles(class System.Drawing.Pen pen, valuetype System.Drawing.RectangleF[] rects) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawRectangles(System.Drawing.Pen,System.Drawing.RectangleF[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawRectangles(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::RectangleF&gt; ^ rects);" />
      <MemberSignature Language="F#" Value="member this.DrawRectangles : System.Drawing.Pen * System.Drawing.RectangleF[] -&gt; unit" Usage="graphics.DrawRectangles (pen, rects)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="rects" Type="System.Drawing.RectangleF[]" />
      </Parameters>
      <Docs>
        <param name="pen">
          <see cref="T:System.Drawing.Pen" />, der die Farbe, Breite und den Stil der Gliederungen der Rechtecke bestimmt.</param>
        <param name="rects">Array von <see cref="T:System.Drawing.RectangleF" />-Strukturen, die die zu zeichnenden Rechtecke darstellen.</param>
        <summary>Zeichnet eine Reihe von Rechtecken, die durch <see cref="T:System.Drawing.RectangleF" />-Strukturen angegeben sind.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen schwarzen Stift.  
  
-   Erstellt ein Array mit drei Rechtecken.  
  
-   Zeichnet die Rechtecke auf dem Bildschirm an.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#83](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#83)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#83](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#83)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#83](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#83)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pen" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="rects" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="rects" /> ist ein Array der Länge 0 (null).</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawString">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zeichnet die angegebene Textzeichenfolge an der angegebenen Position mit dem angegebenen <see cref="T:System.Drawing.Brush" />-Objekt und dem angegebenen <see cref="T:System.Drawing.Font" />-Objekt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawString">
      <MemberSignature Language="C#" Value="public void DrawString (string s, System.Drawing.Font font, System.Drawing.Brush brush, System.Drawing.PointF point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawString(string s, class System.Drawing.Font font, class System.Drawing.Brush brush, valuetype System.Drawing.PointF point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawString(System.String,System.Drawing.Font,System.Drawing.Brush,System.Drawing.PointF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawString(System::String ^ s, System::Drawing::Font ^ font, System::Drawing::Brush ^ brush, System::Drawing::PointF point);" />
      <MemberSignature Language="F#" Value="member this.DrawString : string * System.Drawing.Font * System.Drawing.Brush * System.Drawing.PointF -&gt; unit" Usage="graphics.DrawString (s, font, brush, point)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="font" Type="System.Drawing.Font" />
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="point" Type="System.Drawing.PointF" />
      </Parameters>
      <Docs>
        <param name="s">Zu zeichnende Zeichenfolge.</param>
        <param name="font">
          <see cref="T:System.Drawing.Font" />, die das Textformat der Zeichenfolge definiert.</param>
        <param name="brush">
          <see cref="T:System.Drawing.Brush" />, der die Farbe und Struktur des gezeichneten Texts bestimmt.</param>
        <param name="point">
          <see cref="T:System.Drawing.PointF" />-Struktur, die die obere linke Ecke des gezeichneten Textes angibt.</param>
        <summary>Zeichnet die angegebene Textzeichenfolge an der angegebenen Position mit dem angegebenen <see cref="T:System.Drawing.Brush" />-Objekt und dem angegebenen <see cref="T:System.Drawing.Font" />-Objekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt eine Textzeichenfolge, die gezeichnet werden soll.  
  
-   Definiert die Schriftart Arial (16).  
  
-   Erstellt einen solide, schwarzen Pinsel zum Zeichnen.  
  
-   Erstellt einen Punkt für die linke obere Ecke unter der den Text gezeichnet werden soll.  
  
-   Zeichnet die Zeichenfolge mit der Schriftart, Pinsel und Ziel auf dem Bildschirm an.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#84](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#84)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#84](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#84)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#84](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#84)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="brush" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="s" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Forms.TextRenderer.DrawText(System.Drawing.IDeviceContext,System.String,System.Drawing.Font,System.Drawing.Point,System.Drawing.Color)" />
        <related type="Article" href="~/docs/framework/winforms/advanced/using-fonts-and-text.md">Verwenden von Schriftarten und Text</related>
      </Docs>
    </Member>
    <Member MemberName="DrawString">
      <MemberSignature Language="C#" Value="public void DrawString (string s, System.Drawing.Font font, System.Drawing.Brush brush, System.Drawing.RectangleF layoutRectangle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawString(string s, class System.Drawing.Font font, class System.Drawing.Brush brush, valuetype System.Drawing.RectangleF layoutRectangle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawString(System.String,System.Drawing.Font,System.Drawing.Brush,System.Drawing.RectangleF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawString(System::String ^ s, System::Drawing::Font ^ font, System::Drawing::Brush ^ brush, System::Drawing::RectangleF layoutRectangle);" />
      <MemberSignature Language="F#" Value="member this.DrawString : string * System.Drawing.Font * System.Drawing.Brush * System.Drawing.RectangleF -&gt; unit" Usage="graphics.DrawString (s, font, brush, layoutRectangle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="font" Type="System.Drawing.Font" />
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="layoutRectangle" Type="System.Drawing.RectangleF" />
      </Parameters>
      <Docs>
        <param name="s">Zu zeichnende Zeichenfolge.</param>
        <param name="font">
          <see cref="T:System.Drawing.Font" />, die das Textformat der Zeichenfolge definiert.</param>
        <param name="brush">
          <see cref="T:System.Drawing.Brush" />, der die Farbe und Struktur des gezeichneten Texts bestimmt.</param>
        <param name="layoutRectangle">
          <see cref="T:System.Drawing.RectangleF" />-Struktur, die die Position des gezeichneten Textes angibt.</param>
        <summary>Zeichnet die angegebene Textzeichenfolge in dem angegebenen Rechteck mit dem angegebenen <see cref="T:System.Drawing.Brush" />-Objekt und dem angegebenen <see cref="T:System.Drawing.Font" />-Objekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Text, dargestellt durch die `s` -Parameter gezeichnet wird, in das Rechteck, dargestellt durch die `layoutRectangle` Parameter. Wenn der Text nicht in das Rechteck passt, wird es auf das nächste Wort abgeschnitten. Um weiter zu ändern, wie die Zeichenfolge in die Verwendung des Rechtecks gezeichnet wird die <xref:System.Drawing.Graphics.DrawString%2A> -Überladung mit einem <xref:System.Drawing.StringFormat>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt eine Textzeichenfolge, die gezeichnet werden soll.  
  
-   Definiert die Schriftart Arial (16).  
  
-   Erstellt einen solide, schwarzen Pinsel zum Zeichnen.  
  
-   Erstellt ein Rechteck in der den Text gezeichnet werden soll.  
  
-   Zeichnet das Rechteck auf dem Bildschirm an.  
  
-   Zeichnet die Zeichenfolge mit der Schriftart, Pinsel und Zielrechtecks auf dem Bildschirm an.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#86](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#86)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#86](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#86)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#86](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#86)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="brush" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="s" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Forms.TextRenderer.DrawText(System.Drawing.IDeviceContext,System.String,System.Drawing.Font,System.Drawing.Point,System.Drawing.Color)" />
        <related type="Article" href="~/docs/framework/winforms/advanced/using-fonts-and-text.md">Verwenden von Schriftarten und Text</related>
      </Docs>
    </Member>
    <Member MemberName="DrawString">
      <MemberSignature Language="C#" Value="public void DrawString (string s, System.Drawing.Font font, System.Drawing.Brush brush, System.Drawing.PointF point, System.Drawing.StringFormat format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawString(string s, class System.Drawing.Font font, class System.Drawing.Brush brush, valuetype System.Drawing.PointF point, class System.Drawing.StringFormat format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawString(System.String,System.Drawing.Font,System.Drawing.Brush,System.Drawing.PointF,System.Drawing.StringFormat)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawString(System::String ^ s, System::Drawing::Font ^ font, System::Drawing::Brush ^ brush, System::Drawing::PointF point, System::Drawing::StringFormat ^ format);" />
      <MemberSignature Language="F#" Value="member this.DrawString : string * System.Drawing.Font * System.Drawing.Brush * System.Drawing.PointF * System.Drawing.StringFormat -&gt; unit" Usage="graphics.DrawString (s, font, brush, point, format)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="font" Type="System.Drawing.Font" />
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="point" Type="System.Drawing.PointF" />
        <Parameter Name="format" Type="System.Drawing.StringFormat" />
      </Parameters>
      <Docs>
        <param name="s">Zu zeichnende Zeichenfolge.</param>
        <param name="font">
          <see cref="T:System.Drawing.Font" />, die das Textformat der Zeichenfolge definiert.</param>
        <param name="brush">
          <see cref="T:System.Drawing.Brush" />, der die Farbe und Struktur des gezeichneten Texts bestimmt.</param>
        <param name="point">
          <see cref="T:System.Drawing.PointF" />-Struktur, die die obere linke Ecke des gezeichneten Textes angibt.</param>
        <param name="format">
          <see cref="T:System.Drawing.StringFormat" />, das die Formatierungsattribute angibt, die auf den gezeichneten Text angewendet werden, z. B. Zeilenabstand und Ausrichtung.</param>
        <summary>Zeichnet die angegebene Zeichenfolge an der angegebenen Position mit dem angegebenen <see cref="T:System.Drawing.Brush" />-Objekt und dem angegebenen <see cref="T:System.Drawing.Font" />-Objekt unter Verwendung der Formatierungsattribute vom angegebenen <see cref="T:System.Drawing.StringFormat" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt eine Textzeichenfolge, die gezeichnet werden soll.  
  
-   Definiert die Schriftart Arial (16).  
  
-   Erstellt einen solide, schwarzen Pinsel zum Zeichnen.  
  
-   Erstellt einen Punkt für die linke obere Ecke unter der den Text gezeichnet werden soll.  
  
-   Legt das Format der Zeichenfolge, die vertikal gezeichnet werden soll.  
  
-   Zeichnet die Zeichenfolge mit der Schriftart, Pinsel, Ziel und Format auf dem Bildschirm an.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#85](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#85)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#85](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#85)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#85](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#85)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="brush" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="s" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Forms.TextRenderer.DrawText(System.Drawing.IDeviceContext,System.String,System.Drawing.Font,System.Drawing.Point,System.Drawing.Color)" />
        <related type="Article" href="~/docs/framework/winforms/advanced/using-fonts-and-text.md">Verwenden von Schriftarten und Text</related>
      </Docs>
    </Member>
    <Member MemberName="DrawString">
      <MemberSignature Language="C#" Value="public void DrawString (string s, System.Drawing.Font font, System.Drawing.Brush brush, System.Drawing.RectangleF layoutRectangle, System.Drawing.StringFormat format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawString(string s, class System.Drawing.Font font, class System.Drawing.Brush brush, valuetype System.Drawing.RectangleF layoutRectangle, class System.Drawing.StringFormat format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawString(System.String,System.Drawing.Font,System.Drawing.Brush,System.Drawing.RectangleF,System.Drawing.StringFormat)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawString(System::String ^ s, System::Drawing::Font ^ font, System::Drawing::Brush ^ brush, System::Drawing::RectangleF layoutRectangle, System::Drawing::StringFormat ^ format);" />
      <MemberSignature Language="F#" Value="member this.DrawString : string * System.Drawing.Font * System.Drawing.Brush * System.Drawing.RectangleF * System.Drawing.StringFormat -&gt; unit" Usage="graphics.DrawString (s, font, brush, layoutRectangle, format)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="font" Type="System.Drawing.Font" />
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="layoutRectangle" Type="System.Drawing.RectangleF" />
        <Parameter Name="format" Type="System.Drawing.StringFormat" />
      </Parameters>
      <Docs>
        <param name="s">Zu zeichnende Zeichenfolge.</param>
        <param name="font">
          <see cref="T:System.Drawing.Font" />, die das Textformat der Zeichenfolge definiert.</param>
        <param name="brush">
          <see cref="T:System.Drawing.Brush" />, der die Farbe und Struktur des gezeichneten Texts bestimmt.</param>
        <param name="layoutRectangle">
          <see cref="T:System.Drawing.RectangleF" />-Struktur, die die Position des gezeichneten Textes angibt.</param>
        <param name="format">
          <see cref="T:System.Drawing.StringFormat" />, das die Formatierungsattribute angibt, die auf den gezeichneten Text angewendet werden, z. B. Zeilenabstand und Ausrichtung.</param>
        <summary>Zeichnet die angegebene Zeichenfolge im angegebenen Rechteck mit dem angegebenen <see cref="T:System.Drawing.Brush" />-Objekt und dem angegebenen <see cref="T:System.Drawing.Font" />-Objekt unter Verwendung der Formatierungsattribute vom angegebenen <see cref="T:System.Drawing.StringFormat" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Text, dargestellt durch die `s` -Parameter gezeichnet wird, in das Rechteck, dargestellt durch die `layoutRectangle` Parameter. Wenn der Text nicht in das Rechteck passt, wird Sie abgeschnitten auf das nächste Wort, sofern nicht anders angegeben mit der `format` Parameter.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt eine Textzeichenfolge, die gezeichnet werden soll.  
  
-   Definiert die Schriftart Arial (16).  
  
-   Erstellt einen solide, schwarzen Pinsel zum Zeichnen.  
  
-   Erstellt ein Rechteck in der den Text gezeichnet werden soll.  
  
-   Zeichnet das Rechteck auf dem Bildschirm an.  
  
-   Legt das Format der Zeichenfolge, die sie innerhalb des Rechtecks zu zentrieren.  
  
-   Zeichnet die Zeichenfolge mit der Schriftart, Pinsel und Zielrechtecks auf dem Bildschirm an.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#87](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#87)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#87](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#87)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#87](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#87)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="brush" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="s" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Forms.TextRenderer.DrawText(System.Drawing.IDeviceContext,System.String,System.Drawing.Font,System.Drawing.Point,System.Drawing.Color)" />
        <related type="Article" href="~/docs/framework/winforms/advanced/using-fonts-and-text.md">Verwenden von Schriftarten und Text</related>
      </Docs>
    </Member>
    <Member MemberName="DrawString">
      <MemberSignature Language="C#" Value="public void DrawString (string s, System.Drawing.Font font, System.Drawing.Brush brush, float x, float y);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawString(string s, class System.Drawing.Font font, class System.Drawing.Brush brush, float32 x, float32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawString(System.String,System.Drawing.Font,System.Drawing.Brush,System.Single,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawString(System::String ^ s, System::Drawing::Font ^ font, System::Drawing::Brush ^ brush, float x, float y);" />
      <MemberSignature Language="F#" Value="member this.DrawString : string * System.Drawing.Font * System.Drawing.Brush * single * single -&gt; unit" Usage="graphics.DrawString (s, font, brush, x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="font" Type="System.Drawing.Font" />
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="s">Zu zeichnende Zeichenfolge.</param>
        <param name="font">
          <see cref="T:System.Drawing.Font" />, die das Textformat der Zeichenfolge definiert.</param>
        <param name="brush">
          <see cref="T:System.Drawing.Brush" />, der die Farbe und Struktur des gezeichneten Texts bestimmt.</param>
        <param name="x">Die x-Koordinate der oberen linken Ecke des gezeichneten Texts.</param>
        <param name="y">Die y-Koordinate der oberen linken Ecke des gezeichneten Texts.</param>
        <summary>Zeichnet die angegebene Textzeichenfolge an der angegebenen Position mit dem angegebenen <see cref="T:System.Drawing.Brush" />-Objekt und dem angegebenen <see cref="T:System.Drawing.Font" />-Objekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt eine Textzeichenfolge, die gezeichnet werden soll.  
  
-   Definiert die Schriftart Arial (16).  
  
-   Erstellt einen durchgehenden schwarzen Pinsel zum Zeichnen.  
  
-   Erstellt einen Punkt für die linke obere Ecke unter der den Text gezeichnet werden soll.  
  
-   Zeichnet die Zeichenfolge mit der Schriftart, Pinsel und Ziel auf dem Bildschirm an.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#88](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#88)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#88](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#88)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#88](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#88)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="brush" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="s" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Forms.TextRenderer.DrawText(System.Drawing.IDeviceContext,System.String,System.Drawing.Font,System.Drawing.Point,System.Drawing.Color)" />
        <related type="Article" href="~/docs/framework/winforms/advanced/using-fonts-and-text.md">Verwenden von Schriftarten und Text</related>
      </Docs>
    </Member>
    <Member MemberName="DrawString">
      <MemberSignature Language="C#" Value="public void DrawString (string s, System.Drawing.Font font, System.Drawing.Brush brush, float x, float y, System.Drawing.StringFormat format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawString(string s, class System.Drawing.Font font, class System.Drawing.Brush brush, float32 x, float32 y, class System.Drawing.StringFormat format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawString(System.String,System.Drawing.Font,System.Drawing.Brush,System.Single,System.Single,System.Drawing.StringFormat)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawString(System::String ^ s, System::Drawing::Font ^ font, System::Drawing::Brush ^ brush, float x, float y, System::Drawing::StringFormat ^ format);" />
      <MemberSignature Language="F#" Value="member this.DrawString : string * System.Drawing.Font * System.Drawing.Brush * single * single * System.Drawing.StringFormat -&gt; unit" Usage="graphics.DrawString (s, font, brush, x, y, format)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="font" Type="System.Drawing.Font" />
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="format" Type="System.Drawing.StringFormat" />
      </Parameters>
      <Docs>
        <param name="s">Zu zeichnende Zeichenfolge.</param>
        <param name="font">
          <see cref="T:System.Drawing.Font" />, die das Textformat der Zeichenfolge definiert.</param>
        <param name="brush">
          <see cref="T:System.Drawing.Brush" />, der die Farbe und Struktur des gezeichneten Texts bestimmt.</param>
        <param name="x">Die x-Koordinate der oberen linken Ecke des gezeichneten Texts.</param>
        <param name="y">Die y-Koordinate der oberen linken Ecke des gezeichneten Texts.</param>
        <param name="format">
          <see cref="T:System.Drawing.StringFormat" />, das die Formatierungsattribute angibt, die auf den gezeichneten Text angewendet werden, z. B. Zeilenabstand und Ausrichtung.</param>
        <summary>Zeichnet die angegebene Zeichenfolge an der angegebenen Position mit dem angegebenen <see cref="T:System.Drawing.Brush" />-Objekt und dem angegebenen <see cref="T:System.Drawing.Font" />-Objekt unter Verwendung der Formatierungsattribute vom angegebenen <see cref="T:System.Drawing.StringFormat" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt eine Textzeichenfolge, die gezeichnet werden soll.  
  
-   Definiert die Schriftart Arial (16).  
  
-   Erstellt einen solide, schwarzen Pinsel zum Zeichnen.  
  
-   Erstellt die Koordinaten eines Punkts für die linke obere Ecke unter der den Text gezeichnet werden soll.  
  
-   Legt das Format der Zeichenfolge, die vertikal gezeichnet werden soll  
  
-   Zeichnet die Zeichenfolge mit der Schriftart, Pinsel, Ziel und Format auf dem Bildschirm an.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#89](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#89)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#89](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#89)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#89](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#89)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="brush" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="s" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Forms.TextRenderer.DrawText(System.Drawing.IDeviceContext,System.String,System.Drawing.Font,System.Drawing.Point,System.Drawing.Color)" />
        <related type="Article" href="~/docs/framework/winforms/advanced/using-fonts-and-text.md">Verwenden von Schriftarten und Text</related>
      </Docs>
    </Member>
    <Member MemberName="EndContainer">
      <MemberSignature Language="C#" Value="public void EndContainer (System.Drawing.Drawing2D.GraphicsContainer container);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndContainer(class System.Drawing.Drawing2D.GraphicsContainer container) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EndContainer(System.Drawing.Drawing2D.GraphicsContainer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndContainer (container As GraphicsContainer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndContainer(System::Drawing::Drawing2D::GraphicsContainer ^ container);" />
      <MemberSignature Language="F#" Value="member this.EndContainer : System.Drawing.Drawing2D.GraphicsContainer -&gt; unit" Usage="graphics.EndContainer container" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="container" Type="System.Drawing.Drawing2D.GraphicsContainer" />
      </Parameters>
      <Docs>
        <param name="container">
          <see cref="T:System.Drawing.Drawing2D.GraphicsContainer" />, der den Container darstellt, den diese Methode wiederherstellt.</param>
        <summary>Schließt den aktuellen Grafikcontainer und stellt den Zustand dieses <see cref="T:System.Drawing.Graphics" /> wieder her, der durch einen Aufruf der <see cref="M:System.Drawing.Graphics.BeginContainer" />-Methode gespeichert wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode mit dem <xref:System.Drawing.Graphics.BeginContainer%2A> Methode zum Erstellen von geschachtelter Grafikcontainer. Grafikcontainer behalten Grafikstatus, z. B. die Transformation, Ausschneidebereich und Renderingeigenschaften.  
  
 Beim Aufrufen der <xref:System.Drawing.Graphics.BeginContainer%2A> -Methode der ein <xref:System.Drawing.Graphics>, ein Informationsblock mit den Status des der <xref:System.Drawing.Graphics> auf einem Stapel abgelegt. Die <xref:System.Drawing.Graphics.BeginContainer%2A> Methode gibt eine <xref:System.Drawing.Drawing2D.GraphicsContainer> , die den Informationsblock identifiziert. Wenn Sie das zu identifizierende Objekt übergeben die <xref:System.Drawing.Graphics.EndContainer%2A> -Methode der Informationsblock wird aus dem Stapel entfernt und wird verwendet, um die Wiederherstellung der <xref:System.Drawing.Graphics> in den Zustand zum Zeitpunkt der war die <xref:System.Drawing.Graphics.BeginContainer%2A> Methodenaufruf.  
  
 Container können geschachtelt werden. d. h., rufen Sie die <xref:System.Drawing.Graphics.BeginContainer%2A> Methode mehrmals vor dem Aufruf der <xref:System.Drawing.Graphics.EndContainer%2A> Methode. Bei jedem Aufruf der <xref:System.Drawing.Graphics.BeginContainer%2A> -Methode, ein Informationsblock ist auf dem Stapel abgelegt, und Sie erhalten eine <xref:System.Drawing.Drawing2D.GraphicsContainer> für den Informationsblock. Wenn Sie eines dieser Objekte zu übergeben die <xref:System.Drawing.Graphics.EndContainer%2A> -Methode, die <xref:System.Drawing.Graphics> wird zurückgegeben, um den Zustand zum Zeitpunkt der war die <xref:System.Drawing.Graphics.BeginContainer%2A> Methodenaufruf, der das bestimmte zurückgegeben <xref:System.Drawing.Drawing2D.GraphicsContainer>. Der Informationsblock auf dem Stapel abgelegt werden, von der <xref:System.Drawing.Graphics.BeginContainer%2A> Methodenaufruf wird aus dem Stapel entfernt, und alle Informationsblöcke, die nach, die auf diesem Stapel abgelegt <xref:System.Drawing.Graphics.BeginContainer%2A> Methodenaufruf werden ebenfalls entfernt.  
  
 Aufrufe von der <xref:System.Drawing.Graphics.Save%2A> Methode Informationsblöcke auf demselben Stapel als Aufrufe an die <xref:System.Drawing.Graphics.BeginContainer%2A> Methode. Ebenso wie eine <xref:System.Drawing.Graphics.EndContainer%2A> -Methodenaufruf zugeordnet ist eine <xref:System.Drawing.Graphics.BeginContainer%2A> -Methodenaufruf, einen <xref:System.Drawing.Graphics.Restore%2A> -Methodenaufruf zugeordnet ist eine <xref:System.Drawing.Graphics.Save%2A> Methodenaufruf.  
  
 Beim Aufrufen der <xref:System.Drawing.Graphics.EndContainer%2A> -Methode, alle Informationsblöcke, die auf dem Stapel abgelegt (durch die <xref:System.Drawing.Graphics.Save%2A> Methode oder der <xref:System.Drawing.Graphics.BeginContainer%2A> Methode) nach dem entsprechenden Aufruf von der <xref:System.Drawing.Graphics.BeginContainer%2A> -Methode aus dem Stapel entfernt werden. Wenn rufen Sie dementsprechend die <xref:System.Drawing.Graphics.Restore%2A> -Methode, alle Informationsblöcke, die auf dem Stapel abgelegt (von der <xref:System.Drawing.Graphics.Save%2A> Methode oder durch die <xref:System.Drawing.Graphics.BeginContainer%2A> Methode) nach dem entsprechenden Aufruf von der <xref:System.Drawing.Graphics.Save%2A> -Methode aus dem Stapel entfernt werden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Öffnet einen neuen Grafikcontainer und speichert den alten Container.  
  
-   Übersetzt die globalen Koordinaten im Container.  
  
-   Füllt ein rotes Rechteck die (Koordinaten des übersetzt die) neuen Container.  
  
-   Schließt den neuen Container und die gespeicherten Container wiederhergestellt.  
  
-   Füllt ein grünes Rechteck (um die nicht übersetzten Koordinaten) des Containers gespeichert.  
  
 Das Ergebnis ist ein grünes Rechteck, das unter dem ein rotes Rechteck mit derselben Größe sich befindet.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#90](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#90)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#90](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#90)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#90](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#90)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="EnumerateMetafile">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sendet die Datensätze im angegebenen <see cref="T:System.Drawing.Imaging.Metafile" /> einzeln an eine Rückrufmethode zum Anzeigen an einem bestimmten Punkt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.Point destPoint, System.Drawing.Graphics.EnumerateMetafileProc callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.Point destPoint, class System.Drawing.Graphics/EnumerateMetafileProc callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Point,System.Drawing.Graphics.EnumerateMetafileProc)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::Point destPoint, System::Drawing::Graphics::EnumerateMetafileProc ^ callback);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.Point * System.Drawing.Graphics.EnumerateMetafileProc -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoint, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoint" Type="System.Drawing.Point" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
      </Parameters>
      <Docs>
        <param name="metafile">Aufzulistendes <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
        <param name="destPoint">
          <see cref="T:System.Drawing.Point" />-Struktur, die die Position der oberen linken Ecke der gezeichneten Metadatei angibt.</param>
        <param name="callback">
          <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" />-Delegat, der die Methode angibt, an die die Datensätze der Metadatei gesendet werden.</param>
        <summary>Sendet die Datensätze im angegebenen <see cref="T:System.Drawing.Imaging.Metafile" /> einzeln an eine Rückrufmethode zum Anzeigen an einem bestimmten Punkt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zählt die Datensätze in der angegebenen Metadatei enthalten sind. Jeder Datensatz wird einzeln an eine Rückrufmethode, die anhand des gesendet der `callback` Parameter. In der Regel die Rückrufmethode Ruft die <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> Methode "wiedergeben", oder Zeichnen-Befehl, den Datensatz.  
  
 Wenn die Callback-Methode ruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, muss hierzu die <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> Methode der spezifischen <xref:System.Drawing.Imaging.Metafile> , aufgezählt wird.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt ein Formular, die eine <xref:System.Drawing.Imaging.Metafile> als eines seiner privaten Member. Die <xref:System.Windows.Forms.Control.OnPaint%2A> Methodenaufrufe <xref:System.Drawing.Graphics.EnumerateMetafile%2A>, die Aufrufe des Formulars `MetafileCallback` Methode für jeden Datensatz in der Metadatei. Die `MetafileCallback`-Methode ruft die <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>-Methode auf. Beachten Sie, dass die `MetafileCallback` Methode empfängt die Daten des Datensatzes als ein <xref:System.IntPtr>, aber die <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> Methode erwartet, dass die Daten des Datensatzes ein Byte-Array sein. Der Aufruf von <xref:System.Runtime.InteropServices.Marshal.Copy%2A> kopiert die Daten des Datensatzes in ein Bytearray, damit sie an übergeben kann <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>.  
  
 [!code-csharp[System.Drawing.Graphics.EnumerateMetafile#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Graphics.EnumerateMetafile/CS/Form1.cs#1)]
 [!code-vb[System.Drawing.Graphics.EnumerateMetafile#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Graphics.EnumerateMetafile/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.Point[] destPoints, System.Drawing.Graphics.EnumerateMetafileProc callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.Point[] destPoints, class System.Drawing.Graphics/EnumerateMetafileProc callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Point[],System.Drawing.Graphics.EnumerateMetafileProc)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, cli::array &lt;System::Drawing::Point&gt; ^ destPoints, System::Drawing::Graphics::EnumerateMetafileProc ^ callback);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.Point[] * System.Drawing.Graphics.EnumerateMetafileProc -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoints, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoints" Type="System.Drawing.Point[]" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
      </Parameters>
      <Docs>
        <param name="metafile">Aufzulistendes <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
        <param name="destPoints">Array von drei <see cref="T:System.Drawing.Point" />-Strukturen, die ein Parallelogramm definieren, das die Größe und Position der gezeichneten Metadatei bestimmt.</param>
        <param name="callback">
          <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" />-Delegat, der die Methode angibt, an die die Datensätze der Metadatei gesendet werden.</param>
        <summary>Sendet die Datensätze im angegebenen <see cref="T:System.Drawing.Imaging.Metafile" /> einzeln an eine Rückrufmethode zum Anzeigen in einem bestimmten Parallelogramm.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zählt die Datensätze in der angegebenen Metadatei enthalten sind. Jeder Datensatz wird einzeln an eine Rückrufmethode, die anhand des gesendet der `callback` Parameter. In der Regel die Rückrufmethode Ruft die <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> Methode "wiedergeben", oder Zeichnen-Befehl, den Datensatz.  
  
 Wenn die Callback-Methode ruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, muss hierzu die <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> Methode der spezifischen <xref:System.Drawing.Imaging.Metafile> , aufgezählt wird.  
  
   
  
## Examples  
 Ein Codebeispiel finden Sie unter <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.PointF destPoint, System.Drawing.Graphics.EnumerateMetafileProc callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.PointF destPoint, class System.Drawing.Graphics/EnumerateMetafileProc callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.PointF,System.Drawing.Graphics.EnumerateMetafileProc)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::PointF destPoint, System::Drawing::Graphics::EnumerateMetafileProc ^ callback);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.PointF * System.Drawing.Graphics.EnumerateMetafileProc -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoint, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoint" Type="System.Drawing.PointF" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
      </Parameters>
      <Docs>
        <param name="metafile">Aufzulistendes <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
        <param name="destPoint">
          <see cref="T:System.Drawing.PointF" />-Struktur, die die Position der oberen linken Ecke der gezeichneten Metadatei angibt.</param>
        <param name="callback">
          <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" />-Delegat, der die Methode angibt, an die die Datensätze der Metadatei gesendet werden.</param>
        <summary>Sendet die Datensätze im angegebenen <see cref="T:System.Drawing.Imaging.Metafile" /> einzeln an eine Rückrufmethode zum Anzeigen an einem bestimmten Punkt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zählt die Datensätze in der angegebenen Metadatei enthalten sind. Jeder Datensatz wird einzeln an eine Rückrufmethode, die anhand des gesendet der `callback` Parameter. In der Regel die Rückrufmethode Ruft die <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> Methode "wiedergeben", oder Zeichnen-Befehl, den Datensatz.  
  
 Wenn die Callback-Methode ruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, muss hierzu die <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> Methode der spezifischen <xref:System.Drawing.Imaging.Metafile> , aufgezählt wird.  
  
   
  
## Examples  
 Ein Codebeispiel finden Sie unter <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.PointF[] destPoints, System.Drawing.Graphics.EnumerateMetafileProc callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.PointF[] destPoints, class System.Drawing.Graphics/EnumerateMetafileProc callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.PointF[],System.Drawing.Graphics.EnumerateMetafileProc)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, cli::array &lt;System::Drawing::PointF&gt; ^ destPoints, System::Drawing::Graphics::EnumerateMetafileProc ^ callback);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.PointF[] * System.Drawing.Graphics.EnumerateMetafileProc -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoints, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoints" Type="System.Drawing.PointF[]" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
      </Parameters>
      <Docs>
        <param name="metafile">Aufzulistendes <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
        <param name="destPoints">Array von drei <see cref="T:System.Drawing.PointF" />-Strukturen, die ein Parallelogramm definieren, das die Größe und Position der gezeichneten Metadatei bestimmt.</param>
        <param name="callback">
          <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" />-Delegat, der die Methode angibt, an die die Datensätze der Metadatei gesendet werden.</param>
        <summary>Sendet die Datensätze im angegebenen <see cref="T:System.Drawing.Imaging.Metafile" /> einzeln an eine Rückrufmethode zum Anzeigen in einem bestimmten Parallelogramm.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zählt die Datensätze in der angegebenen Metadatei enthalten sind. Jeder Datensatz wird einzeln an eine Rückrufmethode, die anhand des gesendet der `callback` Parameter. In der Regel die Rückrufmethode Ruft die <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> Methode "wiedergeben", oder Zeichnen-Befehl, den Datensatz.  
  
 Wenn die Callback-Methode ruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, muss hierzu die <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> Methode der spezifischen <xref:System.Drawing.Imaging.Metafile> , aufgezählt wird.  
  
 Die `destPoints` Parameter gibt die drei Punkte eines Parallelogramms an. Die drei <xref:System.Drawing.PointF> -Strukturen stellen die oberen linken, oberen rechten und unteren linken Ecke des Parallelogramms. Der vierte Punkt ist über die ersten drei zu einem Parallelogramm extrapoliert. Die gezeichnete Metadatei ist skaliert und entsprechend Parallelogramms verbogen.  
  
   
  
## Examples  
 Ein Codebeispiel finden Sie unter <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.Rectangle destRect, System.Drawing.Graphics.EnumerateMetafileProc callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.Rectangle destRect, class System.Drawing.Graphics/EnumerateMetafileProc callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Rectangle,System.Drawing.Graphics.EnumerateMetafileProc)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::Rectangle destRect, System::Drawing::Graphics::EnumerateMetafileProc ^ callback);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.Rectangle * System.Drawing.Graphics.EnumerateMetafileProc -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destRect, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
      </Parameters>
      <Docs>
        <param name="metafile">Aufzulistendes <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
        <param name="destRect">
          <see cref="T:System.Drawing.Rectangle" />-Struktur, die die Position und Größe der gezeichneten Metadatei angibt.</param>
        <param name="callback">
          <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" />-Delegat, der die Methode angibt, an die die Datensätze der Metadatei gesendet werden.</param>
        <summary>Sendet die Datensätze im angegebenen <see cref="T:System.Drawing.Imaging.Metafile" /> einzeln an eine Rückrufmethode zum Anzeigen in einem bestimmten Rechteck.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zählt die Datensätze in der angegebenen Metadatei enthalten sind. Jeder Datensatz wird einzeln an eine Rückrufmethode, die anhand des gesendet der `callback` Parameter. In der Regel die Rückrufmethode Ruft die <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> Methode "wiedergeben", oder Zeichnen-Befehl, den Datensatz.  
  
 Wenn die Callback-Methode ruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, muss hierzu die <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> Methode der spezifischen <xref:System.Drawing.Imaging.Metafile> , aufgezählt wird.  
  
   
  
## Examples  
 Ein Codebeispiel finden Sie unter <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.RectangleF destRect, System.Drawing.Graphics.EnumerateMetafileProc callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.RectangleF destRect, class System.Drawing.Graphics/EnumerateMetafileProc callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.RectangleF,System.Drawing.Graphics.EnumerateMetafileProc)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::RectangleF destRect, System::Drawing::Graphics::EnumerateMetafileProc ^ callback);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.RectangleF * System.Drawing.Graphics.EnumerateMetafileProc -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destRect, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
      </Parameters>
      <Docs>
        <param name="metafile">Aufzulistendes <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
        <param name="destRect">
          <see cref="T:System.Drawing.RectangleF" />-Struktur, die die Position und Größe der gezeichneten Metadatei angibt.</param>
        <param name="callback">
          <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" />-Delegat, der die Methode angibt, an die die Datensätze der Metadatei gesendet werden.</param>
        <summary>Sendet die Datensätze im angegebenen <see cref="T:System.Drawing.Imaging.Metafile" /> einzeln an eine Rückrufmethode zum Anzeigen in einem bestimmten Rechteck.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zählt die Datensätze in der angegebenen Metadatei enthalten sind. Jeder Datensatz wird einzeln an eine Rückrufmethode, die anhand des gesendet der `callback` Parameter. In der Regel die Rückrufmethode Ruft die <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> Methode "wiedergeben", oder Zeichnen-Befehl, den Datensatz.  
  
 Wenn die Callback-Methode ruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, muss hierzu die <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> Methode der spezifischen <xref:System.Drawing.Imaging.Metafile> , aufgezählt wird.  
  
   
  
## Examples  
 Ein Codebeispiel finden Sie unter <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.Point destPoint, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.Point destPoint, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Point,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::Point destPoint, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.Point * System.Drawing.Graphics.EnumerateMetafileProc * nativeint -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoint, callback, callbackData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoint" Type="System.Drawing.Point" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="metafile">Aufzulistendes <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
        <param name="destPoint">
          <see cref="T:System.Drawing.Point" />-Struktur, die die Position der oberen linken Ecke der gezeichneten Metadatei angibt.</param>
        <param name="callback">
          <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" />-Delegat, der die Methode angibt, an die die Datensätze der Metadatei gesendet werden.</param>
        <param name="callbackData">Interner Zeiger, der erforderlich ist, aber ignoriert wird. Für diesen Parameter kann <see cref="F:System.IntPtr.Zero" /> übergeben werden.</param>
        <summary>Sendet die Datensätze im angegebenen <see cref="T:System.Drawing.Imaging.Metafile" /> einzeln an eine Rückrufmethode zum Anzeigen an einem bestimmten Punkt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zählt die Datensätze in der angegebenen Metadatei enthalten sind. Jeder Datensatz wird einzeln an eine Rückrufmethode, die anhand des gesendet der `callback` Parameter. In der Regel die Rückrufmethode Ruft die <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> Methode "wiedergeben", oder Zeichnen-Befehl, den Datensatz.  
  
 Wenn die Callback-Methode ruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, muss hierzu die <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> Methode der spezifischen <xref:System.Drawing.Imaging.Metafile> , aufgezählt wird.  
  
   
  
## Examples  
 Ein Codebeispiel finden Sie unter <xref:System.Drawing.Graphics.EnumerateMetafile%2A>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.Point[] destPoints, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.Point[] destPoints, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Point[],System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, cli::array &lt;System::Drawing::Point&gt; ^ destPoints, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.Point[] * System.Drawing.Graphics.EnumerateMetafileProc * nativeint -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoints, callback, callbackData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoints" Type="System.Drawing.Point[]" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="metafile">Aufzulistendes <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
        <param name="destPoints">Array von drei <see cref="T:System.Drawing.Point" />-Strukturen, die ein Parallelogramm definieren, das die Größe und Position der gezeichneten Metadatei bestimmt.</param>
        <param name="callback">
          <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" />-Delegat, der die Methode angibt, an die die Datensätze der Metadatei gesendet werden.</param>
        <param name="callbackData">Interner Zeiger, der erforderlich ist, aber ignoriert wird. Für diesen Parameter kann <see cref="F:System.IntPtr.Zero" /> übergeben werden.</param>
        <summary>Sendet die Datensätze im angegebenen <see cref="T:System.Drawing.Imaging.Metafile" /> einzeln an eine Rückrufmethode zum Anzeigen in einem bestimmten Parallelogramm.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zählt die Datensätze in der angegebenen Metadatei enthalten sind. Jeder Datensatz wird einzeln an eine Rückrufmethode, die anhand des gesendet der `callback` Parameter. In der Regel die Rückrufmethode Ruft die <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> Methode "wiedergeben", oder Zeichnen-Befehl, den Datensatz.  
  
 Wenn die Callback-Methode ruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, muss hierzu die <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> Methode der spezifischen <xref:System.Drawing.Imaging.Metafile> , aufgezählt wird.  
  
   
  
## Examples  
 Ein Codebeispiel finden Sie unter <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.PointF destPoint, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.PointF destPoint, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.PointF,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::PointF destPoint, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.PointF * System.Drawing.Graphics.EnumerateMetafileProc * nativeint -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoint, callback, callbackData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoint" Type="System.Drawing.PointF" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="metafile">Aufzulistendes <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
        <param name="destPoint">
          <see cref="T:System.Drawing.PointF" />-Struktur, die die Position der oberen linken Ecke der gezeichneten Metadatei angibt.</param>
        <param name="callback">
          <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" />-Delegat, der die Methode angibt, an die die Datensätze der Metadatei gesendet werden.</param>
        <param name="callbackData">Interner Zeiger, der erforderlich ist, aber ignoriert wird. Für diesen Parameter kann <see cref="F:System.IntPtr.Zero" /> übergeben werden.</param>
        <summary>Sendet die Datensätze im angegebenen <see cref="T:System.Drawing.Imaging.Metafile" /> einzeln an eine Rückrufmethode zum Anzeigen an einem bestimmten Punkt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zählt die Datensätze in der angegebenen Metadatei enthalten sind. Jeder Datensatz wird einzeln an eine Rückrufmethode, die anhand des gesendet der `callback` Parameter. In der Regel die Rückrufmethode Ruft die <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> Methode "wiedergeben", oder Zeichnen-Befehl, den Datensatz.  
  
 Wenn die Callback-Methode ruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, muss hierzu die <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> Methode der spezifischen <xref:System.Drawing.Imaging.Metafile> , aufgezählt wird.  
  
   
  
## Examples  
 Ein Codebeispiel finden Sie unter <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.PointF[] destPoints, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.PointF[] destPoints, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.PointF[],System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, cli::array &lt;System::Drawing::PointF&gt; ^ destPoints, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.PointF[] * System.Drawing.Graphics.EnumerateMetafileProc * nativeint -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoints, callback, callbackData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoints" Type="System.Drawing.PointF[]" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="metafile">Aufzulistendes <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
        <param name="destPoints">Array von drei <see cref="T:System.Drawing.PointF" />-Strukturen, die ein Parallelogramm definieren, das die Größe und Position der gezeichneten Metadatei bestimmt.</param>
        <param name="callback">
          <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" />-Delegat, der die Methode angibt, an die die Datensätze der Metadatei gesendet werden.</param>
        <param name="callbackData">Interner Zeiger, der erforderlich ist, aber ignoriert wird. Für diesen Parameter kann <see cref="F:System.IntPtr.Zero" /> übergeben werden.</param>
        <summary>Sendet die Datensätze im angegebenen <see cref="T:System.Drawing.Imaging.Metafile" /> einzeln an eine Rückrufmethode zum Anzeigen in einem bestimmten Parallelogramm.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zählt die Datensätze in der angegebenen Metadatei enthalten sind. Jeder Datensatz wird einzeln an eine Rückrufmethode, die anhand des gesendet der `callback` Parameter. In der Regel die Rückrufmethode Ruft die <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> Methode "wiedergeben", oder Zeichnen-Befehl, den Datensatz.  
  
 Wenn die Callback-Methode ruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, muss hierzu die <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> Methode der spezifischen <xref:System.Drawing.Imaging.Metafile> , aufgezählt wird.  
  
 Die `destPoints` Parameter gibt die drei Punkte eines Parallelogramms an. Die drei <xref:System.Drawing.PointF> -Strukturen stellen die oberen linken, oberen rechten und unteren linken Ecke des Parallelogramms. Der vierte Punkt ist über die ersten drei zu einem Parallelogramm extrapoliert. Die gezeichnete Metadatei ist skaliert und entsprechend Parallelogramms verbogen.  
  
   
  
## Examples  
 Ein Codebeispiel finden Sie unter <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.Rectangle destRect, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.Rectangle destRect, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Rectangle,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::Rectangle destRect, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.Rectangle * System.Drawing.Graphics.EnumerateMetafileProc * nativeint -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destRect, callback, callbackData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="metafile">Aufzulistendes <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
        <param name="destRect">
          <see cref="T:System.Drawing.Rectangle" />-Struktur, die die Position und Größe der gezeichneten Metadatei angibt.</param>
        <param name="callback">
          <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" />-Delegat, der die Methode angibt, an die die Datensätze der Metadatei gesendet werden.</param>
        <param name="callbackData">Interner Zeiger, der erforderlich ist, aber ignoriert wird. Für diesen Parameter kann <see cref="F:System.IntPtr.Zero" /> übergeben werden.</param>
        <summary>Sendet die Datensätze im angegebenen <see cref="T:System.Drawing.Imaging.Metafile" /> einzeln an eine Rückrufmethode zum Anzeigen in einem bestimmten Rechteck.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zählt die Datensätze in der angegebenen Metadatei enthalten sind. Jeder Datensatz wird einzeln an eine Rückrufmethode, die anhand des gesendet der `callback` Parameter. In der Regel die Rückrufmethode Ruft die <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> Methode "wiedergeben", oder Zeichnen-Befehl, den Datensatz.  
  
 Wenn die Callback-Methode ruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, muss hierzu die <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> Methode der spezifischen <xref:System.Drawing.Imaging.Metafile> , aufgezählt wird.  
  
   
  
## Examples  
 Ein Codebeispiel finden Sie unter <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.RectangleF destRect, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.RectangleF destRect, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.RectangleF,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::RectangleF destRect, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.RectangleF * System.Drawing.Graphics.EnumerateMetafileProc * nativeint -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destRect, callback, callbackData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="metafile">Aufzulistendes <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
        <param name="destRect">
          <see cref="T:System.Drawing.RectangleF" />-Struktur, die die Position und Größe der gezeichneten Metadatei angibt.</param>
        <param name="callback">
          <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" />-Delegat, der die Methode angibt, an die die Datensätze der Metadatei gesendet werden.</param>
        <param name="callbackData">Interner Zeiger, der erforderlich ist, aber ignoriert wird. Für diesen Parameter kann <see cref="F:System.IntPtr.Zero" /> übergeben werden.</param>
        <summary>Sendet die Datensätze im angegebenen <see cref="T:System.Drawing.Imaging.Metafile" /> einzeln an eine Rückrufmethode zum Anzeigen in einem bestimmten Rechteck.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zählt die Datensätze in der angegebenen Metadatei enthalten sind. Jeder Datensatz wird einzeln an eine Rückrufmethode, die anhand des gesendet der `callback` Parameter. In der Regel die Rückrufmethode Ruft die <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> Methode "wiedergeben", oder Zeichnen-Befehl, den Datensatz.  
  
 Wenn die Callback-Methode ruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, muss hierzu die <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> Methode der spezifischen <xref:System.Drawing.Imaging.Metafile> , aufgezählt wird.  
  
   
  
## Examples  
 Ein Codebeispiel finden Sie unter <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.Point destPoint, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData, System.Drawing.Imaging.ImageAttributes imageAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.Point destPoint, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData, class System.Drawing.Imaging.ImageAttributes imageAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Point,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr,System.Drawing.Imaging.ImageAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::Point destPoint, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData, System::Drawing::Imaging::ImageAttributes ^ imageAttr);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.Point * System.Drawing.Graphics.EnumerateMetafileProc * nativeint * System.Drawing.Imaging.ImageAttributes -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoint, callback, callbackData, imageAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoint" Type="System.Drawing.Point" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
      </Parameters>
      <Docs>
        <param name="metafile">Aufzulistendes <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
        <param name="destPoint">
          <see cref="T:System.Drawing.Point" />-Struktur, die die Position der oberen linken Ecke der gezeichneten Metadatei angibt.</param>
        <param name="callback">
          <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" />-Delegat, der die Methode angibt, an die die Datensätze der Metadatei gesendet werden.</param>
        <param name="callbackData">Interner Zeiger, der erforderlich ist, aber ignoriert wird. Für diesen Parameter kann <see cref="F:System.IntPtr.Zero" /> übergeben werden.</param>
        <param name="imageAttr">
          <see cref="T:System.Drawing.Imaging.ImageAttributes" />, das Informationen über Bildattribute für das gezeichnete Bild angibt.</param>
        <summary>Sendet die Datensätze des angegebenen <see cref="T:System.Drawing.Imaging.Metafile" /> jeweils einzeln an eine Rückrufmethode, um sie an einem angegebenen Punkt unter Verwendung von angegebenen Bildattributen anzuzeigen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zählt die Datensätze in der angegebenen Metadatei enthalten sind. Jeder Datensatz wird einzeln an eine Rückrufmethode, die anhand des gesendet der `callback` Parameter. In der Regel die Rückrufmethode Ruft die <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> Methode "wiedergeben", oder Zeichnen-Befehl, den Datensatz.  
  
 Wenn die Callback-Methode ruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, muss hierzu die <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> Methode der spezifischen <xref:System.Drawing.Imaging.Metafile> , aufgezählt wird.  
  
   
  
## Examples  
 Ein Codebeispiel finden Sie unter <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.Point destPoint, System.Drawing.Rectangle srcRect, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Graphics.EnumerateMetafileProc callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.Point destPoint, valuetype System.Drawing.Rectangle srcRect, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Graphics/EnumerateMetafileProc callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Point,System.Drawing.Rectangle,System.Drawing.GraphicsUnit,System.Drawing.Graphics.EnumerateMetafileProc)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::Point destPoint, System::Drawing::Rectangle srcRect, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Graphics::EnumerateMetafileProc ^ callback);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.Point * System.Drawing.Rectangle * System.Drawing.GraphicsUnit * System.Drawing.Graphics.EnumerateMetafileProc -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoint, srcRect, srcUnit, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoint" Type="System.Drawing.Point" />
        <Parameter Name="srcRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
      </Parameters>
      <Docs>
        <param name="metafile">Aufzulistendes <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
        <param name="destPoint">
          <see cref="T:System.Drawing.Point" />-Struktur, die die Position der oberen linken Ecke der gezeichneten Metadatei angibt.</param>
        <param name="srcRect">
          <see cref="T:System.Drawing.Rectangle" />-Struktur, die den zu zeichnenden Teil der Metadatei relativ zur oberen linken Ecke angibt.</param>
        <param name="srcUnit">Member der <see cref="T:System.Drawing.GraphicsUnit" />-Enumeration, der die Maßeinheit angibt, mit der der Teil der Metadatei bestimmt wird, der in dem vom <paramref name="srcRect" />-Parameter angegebenen Rechteck enthalten ist.</param>
        <param name="callback">
          <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" />-Delegat, der die Methode angibt, an die die Datensätze der Metadatei gesendet werden.</param>
        <summary>Sendet die Datensätze in einem ausgewählten Rechteck eines <see cref="T:System.Drawing.Imaging.Metafile" /> einzeln an eine Rückrufmethode zum Anzeigen an einem bestimmten Punkt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zählt die Datensätze in der angegebenen Metadatei enthalten sind. Jeder Datensatz wird einzeln an eine Rückrufmethode, die anhand des gesendet der `callback` Parameter. In der Regel die Rückrufmethode Ruft die <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> Methode "wiedergeben", oder Zeichnen-Befehl, den Datensatz.  
  
 Wenn die Callback-Methode ruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, muss hierzu die <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> Methode der spezifischen <xref:System.Drawing.Imaging.Metafile> , aufgezählt wird.  
  
   
  
## Examples  
 Ein Codebeispiel finden Sie unter <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.Point[] destPoints, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData, System.Drawing.Imaging.ImageAttributes imageAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.Point[] destPoints, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData, class System.Drawing.Imaging.ImageAttributes imageAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Point[],System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr,System.Drawing.Imaging.ImageAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, cli::array &lt;System::Drawing::Point&gt; ^ destPoints, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData, System::Drawing::Imaging::ImageAttributes ^ imageAttr);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.Point[] * System.Drawing.Graphics.EnumerateMetafileProc * nativeint * System.Drawing.Imaging.ImageAttributes -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoints, callback, callbackData, imageAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoints" Type="System.Drawing.Point[]" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
      </Parameters>
      <Docs>
        <param name="metafile">Aufzulistendes <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
        <param name="destPoints">Array von drei <see cref="T:System.Drawing.Point" />-Strukturen, die ein Parallelogramm definieren, das die Größe und Position der gezeichneten Metadatei bestimmt.</param>
        <param name="callback">
          <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" />-Delegat, der die Methode angibt, an die die Datensätze der Metadatei gesendet werden.</param>
        <param name="callbackData">Interner Zeiger, der erforderlich ist, aber ignoriert wird. Für diesen Parameter kann <see cref="F:System.IntPtr.Zero" /> übergeben werden.</param>
        <param name="imageAttr">
          <see cref="T:System.Drawing.Imaging.ImageAttributes" />, das Informationen über Bildattribute für das gezeichnete Bild angibt.</param>
        <summary>Sendet die Datensätze des angegebenen <see cref="T:System.Drawing.Imaging.Metafile" /> jeweils einzeln an eine Rückrufmethode, um sie in einem angegebenen Parallelogramm unter Verwendung von angegebenen Bildattributen anzuzeigen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zählt die Datensätze in der angegebenen Metadatei enthalten sind. Jeder Datensatz wird einzeln an eine Rückrufmethode, die anhand des gesendet der `callback` Parameter. In der Regel die Rückrufmethode Ruft die <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> Methode "wiedergeben", oder Zeichnen-Befehl, den Datensatz.  
  
 Wenn die Callback-Methode ruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, muss hierzu die <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> Methode der spezifischen <xref:System.Drawing.Imaging.Metafile> , aufgezählt wird.  
  
 Die `destPoints` Parameter gibt die drei Punkte eines Parallelogramms an. Die drei <xref:System.Drawing.Point> -Strukturen stellen die oberen linken, oberen rechten und unteren linken Ecke des Parallelogramms. Der vierte Punkt ist über die ersten drei zu einem Parallelogramm extrapoliert. Die gezeichnete Metadatei ist skaliert und entsprechend Parallelogramms verbogen.  
  
 Die Image-Attribute, die gemäß der `imageAttr` Parameter ersetzen, die diese angegeben, wann die Metadatei geschrieben wurde.  
  
   
  
## Examples  
 Ein Codebeispiel finden Sie unter <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.Point[] destPoints, System.Drawing.Rectangle srcRect, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Graphics.EnumerateMetafileProc callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.Point[] destPoints, valuetype System.Drawing.Rectangle srcRect, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Graphics/EnumerateMetafileProc callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Point[],System.Drawing.Rectangle,System.Drawing.GraphicsUnit,System.Drawing.Graphics.EnumerateMetafileProc)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, cli::array &lt;System::Drawing::Point&gt; ^ destPoints, System::Drawing::Rectangle srcRect, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Graphics::EnumerateMetafileProc ^ callback);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.Point[] * System.Drawing.Rectangle * System.Drawing.GraphicsUnit * System.Drawing.Graphics.EnumerateMetafileProc -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoints, srcRect, srcUnit, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoints" Type="System.Drawing.Point[]" />
        <Parameter Name="srcRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
      </Parameters>
      <Docs>
        <param name="metafile">Aufzulistendes <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
        <param name="destPoints">Array von drei <see cref="T:System.Drawing.Point" />-Strukturen, die ein Parallelogramm definieren, das die Größe und Position der gezeichneten Metadatei bestimmt.</param>
        <param name="srcRect">
          <see cref="T:System.Drawing.Rectangle" />-Struktur, die den zu zeichnenden Teil der Metadatei relativ zur oberen linken Ecke angibt.</param>
        <param name="srcUnit">Member der <see cref="T:System.Drawing.GraphicsUnit" />-Enumeration, der die Maßeinheit angibt, mit der der Teil der Metadatei bestimmt wird, der in dem vom <paramref name="srcRect" />-Parameter angegebenen Rechteck enthalten ist.</param>
        <param name="callback">
          <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" />-Delegat, der die Methode angibt, an die die Datensätze der Metadatei gesendet werden.</param>
        <summary>Sendet die Datensätze in einem ausgewählten Rechteck eines <see cref="T:System.Drawing.Imaging.Metafile" /> einzeln an eine Rückrufmethode zum Anzeigen in einem bestimmten Parallelogramm.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zählt die Datensätze in der angegebenen Metadatei enthalten sind. Jeder Datensatz wird einzeln an eine Rückrufmethode, die anhand des gesendet der `callback` Parameter. In der Regel die Rückrufmethode Ruft die <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> Methode "wiedergeben", oder Zeichnen-Befehl, den Datensatz.  
  
 Wenn die Callback-Methode ruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, muss hierzu die <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> Methode der spezifischen <xref:System.Drawing.Imaging.Metafile> , aufgezählt wird.  
  
 Die `destPoints` Parameter gibt die drei Punkte eines Parallelogramms an. Die drei <xref:System.Drawing.Point> -Strukturen stellen die oberen linken, oberen rechten und unteren linken Ecke des Parallelogramms. Der vierte Punkt ist über die ersten drei zu einem Parallelogramm extrapoliert. Die gezeichnete Metadatei ist skaliert und entsprechend Parallelogramms verbogen.  
  
 Alle zeichnen, die findet nicht in das Rechteck, das gemäß der `srcRect` Parameter wird ignoriert.  
  
   
  
## Examples  
 Ein Codebeispiel finden Sie unter <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.PointF destPoint, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData, System.Drawing.Imaging.ImageAttributes imageAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.PointF destPoint, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData, class System.Drawing.Imaging.ImageAttributes imageAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.PointF,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr,System.Drawing.Imaging.ImageAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::PointF destPoint, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData, System::Drawing::Imaging::ImageAttributes ^ imageAttr);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.PointF * System.Drawing.Graphics.EnumerateMetafileProc * nativeint * System.Drawing.Imaging.ImageAttributes -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoint, callback, callbackData, imageAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoint" Type="System.Drawing.PointF" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
      </Parameters>
      <Docs>
        <param name="metafile">Aufzulistendes <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
        <param name="destPoint">
          <see cref="T:System.Drawing.PointF" />-Struktur, die die Position der oberen linken Ecke der gezeichneten Metadatei angibt.</param>
        <param name="callback">
          <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" />-Delegat, der die Methode angibt, an die die Datensätze der Metadatei gesendet werden.</param>
        <param name="callbackData">Interner Zeiger, der erforderlich ist, aber ignoriert wird. Für diesen Parameter kann <see cref="F:System.IntPtr.Zero" /> übergeben werden.</param>
        <param name="imageAttr">
          <see cref="T:System.Drawing.Imaging.ImageAttributes" />, das Informationen über Bildattribute für das gezeichnete Bild angibt.</param>
        <summary>Sendet die Datensätze des angegebenen <see cref="T:System.Drawing.Imaging.Metafile" /> jeweils einzeln an eine Rückrufmethode, um sie an einem angegebenen Punkt unter Verwendung von angegebenen Bildattributen anzuzeigen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zählt die Datensätze in der angegebenen Metadatei enthalten sind. Jeder Datensatz wird einzeln an eine Rückrufmethode, die anhand des gesendet der `callback` Parameter. In der Regel die Rückrufmethode Ruft die <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> Methode "wiedergeben", oder Zeichnen-Befehl, den Datensatz.  
  
 Wenn die Callback-Methode ruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, muss hierzu die Methode der spezifischen <xref:System.Drawing.Imaging.Metafile> , aufgezählt wird.  
  
 Die Image-Attribute, die gemäß der `imageAttr` Parameter ersetzen, die diese angegeben, wann die Metadatei geschrieben wurde.  
  
   
  
## Examples  
 Ein Codebeispiel finden Sie unter <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.PointF destPoint, System.Drawing.RectangleF srcRect, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Graphics.EnumerateMetafileProc callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.PointF destPoint, valuetype System.Drawing.RectangleF srcRect, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Graphics/EnumerateMetafileProc callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.PointF,System.Drawing.RectangleF,System.Drawing.GraphicsUnit,System.Drawing.Graphics.EnumerateMetafileProc)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::PointF destPoint, System::Drawing::RectangleF srcRect, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Graphics::EnumerateMetafileProc ^ callback);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.PointF * System.Drawing.RectangleF * System.Drawing.GraphicsUnit * System.Drawing.Graphics.EnumerateMetafileProc -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoint, srcRect, srcUnit, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoint" Type="System.Drawing.PointF" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
      </Parameters>
      <Docs>
        <param name="metafile">Aufzulistendes <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
        <param name="destPoint">
          <see cref="T:System.Drawing.PointF" />-Struktur, die die Position der oberen linken Ecke der gezeichneten Metadatei angibt.</param>
        <param name="srcRect">
          <see cref="T:System.Drawing.RectangleF" />-Struktur, die den zu zeichnenden Teil der Metadatei relativ zur oberen linken Ecke angibt.</param>
        <param name="srcUnit">Member der <see cref="T:System.Drawing.GraphicsUnit" />-Enumeration, der die Maßeinheit angibt, mit der der Teil der Metadatei bestimmt wird, der in dem vom <paramref name="srcRect" />-Parameter angegebenen Rechteck enthalten ist.</param>
        <param name="callback">
          <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" />-Delegat, der die Methode angibt, an die die Datensätze der Metadatei gesendet werden.</param>
        <summary>Sendet die Datensätze in einem ausgewählten Rechteck eines <see cref="T:System.Drawing.Imaging.Metafile" /> einzeln an eine Rückrufmethode zum Anzeigen an einem bestimmten Punkt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zählt die Datensätze in der angegebenen Metadatei enthalten sind. Jeder Datensatz wird einzeln an eine Rückrufmethode, die anhand des gesendet der `callback` Parameter. In der Regel die Rückrufmethode Ruft die <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> Methode "wiedergeben", oder Zeichnen-Befehl, den Datensatz.  
  
 Wenn die Callback-Methode ruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, muss hierzu die <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> Methode der spezifischen <xref:System.Drawing.Imaging.Metafile> , aufgezählt wird.  
  
 Alle zeichnen, die findet nicht in das Rechteck, das gemäß der `srcRect` Parameter wird ignoriert.  
  
   
  
## Examples  
 Ein Codebeispiel finden Sie unter <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.PointF[] destPoints, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData, System.Drawing.Imaging.ImageAttributes imageAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.PointF[] destPoints, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData, class System.Drawing.Imaging.ImageAttributes imageAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.PointF[],System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr,System.Drawing.Imaging.ImageAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, cli::array &lt;System::Drawing::PointF&gt; ^ destPoints, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData, System::Drawing::Imaging::ImageAttributes ^ imageAttr);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.PointF[] * System.Drawing.Graphics.EnumerateMetafileProc * nativeint * System.Drawing.Imaging.ImageAttributes -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoints, callback, callbackData, imageAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoints" Type="System.Drawing.PointF[]" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
      </Parameters>
      <Docs>
        <param name="metafile">Aufzulistendes <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
        <param name="destPoints">Array von drei <see cref="T:System.Drawing.PointF" />-Strukturen, die ein Parallelogramm definieren, das die Größe und Position der gezeichneten Metadatei bestimmt.</param>
        <param name="callback">
          <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" />-Delegat, der die Methode angibt, an die die Datensätze der Metadatei gesendet werden.</param>
        <param name="callbackData">Interner Zeiger, der erforderlich ist, aber ignoriert wird. Für diesen Parameter kann <see cref="F:System.IntPtr.Zero" /> übergeben werden.</param>
        <param name="imageAttr">
          <see cref="T:System.Drawing.Imaging.ImageAttributes" />, das Informationen über Bildattribute für das gezeichnete Bild angibt.</param>
        <summary>Sendet die Datensätze des angegebenen <see cref="T:System.Drawing.Imaging.Metafile" /> jeweils einzeln an eine Rückrufmethode, um sie in einem angegebenen Parallelogramm unter Verwendung von angegebenen Bildattributen anzuzeigen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zählt die Datensätze in der angegebenen Metadatei enthalten sind. Jeder Datensatz wird einzeln an eine Rückrufmethode, die anhand des gesendet der `callback` Parameter. In der Regel die Rückrufmethode Ruft die <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> Methode "wiedergeben", oder Zeichnen-Befehl, den Datensatz.  
  
 Wenn die Callback-Methode ruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, muss hierzu die <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> Methode der spezifischen <xref:System.Drawing.Imaging.Metafile> , aufgezählt wird.  
  
 Die `destPoints` Parameter gibt die drei Punkte eines Parallelogramms an. Die drei <xref:System.Drawing.PointF> -Strukturen stellen die oberen linken, oberen rechten und unteren linken Ecke des Parallelogramms. Der vierte Punkt ist über die ersten drei zu einem Parallelogramm extrapoliert. Die gezeichnete Metadatei ist skaliert und entsprechend Parallelogramms verbogen.  
  
 Die Image-Attribute, die gemäß der `imageAttr` Parameter ersetzen, die diese angegeben, wann die Metadatei geschrieben wurde.  
  
   
  
## Examples  
 Ein Codebeispiel finden Sie unter <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.PointF[] destPoints, System.Drawing.RectangleF srcRect, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Graphics.EnumerateMetafileProc callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.PointF[] destPoints, valuetype System.Drawing.RectangleF srcRect, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Graphics/EnumerateMetafileProc callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.PointF[],System.Drawing.RectangleF,System.Drawing.GraphicsUnit,System.Drawing.Graphics.EnumerateMetafileProc)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, cli::array &lt;System::Drawing::PointF&gt; ^ destPoints, System::Drawing::RectangleF srcRect, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Graphics::EnumerateMetafileProc ^ callback);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.PointF[] * System.Drawing.RectangleF * System.Drawing.GraphicsUnit * System.Drawing.Graphics.EnumerateMetafileProc -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoints, srcRect, srcUnit, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoints" Type="System.Drawing.PointF[]" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
      </Parameters>
      <Docs>
        <param name="metafile">Aufzulistendes <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
        <param name="destPoints">Array von drei <see cref="T:System.Drawing.PointF" />-Strukturen, die ein Parallelogramm definieren, das die Größe und Position der gezeichneten Metadatei bestimmt.</param>
        <param name="srcRect">
          <see cref="T:System.Drawing.RectangleF" />-Struktur, die den zu zeichnenden Teil der Metadatei relativ zur oberen linken Ecke angibt.</param>
        <param name="srcUnit">Member der <see cref="T:System.Drawing.GraphicsUnit" />-Enumeration, der die Maßeinheit angibt, mit der der Teil der Metadatei bestimmt wird, der in dem vom <paramref name="srcRect" />-Parameter angegebenen Rechteck enthalten ist.</param>
        <param name="callback">
          <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" />-Delegat, der die Methode angibt, an die die Datensätze der Metadatei gesendet werden.</param>
        <summary>Sendet die Datensätze in einem ausgewählten Rechteck eines <see cref="T:System.Drawing.Imaging.Metafile" /> einzeln an eine Rückrufmethode zum Anzeigen in einem bestimmten Parallelogramm.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zählt die Datensätze in der angegebenen Metadatei enthalten sind. Jeder Datensatz wird einzeln an eine Rückrufmethode, die anhand des gesendet der `callback` Parameter. In der Regel die Rückrufmethode Ruft die <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> Methode "wiedergeben", oder Zeichnen-Befehl, den Datensatz.  
  
 Wenn die Callback-Methode ruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, muss hierzu die <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> Methode der spezifischen <xref:System.Drawing.Imaging.Metafile> , aufgezählt wird.  
  
 Die `destPoints` Parameter gibt die drei Punkte eines Parallelogramms an. Die drei <xref:System.Drawing.Point> -Strukturen stellen die oberen linken, oberen rechten und unteren linken Ecke des Parallelogramms. Der vierte Punkt ist über die ersten drei zu einem Parallelogramm extrapoliert. Die gezeichnete Metadatei ist skaliert und entsprechend Parallelogramms verbogen.  
  
 Alle zeichnen, die findet nicht in das Rechteck, das gemäß der `srcRect` Parameter wird ignoriert.  
  
   
  
## Examples  
 Ein Codebeispiel finden Sie unter <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.Rectangle destRect, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData, System.Drawing.Imaging.ImageAttributes imageAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.Rectangle destRect, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData, class System.Drawing.Imaging.ImageAttributes imageAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Rectangle,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr,System.Drawing.Imaging.ImageAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::Rectangle destRect, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData, System::Drawing::Imaging::ImageAttributes ^ imageAttr);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.Rectangle * System.Drawing.Graphics.EnumerateMetafileProc * nativeint * System.Drawing.Imaging.ImageAttributes -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destRect, callback, callbackData, imageAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
      </Parameters>
      <Docs>
        <param name="metafile">Aufzulistendes <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
        <param name="destRect">
          <see cref="T:System.Drawing.Rectangle" />-Struktur, die die Position und Größe der gezeichneten Metadatei angibt.</param>
        <param name="callback">
          <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" />-Delegat, der die Methode angibt, an die die Datensätze der Metadatei gesendet werden.</param>
        <param name="callbackData">Interner Zeiger, der erforderlich ist, aber ignoriert wird. Für diesen Parameter kann <see cref="F:System.IntPtr.Zero" /> übergeben werden.</param>
        <param name="imageAttr">
          <see cref="T:System.Drawing.Imaging.ImageAttributes" />, das Informationen über Bildattribute für das gezeichnete Bild angibt.</param>
        <summary>Sendet die Datensätze des angegebenen <see cref="T:System.Drawing.Imaging.Metafile" /> jeweils einzeln an eine Rückrufmethode, um sie in einem angegebenen Rechteck unter Verwendung von angegebenen Bildattributen anzuzeigen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zählt die Datensätze in der angegebenen Metadatei enthalten sind. Jeder Datensatz wird einzeln an eine Rückrufmethode, die anhand des gesendet der `callback` Parameter. In der Regel die Rückrufmethode Ruft die <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> Methode "wiedergeben", oder Zeichnen-Befehl, den Datensatz.  
  
 Wenn die Callback-Methode ruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, muss hierzu die <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> Methode der spezifischen <xref:System.Drawing.Imaging.Metafile> , aufgezählt wird.  
  
 Die Image-Attribute, die gemäß der `imageAttr` Parameter ersetzen, die diese angegeben, wann die Metadatei geschrieben wurde.  
  
   
  
## Examples  
 Ein Codebeispiel finden Sie unter <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.Rectangle destRect, System.Drawing.Rectangle srcRect, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Graphics.EnumerateMetafileProc callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.Rectangle destRect, valuetype System.Drawing.Rectangle srcRect, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Graphics/EnumerateMetafileProc callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Rectangle,System.Drawing.Rectangle,System.Drawing.GraphicsUnit,System.Drawing.Graphics.EnumerateMetafileProc)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::Rectangle destRect, System::Drawing::Rectangle srcRect, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Graphics::EnumerateMetafileProc ^ callback);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.Rectangle * System.Drawing.Rectangle * System.Drawing.GraphicsUnit * System.Drawing.Graphics.EnumerateMetafileProc -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destRect, srcRect, srcUnit, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
      </Parameters>
      <Docs>
        <param name="metafile">Aufzulistendes <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
        <param name="destRect">
          <see cref="T:System.Drawing.Rectangle" />-Struktur, die die Position und Größe der gezeichneten Metadatei angibt.</param>
        <param name="srcRect">
          <see cref="T:System.Drawing.Rectangle" />-Struktur, die den zu zeichnenden Teil der Metadatei relativ zur oberen linken Ecke angibt.</param>
        <param name="srcUnit">Member der <see cref="T:System.Drawing.GraphicsUnit" />-Enumeration, der die Maßeinheit angibt, mit der der Teil der Metadatei bestimmt wird, der in dem vom <paramref name="srcRect" />-Parameter angegebenen Rechteck enthalten ist.</param>
        <param name="callback">
          <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" />-Delegat, der die Methode angibt, an die die Datensätze der Metadatei gesendet werden.</param>
        <summary>Sendet die Datensätze eines ausgewählten Rechtecks eines <see cref="T:System.Drawing.Imaging.Metafile" /> einzeln an eine Rückrufmethode zum Anzeigen in einem bestimmten Rechteck.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zählt die Datensätze in der angegebenen Metadatei enthalten sind. Jeder Datensatz wird einzeln an eine Rückrufmethode, die anhand des gesendet der `callback` Parameter. In der Regel die Rückrufmethode Ruft die <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> Methode "wiedergeben", oder Zeichnen-Befehl, den Datensatz.  
  
 Wenn die Callback-Methode ruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, muss hierzu die <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> Methode der spezifischen <xref:System.Drawing.Imaging.Metafile> , aufgezählt wird.  
  
 Alle zeichnen, die findet nicht in das Rechteck, das gemäß der `srcRect` Parameter wird ignoriert.  
  
   
  
## Examples  
 Ein Codebeispiel finden Sie unter <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.RectangleF destRect, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData, System.Drawing.Imaging.ImageAttributes imageAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.RectangleF destRect, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData, class System.Drawing.Imaging.ImageAttributes imageAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.RectangleF,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr,System.Drawing.Imaging.ImageAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::RectangleF destRect, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData, System::Drawing::Imaging::ImageAttributes ^ imageAttr);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.RectangleF * System.Drawing.Graphics.EnumerateMetafileProc * nativeint * System.Drawing.Imaging.ImageAttributes -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destRect, callback, callbackData, imageAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
      </Parameters>
      <Docs>
        <param name="metafile">Aufzulistendes <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
        <param name="destRect">
          <see cref="T:System.Drawing.RectangleF" />-Struktur, die die Position und Größe der gezeichneten Metadatei angibt.</param>
        <param name="callback">
          <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" />-Delegat, der die Methode angibt, an die die Datensätze der Metadatei gesendet werden.</param>
        <param name="callbackData">Interner Zeiger, der erforderlich ist, aber ignoriert wird. Für diesen Parameter kann <see cref="F:System.IntPtr.Zero" /> übergeben werden.</param>
        <param name="imageAttr">
          <see cref="T:System.Drawing.Imaging.ImageAttributes" />, das Informationen über Bildattribute für das gezeichnete Bild angibt.</param>
        <summary>Sendet die Datensätze des angegebenen <see cref="T:System.Drawing.Imaging.Metafile" /> jeweils einzeln an eine Rückrufmethode, um sie in einem angegebenen Rechteck unter Verwendung von angegebenen Bildattributen anzuzeigen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zählt die Datensätze in der angegebenen Metadatei enthalten sind. Jeder Datensatz wird einzeln an eine Rückrufmethode, die anhand des gesendet der `callback` Parameter. In der Regel die Rückrufmethode Ruft die <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> Methode "wiedergeben", oder Zeichnen-Befehl, den Datensatz.  
  
 Wenn die Callback-Methode ruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, muss hierzu die <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> Methode der spezifischen <xref:System.Drawing.Imaging.Metafile> , aufgezählt wird.  
  
 Die Image-Attribute, die gemäß der `imageAttr` Parameter ersetzen, die diese angegeben, wann die Metadatei geschrieben wurde.  
  
   
  
## Examples  
 Ein Codebeispiel finden Sie unter <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.RectangleF destRect, System.Drawing.RectangleF srcRect, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Graphics.EnumerateMetafileProc callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.RectangleF destRect, valuetype System.Drawing.RectangleF srcRect, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Graphics/EnumerateMetafileProc callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.RectangleF,System.Drawing.RectangleF,System.Drawing.GraphicsUnit,System.Drawing.Graphics.EnumerateMetafileProc)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::RectangleF destRect, System::Drawing::RectangleF srcRect, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Graphics::EnumerateMetafileProc ^ callback);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.RectangleF * System.Drawing.RectangleF * System.Drawing.GraphicsUnit * System.Drawing.Graphics.EnumerateMetafileProc -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destRect, srcRect, srcUnit, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
      </Parameters>
      <Docs>
        <param name="metafile">Aufzulistendes <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
        <param name="destRect">
          <see cref="T:System.Drawing.RectangleF" />-Struktur, die die Position und Größe der gezeichneten Metadatei angibt.</param>
        <param name="srcRect">
          <see cref="T:System.Drawing.RectangleF" />-Struktur, die den zu zeichnenden Teil der Metadatei relativ zur oberen linken Ecke angibt.</param>
        <param name="srcUnit">Member der <see cref="T:System.Drawing.GraphicsUnit" />-Enumeration, der die Maßeinheit angibt, mit der der Teil der Metadatei bestimmt wird, der in dem vom <paramref name="srcRect" />-Parameter angegebenen Rechteck enthalten ist.</param>
        <param name="callback">
          <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" />-Delegat, der die Methode angibt, an die die Datensätze der Metadatei gesendet werden.</param>
        <summary>Sendet die Datensätze eines ausgewählten Rechtecks eines <see cref="T:System.Drawing.Imaging.Metafile" /> einzeln an eine Rückrufmethode zum Anzeigen in einem bestimmten Rechteck.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zählt die Datensätze in der angegebenen Metadatei enthalten sind. Jeder Datensatz wird einzeln an eine Rückrufmethode, die anhand des gesendet der `callback` Parameter. In der Regel die Rückrufmethode Ruft die <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> Methode "wiedergeben", oder Zeichnen-Befehl, den Datensatz.  
  
 Wenn die Callback-Methode ruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, muss hierzu die <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> Methode der spezifischen <xref:System.Drawing.Imaging.Metafile> , aufgezählt wird.  
  
 Alle zeichnen, die findet nicht in das Rechteck, das gemäß der `srcRect` Parameter wird ignoriert.  
  
   
  
## Examples  
 Ein Codebeispiel finden Sie unter <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.Point destPoint, System.Drawing.Rectangle srcRect, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.Point destPoint, valuetype System.Drawing.Rectangle srcRect, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Point,System.Drawing.Rectangle,System.Drawing.GraphicsUnit,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::Point destPoint, System::Drawing::Rectangle srcRect, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.Point * System.Drawing.Rectangle * System.Drawing.GraphicsUnit * System.Drawing.Graphics.EnumerateMetafileProc * nativeint -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoint, srcRect, srcUnit, callback, callbackData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoint" Type="System.Drawing.Point" />
        <Parameter Name="srcRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="metafile">Aufzulistendes <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
        <param name="destPoint">
          <see cref="T:System.Drawing.Point" />-Struktur, die die Position der oberen linken Ecke der gezeichneten Metadatei angibt.</param>
        <param name="srcRect">
          <see cref="T:System.Drawing.Rectangle" />-Struktur, die den zu zeichnenden Teil der Metadatei relativ zur oberen linken Ecke angibt.</param>
        <param name="srcUnit">Member der <see cref="T:System.Drawing.GraphicsUnit" />-Enumeration, der die Maßeinheit angibt, mit der der Teil der Metadatei bestimmt wird, der in dem vom <paramref name="srcRect" />-Parameter angegebenen Rechteck enthalten ist.</param>
        <param name="callback">
          <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" />-Delegat, der die Methode angibt, an die die Datensätze der Metadatei gesendet werden.</param>
        <param name="callbackData">Interner Zeiger, der erforderlich ist, aber ignoriert wird. Für diesen Parameter kann <see cref="F:System.IntPtr.Zero" /> übergeben werden.</param>
        <summary>Sendet die Datensätze in einem ausgewählten Rechteck eines <see cref="T:System.Drawing.Imaging.Metafile" /> einzeln an eine Rückrufmethode zum Anzeigen an einem bestimmten Punkt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zählt die Datensätze in der angegebenen Metadatei enthalten sind. Jeder Datensatz wird einzeln an eine Rückrufmethode, die anhand des gesendet der `callback` Parameter. In der Regel die Rückrufmethode Ruft die <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> Methode "wiedergeben", oder Zeichnen-Befehl, den Datensatz.  
  
 Wenn die Callback-Methode ruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, muss hierzu die <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> Methode der spezifischen <xref:System.Drawing.Imaging.Metafile> , aufgezählt wird.  
  
   
  
## Examples  
 Ein Codebeispiel finden Sie unter <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.Point[] destPoints, System.Drawing.Rectangle srcRect, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.Point[] destPoints, valuetype System.Drawing.Rectangle srcRect, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Point[],System.Drawing.Rectangle,System.Drawing.GraphicsUnit,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, cli::array &lt;System::Drawing::Point&gt; ^ destPoints, System::Drawing::Rectangle srcRect, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.Point[] * System.Drawing.Rectangle * System.Drawing.GraphicsUnit * System.Drawing.Graphics.EnumerateMetafileProc * nativeint -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoints, srcRect, srcUnit, callback, callbackData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoints" Type="System.Drawing.Point[]" />
        <Parameter Name="srcRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="metafile">Aufzulistendes <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
        <param name="destPoints">Array von drei <see cref="T:System.Drawing.Point" />-Strukturen, die ein Parallelogramm definieren, das die Größe und Position der gezeichneten Metadatei bestimmt.</param>
        <param name="srcRect">
          <see cref="T:System.Drawing.Rectangle" />-Struktur, die den zu zeichnenden Teil der Metadatei relativ zur oberen linken Ecke angibt.</param>
        <param name="srcUnit">Member der <see cref="T:System.Drawing.GraphicsUnit" />-Enumeration, der die Maßeinheit angibt, mit der der Teil der Metadatei bestimmt wird, der in dem vom <paramref name="srcRect" />-Parameter angegebenen Rechteck enthalten ist.</param>
        <param name="callback">
          <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" />-Delegat, der die Methode angibt, an die die Datensätze der Metadatei gesendet werden.</param>
        <param name="callbackData">Interner Zeiger, der erforderlich ist, aber ignoriert wird. Für diesen Parameter kann <see cref="F:System.IntPtr.Zero" /> übergeben werden.</param>
        <summary>Sendet die Datensätze in einem ausgewählten Rechteck eines <see cref="T:System.Drawing.Imaging.Metafile" /> einzeln an eine Rückrufmethode zum Anzeigen in einem bestimmten Parallelogramm.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zählt die Datensätze in der angegebenen Metadatei enthalten sind. Jeder Datensatz wird einzeln an eine Rückrufmethode, die anhand des gesendet der `callback` Parameter. In der Regel die Rückrufmethode Ruft die <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> Methode "wiedergeben", oder Zeichnen-Befehl, den Datensatz.  
  
 Wenn die Callback-Methode ruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, muss hierzu die <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> Methode der spezifischen <xref:System.Drawing.Imaging.Metafile> , aufgezählt wird.  
  
 Die `destPoints` Parameter gibt die drei Punkte eines Parallelogramms an. Die drei <xref:System.Drawing.Point> -Strukturen stellen die oberen linken, oberen rechten und unteren linken Ecke des Parallelogramms. Der vierte Punkt ist über die ersten drei zu einem Parallelogramm extrapoliert. Die gezeichnete Metadatei ist skaliert und entsprechend Parallelogramms verbogen.  
  
 Alle zeichnen, die findet nicht in das Rechteck, das gemäß der `srcRect` Parameter wird ignoriert.  
  
   
  
## Examples  
 Ein Codebeispiel finden Sie unter <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.PointF destPoint, System.Drawing.RectangleF srcRect, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.PointF destPoint, valuetype System.Drawing.RectangleF srcRect, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.PointF,System.Drawing.RectangleF,System.Drawing.GraphicsUnit,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::PointF destPoint, System::Drawing::RectangleF srcRect, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.PointF * System.Drawing.RectangleF * System.Drawing.GraphicsUnit * System.Drawing.Graphics.EnumerateMetafileProc * nativeint -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoint, srcRect, srcUnit, callback, callbackData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoint" Type="System.Drawing.PointF" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="metafile">Aufzulistendes <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
        <param name="destPoint">
          <see cref="T:System.Drawing.PointF" />-Struktur, die die Position der oberen linken Ecke der gezeichneten Metadatei angibt.</param>
        <param name="srcRect">
          <see cref="T:System.Drawing.RectangleF" />-Struktur, die den zu zeichnenden Teil der Metadatei relativ zur oberen linken Ecke angibt.</param>
        <param name="srcUnit">Member der <see cref="T:System.Drawing.GraphicsUnit" />-Enumeration, der die Maßeinheit angibt, mit der der Teil der Metadatei bestimmt wird, der in dem vom <paramref name="srcRect" />-Parameter angegebenen Rechteck enthalten ist.</param>
        <param name="callback">
          <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" />-Delegat, der die Methode angibt, an die die Datensätze der Metadatei gesendet werden.</param>
        <param name="callbackData">Interner Zeiger, der erforderlich ist, aber ignoriert wird. Für diesen Parameter kann <see cref="F:System.IntPtr.Zero" /> übergeben werden.</param>
        <summary>Sendet die Datensätze in einem ausgewählten Rechteck eines <see cref="T:System.Drawing.Imaging.Metafile" /> einzeln an eine Rückrufmethode zum Anzeigen an einem bestimmten Punkt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zählt die Datensätze in der angegebenen Metadatei enthalten sind. Jeder Datensatz wird einzeln an eine Rückrufmethode, die anhand des gesendet der `callback` Parameter. In der Regel die Rückrufmethode Ruft die <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> Methode "wiedergeben", oder Zeichnen-Befehl, den Datensatz.  
  
 Wenn die Callback-Methode ruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, muss hierzu die <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> Methode der spezifischen <xref:System.Drawing.Imaging.Metafile> , aufgezählt wird.  
  
 Alle zeichnen, die findet nicht in das Rechteck, das gemäß der `srcRect` Parameter wird ignoriert.  
  
   
  
## Examples  
 Ein Codebeispiel finden Sie unter <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.PointF[] destPoints, System.Drawing.RectangleF srcRect, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.PointF[] destPoints, valuetype System.Drawing.RectangleF srcRect, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.PointF[],System.Drawing.RectangleF,System.Drawing.GraphicsUnit,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, cli::array &lt;System::Drawing::PointF&gt; ^ destPoints, System::Drawing::RectangleF srcRect, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.PointF[] * System.Drawing.RectangleF * System.Drawing.GraphicsUnit * System.Drawing.Graphics.EnumerateMetafileProc * nativeint -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoints, srcRect, srcUnit, callback, callbackData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoints" Type="System.Drawing.PointF[]" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="metafile">Aufzulistendes <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
        <param name="destPoints">Array von drei <see cref="T:System.Drawing.PointF" />-Strukturen, die ein Parallelogramm definieren, das die Größe und Position der gezeichneten Metadatei bestimmt.</param>
        <param name="srcRect">
          <see cref="T:System.Drawing.RectangleF" />-Struktur, die den zu zeichnenden Teil der Metadatei relativ zur oberen linken Ecke angibt.</param>
        <param name="srcUnit">Member der <see cref="T:System.Drawing.GraphicsUnit" />-Enumeration, der die Maßeinheit angibt, mit der der Teil der Metadatei bestimmt wird, der in dem vom <paramref name="srcRect" />-Parameter angegebenen Rechteck enthalten ist.</param>
        <param name="callback">
          <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" />-Delegat, der die Methode angibt, an die die Datensätze der Metadatei gesendet werden.</param>
        <param name="callbackData">Interner Zeiger, der erforderlich ist, aber ignoriert wird. Für diesen Parameter kann <see cref="F:System.IntPtr.Zero" /> übergeben werden.</param>
        <summary>Sendet die Datensätze in einem ausgewählten Rechteck eines <see cref="T:System.Drawing.Imaging.Metafile" /> einzeln an eine Rückrufmethode zum Anzeigen in einem bestimmten Parallelogramm.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zählt die Datensätze in der angegebenen Metadatei enthalten sind. Jeder Datensatz wird einzeln an eine Rückrufmethode, die anhand des gesendet der `callback` Parameter. In der Regel die Rückrufmethode Ruft die <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> Methode "wiedergeben", oder Zeichnen-Befehl, den Datensatz.  
  
 Wenn die Callback-Methode ruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, muss hierzu die <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> Methode der spezifischen <xref:System.Drawing.Imaging.Metafile> , aufgezählt wird.  
  
 Die `destPoints` Parameter gibt die drei Punkte eines Parallelogramms an. Die drei <xref:System.Drawing.PointF> -Strukturen stellen die oberen linken, oberen rechten und unteren linken Ecke des Parallelogramms. Der vierte Punkt ist über die ersten drei zu einem Parallelogramm extrapoliert. Die gezeichnete Metadatei ist skaliert und entsprechend Parallelogramms verbogen.  
  
 Alle zeichnen, die findet nicht in das Rechteck, das gemäß der `srcRect` Parameter wird ignoriert.  
  
   
  
## Examples  
 Ein Codebeispiel finden Sie unter <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.Rectangle destRect, System.Drawing.Rectangle srcRect, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.Rectangle destRect, valuetype System.Drawing.Rectangle srcRect, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Rectangle,System.Drawing.Rectangle,System.Drawing.GraphicsUnit,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::Rectangle destRect, System::Drawing::Rectangle srcRect, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.Rectangle * System.Drawing.Rectangle * System.Drawing.GraphicsUnit * System.Drawing.Graphics.EnumerateMetafileProc * nativeint -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destRect, srcRect, srcUnit, callback, callbackData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="metafile">Aufzulistendes <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
        <param name="destRect">
          <see cref="T:System.Drawing.Rectangle" />-Struktur, die die Position und Größe der gezeichneten Metadatei angibt.</param>
        <param name="srcRect">
          <see cref="T:System.Drawing.Rectangle" />-Struktur, die den zu zeichnenden Teil der Metadatei relativ zur oberen linken Ecke angibt.</param>
        <param name="srcUnit">Member der <see cref="T:System.Drawing.GraphicsUnit" />-Enumeration, der die Maßeinheit angibt, mit der der Teil der Metadatei bestimmt wird, der in dem vom <paramref name="srcRect" />-Parameter angegebenen Rechteck enthalten ist.</param>
        <param name="callback">
          <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" />-Delegat, der die Methode angibt, an die die Datensätze der Metadatei gesendet werden.</param>
        <param name="callbackData">Interner Zeiger, der erforderlich ist, aber ignoriert wird. Für diesen Parameter kann <see cref="F:System.IntPtr.Zero" /> übergeben werden.</param>
        <summary>Sendet die Datensätze eines ausgewählten Rechtecks eines <see cref="T:System.Drawing.Imaging.Metafile" /> einzeln an eine Rückrufmethode zum Anzeigen in einem bestimmten Rechteck.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zählt die Datensätze in der angegebenen Metadatei enthalten sind. Jeder Datensatz wird einzeln an eine Rückrufmethode, die anhand des gesendet der `callback` Parameter. In der Regel die Rückrufmethode Ruft die <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> Methode "wiedergeben", oder Zeichnen-Befehl, den Datensatz.  
  
 Wenn die Callback-Methode ruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, muss hierzu die <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> Methode der spezifischen <xref:System.Drawing.Imaging.Metafile> , aufgezählt wird.  
  
 Alle zeichnen, die findet nicht in das Rechteck, das gemäß der `srcRect` Parameter wird ignoriert.  
  
   
  
## Examples  
 Ein Codebeispiel finden Sie unter <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.RectangleF destRect, System.Drawing.RectangleF srcRect, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.RectangleF destRect, valuetype System.Drawing.RectangleF srcRect, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.RectangleF,System.Drawing.RectangleF,System.Drawing.GraphicsUnit,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::RectangleF destRect, System::Drawing::RectangleF srcRect, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.RectangleF * System.Drawing.RectangleF * System.Drawing.GraphicsUnit * System.Drawing.Graphics.EnumerateMetafileProc * nativeint -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destRect, srcRect, srcUnit, callback, callbackData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="metafile">Aufzulistendes <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
        <param name="destRect">
          <see cref="T:System.Drawing.RectangleF" />-Struktur, die die Position und Größe der gezeichneten Metadatei angibt.</param>
        <param name="srcRect">
          <see cref="T:System.Drawing.RectangleF" />-Struktur, die den zu zeichnenden Teil der Metadatei relativ zur oberen linken Ecke angibt.</param>
        <param name="srcUnit">Member der <see cref="T:System.Drawing.GraphicsUnit" />-Enumeration, der die Maßeinheit angibt, mit der der Teil der Metadatei bestimmt wird, der in dem vom <paramref name="srcRect" />-Parameter angegebenen Rechteck enthalten ist.</param>
        <param name="callback">
          <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" />-Delegat, der die Methode angibt, an die die Datensätze der Metadatei gesendet werden.</param>
        <param name="callbackData">Interner Zeiger, der erforderlich ist, aber ignoriert wird. Für diesen Parameter kann <see cref="F:System.IntPtr.Zero" /> übergeben werden.</param>
        <summary>Sendet die Datensätze eines ausgewählten Rechtecks eines <see cref="T:System.Drawing.Imaging.Metafile" /> einzeln an eine Rückrufmethode zum Anzeigen in einem bestimmten Rechteck.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zählt die Datensätze in der angegebenen Metadatei enthalten sind. Jeder Datensatz wird einzeln an eine Rückrufmethode, die anhand des gesendet der`callback` Parameter. In der Regel die Rückrufmethode Ruft die <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> Methode "wiedergeben", oder Zeichnen-Befehl, den Datensatz.  
  
 Wenn die Callback-Methode ruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, muss hierzu die <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> Methode der spezifischen <xref:System.Drawing.Imaging.Metafile> , aufgezählt wird.  
  
 Alle zeichnen, die findet nicht in das Rechteck, das gemäß der `srcRect` Parameter wird ignoriert.  
  
   
  
## Examples  
 Ein Codebeispiel finden Sie unter <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.Point destPoint, System.Drawing.Rectangle srcRect, System.Drawing.GraphicsUnit unit, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData, System.Drawing.Imaging.ImageAttributes imageAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.Point destPoint, valuetype System.Drawing.Rectangle srcRect, valuetype System.Drawing.GraphicsUnit unit, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData, class System.Drawing.Imaging.ImageAttributes imageAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Point,System.Drawing.Rectangle,System.Drawing.GraphicsUnit,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr,System.Drawing.Imaging.ImageAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::Point destPoint, System::Drawing::Rectangle srcRect, System::Drawing::GraphicsUnit unit, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData, System::Drawing::Imaging::ImageAttributes ^ imageAttr);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.Point * System.Drawing.Rectangle * System.Drawing.GraphicsUnit * System.Drawing.Graphics.EnumerateMetafileProc * nativeint * System.Drawing.Imaging.ImageAttributes -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoint, srcRect, unit, callback, callbackData, imageAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoint" Type="System.Drawing.Point" />
        <Parameter Name="srcRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="unit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
      </Parameters>
      <Docs>
        <param name="metafile">Aufzulistendes <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
        <param name="destPoint">
          <see cref="T:System.Drawing.Point" />-Struktur, die die Position der oberen linken Ecke der gezeichneten Metadatei angibt.</param>
        <param name="srcRect">
          <see cref="T:System.Drawing.Rectangle" />-Struktur, die den zu zeichnenden Teil der Metadatei relativ zur oberen linken Ecke angibt.</param>
        <param name="unit">Member der <see cref="T:System.Drawing.GraphicsUnit" />-Enumeration, der die Maßeinheit angibt, mit der der Teil der Metadatei bestimmt wird, der in dem vom <paramref name="srcRect" />-Parameter angegebenen Rechteck enthalten ist.</param>
        <param name="callback">
          <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" />-Delegat, der die Methode angibt, an die die Datensätze der Metadatei gesendet werden.</param>
        <param name="callbackData">Interner Zeiger, der erforderlich ist, aber ignoriert wird. Für diesen Parameter kann <see cref="F:System.IntPtr.Zero" /> übergeben werden.</param>
        <param name="imageAttr">
          <see cref="T:System.Drawing.Imaging.ImageAttributes" />, das Informationen über Bildattribute für das gezeichnete Bild angibt.</param>
        <summary>Sendet die Datensätze in einem ausgewählten Rechteck aus einem <see cref="T:System.Drawing.Imaging.Metafile" /> einzeln an eine Rückrufmethode, um sie unter Verwendung der angegebenen Bildattribute an einem angegebenen Punkt anzuzeigen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zählt die Datensätze in der angegebenen Metadatei enthalten sind. Jeder Datensatz wird einzeln an eine Rückrufmethode, die anhand des gesendet der `callback` Parameter. In der Regel die Rückrufmethode Ruft die <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> Methode "wiedergeben", oder Zeichnen-Befehl, den Datensatz.  
  
 Wenn die Callback-Methode ruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, muss hierzu die <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> Methode der spezifischen <xref:System.Drawing.Imaging.Metafile> , aufgezählt wird.  
  
   
  
## Examples  
 Ein Codebeispiel finden Sie unter <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.Point[] destPoints, System.Drawing.Rectangle srcRect, System.Drawing.GraphicsUnit unit, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData, System.Drawing.Imaging.ImageAttributes imageAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.Point[] destPoints, valuetype System.Drawing.Rectangle srcRect, valuetype System.Drawing.GraphicsUnit unit, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData, class System.Drawing.Imaging.ImageAttributes imageAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Point[],System.Drawing.Rectangle,System.Drawing.GraphicsUnit,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr,System.Drawing.Imaging.ImageAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, cli::array &lt;System::Drawing::Point&gt; ^ destPoints, System::Drawing::Rectangle srcRect, System::Drawing::GraphicsUnit unit, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData, System::Drawing::Imaging::ImageAttributes ^ imageAttr);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.Point[] * System.Drawing.Rectangle * System.Drawing.GraphicsUnit * System.Drawing.Graphics.EnumerateMetafileProc * nativeint * System.Drawing.Imaging.ImageAttributes -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoints, srcRect, unit, callback, callbackData, imageAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoints" Type="System.Drawing.Point[]" />
        <Parameter Name="srcRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="unit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
      </Parameters>
      <Docs>
        <param name="metafile">Aufzulistendes <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
        <param name="destPoints">Array von drei <see cref="T:System.Drawing.Point" />-Strukturen, die ein Parallelogramm definieren, das die Größe und Position der gezeichneten Metadatei bestimmt.</param>
        <param name="srcRect">
          <see cref="T:System.Drawing.Rectangle" />-Struktur, die den zu zeichnenden Teil der Metadatei relativ zur oberen linken Ecke angibt.</param>
        <param name="unit">Member der <see cref="T:System.Drawing.GraphicsUnit" />-Enumeration, der die Maßeinheit angibt, mit der der Teil der Metadatei bestimmt wird, der in dem vom <paramref name="srcRect" />-Parameter angegebenen Rechteck enthalten ist.</param>
        <param name="callback">
          <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" />-Delegat, der die Methode angibt, an die die Datensätze der Metadatei gesendet werden.</param>
        <param name="callbackData">Interner Zeiger, der erforderlich ist, aber ignoriert wird. Für diesen Parameter kann <see cref="F:System.IntPtr.Zero" /> übergeben werden.</param>
        <param name="imageAttr">
          <see cref="T:System.Drawing.Imaging.ImageAttributes" />, das Informationen über Bildattribute für das gezeichnete Bild angibt.</param>
        <summary>Sendet die Datensätze in einem ausgewählten Rechteck von einem <see cref="T:System.Drawing.Imaging.Metafile" /> einzeln an eine Rückrufmethode, um sie in einem angegebenen Parallelogramm unter Verwendung von angegebenen Bildattributen anzuzeigen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zählt die Datensätze in der angegebenen Metadatei enthalten sind. Jeder Datensatz wird einzeln an eine Rückrufmethode, die anhand des gesendet der `callback` Parameter. In der Regel die Rückrufmethode Ruft die <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> Methode "wiedergeben", oder Zeichnen-Befehl, den Datensatz.  
  
 Wenn die Callback-Methode ruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, muss hierzu die <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> Methode der spezifischen <xref:System.Drawing.Imaging.Metafile> , aufgezählt wird.  
  
 Die `destPoints` Parameter gibt die drei Punkte eines Parallelogramms an. Die drei <xref:System.Drawing.Point> -Strukturen stellen die oberen linken, oberen rechten und unteren linken Ecke des Parallelogramms. Der vierte Punkt ist über die ersten drei zu einem Parallelogramm extrapoliert. Die gezeichnete Metadatei ist skaliert und entsprechend Parallelogramms verbogen.  
  
 Alle zeichnen, die findet nicht in das Rechteck, das gemäß der `srcRect` Parameter wird ignoriert.  
  
 Die Image-Attribute, die gemäß der `imageAttr` Parameter ersetzen, die diese angegeben, wann die Metadatei geschrieben wurde.  
  
   
  
## Examples  
 Ein Codebeispiel finden Sie unter <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.PointF destPoint, System.Drawing.RectangleF srcRect, System.Drawing.GraphicsUnit unit, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData, System.Drawing.Imaging.ImageAttributes imageAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.PointF destPoint, valuetype System.Drawing.RectangleF srcRect, valuetype System.Drawing.GraphicsUnit unit, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData, class System.Drawing.Imaging.ImageAttributes imageAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.PointF,System.Drawing.RectangleF,System.Drawing.GraphicsUnit,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr,System.Drawing.Imaging.ImageAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::PointF destPoint, System::Drawing::RectangleF srcRect, System::Drawing::GraphicsUnit unit, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData, System::Drawing::Imaging::ImageAttributes ^ imageAttr);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.PointF * System.Drawing.RectangleF * System.Drawing.GraphicsUnit * System.Drawing.Graphics.EnumerateMetafileProc * nativeint * System.Drawing.Imaging.ImageAttributes -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoint, srcRect, unit, callback, callbackData, imageAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoint" Type="System.Drawing.PointF" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="unit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
      </Parameters>
      <Docs>
        <param name="metafile">Aufzulistendes <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
        <param name="destPoint">
          <see cref="T:System.Drawing.PointF" />-Struktur, die die Position der oberen linken Ecke der gezeichneten Metadatei angibt.</param>
        <param name="srcRect">
          <see cref="T:System.Drawing.RectangleF" />-Struktur, die den zu zeichnenden Teil der Metadatei relativ zur oberen linken Ecke angibt.</param>
        <param name="unit">Member der <see cref="T:System.Drawing.GraphicsUnit" />-Enumeration, der die Maßeinheit angibt, mit der der Teil der Metadatei bestimmt wird, der in dem vom <paramref name="srcRect" />-Parameter angegebenen Rechteck enthalten ist.</param>
        <param name="callback">
          <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" />-Delegat, der die Methode angibt, an die die Datensätze der Metadatei gesendet werden.</param>
        <param name="callbackData">Interner Zeiger, der erforderlich ist, aber ignoriert wird. Für diesen Parameter kann <see cref="F:System.IntPtr.Zero" /> übergeben werden.</param>
        <param name="imageAttr">
          <see cref="T:System.Drawing.Imaging.ImageAttributes" />, das Informationen über Bildattribute für das gezeichnete Bild angibt.</param>
        <summary>Sendet die Datensätze in einem ausgewählten Rechteck aus einem <see cref="T:System.Drawing.Imaging.Metafile" /> einzeln an eine Rückrufmethode, um sie unter Verwendung der angegebenen Bildattribute an einem angegebenen Punkt anzuzeigen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zählt die Datensätze in der angegebenen Metadatei enthalten sind. Jeder Datensatz wird einzeln an eine Rückrufmethode, die anhand des gesendet der `callback` Parameter. In der Regel die Rückrufmethode Ruft die <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> Methode "wiedergeben", oder Zeichnen-Befehl, den Datensatz.  
  
 Wenn die Callback-Methode ruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, muss hierzu die <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> Methode der spezifischen <xref:System.Drawing.Imaging.Metafile> , aufgezählt wird.  
  
 Alle zeichnen, die findet nicht in das Rechteck, das gemäß der `srcRect` Parameter wird ignoriert.  
  
 Die Image-Attribute, die gemäß der `imageAttr` Parameter ersetzen, die diese angegeben, wann die Metadatei geschrieben wurde.  
  
   
  
## Examples  
 Ein Codebeispiel finden Sie unter <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.PointF[] destPoints, System.Drawing.RectangleF srcRect, System.Drawing.GraphicsUnit unit, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData, System.Drawing.Imaging.ImageAttributes imageAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.PointF[] destPoints, valuetype System.Drawing.RectangleF srcRect, valuetype System.Drawing.GraphicsUnit unit, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData, class System.Drawing.Imaging.ImageAttributes imageAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.PointF[],System.Drawing.RectangleF,System.Drawing.GraphicsUnit,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr,System.Drawing.Imaging.ImageAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, cli::array &lt;System::Drawing::PointF&gt; ^ destPoints, System::Drawing::RectangleF srcRect, System::Drawing::GraphicsUnit unit, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData, System::Drawing::Imaging::ImageAttributes ^ imageAttr);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.PointF[] * System.Drawing.RectangleF * System.Drawing.GraphicsUnit * System.Drawing.Graphics.EnumerateMetafileProc * nativeint * System.Drawing.Imaging.ImageAttributes -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoints, srcRect, unit, callback, callbackData, imageAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoints" Type="System.Drawing.PointF[]" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="unit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
      </Parameters>
      <Docs>
        <param name="metafile">Aufzulistendes <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
        <param name="destPoints">Array von drei <see cref="T:System.Drawing.PointF" />-Strukturen, die ein Parallelogramm definieren, das die Größe und Position der gezeichneten Metadatei bestimmt.</param>
        <param name="srcRect">
          <see cref="T:System.Drawing.RectangleF" />-Struktur, die den zu zeichnenden Teil der Metadatei relativ zur oberen linken Ecke angibt.</param>
        <param name="unit">Member der <see cref="T:System.Drawing.GraphicsUnit" />-Enumeration, der die Maßeinheit angibt, mit der der Teil der Metadatei bestimmt wird, der in dem vom <paramref name="srcRect" />-Parameter angegebenen Rechteck enthalten ist.</param>
        <param name="callback">
          <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" />-Delegat, der die Methode angibt, an die die Datensätze der Metadatei gesendet werden.</param>
        <param name="callbackData">Interner Zeiger, der erforderlich ist, aber ignoriert wird. Für diesen Parameter kann <see cref="F:System.IntPtr.Zero" /> übergeben werden.</param>
        <param name="imageAttr">
          <see cref="T:System.Drawing.Imaging.ImageAttributes" />, das Informationen über Bildattribute für das gezeichnete Bild angibt.</param>
        <summary>Sendet die Datensätze in einem ausgewählten Rechteck von einem <see cref="T:System.Drawing.Imaging.Metafile" /> einzeln an eine Rückrufmethode, um sie in einem angegebenen Parallelogramm unter Verwendung von angegebenen Bildattributen anzuzeigen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zählt die Datensätze in der angegebenen Metadatei enthalten sind. Jeder Datensatz wird einzeln an eine Rückrufmethode, die anhand des gesendet der `callback` Parameter. In der Regel die Rückrufmethode Ruft die <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> Methode "wiedergeben", oder Zeichnen-Befehl, den Datensatz.  
  
 Wenn die Callback-Methode ruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, muss hierzu die <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> Methode der spezifischen <xref:System.Drawing.Imaging.Metafile> , aufgezählt wird.  
  
 Die `destPoints` Parameter gibt die drei Punkte eines Parallelogramms an. Die drei <xref:System.Drawing.PointF> -Strukturen stellen die oberen linken, oberen rechten und unteren linken Ecke des Parallelogramms. Der vierte Punkt ist über die ersten drei zu einem Parallelogramm extrapoliert. Die gezeichnete Metadatei ist skaliert und entsprechend Parallelogramms verbogen.  
  
 Alle zeichnen, die findet nicht in das Rechteck, das gemäß der `srcRect` Parameter wird ignoriert.  
  
 Die Image-Attribute, die gemäß der `imageAttr` Parameter ersetzen, die diese angegeben, wann die Metadatei geschrieben wurde.  
  
   
  
## Examples  
 Ein Codebeispiel finden Sie unter <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.Rectangle destRect, System.Drawing.Rectangle srcRect, System.Drawing.GraphicsUnit unit, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData, System.Drawing.Imaging.ImageAttributes imageAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.Rectangle destRect, valuetype System.Drawing.Rectangle srcRect, valuetype System.Drawing.GraphicsUnit unit, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData, class System.Drawing.Imaging.ImageAttributes imageAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Rectangle,System.Drawing.Rectangle,System.Drawing.GraphicsUnit,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr,System.Drawing.Imaging.ImageAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::Rectangle destRect, System::Drawing::Rectangle srcRect, System::Drawing::GraphicsUnit unit, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData, System::Drawing::Imaging::ImageAttributes ^ imageAttr);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.Rectangle * System.Drawing.Rectangle * System.Drawing.GraphicsUnit * System.Drawing.Graphics.EnumerateMetafileProc * nativeint * System.Drawing.Imaging.ImageAttributes -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destRect, srcRect, unit, callback, callbackData, imageAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="unit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
      </Parameters>
      <Docs>
        <param name="metafile">Aufzulistendes <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
        <param name="destRect">
          <see cref="T:System.Drawing.Rectangle" />-Struktur, die die Position und Größe der gezeichneten Metadatei angibt.</param>
        <param name="srcRect">
          <see cref="T:System.Drawing.Rectangle" />-Struktur, die den zu zeichnenden Teil der Metadatei relativ zur oberen linken Ecke angibt.</param>
        <param name="unit">Member der <see cref="T:System.Drawing.GraphicsUnit" />-Enumeration, der die Maßeinheit angibt, mit der der Teil der Metadatei bestimmt wird, der in dem vom <paramref name="srcRect" />-Parameter angegebenen Rechteck enthalten ist.</param>
        <param name="callback">
          <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" />-Delegat, der die Methode angibt, an die die Datensätze der Metadatei gesendet werden.</param>
        <param name="callbackData">Interner Zeiger, der erforderlich ist, aber ignoriert wird. Für diesen Parameter kann <see cref="F:System.IntPtr.Zero" /> übergeben werden.</param>
        <param name="imageAttr">
          <see cref="T:System.Drawing.Imaging.ImageAttributes" />, das Informationen über Bildattribute für das gezeichnete Bild angibt.</param>
        <summary>Sendet die Datensätze eines ausgewählten Rechtecks von einem <see cref="T:System.Drawing.Imaging.Metafile" /> einzeln an eine Rückrufmethode, um sie in einem angegebenen Rechteck unter Verwendung von angegebenen Bildattributen anzuzeigen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zählt die Datensätze in der angegebenen Metadatei enthalten sind. Jeder Datensatz wird einzeln an eine Rückrufmethode, die anhand des gesendet der `callback` Parameter. In der Regel die Rückrufmethode Ruft die <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> Methode "wiedergeben", oder Zeichnen-Befehl, den Datensatz.  
  
 Wenn die Callback-Methode ruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, muss hierzu die <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> Methode der spezifischen <xref:System.Drawing.Imaging.Metafile> , aufgezählt wird.  
  
 Alle zeichnen, die findet nicht in das Rechteck, das gemäß der `srcRect` Parameter wird ignoriert.  
  
 Die Image-Attribute, die gemäß der `imageAttr` Parameter ersetzen, die diese angegeben, wann die Metadatei geschrieben wurde.  
  
   
  
## Examples  
 Ein Codebeispiel finden Sie unter <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.RectangleF destRect, System.Drawing.RectangleF srcRect, System.Drawing.GraphicsUnit unit, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData, System.Drawing.Imaging.ImageAttributes imageAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.RectangleF destRect, valuetype System.Drawing.RectangleF srcRect, valuetype System.Drawing.GraphicsUnit unit, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData, class System.Drawing.Imaging.ImageAttributes imageAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.RectangleF,System.Drawing.RectangleF,System.Drawing.GraphicsUnit,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr,System.Drawing.Imaging.ImageAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::RectangleF destRect, System::Drawing::RectangleF srcRect, System::Drawing::GraphicsUnit unit, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData, System::Drawing::Imaging::ImageAttributes ^ imageAttr);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.RectangleF * System.Drawing.RectangleF * System.Drawing.GraphicsUnit * System.Drawing.Graphics.EnumerateMetafileProc * nativeint * System.Drawing.Imaging.ImageAttributes -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destRect, srcRect, unit, callback, callbackData, imageAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="unit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
      </Parameters>
      <Docs>
        <param name="metafile">Aufzulistendes <see cref="T:System.Drawing.Imaging.Metafile" />.</param>
        <param name="destRect">
          <see cref="T:System.Drawing.RectangleF" />-Struktur, die die Position und Größe der gezeichneten Metadatei angibt.</param>
        <param name="srcRect">
          <see cref="T:System.Drawing.RectangleF" />-Struktur, die den zu zeichnenden Teil der Metadatei relativ zur oberen linken Ecke angibt.</param>
        <param name="unit">Member der <see cref="T:System.Drawing.GraphicsUnit" />-Enumeration, der die Maßeinheit angibt, mit der der Teil der Metadatei bestimmt wird, der in dem vom <paramref name="srcRect" />-Parameter angegebenen Rechteck enthalten ist.</param>
        <param name="callback">
          <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" />-Delegat, der die Methode angibt, an die die Datensätze der Metadatei gesendet werden.</param>
        <param name="callbackData">Interner Zeiger, der erforderlich ist, aber ignoriert wird. Für diesen Parameter kann <see cref="F:System.IntPtr.Zero" /> übergeben werden.</param>
        <param name="imageAttr">
          <see cref="T:System.Drawing.Imaging.ImageAttributes" />, das Informationen über Bildattribute für das gezeichnete Bild angibt.</param>
        <summary>Sendet die Datensätze eines ausgewählten Rechtecks von einem <see cref="T:System.Drawing.Imaging.Metafile" /> einzeln an eine Rückrufmethode, um sie in einem angegebenen Rechteck unter Verwendung von angegebenen Bildattributen anzuzeigen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode zählt die Datensätze in der angegebenen Metadatei enthalten sind. Jeder Datensatz wird einzeln an eine Rückrufmethode, die anhand des gesendet der `callback` Parameter. In der Regel die Rückrufmethode Ruft die <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> Methode "wiedergeben", oder Zeichnen-Befehl, den Datensatz.  
  
 Wenn die Callback-Methode ruft <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, muss hierzu die <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> Methode der spezifischen <xref:System.Drawing.Imaging.Metafile> , aufgezählt wird.  
  
 Alle zeichnen, die findet nicht in das Rechteck, das gemäß der `srcRect` Parameter wird ignoriert.  
  
 Die Image-Attribute, die gemäß der `imageAttr` Parameter ersetzen, die diese angegeben, wann die Metadatei geschrieben wurde.  
  
   
  
## Examples  
 Ein Codebeispiel finden Sie unter <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Bilder, Bitmaps und Metadateien</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ExcludeClip">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Aktualisiert den Ausschneidebereich dieses <see cref="T:System.Drawing.Graphics" />, um den durch eine <see cref="T:System.Drawing.Rectangle" />-Struktur angegebenen Bereich auszuschließen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ExcludeClip">
      <MemberSignature Language="C#" Value="public void ExcludeClip (System.Drawing.Rectangle rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExcludeClip(valuetype System.Drawing.Rectangle rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.ExcludeClip(System.Drawing.Rectangle)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExcludeClip (rect As Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExcludeClip(System::Drawing::Rectangle rect);" />
      <MemberSignature Language="F#" Value="member this.ExcludeClip : System.Drawing.Rectangle -&gt; unit" Usage="graphics.ExcludeClip rect" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="rect">
          <see cref="T:System.Drawing.Rectangle" />-Struktur, die das Rechteck angibt, das aus dem Ausschneidebereich ausgeschlossen wird.</param>
        <summary>Aktualisiert den Ausschneidebereich dieses <see cref="T:System.Drawing.Graphics" />, um den durch eine <see cref="T:System.Drawing.Rectangle" />-Struktur angegebenen Bereich auszuschließen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode schließt den Bereich, der gemäß der `rect` Parameter aus der der aktuelle Ausschneidebereich und weist den resultierenden Bereich zu den <xref:System.Drawing.Graphics.Clip%2A> -Eigenschaft dieses <xref:System.Drawing.Graphics>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein 100 Pixel von 100 Pixel Rechteck, dessen obere linke Ecke an den Koordinaten (100, 100) befindet.  
  
-   Erstellt einen Bereich, der durch das Rechteck definiert.  
  
-   Legt den Ausschneidebereich den rechteckigen Bereich ausschließen.  
  
-   Füllt ein 300 Pixel Rechteck x 300 Pixel, deren linke obere Ecke an den Koordinaten (0, 0) mit einem Pinsel mit blauer Volltonfarbe befindet.  
  
 Das Ergebnis ist ein blaues Rechteck mit einem quadratischen Bereich in Richtung der unteren rechten Ecke fehlt.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#92](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#92)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#92](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#92)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#92](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#92)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExcludeClip">
      <MemberSignature Language="C#" Value="public void ExcludeClip (System.Drawing.Region region);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExcludeClip(class System.Drawing.Region region) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.ExcludeClip(System.Drawing.Region)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExcludeClip(System::Drawing::Region ^ region);" />
      <MemberSignature Language="F#" Value="member this.ExcludeClip : System.Drawing.Region -&gt; unit" Usage="graphics.ExcludeClip region" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="region" Type="System.Drawing.Region" />
      </Parameters>
      <Docs>
        <param name="region">
          <see cref="T:System.Drawing.Region" />, der den Bereich angibt, der aus dem Ausschneidebereich ausgeschlossen werden soll.</param>
        <summary>Aktualisiert den Ausschneidebereich dieses <see cref="T:System.Drawing.Graphics" />, um den durch einen <see cref="T:System.Drawing.Region" /> angegebenen Bereich auszuschließen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode schließt den Bereich, der gemäß der `region` Parameter aus der der aktuelle Ausschneidebereich und weist den resultierenden Bereich zu den <xref:System.Drawing.Graphics.Clip%2A> -Eigenschaft dieses <xref:System.Drawing.Graphics>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein 100 Pixel von 100 Pixel Rechteck, dessen obere linke Ecke an den Koordinaten (100, 100) befindet.  
  
-   Legt den Ausschneidebereich, schließen Sie das Rechteck fest.  
  
-   Füllt ein 300 Pixel Rechteck x 300 Pixel, deren linke obere Ecke an den Koordinaten (0, 0) mit einem Pinsel mit blauer Volltonfarbe befindet.  
  
 Das Ergebnis ist ein blaues Rechteck mit einer quadratischen Fläche auf der unteren rechten Ecke fehlt.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#91](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#91)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#91](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#91)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#91](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#91)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="FillClosedCurve">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Füllt das Innere einer geschlossenen Cardinal-Splinekurve, die durch ein Array von <see cref="T:System.Drawing.Point" />-Strukturen definiert ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FillClosedCurve">
      <MemberSignature Language="C#" Value="public void FillClosedCurve (System.Drawing.Brush brush, System.Drawing.Point[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillClosedCurve(class System.Drawing.Brush brush, valuetype System.Drawing.Point[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillClosedCurve(System.Drawing.Brush,System.Drawing.Point[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillClosedCurve(System::Drawing::Brush ^ brush, cli::array &lt;System::Drawing::Point&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.FillClosedCurve : System.Drawing.Brush * System.Drawing.Point[] -&gt; unit" Usage="graphics.FillClosedCurve (brush, points)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="points" Type="System.Drawing.Point[]" />
      </Parameters>
      <Docs>
        <param name="brush">
          <see cref="T:System.Drawing.Brush" />, der die Merkmale des Füllvorgangs bestimmt.</param>
        <param name="points">Array von <see cref="T:System.Drawing.Point" />-Strukturen, die die Splinekurve definieren.</param>
        <summary>Füllt das Innere einer geschlossenen Cardinal-Splinekurve, die durch ein Array von <see cref="T:System.Drawing.Point" />-Strukturen definiert ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode füllt das Innere des eine geschlossene cardinal-Splinekurve, die jedem Punkt im Array durchlaufen. Wenn der letzte Punkt nicht den ersten Punkt übereinstimmt, wird ein zusätzliches Kurvensegment vom letzten Punkt und dem ersten Punkt, um es zu schließen hinzugefügt.  
  
 Das Punktarray muss mindestens vier enthalten <xref:System.Drawing.Point> Strukturen.  
  
 Diese Methode verwendet eine Standard-Spannung von 0,5.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen Pinsel mit Volltonfarbe roten.  
  
-   Erstellt ein Array von vier Punkte, um eine Splinekurve definieren.  
  
-   Füllt die Kurve auf dem Bildschirm an.  
  
 Die Kurve verfügt über eine Standard-Spannung von 0,5.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#93](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#93)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#93](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#93)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#93](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#93)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="brush" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="points" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FillClosedCurve">
      <MemberSignature Language="C#" Value="public void FillClosedCurve (System.Drawing.Brush brush, System.Drawing.PointF[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillClosedCurve(class System.Drawing.Brush brush, valuetype System.Drawing.PointF[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillClosedCurve(System.Drawing.Brush,System.Drawing.PointF[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillClosedCurve(System::Drawing::Brush ^ brush, cli::array &lt;System::Drawing::PointF&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.FillClosedCurve : System.Drawing.Brush * System.Drawing.PointF[] -&gt; unit" Usage="graphics.FillClosedCurve (brush, points)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
      </Parameters>
      <Docs>
        <param name="brush">
          <see cref="T:System.Drawing.Brush" />, der die Merkmale des Füllvorgangs bestimmt.</param>
        <param name="points">Array von <see cref="T:System.Drawing.PointF" />-Strukturen, die die Splinekurve definieren.</param>
        <summary>Füllt das Innere einer geschlossenen Cardinal-Splinekurve, die durch ein Array von <see cref="T:System.Drawing.PointF" />-Strukturen definiert ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode füllt das Innere des eine geschlossene cardinal-Splinekurve, die jedem Punkt im Array durchlaufen. Wenn der letzte Punkt nicht den ersten Punkt übereinstimmt, wird ein zusätzliches Kurvensegment vom letzten Punkt und dem ersten Punkt, um es zu schließen hinzugefügt.  
  
 Das Punktarray muss mindestens vier enthalten <xref:System.Drawing.PointF> Strukturen.  
  
 Diese Methode verwendet eine Standard-Spannung von 0,5.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen Pinsel mit Volltonfarbe roten.  
  
-   Erstellt ein Array von vier Punkte, um eine Splinekurve definieren.  
  
-   Füllt die Kurve auf dem Bildschirm an.  
  
 Die Kurve verfügt über eine Standard-Spannung von 0,5.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#96](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#96)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#96](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#96)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#96](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#96)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="brush" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="points" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FillClosedCurve">
      <MemberSignature Language="C#" Value="public void FillClosedCurve (System.Drawing.Brush brush, System.Drawing.Point[] points, System.Drawing.Drawing2D.FillMode fillmode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillClosedCurve(class System.Drawing.Brush brush, valuetype System.Drawing.Point[] points, valuetype System.Drawing.Drawing2D.FillMode fillmode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillClosedCurve(System.Drawing.Brush,System.Drawing.Point[],System.Drawing.Drawing2D.FillMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillClosedCurve(System::Drawing::Brush ^ brush, cli::array &lt;System::Drawing::Point&gt; ^ points, System::Drawing::Drawing2D::FillMode fillmode);" />
      <MemberSignature Language="F#" Value="member this.FillClosedCurve : System.Drawing.Brush * System.Drawing.Point[] * System.Drawing.Drawing2D.FillMode -&gt; unit" Usage="graphics.FillClosedCurve (brush, points, fillmode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="points" Type="System.Drawing.Point[]" />
        <Parameter Name="fillmode" Type="System.Drawing.Drawing2D.FillMode" />
      </Parameters>
      <Docs>
        <param name="brush">
          <see cref="T:System.Drawing.Brush" />, der die Merkmale des Füllvorgangs bestimmt.</param>
        <param name="points">Array von <see cref="T:System.Drawing.Point" />-Strukturen, die die Splinekurve definieren.</param>
        <param name="fillmode">Member der <see cref="T:System.Drawing.Drawing2D.FillMode" />-Enumeration, der bestimmt, wie die Kurve ausgefüllt wird.</param>
        <summary>Füllt das Innere einer geschlossenen Cardinal-Splinekurve, die durch ein Array von <see cref="T:System.Drawing.Point" />-Strukturen definiert ist, im angegebenen Füllmodus aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode füllt das Innere des eine geschlossene cardinal-Splinekurve, die jedem Punkt im Array durchlaufen. Wenn der letzte Punkt nicht den ersten Punkt übereinstimmt, wird ein zusätzliches Kurvensegment vom letzten Punkt und dem ersten Punkt, um es zu schließen hinzugefügt.  
  
 Das Punktarray muss mindestens vier enthalten <xref:System.Drawing.Point> Strukturen.  
  
 Diese Methode verwendet eine Standard-Spannung von 0,5.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen Pinsel mit Volltonfarbe roten.  
  
-   Erstellt ein Array von vier Punkte, um eine Splinekurve definieren.  
  
-   Legt den Füllmodus auf <xref:System.Drawing.Drawing2D.FillMode.Winding>.  
  
-   Füllt die Kurve auf dem Bildschirm an.  
  
 Die Kurve verfügt über eine Standard-Spannung von 0,5.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#94](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#94)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#94](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#94)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#94](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#94)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="brush" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="points" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FillClosedCurve">
      <MemberSignature Language="C#" Value="public void FillClosedCurve (System.Drawing.Brush brush, System.Drawing.PointF[] points, System.Drawing.Drawing2D.FillMode fillmode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillClosedCurve(class System.Drawing.Brush brush, valuetype System.Drawing.PointF[] points, valuetype System.Drawing.Drawing2D.FillMode fillmode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillClosedCurve(System.Drawing.Brush,System.Drawing.PointF[],System.Drawing.Drawing2D.FillMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillClosedCurve(System::Drawing::Brush ^ brush, cli::array &lt;System::Drawing::PointF&gt; ^ points, System::Drawing::Drawing2D::FillMode fillmode);" />
      <MemberSignature Language="F#" Value="member this.FillClosedCurve : System.Drawing.Brush * System.Drawing.PointF[] * System.Drawing.Drawing2D.FillMode -&gt; unit" Usage="graphics.FillClosedCurve (brush, points, fillmode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
        <Parameter Name="fillmode" Type="System.Drawing.Drawing2D.FillMode" />
      </Parameters>
      <Docs>
        <param name="brush">
          <see cref="T:System.Drawing.Brush" />, der die Merkmale des Füllvorgangs bestimmt.</param>
        <param name="points">Array von <see cref="T:System.Drawing.PointF" />-Strukturen, die die Splinekurve definieren.</param>
        <param name="fillmode">Member der <see cref="T:System.Drawing.Drawing2D.FillMode" />-Enumeration, der bestimmt, wie die Kurve ausgefüllt wird.</param>
        <summary>Füllt das Innere einer geschlossenen Cardinal-Splinekurve, die durch ein Array von <see cref="T:System.Drawing.PointF" />-Strukturen definiert ist, im angegebenen Füllmodus aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode füllt das Innere des eine geschlossene cardinal-Splinekurve, die jedem Punkt im Array durchlaufen. Wenn der letzte Punkt nicht den ersten Punkt übereinstimmt, wird ein zusätzliches Kurvensegment vom letzten Punkt und dem ersten Punkt, um es zu schließen hinzugefügt.  
  
 Das Punktarray muss mindestens vier enthalten <xref:System.Drawing.Point> Strukturen.  
  
 Diese Methode verwendet eine Standard-Spannung von 0,5.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen Pinsel mit Volltonfarbe roten.  
  
-   Erstellt ein Array von vier Punkte, um eine Splinekurve definieren.  
  
-   Legt den Füllmodus auf <xref:System.Drawing.Drawing2D.FillMode.Winding>.  
  
-   Füllt die Kurve auf dem Bildschirm an.  
  
 Die Kurve verfügt über eine Standard-Spannung von 0,5.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#97](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#97)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#97](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#97)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#97](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#97)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="brush" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="points" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FillClosedCurve">
      <MemberSignature Language="C#" Value="public void FillClosedCurve (System.Drawing.Brush brush, System.Drawing.Point[] points, System.Drawing.Drawing2D.FillMode fillmode, float tension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillClosedCurve(class System.Drawing.Brush brush, valuetype System.Drawing.Point[] points, valuetype System.Drawing.Drawing2D.FillMode fillmode, float32 tension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillClosedCurve(System.Drawing.Brush,System.Drawing.Point[],System.Drawing.Drawing2D.FillMode,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillClosedCurve(System::Drawing::Brush ^ brush, cli::array &lt;System::Drawing::Point&gt; ^ points, System::Drawing::Drawing2D::FillMode fillmode, float tension);" />
      <MemberSignature Language="F#" Value="member this.FillClosedCurve : System.Drawing.Brush * System.Drawing.Point[] * System.Drawing.Drawing2D.FillMode * single -&gt; unit" Usage="graphics.FillClosedCurve (brush, points, fillmode, tension)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="points" Type="System.Drawing.Point[]" />
        <Parameter Name="fillmode" Type="System.Drawing.Drawing2D.FillMode" />
        <Parameter Name="tension" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="brush">
          <see cref="T:System.Drawing.Brush" />, der die Merkmale des Füllvorgangs bestimmt.</param>
        <param name="points">Array von <see cref="T:System.Drawing.Point" />-Strukturen, die die Splinekurve definieren.</param>
        <param name="fillmode">Member der <see cref="T:System.Drawing.Drawing2D.FillMode" />-Enumeration, der bestimmt, wie die Kurve ausgefüllt wird.</param>
        <param name="tension">Ein Wert größer oder gleich 0,0F, der die Spannung der Kurve angibt.</param>
        <summary>Füllt das Innere einer geschlossenen Cardinal-Splinekurve, die durch ein Array von <see cref="T:System.Drawing.Point" />-Strukturen definiert ist, im angegebenen Füllmodus und mit der angegebenen Spannung aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode füllt das Innere des eine geschlossene cardinal-Splinekurve, die jedem Punkt im Array durchlaufen. Wenn der letzte Punkt nicht den ersten Punkt übereinstimmt, wird ein zusätzliches Kurvensegment vom letzten Punkt und dem ersten Punkt, um es zu schließen hinzugefügt.  
  
 Das Punktarray muss mindestens vier enthalten <xref:System.Drawing.Point> Strukturen.  
  
 Die `tension` -Parameter bestimmt die Form des Splines. Wenn der Wert des der `tension` -Parameter ist 0, 0F, diese Methode zeichnet gerade Liniensegmente um miteinander zu verbinden. In der Regel die `tension` -Parameter ist kleiner als oder gleich 1. 0f. Werte über 1. 0f zu ungewöhnliche Ergebnissen führen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen Pinsel mit Volltonfarbe roten.  
  
-   Erstellt ein Array von vier Punkte, um eine Splinekurve definieren.  
  
-   Legt den Füllmodus auf <xref:System.Drawing.Drawing2D.FillMode.Winding>.  
  
-   Legt die Spannung zu 1.0 fest.  
  
-   Füllt die Kurve auf dem Bildschirm an.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#95](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#95)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#95](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#95)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#95](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#95)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="brush" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="points" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FillClosedCurve">
      <MemberSignature Language="C#" Value="public void FillClosedCurve (System.Drawing.Brush brush, System.Drawing.PointF[] points, System.Drawing.Drawing2D.FillMode fillmode, float tension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillClosedCurve(class System.Drawing.Brush brush, valuetype System.Drawing.PointF[] points, valuetype System.Drawing.Drawing2D.FillMode fillmode, float32 tension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillClosedCurve(System.Drawing.Brush,System.Drawing.PointF[],System.Drawing.Drawing2D.FillMode,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillClosedCurve(System::Drawing::Brush ^ brush, cli::array &lt;System::Drawing::PointF&gt; ^ points, System::Drawing::Drawing2D::FillMode fillmode, float tension);" />
      <MemberSignature Language="F#" Value="member this.FillClosedCurve : System.Drawing.Brush * System.Drawing.PointF[] * System.Drawing.Drawing2D.FillMode * single -&gt; unit" Usage="graphics.FillClosedCurve (brush, points, fillmode, tension)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
        <Parameter Name="fillmode" Type="System.Drawing.Drawing2D.FillMode" />
        <Parameter Name="tension" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="brush">Ein <see cref="T:System.Drawing.Brush" />, der die Merkmale des Füllvorgangs bestimmt.</param>
        <param name="points">Array von <see cref="T:System.Drawing.PointF" />-Strukturen, die die Splinekurve definieren.</param>
        <param name="fillmode">Member der <see cref="T:System.Drawing.Drawing2D.FillMode" />-Enumeration, der bestimmt, wie die Kurve ausgefüllt wird.</param>
        <param name="tension">Ein Wert größer oder gleich 0,0F, der die Spannung der Kurve angibt.</param>
        <summary>Füllt das Innere einer geschlossenen Cardinal-Splinekurve, die durch ein Array von <see cref="T:System.Drawing.PointF" />-Strukturen definiert ist, im angegebenen Füllmodus und mit der angegebenen Spannung aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode füllt das Innere des eine geschlossene cardinal-Splinekurve, die jedem Punkt im Array durchlaufen. Wenn der letzte Punkt nicht den ersten Punkt übereinstimmt, wird ein zusätzliches Kurvensegment vom letzten Punkt und dem ersten Punkt, um es zu schließen hinzugefügt.  
  
 Das Punktarray muss mindestens vier enthalten <xref:System.Drawing.Point> Strukturen.  
  
 Die `tension` -Parameter bestimmt die Form des Splines. Wenn der Wert des der `tension` -Parameter ist 0, 0F, diese Methode zeichnet gerade Liniensegmente um miteinander zu verbinden. In der Regel die `tension` -Parameter ist kleiner als oder gleich 1. 0f. Werte über 1. 0f zu ungewöhnliche Ergebnissen führen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen Pinsel mit Volltonfarbe roten.  
  
-   Erstellt ein Array von vier Punkte, um eine Splinekurve definieren.  
  
-   Legt den Füllmodus auf <xref:System.Drawing.Drawing2D.FillMode.Winding>.  
  
-   Legt die Spannung zu 1.0 fest.  
  
-   Füllt die Kurve auf dem Bildschirm an.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#98](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#98)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#98](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#98)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#98](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="brush" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="points" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="FillEllipse">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Füllt das Innere einer Ellipse, die durch ein umschließendes Rechteck definiert ist, das durch ein Koordinatenpaar, eine Höhen- und eine Breitenangabe angegeben ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FillEllipse">
      <MemberSignature Language="C#" Value="public void FillEllipse (System.Drawing.Brush brush, System.Drawing.Rectangle rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillEllipse(class System.Drawing.Brush brush, valuetype System.Drawing.Rectangle rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillEllipse(System.Drawing.Brush,System.Drawing.Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillEllipse(System::Drawing::Brush ^ brush, System::Drawing::Rectangle rect);" />
      <MemberSignature Language="F#" Value="member this.FillEllipse : System.Drawing.Brush * System.Drawing.Rectangle -&gt; unit" Usage="graphics.FillEllipse (brush, rect)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="brush">
          <see cref="T:System.Drawing.Brush" />, der die Merkmale des Füllvorgangs bestimmt.</param>
        <param name="rect">
          <see cref="T:System.Drawing.Rectangle" />-Struktur, die das umschließende Rechteck darstellt, das die Ellipse definiert.</param>
        <summary>Füllt das Innere einer Ellipse, die durch ein umschließendes Rechteck definiert ist, das durch eine <see cref="T:System.Drawing.Rectangle" />-Struktur angegeben ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode füllt das Innere einer Ellipse mit einem <xref:System.Drawing.Brush>. Die Ellipse wird definiert durch das umschließende Rechteck dargestellt durch die `rect` Parameter.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen Pinsel mit Volltonfarbe roten.  
  
-   Erstellt ein Rechteck, das eine Ellipse umschließt.  
  
-   Füllt die Ellipse auf dem Bildschirm.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#99](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#99)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#99](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#99)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#99](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#99)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="brush" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FillEllipse">
      <MemberSignature Language="C#" Value="public void FillEllipse (System.Drawing.Brush brush, System.Drawing.RectangleF rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillEllipse(class System.Drawing.Brush brush, valuetype System.Drawing.RectangleF rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillEllipse(System.Drawing.Brush,System.Drawing.RectangleF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillEllipse(System::Drawing::Brush ^ brush, System::Drawing::RectangleF rect);" />
      <MemberSignature Language="F#" Value="member this.FillEllipse : System.Drawing.Brush * System.Drawing.RectangleF -&gt; unit" Usage="graphics.FillEllipse (brush, rect)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="rect" Type="System.Drawing.RectangleF" />
      </Parameters>
      <Docs>
        <param name="brush">
          <see cref="T:System.Drawing.Brush" />, der die Merkmale des Füllvorgangs bestimmt.</param>
        <param name="rect">
          <see cref="T:System.Drawing.RectangleF" />-Struktur, die das umschließende Rechteck darstellt, das die Ellipse definiert.</param>
        <summary>Füllt das Innere einer Ellipse, die durch ein umschließendes Rechteck definiert ist, das durch eine <see cref="T:System.Drawing.RectangleF" />-Struktur angegeben ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode füllt das Innere einer Ellipse mit einem <xref:System.Drawing.Brush>. Die Ellipse wird definiert durch das umschließende Rechteck dargestellt durch die `rect` Parameter.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen Pinsel mit Volltonfarbe roten.  
  
-   Erstellt ein Rechteck, das eine Ellipse umschließt.  
  
-   Füllt die Ellipse auf dem Bildschirm.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#100](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#100)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#100](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#100)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#100](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#100)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="brush" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FillEllipse">
      <MemberSignature Language="C#" Value="public void FillEllipse (System.Drawing.Brush brush, int x, int y, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillEllipse(class System.Drawing.Brush brush, int32 x, int32 y, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillEllipse(System.Drawing.Brush,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillEllipse(System::Drawing::Brush ^ brush, int x, int y, int width, int height);" />
      <MemberSignature Language="F#" Value="member this.FillEllipse : System.Drawing.Brush * int * int * int * int -&gt; unit" Usage="graphics.FillEllipse (brush, x, y, width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="brush">
          <see cref="T:System.Drawing.Brush" />, der die Merkmale des Füllvorgangs bestimmt.</param>
        <param name="x">Die x-Koordinate der oberen linken Ecke des umschließenden Rechtecks, das die Ellipse definiert.</param>
        <param name="y">Die y-Koordinate der oberen linken Ecke des umschließenden Rechtecks, das die Ellipse definiert.</param>
        <param name="width">Breite des umschließenden Rechtecks, das die Ellipse definiert.</param>
        <param name="height">Höhe des umschließenden Rechtecks, das die Ellipse definiert.</param>
        <summary>Füllt das Innere einer Ellipse, die durch ein umschließendes Rechteck definiert ist, das durch ein Koordinatenpaar, eine Höhen- und eine Breitenangabe angegeben ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode füllt das Innere einer Ellipse mit einem <xref:System.Drawing.Brush>. Die Ellipse wird definiert durch das umschließende Rechteck dargestellt durch die `x`, `y`, `width`, und `height` Parameter.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen Pinsel mit Volltonfarbe roten.  
  
-   Erstellt die Position und Größe eines Rechtecks, das eine Ellipse umschließt.  
  
-   Füllt die Ellipse auf dem Bildschirm.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#101](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#101)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#101](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#101)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#101](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#101)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="brush" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FillEllipse">
      <MemberSignature Language="C#" Value="public void FillEllipse (System.Drawing.Brush brush, float x, float y, float width, float height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillEllipse(class System.Drawing.Brush brush, float32 x, float32 y, float32 width, float32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillEllipse(System.Drawing.Brush,System.Single,System.Single,System.Single,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillEllipse(System::Drawing::Brush ^ brush, float x, float y, float width, float height);" />
      <MemberSignature Language="F#" Value="member this.FillEllipse : System.Drawing.Brush * single * single * single * single -&gt; unit" Usage="graphics.FillEllipse (brush, x, y, width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="width" Type="System.Single" />
        <Parameter Name="height" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="brush">
          <see cref="T:System.Drawing.Brush" />, der die Merkmale des Füllvorgangs bestimmt.</param>
        <param name="x">Die x-Koordinate der oberen linken Ecke des umschließenden Rechtecks, das die Ellipse definiert.</param>
        <param name="y">Die y-Koordinate der oberen linken Ecke des umschließenden Rechtecks, das die Ellipse definiert.</param>
        <param name="width">Breite des umschließenden Rechtecks, das die Ellipse definiert.</param>
        <param name="height">Höhe des umschließenden Rechtecks, das die Ellipse definiert.</param>
        <summary>Füllt das Innere einer Ellipse, die durch ein umschließendes Rechteck definiert ist, das durch ein Koordinatenpaar, eine Höhen- und eine Breitenangabe angegeben ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode füllt das Innere einer Ellipse mit einem <xref:System.Drawing.Brush>. Die Ellipse wird definiert durch das umschließende Rechteck dargestellt durch die `x`, `y`, `width`, und `height` Parameter.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen Pinsel mit Volltonfarbe roten.  
  
-   Erstellt die Position und Größe eines Rechtecks, das eine Ellipse umschließt.  
  
-   Füllt die Ellipse auf dem Bildschirm.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#102](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#102)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#102](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#102)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#102](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#102)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="brush" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FillPath">
      <MemberSignature Language="C#" Value="public void FillPath (System.Drawing.Brush brush, System.Drawing.Drawing2D.GraphicsPath path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillPath(class System.Drawing.Brush brush, class System.Drawing.Drawing2D.GraphicsPath path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillPath(System.Drawing.Brush,System.Drawing.Drawing2D.GraphicsPath)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillPath(System::Drawing::Brush ^ brush, System::Drawing::Drawing2D::GraphicsPath ^ path);" />
      <MemberSignature Language="F#" Value="member this.FillPath : System.Drawing.Brush * System.Drawing.Drawing2D.GraphicsPath -&gt; unit" Usage="graphics.FillPath (brush, path)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="path" Type="System.Drawing.Drawing2D.GraphicsPath" />
      </Parameters>
      <Docs>
        <param name="brush">
          <see cref="T:System.Drawing.Brush" />, der die Merkmale des Füllvorgangs bestimmt.</param>
        <param name="path">
          <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />, der den auszufüllenden Pfad darstellt.</param>
        <summary>Füllt das Innere von einem <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Drawing.Drawing2D.GraphicsPath> besteht aus einer Reihe von Linien- und Segmenten. Wenn der Pfad durch dargestellt die `path` Parameter nicht geschlossen ist, ein zusätzliches Segment wurde vom letzten Punkt und dem ersten Punkt um den Pfad zu schließen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen Pinsel mit Volltonfarbe roten.  
  
-   Erstellt ein Grafikobjekt-Pfad an.  
  
-   Der Grafikpfad wird eine Ellipse hinzugefügt.  
  
-   Füllt den Pfad auf dem Bildschirm.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#103](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#103)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#103](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#103)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#103](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#103)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="brush" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="path" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="FillPie">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Füllt das Innere eines Kreisausschnitts, der durch eine Ellipse definiert wird, die durch ein Koordinatenpaar, eine Breiten- und eine Höhenangabe und zwei Radien angegeben ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FillPie">
      <MemberSignature Language="C#" Value="public void FillPie (System.Drawing.Brush brush, System.Drawing.Rectangle rect, float startAngle, float sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillPie(class System.Drawing.Brush brush, valuetype System.Drawing.Rectangle rect, float32 startAngle, float32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillPie(System.Drawing.Brush,System.Drawing.Rectangle,System.Single,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillPie(System::Drawing::Brush ^ brush, System::Drawing::Rectangle rect, float startAngle, float sweepAngle);" />
      <MemberSignature Language="F#" Value="member this.FillPie : System.Drawing.Brush * System.Drawing.Rectangle * single * single -&gt; unit" Usage="graphics.FillPie (brush, rect, startAngle, sweepAngle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
        <Parameter Name="startAngle" Type="System.Single" />
        <Parameter Name="sweepAngle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="brush">
          <see cref="T:System.Drawing.Brush" />, der die Merkmale des Füllvorgangs bestimmt.</param>
        <param name="rect">
          <see cref="T:System.Drawing.Rectangle" />-Struktur, die das umschließende Rechteck darstellt, das die Ellipse definiert, aus der der Kreisausschnitt stammt.</param>
        <param name="startAngle">Zwischen der x-Achse und der ersten Seite des Kreisausschnitts im Uhrzeigersinn gemessener Winkel in Grad.</param>
        <param name="sweepAngle">Zwischen dem <paramref name="startAngle" />-Parameter und der zweiten Seite des Kreisausschnitts im Uhrzeigersinn gemessener Winkel in Grad.</param>
        <summary>Füllt das Innere eines Kreisausschnitts, der durch eine Ellipse definiert ist, die durch eine <see cref="T:System.Drawing.RectangleF" />-Struktur und zwei Radien angegeben wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode füllt das Innere eines Kreisausschnitts, der durch einen Bogen einer Ellipse und die zwei Radien, die sich überschneiden, mit den Endpunkten des Bogens definiert. Die Ellipse wird durch das umschließende Rechteck definiert. Der Kreisausschnitt besteht aus den zwei Radien von definiert die `startAngle` und `sweepAngle` Parameter und den Bogen zwischen den Schnittmengen von dieser Radien mit der Ellipse.  
  
 Wenn die `sweepAngle` -Parameter ist größer als 360 Grad oder kleiner als-360 Grad, es wird behandelt, als wäre es 360 Grad oder-360 Grad bzw.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen Pinsel mit Volltonfarbe roten.  
  
-   Erstellt ein Rechteck, das eine Ellipse umschließt.  
  
-   Definiert den Startwinkel (in Bezug auf die x-Achse) und den mittelpunktswinkel (beide im Uhrzeigersinn).  
  
-   Füllt den kreisförmigen Bereichs der Ellipse auf dem Bildschirm an.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#104](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#104)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#104](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#104)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#104](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#104)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="brush" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FillPie">
      <MemberSignature Language="C#" Value="public void FillPie (System.Drawing.Brush brush, int x, int y, int width, int height, int startAngle, int sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillPie(class System.Drawing.Brush brush, int32 x, int32 y, int32 width, int32 height, int32 startAngle, int32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillPie(System.Drawing.Brush,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillPie(System::Drawing::Brush ^ brush, int x, int y, int width, int height, int startAngle, int sweepAngle);" />
      <MemberSignature Language="F#" Value="member this.FillPie : System.Drawing.Brush * int * int * int * int * int * int -&gt; unit" Usage="graphics.FillPie (brush, x, y, width, height, startAngle, sweepAngle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
        <Parameter Name="startAngle" Type="System.Int32" />
        <Parameter Name="sweepAngle" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="brush">
          <see cref="T:System.Drawing.Brush" />, der die Merkmale des Füllvorgangs bestimmt.</param>
        <param name="x">Die x-Koordinate der oberen linken Ecke des umschließenden Rechtecks, das die Ellipse definiert, aus der der Kreisausschnitt stammt.</param>
        <param name="y">Die y-Koordinate der oberen linken Ecke des umschließenden Rechtecks, das die Ellipse definiert, aus der der Kreisausschnitt stammt.</param>
        <param name="width">Breite des umschließenden Rechtecks, das die Ellipse definiert, aus der der Kreisausschnitt stammt.</param>
        <param name="height">Höhe des umschließenden Rechtecks, das die Ellipse definiert, aus der der Kreisausschnitt stammt.</param>
        <param name="startAngle">Zwischen der x-Achse und der ersten Seite des Kreisausschnitts im Uhrzeigersinn gemessener Winkel in Grad.</param>
        <param name="sweepAngle">Zwischen dem <paramref name="startAngle" />-Parameter und der zweiten Seite des Kreisausschnitts im Uhrzeigersinn gemessener Winkel in Grad.</param>
        <summary>Füllt das Innere eines Kreisausschnitts, der durch eine Ellipse definiert wird, die durch ein Koordinatenpaar, eine Breiten- und eine Höhenangabe und zwei Radien angegeben ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode füllt das Innere eines Kreisausschnitts, der durch einen Bogen einer Ellipse und die zwei Radien, die sich überschneiden, mit den Endpunkten des Bogens definiert. Die Ellipse wird durch das umschließende Rechteck definiert. Der Kreisausschnitt besteht aus den zwei Radien von definiert die `startAngle` und `sweepAngle` Parameter und den Bogen zwischen den Schnittmengen von dieser Radien mit der Ellipse.  
  
 Wenn die `sweepAngle` -Parameter ist größer als 360 Grad oder kleiner als-360 Grad, es wird behandelt, als wäre es 360 Grad oder-360 Grad bzw.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen Pinsel mit Volltonfarbe roten.  
  
-   Erstellt die Position und Größe eines Rechtecks, das eine Ellipse umschließt.  
  
-   Definiert den Startwinkel (in Bezug auf die x-Achse) und den mittelpunktswinkel (beide im Uhrzeigersinn).  
  
-   Füllt den kreisförmigen Bereichs der Ellipse auf dem Bildschirm an.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#105](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#105)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#105](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#105)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#105](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#105)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="brush" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FillPie">
      <MemberSignature Language="C#" Value="public void FillPie (System.Drawing.Brush brush, float x, float y, float width, float height, float startAngle, float sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillPie(class System.Drawing.Brush brush, float32 x, float32 y, float32 width, float32 height, float32 startAngle, float32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillPie(System.Drawing.Brush,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillPie(System::Drawing::Brush ^ brush, float x, float y, float width, float height, float startAngle, float sweepAngle);" />
      <MemberSignature Language="F#" Value="member this.FillPie : System.Drawing.Brush * single * single * single * single * single * single -&gt; unit" Usage="graphics.FillPie (brush, x, y, width, height, startAngle, sweepAngle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="width" Type="System.Single" />
        <Parameter Name="height" Type="System.Single" />
        <Parameter Name="startAngle" Type="System.Single" />
        <Parameter Name="sweepAngle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="brush">
          <see cref="T:System.Drawing.Brush" />, der die Merkmale des Füllvorgangs bestimmt.</param>
        <param name="x">Die x-Koordinate der oberen linken Ecke des umschließenden Rechtecks, das die Ellipse definiert, aus der der Kreisausschnitt stammt.</param>
        <param name="y">Die y-Koordinate der oberen linken Ecke des umschließenden Rechtecks, das die Ellipse definiert, aus der der Kreisausschnitt stammt.</param>
        <param name="width">Breite des umschließenden Rechtecks, das die Ellipse definiert, aus der der Kreisausschnitt stammt.</param>
        <param name="height">Höhe des umschließenden Rechtecks, das die Ellipse definiert, aus der der Kreisausschnitt stammt.</param>
        <param name="startAngle">Zwischen der x-Achse und der ersten Seite des Kreisausschnitts im Uhrzeigersinn gemessener Winkel in Grad.</param>
        <param name="sweepAngle">Zwischen dem <paramref name="startAngle" />-Parameter und der zweiten Seite des Kreisausschnitts im Uhrzeigersinn gemessener Winkel in Grad.</param>
        <summary>Füllt das Innere eines Kreisausschnitts, der durch eine Ellipse definiert wird, die durch ein Koordinatenpaar, eine Breiten- und eine Höhenangabe und zwei Radien angegeben ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode füllt das Innere eines Kreisausschnitts, der durch einen Bogen einer Ellipse und die zwei Radien, die sich überschneiden, mit den Endpunkten des Bogens definiert. Die Ellipse wird durch das umschließende Rechteck definiert. Der Kreisausschnitt besteht aus den zwei Radien von definiert die `startAngle` und `sweepAngle` Parameter und den Bogen zwischen den Schnittmengen von dieser Radien mit der Ellipse.  
  
 Wenn die `sweepAngle` -Parameter ist größer als 360 Grad oder kleiner als-360 Grad, es wird behandelt, als wäre es 360 Grad oder-360 Grad bzw.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen Pinsel mit Volltonfarbe roten.  
  
-   Erstellt die Position und Größe eines Rechtecks, das eine Ellipse umschließt.  
  
-   Definiert den Startwinkel (in Bezug auf die x-Achse) und den mittelpunktswinkel (beide im Uhrzeigersinn).  
  
-   Füllt den kreisförmigen Bereichs der Ellipse auf dem Bildschirm an.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#106](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#106)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#106](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#106)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#106](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#106)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="brush" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="FillPolygon">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Füllt das Innere eines Vielecks, das durch ein Array von Punkten definiert ist, das durch <see cref="T:System.Drawing.Point" />-Strukturen angegeben ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FillPolygon">
      <MemberSignature Language="C#" Value="public void FillPolygon (System.Drawing.Brush brush, System.Drawing.Point[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillPolygon(class System.Drawing.Brush brush, valuetype System.Drawing.Point[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillPolygon(System.Drawing.Brush,System.Drawing.Point[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillPolygon(System::Drawing::Brush ^ brush, cli::array &lt;System::Drawing::Point&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.FillPolygon : System.Drawing.Brush * System.Drawing.Point[] -&gt; unit" Usage="graphics.FillPolygon (brush, points)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="points" Type="System.Drawing.Point[]" />
      </Parameters>
      <Docs>
        <param name="brush">
          <see cref="T:System.Drawing.Brush" />, der die Merkmale des Füllvorgangs bestimmt.</param>
        <param name="points">Array von <see cref="T:System.Drawing.Point" />-Strukturen, die die Eckpunkte des zu füllenden Vielecks darstellen.</param>
        <summary>Füllt das Innere eines Vielecks, das durch ein Array von Punkten definiert ist, das durch <see cref="T:System.Drawing.Point" />-Strukturen angegeben ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeder zwei aufeinander folgenden Punkten im Array gibt es sich um eine Seite des Polygons. Wenn der letzte Punkt und der erste Punkt nicht übereinstimmen, geben sie außerdem die schließende-Seite des Polygons.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen Pinsel mit blauen Volltonfarbe.  
  
-   Erstellt ein Array von sieben Punkte, um ein Polygon zu definieren.  
  
-   Füllt den polygonalen Bereich auf dem Bildschirm.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#107](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#107)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#107](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#107)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#107](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#107)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="brush" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="points" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FillPolygon">
      <MemberSignature Language="C#" Value="public void FillPolygon (System.Drawing.Brush brush, System.Drawing.PointF[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillPolygon(class System.Drawing.Brush brush, valuetype System.Drawing.PointF[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillPolygon(System.Drawing.Brush,System.Drawing.PointF[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillPolygon(System::Drawing::Brush ^ brush, cli::array &lt;System::Drawing::PointF&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.FillPolygon : System.Drawing.Brush * System.Drawing.PointF[] -&gt; unit" Usage="graphics.FillPolygon (brush, points)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
      </Parameters>
      <Docs>
        <param name="brush">
          <see cref="T:System.Drawing.Brush" />, der die Merkmale des Füllvorgangs bestimmt.</param>
        <param name="points">Array von <see cref="T:System.Drawing.PointF" />-Strukturen, die die Eckpunkte des zu füllenden Vielecks darstellen.</param>
        <summary>Füllt das Innere eines Vielecks, das durch ein Array von Punkten definiert ist, das durch <see cref="T:System.Drawing.PointF" />-Strukturen angegeben ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeder zwei aufeinander folgenden Punkten im Array gibt es sich um eine Seite des Polygons. Wenn der letzte Punkt und der erste Punkt nicht übereinstimmen, geben sie außerdem die schließende-Seite des Polygons.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen Pinsel mit blauen Volltonfarbe.  
  
-   Erstellt ein Array von sieben Punkte, um ein Polygon zu definieren.  
  
-   Füllt den polygonalen Bereich auf dem Bildschirm.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#109](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#109)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#109](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#109)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#109](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#109)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="brush" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="points" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FillPolygon">
      <MemberSignature Language="C#" Value="public void FillPolygon (System.Drawing.Brush brush, System.Drawing.Point[] points, System.Drawing.Drawing2D.FillMode fillMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillPolygon(class System.Drawing.Brush brush, valuetype System.Drawing.Point[] points, valuetype System.Drawing.Drawing2D.FillMode fillMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillPolygon(System.Drawing.Brush,System.Drawing.Point[],System.Drawing.Drawing2D.FillMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillPolygon(System::Drawing::Brush ^ brush, cli::array &lt;System::Drawing::Point&gt; ^ points, System::Drawing::Drawing2D::FillMode fillMode);" />
      <MemberSignature Language="F#" Value="member this.FillPolygon : System.Drawing.Brush * System.Drawing.Point[] * System.Drawing.Drawing2D.FillMode -&gt; unit" Usage="graphics.FillPolygon (brush, points, fillMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="points" Type="System.Drawing.Point[]" />
        <Parameter Name="fillMode" Type="System.Drawing.Drawing2D.FillMode" />
      </Parameters>
      <Docs>
        <param name="brush">
          <see cref="T:System.Drawing.Brush" />, der die Merkmale des Füllvorgangs bestimmt.</param>
        <param name="points">Array von <see cref="T:System.Drawing.Point" />-Strukturen, die die Eckpunkte des zu füllenden Vielecks darstellen.</param>
        <param name="fillMode">Member der <see cref="T:System.Drawing.Drawing2D.FillMode" />-Enumeration, der den Stil für den Füllvorgang bestimmt.</param>
        <summary>Füllt das Innere eines Vielecks, das durch ein Array von Punkten definiert ist, das durch <see cref="T:System.Drawing.Point" />-Strukturen angegeben ist, wobei der angegebene Füllmodus verwendet wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeder zwei aufeinander folgenden Punkten im Array gibt es sich um eine Seite des Polygons. Wenn der letzte Punkt und der erste Punkt nicht übereinstimmen, geben sie außerdem die schließende-Seite des Polygons.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen Pinsel mit blauen Volltonfarbe.  
  
-   Erstellt ein Array von sieben Punkte, um ein Polygon zu definieren.  
  
-   Legt den Füllmodus auf <xref:System.Drawing.Drawing2D.FillMode.Winding>.  
  
-   Füllt den polygonalen Bereich auf dem Bildschirm.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#108](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#108)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#108](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#108)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#108](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#108)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="brush" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="points" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FillPolygon">
      <MemberSignature Language="C#" Value="public void FillPolygon (System.Drawing.Brush brush, System.Drawing.PointF[] points, System.Drawing.Drawing2D.FillMode fillMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillPolygon(class System.Drawing.Brush brush, valuetype System.Drawing.PointF[] points, valuetype System.Drawing.Drawing2D.FillMode fillMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillPolygon(System.Drawing.Brush,System.Drawing.PointF[],System.Drawing.Drawing2D.FillMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillPolygon(System::Drawing::Brush ^ brush, cli::array &lt;System::Drawing::PointF&gt; ^ points, System::Drawing::Drawing2D::FillMode fillMode);" />
      <MemberSignature Language="F#" Value="member this.FillPolygon : System.Drawing.Brush * System.Drawing.PointF[] * System.Drawing.Drawing2D.FillMode -&gt; unit" Usage="graphics.FillPolygon (brush, points, fillMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
        <Parameter Name="fillMode" Type="System.Drawing.Drawing2D.FillMode" />
      </Parameters>
      <Docs>
        <param name="brush">
          <see cref="T:System.Drawing.Brush" />, der die Merkmale des Füllvorgangs bestimmt.</param>
        <param name="points">Array von <see cref="T:System.Drawing.PointF" />-Strukturen, die die Eckpunkte des zu füllenden Vielecks darstellen.</param>
        <param name="fillMode">Member der <see cref="T:System.Drawing.Drawing2D.FillMode" />-Enumeration, der den Stil für den Füllvorgang bestimmt.</param>
        <summary>Füllt das Innere eines Vielecks, das durch ein Array von Punkten definiert ist, das durch <see cref="T:System.Drawing.PointF" />-Strukturen angegeben ist, wobei der angegebene Füllmodus verwendet wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeder zwei aufeinander folgenden Punkten im Array gibt es sich um eine Seite des Polygons. Wenn der letzte Punkt und der erste Punkt nicht übereinstimmen, geben sie außerdem die schließende-Seite des Polygons.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgende Aktionen aus:  
  
-   Erstellt einen Pinsel mit blauen Volltonfarbe.  
  
-   Erstellt ein Array von sieben Punkte, um ein Polygon zu definieren.  
  
-   Legt den Füllmodus auf <xref:System.Drawing.Drawing2D.FillMode.Winding>.  
  
-   Füllt den polygonalen Bereich auf dem Bildschirm.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#110](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#110)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#110](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#110)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#110](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#110)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="brush" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="points" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="FillRectangle">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Füllt das Innere eines Rechtecks, das durch ein Koordinatenpaar, eine Höhen- und eine Breitenangabe angegeben ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FillRectangle">
      <MemberSignature Language="C#" Value="public void FillRectangle (System.Drawing.Brush brush, System.Drawing.Rectangle rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillRectangle(class System.Drawing.Brush brush, valuetype System.Drawing.Rectangle rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillRectangle(System.Drawing.Brush,System.Drawing.Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillRectangle(System::Drawing::Brush ^ brush, System::Drawing::Rectangle rect);" />
      <MemberSignature Language="F#" Value="member this.FillRectangle : System.Drawing.Brush * System.Drawing.Rectangle -&gt; unit" Usage="graphics.FillRectangle (brush, rect)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="brush">
          <see cref="T:System.Drawing.Brush" />, der die Merkmale des Füllvorgangs bestimmt.</param>
        <param name="rect">
          <see cref="T:System.Drawing.Rectangle" />-Struktur, die das zu füllende Rechteck darstellt.</param>
        <summary>Füllt das Innere eines durch eine <see cref="T:System.Drawing.Rectangle" />-Struktur angegebenen Rechtecks.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode füllt das Innere des Rechtecks von definiert die `rect` Parameter, einschließlich der angegebenen oberen linken Ecke bis zu der berechneten senken und Rändern.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgende Aktionen aus:  
  
-   Erstellt einen Pinsel mit blauen Volltonfarbe.  
  
-   Erstellt ein Rechteck.  
  
-   Füllt den rechteckigen Bereich auf dem Bildschirm.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#111](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#111)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#111](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#111)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#111](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#111)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="brush" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FillRectangle">
      <MemberSignature Language="C#" Value="public void FillRectangle (System.Drawing.Brush brush, System.Drawing.RectangleF rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillRectangle(class System.Drawing.Brush brush, valuetype System.Drawing.RectangleF rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillRectangle(System.Drawing.Brush,System.Drawing.RectangleF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillRectangle(System::Drawing::Brush ^ brush, System::Drawing::RectangleF rect);" />
      <MemberSignature Language="F#" Value="member this.FillRectangle : System.Drawing.Brush * System.Drawing.RectangleF -&gt; unit" Usage="graphics.FillRectangle (brush, rect)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="rect" Type="System.Drawing.RectangleF" />
      </Parameters>
      <Docs>
        <param name="brush">
          <see cref="T:System.Drawing.Brush" />, der die Merkmale des Füllvorgangs bestimmt.</param>
        <param name="rect">
          <see cref="T:System.Drawing.RectangleF" />-Struktur, die das zu füllende Rechteck darstellt.</param>
        <summary>Füllt das Innere eines durch eine <see cref="T:System.Drawing.RectangleF" />-Struktur angegebenen Rechtecks.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode füllt das Innere des Rechtecks von definiert die `rect` Parameter, einschließlich der angegebenen oberen linken Ecke bis zu der berechneten senken und Rändern.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgende Aktionen aus:  
  
-   Erstellt einen Pinsel mit blauen Volltonfarbe.  
  
-   Erstellt ein Rechteck.  
  
-   Füllt den rechteckigen Bereich auf dem Bildschirm.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#112](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#112)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#112](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#112)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#112](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#112)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="brush" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FillRectangle">
      <MemberSignature Language="C#" Value="public void FillRectangle (System.Drawing.Brush brush, int x, int y, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillRectangle(class System.Drawing.Brush brush, int32 x, int32 y, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillRectangle(System.Drawing.Brush,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillRectangle(System::Drawing::Brush ^ brush, int x, int y, int width, int height);" />
      <MemberSignature Language="F#" Value="member this.FillRectangle : System.Drawing.Brush * int * int * int * int -&gt; unit" Usage="graphics.FillRectangle (brush, x, y, width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="brush">
          <see cref="T:System.Drawing.Brush" />, der die Merkmale des Füllvorgangs bestimmt.</param>
        <param name="x">Die x-Koordinate der oberen linken Ecke des zu füllenden Rechtecks.</param>
        <param name="y">Die y-Koordinate der oberen linken Ecke des zu füllenden Rechtecks.</param>
        <param name="width">Breite des zu füllenden Rechtecks.</param>
        <param name="height">Höhe des zu füllenden Rechtecks.</param>
        <summary>Füllt das Innere eines Rechtecks, das durch ein Koordinatenpaar, eine Höhen- und eine Breitenangabe angegeben ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode füllt das Innere des Rechtecks von definiert die`x`, `y`, `width`, und `height` Parametern – einschließlich der angegebenen oberen linken Ecke bis zu der berechneten senken und Rändern.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgende Aktionen aus:  
  
-   Erstellt einen Pinsel mit blauen Volltonfarbe.  
  
-   Erstellt die Position und Größe eines Rechtecks an.  
  
-   Füllt den rechteckigen Bereich auf dem Bildschirm.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#113](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#113)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#113](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#113)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#113](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#113)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="brush" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FillRectangle">
      <MemberSignature Language="C#" Value="public void FillRectangle (System.Drawing.Brush brush, float x, float y, float width, float height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillRectangle(class System.Drawing.Brush brush, float32 x, float32 y, float32 width, float32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillRectangle(System.Drawing.Brush,System.Single,System.Single,System.Single,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillRectangle(System::Drawing::Brush ^ brush, float x, float y, float width, float height);" />
      <MemberSignature Language="F#" Value="member this.FillRectangle : System.Drawing.Brush * single * single * single * single -&gt; unit" Usage="graphics.FillRectangle (brush, x, y, width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="width" Type="System.Single" />
        <Parameter Name="height" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="brush">
          <see cref="T:System.Drawing.Brush" />, der die Merkmale des Füllvorgangs bestimmt.</param>
        <param name="x">Die x-Koordinate der oberen linken Ecke des zu füllenden Rechtecks.</param>
        <param name="y">Die y-Koordinate der oberen linken Ecke des zu füllenden Rechtecks.</param>
        <param name="width">Breite des zu füllenden Rechtecks.</param>
        <param name="height">Höhe des zu füllenden Rechtecks.</param>
        <summary>Füllt das Innere eines Rechtecks, das durch ein Koordinatenpaar, eine Höhen- und eine Breitenangabe angegeben ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode füllt das Innere des Rechtecks von definiert die `x`, `y`, `width`, und `height` Parametern – einschließlich der angegebenen oberen linken Ecke bis zu der berechneten senken und Rändern.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgende Aktionen aus:  
  
-   Erstellt einen Pinsel mit blauen Volltonfarbe.  
  
-   Erstellt die Position und Größe eines Rechtecks an.  
  
-   Füllt den rechteckigen Bereich auf dem Bildschirm.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#114](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#114)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#114](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#114)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#114](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#114)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="brush" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="FillRectangles">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Füllt das Innere einer Reihe von Rechtecken, die durch <see cref="T:System.Drawing.Rectangle" />-Strukturen angegeben sind.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FillRectangles">
      <MemberSignature Language="C#" Value="public void FillRectangles (System.Drawing.Brush brush, System.Drawing.Rectangle[] rects);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillRectangles(class System.Drawing.Brush brush, valuetype System.Drawing.Rectangle[] rects) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillRectangles(System.Drawing.Brush,System.Drawing.Rectangle[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillRectangles(System::Drawing::Brush ^ brush, cli::array &lt;System::Drawing::Rectangle&gt; ^ rects);" />
      <MemberSignature Language="F#" Value="member this.FillRectangles : System.Drawing.Brush * System.Drawing.Rectangle[] -&gt; unit" Usage="graphics.FillRectangles (brush, rects)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="rects" Type="System.Drawing.Rectangle[]" />
      </Parameters>
      <Docs>
        <param name="brush">
          <see cref="T:System.Drawing.Brush" />, der die Merkmale des Füllvorgangs bestimmt.</param>
        <param name="rects">Array von <see cref="T:System.Drawing.Rectangle" />-Strukturen, die die zu füllenden Rechtecke darstellen.</param>
        <summary>Füllt das Innere einer Reihe von Rechtecken, die durch <see cref="T:System.Drawing.Rectangle" />-Strukturen angegeben sind.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgende Aktionen aus:  
  
-   Erstellt einen Pinsel mit blauen Volltonfarbe.  
  
-   Erstellt ein Array mit drei Rechtecken.  
  
-   Füllt die drei rechteckige Bereiche auf dem Bildschirm an.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#115](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#115)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#115](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#115)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#115](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#115)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="brush" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="rects" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="rects" /> ist ein Array der Länge 0 (null).</exception>
      </Docs>
    </Member>
    <Member MemberName="FillRectangles">
      <MemberSignature Language="C#" Value="public void FillRectangles (System.Drawing.Brush brush, System.Drawing.RectangleF[] rects);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillRectangles(class System.Drawing.Brush brush, valuetype System.Drawing.RectangleF[] rects) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillRectangles(System.Drawing.Brush,System.Drawing.RectangleF[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillRectangles(System::Drawing::Brush ^ brush, cli::array &lt;System::Drawing::RectangleF&gt; ^ rects);" />
      <MemberSignature Language="F#" Value="member this.FillRectangles : System.Drawing.Brush * System.Drawing.RectangleF[] -&gt; unit" Usage="graphics.FillRectangles (brush, rects)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="rects" Type="System.Drawing.RectangleF[]" />
      </Parameters>
      <Docs>
        <param name="brush">
          <see cref="T:System.Drawing.Brush" />, der die Merkmale des Füllvorgangs bestimmt.</param>
        <param name="rects">Array von <see cref="T:System.Drawing.RectangleF" />-Strukturen, die die zu füllenden Rechtecke darstellen.</param>
        <summary>Füllt das Innere einer Reihe von Rechtecken, die durch <see cref="T:System.Drawing.RectangleF" />-Strukturen angegeben sind.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgende Aktionen aus:  
  
-   Erstellt einen Pinsel mit blauen Volltonfarbe.  
  
-   Erstellt ein Array mit drei Rechtecken.  
  
-   Füllt die drei rechteckige Bereiche auf dem Bildschirm an.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#116](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#116)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#116](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#116)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#116](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#116)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="brush" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="rects" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="Rects" /> ist ein Array der Länge 0 (null).</exception>
      </Docs>
    </Member>
    <Member MemberName="FillRegion">
      <MemberSignature Language="C#" Value="public void FillRegion (System.Drawing.Brush brush, System.Drawing.Region region);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillRegion(class System.Drawing.Brush brush, class System.Drawing.Region region) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillRegion(System.Drawing.Brush,System.Drawing.Region)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillRegion(System::Drawing::Brush ^ brush, System::Drawing::Region ^ region);" />
      <MemberSignature Language="F#" Value="member this.FillRegion : System.Drawing.Brush * System.Drawing.Region -&gt; unit" Usage="graphics.FillRegion (brush, region)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="region" Type="System.Drawing.Region" />
      </Parameters>
      <Docs>
        <param name="brush">
          <see cref="T:System.Drawing.Brush" />, der die Merkmale des Füllvorgangs bestimmt.</param>
        <param name="region">
          <see cref="T:System.Drawing.Region" />, der den auszufüllenden Bereich darstellt.</param>
        <summary>Füllt das Innere von einem <see cref="T:System.Drawing.Region" /> aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Drawing.Region> besteht aus Rechtecken und Pfaden. Wenn die Region nicht geschlossen ist, wird ein zusätzliches Segment der erste Punkt, um es zu schließen vom letzten Punkt hinzugefügt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgende Aktionen aus:  
  
-   Erstellt einen Pinsel mit blauen Volltonfarbe.  
  
-   Erstellt ein Rechteck.  
  
-   Erstellt einen rechteckigen Bereich an.  
  
-   Füllt den rechteckigen Bereich auf dem Bildschirm an.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#117](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#117)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#117](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#117)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#117](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#117)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="brush" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="region" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Graphics ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Graphics ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="graphics.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einem Objekt Gelegenheit zu dem Versuch, Ressourcen freizugeben und andere Bereinigungen durchzuführen, bevor es von der Garbage Collection freigegeben wird.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Flush">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erzwingt die Ausführung aller ausstehenden Grafikoperationen und wird umgehend beendet, wobei das Abschließen der Operationen nicht abgewartet wird.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Flush();" />
      <MemberSignature Language="F#" Value="member this.Flush : unit -&gt; unit" Usage="graphics.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erzwingt die Ausführung aller ausstehenden Grafikoperationen und wird umgehend beendet, wobei das Abschließen der Operationen nicht abgewartet wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode startet einen Löschvorgang und gibt sofort zurück, ohne zu warten, für jeden aktuell ausgeführten Graphics-Vorgang, um den Vorgang abzuschließen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public void Flush (System.Drawing.Drawing2D.FlushIntention intention);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Flush(valuetype System.Drawing.Drawing2D.FlushIntention intention) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.Flush(System.Drawing.Drawing2D.FlushIntention)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Flush (intention As FlushIntention)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Flush(System::Drawing::Drawing2D::FlushIntention intention);" />
      <MemberSignature Language="F#" Value="member this.Flush : System.Drawing.Drawing2D.FlushIntention -&gt; unit" Usage="graphics.Flush intention" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="intention" Type="System.Drawing.Drawing2D.FlushIntention" />
      </Parameters>
      <Docs>
        <param name="intention">Member der <see cref="T:System.Drawing.Drawing2D.FlushIntention" />-Enumeration, der angibt, ob die Methode sofort beendet oder der Abschluss aller vorhandenen Operationen abgewartet wird.</param>
        <summary>Erzwingt die Ausführung aller ausstehenden Grafikoperationen, wobei angegeben werden kann, ob für das Beenden der Methode auf das Abschließen der Operationen gewartet werden soll.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert <xref:System.Drawing.Drawing2D.FlushIntention.Flush> für die `intention` Parameter gibt an, dass die Methode zurückgeben, sofort nach dem Beginn der Leerung, während ein Wert von <xref:System.Drawing.Drawing2D.FlushIntention.Sync> gibt an, dass vor der Rückgabe die Methode warten, bis zum Abschluss aller vorhandenen Operations.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="FromHdc">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt ein neues <see cref="T:System.Drawing.Graphics" /> aus dem angegebenen Handle für einen Gerätekontext.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FromHdc">
      <MemberSignature Language="C#" Value="public static System.Drawing.Graphics FromHdc (IntPtr hdc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Drawing.Graphics FromHdc(native int hdc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FromHdc(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromHdc (hdc As IntPtr) As Graphics" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Drawing::Graphics ^ FromHdc(IntPtr hdc);" />
      <MemberSignature Language="F#" Value="static member FromHdc : nativeint -&gt; System.Drawing.Graphics" Usage="System.Drawing.Graphics.FromHdc hdc" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netcore-2.1;dotnet-plat-ext-2.1;netcore-2.2">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Graphics</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hdc" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="hdc">Handle für einen Gerätekontext.</param>
        <summary>Erstellt ein neues <see cref="T:System.Drawing.Graphics" /> aus dem angegebenen Handle für einen Gerätekontext.</summary>
        <returns>Diese Methode gibt ein neues <see cref="T:System.Drawing.Graphics" /> für den angegebenen Gerätekontext zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie immer die <xref:System.Drawing.Graphics.Dispose%2A> Methode zum Freigeben der <xref:System.Drawing.Graphics> und zugehörigen Ressourcen erstellt die <xref:System.Drawing.Graphics.FromHdc%2A> Methode.  
  
 Auch wenn das Anzeigegerät ein zugeordnetes ICM-Farbprofil hat [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] nicht dieses Profil standardmäßig verwenden. ICM für Aktivieren einer <xref:System.Drawing.Graphics>, erstellen die <xref:System.Drawing.Graphics> aus einem HDC, nachdem Sie die HDC (und ICM_ON) zum Übergeben der `SetICMMode` Funktion. Und dann alle Zeichnung erreicht, indem die <xref:System.Drawing.Graphics> wird gemäß dem Anzeigegerät zugeordnete ICM Profil angepasst werden. Aktivieren ICM führt zu Leistungseinbußen.  
  
 Rufen Sie den Status des Gerätekontexts (Zuordnungsmodus, logische Einheit und ähnliches) zum Zeitpunkt <xref:System.Drawing.Graphics.FromHdc%2A> kann Rendering durch beeinträchtigen die <xref:System.Drawing.Graphics>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgende Aktionen aus:  
  
-   Erstellt eine Variable des internen Zeiger vom Typ `hdc` und legt es auf das Handle für den Gerätekontext des Graphics-Objekts des Formulars.  
  
-   Erstellt eine neue Grafik mit `hdc`.  
  
-   Zeichnet ein Rechteck mit dem neuen Graphics-Objekt (auf dem Bildschirm).  
  
-   Gibt das neue Grafik-Objekt, mit `hdc`.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#118](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#118)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#118](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#118)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#118](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#118)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromHdc">
      <MemberSignature Language="C#" Value="public static System.Drawing.Graphics FromHdc (IntPtr hdc, IntPtr hdevice);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Drawing.Graphics FromHdc(native int hdc, native int hdevice) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FromHdc(System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromHdc (hdc As IntPtr, hdevice As IntPtr) As Graphics" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Drawing::Graphics ^ FromHdc(IntPtr hdc, IntPtr hdevice);" />
      <MemberSignature Language="F#" Value="static member FromHdc : nativeint * nativeint -&gt; System.Drawing.Graphics" Usage="System.Drawing.Graphics.FromHdc (hdc, hdevice)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netcore-2.1;dotnet-plat-ext-2.1;netcore-2.2">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Graphics</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hdc" Type="System.IntPtr" />
        <Parameter Name="hdevice" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="hdc">Handle für einen Gerätekontext.</param>
        <param name="hdevice">Handle für ein Gerät.</param>
        <summary>Erstellt ein neues <see cref="T:System.Drawing.Graphics" /> aus dem angegebenen Handle für einen Gerätekontext und einem Handle für ein Gerät.</summary>
        <returns>Diese Methode gibt ein neues <see cref="T:System.Drawing.Graphics" /> für den angegebenen Gerätekontext und das angegebene Gerät zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie immer die <xref:System.Drawing.Graphics.Dispose%2A> Methode zum Freigeben der <xref:System.Drawing.Graphics> und zugehörigen Ressourcen erstellt die <xref:System.Drawing.Graphics.FromHdc%2A> Methode.  
  
 Auch wenn das Anzeigegerät ein zugeordnetes ICM-Farbprofil hat [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] nicht dieses Profil standardmäßig verwenden. ICM für Aktivieren einer <xref:System.Drawing.Graphics>, erstellen die <xref:System.Drawing.Graphics> aus einem HDC, nachdem Sie die HDC (und ICM_ON) zum Übergeben der `SetICMMode` Funktion. Und dann alle Zeichnung erreicht, indem die <xref:System.Drawing.Graphics> wird gemäß dem Anzeigegerät zugeordnete ICM Profil angepasst werden. Aktivieren ICM führt zu Leistungseinbußen.  
  
 Rufen Sie den Status des Gerätekontexts (Zuordnungsmodus, logische Einheit und ähnliches) zum Zeitpunkt <xref:System.Drawing.Graphics.FromHdc%2A> kann Rendering durch beeinträchtigen die <xref:System.Drawing.Graphics>.  
  
 Das Handle für die in der Regel können bestimmte Druckerfunktionen Abfrage ermittelt werden.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff von nicht verwaltetem Code. Im Zusammenhang Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="FromHdcInternal">
      <MemberSignature Language="C#" Value="public static System.Drawing.Graphics FromHdcInternal (IntPtr hdc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Drawing.Graphics FromHdcInternal(native int hdc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FromHdcInternal(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromHdcInternal (hdc As IntPtr) As Graphics" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Drawing::Graphics ^ FromHdcInternal(IntPtr hdc);" />
      <MemberSignature Language="F#" Value="static member FromHdcInternal : nativeint -&gt; System.Drawing.Graphics" Usage="System.Drawing.Graphics.FromHdcInternal hdc" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netcore-2.1;dotnet-plat-ext-2.1;netcore-2.2">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Graphics</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hdc" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="hdc">Handle für einen Gerätekontext.</param>
        <summary>Gibt ein <see cref="T:System.Drawing.Graphics" /> für den angegebenen Gerätekontext zurück.</summary>
        <returns>Ein <see cref="T:System.Drawing.Graphics" /> für den angegebenen Gerätekontext.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode sollte nicht verwendet werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromHwnd">
      <MemberSignature Language="C#" Value="public static System.Drawing.Graphics FromHwnd (IntPtr hwnd);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Drawing.Graphics FromHwnd(native int hwnd) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FromHwnd(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromHwnd (hwnd As IntPtr) As Graphics" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Drawing::Graphics ^ FromHwnd(IntPtr hwnd);" />
      <MemberSignature Language="F#" Value="static member FromHwnd : nativeint -&gt; System.Drawing.Graphics" Usage="System.Drawing.Graphics.FromHwnd hwnd" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netcore-2.1;dotnet-plat-ext-2.1;netcore-2.2">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Graphics</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hwnd" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="hwnd">Handle für ein Fenster.</param>
        <summary>Erstellt ein neues <see cref="T:System.Drawing.Graphics" /> aus dem angegebenen Handle für ein Fenster.</summary>
        <returns>Diese Methode gibt ein neues <see cref="T:System.Drawing.Graphics" /> für das angegebene Fensterhandle zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie immer die <xref:System.Drawing.Graphics.Dispose%2A> Methode zum Freigeben der <xref:System.Drawing.Graphics> und zugehörigen Ressourcen erstellt die <xref:System.Drawing.Graphics.FromHwnd%2A> Methode.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler als auch `thisForm`, <xref:System.Windows.Forms.Form> für das Beispiel. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt eine neue Variable für den internen Zeiger `hwnd` und legt es auf das Handle des Beispielformulars fest.  
  
-   Erstellt ein neues <xref:System.Drawing.Graphics> anhand des Handles.  
  
-   Zeichnet ein Rechteck mit dem neuen <xref:System.Drawing.Graphics> mit einem roten Stift.  
  
-   Verwirft das neue <xref:System.Drawing.Graphics>.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#119](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#119)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#119](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#119)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#119](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#119)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff von nicht verwaltetem Code. Im Zusammenhang Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="FromHwndInternal">
      <MemberSignature Language="C#" Value="public static System.Drawing.Graphics FromHwndInternal (IntPtr hwnd);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Drawing.Graphics FromHwndInternal(native int hwnd) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FromHwndInternal(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromHwndInternal (hwnd As IntPtr) As Graphics" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Drawing::Graphics ^ FromHwndInternal(IntPtr hwnd);" />
      <MemberSignature Language="F#" Value="static member FromHwndInternal : nativeint -&gt; System.Drawing.Graphics" Usage="System.Drawing.Graphics.FromHwndInternal hwnd" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netcore-2.1;dotnet-plat-ext-2.1;netcore-2.2">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Graphics</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hwnd" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="hwnd">Handle für ein Fenster.</param>
        <summary>Erstellt ein neues <see cref="T:System.Drawing.Graphics" /> für das angegebene Fensterhandle.</summary>
        <returns>Ein <see cref="T:System.Drawing.Graphics" /> für das angegebene Fensterhandle.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode sollte nicht verwendet werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromImage">
      <MemberSignature Language="C#" Value="public static System.Drawing.Graphics FromImage (System.Drawing.Image image);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Drawing.Graphics FromImage(class System.Drawing.Image image) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FromImage(System.Drawing.Image)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Drawing::Graphics ^ FromImage(System::Drawing::Image ^ image);" />
      <MemberSignature Language="F#" Value="static member FromImage : System.Drawing.Image -&gt; System.Drawing.Graphics" Usage="System.Drawing.Graphics.FromImage image" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Graphics</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
      </Parameters>
      <Docs>
        <param name="image">
          <see cref="T:System.Drawing.Image" />, aus dem das neue <see cref="T:System.Drawing.Graphics" /> erstellt werden soll.</param>
        <summary>Erstellt ein neues <see cref="T:System.Drawing.Graphics" /> aus dem angegebenen <see cref="T:System.Drawing.Image" />.</summary>
        <returns>Diese Methode gibt ein neues <see cref="T:System.Drawing.Graphics" /> für das angegebene <see cref="T:System.Drawing.Image" />-Objekt zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn das Bild ein indiziertes Pixelformat verfügt, löst diese Methode eine Ausnahme mit der Meldung, "ein Graphics-Objekt kann nicht aus einem Image aus, die ein indiziertes Pixelformat erstellt werden." Die indizierte Pixelformate werden in der folgenden Liste angezeigt.  
  
-   <xref:System.Drawing.Imaging.PixelFormat.Format1bppIndexed>  
  
-   <xref:System.Drawing.Imaging.PixelFormat.Format4bppIndexed>  
  
-   <xref:System.Drawing.Imaging.PixelFormat.Format8bppIndexed>  
  
 Sie können das indizierte Bild als ein anderes Format speichern, mithilfe der <xref:System.Drawing.Image.Save%28System.String%2CSystem.Drawing.Imaging.ImageFormat%29> -Methode, und klicken Sie dann Abrufen einer <xref:System.Drawing.Graphics> Objekt für das neue Image.  
  
 Außerdem löst diese Methode eine Ausnahme aus, wenn im Abbild keines der folgenden Pixelformate wird.  
  
-   <xref:System.Drawing.Imaging.PixelFormat.Undefined>  
  
-   <xref:System.Drawing.Imaging.PixelFormat.DontCare>  
  
-   <xref:System.Drawing.Imaging.PixelFormat.Format16bppArgb1555>  
  
-   <xref:System.Drawing.Imaging.PixelFormat.Format16bppGrayScale>  
  
 Rufen Sie immer die <xref:System.Drawing.Graphics.Dispose%2A> Methode zum Freigeben der <xref:System.Drawing.Graphics> und zugehörigen Ressourcen erstellt die <xref:System.Drawing.Graphics.FromImage%2A> Methode.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgende Aktionen aus:  
  
-   Erstellt eine <xref:System.Drawing.Image> von eine SampImag.jpg-Datei im Ordner "Beispiel".  
  
-   Erstellt eine <xref:System.Drawing.Graphics> aus der <xref:System.Drawing.Image>.  
  
-   Ändert das Image durch Ausfüllen eines Rechtecks darin an.  
  
-   Zeichnet die <xref:System.Drawing.Image> auf dem Bildschirm.  
  
-   Gibt das erstellte <xref:System.Drawing.Graphics>.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#120](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#120)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#120](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#120)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#120](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#120)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="image" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Exception">
          <paramref name="image" /> besitzt ein indiziertes Pixelformat, oder sein Format ist nicht definiert.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/737bae30-e599-4e1d-bf30-bab8280b32be">Gewusst wie: Erstellen einer Bitmap zur Laufzeit</related>
        <related type="Article" href="https://msdn.microsoft.com/library/a626d701-bd99-4fd8-b92f-7b8f794e042b">Arbeiten mit Bildern, Bitmaps, Symbolen und Metadateien</related>
        <related type="Article" href="https://msdn.microsoft.com/library/162861f9-f050-445e-8abb-b2c43a918b8b">Gewusst wie: Erstellen von Graphics-Objekten zum Zeichnen</related>
      </Docs>
    </Member>
    <Member MemberName="GetContextInfo">
      <MemberSignature Language="C#" Value="public object GetContextInfo ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetContextInfo() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.GetContextInfo" />
      <MemberSignature Language="VB.NET" Value="Public Function GetContextInfo () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetContextInfo();" />
      <MemberSignature Language="F#" Value="member this.GetContextInfo : unit -&gt; obj" Usage="graphics.GetContextInfo " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netcore-2.1;dotnet-plat-ext-2.1;netcore-2.2">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft den kumulierten Grafikkontext ab.</summary>
        <returns>Ein <see cref="T:System.Object" />, das den kumulierten Grafikkontext darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Rückgabewert ist ein Objektarray, in dem das erste Element enthält die kumulativen Clip-Bereich und das zweite Element enthält die kumulativen übersetzt/Transformationsmatrix.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHalftonePalette">
      <MemberSignature Language="C#" Value="public static IntPtr GetHalftonePalette ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetHalftonePalette() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.GetHalftonePalette" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetHalftonePalette () As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr GetHalftonePalette();" />
      <MemberSignature Language="F#" Value="static member GetHalftonePalette : unit -&gt; nativeint" Usage="System.Drawing.Graphics.GetHalftonePalette " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft ein Handle für die aktuelle Windows-Halbtonpalette ab.</summary>
        <returns>Interner Zeiger, der das Handle für die Palette angibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Zweck der <xref:System.Drawing.Graphics.GetHalftonePalette%2A> Methode besteht darin, aktivieren Sie [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] von eine bessere Qualität bei die Anzeige, 8 Bits pro Pixel verwendet. Um ein Bild mithilfe der Halbtonpalette anzuzeigen, verwenden Sie das folgende Verfahren aus.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Definiert die Interoperabilität <xref:System.Runtime.InteropServices.DllImportAttribute> Attribute für die Windows-DLL-Datei gdi32.dll, enthält die erforderlichen [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] Funktionen.  
  
-   Definiert die `SelectPalette` und `RealizePalette` Funktionen in dieser DLL als extern.  
  
-   Erstellt ein Bild aus einer bestehenden Bilddatei SampImag.jpg (der im gleichen Ordner wie die Beispiel-Codedatei sein muss), und zeichnet das Bild auf dem Bildschirm.  
  
-   Interner Zeigertypvariablen erstellt, und legt deren Werte auf den Ziehpunkt, um das Graphics-Objekt und die aktuelle Windows-Halbtonpalette bzw.  
  
-   Wählt aus, und erkennt, dass die Halbtonpalette ab.  
  
-   Erstellt eine neue Grafik-Objekt, mit der `hdc` Parameter.  
  
-   Zeichnet das Bild erneut an.  
  
-   Gibt das Handle für den Gerätekontext frei.  
  
 Das Ergebnis ist, zwei Darstellungen des Beispielbilds: eine mit der 16-Bit-Palette und eine mit der 8-Bit-Palette.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#121](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#121)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#121](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#121)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#121](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#121)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHdc">
      <MemberSignature Language="C#" Value="public IntPtr GetHdc ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance native int GetHdc() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.GetHdc" />
      <MemberSignature Language="VB.NET" Value="Public Function GetHdc () As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IntPtr GetHdc();" />
      <MemberSignature Language="F#" Value="abstract member GetHdc : unit -&gt; nativeint&#xA;override this.GetHdc : unit -&gt; nativeint" Usage="graphics.GetHdc " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Drawing.IDeviceContext.GetHdc</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft das Handle für den Gerätekontext ab, der diesem <see cref="T:System.Drawing.Graphics" /> zugeordnet ist.</summary>
        <returns>Handle für den Gerätekontext, der diesem <see cref="T:System.Drawing.Graphics" /> zugeordnet ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Gerätekontext ist eine Windows-Struktur, die basierend auf [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] , definiert einen Satz von grafischen Objekten und die zugehörigen Attribute als auch die grafische Modi, die Ausgabe zu beeinflussen. Diese Methode gibt dieser Gerätekontext, mit Ausnahme von einer Schriftart an. Aufruft, weil eine Schriftart nicht ausgewählt ist, um die <xref:System.Drawing.Font.FromHdc%2A> Methode, die mithilfe eines Handles, die von zurückgegeben der <xref:System.Drawing.Graphics.GetHdc%2A> Methode fehl.  
  
 Aufrufe von der <xref:System.Drawing.Graphics.GetHdc%2A> und <xref:System.Drawing.Graphics.ReleaseHdc%2A> Methoden müssen als Paar angezeigt werden. Während des Bereichs einer <xref:System.Drawing.Graphics.GetHdc%2A> und <xref:System.Drawing.Graphics.ReleaseHdc%2A> -Methode bestehenden Methodenpaars, es in der Regel Aufrufe nur [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] Funktionen. In diesem Bereich vorgenommen aufgerufen werden [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] Methoden der <xref:System.Drawing.Graphics> , erzeugt die `hdc` Parameter tritt ein Fehler mit einer `ObjectBusy` Fehler. Darüber hinaus [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] ignoriert alle Zustandsänderungen, die versucht, den <xref:System.Drawing.Graphics> von der `hdc` Parameter in nachfolgenden Vorgängen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Das Beispiel veranschaulicht das Aufrufen einer Windows [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] Funktion führen Sie die gleiche Aufgabe wie eine [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] <xref:System.Drawing.Graphics> Methode. Der Code führt die folgenden Aktionen aus:  
  
-   Definiert die Interoperabilität <xref:System.Runtime.InteropServices.DllImportAttribute> -Attribut für die Windows-DLL-Datei gdi32.dll. Diese DLL enthält die gewünschte [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] Funktion.  
  
-   Definiert die <xref:System.Drawing.Rectangle> Funktion in dieser DLL als extern.  
  
-   Erstellt einen roten Stift.  
  
-   Mit dem Stift Sie zeichnet ein Rechteck mit dem Bildschirm die [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] <xref:System.Drawing.Graphics.DrawRectangle%2A> Methode.  
  
-   Definiert eine Variable des internen Zeiger vom Typ `hdc` und legt dessen Wert auf das Handle für den Gerätekontext des Formulars.  
  
-   Zeichnet ein Rechteck auf dem Bildschirm, wobei die [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] <xref:System.Drawing.Rectangle> Funktion.  
  
-   Gibt den Gerätekontext frei durch dargestellt die `hdc` Parameter.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#122](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#122)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#122](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#122)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#122](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#122)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff von nicht verwaltetem Code. Im Zusammenhang Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetNearestColor">
      <MemberSignature Language="C#" Value="public System.Drawing.Color GetNearestColor (System.Drawing.Color color);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.Color GetNearestColor(valuetype System.Drawing.Color color) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.GetNearestColor(System.Drawing.Color)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::Color GetNearestColor(System::Drawing::Color color);" />
      <MemberSignature Language="F#" Value="member this.GetNearestColor : System.Drawing.Color -&gt; System.Drawing.Color" Usage="graphics.GetNearestColor color" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="color" Type="System.Drawing.Color" />
      </Parameters>
      <Docs>
        <param name="color">
          <see cref="T:System.Drawing.Color" />-Struktur, für die eine Übereinstimmung gesucht werden soll.</param>
        <summary>Ruft die der angegebenen <see cref="T:System.Drawing.Color" />-Struktur nächstgelegene Farbe ab.</summary>
        <returns>Eine <see cref="T:System.Drawing.Color" />-Struktur, die die nächstgelegene Farbe für die durch den <paramref name="color" />-Parameter angegebene Farbe darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt eine willkürlich erstellte Farbe mit über den ARGB-Koordinaten (255, 165, 63, 136).  
  
-   Erstellt einen einfarbigen Pinsel und legt die Farbe auf die angegebene Farbe fest.  
  
-   Füllt eine Ellipse mit dem willkürlich erstellte Farbe an.  
  
-   Erstellt eine zweite Farbe aus, und legt dessen Wert auf das nächste System über den ARGB-Farbe.  
  
-   Füllt eine zweite Ellipse mit dieser Farbe an.  
  
 Das Ergebnis ist, zwei Ellipsen: die erste gezeichnet, die mit beliebigen angegebenen Farbe und das zweite, die mit der Systemfarbe am nächsten liegt der angegebenen Farbe gezeichnet.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#123](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#123)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#123](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#123)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#123](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#123)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InterpolationMode">
      <MemberSignature Language="C#" Value="public System.Drawing.Drawing2D.InterpolationMode InterpolationMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Drawing2D.InterpolationMode InterpolationMode" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Graphics.InterpolationMode" />
      <MemberSignature Language="VB.NET" Value="Public Property InterpolationMode As InterpolationMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Drawing2D::InterpolationMode InterpolationMode { System::Drawing::Drawing2D::InterpolationMode get(); void set(System::Drawing::Drawing2D::InterpolationMode value); };" />
      <MemberSignature Language="F#" Value="member this.InterpolationMode : System.Drawing.Drawing2D.InterpolationMode with get, set" Usage="System.Drawing.Graphics.InterpolationMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Drawing2D.InterpolationMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Interpolationsmodus ab, der diesem <see cref="T:System.Drawing.Graphics" /> zugeordnet ist, oder legt diesen fest.</summary>
        <value>Einer der <see cref="T:System.Drawing.Drawing2D.InterpolationMode" />-Werte.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Interpolationsmodus bestimmt, wie temporäre Werte zwischen zwei Endpunkten berechnet werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IntersectClip">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Aktualisiert den Ausschneidebereich von diesem <see cref="T:System.Drawing.Graphics" /> auf die Schnittmenge des aktuellen Ausschneidebereichs und der angegebenen <see cref="T:System.Drawing.Rectangle" />-Struktur.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IntersectClip">
      <MemberSignature Language="C#" Value="public void IntersectClip (System.Drawing.Rectangle rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void IntersectClip(valuetype System.Drawing.Rectangle rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.IntersectClip(System.Drawing.Rectangle)" />
      <MemberSignature Language="VB.NET" Value="Public Sub IntersectClip (rect As Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void IntersectClip(System::Drawing::Rectangle rect);" />
      <MemberSignature Language="F#" Value="member this.IntersectClip : System.Drawing.Rectangle -&gt; unit" Usage="graphics.IntersectClip rect" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="rect">
          <see cref="T:System.Drawing.Rectangle" />-Struktur, die den aktuellen Ausschneidebereich schneiden soll.</param>
        <summary>Aktualisiert den Ausschneidebereich von diesem <see cref="T:System.Drawing.Graphics" /> auf die Schnittmenge des aktuellen Ausschneidebereichs und der angegebenen <see cref="T:System.Drawing.Rectangle" />-Struktur.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode weist die <xref:System.Drawing.Graphics.Clip%2A> -Eigenschaft dieses <xref:System.Drawing.Graphics> Bereich dargestellt durch die Schnittmenge des aktuellen Ausschneidebereichs und des Rechtecks, die gemäß der `rect` Parameter.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein Rechteck mit der linken oberen Ecke auf (0, 0) und legt den Ausschneidebereich dieses Rechteck.  
  
-   Erstellt ein zweites Rechteck mit der linken oberen Ecke an (100, 100) und legt den Ausschneidebereich auf die Schnittmenge dieses Rechtecks und des aktuellen Ausschneidebereichs (das erste Rechteck).  
  
-   Füllt ein großes Rechteck, das beide vorherigen Rechtecke mit einem Pinsel mit blauer Volltonfarbe enthält.  
  
-   Setzt den Ausschneidebereich auf unendlich zurück.  
  
-   Zeichnet Rechtecke, um die zwei Ausschneidebereiche. Er verwendet einen schwarzen Stift, für das erste Auswahlrechteck und ein roter Stift für den zweiten Ausschneidebereich.  
  
 Das Ergebnis ist, dass nur die Schnittmenge der beiden Rechtecke blau gefüllt ist.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#124](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#124)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#124](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#124)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#124](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#124)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IntersectClip">
      <MemberSignature Language="C#" Value="public void IntersectClip (System.Drawing.RectangleF rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void IntersectClip(valuetype System.Drawing.RectangleF rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.IntersectClip(System.Drawing.RectangleF)" />
      <MemberSignature Language="VB.NET" Value="Public Sub IntersectClip (rect As RectangleF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void IntersectClip(System::Drawing::RectangleF rect);" />
      <MemberSignature Language="F#" Value="member this.IntersectClip : System.Drawing.RectangleF -&gt; unit" Usage="graphics.IntersectClip rect" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.RectangleF" />
      </Parameters>
      <Docs>
        <param name="rect">
          <see cref="T:System.Drawing.RectangleF" />-Struktur, die den aktuellen Ausschneidebereich schneiden soll.</param>
        <summary>Aktualisiert den Ausschneidebereich von diesem <see cref="T:System.Drawing.Graphics" /> auf die Schnittmenge des aktuellen Ausschneidebereichs und der angegebenen <see cref="T:System.Drawing.RectangleF" />-Struktur.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode weist die <xref:System.Drawing.Graphics.Clip%2A> -Eigenschaft dieses <xref:System.Drawing.Graphics> Bereich dargestellt durch die Schnittmenge des aktuellen Ausschneidebereichs und des Rechtecks, die gemäß der `rect` Parameter.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein Rechteck mit der linken oberen Ecke auf (0, 0) und legt den Ausschneidebereich dieses Rechteck.  
  
-   Erstellt ein zweites Rechteck mit der linken oberen Ecke an (100, 100) und legt den Ausschneidebereich auf die Schnittmenge dieses Rechtecks und des aktuellen Ausschneidebereichs (das erste Rechteck).  
  
-   Füllt ein großes Rechteck, das beide vorherigen Rechtecke mit einem Pinsel mit blauer Volltonfarbe enthält.  
  
-   Setzt den Ausschneidebereich auf unendlich zurück.  
  
-   Zeichnet Rechtecke, um die zwei Ausschneidebereiche. Er verwendet einen schwarzen Stift, für das erste Auswahlrechteck und ein roter Stift für den zweiten Ausschneidebereich.  
  
 Das Ergebnis ist, dass nur die Schnittmenge der beiden Rechtecke blau gefüllt ist.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#125](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#125)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#125](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#125)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#125](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#125)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IntersectClip">
      <MemberSignature Language="C#" Value="public void IntersectClip (System.Drawing.Region region);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void IntersectClip(class System.Drawing.Region region) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.IntersectClip(System.Drawing.Region)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void IntersectClip(System::Drawing::Region ^ region);" />
      <MemberSignature Language="F#" Value="member this.IntersectClip : System.Drawing.Region -&gt; unit" Usage="graphics.IntersectClip region" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="region" Type="System.Drawing.Region" />
      </Parameters>
      <Docs>
        <param name="region">
          <see cref="T:System.Drawing.Region" />, dessen Schnittmenge mit dem aktuellen Bereich gebildet werden soll.</param>
        <summary>Aktualisiert den Ausschneidebereich dieses <see cref="T:System.Drawing.Graphics" /> auf die Schnittmenge des aktuellen Ausschneidebereichs und des angegebenen <see cref="T:System.Drawing.Region" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode weist die <xref:System.Drawing.Graphics.Clip%2A> -Eigenschaft dieses <xref:System.Drawing.Graphics> Bereich dargestellt durch die Schnittmenge des aktuellen Ausschneidebereichs und die Region, die gemäß der `region` Parameter.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein Rechteck mit der linken oberen Ecke auf (0, 0).  
  
-   Erstellt einen Bereich und wird auf das Rechteck, und legt den Ausschneidebereich in dieser Region.  
  
-   Erstellt ein zweites Rechteck mit der linken oberen Ecke an (100, 100).  
  
-   Erstellt einen Bereich wird auf das zweite Rechteck und legt den Ausschneidebereich auf die Schnittmenge dieses Bereichs und des aktuellen Ausschneidebereichs (das erste Rechteck), die mit einem Kombinationsmodus von <xref:System.Drawing.Drawing2D.CombineMode.Replace>.  
  
-   Füllt ein großes Rechteck, das beide vorherigen Regionen mit einem Pinsel mit blauer Volltonfarbe enthält.  
  
-   Setzt den Ausschneidebereich auf unendlich zurück.  
  
-   Zeichnet Rechtecke, um die zwei Ausschneidebereiche. Er verwendet einen schwarzen Stift für den ersten Ausschneidebereich und ein roter Stift für den zweiten Ausschneidebereich.  
  
 Das Ergebnis ist, dass nur die Schnittmenge der beiden Regionen blau gefüllt ist.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#126](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#126)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#126](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#126)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#126](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#126)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClipEmpty">
      <MemberSignature Language="C#" Value="public bool IsClipEmpty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClipEmpty" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Graphics.IsClipEmpty" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsClipEmpty As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsClipEmpty { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsClipEmpty : bool" Usage="System.Drawing.Graphics.IsClipEmpty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Ausschneidebereich dieses <see cref="T:System.Drawing.Graphics" /> leer ist.</summary>
        <value>
          <see langword="true" />, falls der Ausschneidebereich dieses <see cref="T:System.Drawing.Graphics" /> leer ist, andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsVisible">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt an, ob der durch ein Koordinatenpaar angegebene Punkt im sichtbaren Ausschneidebereich dieses <see cref="T:System.Drawing.Graphics" /> enthalten ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (System.Drawing.Point point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(valuetype System.Drawing.Point point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.IsVisible(System.Drawing.Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(System::Drawing::Point point);" />
      <MemberSignature Language="F#" Value="member this.IsVisible : System.Drawing.Point -&gt; bool" Usage="graphics.IsVisible point" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="point">
          <see cref="T:System.Drawing.Point" />-Struktur, die auf Sichtbarkeit geprüft werden soll.</param>
        <summary>Gibt an, ob die angegebene <see cref="T:System.Drawing.Point" />-Struktur innerhalb des sichtbaren Ausschneidebereichs dieses <see cref="T:System.Drawing.Graphics" /> enthalten ist.</summary>
        <returns>
          <see langword="true" />, falls der durch den <paramref name="point" />-Parameter angegebene Punkt innerhalb des sichtbaren Ausschneidebereichs dieses <see cref="T:System.Drawing.Graphics" /> enthalten ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen rechteckigen Ausschneidebereich und wird als Ausschneidebereich für das Graphics-Objekt, von dem Formular mithilfe <xref:System.Drawing.Drawing2D.CombineMode.Replace>.  
  
-   Erstellt zwei Punkten, in den Ausschneidebereich und außerhalb.  
  
-   Prüft, jeden der Punkte für die Sichtbarkeit und zeichnet nur den sichtbaren Punkt.  
  
 Das Ergebnis ist eine kleine roten Kreis in der Clip-Bereich.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#127](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#127)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#127](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#127)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#127](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#127)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (System.Drawing.PointF point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(valuetype System.Drawing.PointF point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.IsVisible(System.Drawing.PointF)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsVisible (point As PointF) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(System::Drawing::PointF point);" />
      <MemberSignature Language="F#" Value="member this.IsVisible : System.Drawing.PointF -&gt; bool" Usage="graphics.IsVisible point" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Drawing.PointF" />
      </Parameters>
      <Docs>
        <param name="point">
          <see cref="T:System.Drawing.PointF" />-Struktur, die auf Sichtbarkeit geprüft werden soll.</param>
        <summary>Gibt an, ob die angegebene <see cref="T:System.Drawing.PointF" />-Struktur innerhalb des sichtbaren Ausschneidebereichs dieses <see cref="T:System.Drawing.Graphics" /> enthalten ist.</summary>
        <returns>
          <see langword="true" />, falls der durch den <paramref name="point" />-Parameter angegebene Punkt innerhalb des sichtbaren Ausschneidebereichs dieses <see cref="T:System.Drawing.Graphics" /> enthalten ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen rechteckigen Ausschneidebereich und wird als für die Grafiken des Formulars mithilfe der Ausschneidebereich <xref:System.Drawing.Drawing2D.CombineMode.Replace>.  
  
-   Erstellt zwei Punkten, in den Ausschneidebereich und außerhalb.  
  
-   Prüft, jeden der Punkte für die Sichtbarkeit und zeichnet nur den sichtbaren Punkt.  
  
 Das Ergebnis ist eine kleine roten Kreis in der Clip-Bereich.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#128](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#128)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#128](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#128)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#128](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#128)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (System.Drawing.Rectangle rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(valuetype System.Drawing.Rectangle rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.IsVisible(System.Drawing.Rectangle)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsVisible (rect As Rectangle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(System::Drawing::Rectangle rect);" />
      <MemberSignature Language="F#" Value="member this.IsVisible : System.Drawing.Rectangle -&gt; bool" Usage="graphics.IsVisible rect" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="rect">
          <see cref="T:System.Drawing.Rectangle" />-Struktur, die auf Sichtbarkeit geprüft werden soll.</param>
        <summary>Gibt an, ob das durch eine <see cref="T:System.Drawing.Rectangle" />-Struktur angegebene Rechteck innerhalb des sichtbaren Ausschneidebereichs dieses <see cref="T:System.Drawing.Graphics" /> enthalten ist.</summary>
        <returns>
          <see langword="true" />, falls das durch den <paramref name="rect" />-Parameter angegebene Rechteck innerhalb des sichtbaren Ausschneidebereichs dieses <see cref="T:System.Drawing.Graphics" /> enthalten ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen rechteckigen Ausschneidebereich und wird als Ausschneidebereich für das Graphics-Objekt, von dem Formular mithilfe <xref:System.Drawing.Drawing2D.CombineMode.Replace>.  
  
-   Erstellt den Speicherort und Größe von zwei Rechtecken, eines in den Ausschneidebereich und außerhalb.  
  
-   Prüft alle Rechtecke für die Sichtbarkeit und zeichnet nur den sichtbaren Punkt.  
  
 Das Ergebnis ist ein kleines rotes Rechteck innerhalb des Ausschneidebereichs.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#129](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#129)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#129](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#129)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#129](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#129)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (System.Drawing.RectangleF rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(valuetype System.Drawing.RectangleF rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.IsVisible(System.Drawing.RectangleF)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsVisible (rect As RectangleF) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(System::Drawing::RectangleF rect);" />
      <MemberSignature Language="F#" Value="member this.IsVisible : System.Drawing.RectangleF -&gt; bool" Usage="graphics.IsVisible rect" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.RectangleF" />
      </Parameters>
      <Docs>
        <param name="rect">
          <see cref="T:System.Drawing.RectangleF" />-Struktur, die auf Sichtbarkeit geprüft werden soll.</param>
        <summary>Gibt an, ob das durch eine <see cref="T:System.Drawing.RectangleF" />-Struktur angegebene Rechteck innerhalb des sichtbaren Ausschneidebereichs dieses <see cref="T:System.Drawing.Graphics" /> enthalten ist.</summary>
        <returns>
          <see langword="true" />, falls das durch den <paramref name="rect" />-Parameter angegebene Rechteck innerhalb des sichtbaren Ausschneidebereichs dieses <see cref="T:System.Drawing.Graphics" /> enthalten ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen rechteckigen Ausschneidebereich und wird als Ausschneidebereich für das Graphics-Objekt, von dem Formular mithilfe <xref:System.Drawing.Drawing2D.CombineMode.Replace>.  
  
-   Erstellt zwei Rechtecke, in den Ausschneidebereich und außerhalb.  
  
-   Prüft alle Rechtecke für die Sichtbarkeit und zeichnet nur den sichtbaren Punkt.  
  
 Das Ergebnis ist ein kleines rotes Rechteck innerhalb des Ausschneidebereichs.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#130](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#130)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#130](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#130)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#130](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#130)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (int x, int y);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(int32 x, int32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.IsVisible(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsVisible (x As Integer, y As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(int x, int y);" />
      <MemberSignature Language="F#" Value="member this.IsVisible : int * int -&gt; bool" Usage="graphics.IsVisible (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">Die x-Koordinate des Punkts, der auf Sichtbarkeit getestet werden soll.</param>
        <param name="y">Die y-Koordinate des Punkts, der auf Sichtbarkeit getestet werden soll.</param>
        <summary>Gibt an, ob der durch ein Koordinatenpaar angegebene Punkt im sichtbaren Ausschneidebereich dieses <see cref="T:System.Drawing.Graphics" /> enthalten ist.</summary>
        <returns>
          <see langword="true" />, falls der durch den <paramref name="x" />-Parameter und den <paramref name="y" />-Parameter definierte Punkt innerhalb des sichtbaren Ausschneidebereichs dieses <see cref="T:System.Drawing.Graphics" /> enthalten ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen rechteckigen Ausschneidebereich und wird als Ausschneidebereich für das Graphics-Objekt, von dem Formular mithilfe <xref:System.Drawing.Drawing2D.CombineMode.Replace>.  
  
-   Erstellt zwei Punkten, in den Ausschneidebereich und außerhalb.  
  
-   Prüft, jeden der Punkte für die Sichtbarkeit und zeichnet nur den sichtbaren Punkt.  
  
 Das Ergebnis ist eine kleine roten Kreis in der Clip-Bereich.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#131](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#131)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#131](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#131)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#131](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#131)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (float x, float y);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(float32 x, float32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.IsVisible(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsVisible (x As Single, y As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(float x, float y);" />
      <MemberSignature Language="F#" Value="member this.IsVisible : single * single -&gt; bool" Usage="graphics.IsVisible (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Die x-Koordinate des Punkts, der auf Sichtbarkeit getestet werden soll.</param>
        <param name="y">Die y-Koordinate des Punkts, der auf Sichtbarkeit getestet werden soll.</param>
        <summary>Gibt an, ob der durch ein Koordinatenpaar angegebene Punkt im sichtbaren Ausschneidebereich dieses <see cref="T:System.Drawing.Graphics" /> enthalten ist.</summary>
        <returns>
          <see langword="true" />, falls der durch den <paramref name="x" />-Parameter und den <paramref name="y" />-Parameter definierte Punkt innerhalb des sichtbaren Ausschneidebereichs dieses <see cref="T:System.Drawing.Graphics" /> enthalten ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen rechteckigen Ausschneidebereich und wird als Ausschneidebereich für das Graphics-Objekt, von dem Formular mithilfe <xref:System.Drawing.Drawing2D.CombineMode.Replace>.  
  
-   Erstellt zwei Punkten, in den Ausschneidebereich und außerhalb.  
  
-   Prüft, jeden der Punkte für die Sichtbarkeit und zeichnet nur den sichtbaren Punkt.  
  
 Das Ergebnis ist eine kleine roten Kreis in der Clip-Bereich.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#133](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#133)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#133](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#133)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#133](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#133)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (int x, int y, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(int32 x, int32 y, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.IsVisible(System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsVisible (x As Integer, y As Integer, width As Integer, height As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(int x, int y, int width, int height);" />
      <MemberSignature Language="F#" Value="member this.IsVisible : int * int * int * int -&gt; bool" Usage="graphics.IsVisible (x, y, width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">Die x-Koordinate der oberen linken Ecke des Rechtecks, das auf Sichtbarkeit getestet werden soll.</param>
        <param name="y">Die y-Koordinate der oberen linken Ecke des Rechtecks, das auf Sichtbarkeit getestet werden soll.</param>
        <param name="width">Breite des Rechtecks, das auf Sichtbarkeit getestet werden soll.</param>
        <param name="height">Höhe des Rechtecks, das auf Sichtbarkeit getestet werden soll.</param>
        <summary>Gibt an, ob das Rechteck, das durch ein Koordinatenpaar, eine Breite und eine Höhe angegeben wird, im sichtbaren Ausschneidebereich dieses <see cref="T:System.Drawing.Graphics" /> enthalten ist.</summary>
        <returns>
          <see langword="true" />, falls das durch die Parameter <paramref name="x" />, <paramref name="y" />, <paramref name="width" /> und <paramref name="height" /> definierte Rechteck innerhalb des sichtbaren Ausschneidebereichs dieses <see cref="T:System.Drawing.Graphics" /> enthalten ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen rechteckigen Ausschneidebereich und wird als Ausschneidebereich für das Graphics-Objekt, von dem Formular mithilfe <xref:System.Drawing.Drawing2D.CombineMode.Replace>.  
  
-   Erstellt den Speicherort und Größe von zwei Rechtecken, eines in den Ausschneidebereich und außerhalb.  
  
-   Prüft alle Rechtecke für die Sichtbarkeit und zeichnet nur den sichtbaren Punkt.  
  
 Das Ergebnis ist ein kleines rotes Rechteck innerhalb des Ausschneidebereichs.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#132](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#132)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#132](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#132)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#132](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#132)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (float x, float y, float width, float height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(float32 x, float32 y, float32 width, float32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.IsVisible(System.Single,System.Single,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsVisible (x As Single, y As Single, width As Single, height As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(float x, float y, float width, float height);" />
      <MemberSignature Language="F#" Value="member this.IsVisible : single * single * single * single -&gt; bool" Usage="graphics.IsVisible (x, y, width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="width" Type="System.Single" />
        <Parameter Name="height" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Die x-Koordinate der oberen linken Ecke des Rechtecks, das auf Sichtbarkeit getestet werden soll.</param>
        <param name="y">Die y-Koordinate der oberen linken Ecke des Rechtecks, das auf Sichtbarkeit getestet werden soll.</param>
        <param name="width">Breite des Rechtecks, das auf Sichtbarkeit getestet werden soll.</param>
        <param name="height">Höhe des Rechtecks, das auf Sichtbarkeit getestet werden soll.</param>
        <summary>Gibt an, ob das Rechteck, das durch ein Koordinatenpaar, eine Breite und eine Höhe angegeben wird, im sichtbaren Ausschneidebereich dieses <see cref="T:System.Drawing.Graphics" /> enthalten ist.</summary>
        <returns>
          <see langword="true" />, falls das durch die Parameter <paramref name="x" />, <paramref name="y" />, <paramref name="width" /> und <paramref name="height" /> definierte Rechteck innerhalb des sichtbaren Ausschneidebereichs dieses <see cref="T:System.Drawing.Graphics" /> enthalten ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen rechteckigen Ausschneidebereich und wird als Ausschneidebereich für das Graphics-Objekt, von dem Formular mithilfe <xref:System.Drawing.Drawing2D.CombineMode.Replace>.  
  
-   Erstellt den Speicherort und Größe von zwei Rechtecken, eines in den Ausschneidebereich und außerhalb.  
  
-   Prüft alle Rechtecke für die Sichtbarkeit und zeichnet nur den sichtbaren Punkt.  
  
 Das Ergebnis ist ein kleines rotes Rechteck innerhalb des Ausschneidebereichs.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#134](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#134)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#134](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#134)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#134](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#134)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisibleClipEmpty">
      <MemberSignature Language="C#" Value="public bool IsVisibleClipEmpty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVisibleClipEmpty" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Graphics.IsVisibleClipEmpty" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsVisibleClipEmpty As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsVisibleClipEmpty { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsVisibleClipEmpty : bool" Usage="System.Drawing.Graphics.IsVisibleClipEmpty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der sichtbare Ausschneidebereich dieses <see cref="T:System.Drawing.Graphics" /> leer ist.</summary>
        <value>
          <see langword="true" />, falls der sichtbare Teil des Ausschneidebereichs dieses <see cref="T:System.Drawing.Graphics" /> leer ist; andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der sichtbare Ausschneidebereich ist die Schnittmenge der Ausschneidebereich dieses `Graphics` und den Ausschneidebereich des Fensters.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MeasureCharacterRanges">
      <MemberSignature Language="C#" Value="public System.Drawing.Region[] MeasureCharacterRanges (string text, System.Drawing.Font font, System.Drawing.RectangleF layoutRect, System.Drawing.StringFormat stringFormat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Drawing.Region[] MeasureCharacterRanges(string text, class System.Drawing.Font font, valuetype System.Drawing.RectangleF layoutRect, class System.Drawing.StringFormat stringFormat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.MeasureCharacterRanges(System.String,System.Drawing.Font,System.Drawing.RectangleF,System.Drawing.StringFormat)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Drawing::Region ^&gt; ^ MeasureCharacterRanges(System::String ^ text, System::Drawing::Font ^ font, System::Drawing::RectangleF layoutRect, System::Drawing::StringFormat ^ stringFormat);" />
      <MemberSignature Language="F#" Value="member this.MeasureCharacterRanges : string * System.Drawing.Font * System.Drawing.RectangleF * System.Drawing.StringFormat -&gt; System.Drawing.Region[]" Usage="graphics.MeasureCharacterRanges (text, font, layoutRect, stringFormat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Region[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="font" Type="System.Drawing.Font" />
        <Parameter Name="layoutRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="stringFormat" Type="System.Drawing.StringFormat" />
      </Parameters>
      <Docs>
        <param name="text">Zu messende Zeichenfolge.</param>
        <param name="font">
          <see cref="T:System.Drawing.Font" />, die das Textformat der Zeichenfolge definiert.</param>
        <param name="layoutRect">
          <see cref="T:System.Drawing.RectangleF" />-Struktur, die das Layoutrechteck für die Zeichenfolge angibt.</param>
        <param name="stringFormat">
          <see cref="T:System.Drawing.StringFormat" />, das Formatierungsinformationen für die Zeichenfolge darstellt, z. B. Zeilenabstand.</param>
        <summary>Ruft ein Array von <see cref="T:System.Drawing.Region" />-Objekten ab, von denen jedes einen Bereich von Zeichenpositionen in der angegebenen Zeichenfolge umschließt.</summary>
        <returns>Diese Methode gibt ein Array von <see cref="T:System.Drawing.Region" />-Objekten zurück, von denen jedes einen Bereich von Zeichenpositionen in der angegebenen Zeichenfolge umschließt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Regionen, die von dieser Methode zurückgegebene hängen von der Auflösung ab, daher gibt es möglicherweise eine leichte Verlust der Genauigkeit sein, wenn Zeichenfolgen in einer Metadatei mit einer Auflösung aufgezeichnet und später mit einer anderen Auflösung wiedergegeben werden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Legt eine Zeichenfolge "erste und zweite Ranges" und eine Schriftart zur Anzeige der Zeichenfolge ("Times New Roman", 16 Punkt).  
  
-   Legt zwei Zeichenbereiche innerhalb der Zeichenfolge (die die Wörter "First" und "Second" entsprechen).  
  
-   Erstellt ein Rechteck, in dem die Zeichenfolge angezeigt.  
  
-   Legt die Formatierung der Zeichenfolge – einschließlich der Verwendung der beiden Zeichenbereiche.  
  
-   Zeichnet die Zeichenfolge auf dem Bildschirm an.  
  
-   Misst die Zeichenbereiche ein, und bestimmt die Rechtecke, die die beiden angegebenen Bereiche gebunden.  
  
-   Zeichnet die zwei Rechtecke auf dem Bildschirm an.  
  
 Das Ergebnis ist die Zeichenfolge, die mit dem ersten Bereich ("First") begrenzt durch ein rotes Rechteck und der zweite Bereich ("Second") begrenzt durch ein blaues Rechteck angezeigt.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#135](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#135)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#135](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#135)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#135](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#135)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Drawing.Graphics.MeasureString(System.String,System.Drawing.Font)" />
        <altmember cref="M:System.Windows.Forms.TextRenderer.MeasureText(System.Drawing.IDeviceContext,System.String,System.Drawing.Font,System.Drawing.Size,System.Windows.Forms.TextFormatFlags)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="MeasureString">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Misst die angegebene Zeichenfolge, wenn diese mit der angegebenen <see cref="T:System.Drawing.Font" /> gezeichnet wird.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MeasureString">
      <MemberSignature Language="C#" Value="public System.Drawing.SizeF MeasureString (string text, System.Drawing.Font font);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.SizeF MeasureString(string text, class System.Drawing.Font font) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.MeasureString(System.String,System.Drawing.Font)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::SizeF MeasureString(System::String ^ text, System::Drawing::Font ^ font);" />
      <MemberSignature Language="F#" Value="member this.MeasureString : string * System.Drawing.Font -&gt; System.Drawing.SizeF" Usage="graphics.MeasureString (text, font)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="font" Type="System.Drawing.Font" />
      </Parameters>
      <Docs>
        <param name="text">Zu messende Zeichenfolge.</param>
        <param name="font">
          <see cref="T:System.Drawing.Font" />, die das Textformat der Zeichenfolge definiert.</param>
        <summary>Misst die angegebene Zeichenfolge, wenn diese mit der angegebenen <see cref="T:System.Drawing.Font" /> gezeichnet wird.</summary>
        <returns>Diese Methode gibt eine <see cref="T:System.Drawing.SizeF" />-Struktur zurück, die die Größe der durch den <paramref name="text" />-Parameter angegebenen Zeichenfolge in der durch die <see cref="P:System.Drawing.Graphics.PageUnit" />-Eigenschaft angegebenen Einheit darstellt, wenn diese mit dem <paramref name="font" />-Parameter gezeichnet wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Drawing.Graphics.MeasureString%2A> Methode dient, für die Verwendung mit einzelnen Zeichenfolgen und eine kleine Menge zusätzlicher Speicherplatz enthält, vor und nach der Zeichenfolge für überhängende Symbole. Darüber hinaus die <xref:System.Drawing.Graphics.DrawString%2A> Methode passt die Glyphe zum Optimieren Anzeigequalität und kann eine Zeichenfolge, die kleiner sind, als von gemeldeten anzeigen <xref:System.Drawing.Graphics.MeasureString%2A>. Verwenden Sie zum Abrufen von Metriken für angrenzende Zeichenfolgen im Layout (z. B. bei der Implementierung von formatiertem Text) der <xref:System.Drawing.Graphics.MeasureCharacterRanges%2A> Methode oder eines der <xref:System.Drawing.Graphics.MeasureString%2A> -Methoden, eine <xref:System.Drawing.StringFormat>, und übergeben Sie <xref:System.Drawing.StringFormat.GenericTypographic%2A>. Stellen Sie außerdem sicher die <xref:System.Drawing.Graphics.TextRenderingHint%2A> für die <xref:System.Drawing.Graphics> ist <xref:System.Drawing.Text.TextRenderingHint.AntiAlias>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt eine zu messende Zeichenfolge.  
  
-   Erstellt ein Schriftartobjekt und wird auf Arial (16 Punkt).  
  
-   Erstellt ein Größenobjekt für die und verwendet es und das Font-Objekt, um die Größe der Zeichenfolge zu messen.  
  
-   Zeichnet ein rotes Rechteck in der gemessenen Größe der Zeichenfolge.  
  
-   Zeichnet die Zeichenfolge innerhalb des Rechtecks gezeichnet.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#136](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#136)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#136](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#136)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#136](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#136)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="font" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Forms.TextRenderer.MeasureText(System.Drawing.IDeviceContext,System.String,System.Drawing.Font,System.Drawing.Size,System.Windows.Forms.TextFormatFlags)" />
        <altmember cref="M:System.Drawing.Graphics.MeasureCharacterRanges(System.String,System.Drawing.Font,System.Drawing.RectangleF,System.Drawing.StringFormat)" />
        <related type="Article" href="~/docs/framework/winforms/advanced/using-fonts-and-text.md">Verwenden von Schriftarten und Text</related>
      </Docs>
    </Member>
    <Member MemberName="MeasureString">
      <MemberSignature Language="C#" Value="public System.Drawing.SizeF MeasureString (string text, System.Drawing.Font font, System.Drawing.SizeF layoutArea);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.SizeF MeasureString(string text, class System.Drawing.Font font, valuetype System.Drawing.SizeF layoutArea) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.MeasureString(System.String,System.Drawing.Font,System.Drawing.SizeF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::SizeF MeasureString(System::String ^ text, System::Drawing::Font ^ font, System::Drawing::SizeF layoutArea);" />
      <MemberSignature Language="F#" Value="member this.MeasureString : string * System.Drawing.Font * System.Drawing.SizeF -&gt; System.Drawing.SizeF" Usage="graphics.MeasureString (text, font, layoutArea)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="font" Type="System.Drawing.Font" />
        <Parameter Name="layoutArea" Type="System.Drawing.SizeF" />
      </Parameters>
      <Docs>
        <param name="text">Zu messende Zeichenfolge.</param>
        <param name="font">
          <see cref="T:System.Drawing.Font" />, die das Textformat der Zeichenfolge definiert.</param>
        <param name="layoutArea">
          <see cref="T:System.Drawing.SizeF" />-Struktur, die den maximalen Layoutbereich für den Text angibt.</param>
        <summary>Misst die angegebene Zeichenfolge, wenn diese mit der angegebenen <see cref="T:System.Drawing.Font" /> innerhalb des angegebenen Layoutbereichs gezeichnet wird.</summary>
        <returns>Diese Methode gibt eine <see cref="T:System.Drawing.SizeF" />-Struktur zurück, die die Größe der durch den <paramref name="text" />-Parameter angegebenen Zeichenfolge in der durch die <see cref="P:System.Drawing.Graphics.PageUnit" />-Eigenschaft angegebenen Einheit darstellt, wenn diese mit dem <paramref name="font" />-Parameter gezeichnet wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Drawing.Graphics.MeasureString%2A> Methode dient, für die Verwendung mit einzelnen Zeichenfolgen und eine kleine Menge zusätzlicher Speicherplatz enthält, vor und nach der Zeichenfolge für überhängende Symbole. Darüber hinaus die <xref:System.Drawing.Graphics.DrawString%2A> Methode passt die Glyphe zum Optimieren Anzeigequalität und kann eine Zeichenfolge, die kleiner sind, als von gemeldeten anzeigen <xref:System.Drawing.Graphics.MeasureString%2A>. Verwenden Sie zum Abrufen von Metriken für angrenzende Zeichenfolgen im Layout (z. B. bei der Implementierung von formatiertem Text) der <xref:System.Drawing.Graphics.MeasureCharacterRanges%2A> Methode oder eines der <xref:System.Drawing.Graphics.MeasureString%2A> -Methoden, eine <xref:System.Drawing.StringFormat>, und übergeben Sie <xref:System.Drawing.StringFormat.GenericTypographic%2A>. Stellen Sie außerdem sicher die <xref:System.Drawing.Graphics.TextRenderingHint%2A> für die <xref:System.Drawing.Graphics> ist <xref:System.Drawing.Text.TextRenderingHint.AntiAlias>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt eine zu messende Zeichenfolge und ein Schriftartobjekt auf Arial (16 Punkt) festgelegt.  
  
-   Legt die maximale Layoutgröße der Zeichenfolge fest.  
  
-   Erstellt ein Größenobjekt für die und, das Schriftartobjekt und die maximale Layoutgröße verwendet, um die Größe der Zeichenfolge zu messen.  
  
-   Zeichnet ein rotes Rechteck in der gemessenen Größe der Zeichenfolge.  
  
-   Zeichnet die Zeichenfolge innerhalb des Rechtecks gezeichnet.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#138](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#138)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#138](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#138)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#138](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#138)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="font" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Forms.TextRenderer.MeasureText(System.Drawing.IDeviceContext,System.String,System.Drawing.Font,System.Drawing.Size,System.Windows.Forms.TextFormatFlags)" />
        <altmember cref="M:System.Drawing.Graphics.MeasureCharacterRanges(System.String,System.Drawing.Font,System.Drawing.RectangleF,System.Drawing.StringFormat)" />
        <related type="Article" href="~/docs/framework/winforms/advanced/using-fonts-and-text.md">Verwenden von Schriftarten und Text</related>
      </Docs>
    </Member>
    <Member MemberName="MeasureString">
      <MemberSignature Language="C#" Value="public System.Drawing.SizeF MeasureString (string text, System.Drawing.Font font, int width);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.SizeF MeasureString(string text, class System.Drawing.Font font, int32 width) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.MeasureString(System.String,System.Drawing.Font,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::SizeF MeasureString(System::String ^ text, System::Drawing::Font ^ font, int width);" />
      <MemberSignature Language="F#" Value="member this.MeasureString : string * System.Drawing.Font * int -&gt; System.Drawing.SizeF" Usage="graphics.MeasureString (text, font, width)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="font" Type="System.Drawing.Font" />
        <Parameter Name="width" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="text">Zu messende Zeichenfolge.</param>
        <param name="font">
          <see cref="T:System.Drawing.Font" />, die das Format der Zeichenfolge definiert.</param>
        <param name="width">Maximale Breite der Zeichenfolge in Pixel.</param>
        <summary>Misst die angegebene Zeichenfolge, wenn diese mit der angegebenen <see cref="T:System.Drawing.Font" /> gezeichnet wird.</summary>
        <returns>Diese Methode gibt eine <see cref="T:System.Drawing.SizeF" />-Struktur zurück, die die Größe der durch den <paramref name="text" />-Parameter angegebenen Zeichenfolge in der durch die <see cref="P:System.Drawing.Graphics.PageUnit" />-Eigenschaft angegebenen Einheit darstellt, wenn diese mit dem <paramref name="font" />-Parameter gezeichnet wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `width` Parameter gibt den maximalen Wert für die Breitenkomponente der zurückgegebenen <xref:System.Drawing.SizeF> Struktur (<xref:System.Drawing.SizeF.Width%2A>). Wenn die `width` -Parameter ist kleiner als die tatsächliche Breite der Zeichenfolge, die zurückgegebene <xref:System.Drawing.SizeF.Width%2A> Komponente wird auf einen Wert für die maximale Anzahl von Zeichen, die in die angegebene Breite passen abgeschnitten. Für die gesamte Zeichenfolge, die zurückgegebene <xref:System.Drawing.SizeF.Height%2A> Komponente wird angepasst, um ein Wert, der Anzeige der Zeichenfolge mit einem Zeilenumbruch ermöglicht.  
  
 Die <xref:System.Drawing.Graphics.MeasureString%2A> Methode dient, für die Verwendung mit einzelnen Zeichenfolgen und eine kleine Menge zusätzlicher Speicherplatz enthält, vor und nach der Zeichenfolge für überhängende Symbole. Darüber hinaus die <xref:System.Drawing.Graphics.DrawString%2A> Methode passt die Glyphe zum Optimieren Anzeigequalität und kann eine Zeichenfolge, die kleiner sind, als von gemeldeten anzeigen <xref:System.Drawing.Graphics.MeasureString%2A>. Verwenden Sie zum Abrufen von Metriken für angrenzende Zeichenfolgen im Layout (z. B. bei der Implementierung von formatiertem Text) der <xref:System.Drawing.Graphics.MeasureCharacterRanges%2A> Methode oder eines der <xref:System.Drawing.Graphics.MeasureString%2A> -Methoden, eine <xref:System.Drawing.StringFormat>, und übergeben Sie <xref:System.Drawing.StringFormat.GenericTypographic%2A>. Stellen Sie außerdem sicher die <xref:System.Drawing.Graphics.TextRenderingHint%2A> für die <xref:System.Drawing.Graphics> ist <xref:System.Drawing.Text.TextRenderingHint.AntiAlias>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt eine zu messende Zeichenfolge und ein Schriftartobjekt auf Arial (16 Punkt) festgelegt.  
  
-   Legt die maximale Breite der Zeichenfolge fest.  
  
-   Erstellt ein Größenobjekt für die und verwendet, das Schriftartobjekt und die maximale Breite der Größe der Zeichenfolge zu messen.  
  
-   Zeichnet ein rotes Rechteck in der gemessenen Größe der Zeichenfolge.  
  
-   Zeichnet die Zeichenfolge innerhalb des Rechtecks gezeichnet.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#141](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#141)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#141](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#141)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#141](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#141)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="font" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Forms.TextRenderer.MeasureText(System.Drawing.IDeviceContext,System.String,System.Drawing.Font,System.Drawing.Size,System.Windows.Forms.TextFormatFlags)" />
        <altmember cref="M:System.Drawing.Graphics.MeasureCharacterRanges(System.String,System.Drawing.Font,System.Drawing.RectangleF,System.Drawing.StringFormat)" />
        <related type="Article" href="~/docs/framework/winforms/advanced/using-fonts-and-text.md">Verwenden von Schriftarten und Text</related>
      </Docs>
    </Member>
    <Member MemberName="MeasureString">
      <MemberSignature Language="C#" Value="public System.Drawing.SizeF MeasureString (string text, System.Drawing.Font font, System.Drawing.PointF origin, System.Drawing.StringFormat stringFormat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.SizeF MeasureString(string text, class System.Drawing.Font font, valuetype System.Drawing.PointF origin, class System.Drawing.StringFormat stringFormat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.MeasureString(System.String,System.Drawing.Font,System.Drawing.PointF,System.Drawing.StringFormat)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::SizeF MeasureString(System::String ^ text, System::Drawing::Font ^ font, System::Drawing::PointF origin, System::Drawing::StringFormat ^ stringFormat);" />
      <MemberSignature Language="F#" Value="member this.MeasureString : string * System.Drawing.Font * System.Drawing.PointF * System.Drawing.StringFormat -&gt; System.Drawing.SizeF" Usage="graphics.MeasureString (text, font, origin, stringFormat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="font" Type="System.Drawing.Font" />
        <Parameter Name="origin" Type="System.Drawing.PointF" />
        <Parameter Name="stringFormat" Type="System.Drawing.StringFormat" />
      </Parameters>
      <Docs>
        <param name="text">Zu messende Zeichenfolge.</param>
        <param name="font">
          <see cref="T:System.Drawing.Font" />, die das Textformat der Zeichenfolge definiert.</param>
        <param name="origin">
          <see cref="T:System.Drawing.PointF" />-Struktur, die die obere linke Ecke der Zeichenfolge darstellt.</param>
        <param name="stringFormat">
          <see cref="T:System.Drawing.StringFormat" />, das Formatierungsinformationen für die Zeichenfolge darstellt, z. B. Zeilenabstand.</param>
        <summary>Misst die angegebene Zeichenfolge, wenn diese mit der angegebenen <see cref="T:System.Drawing.Font" /> gezeichnet und mit dem angegebenen <see cref="T:System.Drawing.StringFormat" /> formatiert wird.</summary>
        <returns>Diese Methode gibt eine <see cref="T:System.Drawing.SizeF" />-Struktur zurück, die die Größe der durch den <paramref name="text" />-Parameter angegebenen Zeichenfolge in der durch die <see cref="P:System.Drawing.Graphics.PageUnit" />-Eigenschaft angegebenen Einheit darstellt, wenn diese mit dem <paramref name="font" />-Parameter und dem <paramref name="stringFormat" />-Parameter gezeichnet wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Drawing.Graphics.MeasureString%2A> Methode dient, für die Verwendung mit einzelnen Zeichenfolgen und eine kleine Menge zusätzlicher Speicherplatz enthält, vor und nach der Zeichenfolge für überhängende Symbole. Darüber hinaus die <xref:System.Drawing.Graphics.DrawString%2A> Methode passt die Glyphe zum Optimieren Anzeigequalität und kann eine Zeichenfolge, die kleiner sind, als von gemeldeten anzeigen <xref:System.Drawing.Graphics.MeasureString%2A>. Verwenden Sie zum Abrufen von Metriken für angrenzende Zeichenfolgen im Layout (z. B. bei der Implementierung von formatiertem Text) der <xref:System.Drawing.Graphics.MeasureCharacterRanges%2A> Methode oder eines der <xref:System.Drawing.Graphics.MeasureString%2A> -Methoden, eine <xref:System.Drawing.StringFormat>, und übergeben Sie <xref:System.Drawing.StringFormat.GenericTypographic%2A>. Stellen Sie außerdem sicher die <xref:System.Drawing.Graphics.TextRenderingHint%2A> für die <xref:System.Drawing.Graphics> ist <xref:System.Drawing.Text.TextRenderingHint.AntiAlias>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt eine zu messende Zeichenfolge und ein Schriftartobjekt auf Arial (16 Punkt) festgelegt  
  
-   Erstellt einen Punkt der oberen linken Ecke der Zeichenfolge zu suchen.  
  
-   Erstellt ein Zeichenfolgenobjekt, das Format und legt die Formatflags auf <xref:System.Drawing.StringFormatFlags.DirectionVertical>.  
  
-   Erstellt ein Größenobjekt, um die Zeichenfolge zu messen.  
  
-   Misst die Größe der Zeichenfolge ist, verwenden die Zeichenfolge, das Font-Objekt, das Suchen von Punkt und das Format der Zeichenfolge.  
  
-   Zeichnet ein rotes Rechteck mit dem Product Punkt und der gemessenen Größe der Zeichenfolge.  
  
-   Zeichnet die Zeichenfolge innerhalb des Rechtecks gezeichnet.  
  
 Das Ergebnis ist ein vertikales Rechteck, das eine vertikale Zeichenfolge.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#137](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#137)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#137](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#137)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#137](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#137)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="font" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Forms.TextRenderer.MeasureText(System.Drawing.IDeviceContext,System.String,System.Drawing.Font,System.Drawing.Size,System.Windows.Forms.TextFormatFlags)" />
        <altmember cref="M:System.Drawing.Graphics.MeasureCharacterRanges(System.String,System.Drawing.Font,System.Drawing.RectangleF,System.Drawing.StringFormat)" />
        <related type="Article" href="~/docs/framework/winforms/advanced/using-fonts-and-text.md">Verwenden von Schriftarten und Text</related>
      </Docs>
    </Member>
    <Member MemberName="MeasureString">
      <MemberSignature Language="C#" Value="public System.Drawing.SizeF MeasureString (string text, System.Drawing.Font font, System.Drawing.SizeF layoutArea, System.Drawing.StringFormat stringFormat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.SizeF MeasureString(string text, class System.Drawing.Font font, valuetype System.Drawing.SizeF layoutArea, class System.Drawing.StringFormat stringFormat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.MeasureString(System.String,System.Drawing.Font,System.Drawing.SizeF,System.Drawing.StringFormat)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::SizeF MeasureString(System::String ^ text, System::Drawing::Font ^ font, System::Drawing::SizeF layoutArea, System::Drawing::StringFormat ^ stringFormat);" />
      <MemberSignature Language="F#" Value="member this.MeasureString : string * System.Drawing.Font * System.Drawing.SizeF * System.Drawing.StringFormat -&gt; System.Drawing.SizeF" Usage="graphics.MeasureString (text, font, layoutArea, stringFormat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="font" Type="System.Drawing.Font" />
        <Parameter Name="layoutArea" Type="System.Drawing.SizeF" />
        <Parameter Name="stringFormat" Type="System.Drawing.StringFormat" />
      </Parameters>
      <Docs>
        <param name="text">Zu messende Zeichenfolge.</param>
        <param name="font">
          <see cref="T:System.Drawing.Font" />, die das Textformat der Zeichenfolge definiert.</param>
        <param name="layoutArea">
          <see cref="T:System.Drawing.SizeF" />-Struktur, die den maximalen Layoutbereich für den Text angibt.</param>
        <param name="stringFormat">
          <see cref="T:System.Drawing.StringFormat" />, das Formatierungsinformationen für die Zeichenfolge darstellt, z. B. Zeilenabstand.</param>
        <summary>Misst die angegebene Zeichenfolge, wenn diese mit der angegebenen <see cref="T:System.Drawing.Font" /> gezeichnet und mit dem angegebenen <see cref="T:System.Drawing.StringFormat" /> formatiert wird.</summary>
        <returns>Diese Methode gibt eine <see cref="T:System.Drawing.SizeF" />-Struktur zurück, die die Größe der durch den <paramref name="text" />-Parameter angegebenen Zeichenfolge in der durch die<see cref="P:System.Drawing.Graphics.PageUnit" />-Eigenschaft angegebenen Einheit darstellt, wenn diese mit dem <paramref name="font" />-Parameter und dem <paramref name="stringFormat" />-Parameter gezeichnet wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Drawing.Graphics.MeasureString%2A> Methode dient, für die Verwendung mit einzelnen Zeichenfolgen und eine kleine Menge zusätzlicher Speicherplatz enthält, vor und nach der Zeichenfolge für überhängende Symbole. Darüber hinaus die <xref:System.Drawing.Graphics.DrawString%2A> Methode passt die Glyphe zum Optimieren Anzeigequalität und kann eine Zeichenfolge, die kleiner sind, als von gemeldeten anzeigen <xref:System.Drawing.Graphics.MeasureString%2A>. Verwenden Sie zum Abrufen von Metriken für angrenzende Zeichenfolgen im Layout (z. B. bei der Implementierung von formatiertem Text) der <xref:System.Drawing.Graphics.MeasureCharacterRanges%2A> Methode oder eines der <xref:System.Drawing.Graphics.MeasureString%2A> -Methoden, eine <xref:System.Drawing.StringFormat>, und übergeben Sie <xref:System.Drawing.StringFormat.GenericTypographic%2A>. Stellen Sie außerdem sicher die <xref:System.Drawing.Graphics.TextRenderingHint%2A> für die <xref:System.Drawing.Graphics> ist <xref:System.Drawing.Text.TextRenderingHint.AntiAlias>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt eine zu messende Zeichenfolge und ein Schriftartobjekt auf Arial (16 Punkt) festgelegt.  
  
-   Legt die maximale Layoutgröße der Zeichenfolge ist, erstellen eine Größenobjekt, um die Zeichenfolge zu messen.  
  
-   Erstellt ein Zeichenfolgenobjekt, das Format und legt die Formatflags auf <xref:System.Drawing.StringFormatFlags.DirectionVertical>.  
  
-   Misst die Größe der Zeichenfolge ist, verwenden die Zeichenfolge, die Schriftartobjekt, die maximale Layoutgröße und das Format der Zeichenfolge.  
  
-   Zeichnet ein rotes Rechteck in der gemessenen Größe der Zeichenfolge.  
  
-   Zeichnet die Zeichenfolge innerhalb des Rechtecks gezeichnet.  
  
 Das Ergebnis ist ein vertikales Rechteck, das eine vertikale Zeichenfolge.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#139](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#139)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#139](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#139)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#139](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#139)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="font" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Forms.TextRenderer.MeasureText(System.Drawing.IDeviceContext,System.String,System.Drawing.Font,System.Drawing.Size,System.Windows.Forms.TextFormatFlags)" />
        <altmember cref="M:System.Drawing.Graphics.MeasureCharacterRanges(System.String,System.Drawing.Font,System.Drawing.RectangleF,System.Drawing.StringFormat)" />
        <related type="Article" href="~/docs/framework/winforms/advanced/using-fonts-and-text.md">Verwenden von Schriftarten und Text</related>
      </Docs>
    </Member>
    <Member MemberName="MeasureString">
      <MemberSignature Language="C#" Value="public System.Drawing.SizeF MeasureString (string text, System.Drawing.Font font, int width, System.Drawing.StringFormat format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.SizeF MeasureString(string text, class System.Drawing.Font font, int32 width, class System.Drawing.StringFormat format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.MeasureString(System.String,System.Drawing.Font,System.Int32,System.Drawing.StringFormat)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::SizeF MeasureString(System::String ^ text, System::Drawing::Font ^ font, int width, System::Drawing::StringFormat ^ format);" />
      <MemberSignature Language="F#" Value="member this.MeasureString : string * System.Drawing.Font * int * System.Drawing.StringFormat -&gt; System.Drawing.SizeF" Usage="graphics.MeasureString (text, font, width, format)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="font" Type="System.Drawing.Font" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="format" Type="System.Drawing.StringFormat" />
      </Parameters>
      <Docs>
        <param name="text">Zu messende Zeichenfolge.</param>
        <param name="font">
          <see cref="T:System.Drawing.Font" />, die das Textformat der Zeichenfolge definiert.</param>
        <param name="width">Maximale Breite der Zeichenfolge.</param>
        <param name="format">
          <see cref="T:System.Drawing.StringFormat" />, das Formatierungsinformationen für die Zeichenfolge darstellt, z. B. Zeilenabstand.</param>
        <summary>Misst die angegebene Zeichenfolge, wenn diese mit der angegebenen <see cref="T:System.Drawing.Font" /> gezeichnet und mit dem angegebenen <see cref="T:System.Drawing.StringFormat" /> formatiert wird.</summary>
        <returns>Diese Methode gibt eine <see cref="T:System.Drawing.SizeF" />-Struktur zurück, die die Größe der durch den <paramref name="text" />-Parameter angegebenen Zeichenfolge in der durch die<see cref="P:System.Drawing.Graphics.PageUnit" />-Eigenschaft angegebenen Einheit darstellt, wenn diese mit dem <paramref name="font" />-Parameter und dem <paramref name="stringFormat" />-Parameter gezeichnet wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Drawing.Graphics.MeasureString%2A> Methode dient, für die Verwendung mit einzelnen Zeichenfolgen und eine kleine Menge zusätzlicher Speicherplatz enthält, vor und nach der Zeichenfolge für überhängende Symbole. Darüber hinaus die <xref:System.Drawing.Graphics.DrawString%2A> Methode passt die Glyphe zum Optimieren Anzeigequalität und kann eine Zeichenfolge, die kleiner sind, als von gemeldeten anzeigen <xref:System.Drawing.Graphics.MeasureString%2A>. Verwenden Sie zum Abrufen von Metriken für angrenzende Zeichenfolgen im Layout (z. B. bei der Implementierung von formatiertem Text) der <xref:System.Drawing.Graphics.MeasureCharacterRanges%2A> Methode oder eines der <xref:System.Drawing.Graphics.MeasureString%2A> -Methoden, eine <xref:System.Drawing.StringFormat>, und übergeben Sie <xref:System.Drawing.StringFormat.GenericTypographic%2A>. Stellen Sie außerdem sicher die <xref:System.Drawing.Graphics.TextRenderingHint%2A> für die <xref:System.Drawing.Graphics> ist <xref:System.Drawing.Text.TextRenderingHint.AntiAlias>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt eine Zeichenfolge zu messen und eine Schriftart auf Arial (16 Punkt) festgelegtes Objekt.  
  
-   Legt die maximale Breite der Zeichenfolge fest.  
  
-   Erstellt ein Zeichenfolgenobjekt, das Format und legt die Formatflags auf <xref:System.Drawing.StringFormatFlags.DirectionVertical>.  
  
-   Erstellt ein Größenobjekt, um die Zeichenfolge zu messen.  
  
-   Misst die Größe der Zeichenfolge ist, verwenden die Zeichenfolge, die Schriftartobjekt, die maximale Breite und das Format der Zeichenfolge.  
  
-   Zeichnet ein rotes Rechteck in der gemessenen Größe der Zeichenfolge.  
  
-   Zeichnet die Zeichenfolge innerhalb des Rechtecks gezeichnet.  
  
 Das Ergebnis ist ein vertikales Rechteck, das eine vertikale Zeichenfolge.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#142](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#142)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#142](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#142)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#142](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#142)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="font" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Forms.TextRenderer.MeasureText(System.Drawing.IDeviceContext,System.String,System.Drawing.Font,System.Drawing.Size,System.Windows.Forms.TextFormatFlags)" />
        <altmember cref="M:System.Drawing.Graphics.MeasureCharacterRanges(System.String,System.Drawing.Font,System.Drawing.RectangleF,System.Drawing.StringFormat)" />
        <related type="Article" href="~/docs/framework/winforms/advanced/using-fonts-and-text.md">Verwenden von Schriftarten und Text</related>
      </Docs>
    </Member>
    <Member MemberName="MeasureString">
      <MemberSignature Language="C#" Value="public System.Drawing.SizeF MeasureString (string text, System.Drawing.Font font, System.Drawing.SizeF layoutArea, System.Drawing.StringFormat stringFormat, out int charactersFitted, out int linesFilled);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.SizeF MeasureString(string text, class System.Drawing.Font font, valuetype System.Drawing.SizeF layoutArea, class System.Drawing.StringFormat stringFormat, [out] int32&amp; charactersFitted, [out] int32&amp; linesFilled) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.MeasureString(System.String,System.Drawing.Font,System.Drawing.SizeF,System.Drawing.StringFormat,System.Int32@,System.Int32@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::SizeF MeasureString(System::String ^ text, System::Drawing::Font ^ font, System::Drawing::SizeF layoutArea, System::Drawing::StringFormat ^ stringFormat, [Runtime::InteropServices::Out] int % charactersFitted, [Runtime::InteropServices::Out] int % linesFilled);" />
      <MemberSignature Language="F#" Value="member this.MeasureString : string * System.Drawing.Font * System.Drawing.SizeF * System.Drawing.StringFormat *  *  -&gt; System.Drawing.SizeF" Usage="graphics.MeasureString (text, font, layoutArea, stringFormat, charactersFitted, linesFilled)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="font" Type="System.Drawing.Font" />
        <Parameter Name="layoutArea" Type="System.Drawing.SizeF" />
        <Parameter Name="stringFormat" Type="System.Drawing.StringFormat" />
        <Parameter Name="charactersFitted" Type="System.Int32" RefType="out" />
        <Parameter Name="linesFilled" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="text">Zu messende Zeichenfolge.</param>
        <param name="font">
          <see cref="T:System.Drawing.Font" />, die das Textformat der Zeichenfolge definiert.</param>
        <param name="layoutArea">
          <see cref="T:System.Drawing.SizeF" />-Struktur, die den maximalen Layoutbereich für den Text angibt.</param>
        <param name="stringFormat">
          <see cref="T:System.Drawing.StringFormat" />, das Formatierungsinformationen für die Zeichenfolge darstellt, z. B. Zeilenabstand.</param>
        <param name="charactersFitted">Anzahl der Zeichen in der Zeichenfolge.</param>
        <param name="linesFilled">Anzahl der Textzeilen in der Zeichenfolge.</param>
        <summary>Misst die angegebene Zeichenfolge, wenn diese mit der angegebenen <see cref="T:System.Drawing.Font" /> gezeichnet und mit dem angegebenen <see cref="T:System.Drawing.StringFormat" /> formatiert wird.</summary>
        <returns>Diese Methode gibt eine <see cref="T:System.Drawing.SizeF" />-Struktur zurück, die die Größe der Zeichenfolge des <paramref name="text" />-Parameters in der durch die <see cref="P:System.Drawing.Graphics.PageUnit" />-Eigenschaft angegebenen Einheit darstellt, wenn diese mit dem <paramref name="font" />-Parameter und dem <paramref name="stringFormat" />-Parameter gezeichnet wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Drawing.Graphics.MeasureString%2A> Methode dient, für die Verwendung mit einzelnen Zeichenfolgen und eine kleine Menge zusätzlicher Speicherplatz enthält, vor und nach der Zeichenfolge für überhängende Symbole. Darüber hinaus die <xref:System.Drawing.Graphics.DrawString%2A> Methode passt die Glyphe zum Optimieren Anzeigequalität und kann eine Zeichenfolge, die kleiner sind, als von gemeldeten anzeigen <xref:System.Drawing.Graphics.MeasureString%2A>. Verwenden Sie zum Abrufen von Metriken für angrenzende Zeichenfolgen im Layout (z. B. bei der Implementierung von formatiertem Text) der <xref:System.Drawing.Graphics.MeasureCharacterRanges%2A> Methode oder eines der <xref:System.Drawing.Graphics.MeasureString%2A> -Methoden, eine <xref:System.Drawing.StringFormat> und übergeben Sie <xref:System.Drawing.StringFormat.GenericTypographic%2A>. Vergewissern Sie sich außerdem die <xref:System.Drawing.Graphics.TextRenderingHint%2A> für die <xref:System.Drawing.Graphics> ist <xref:System.Drawing.Text.TextRenderingHint.AntiAlias>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt eine zu messende Zeichenfolge und ein Schriftartobjekt auf Arial (16 Punkt) festgelegt  
  
-   Legt die maximale Layoutgröße der Zeichenfolge fest.  
  
-   Erstellt ein Zeichenfolgenobjekt, das Format und legt die Formatflags auf <xref:System.Drawing.StringFormatFlags.DirectionVertical>.  
  
-   Erstellt die Ganzzahlvariablen `charactersFitted` und `linesFilled` und ein Größenobjekt die Zeichenfolge gemessen.  
  
-   Misst die Größe der Zeichenfolge ein, und bestimmt die Anzahl der Zeichen, die angepasst und Zeilen, die ausgefüllt werden, verwenden die Zeichenfolge, die Schriftartobjekt, die maximale Layoutgröße und das Format der Zeichenfolge.  
  
-   Zeichnet ein rotes Rechteck in der gemessenen Größe der Zeichenfolge.  
  
-   Zeichnet die Zeichenfolge innerhalb des Rechtecks gezeichnet.  
  
-   Zeichnet die Werte von der Anzahl von Zeichen, die angepasst und Zeilen gefüllt.  
  
 Das Ergebnis ist ein vertikales Rechteck, das eine vertikale Zeichenfolge.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#140](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#140)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#140](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#140)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#140](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#140)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="font" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Forms.TextRenderer.MeasureText(System.Drawing.IDeviceContext,System.String,System.Drawing.Font,System.Drawing.Size,System.Windows.Forms.TextFormatFlags)" />
        <altmember cref="M:System.Drawing.Graphics.MeasureCharacterRanges(System.String,System.Drawing.Font,System.Drawing.RectangleF,System.Drawing.StringFormat)" />
        <related type="Article" href="~/docs/framework/winforms/advanced/using-fonts-and-text.md">Verwenden von Schriftarten und Text</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="MultiplyTransform">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Multipliziert die globale Transformation für dieses <see cref="T:System.Drawing.Graphics" /> und die angegebene <see cref="T:System.Drawing.Drawing2D.Matrix" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MultiplyTransform">
      <MemberSignature Language="C#" Value="public void MultiplyTransform (System.Drawing.Drawing2D.Matrix matrix);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MultiplyTransform(class System.Drawing.Drawing2D.Matrix matrix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.MultiplyTransform(System.Drawing.Drawing2D.Matrix)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MultiplyTransform(System::Drawing::Drawing2D::Matrix ^ matrix);" />
      <MemberSignature Language="F#" Value="member this.MultiplyTransform : System.Drawing.Drawing2D.Matrix -&gt; unit" Usage="graphics.MultiplyTransform matrix" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="matrix" Type="System.Drawing.Drawing2D.Matrix" />
      </Parameters>
      <Docs>
        <param name="matrix">4x4 <see cref="T:System.Drawing.Drawing2D.Matrix" />, die die globale Transformation multipliziert.</param>
        <summary>Multipliziert die globale Transformation für dieses <see cref="T:System.Drawing.Graphics" /> und die angegebene <see cref="T:System.Drawing.Drawing2D.Matrix" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode stellt die Matrix voran gemäß der `matrix` -Parameter, damit das Ergebnis ist `matrix` x globale Transformation.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt eine `transformMatrix` Matrix (eine 2 x 2-Identitätsmatrix plus einem Verschiebungsvektor von 0 (null)).  
  
-   Verschiebt die Transformationsmatrix einen Vektor (200, 100).  
  
-   Die globale Transformationsmatrix der Windows Form um 30° dreht, die Rotationsmatrix für 30 Grad Transformationsmatrix des Formulars voran.  
  
-   Multipliziert die Transformationsmatrix gedreht Welt mit der verschobenen `transformMatrix`, und stellt voran die `transformMatrix` auf die globale Transformationsmatrix.  
  
-   Zeichnet eine Ellipse gedrehte, übersetzte.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#143](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#143)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#143](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#143)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#143](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#143)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/0659fe00-9e0c-41c4-9118-016f2404c905">Matrixdarstellung von Transformationen</related>
      </Docs>
    </Member>
    <Member MemberName="MultiplyTransform">
      <MemberSignature Language="C#" Value="public void MultiplyTransform (System.Drawing.Drawing2D.Matrix matrix, System.Drawing.Drawing2D.MatrixOrder order);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MultiplyTransform(class System.Drawing.Drawing2D.Matrix matrix, valuetype System.Drawing.Drawing2D.MatrixOrder order) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.MultiplyTransform(System.Drawing.Drawing2D.Matrix,System.Drawing.Drawing2D.MatrixOrder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MultiplyTransform(System::Drawing::Drawing2D::Matrix ^ matrix, System::Drawing::Drawing2D::MatrixOrder order);" />
      <MemberSignature Language="F#" Value="member this.MultiplyTransform : System.Drawing.Drawing2D.Matrix * System.Drawing.Drawing2D.MatrixOrder -&gt; unit" Usage="graphics.MultiplyTransform (matrix, order)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="matrix" Type="System.Drawing.Drawing2D.Matrix" />
        <Parameter Name="order" Type="System.Drawing.Drawing2D.MatrixOrder" />
      </Parameters>
      <Docs>
        <param name="matrix">4x4 <see cref="T:System.Drawing.Drawing2D.Matrix" />, die die globale Transformation multipliziert.</param>
        <param name="order">Member der <see cref="T:System.Drawing.Drawing2D.MatrixOrder" />-Enumeration, der die Reihenfolge der Multiplikation bestimmt.</param>
        <summary>Multipliziert die globale Transformation dieses <see cref="T:System.Drawing.Graphics" /> und die angegebene <see cref="T:System.Drawing.Drawing2D.Matrix" /> in der angegebenen Reihenfolge.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert <xref:System.Drawing.Drawing2D.MatrixOrder.Prepend> für die `order` Parameter gibt an, dass die Reihenfolge der Multiplikation `matrix` x globale Transformation. Der Wert <xref:System.Drawing.Drawing2D.MatrixOrder.Append> für `order` gibt an, dass die Reihenfolge der Multiplikation globale Transformation X `matrix`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt eine `transformMatrix` Matrix (eine 2 x 2-Identitätsmatrix plus einem Verschiebungsvektor von 0 (null)).  
  
-   Verschiebt die Transformationsmatrix einen Vektor (200, 100).  
  
-   Dreht die globale Transformationsmatrix des Windows-Formulars 30 Grad festlegen, die Rotationsmatrix für 30 Grad Transformationsmatrix des Formulars.  
  
-   Multipliziert die Transformationsmatrix gedreht Welt mit der verschobenen `transformMatrix`, sequenzanfügung der `transformMatrix` auf die globale Transformationsmatrix.  
  
-   Zeichnet eine Ellipse gedrehte, übersetzte.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#144](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#144)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#144](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#144)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#144](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#144)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/0659fe00-9e0c-41c4-9118-016f2404c905">Matrixdarstellung von Transformationen</related>
      </Docs>
    </Member>
    <Member MemberName="PageScale">
      <MemberSignature Language="C#" Value="public float PageScale { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float32 PageScale" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Graphics.PageScale" />
      <MemberSignature Language="VB.NET" Value="Public Property PageScale As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property float PageScale { float get(); void set(float value); };" />
      <MemberSignature Language="F#" Value="member this.PageScale : single with get, set" Usage="System.Drawing.Graphics.PageScale" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Skalierung zwischen globalen Einheiten und Seiteneinheiten für dieses <see cref="T:System.Drawing.Graphics" /> ab oder legt diese fest.</summary>
        <value>Diese Eigenschaft gibt einen Wert für die Skalierung zwischen globalen Einheiten und Seiteneinheiten für dieses <see cref="T:System.Drawing.Graphics" /> an.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie Sie mit der <xref:System.Drawing.Graphics.PageScale%2A> und <xref:System.Drawing.Graphics.TranslateTransform%2A> Elemente, die Skalierung und den Ursprung zu ändern, wenn Sie ein Rechteck zu zeichnen.  
  
 In diesem Beispiel wird mit Windows Forms verwendet werden soll. Fügen Sie den Code in ein Formular, und rufen die `ChangePageScaleAndTranslateTransform` Methode bei der Behandlung des Formulars <xref:System.Windows.Forms.Control.Paint> Ereignis, und übergeben `e` als <xref:System.Windows.Forms.PaintEventArgs>.  
  
 [!code-cpp[System.Drawing.GraphicsProperties#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.GraphicsProperties/CPP/form1.cpp#2)]
 [!code-csharp[System.Drawing.GraphicsProperties#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.GraphicsProperties/CS/form1.cs#2)]
 [!code-vb[System.Drawing.GraphicsProperties#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.GraphicsProperties/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/c61ff50a-eb1d-4e6c-83cd-f7e9764cfa9f">Typen von Koordinatensystemen</related>
      </Docs>
    </Member>
    <Member MemberName="PageUnit">
      <MemberSignature Language="C#" Value="public System.Drawing.GraphicsUnit PageUnit { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.GraphicsUnit PageUnit" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Graphics.PageUnit" />
      <MemberSignature Language="VB.NET" Value="Public Property PageUnit As GraphicsUnit" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::GraphicsUnit PageUnit { System::Drawing::GraphicsUnit get(); void set(System::Drawing::GraphicsUnit value); };" />
      <MemberSignature Language="F#" Value="member this.PageUnit : System.Drawing.GraphicsUnit with get, set" Usage="System.Drawing.Graphics.PageUnit" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.GraphicsUnit</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die in diesem <see cref="T:System.Drawing.Graphics" /> für Seitenkoordinaten verwendete Maßeinheit ab oder legt diese fest.</summary>
        <value>Einer der <see cref="T:System.Drawing.GraphicsUnit" />-Werte, der nicht <see cref="F:System.Drawing.GraphicsUnit.World" /> ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Im Grafikprozessor ist die Maßeinheit für Seitenkoordinaten in diesem <xref:System.Drawing.Graphics>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, die Auswirkungen der Änderung der <xref:System.Drawing.Graphics.PageUnit%2A> Eigenschaft.  
  
 In diesem Beispiel wird mit Windows Forms verwendet werden soll. Fügen Sie den Code in ein Formular, und rufen die `ChangePageUnit` Methode bei der Behandlung des Formulars <xref:System.Windows.Forms.Control.Paint> Ereignis, und übergeben `e` als <xref:System.Windows.Forms.PaintEventArgs>.  
  
 [!code-cpp[System.Drawing.GraphicsProperties#3](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.GraphicsProperties/CPP/form1.cpp#3)]
 [!code-csharp[System.Drawing.GraphicsProperties#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.GraphicsProperties/CS/form1.cs#3)]
 [!code-vb[System.Drawing.GraphicsProperties#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.GraphicsProperties/VB/form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <see cref="P:System.Drawing.Graphics.PageUnit" /> wird auf die nicht physische Einheit <see cref="F:System.Drawing.GraphicsUnit.World" /> festgelegt.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/c61ff50a-eb1d-4e6c-83cd-f7e9764cfa9f">Typen von Koordinatensystemen</related>
      </Docs>
    </Member>
    <Member MemberName="PixelOffsetMode">
      <MemberSignature Language="C#" Value="public System.Drawing.Drawing2D.PixelOffsetMode PixelOffsetMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Drawing2D.PixelOffsetMode PixelOffsetMode" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Graphics.PixelOffsetMode" />
      <MemberSignature Language="VB.NET" Value="Public Property PixelOffsetMode As PixelOffsetMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Drawing2D::PixelOffsetMode PixelOffsetMode { System::Drawing::Drawing2D::PixelOffsetMode get(); void set(System::Drawing::Drawing2D::PixelOffsetMode value); };" />
      <MemberSignature Language="F#" Value="member this.PixelOffsetMode : System.Drawing.Drawing2D.PixelOffsetMode with get, set" Usage="System.Drawing.Graphics.PixelOffsetMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Drawing2D.PixelOffsetMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, wie Pixel beim Rendering dieses <see cref="T:System.Drawing.Graphics" /> ausgeglichen werden, oder legt diesen fest.</summary>
        <value>Diese Eigenschaft gibt einen Member der <see cref="T:System.Drawing.Drawing2D.PixelOffsetMode" />-Enumeration an.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Eigenschaft an beiden höhere Qualität, langsamer rendern oder niedrigere Qualität und schnelleres Rendering von den Inhalt dieses <xref:System.Drawing.Graphics> Objekt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReleaseHdc">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt ein Handle für einen Gerätekontext frei, das bei einem vorherigen Aufruf der <see cref="M:System.Drawing.Graphics.GetHdc" />-Methode dieses <see cref="T:System.Drawing.Graphics" /> abgerufen wurde.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReleaseHdc">
      <MemberSignature Language="C#" Value="public void ReleaseHdc ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReleaseHdc() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.ReleaseHdc" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseHdc ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ReleaseHdc();" />
      <MemberSignature Language="F#" Value="abstract member ReleaseHdc : unit -&gt; unit&#xA;override this.ReleaseHdc : unit -&gt; unit" Usage="graphics.ReleaseHdc " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Drawing.IDeviceContext.ReleaseHdc</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt ein Handle für einen Gerätekontext frei, das bei einem vorherigen Aufruf der <see cref="M:System.Drawing.Graphics.GetHdc" />-Methode dieses <see cref="T:System.Drawing.Graphics" /> abgerufen wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Drawing.Graphics.GetHdc%2A> und <xref:System.Drawing.Graphics.ReleaseHdc%2A> stehen zwei Methoden, mit denen Sie abrufen und Freigeben des Handles für ein Windows-Gerät. Befolgen Sie stets einen Aufruf von <xref:System.Drawing.Graphics.GetHdc%2A> mit einem Aufruf von <xref:System.Drawing.Graphics.ReleaseHdc%2A> Wenn Sie mit dem Windows-Handle fertig sind.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff von nicht verwaltetem Code. Im Zusammenhang Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
        <altmember cref="T:System.Drawing.IDeviceContext" />
      </Docs>
    </Member>
    <Member MemberName="ReleaseHdc">
      <MemberSignature Language="C#" Value="public void ReleaseHdc (IntPtr hdc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReleaseHdc(native int hdc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.ReleaseHdc(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseHdc (hdc As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReleaseHdc(IntPtr hdc);" />
      <MemberSignature Language="F#" Value="member this.ReleaseHdc : nativeint -&gt; unit" Usage="graphics.ReleaseHdc hdc" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netcore-2.1;dotnet-plat-ext-2.1;netcore-2.2">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hdc" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="hdc">Handle für einen Gerätekontext, der durch einen vorherigen Aufruf der <see cref="M:System.Drawing.Graphics.GetHdc" />-Methode dieses <see cref="T:System.Drawing.Graphics" /> abgerufen wurde.</param>
        <summary>Gibt ein Handle für einen Gerätekontext frei, das bei einem vorherigen Aufruf der <see cref="M:System.Drawing.Graphics.GetHdc" />-Methode dieses <see cref="T:System.Drawing.Graphics" /> abgerufen wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Gerätekontext ist eine Windows-Struktur, die basierend auf [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] , definiert einen Satz von grafischen Objekten und die zugehörigen Attribute als auch die grafische Modi, die Ausgabe zu beeinflussen.  
  
 Aufrufe von der <xref:System.Drawing.Graphics.GetHdc%2A> und <xref:System.Drawing.Graphics.ReleaseHdc%2A> Methoden müssen als Paar angezeigt werden. Während des Bereichs einer <xref:System.Drawing.Graphics.GetHdc%2A> und <xref:System.Drawing.Graphics.ReleaseHdc%2A> -Methode bestehenden Methodenpaars, Sie in der Regel Aufrufe vornehmen, nur für [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] Funktionen. In diesem Bereich vorgenommen aufgerufen werden [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] Methoden der <xref:System.Drawing.Graphics> , erzeugt die `hdc` Parameter tritt ein Fehler mit einer `ObjectBusy` Fehler. Darüber hinaus [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] ignoriert alle Zustandsänderungen, die versucht, den <xref:System.Drawing.Graphics> von der `hdc` Parameter in nachfolgenden Vorgängen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Das Beispiel veranschaulicht das Aufrufen einer Windows [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] Funktion führen Sie die gleiche Aufgabe wie eine [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] <xref:System.Drawing.Graphics> Methode. Der Code führt die folgenden Aktionen aus:  
  
-   Definiert die Interoperabilität <xref:System.Runtime.InteropServices.DllImportAttribute> -Attribut für die Windows-DLL-Datei gdi32.dll. Diese DLL enthält die gewünschte [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] -Funktion und definiert die <xref:System.Drawing.Rectangle> Funktion in dieser DLL als extern.  
  
-   Erstellt einen roten Stift.  
  
-   Mit dem Stift Sie zeichnet ein Rechteck mit dem Bildschirm die [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] <xref:System.Drawing.Graphics.DrawRectangle%2A> Methode.  
  
-   Definiert eine Variable des internen Zeiger vom Typ `hdc` und legt dessen Wert auf das Handle für den Gerätekontext des Formulars.  
  
-   Zeichnet ein Rechteck auf dem Bildschirm, wobei die [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] <xref:System.Drawing.Rectangle> Funktion.  
  
-   Gibt den Gerätekontext frei durch dargestellt die `hdc` Parameter.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#145](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#145)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#145](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#145)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#145](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#145)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff von nicht verwaltetem Code. Im Zusammenhang Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ReleaseHdcInternal">
      <MemberSignature Language="C#" Value="public void ReleaseHdcInternal (IntPtr hdc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReleaseHdcInternal(native int hdc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.ReleaseHdcInternal(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseHdcInternal (hdc As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReleaseHdcInternal(IntPtr hdc);" />
      <MemberSignature Language="F#" Value="member this.ReleaseHdcInternal : nativeint -&gt; unit" Usage="graphics.ReleaseHdcInternal hdc" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netcore-2.1;dotnet-plat-ext-2.1;netcore-2.2">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hdc" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="hdc">Handle für einen Gerätekontext.</param>
        <summary>Gibt ein Handle für einen Gerätekontext frei.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff von nicht verwaltetem Code. Im Zusammenhang Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="RenderingOrigin">
      <MemberSignature Language="C#" Value="public System.Drawing.Point RenderingOrigin { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Point RenderingOrigin" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Graphics.RenderingOrigin" />
      <MemberSignature Language="VB.NET" Value="Public Property RenderingOrigin As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Point RenderingOrigin { System::Drawing::Point get(); void set(System::Drawing::Point value); };" />
      <MemberSignature Language="F#" Value="member this.RenderingOrigin : System.Drawing.Point with get, set" Usage="System.Drawing.Graphics.RenderingOrigin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Renderingursprung dieses <see cref="T:System.Drawing.Graphics" /> für Dithering und Schraffurpinsel ab oder legt diesen fest.</summary>
        <value>Eine <see cref="T:System.Drawing.Point" />-Struktur, die den Ursprung für das Dithering mit 8 Bits pro Pixel und 16 Bits pro Pixel darstellt und auch für das Festlegen des Ursprungs für Schraffurpinsel verwendet wird.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetClip">
      <MemberSignature Language="C#" Value="public void ResetClip ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetClip() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.ResetClip" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetClip ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetClip();" />
      <MemberSignature Language="F#" Value="member this.ResetClip : unit -&gt; unit" Usage="graphics.ResetClip " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Setzt den Ausschneidebereich dieses <see cref="T:System.Drawing.Graphics" /> auf einen unendlichen Bereich zurück.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Ausschneidebereich eine <xref:System.Drawing.Graphics> ist unendlich, Elemente, die dieses <xref:System.Drawing.Graphics> zeichnet werden nicht abgeschnitten.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein Rechteck mit der linken oberen Ecke auf (0, 0) und legt den Ausschneidebereich dieses Rechteck.  
  
-   Erstellt ein zweites Rechteck mit der linken oberen Ecke an (100, 100) und legt den Ausschneidebereich auf die Schnittmenge dieses Rechtecks und des aktuellen Ausschneidebereichs (das erste Rechteck).  
  
-   Füllt ein großes Rechteck, das beide vorherigen Rechtecke mit einem Pinsel mit blauer Volltonfarbe enthält.  
  
-   Setzt den Ausschneidebereich auf unendlich zurück.  
  
-   Zeichnet Rechtecke, um die zwei Ausschneidebereiche; Er verwendet einen schwarzen Stift, für das erste Auswahlrechteck und ein roter Stift für den zweiten Ausschneidebereich.  
  
 Das Ergebnis ist, dass nur die Schnittmenge der beiden Rechtecke blau gefüllt ist.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#146](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#146)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#146](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#146)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#146](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#146)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetTransform">
      <MemberSignature Language="C#" Value="public void ResetTransform ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetTransform() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.ResetTransform" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetTransform ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetTransform();" />
      <MemberSignature Language="F#" Value="member this.ResetTransform : unit -&gt; unit" Usage="graphics.ResetTransform " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Setzt die globale Transformationsmatrix dieses <see cref="T:System.Drawing.Graphics" /> auf die Identitätsmatrix zurück.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Identitätsmatrix stellt eine Transformation ohne Skalierung, Rotations- oder translationsmatrix dar. Die globale Transformation dieses zurücksetzen <xref:System.Drawing.Graphics> auf die Identitätsmatrix bedeutet, dass die globale Transformation nicht über die Geometrie der transformierten Elemente ändert.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Übersetzt die globale Transformation des Windows Form mit einem Vektor (100, 0).  
  
-   Speichert den Status der Grafik des Formulars.  
  
-   Setzt die globale Transformation des Formulars mit einer Identität und füllt mit einem roten einfarbigen Pinsel ein Rechteck.  
  
-   Hiermit wird der Grafikstatus der übersetzten und füllt ein Rechteck mit einem Pinsel mit blauer Volltonfarbe.  
  
 Das Ergebnis ist ein nicht übersetzte rot gefülltes Rechteck und eine übersetzte blau gefülltes Rechteck.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#147](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#147)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#147](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#147)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#147](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#147)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Restore">
      <MemberSignature Language="C#" Value="public void Restore (System.Drawing.Drawing2D.GraphicsState gstate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Restore(class System.Drawing.Drawing2D.GraphicsState gstate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.Restore(System.Drawing.Drawing2D.GraphicsState)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Restore (gstate As GraphicsState)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Restore(System::Drawing::Drawing2D::GraphicsState ^ gstate);" />
      <MemberSignature Language="F#" Value="member this.Restore : System.Drawing.Drawing2D.GraphicsState -&gt; unit" Usage="graphics.Restore gstate" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="gstate" Type="System.Drawing.Drawing2D.GraphicsState" />
      </Parameters>
      <Docs>
        <param name="gstate">
          <see cref="T:System.Drawing.Drawing2D.GraphicsState" />, der den Zustand darstellt, der für dieses <see cref="T:System.Drawing.Graphics" /> wiederhergestellt werden soll.</param>
        <summary>Stellt den Zustand dieses <see cref="T:System.Drawing.Graphics" /> wieder her, der durch einen <see cref="T:System.Drawing.Drawing2D.GraphicsState" /> dargestellt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim Aufrufen der <xref:System.Drawing.Graphics.Save%2A> -Methode der ein <xref:System.Drawing.Graphics>, ein Informationsblock mit den Status des der <xref:System.Drawing.Graphics> auf einem Stapel abgelegt. Die <xref:System.Drawing.Graphics.Save%2A> Methode gibt eine <xref:System.Drawing.Drawing2D.GraphicsState> , die den Informationsblock identifiziert. Beim Übergeben der identifizierenden <xref:System.Drawing.Drawing2D.GraphicsState> auf die <xref:System.Drawing.Graphics.Restore%2A> -Methode der Informationsblock wird aus dem Stapel entfernt und wird verwendet, um die Wiederherstellung der <xref:System.Drawing.Graphics> in den Zustand zum Zeitpunkt der war die <xref:System.Drawing.Graphics.Save%2A> Methodenaufruf. Beachten Sie, dass die <xref:System.Drawing.Drawing2D.GraphicsState> zurückgegeben, die durch einen Aufruf der <xref:System.Drawing.Graphics.Save%2A> Methode kann nur einmal übergeben werden, um die `Restore` Methode.  
  
 Aufrufe von der <xref:System.Drawing.Graphics.Save%2A> Methode kann geschachtelt werden; d. h., rufen Sie die <xref:System.Drawing.Graphics.Save%2A> Methode mehrmals vor dem Aufruf der <xref:System.Drawing.Graphics.Restore%2A> Methode. Bei jedem Aufruf der <xref:System.Drawing.Graphics.Save%2A> -Methode, ein Informationsblock ist auf dem Stapel abgelegt, und Sie erhalten eine <xref:System.Drawing.Drawing2D.GraphicsState> für den Informationsblock. Wenn Sie eines dieser Objekte zu übergeben die <xref:System.Drawing.Graphics.Restore%2A> -Methode, die <xref:System.Drawing.Graphics> wird zurückgegeben, um den Zustand zum Zeitpunkt der war die <xref:System.Drawing.Graphics.Save%2A> Methodenaufruf, der das bestimmte zurückgegeben <xref:System.Drawing.Drawing2D.GraphicsState>. Der Informationsblock auf dem Stapel abgelegt werden, von der <xref:System.Drawing.Graphics.Save%2A> Methodenaufruf wird aus dem Stapel entfernt, und alle Informationsblöcke, die nach, die auf diesem Stapel abgelegt <xref:System.Drawing.Graphics.Save%2A> Methodenaufruf werden ebenfalls entfernt.  
  
 Aufrufe von der <xref:System.Drawing.Graphics.BeginContainer%2A> Methode Informationsblöcke auf demselben Stapel als Aufrufe an die <xref:System.Drawing.Graphics.Save%2A> Methode. Ebenso wie eine <xref:System.Drawing.Graphics.Restore%2A> Aufruf zugeordnet ist eine <xref:System.Drawing.Graphics.Save%2A> aufrufen, eine <xref:System.Drawing.Graphics.EndContainer%2A> -Methodenaufruf zugeordnet ist eine <xref:System.Drawing.Graphics.BeginContainer%2A> Methodenaufruf.  
  
 Beim Aufrufen der <xref:System.Drawing.Graphics.Restore%2A> -Methode, alle Informationsblöcke, die auf dem Stapel abgelegt (durch die <xref:System.Drawing.Graphics.Save%2A> Methode oder der <xref:System.Drawing.Graphics.BeginContainer%2A> Methode) nach dem entsprechenden Aufruf von der <xref:System.Drawing.Graphics.Save%2A> -Methode aus dem Stapel entfernt werden. Wenn rufen Sie dementsprechend die <xref:System.Drawing.Graphics.EndContainer%2A> -Methode, alle Informationsblöcke, die auf dem Stapel abgelegt (von der <xref:System.Drawing.Graphics.Save%2A> Methode oder durch die <xref:System.Drawing.Graphics.BeginContainer%2A> Methode) nach dem entsprechenden Aufruf von der <xref:System.Drawing.Graphics.BeginContainer%2A> -Methode aus dem Stapel entfernt werden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Übersetzt die globale Transformation des Windows Form mit einem Vektor (100, 0).  
  
-   Speichert den Status der Grafik des Formulars.  
  
-   Setzt die globale Transformation des Formulars mit einer Identität und füllt mit einem roten einfarbigen Pinsel ein Rechteck.  
  
-   Hiermit wird der Grafikstatus der übersetzten und füllt ein zweites Rechteck mit einem Pinsel mit blauer Volltonfarbe.  
  
 Das Ergebnis ist ein nicht übersetzte rot gefülltes Rechteck und eine übersetzte blau gefülltes Rechteck.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#148](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#148)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#148](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#148)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#148](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#148)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RotateTransform">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wendet die angegebene Drehung auf die Transformationsmatrix dieses <see cref="T:System.Drawing.Graphics" /> an.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RotateTransform">
      <MemberSignature Language="C#" Value="public void RotateTransform (float angle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RotateTransform(float32 angle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.RotateTransform(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RotateTransform (angle As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RotateTransform(float angle);" />
      <MemberSignature Language="F#" Value="member this.RotateTransform : single -&gt; unit" Usage="graphics.RotateTransform angle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="angle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="angle">Drehungswinkel in Grad.</param>
        <summary>Wendet die angegebene Drehung auf die Transformationsmatrix dieses <see cref="T:System.Drawing.Graphics" /> an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Drehung Vorgang besteht aus dem multipliziert der Transformationsmatrix mit einer Matrix, dessen Elemente abgeleitet werden, die `angle` Parameter. Diese Methode gilt die Drehung vorangestellt an die Transformationsmatrix.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Übersetzt die globale Transformationsmatrix der Windows Form um den Vektor (100, 0).  
  
-   Dreht die globale Transformation einen Winkel von 30 Grad, um die globale Transformationsmatrix die Rotationsmatrix.  
  
-   Zeichnet eine Ellipse gedrehte, übersetzte mit einem blauen Stift.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#149](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#149)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#149](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#149)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#149](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#149)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RotateTransform">
      <MemberSignature Language="C#" Value="public void RotateTransform (float angle, System.Drawing.Drawing2D.MatrixOrder order);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RotateTransform(float32 angle, valuetype System.Drawing.Drawing2D.MatrixOrder order) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.RotateTransform(System.Single,System.Drawing.Drawing2D.MatrixOrder)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RotateTransform (angle As Single, order As MatrixOrder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RotateTransform(float angle, System::Drawing::Drawing2D::MatrixOrder order);" />
      <MemberSignature Language="F#" Value="member this.RotateTransform : single * System.Drawing.Drawing2D.MatrixOrder -&gt; unit" Usage="graphics.RotateTransform (angle, order)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="angle" Type="System.Single" />
        <Parameter Name="order" Type="System.Drawing.Drawing2D.MatrixOrder" />
      </Parameters>
      <Docs>
        <param name="angle">Drehungswinkel in Grad.</param>
        <param name="order">Member der <see cref="T:System.Drawing.Drawing2D.MatrixOrder" />-Enumeration, der angibt, ob die Drehung an die Matrixtransformation angehängt oder dieser vorangestellt wird.</param>
        <summary>Wendet die angegebene Drehung auf die Transformationsmatrix dieses <see cref="T:System.Drawing.Graphics" /> in der angegebenen Reihenfolge an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Drehung Vorgang besteht aus dem multipliziert der Transformationsmatrix mit einer Matrix, dessen Elemente abgeleitet werden, die `angle` Parameter. Diese Methode voran, oder fügt an die Transformationsmatrix der <xref:System.Drawing.Graphics> durch die Rotationsmatrix gemäß der `order` Parameter.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Übersetzt die globale Transformationsmatrix der Windows Form um den Vektor (100, 0).  
  
-   Dreht die globale Transformation einen Winkel von 30 Grad festlegen, die Rotationsmatrix anfügen, um die globale Transformationsmatrix mit <xref:System.Drawing.Drawing2D.MatrixOrder.Append>.  
  
-   Zeichnet eine übersetzte gedreht Ellipse mit einem blauen Stift.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#150](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#150)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#150](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#150)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#150](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#150)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public System.Drawing.Drawing2D.GraphicsState Save ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Drawing.Drawing2D.GraphicsState Save() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.Save" />
      <MemberSignature Language="VB.NET" Value="Public Function Save () As GraphicsState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::Drawing2D::GraphicsState ^ Save();" />
      <MemberSignature Language="F#" Value="member this.Save : unit -&gt; System.Drawing.Drawing2D.GraphicsState" Usage="graphics.Save " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Drawing2D.GraphicsState</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Speichert den aktuellen Zustand dieses <see cref="T:System.Drawing.Graphics" /> und identifiziert den gespeicherten Zustand mit einem <see cref="T:System.Drawing.Drawing2D.GraphicsState" />.</summary>
        <returns>Diese Methode gibt einen <see cref="T:System.Drawing.Drawing2D.GraphicsState" /> zurück, der den gespeicherten Zustand dieses <see cref="T:System.Drawing.Graphics" /> darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim Aufrufen der <xref:System.Drawing.Graphics.Save%2A> -Methode der ein <xref:System.Drawing.Graphics>, ein Informationsblock mit den Status des der <xref:System.Drawing.Graphics> auf einem Stapel abgelegt. Die <xref:System.Drawing.Graphics.Save%2A> Methode gibt eine <xref:System.Drawing.Drawing2D.GraphicsState> , die den Informationsblock identifiziert. Beim Übergeben der identifizierenden <xref:System.Drawing.Drawing2D.GraphicsState> auf die <xref:System.Drawing.Graphics.Restore%2A> -Methode der Informationsblock wird aus dem Stapel entfernt und wird verwendet, um die Wiederherstellung der <xref:System.Drawing.Graphics> in den Zustand zum Zeitpunkt der war die <xref:System.Drawing.Graphics.Save%2A> Methodenaufruf. Beachten Sie, dass die <xref:System.Drawing.Drawing2D.GraphicsState> zurückgegeben, die durch einen Aufruf der <xref:System.Drawing.Graphics.Save%2A> Methode kann nur einmal übergeben werden, um die <xref:System.Drawing.Graphics.Restore%2A> Methode.  
  
 Aufrufe von der <xref:System.Drawing.Graphics.Save%2A> Methode kann geschachtelt werden; d. h., rufen Sie die <xref:System.Drawing.Graphics.Save%2A> Methode mehrmals vor dem Aufruf der <xref:System.Drawing.Graphics.Restore%2A> Methode. Bei jedem Aufruf der <xref:System.Drawing.Graphics.Save%2A> -Methode, ein Informationsblock ist auf dem Stapel abgelegt, und Sie erhalten eine <xref:System.Drawing.Drawing2D.GraphicsState> für den Informationsblock. Wenn Sie eines dieser Objekte zu übergeben die <xref:System.Drawing.Graphics.Restore%2A> -Methode, die <xref:System.Drawing.Graphics> wird zurückgegeben, um den Zustand zum Zeitpunkt der war die <xref:System.Drawing.Graphics.Save%2A> Methodenaufruf, der das bestimmte zurückgegeben <xref:System.Drawing.Drawing2D.GraphicsState>. Der Informationsblock auf dem Stapel abgelegt werden, von der <xref:System.Drawing.Graphics.Save%2A> Methodenaufruf wird aus dem Stapel entfernt, und alle Informationsblöcke, die nach, die auf diesem Stapel abgelegt <xref:System.Drawing.Graphics.Save%2A> Methodenaufruf werden ebenfalls entfernt.  
  
 Aufrufe von der <xref:System.Drawing.Graphics.BeginContainer%2A> Methode Informationsblöcke auf demselben Stapel als Aufrufe an die <xref:System.Drawing.Graphics.Save%2A> Methode. Ebenso wie eine <xref:System.Drawing.Graphics.Restore%2A> Aufruf zugeordnet ist eine <xref:System.Drawing.Graphics.Save%2A> aufrufen, eine <xref:System.Drawing.Graphics.EndContainer%2A> -Methodenaufruf zugeordnet ist eine <xref:System.Drawing.Graphics.BeginContainer%2A> Methodenaufruf.  
  
 Beim Aufrufen der <xref:System.Drawing.Graphics.Restore%2A> -Methode, alle Informationsblöcke, die auf dem Stapel abgelegt (durch die <xref:System.Drawing.Graphics.Save%2A> Methode oder der <xref:System.Drawing.Graphics.BeginContainer%2A> Methode) nach dem entsprechenden Aufruf von der <xref:System.Drawing.Graphics.Save%2A> -Methode aus dem Stapel entfernt werden. Wenn rufen Sie dementsprechend die <xref:System.Drawing.Graphics.EndContainer%2A> -Methode, alle Informationsblöcke, die auf dem Stapel abgelegt (von der <xref:System.Drawing.Graphics.Save%2A> Methode oder durch die <xref:System.Drawing.Graphics.BeginContainer%2A> Methode) nach dem entsprechenden Aufruf von der <xref:System.Drawing.Graphics.BeginContainer%2A> -Methode aus dem Stapel entfernt werden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Übersetzt die globale Transformation des Windows Form mit einem Vektor (100, 0).  
  
-   Speichert den Status der Grafik des Formulars.  
  
-   Setzt die globale Transformation des Formulars mit einer Identität (2 x 2-Identitätsmatrix plus eine 0 (null)-Vektor-Übersetzung), und füllt mit einem roten einfarbigen Pinsel ein Rechteck.  
  
-   Hiermit wird der Grafikstatus der übersetzten und füllt ein Rechteck mit einem Pinsel mit blauer Volltonfarbe.  
  
 Das Ergebnis ist ein nicht übersetzte rot gefülltes Rechteck auf der linken Seite und einer übersetzten blau gefülltes Rechteck auf der rechten Seite des Formulars.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#151](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#151)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#151](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#151)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#151](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#151)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ScaleTransform">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wendet die angegebene Skalierungsoperation auf die Transformationsmatrix dieses <see cref="T:System.Drawing.Graphics" /> an, indem diese der Transformationsmatrix des Objekts vorangestellt wird.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ScaleTransform">
      <MemberSignature Language="C#" Value="public void ScaleTransform (float sx, float sy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ScaleTransform(float32 sx, float32 sy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.ScaleTransform(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ScaleTransform (sx As Single, sy As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ScaleTransform(float sx, float sy);" />
      <MemberSignature Language="F#" Value="member this.ScaleTransform : single * single -&gt; unit" Usage="graphics.ScaleTransform (sx, sy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sx" Type="System.Single" />
        <Parameter Name="sy" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="sx">Skalierungsfaktor in der x-Richtung.</param>
        <param name="sy">Skalierungsfaktor in der y-Richtung.</param>
        <summary>Wendet die angegebene Skalierungsoperation auf die Transformationsmatrix dieses <see cref="T:System.Drawing.Graphics" /> an, indem diese der Transformationsmatrix des Objekts vorangestellt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Multipliziert die Transformationsmatrix mit einer diagonalen-Matrix, dessen Elemente, der Skalierungsvorgang besteht aus (`sx`, `sy`, 1). Diese Methode stellt die Transformationsmatrix voran die <xref:System.Drawing.Graphics> durch die Skalierungsmatrix.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Dreht die globale Transformationsmatrix der Windows Form um 30° an.  
  
-   Skaliert diese Matrix um den Faktor 3 in der X-Richtung und einen Faktor von 1 in der y-Richtung durch die Skalierungstransformation voranstellen.  
  
-   Zeichnet ein skaliertes gedrehtes Rechteck mit einem blauen Stift.  
  
 Das Ergebnis ist weiterhin ein Rechteck.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#152](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#152)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#152](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#152)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#152](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#152)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScaleTransform">
      <MemberSignature Language="C#" Value="public void ScaleTransform (float sx, float sy, System.Drawing.Drawing2D.MatrixOrder order);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ScaleTransform(float32 sx, float32 sy, valuetype System.Drawing.Drawing2D.MatrixOrder order) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.ScaleTransform(System.Single,System.Single,System.Drawing.Drawing2D.MatrixOrder)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ScaleTransform (sx As Single, sy As Single, order As MatrixOrder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ScaleTransform(float sx, float sy, System::Drawing::Drawing2D::MatrixOrder order);" />
      <MemberSignature Language="F#" Value="member this.ScaleTransform : single * single * System.Drawing.Drawing2D.MatrixOrder -&gt; unit" Usage="graphics.ScaleTransform (sx, sy, order)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sx" Type="System.Single" />
        <Parameter Name="sy" Type="System.Single" />
        <Parameter Name="order" Type="System.Drawing.Drawing2D.MatrixOrder" />
      </Parameters>
      <Docs>
        <param name="sx">Skalierungsfaktor in der x-Richtung.</param>
        <param name="sy">Skalierungsfaktor in der y-Richtung.</param>
        <param name="order">Member der <see cref="T:System.Drawing.Drawing2D.MatrixOrder" />-Enumeration, der angibt, ob die Skalierungsoperation an die Transformationsmatrix angehängt oder dieser vorangestellt wird.</param>
        <summary>Wendet den angegebenen Skalierungsvorgang auf die Transformationsmatrix dieses <see cref="T:System.Drawing.Graphics" /> in der angegebenen Reihenfolge an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Multipliziert die Transformationsmatrix mit einer diagonalen-Matrix, dessen Elemente, der Skalierungsvorgang besteht aus (`sx`, `sy`, 1). Voran, oder diese Methode fügt die Transformationsmatrix der <xref:System.Drawing.Graphics> durch die Skalierungsmatrix gemäß der `order` Parameter.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Dreht die globale Transformationsmatrix der Windows Form um 30° an.  
  
-   Skaliert diese Matrix um den Faktor 3 in der X-Richtung und einen Faktor von 1 in der y-Richtung durch die Skalierungstransformation mit Anfügen der <xref:System.Drawing.Drawing2D.MatrixOrder.Append> Member.  
  
-   Zeichnet ein Rechteck gedrehtes, skaliertes mit einem blauen Stift.  
  
 Das Ergebnis ist ein Parallelogramm.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#153](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#153)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#153](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#153)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#153](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#153)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetClip">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Legt den Ausschneidebereich dieses <see cref="T:System.Drawing.Graphics" /> auf die <see langword="Clip" />-Eigenschaft des angegebenen <see cref="T:System.Drawing.Graphics" /> fest.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetClip">
      <MemberSignature Language="C#" Value="public void SetClip (System.Drawing.Drawing2D.GraphicsPath path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetClip(class System.Drawing.Drawing2D.GraphicsPath path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.SetClip(System.Drawing.Drawing2D.GraphicsPath)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetClip (path As GraphicsPath)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetClip(System::Drawing::Drawing2D::GraphicsPath ^ path);" />
      <MemberSignature Language="F#" Value="member this.SetClip : System.Drawing.Drawing2D.GraphicsPath -&gt; unit" Usage="graphics.SetClip path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.Drawing.Drawing2D.GraphicsPath" />
      </Parameters>
      <Docs>
        <param name="path">
          <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />, der den neuen Ausschneidebereich darstellt.</param>
        <summary>Legt den Ausschneidebereich dieses <see cref="T:System.Drawing.Graphics" /> auf den angegebenen <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Grafikpfad durch dargestellt die `path` Parameter nicht geschlossen ist, ein zusätzliches Segment wurde vom letzten Punkt und dem ersten Punkt um den Pfad zu schließen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen Grafikpfad aus, und der Pfad eine Ellipse hinzugefügt.  
  
-   Legt den Ausschneidebereich auf des elliptischen Pfads fest.  
  
-   Füllt ein großes Rechteck mit einem schwarzen einfarbigen Pinsel.  
  
 Das Ergebnis ist eine ausgefüllte Ellipse Schwarz.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#154](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#154)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#154](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#154)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#154](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#154)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetClip">
      <MemberSignature Language="C#" Value="public void SetClip (System.Drawing.Graphics g);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetClip(class System.Drawing.Graphics g) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.SetClip(System.Drawing.Graphics)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetClip (g As Graphics)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetClip(System::Drawing::Graphics ^ g);" />
      <MemberSignature Language="F#" Value="member this.SetClip : System.Drawing.Graphics -&gt; unit" Usage="graphics.SetClip g" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="g" Type="System.Drawing.Graphics" />
      </Parameters>
      <Docs>
        <param name="g">
          <see cref="T:System.Drawing.Graphics" />, von dem der neue Ausschneidebereich übernommen werden soll.</param>
        <summary>Legt den Ausschneidebereich dieses <see cref="T:System.Drawing.Graphics" /> auf die <see langword="Clip" />-Eigenschaft des angegebenen <see cref="T:System.Drawing.Graphics" /> fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler als auch `thisForm`, <xref:System.Windows.Forms.Form> für das Beispiel. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt eine temporäre <xref:System.Drawing.Graphics> aus der `thisForm` <xref:System.Windows.Forms.Form> des Beispiels.  
  
-   Legt den Ausschneidebereich des temporären <xref:System.Drawing.Graphics> auf ein kleines Quadrat.  
  
-   Aktualisiert den Ausschneidebereich des Formulars Grafikobjekt des temporären <xref:System.Drawing.Graphics>.  
  
-   Füllt ein großes Rechteck mit einem schwarzen einfarbigen Pinsel.  
  
 Das Ergebnis ist eine kleine, gefülltes schwarzes Quadrat.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#156](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#156)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#156](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#156)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#156](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#156)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetClip">
      <MemberSignature Language="C#" Value="public void SetClip (System.Drawing.Rectangle rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetClip(valuetype System.Drawing.Rectangle rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.SetClip(System.Drawing.Rectangle)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetClip (rect As Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetClip(System::Drawing::Rectangle rect);" />
      <MemberSignature Language="F#" Value="member this.SetClip : System.Drawing.Rectangle -&gt; unit" Usage="graphics.SetClip rect" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="rect">
          <see cref="T:System.Drawing.Rectangle" />-Struktur, die den neuen Ausschneidebereich darstellt.</param>
        <summary>Legt den Ausschneidebereich dieses <see cref="T:System.Drawing.Graphics" /> auf das Rechteck fest, das durch eine <see cref="T:System.Drawing.Rectangle" />-Struktur angegeben wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein kleines Rechteck für den Ausschneidebereich an.  
  
-   Legt den Ausschneidebereich auf das Rechteck fest.  
  
-   Füllt ein großes Rechteck mit einem schwarzen einfarbigen Pinsel.  
  
 Das Ergebnis ist ein kleines, gefüllte Schwarz Rechteck.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#158](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#158)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#158](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#158)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#158](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#158)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetClip">
      <MemberSignature Language="C#" Value="public void SetClip (System.Drawing.RectangleF rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetClip(valuetype System.Drawing.RectangleF rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.SetClip(System.Drawing.RectangleF)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetClip (rect As RectangleF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetClip(System::Drawing::RectangleF rect);" />
      <MemberSignature Language="F#" Value="member this.SetClip : System.Drawing.RectangleF -&gt; unit" Usage="graphics.SetClip rect" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.RectangleF" />
      </Parameters>
      <Docs>
        <param name="rect">
          <see cref="T:System.Drawing.RectangleF" />-Struktur, die den neuen Ausschneidebereich darstellt.</param>
        <summary>Legt den Ausschneidebereich dieses <see cref="T:System.Drawing.Graphics" /> auf das Rechteck fest, das durch eine <see cref="T:System.Drawing.RectangleF" />-Struktur angegeben wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein kleines Rechteck für den Ausschneidebereich an.  
  
-   Legt den Ausschneidebereich auf das Rechteck fest.  
  
-   Füllt ein großes Rechteck mit einem schwarzen einfarbigen Pinsel.  
  
 Das Ergebnis ist ein kleines, gefüllte Schwarz Rechteck.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#160](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#160)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#160](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#160)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#160](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#160)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetClip">
      <MemberSignature Language="C#" Value="public void SetClip (System.Drawing.Drawing2D.GraphicsPath path, System.Drawing.Drawing2D.CombineMode combineMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetClip(class System.Drawing.Drawing2D.GraphicsPath path, valuetype System.Drawing.Drawing2D.CombineMode combineMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.SetClip(System.Drawing.Drawing2D.GraphicsPath,System.Drawing.Drawing2D.CombineMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetClip(System::Drawing::Drawing2D::GraphicsPath ^ path, System::Drawing::Drawing2D::CombineMode combineMode);" />
      <MemberSignature Language="F#" Value="member this.SetClip : System.Drawing.Drawing2D.GraphicsPath * System.Drawing.Drawing2D.CombineMode -&gt; unit" Usage="graphics.SetClip (path, combineMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.Drawing.Drawing2D.GraphicsPath" />
        <Parameter Name="combineMode" Type="System.Drawing.Drawing2D.CombineMode" />
      </Parameters>
      <Docs>
        <param name="path">Zu kombinierender <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</param>
        <param name="combineMode">Member der <see cref="T:System.Drawing.Drawing2D.CombineMode" />-Enumeration, der die zu verwendende Operation zum Kombinieren angibt.</param>
        <summary>Legt den Ausschneidebereich dieses <see cref="T:System.Drawing.Graphics" /> auf das Ergebnis des angegebenen Vorgangs fest, indem der aktuelle Ausschneidebereich und der angegebene <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> kombiniert werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Grafikpfad durch dargestellt die `path` Parameter nicht geschlossen ist, ein zusätzliches Segment wurde vom letzten Punkt und dem ersten Punkt um den Pfad zu schließen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen Grafikpfad aus, und der Pfad eine Ellipse hinzugefügt.  
  
-   Legt den Ausschneidebereich, des elliptischen Pfads mit dem <xref:System.Drawing.Drawing2D.CombineMode.Replace> Member.  
  
-   Füllt ein großes Rechteck mit einem schwarzen einfarbigen Pinsel.  
  
 Das Ergebnis ist eine ausgefüllte Ellipse Schwarz.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#155](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#155)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#155](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#155)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#155](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#155)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetClip">
      <MemberSignature Language="C#" Value="public void SetClip (System.Drawing.Graphics g, System.Drawing.Drawing2D.CombineMode combineMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetClip(class System.Drawing.Graphics g, valuetype System.Drawing.Drawing2D.CombineMode combineMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.SetClip(System.Drawing.Graphics,System.Drawing.Drawing2D.CombineMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetClip(System::Drawing::Graphics ^ g, System::Drawing::Drawing2D::CombineMode combineMode);" />
      <MemberSignature Language="F#" Value="member this.SetClip : System.Drawing.Graphics * System.Drawing.Drawing2D.CombineMode -&gt; unit" Usage="graphics.SetClip (g, combineMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="g" Type="System.Drawing.Graphics" />
        <Parameter Name="combineMode" Type="System.Drawing.Drawing2D.CombineMode" />
      </Parameters>
      <Docs>
        <param name="g">
          <see cref="T:System.Drawing.Graphics" />, das den zu kombinierenden Ausschneidebereich angibt.</param>
        <param name="combineMode">Member der <see cref="T:System.Drawing.Drawing2D.CombineMode" />-Enumeration, der die zu verwendende Operation zum Kombinieren angibt.</param>
        <summary>Legt den Ausschneidebereich dieses <see cref="T:System.Drawing.Graphics" /> auf das Ergebnis der angegebenen Kombination des aktuellen Ausschneidebereichs und der <see cref="P:System.Drawing.Graphics.Clip" />-Eigenschaft des angegebenen <see cref="T:System.Drawing.Graphics" /> fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler als auch `thisForm`, <xref:System.Windows.Forms.Form> für das Beispiel. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt eine temporäre <xref:System.Drawing.Graphics> aus der `thisForm` <xref:System.Windows.Forms.Form> des Beispiels.  
  
-   Legt den Ausschneidebereich des temporären <xref:System.Drawing.Graphics> auf ein kleines Quadrat.  
  
-   Aktualisiert den Ausschneidebereich des Formulars grafisches Objekt mit der neuen <xref:System.Drawing.Graphics> mit der <xref:System.Drawing.Drawing2D.CombineMode.Replace> Member.  
  
-   Füllt ein großes Rechteck mit einem schwarzen einfarbigen Pinsel.  
  
 Das Ergebnis ist eine kleine, gefülltes schwarzes Quadrat.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#157](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#157)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#157](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#157)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#157](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#157)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetClip">
      <MemberSignature Language="C#" Value="public void SetClip (System.Drawing.Rectangle rect, System.Drawing.Drawing2D.CombineMode combineMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetClip(valuetype System.Drawing.Rectangle rect, valuetype System.Drawing.Drawing2D.CombineMode combineMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.SetClip(System.Drawing.Rectangle,System.Drawing.Drawing2D.CombineMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetClip(System::Drawing::Rectangle rect, System::Drawing::Drawing2D::CombineMode combineMode);" />
      <MemberSignature Language="F#" Value="member this.SetClip : System.Drawing.Rectangle * System.Drawing.Drawing2D.CombineMode -&gt; unit" Usage="graphics.SetClip (rect, combineMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
        <Parameter Name="combineMode" Type="System.Drawing.Drawing2D.CombineMode" />
      </Parameters>
      <Docs>
        <param name="rect">Zu kombinierende <see cref="T:System.Drawing.Rectangle" />-Struktur.</param>
        <param name="combineMode">Member der <see cref="T:System.Drawing.Drawing2D.CombineMode" />-Enumeration, der die zu verwendende Operation zum Kombinieren angibt.</param>
        <summary>Legt den Ausschneidebereich dieses <see cref="T:System.Drawing.Graphics" /> auf das Ergebnis des angegebenen Vorgangs fest, indem der aktuelle Ausschneidebereich und das Rechteck, das durch eine <see cref="T:System.Drawing.Rectangle" />-Struktur angegeben wird, kombiniert werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein kleines Rechteck für den Ausschneidebereich an.  
  
-   Legt den Ausschneidebereich in das Rechteck mit der <xref:System.Drawing.Drawing2D.CombineMode.Replace> Member.  
  
-   Füllt ein großes Rechteck mit einem schwarzen einfarbigen Pinsel.  
  
 Das Ergebnis ist ein kleines, gefüllte Schwarz Rechteck.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#159](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#159)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#159](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#159)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#159](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#159)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetClip">
      <MemberSignature Language="C#" Value="public void SetClip (System.Drawing.RectangleF rect, System.Drawing.Drawing2D.CombineMode combineMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetClip(valuetype System.Drawing.RectangleF rect, valuetype System.Drawing.Drawing2D.CombineMode combineMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.SetClip(System.Drawing.RectangleF,System.Drawing.Drawing2D.CombineMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetClip(System::Drawing::RectangleF rect, System::Drawing::Drawing2D::CombineMode combineMode);" />
      <MemberSignature Language="F#" Value="member this.SetClip : System.Drawing.RectangleF * System.Drawing.Drawing2D.CombineMode -&gt; unit" Usage="graphics.SetClip (rect, combineMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.RectangleF" />
        <Parameter Name="combineMode" Type="System.Drawing.Drawing2D.CombineMode" />
      </Parameters>
      <Docs>
        <param name="rect">Zu kombinierende <see cref="T:System.Drawing.RectangleF" />-Struktur.</param>
        <param name="combineMode">Member der <see cref="T:System.Drawing.Drawing2D.CombineMode" />-Enumeration, der die zu verwendende Operation zum Kombinieren angibt.</param>
        <summary>Legt den Ausschneidebereich dieses <see cref="T:System.Drawing.Graphics" /> auf das Ergebnis des angegebenen Vorgangs fest, indem der aktuelle Ausschneidebereich und das Rechteck, das durch eine <see cref="T:System.Drawing.RectangleF" />-Struktur angegeben wird, kombiniert werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein kleines Rechteck für den Ausschneidebereich an.  
  
-   Legt den Ausschneidebereich in das Rechteck mit der <xref:System.Drawing.Drawing2D.CombineMode.Replace> Member.  
  
-   Füllt ein großes Rechteck mit einem schwarzen einfarbigen Pinsel.  
  
 Das Ergebnis ist ein kleines, gefüllte Schwarz Rechteck.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#161](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#161)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#161](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#161)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#161](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#161)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetClip">
      <MemberSignature Language="C#" Value="public void SetClip (System.Drawing.Region region, System.Drawing.Drawing2D.CombineMode combineMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetClip(class System.Drawing.Region region, valuetype System.Drawing.Drawing2D.CombineMode combineMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.SetClip(System.Drawing.Region,System.Drawing.Drawing2D.CombineMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetClip(System::Drawing::Region ^ region, System::Drawing::Drawing2D::CombineMode combineMode);" />
      <MemberSignature Language="F#" Value="member this.SetClip : System.Drawing.Region * System.Drawing.Drawing2D.CombineMode -&gt; unit" Usage="graphics.SetClip (region, combineMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="region" Type="System.Drawing.Region" />
        <Parameter Name="combineMode" Type="System.Drawing.Drawing2D.CombineMode" />
      </Parameters>
      <Docs>
        <param name="region">Zu kombinierender <see cref="T:System.Drawing.Region" />.</param>
        <param name="combineMode">Member der <see cref="T:System.Drawing.Drawing2D.CombineMode" />-Enumeration, der die zu verwendende Operation zum Kombinieren angibt.</param>
        <summary>Legt den Ausschneidebereich dieses <see cref="T:System.Drawing.Graphics" /> auf das Ergebnis des angegebenen Vorgangs fest, indem der aktuelle Ausschneidebereich und der angegebene <see cref="T:System.Drawing.Region" /> kombiniert werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein kleines Rechteck für den Ausschneidebereich an.  
  
-   Legt den Ausschneidebereich in das Rechteck mit der <xref:System.Drawing.Drawing2D.CombineMode.Replace> Member.  
  
-   Füllt ein großes Rechteck mit einem schwarzen einfarbigen Pinsel.  
  
 Das Ergebnis ist ein kleines, gefüllte Schwarz Rechteck.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#162](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#162)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#162](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#162)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#162](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#162)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SmoothingMode">
      <MemberSignature Language="C#" Value="public System.Drawing.Drawing2D.SmoothingMode SmoothingMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Drawing2D.SmoothingMode SmoothingMode" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Graphics.SmoothingMode" />
      <MemberSignature Language="VB.NET" Value="Public Property SmoothingMode As SmoothingMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Drawing2D::SmoothingMode SmoothingMode { System::Drawing::Drawing2D::SmoothingMode get(); void set(System::Drawing::Drawing2D::SmoothingMode value); };" />
      <MemberSignature Language="F#" Value="member this.SmoothingMode : System.Drawing.Drawing2D.SmoothingMode with get, set" Usage="System.Drawing.Graphics.SmoothingMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Drawing2D.SmoothingMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Renderqualität für dieses <see cref="T:System.Drawing.Graphics" /> ab oder legt diese fest.</summary>
        <value>Einer der <see cref="T:System.Drawing.Drawing2D.SmoothingMode" />-Werte.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Glättungsmodus gibt an, ob Linien, Kurven und Ränder von gefüllten Bereichen Glättung (Antialiasing sogenannte). Eine Ausnahme ist, dass der Pinsel mit Farbverlauf Pfad nicht die Glättungsmodus unterliegen. Gefüllt mit Bereichen ein <xref:System.Drawing.Drawing2D.PathGradientBrush> (Alias) über die gleiche Weise gerendert werden, unabhängig von der <xref:System.Drawing.Graphics.SmoothingMode%2A> Eigenschaft.  
  
   
  
## Examples  
 Die folgende Methode zeigt die Auswirkungen der Einstellung der <xref:System.Drawing.Pen.DashCap%2A>, <xref:System.Drawing.Pen.DashPattern%2A>, und <xref:System.Drawing.Graphics.SmoothingMode%2A> Eigenschaften. Die Ausgabe des Beispiels wird in der folgenden Abbildung angezeigt.  
  
 ![Linien mit und ohne Glättung. ] (~/add/media/gdi-smoothingmode.png "Linien mit und ohne Glättung.")  
  
 In diesem Beispiel wird mit Windows Forms verwendet werden soll. Fügen Sie den Code in ein Formular, und rufen die `ShowPensAndSmoothingMode` Methode bei der Behandlung des Formulars <xref:System.Windows.Forms.Control.Paint> Ereignis, und übergeben `e` als <xref:System.Windows.Forms.PaintEventArgs>.  
  
 [!code-cpp[System.Drawing.PensExample#3](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.PensExample/CPP/form1.cpp#3)]
 [!code-csharp[System.Drawing.PensExample#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.PensExample/CS/form1.cs#3)]
 [!code-vb[System.Drawing.PensExample#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.PensExample/VB/form1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextContrast">
      <MemberSignature Language="C#" Value="public int TextContrast { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 TextContrast" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Graphics.TextContrast" />
      <MemberSignature Language="VB.NET" Value="Public Property TextContrast As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int TextContrast { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.TextContrast : int with get, set" Usage="System.Drawing.Graphics.TextContrast" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Gammakorrekturwert für das Rendern von Text ab oder legt diesen fest.</summary>
        <value>Der Gammakorrekturwert, der für das Rendern von Anitaliasing- und ClearType-Text verwendet wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Gammakorrekturwert muss zwischen 0 und 12 liegen. Der Standardwert ist 4.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der <xref:System.Drawing.Graphics.TextRenderingHint%2A> und <xref:System.Drawing.Graphics.TextContrast%2A> Eigenschaften.  
  
 In diesem Beispiel wird mit Windows Forms verwendet werden soll. Fügen Sie den Code in ein Formular, und rufen die `ChangeTextRenderingHintAndTextContrast` Methode bei der Behandlung des Formulars <xref:System.Windows.Forms.Control.Paint> Ereignis, und übergeben `e` als <xref:System.Windows.Forms.PaintEventArgs>.  
  
 [!code-cpp[System.Drawing.GraphicsProperties#5](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.GraphicsProperties/CPP/form1.cpp#5)]
 [!code-csharp[System.Drawing.GraphicsProperties#5](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.GraphicsProperties/CS/form1.cs#5)]
 [!code-vb[System.Drawing.GraphicsProperties#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.GraphicsProperties/VB/form1.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextRenderingHint">
      <MemberSignature Language="C#" Value="public System.Drawing.Text.TextRenderingHint TextRenderingHint { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Text.TextRenderingHint TextRenderingHint" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Graphics.TextRenderingHint" />
      <MemberSignature Language="VB.NET" Value="Public Property TextRenderingHint As TextRenderingHint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Text::TextRenderingHint TextRenderingHint { System::Drawing::Text::TextRenderingHint get(); void set(System::Drawing::Text::TextRenderingHint value); };" />
      <MemberSignature Language="F#" Value="member this.TextRenderingHint : System.Drawing.Text.TextRenderingHint with get, set" Usage="System.Drawing.Graphics.TextRenderingHint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Text.TextRenderingHint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Renderingmodus für Text ab, der diesem <see cref="T:System.Drawing.Graphics" /> zugeordnet ist, oder legt diesen fest.</summary>
        <value>Einer der <see cref="T:System.Drawing.Text.TextRenderingHint" />-Werte.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Text-Rendering-Hinweis gibt an, ob Text mit Antialiasing gerendert.  
  
> [!NOTE]
>  Verwenden Sie keine <xref:System.Drawing.Graphics.CompositingMode%2A> Eigenschaftswert, der <xref:System.Drawing.Drawing2D.CompositingMode.SourceCopy> beim der <xref:System.Drawing.Graphics.TextRenderingHint%2A> -Eigenschaftensatz auf <xref:System.Drawing.Text.TextRenderingHint.ClearTypeGridFit>. Eine Ausnahme auftreten, oder das Bild möglicherweise nicht ordnungsgemäß gerendert.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der <xref:System.Drawing.Graphics.TextRenderingHint%2A> und <xref:System.Drawing.Graphics.TextContrast%2A> Eigenschaften.  
  
 In diesem Beispiel wird mit Windows Forms verwendet werden soll. Fügen Sie den Code in ein Formular, und rufen die `ChangeTextRenderingHintAndTextContrast` Methode bei der Behandlung des Formulars <xref:System.Windows.Forms.Control.Paint> Ereignis, und übergeben `e` als <xref:System.Windows.Forms.PaintEventArgs>.  
  
 [!code-cpp[System.Drawing.GraphicsProperties#5](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.GraphicsProperties/CPP/form1.cpp#5)]
 [!code-csharp[System.Drawing.GraphicsProperties#5](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.GraphicsProperties/CS/form1.cs#5)]
 [!code-vb[System.Drawing.GraphicsProperties#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.GraphicsProperties/VB/form1.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Transform">
      <MemberSignature Language="C#" Value="public System.Drawing.Drawing2D.Matrix Transform { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Drawing2D.Matrix Transform" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Graphics.Transform" />
      <MemberSignature Language="VB.NET" Value="Public Property Transform As Matrix" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Drawing2D::Matrix ^ Transform { System::Drawing::Drawing2D::Matrix ^ get(); void set(System::Drawing::Drawing2D::Matrix ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Transform : System.Drawing.Drawing2D.Matrix with get, set" Usage="System.Drawing.Graphics.Transform" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Drawing2D.Matrix</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Kopie der geometrischen globalen Transformation für dieses <see cref="T:System.Drawing.Graphics" /> ab oder legt diese fest.</summary>
        <value>Eine Kopie von <see cref="T:System.Drawing.Drawing2D.Matrix" />, die die geometrische globale Transformation für dieses <see cref="T:System.Drawing.Graphics" /> darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 GDI + verwendet drei Koordinatensysteme: Welt, Seiten- und Gerät. Globale Koordinaten sind die Koordinaten, die zum Modellieren einer bestimmten grafikumgebung verwendet und die Koordinaten, die Sie Methoden in .NET Framework übergeben. Seitenkoordinaten beziehen sich auf das Koordinatensystem, die von einer Zeichenoberfläche, z. B. einem Formular oder ein Steuerelement verwendet. Gerätekoordinaten sind, die Koordinaten, die von der physischen Zeichengerät, z. B. einen Bildschirm oder Drucker, der verwendet wird. Die <xref:System.Drawing.Graphics.Transform%2A> Eigenschaft darstellt, die globale Transformation, die globale Koordinaten in Seitenkoordinaten zuordnet.  
  
 Da die Matrix zurückgegeben und durch die <xref:System.Drawing.Graphics.Transform%2A> Eigenschaft ist eine Kopie der geometrischen Transformation, sollten Sie die Matrix freigeben, wenn Sie nicht mehr benötigen.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/c61ff50a-eb1d-4e6c-83cd-f7e9764cfa9f">Typen von Koordinatensystemen</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TransformPoints">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Transformiert ein Array von Punkten unter Verwendung der aktuellen globalen Transformation und der Seitentransformation dieses <see cref="T:System.Drawing.Graphics" /> aus einem Koordinatenbereich in einen anderen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TransformPoints">
      <MemberSignature Language="C#" Value="public void TransformPoints (System.Drawing.Drawing2D.CoordinateSpace destSpace, System.Drawing.Drawing2D.CoordinateSpace srcSpace, System.Drawing.Point[] pts);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransformPoints(valuetype System.Drawing.Drawing2D.CoordinateSpace destSpace, valuetype System.Drawing.Drawing2D.CoordinateSpace srcSpace, valuetype System.Drawing.Point[] pts) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.TransformPoints(System.Drawing.Drawing2D.CoordinateSpace,System.Drawing.Drawing2D.CoordinateSpace,System.Drawing.Point[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransformPoints (destSpace As CoordinateSpace, srcSpace As CoordinateSpace, pts As Point())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransformPoints(System::Drawing::Drawing2D::CoordinateSpace destSpace, System::Drawing::Drawing2D::CoordinateSpace srcSpace, cli::array &lt;System::Drawing::Point&gt; ^ pts);" />
      <MemberSignature Language="F#" Value="member this.TransformPoints : System.Drawing.Drawing2D.CoordinateSpace * System.Drawing.Drawing2D.CoordinateSpace * System.Drawing.Point[] -&gt; unit" Usage="graphics.TransformPoints (destSpace, srcSpace, pts)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destSpace" Type="System.Drawing.Drawing2D.CoordinateSpace" />
        <Parameter Name="srcSpace" Type="System.Drawing.Drawing2D.CoordinateSpace" />
        <Parameter Name="pts" Type="System.Drawing.Point[]" />
      </Parameters>
      <Docs>
        <param name="destSpace">Member der <see cref="T:System.Drawing.Drawing2D.CoordinateSpace" />-Enumeration, der den Zielkoordinatenbereich angibt.</param>
        <param name="srcSpace">Member der <see cref="T:System.Drawing.Drawing2D.CoordinateSpace" />-Enumeration, der den Quellkoordinatenbereich angibt.</param>
        <param name="pts">Array von <see cref="T:System.Drawing.Point" />-Strukturen, die die zu transformierenden Punkte darstellen.</param>
        <summary>Transformiert ein Array von Punkten unter Verwendung der aktuellen globalen Transformation und der Seitentransformation dieses <see cref="T:System.Drawing.Graphics" /> aus einem Koordinatenbereich in einen anderen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt zwei Punkte, und eine blaue Linie zwischen diesen zeichnet.  
  
-   Legt fest, die globale Transformation Wert 40 in X-Richtung und 30 in y-Richtung übersetzen.  
  
-   Transformiert die Punkte aus globalen Koordinaten (<xref:System.Drawing.Drawing2D.CoordinateSpace.World>) in Seitenkoordinaten (<xref:System.Drawing.Drawing2D.CoordinateSpace.Page>).  
  
-   Setzt die globale Transformation auf die Identität zurück.  
  
-   Zeichnet eine rote Linie zwischen den transformierten Punkten.  
  
 Das Ergebnis ist eine blaue Linie und eine übersetzte rote Linie darunter.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#163](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#163)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#163](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#163)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#163](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#163)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TransformPoints">
      <MemberSignature Language="C#" Value="public void TransformPoints (System.Drawing.Drawing2D.CoordinateSpace destSpace, System.Drawing.Drawing2D.CoordinateSpace srcSpace, System.Drawing.PointF[] pts);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransformPoints(valuetype System.Drawing.Drawing2D.CoordinateSpace destSpace, valuetype System.Drawing.Drawing2D.CoordinateSpace srcSpace, valuetype System.Drawing.PointF[] pts) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.TransformPoints(System.Drawing.Drawing2D.CoordinateSpace,System.Drawing.Drawing2D.CoordinateSpace,System.Drawing.PointF[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransformPoints (destSpace As CoordinateSpace, srcSpace As CoordinateSpace, pts As PointF())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransformPoints(System::Drawing::Drawing2D::CoordinateSpace destSpace, System::Drawing::Drawing2D::CoordinateSpace srcSpace, cli::array &lt;System::Drawing::PointF&gt; ^ pts);" />
      <MemberSignature Language="F#" Value="member this.TransformPoints : System.Drawing.Drawing2D.CoordinateSpace * System.Drawing.Drawing2D.CoordinateSpace * System.Drawing.PointF[] -&gt; unit" Usage="graphics.TransformPoints (destSpace, srcSpace, pts)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destSpace" Type="System.Drawing.Drawing2D.CoordinateSpace" />
        <Parameter Name="srcSpace" Type="System.Drawing.Drawing2D.CoordinateSpace" />
        <Parameter Name="pts" Type="System.Drawing.PointF[]" />
      </Parameters>
      <Docs>
        <param name="destSpace">Member der <see cref="T:System.Drawing.Drawing2D.CoordinateSpace" />-Enumeration, der den Zielkoordinatenbereich angibt.</param>
        <param name="srcSpace">Member der <see cref="T:System.Drawing.Drawing2D.CoordinateSpace" />-Enumeration, der den Quellkoordinatenbereich angibt.</param>
        <param name="pts">Array von <see cref="T:System.Drawing.PointF" />-Strukturen, die die zu transformierenden Punkte darstellen.</param>
        <summary>Transformiert ein Array von Punkten unter Verwendung der aktuellen globalen Transformation und der Seitentransformation dieses <see cref="T:System.Drawing.Graphics" /> aus einem Koordinatenbereich in einen anderen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt zwei Punkte, und eine blaue Linie zwischen diesen zeichnet.  
  
-   Legt fest, die globale Transformation Wert 40 in X-Richtung und 30 in y-Richtung übersetzen.  
  
-   Transformiert die Punkte aus globalen Koordinaten (<xref:System.Drawing.Drawing2D.CoordinateSpace.World>) in Seitenkoordinaten (<xref:System.Drawing.Drawing2D.CoordinateSpace.Page>).  
  
-   Setzt die globale Transformation auf die Identität zurück und zeichnet eine rote Linie zwischen den transformierten Punkten.  
  
 Das Ergebnis ist eine blaue Linie und eine übersetzte rote Linie darunter.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#164](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#164)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#164](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#164)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#164](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#164)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TranslateClip">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Verschiebt den Ausschneidebereich dieses <see cref="T:System.Drawing.Graphics" /> horizontal und vertikal um die angegebenen Werte.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TranslateClip">
      <MemberSignature Language="C#" Value="public void TranslateClip (int dx, int dy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TranslateClip(int32 dx, int32 dy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.TranslateClip(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TranslateClip (dx As Integer, dy As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TranslateClip(int dx, int dy);" />
      <MemberSignature Language="F#" Value="member this.TranslateClip : int * int -&gt; unit" Usage="graphics.TranslateClip (dx, dy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dx" Type="System.Int32" />
        <Parameter Name="dy" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dx">Die x-Koordinate der Verschiebung.</param>
        <param name="dy">Die y-Koordinate der Verschiebung.</param>
        <summary>Verschiebt den Ausschneidebereich dieses <see cref="T:System.Drawing.Graphics" /> horizontal und vertikal um die angegebenen Werte.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein Rechteck für den Ausschneidebereich.  
  
-   Legt den Ausschneidebereich auf das Rechteck fest.  
  
-   Verschiebt den Ausschneidebereich mit einem Vektor (50, 50).  
  
-   Füllt ein großes Rechteck mit einem schwarzen einfarbigen Pinsel.  
  
 Das Ergebnis ist ein Rechteck übersetzte "," small "," Schwarz.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#165](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#165)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#165](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#165)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#165](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#165)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TranslateClip">
      <MemberSignature Language="C#" Value="public void TranslateClip (float dx, float dy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TranslateClip(float32 dx, float32 dy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.TranslateClip(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TranslateClip (dx As Single, dy As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TranslateClip(float dx, float dy);" />
      <MemberSignature Language="F#" Value="member this.TranslateClip : single * single -&gt; unit" Usage="graphics.TranslateClip (dx, dy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dx" Type="System.Single" />
        <Parameter Name="dy" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="dx">Die x-Koordinate der Verschiebung.</param>
        <param name="dy">Die y-Koordinate der Verschiebung.</param>
        <summary>Verschiebt den Ausschneidebereich dieses <see cref="T:System.Drawing.Graphics" /> horizontal und vertikal um die angegebenen Werte.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein Rechteck für den Ausschneidebereich.  
  
-   Legt den Ausschneidebereich auf das Rechteck fest.  
  
-   Verschiebt den Ausschneidebereich mit einem Vektor (50, 0F, 50,0F).).  
  
-   Füllt ein großes Rechteck mit einem schwarzen einfarbigen Pinsel.  
  
 Das Ergebnis ist ein Rechteck übersetzte "," small "," Schwarz.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#166](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#166)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#166](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#166)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#166](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#166)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TranslateTransform">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ändert den Ursprung des Koordinatensystems, indem die angegebene Verschiebung der Transformationsmatrix dieses <see cref="T:System.Drawing.Graphics" /> vorangestellt wird.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TranslateTransform">
      <MemberSignature Language="C#" Value="public void TranslateTransform (float dx, float dy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TranslateTransform(float32 dx, float32 dy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.TranslateTransform(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TranslateTransform (dx As Single, dy As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TranslateTransform(float dx, float dy);" />
      <MemberSignature Language="F#" Value="member this.TranslateTransform : single * single -&gt; unit" Usage="graphics.TranslateTransform (dx, dy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dx" Type="System.Single" />
        <Parameter Name="dy" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="dx">Die x-Koordinate der Verschiebung.</param>
        <param name="dy">Die y-Koordinate der Verschiebung.</param>
        <summary>Ändert den Ursprung des Koordinatensystems, indem die angegebene Verschiebung der Transformationsmatrix dieses <see cref="T:System.Drawing.Graphics" /> vorangestellt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Ursprung ist in der Regel der linken oberen Ecke der Zeichenoberfläche an.  Besteht aus dem ausdrucksübersetzungsvorgang multipliziert die Transformationsmatrix mit einer Matrix, deren Übersetzung Teil, der `dx` und `dy` Parameter. Diese Methode gilt die Übersetzung durch voranstellen die translationsmatrix an die Transformationsmatrix.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Dreht die globale Transformationsmatrix des Windows-Formulars 30, 0F Grad.  
  
-   Verschiebt den Ursprung des Graphics-Objekts durch Aufrufen von <xref:System.Drawing.Graphics.TranslateTransform%2A>, vorangestellt wird die Verschiebung der Transformationsmatrix.  
  
-   Zeichnet eine übersetzte gedreht Ellipse mit einem blauen Stift.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#167](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#167)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#167](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#167)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#167](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#167)]  
  
 Die folgende Abbildung zeigt die Ausgabe der Ausführung des vorherigen Codebeispiel.  
  
 ![Übersetzte und transformierte Ellipse](~/add/media/ndp-tranlatetransform.png "übersetzte und transformierte Ellipse")  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/9fef7451-bddf-4c68-9350-400d1f1f25a3">Koordinatensysteme und Transformationen</related>
        <related type="Article" href="https://msdn.microsoft.com/library/1f8e18d3-d2f5-460e-a8e3-2da891c301de">Verwenden von Transformationen in Managed GDI+</related>
      </Docs>
    </Member>
    <Member MemberName="TranslateTransform">
      <MemberSignature Language="C#" Value="public void TranslateTransform (float dx, float dy, System.Drawing.Drawing2D.MatrixOrder order);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TranslateTransform(float32 dx, float32 dy, valuetype System.Drawing.Drawing2D.MatrixOrder order) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.TranslateTransform(System.Single,System.Single,System.Drawing.Drawing2D.MatrixOrder)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TranslateTransform (dx As Single, dy As Single, order As MatrixOrder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TranslateTransform(float dx, float dy, System::Drawing::Drawing2D::MatrixOrder order);" />
      <MemberSignature Language="F#" Value="member this.TranslateTransform : single * single * System.Drawing.Drawing2D.MatrixOrder -&gt; unit" Usage="graphics.TranslateTransform (dx, dy, order)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dx" Type="System.Single" />
        <Parameter Name="dy" Type="System.Single" />
        <Parameter Name="order" Type="System.Drawing.Drawing2D.MatrixOrder" />
      </Parameters>
      <Docs>
        <param name="dx">Die x-Koordinate der Verschiebung.</param>
        <param name="dy">Die y-Koordinate der Verschiebung.</param>
        <param name="order">Member der <see cref="T:System.Drawing.Drawing2D.MatrixOrder" />-Enumeration, der angibt, ob die Verschiebung an die Transformationsmatrix angehängt oder dieser vorangestellt wird.</param>
        <summary>Ändert den Ursprung des Koordinatensystems, indem die angegebene Verschiebung zur Transformationsmatrix dieses <see cref="T:System.Drawing.Graphics" /> in der angegebenen Reihenfolge angewendet wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Besteht aus dem ausdrucksübersetzungsvorgang multipliziert die Transformationsmatrix mit einer Matrix, deren Übersetzung Teil, der `dx` und `dy` Parameter. Voran, oder diese Methode fügt die Transformationsmatrix der <xref:System.Drawing.Graphics> durch die translationsmatrix gemäß der `order` Parameter.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs> `e`, ein Parameter von der <xref:System.Windows.Forms.Control.Paint> -Ereignishandler. Der Code führt die folgenden Aktionen aus:  
  
-   Dreht die globale Transformationsmatrix des Windows-Formulars 30, 0F Grad.  
  
-   Verschiebt das Grafikobjekt Ursprung durch Aufrufen von <xref:System.Drawing.Graphics.TranslateTransform%2A>, die Übersetzung an die globale Transformationsmatrix angehängt.  
  
-   Zeichnet eine Ellipse gedrehte, übersetzte mit einem blauen Stift.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#168](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#168)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#168](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#168)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#168](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#168)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/9fef7451-bddf-4c68-9350-400d1f1f25a3">Koordinatensysteme und Transformationen</related>
        <related type="Article" href="https://msdn.microsoft.com/library/1f8e18d3-d2f5-460e-a8e3-2da891c301de">Verwenden von Transformationen in Managed GDI+</related>
      </Docs>
    </Member>
    <Member MemberName="VisibleClipBounds">
      <MemberSignature Language="C#" Value="public System.Drawing.RectangleF VisibleClipBounds { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.RectangleF VisibleClipBounds" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Graphics.VisibleClipBounds" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property VisibleClipBounds As RectangleF" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::RectangleF VisibleClipBounds { System::Drawing::RectangleF get(); };" />
      <MemberSignature Language="F#" Value="member this.VisibleClipBounds : System.Drawing.RectangleF" Usage="System.Drawing.Graphics.VisibleClipBounds" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.RectangleF</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das umschließende Rechteck des sichtbaren Ausschneidebereichs dieses <see cref="T:System.Drawing.Graphics" /> ab.</summary>
        <value>Eine <see cref="T:System.Drawing.RectangleF" />-Struktur, die ein umschließendes Rechteck für den sichtbaren Ausschneidebereich dieses <see cref="T:System.Drawing.Graphics" /> darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Einheit für die sich ergebende Rechteck wird festgelegt, durch die <xref:System.Drawing.Graphics.PageUnit%2A> Eigenschaft. Die Standardeinheit ist Pixel. Ein <xref:System.Drawing.Graphics> in der Regel mit einem Steuerelement zugeordnet ist und der Ursprung des Rechtecks wird relativ zum Clientbereich des Steuerelements.  
  
 Der sichtbare Ausschneidebereich ist die Schnittmenge der Ausschneidebereich dieses <xref:System.Drawing.Graphics> und den Ausschneidebereich des Fensters.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>