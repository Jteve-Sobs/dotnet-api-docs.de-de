<Type Name="Expression&lt;TDelegate&gt;" FullName="System.Linq.Expressions.Expression&lt;TDelegate&gt;">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="2711225af30b344d334264556f3f2446699a2806" />
    <Meta Name="ms.sourcegitcommit" Value="9dda17222b9f7d3edf130133bfb1370d5b410a4b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="09/22/2018" />
    <Meta Name="ms.locfileid" Value="46602822" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Expression&lt;TDelegate&gt; : System.Linq.Expressions.LambdaExpression" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Expression`1&lt;TDelegate&gt; extends System.Linq.Expressions.LambdaExpression" />
  <TypeSignature Language="DocId" Value="T:System.Linq.Expressions.Expression`1" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Expression(Of TDelegate)&#xA;Inherits LambdaExpression" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename TDelegate&gt;&#xA;public ref class Expression sealed : System::Linq::Expressions::LambdaExpression" />
  <TypeSignature Language="F#" Value="type Expression&lt;'Delegate&gt; = class&#xA;    inherit LambdaExpression" />
  <AssemblyInfo>
    <AssemblyName>System.Linq.Expressions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="TDelegate" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Linq.Expressions.LambdaExpression</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <typeparam name="TDelegate">Der Typ des Delegaten, der die <see cref="T:System.Linq.Expressions.Expression`1" /> darstellt.</typeparam>
    <summary>Stellt einen stark typisierten Lambdaausdruck als Datenstruktur in Form einer Ausdrucksbaumstruktur dar. Diese Klasse kann nicht vererbt werden.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein Lambda-Ausdruck zugewiesen wird, um eine Variable, ein Feld oder Parameter, dessen Typ <xref:System.Linq.Expressions.Expression%601>, gibt der Compiler Anweisungen, um eine Ausdrucksbaumstruktur zu erstellen.  
  
> [!NOTE]
>  Eine Konvertierung von einem Lambda-Ausdruck eingeben `Expression<D>` (`Expression(Of D)` in Visual Basic) ist vorhanden, wenn eine Konvertierung von Lambda-Ausdrucks in einen Delegaten vom Typ `D` vorhanden ist. Allerdings kann die Konvertierung, z. B. fehlschlagen, wenn der Text des Lambda-Ausdrucks ein Block ist. Dies bedeutet, dass Delegaten und Ausdrucksbaumstrukturen in Bezug auf die Auflösung von funktionsüberladungen auf ähnliche Weise Verhalten.  
  
 Die Ausdrucksbaumstruktur ist eine Darstellung der Daten im Speicher des Lambda-Ausdrucks. Die Ausdrucksbaumstruktur ist die Struktur des Lambda-Ausdrucks, transparent und explizit. Sie können mit den Daten in der Ausdrucksbaumstruktur interagieren, ebenso wie mit jeder anderen Datenstruktur.  
  
 Die Möglichkeit, Ausdrücke als Datenstrukturen zu behandeln, können APIs, um Benutzercode in einem Format zu erhalten, die überprüft, transformiert und auf benutzerdefinierte Weise verarbeitet werden können. Z. B. die [!INCLUDE[vbtecdlinq](~/includes/vbtecdlinq-md.md)] Data Access-Implementierung verwendet diese Funktion, um Ausdrucksbaumstrukturen mit Transact-SQL-Anweisungen übersetzt werden, die von der Datenbank ausgewertet werden kann.  
  
 Viele Standardabfrageoperatoren, die definiert, der <xref:System.Linq.Queryable> Klasse weisen eine oder mehrere Parameter vom Typ <xref:System.Linq.Expressions.Expression%601>.  
  
 Die <xref:System.Linq.Expressions.Expression.NodeType%2A> von einem <xref:System.Linq.Expressions.Expression%601> ist <xref:System.Linq.Expressions.ExpressionType.Lambda>.  
  
 Verwenden der <xref:System.Linq.Expressions.Expression.Lambda%60%601%28System.Linq.Expressions.Expression%2CSystem.Collections.Generic.IEnumerable%7BSystem.Linq.Expressions.ParameterExpression%7D%29> oder <xref:System.Linq.Expressions.Expression.Lambda%60%601%28System.Linq.Expressions.Expression%2CSystem.Linq.Expressions.ParameterExpression%5B%5D%29> Methode zum Erstellen einer <xref:System.Linq.Expressions.Expression%601> Objekt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie einen Lambda-Ausdruck als ausführbarer Code in Form eines Delegaten und als Daten in Form einer Ausdrucksbaumstruktur dargestellt wird. Außerdem wird veranschaulicht, wie die Ausdrucksbaumstruktur in ausführbaren Code mithilfe von wieder aktivieren die <xref:System.Linq.Expressions.Expression%601.Compile%2A> Methode.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.ExpressionT/CS/ExpressionT.cs#1)]
 [!code-vb[System.Linq.Expressions.ExpressionT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.ExpressionT/VB/ExpressionT.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/csharp/programming-guide/statements-expressions-operators/lambda-expressions.md">Lambda-Ausdrücke (C#-Programmierhandbuch)</related>
    <related type="Article" href="http://msdn.microsoft.com/library/fb1d3ed8-d5b0-4211-a71f-dd271529294b">Expression Trees</related>
  </Docs>
  <Members>
    <Member MemberName="Accept">
      <MemberSignature Language="C#" Value="protected internal override System.Linq.Expressions.Expression Accept (System.Linq.Expressions.ExpressionVisitor visitor);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance class System.Linq.Expressions.Expression Accept(class System.Linq.Expressions.ExpressionVisitor visitor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression`1.Accept(System.Linq.Expressions.ExpressionVisitor)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Function Accept (visitor As ExpressionVisitor) As Expression" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override System::Linq::Expressions::Expression ^ Accept(System::Linq::Expressions::ExpressionVisitor ^ visitor);" />
      <MemberSignature Language="F#" Value="override this.Accept : System.Linq.Expressions.ExpressionVisitor -&gt; System.Linq.Expressions.Expression" Usage="expression.Accept visitor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="visitor" Type="System.Linq.Expressions.ExpressionVisitor" />
      </Parameters>
      <Docs>
        <param name="visitor">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Compile">
      <MemberSignature Language="C#" Value="public TDelegate Compile ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !TDelegate Compile() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression`1.Compile" />
      <MemberSignature Language="VB.NET" Value="Public Function Compile () As TDelegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TDelegate Compile();" />
      <MemberSignature Language="F#" Value="override this.Compile : unit -&gt; 'Delegate" Usage="expression.Compile " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TDelegate</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Kompiliert den von der Ausdrucksbaumstruktur beschriebenen Lambda-Ausdruck in ausführbaren Code und erzeugt einen Delegaten, der den Lambda-Ausdruck darstellt.</summary>
        <returns>Ein Delegat vom Typ <paramref name="TDelegate" />, der den vom <see cref="T:System.Linq.Expressions.Expression`1" /> beschriebenen kompilierten Lambda-Ausdruck darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Expressions.Expression%601.Compile%2A> Methode erzeugt einen Delegaten vom Typ `TDelegate` zur Laufzeit. Wenn dieser Delegat ausgeführt wird, haben sie das von der Semantik der beschriebene Verhalten der <xref:System.Linq.Expressions.Expression%601>.  
  
 Die <xref:System.Linq.Expressions.Expression%601.Compile%2A> Methode kann verwendet werden, um den Wert der jede beliebige Ausdrucksbaumstruktur abzurufen. Erstellen Sie zunächst einen Lambda-Ausdruck, die den Ausdruck als Text mithilfe der <xref:System.Linq.Expressions.Expression.Lambda%2A> Methode. Rufen Sie anschließend <xref:System.Linq.Expressions.Expression%601.Compile%2A> zum Abrufen eines Delegaten und führen Sie den Delegaten, um den Wert des Ausdrucks abzurufen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Expressions.Expression%601.Compile%2A> wird verwendet, um eine Ausdrucksbaumstruktur ausgeführt wird.  
  
 [!code-csharp[System.Linq.Expressions.ExpressionT#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Expressions.ExpressionT/CS/ExpressionT.cs#2)]
 [!code-vb[System.Linq.Expressions.ExpressionT#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Expressions.ExpressionT/VB/ExpressionT.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Compile">
      <MemberSignature Language="C#" Value="public TDelegate Compile (bool preferInterpretation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !TDelegate Compile(bool preferInterpretation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression`1.Compile(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Compile (preferInterpretation As Boolean) As TDelegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TDelegate Compile(bool preferInterpretation);" />
      <MemberSignature Language="F#" Value="override this.Compile : bool -&gt; 'Delegate" Usage="expression.Compile preferInterpretation" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netstandard-2.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TDelegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="preferInterpretation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="preferInterpretation">
          <see langword="true" />, um anzugeben, dass der Ausdruck in ein interpretiertes Format kompiliert werden muss, sofern verfügbar; andernfalls <see langword="false" />.</param>
        <summary>Kompiliert die Lambdaausdrücke, die von der Ausdrucksbaumstruktur als interpretierter oder kompilierter Code beschrieben werden, und erzeugt einen Delegaten, der den Lambdaausdruck darstellt.</summary>
        <returns>Ein Delegat, der den kompilierten Lambdaausdruck darstellt, der durch das <see cref="T:System.Linq.Expressions.Expression`1" />-Objekt beschrieben wird.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Compile">
      <MemberSignature Language="C#" Value="public TDelegate Compile (System.Runtime.CompilerServices.DebugInfoGenerator debugInfoGenerator);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !TDelegate Compile(class System.Runtime.CompilerServices.DebugInfoGenerator debugInfoGenerator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression`1.Compile(System.Runtime.CompilerServices.DebugInfoGenerator)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TDelegate Compile(System::Runtime::CompilerServices::DebugInfoGenerator ^ debugInfoGenerator);" />
      <MemberSignature Language="F#" Value="override this.Compile : System.Runtime.CompilerServices.DebugInfoGenerator -&gt; 'Delegate" Usage="expression.Compile debugInfoGenerator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TDelegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="debugInfoGenerator" Type="System.Runtime.CompilerServices.DebugInfoGenerator" />
      </Parameters>
      <Docs>
        <param name="debugInfoGenerator">Generator für Debuginformationen, mit dem der Compiler Sequenzpunkte markiert und lokale Variablen mit Anmerkungen versieht.</param>
        <summary>Erzeugt einen Delegaten, der den Lambdaausdruck darstellt.</summary>
        <returns>Ein Delegat, der die kompilierte Version des Lambdaausdrucks enthält.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Update">
      <MemberSignature Language="C#" Value="public System.Linq.Expressions.Expression&lt;TDelegate&gt; Update (System.Linq.Expressions.Expression body, System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Linq.Expressions.Expression`1&lt;!TDelegate&gt; Update(class System.Linq.Expressions.Expression body, class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.Expressions.ParameterExpression&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.Expression`1.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})" />
      <MemberSignature Language="VB.NET" Value="Public Function Update (body As Expression, parameters As IEnumerable(Of ParameterExpression)) As Expression(Of TDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Linq::Expressions::Expression&lt;TDelegate&gt; ^ Update(System::Linq::Expressions::Expression ^ body, System::Collections::Generic::IEnumerable&lt;System::Linq::Expressions::ParameterExpression ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.Update : System.Linq.Expressions.Expression * seq&lt;System.Linq.Expressions.ParameterExpression&gt; -&gt; System.Linq.Expressions.Expression&lt;'Delegate&gt;" Usage="expression.Update (body, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;TDelegate&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="System.Linq.Expressions.Expression" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IEnumerable&lt;System.Linq.Expressions.ParameterExpression&gt;" />
      </Parameters>
      <Docs>
        <param name="body">Die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft des Ergebnisses.</param>
        <param name="parameters">Die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Eigenschaft des Ergebnisses.</param>
        <summary>Erstellt einen neuen Ausdruck, der diesem ähnelt, verwendet jedoch die angegebenen untergeordneten Elemente. Wenn alle untergeordneten Elemente identisch sind, wird dieser Ausdruck zurückgegeben.</summary>
        <returns>Dieser Ausdruck, wenn keine untergeordneten Elemente geändert werden, oder ein Ausdruck mit den aktualisierten untergeordneten Elementen.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>