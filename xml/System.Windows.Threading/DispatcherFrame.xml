<Type Name="DispatcherFrame" FullName="System.Windows.Threading.DispatcherFrame">
  <Metadata><Meta Name="ms.openlocfilehash" Value="ae52d5e0c9e229bf309b8c34559ca8ecdb4ac70b" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69445824" /></Metadata><TypeSignature Language="C#" Value="public class DispatcherFrame : System.Windows.Threading.DispatcherObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi DispatcherFrame extends System.Windows.Threading.DispatcherObject" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Threading.DispatcherFrame" />
  <TypeSignature Language="VB.NET" Value="Public Class DispatcherFrame&#xA;Inherits DispatcherObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class DispatcherFrame : System::Windows::Threading::DispatcherObject" />
  <TypeSignature Language="F#" Value="type DispatcherFrame = class&#xA;    inherit DispatcherObject" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Threading.DispatcherObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Stellt eine Ausführungsschleife im <see cref="T:System.Windows.Threading.Dispatcher" /> dar.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Threading.DispatcherFrame>Objekte werden in der Regel in zwei Kategorien unterteilt:  
  
-   Lange laufende, allgemeine Frames, die nur beendet werden, wenn an die Anweisung übergeben wird.  Diese Frames sollten beendet werden, wenn Sie angefordert werden.  
  
-   Kurze laufende, sehr spezifische Frames, die beendet werden, wenn ein wichtiges Kriterium erfüllt ist.  Diese Frames werden möglicherweise nicht beendet, wenn Sie angefordert werden, um zu warten, bis Ihre Beendigungs Kriterien erfüllt werden.  Diesen Frames sollte ein Timeout zugeordnet sein.  
  
<a name="xamlTextUsage_DispatcherFrame"></a>   
## <a name="xaml-text-usage"></a>Verwendung von XAML-Text  
 Diese verwaltete Klasse kann nicht in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]verwendet werden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie ein <xref:System.Windows.Threading.DispatcherFrame> verwendet wird, um ähnliche Ergebnisse [!INCLUDE[TLA#tla_winforms](~/includes/tlasharptla-winforms-md.md)] wie die <xref:System.Windows.Forms.Application.DoEvents%2A> -Methode zu erzielen.  
  
 [!code-csharp[dispatchersnippets#DispatcherDispatcherFrameDoEvents](~/samples/snippets/csharp/VS_Snippets_Wpf/DispatcherSnippets/CSharp/Window1.xaml.cs#dispatcherdispatcherframedoevents)]
 [!code-vb[dispatchersnippets#DispatcherDispatcherFrameDoEvents](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DispatcherSnippets/visualbasic/window1.xaml.vb#dispatcherdispatcherframedoevents)]  
  
 ]]></format>
    </remarks>
    <altmember cref="M:System.Windows.Threading.Dispatcher.PushFrame(System.Windows.Threading.DispatcherFrame)" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Threading.DispatcherFrame" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DispatcherFrame ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.DispatcherFrame.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DispatcherFrame();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Threading.DispatcherFrame" />-Klasse.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Threading.Dispatcher.PushFrame(System.Windows.Threading.DispatcherFrame)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DispatcherFrame (bool exitWhenRequested);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool exitWhenRequested) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.DispatcherFrame.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (exitWhenRequested As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DispatcherFrame(bool exitWhenRequested);" />
      <MemberSignature Language="F#" Value="new System.Windows.Threading.DispatcherFrame : bool -&gt; System.Windows.Threading.DispatcherFrame" Usage="new System.Windows.Threading.DispatcherFrame exitWhenRequested" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="exitWhenRequested" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="exitWhenRequested">Gibt an, ob dieser Frame beendet wird, wenn alle Frames eine Beendigungsaufforderung erhalten.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Threading.DispatcherFrame" />-Klasse mit dem angegebenen Flag für eine Beendigungsanforderung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<xref:System.Windows.Threading.DispatcherFrame>in der Regel in zwei Kategorien unterteilt:

- Lange laufende, allgemeine Frames, die nur beendet werden, wenn an die Anweisung übergeben wird. Diese Frames sollten beendet werden, wenn Sie angefordert werden.

- Kurze laufende, sehr spezifische Frames, die beendet werden, wenn ein wichtiges Kriterium erfüllt ist. Diese Frames werden möglicherweise nicht beendet, wenn Sie angefordert werden, um zu warten, bis Ihre Beendigungs Kriterien erfüllt werden.  Diesen Frames sollte ein Timeout zugeordnet sein.

Beim Herunterfahren der Anwendung werden alle Frames zum Beenden aufgefordert.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Threading.Dispatcher.PushFrame(System.Windows.Threading.DispatcherFrame)" />
      </Docs>
    </Member>
    <Member MemberName="Continue">
      <MemberSignature Language="C#" Value="public bool Continue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Continue" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Threading.DispatcherFrame.Continue" />
      <MemberSignature Language="VB.NET" Value="Public Property Continue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Continue { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Continue : bool with get, set" Usage="System.Windows.Threading.DispatcherFrame.Continue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, mit dem angegeben wird, ob dieser <see cref="T:System.Windows.Threading.DispatcherFrame" /> fortgesetzt werden soll, oder legt diesen Wert fest.</summary>
        <value><see langword="true" />, wenn der Frame fortgesetzt werden soll, andernfalls <see langword="false" />.  Der Standardwert ist <see langword="true" />sein.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Threading.DispatcherFrame.Continue%2A>wird am Anfang jeder Verteiler-Schleife abgefragt.  
  
 Beim Herunterfahren der Anwendung werden alle Frames zum Beenden aufgefordert.  
  
<a name="xamlTextUsage_Continue"></a>   
## <a name="xaml-text-usage"></a>Verwendung von XAML-Text  
 Member dieser Klasse werden in der Regel nicht in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]verwendet oder können nicht in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]verwendet werden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie ein <xref:System.Windows.Threading.DispatcherFrame> verwendet wird, um ähnliche Ergebnisse [!INCLUDE[TLA#tla_winforms](~/includes/tlasharptla-winforms-md.md)] wie die <xref:System.Windows.Forms.Application.DoEvents%2A> -Methode zu erzielen.  
  
 [!code-csharp[dispatchersnippets#DispatcherDispatcherFrameDoEvents](~/samples/snippets/csharp/VS_Snippets_Wpf/DispatcherSnippets/CSharp/Window1.xaml.cs#dispatcherdispatcherframedoevents)]
 [!code-vb[dispatchersnippets#DispatcherDispatcherFrameDoEvents](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DispatcherSnippets/visualbasic/window1.xaml.vb#dispatcherdispatcherframedoevents)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Threading.Dispatcher.PushFrame(System.Windows.Threading.DispatcherFrame)" />
      </Docs>
    </Member>
  </Members>
</Type>
