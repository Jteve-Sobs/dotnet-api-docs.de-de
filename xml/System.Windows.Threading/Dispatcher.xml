<Type Name="Dispatcher" FullName="System.Windows.Threading.Dispatcher">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="241fd0ba7a347cff7d7803a0904f74473d27fbc8" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36464419" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Dispatcher" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed Dispatcher extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Threading.Dispatcher" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Dispatcher" />
  <TypeSignature Language="C++ CLI" Value="public ref class Dispatcher sealed" />
  <TypeSignature Language="F#" Value="type Dispatcher = class" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Provides services for managing the queue of work items for a thread.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Threading.Dispatcher> verwaltet eine priorisierte Warteschlange von Arbeitsaufgaben für einen bestimmten Thread.  
  
 Wenn eine <xref:System.Windows.Threading.Dispatcher> wird erstellt in einem Thread wird nur <xref:System.Windows.Threading.Dispatcher> , dem Thread zugeordnet werden kann auch dann, wenn die <xref:System.Windows.Threading.Dispatcher> wird heruntergefahren.  
  
 Wenn Sie versuchen, erhalten die <xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A> für den aktuellen Thread und einem <xref:System.Windows.Threading.Dispatcher> ist nicht mit dem Thread zugeordneten eine <xref:System.Windows.Threading.Dispatcher> erstellt werden. Ein <xref:System.Windows.Threading.Dispatcher> wird auch erstellt, bei der Erstellung einer <xref:System.Windows.Threading.DispatcherObject>. Wenn Sie erstellen eine <xref:System.Windows.Threading.Dispatcher> in einem Hintergrundthread werden sicher, dass der Verteiler Herunterfahren, bevor der Thread wird beendet.  
  
 Wenn eine <xref:System.Windows.Threading.Dispatcher> beendet wird, er kann nicht neu gestartet werden.  
  
 In [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], <xref:System.Windows.Threading.DispatcherObject> kann nur zugegriffen werden, indem die <xref:System.Windows.Threading.Dispatcher> er zugeordnet ist.  Beispielsweise kann kein Hintergrundthread aktualisiert den Inhalt des eine <xref:System.Windows.Controls.Button> zugeordneten der <xref:System.Windows.Threading.Dispatcher> auf die [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] Thread.  In der Hintergrundthread, den Zugriff auf die <xref:System.Windows.Controls.ContentControl.Content%2A> Eigenschaft von der <xref:System.Windows.Controls.Button>, der Hintergrundthread die Verarbeitung zur delegieren muss die <xref:System.Windows.Threading.Dispatcher> zugeordnet der [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] Thread.  Dies wird erreicht, indem Sie entweder <xref:System.Windows.Threading.Dispatcher.Invoke%2A> oder <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>. <xref:System.Windows.Threading.Dispatcher.Invoke%2A> ist synchron und <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> asynchron ist.  Der Vorgang wird hinzugefügt, in die Warteschlange des der <xref:System.Windows.Threading.Dispatcher> an der angegebenen <xref:System.Windows.Threading.DispatcherPriority>.  
  
 Wenn <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> aufgerufen wird, auf eine <xref:System.Windows.Threading.Dispatcher> , die heruntergefahren wurde, der Status-Eigenschaft des zurückgegebenen <xref:System.Windows.Threading.DispatcherOperation> festgelegt ist, um <xref:System.Windows.Threading.DispatcherOperationStatus.Aborted>.  
  
 Alle Methoden auf <xref:System.Windows.Threading.Dispatcher>, mit Ausnahme von <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A>, Freethread-sind.  
  
 Objekte, die Ableitung <xref:System.Windows.Threading.DispatcherObject> Threadaffinität.  
  
 Objekte, die Ableitung <xref:System.Windows.Freezable> sind Freethread-Wenn sie fixiert werden.  Weitere Informationen finden Sie unter der [Übersicht über Freezable-Objekte](~/docs/framework/wpf/advanced/freezable-objects-overview.md).  
  
   
  
## Examples  
 Im folgende Beispiel wird gezeigt, wie an eine Operation auf eine <xref:System.Windows.Threading.Dispatcher>.  Der vollständige Quellcode dieses Beispiels, finden Sie unter [Singlethread-Anwendung mit der lang andauernde Berechnung Beispiel](http://go.microsoft.com/fwlink/?LinkID=160038).  
  
 Zuerst wird ein Delegat erstellt, die keine Argumente akzeptiert.  
  
 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberInit](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberinit)] 
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberInit](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberinit)]   
  
 Als Nächstes <xref:System.Windows.Threading.Dispatcher.BeginInvoke%28System.Windows.Threading.DispatcherPriority%2CSystem.Delegate%29> aufgerufen wird.  Dieser Aufruf <xref:System.Windows.Threading.Dispatcher.BeginInvoke%28System.Windows.Threading.DispatcherPriority%2CSystem.Delegate%29> akzeptiert zwei Parameter: die Priorität, die festgelegt wird, dass <xref:System.Windows.Threading.DispatcherPriority.Normal?displayProperty=nameWithType>, und der Rückruf, der über eine Instanz des Delegaten übergeben wird `NextPrimeDelegate`.  
  
 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberBeginInvoke](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberbegininvoke)] 
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberBeginInvoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberbegininvoke)]   
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName="BeginInvoke">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Executes a delegate asynchronously on the thread the <see cref="T:System.Windows.Threading.Dispatcher" /> is associated with.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], Threads, der erstellt eine <xref:System.Windows.Threading.DispatcherObject> kann dieses Objekt zugreifen.  Z. B. ein Hintergrundthread, der aus dem Hauptbenutzeroberflächen-Thread eröffnet kann nicht den Inhalt des aktualisiert eine <xref:System.Windows.Controls.Button> , die im UI-Thread erstellt wurde.  In der Reihenfolge des Hintergrundthreads, die Content-Eigenschaft für den Zugriff auf die <xref:System.Windows.Controls.Button>, der Hintergrundthread die Verarbeitung zur delegieren muss die <xref:System.Windows.Threading.Dispatcher> im UI-Thread zugeordnet.  Dies wird erreicht, indem Sie entweder <xref:System.Windows.Threading.Dispatcher.Invoke%2A> oder <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> ist synchron und <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> asynchron ist.  Der Vorgang wird hinzugefügt, auf die Ereigniswarteschlange von der <xref:System.Windows.Threading.Dispatcher> an der angegebenen <xref:System.Windows.Threading.DispatcherPriority>.  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> ist asynchron. aus diesem Grund gibt Steuerelement sofort an das aufrufende Objekt zurück, nachdem er aufgerufen wird.  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> Gibt eine <xref:System.Windows.Threading.DispatcherOperation> -Objekt, das verwendet werden kann, um die Interaktion mit dem Delegaten, wenn der Delegat in der Warteschlange befindet.  
  
 Die <xref:System.Windows.Threading.DispatcherOperation> zurückgegebenes Objekt <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> können auf verschiedene Weise für die Interaktion mit den angegebenen Delegaten verwendet werden:  
  
-   Ändern der <xref:System.Windows.Threading.DispatcherPriority> des Delegaten entspricht ausstehende Ausführung im Ereignis in die Warteschlange.  
  
-   Entfernen den Delegaten aus der Ereigniswarteschlange.  
  
-   Es wird darauf gewartet, dass der Delegat zurückgegeben.  
  
-   Abrufen des Werts, die der Delegat, nachdem er zurückgegeben ausgeführt wird.  
  
 Wenn mehrere <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> Aufrufe gleichzeitig <xref:System.Windows.Threading.DispatcherPriority>, werden sie in der Reihenfolge der Aufrufe wurden ausgeführt.  
  
 Wenn <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> aufgerufen wird, auf eine <xref:System.Windows.Threading.Dispatcher> , die heruntergefahren wurde, der Status-Eigenschaft des zurückgegebenen <xref:System.Windows.Threading.DispatcherOperation> festgelegt ist, um <xref:System.Windows.Threading.DispatcherOperationStatus.Aborted>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginInvoke">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation BeginInvoke (Delegate method, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation BeginInvoke(class System.Delegate method, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.BeginInvoke(System.Delegate,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginInvoke (method As Delegate, ParamArray args As Object()) As DispatcherOperation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Threading::DispatcherOperation ^ BeginInvoke(Delegate ^ method, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.BeginInvoke : Delegate * obj[] -&gt; System.Windows.Threading.DispatcherOperation" Usage="dispatcher.BeginInvoke (method, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method">The delegate to a method that takes parameters specified in <c>args</c>, which is pushed onto the <see cref="T:System.Windows.Threading.Dispatcher" /> event queue.</param>
        <param name="args">An array of objects to pass as arguments to the given method. Can be <see langword="null" />.</param>
        <summary>Executes the specified delegate asynchronously with the specified arguments on the thread that the <see cref="T:System.Windows.Threading.Dispatcher" /> was created on.</summary>
        <returns>An object, which is returned immediately after <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" /> is called, that can be used to interact with the delegate as it is pending execution in the event queue.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Threading.DispatcherOperation> zurückgegebenes Objekt <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> können auf verschiedene Weise für die Interaktion mit den angegebenen Delegaten verwendet werden:  
  
-   Ändern der <xref:System.Windows.Threading.DispatcherPriority> des Delegaten entspricht ausstehende Ausführung im Ereignis in die Warteschlange.  
  
-   Entfernen den Delegaten aus der Ereigniswarteschlange.  
  
-   Es wird darauf gewartet, dass der Delegat zurückgegeben.  
  
-   Abrufen des Werts, die der Delegat, nachdem er zurückgegeben ausgeführt wird.  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> ist asynchron. aus diesem Grund gibt Steuerelement sofort an das aufrufende Objekt zurück, nachdem er aufgerufen wird.  
  
 In [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], Threads, der erstellt eine <xref:System.Windows.Threading.DispatcherObject> kann dieses Objekt zugreifen. Z. B. ein Hintergrundthread, der aus dem Hauptbenutzeroberflächen-Thread eröffnet kann nicht den Inhalt des aktualisiert eine <xref:System.Windows.Controls.Button> , die im UI-Thread erstellt wurde. In der Reihenfolge des Hintergrundthreads, die Content-Eigenschaft für den Zugriff auf die <xref:System.Windows.Controls.Button>, der Hintergrundthread die Verarbeitung zur delegieren muss die <xref:System.Windows.Threading.Dispatcher> im UI-Thread zugeordnet. Dies wird erreicht, indem Sie entweder <xref:System.Windows.Threading.Dispatcher.Invoke%2A> oder <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>. <xref:System.Windows.Threading.Dispatcher.Invoke%2A> ist synchron und <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> asynchron ist. Der Vorgang wird hinzugefügt, auf die Ereigniswarteschlange von der <xref:System.Windows.Threading.Dispatcher> an der angegebenen <xref:System.Windows.Threading.DispatcherPriority>.  
  
 Wenn <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> aufgerufen wird, auf eine <xref:System.Windows.Threading.Dispatcher> , die heruntergefahren wurde, der Status-Eigenschaft des zurückgegebenen <xref:System.Windows.Threading.DispatcherOperation> festgelegt ist, um <xref:System.Windows.Threading.DispatcherOperationStatus.Aborted>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginInvoke">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation BeginInvoke (System.Windows.Threading.DispatcherPriority priority, Delegate method);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation BeginInvoke(valuetype System.Windows.Threading.DispatcherPriority priority, class System.Delegate method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginInvoke (priority As DispatcherPriority, method As Delegate) As DispatcherOperation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Threading::DispatcherOperation ^ BeginInvoke(System::Windows::Threading::DispatcherPriority priority, Delegate ^ method);" />
      <MemberSignature Language="F#" Value="member this.BeginInvoke : System.Windows.Threading.DispatcherPriority * Delegate -&gt; System.Windows.Threading.DispatcherOperation" Usage="dispatcher.BeginInvoke (priority, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="method" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="priority">The priority, relative to the other pending operations in the <see cref="T:System.Windows.Threading.Dispatcher" /> event queue, the specified method is invoked.</param>
        <param name="method">The delegate to a method that takes no arguments, which is pushed onto the <see cref="T:System.Windows.Threading.Dispatcher" /> event queue.</param>
        <summary>Executes the specified delegate asynchronously at the specified priority on the thread the <see cref="T:System.Windows.Threading.Dispatcher" /> is associated with.</summary>
        <returns>An object, which is returned immediately after <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" /> is called, that can be used to interact with the delegate as it is pending execution in the event queue.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn mehrere <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> Aufrufe gleichzeitig <xref:System.Windows.Threading.DispatcherPriority>, werden sie in der Reihenfolge der Aufrufe wurden ausgeführt.  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> Gibt eine <xref:System.Windows.Threading.DispatcherOperation> -Objekt, das verwendet werden kann, um die Interaktion mit dem Delegaten, wenn der Delegat in der Warteschlange befindet.  
  
 Die <xref:System.Windows.Threading.DispatcherOperation> zurückgegebenes Objekt <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> können auf verschiedene Weise für die Interaktion mit den angegebenen Delegaten verwendet werden:  
  
-   Ändern der <xref:System.Windows.Threading.DispatcherPriority> des Delegaten entspricht ausstehende Ausführung im Ereignis in die Warteschlange.  
  
-   Entfernen den Delegaten aus der Ereigniswarteschlange.  
  
-   Es wird darauf gewartet, dass der Delegat zurückgegeben.  
  
-   Abrufen des Werts, die der Delegat, nachdem er zurückgegeben ausgeführt wird.  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> ist asynchron. aus diesem Grund gibt Steuerelement sofort an das aufrufende Objekt zurück, nachdem er aufgerufen wird.  
  
 In [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], Threads, der erstellt eine <xref:System.Windows.Threading.DispatcherObject> kann dieses Objekt zugreifen.  Z. B. ein Hintergrundthread, der aus dem Hauptbenutzeroberflächen-Thread eröffnet kann nicht den Inhalt des aktualisiert eine <xref:System.Windows.Controls.Button> , die im UI-Thread erstellt wurde.  In der Reihenfolge des Hintergrundthreads, die Content-Eigenschaft für den Zugriff auf die <xref:System.Windows.Controls.Button>, der Hintergrundthread die Verarbeitung zur delegieren muss die <xref:System.Windows.Threading.Dispatcher> im UI-Thread zugeordnet.  Dies wird erreicht, indem Sie entweder <xref:System.Windows.Threading.Dispatcher.Invoke%2A> oder <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> ist synchron und <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> asynchron ist.  Der Vorgang wird hinzugefügt, auf die Ereigniswarteschlange von der <xref:System.Windows.Threading.Dispatcher> an der angegebenen <xref:System.Windows.Threading.DispatcherPriority>.  
  
 Wenn <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> aufgerufen wird, auf eine <xref:System.Windows.Threading.Dispatcher> , die heruntergefahren wurde, der Status-Eigenschaft des zurückgegebenen <xref:System.Windows.Threading.DispatcherOperation> festgelegt ist, um <xref:System.Windows.Threading.DispatcherOperationStatus.Aborted>.  
  
   
  
## Examples  
 Im folgende Beispiel wird gezeigt, wie an eine Operation auf eine <xref:System.Windows.Threading.Dispatcher>.  Der vollständige Quellcode dieses Beispiels, finden Sie unter [Singlethread-Anwendung mit der lang andauernde Berechnung Beispiel](http://go.microsoft.com/fwlink/?LinkID=160038).  
  
 Zuerst wird ein Delegat erstellt, die keine Argumente akzeptiert.  
  
 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberInit](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberinit)] 
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberInit](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberinit)]   
  
 Als Nächstes <xref:System.Windows.Threading.Dispatcher.BeginInvoke%28System.Windows.Threading.DispatcherPriority%2CSystem.Delegate%29> aufgerufen wird.  Da jede <xref:System.Windows.Threading.DispatcherObject> verfügt über eine Eigenschaft, die zurückgibt der <xref:System.Windows.Threading.Dispatcher> zugeordnet ist, den gewünschten <xref:System.Windows.Threading.Dispatcher> erhalten, indem Sie Abfragen der <xref:System.Windows.Threading.DispatcherObject>, in diesem Fall eine <xref:System.Windows.Controls.Button> mit dem Namen `startStopButton`.   Der Aufruf von <xref:System.Windows.Threading.Dispatcher.BeginInvoke%28System.Windows.Threading.DispatcherPriority%2CSystem.Delegate%29> akzeptiert zwei Parameter: die Priorität, die festgelegt wird, dass <xref:System.Windows.Threading.DispatcherPriority.Normal?displayProperty=nameWithType>, und der Rückruf, der über eine Instanz des Delegaten übergeben wird `NextPrimeDelegate`.  
  
 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberBeginInvoke](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberbegininvoke)] 
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberBeginInvoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberbegininvoke)]   
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="priority" /> is not a valid <see cref="T:System.Windows.Threading.DispatcherPriority" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginInvoke">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation BeginInvoke (Delegate method, System.Windows.Threading.DispatcherPriority priority, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation BeginInvoke(class System.Delegate method, valuetype System.Windows.Threading.DispatcherPriority priority, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.BeginInvoke(System.Delegate,System.Windows.Threading.DispatcherPriority,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginInvoke (method As Delegate, priority As DispatcherPriority, ParamArray args As Object()) As DispatcherOperation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Threading::DispatcherOperation ^ BeginInvoke(Delegate ^ method, System::Windows::Threading::DispatcherPriority priority, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.BeginInvoke : Delegate * System.Windows.Threading.DispatcherPriority * obj[] -&gt; System.Windows.Threading.DispatcherOperation" Usage="dispatcher.BeginInvoke (method, priority, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method">The delegate to a method that takes parameters specified in <c>args</c>, which is pushed onto the <see cref="T:System.Windows.Threading.Dispatcher" /> event queue.</param>
        <param name="priority">The priority, relative to the other pending operations in the <see cref="T:System.Windows.Threading.Dispatcher" /> event queue, the specified method is invoked.</param>
        <param name="args">An array of objects to pass as arguments to the given method. Can be <see langword="null" />.</param>
        <summary>Executes the specified delegate asynchronously with the specified arguments, at the specified priority, on the thread that the <see cref="T:System.Windows.Threading.Dispatcher" /> was created on.</summary>
        <returns>An object, which is returned immediately after <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" /> is called, that can be used to interact with the delegate as it is pending execution in the event queue.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Threading.DispatcherOperation> zurückgegebenes Objekt <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> können auf verschiedene Weise für die Interaktion mit den angegebenen Delegaten verwendet werden:  
  
-   Ändern der <xref:System.Windows.Threading.DispatcherPriority> des Delegaten entspricht ausstehende Ausführung im Ereignis in die Warteschlange.  
  
-   Entfernen den Delegaten aus der Ereigniswarteschlange.  
  
-   Es wird darauf gewartet, dass der Delegat zurückgegeben.  
  
-   Abrufen des Werts, die der Delegat, nachdem er zurückgegeben ausgeführt wird.  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> ist asynchron. aus diesem Grund gibt Steuerelement sofort an das aufrufende Objekt zurück, nachdem er aufgerufen wird.  
  
 In [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], Threads, der erstellt eine <xref:System.Windows.Threading.DispatcherObject> kann dieses Objekt zugreifen. Z. B. ein Hintergrundthread, der aus dem Hauptbenutzeroberflächen-Thread eröffnet kann nicht den Inhalt des aktualisiert eine <xref:System.Windows.Controls.Button> , die im UI-Thread erstellt wurde. In der Reihenfolge des Hintergrundthreads, die Content-Eigenschaft für den Zugriff auf die <xref:System.Windows.Controls.Button>, der Hintergrundthread die Verarbeitung zur delegieren muss die <xref:System.Windows.Threading.Dispatcher> im UI-Thread zugeordnet. Dies wird erreicht, indem Sie entweder <xref:System.Windows.Threading.Dispatcher.Invoke%2A> oder <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>. <xref:System.Windows.Threading.Dispatcher.Invoke%2A> ist synchron und <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> asynchron ist. Der Vorgang wird hinzugefügt, auf die Ereigniswarteschlange von der <xref:System.Windows.Threading.Dispatcher> an der angegebenen <xref:System.Windows.Threading.DispatcherPriority>.  
  
 Wenn <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> aufgerufen wird, auf eine <xref:System.Windows.Threading.Dispatcher> , die heruntergefahren wurde, der Status-Eigenschaft des zurückgegebenen <xref:System.Windows.Threading.DispatcherOperation> festgelegt ist, um <xref:System.Windows.Threading.DispatcherOperationStatus.Aborted>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginInvoke">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation BeginInvoke (System.Windows.Threading.DispatcherPriority priority, Delegate method, object arg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation BeginInvoke(valuetype System.Windows.Threading.DispatcherPriority priority, class System.Delegate method, object arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginInvoke (priority As DispatcherPriority, method As Delegate, arg As Object) As DispatcherOperation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Threading::DispatcherOperation ^ BeginInvoke(System::Windows::Threading::DispatcherPriority priority, Delegate ^ method, System::Object ^ arg);" />
      <MemberSignature Language="F#" Value="member this.BeginInvoke : System.Windows.Threading.DispatcherPriority * Delegate * obj -&gt; System.Windows.Threading.DispatcherOperation" Usage="dispatcher.BeginInvoke (priority, method, arg)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="arg" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="priority">The priority, relative to the other pending operations in the <see cref="T:System.Windows.Threading.Dispatcher" /> event queue, the specified method is invoked.</param>
        <param name="method">A delegate to a method that takes one argument, which is pushed onto the <see cref="T:System.Windows.Threading.Dispatcher" /> event queue.</param>
        <param name="arg">The object to pass as an argument to the specified method.</param>
        <summary>Executes the specified delegate asynchronously at the specified priority and with the specified argument on the thread the <see cref="T:System.Windows.Threading.Dispatcher" /> is associated with.</summary>
        <returns>An object, which is returned immediately after <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" /> is called, that can be used to interact with the delegate as it is pending execution in the event queue.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Arg` kann `null` Wenn keine Argumente benötigt werden.  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> Gibt eine <xref:System.Windows.Threading.DispatcherOperation> -Objekt, das verwendet werden kann, um die Interaktion mit dem Delegaten, wenn der Delegat in der Warteschlange befindet.  
  
 Die <xref:System.Windows.Threading.DispatcherOperation> zurückgegebenes Objekt <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> können auf verschiedene Weise für die Interaktion mit den angegebenen Delegaten verwendet werden:  
  
-   Ändern der <xref:System.Windows.Threading.DispatcherPriority> des Delegaten entspricht ausstehende Ausführung im Ereignis in die Warteschlange.  
  
-   Entfernen den Delegaten aus der Ereigniswarteschlange.  
  
-   Es wird darauf gewartet, dass der Delegat zurückgegeben.  
  
-   Abrufen des Werts, die der Delegat, nachdem er zurückgegeben ausgeführt wird.  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> ist asynchron. aus diesem Grund gibt Steuerelement sofort an das aufrufende Objekt zurück, nachdem er aufgerufen wird.  
  
 In [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], Threads, der erstellt eine <xref:System.Windows.Threading.DispatcherObject> kann dieses Objekt zugreifen.  Z. B. ein Hintergrundthread, der aus dem Hauptbenutzeroberflächen-Thread eröffnet kann nicht den Inhalt des aktualisiert eine <xref:System.Windows.Controls.Button> , die im UI-Thread erstellt wurde.  In der Reihenfolge des Hintergrundthreads, die Content-Eigenschaft für den Zugriff auf die <xref:System.Windows.Controls.Button>, der Hintergrundthread die Verarbeitung zur delegieren muss die <xref:System.Windows.Threading.Dispatcher> im UI-Thread zugeordnet.  Dies wird erreicht, indem Sie entweder <xref:System.Windows.Threading.Dispatcher.Invoke%2A> oder <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> ist synchron und <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> asynchron ist.  Der Vorgang wird hinzugefügt, auf die Ereigniswarteschlange von der <xref:System.Windows.Threading.Dispatcher> an der angegebenen <xref:System.Windows.Threading.DispatcherPriority>.  
  
 Wenn mehrere <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> Aufrufe gleichzeitig <xref:System.Windows.Threading.DispatcherPriority>, werden sie in der Reihenfolge der Aufrufe wurden ausgeführt.  
  
 Wenn <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> aufgerufen wird, auf eine <xref:System.Windows.Threading.Dispatcher> , die heruntergefahren wurde, der Status-Eigenschaft des zurückgegebenen <xref:System.Windows.Threading.DispatcherOperation> festgelegt ist, um <xref:System.Windows.Threading.DispatcherOperationStatus.Aborted>.  
  
   
  
## Examples  
 Im folgende Beispiel wird gezeigt, wie an eine Operation auf eine <xref:System.Windows.Threading.Dispatcher>.  
  
 Zuerst wird ein Delegat erstellt, das ein Argument, in diesem Fall eine Zeichenfolge akzeptiert.  
  
 [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherDelegates](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherdelegates)]
 [!code-vb[ThreadingWeatherForecast#ThreadingWeatherDelegates](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherdelegates)]  
  
 Als Nächstes <xref:System.Windows.Threading.Dispatcher.BeginInvoke%28System.Windows.Threading.DispatcherPriority%2CSystem.Delegate%2CSystem.Object%29> aufgerufen wird.  Da jede <xref:System.Windows.Threading.DispatcherObject> verfügt über eine Eigenschaft, die zurückgibt der <xref:System.Windows.Threading.Dispatcher> zugeordnet ist, den gewünschten <xref:System.Windows.Threading.Dispatcher> erhalten, indem Sie Abfragen der <xref:System.Windows.Threading.DispatcherObject>, in diesem Fall eine <xref:System.Windows.Controls.Grid> mit dem Namen `tomorrowsWeather`. Der Aufruf von <xref:System.Windows.Threading.Dispatcher.BeginInvoke%28System.Windows.Threading.DispatcherPriority%2CSystem.Delegate%2CSystem.Object%29> akzeptiert drei Parameter: die Priorität, die festgelegt wird, dass <xref:System.Windows.Threading.DispatcherPriority.Normal?displayProperty=nameWithType>; der Rückruf, der über eine Instanz des Delegaten übergeben wird `OneArgDelegate`; und eine Zeichenfolge mit dem Namen `weather`, dies ist das Argument für den Rückruf bereit.  
  
 [!code-csharp[threadingweatherforecast#ThreadingWeatherDispatcherOneArge](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherdispatcheronearge)]
 [!code-vb[threadingweatherforecast#ThreadingWeatherDispatcherOneArge](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherdispatcheronearge)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="priority" /> is not a valid <see cref="T:System.Windows.Threading.DispatcherPriority" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginInvoke">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation BeginInvoke (System.Windows.Threading.DispatcherPriority priority, Delegate method, object arg, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation BeginInvoke(valuetype System.Windows.Threading.DispatcherPriority priority, class System.Delegate method, object arg, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginInvoke (priority As DispatcherPriority, method As Delegate, arg As Object, ParamArray args As Object()) As DispatcherOperation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Threading::DispatcherOperation ^ BeginInvoke(System::Windows::Threading::DispatcherPriority priority, Delegate ^ method, System::Object ^ arg, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.BeginInvoke : System.Windows.Threading.DispatcherPriority * Delegate * obj * obj[] -&gt; System.Windows.Threading.DispatcherOperation" Usage="dispatcher.BeginInvoke (priority, method, arg, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="arg" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="priority">The priority, relative to the other pending operations in the <see cref="T:System.Windows.Threading.Dispatcher" /> event queue, the specified method is invoked.</param>
        <param name="method">A delegate to a method that takes multiple arguments, which is pushed onto the <see cref="T:System.Windows.Threading.Dispatcher" /> event queue.</param>
        <param name="arg">The object to pass as an argument to the specified method.</param>
        <param name="args">An array of objects to pass as arguments to the specified method.</param>
        <summary>Executes the specified delegate asynchronously at the specified priority and with the specified array of arguments on the thread the <see cref="T:System.Windows.Threading.Dispatcher" /> is associated with.</summary>
        <returns>An object, which is returned immediately after <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" /> is called, that can be used to interact with the delegate as it is pending execution in the <see cref="T:System.Windows.Threading.Dispatcher" /> queue.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `arg` Parameter möglich `null` Wenn keine Argumente benötigt werden.  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> Gibt eine <xref:System.Windows.Threading.DispatcherOperation> -Objekt, das verwendet werden kann, um die Interaktion mit dem Delegaten, wenn der Delegat in der Warteschlange befindet.  
  
 Die <xref:System.Windows.Threading.DispatcherOperation> zurückgegebenes Objekt <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> können auf verschiedene Weise für die Interaktion mit den angegebenen Delegaten verwendet werden:  
  
-   Ändern der <xref:System.Windows.Threading.DispatcherPriority> des Delegaten entspricht ausstehende Ausführung im Ereignis in die Warteschlange.  
  
-   Entfernen den Delegaten aus der Ereigniswarteschlange.  
  
-   Es wird darauf gewartet, dass der Delegat zurückgegeben.  
  
-   Abrufen des Werts, die der Delegat, nachdem er zurückgegeben ausgeführt wird.  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> ist asynchron. aus diesem Grund gibt Steuerelement sofort an das aufrufende Objekt zurück, nachdem er aufgerufen wird.  
  
 In [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], Threads, der erstellt eine <xref:System.Windows.Threading.DispatcherObject> kann dieses Objekt zugreifen.  Z. B. ein Hintergrundthread, der aus dem Hauptbenutzeroberflächen-Thread eröffnet kann nicht den Inhalt des aktualisiert eine <xref:System.Windows.Controls.Button> , die im UI-Thread erstellt wurde.  In der Reihenfolge des Hintergrundthreads, die Content-Eigenschaft für den Zugriff auf die <xref:System.Windows.Controls.Button>, der Hintergrundthread die Verarbeitung zur delegieren muss die <xref:System.Windows.Threading.Dispatcher> im UI-Thread zugeordnet.  Dies wird erreicht, indem Sie entweder <xref:System.Windows.Threading.Dispatcher.Invoke%2A> oder <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> ist synchron und <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> asynchron ist.  Der Vorgang wird hinzugefügt, auf die Ereigniswarteschlange von der <xref:System.Windows.Threading.Dispatcher> an der angegebenen <xref:System.Windows.Threading.DispatcherPriority>.  
  
 Wenn mehrere <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> Aufrufe gleichzeitig <xref:System.Windows.Threading.DispatcherPriority>, werden sie in der Reihenfolge der Aufrufe wurden ausgeführt.  
  
 Wenn <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> aufgerufen wird, auf eine <xref:System.Windows.Threading.Dispatcher> , die heruntergefahren wurde, der Status-Eigenschaft des zurückgegebenen <xref:System.Windows.Threading.DispatcherOperation> festgelegt ist, um <xref:System.Windows.Threading.DispatcherOperationStatus.Aborted>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <see cref="T:System.Windows.Threading.DispatcherPriority" /> is not a valid priority.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginInvokeShutdown">
      <MemberSignature Language="C#" Value="public void BeginInvokeShutdown (System.Windows.Threading.DispatcherPriority priority);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginInvokeShutdown(valuetype System.Windows.Threading.DispatcherPriority priority) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.BeginInvokeShutdown(System.Windows.Threading.DispatcherPriority)" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInvokeShutdown (priority As DispatcherPriority)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginInvokeShutdown(System::Windows::Threading::DispatcherPriority priority);" />
      <MemberSignature Language="F#" Value="member this.BeginInvokeShutdown : System.Windows.Threading.DispatcherPriority -&gt; unit" Usage="dispatcher.BeginInvokeShutdown priority" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
      </Parameters>
      <Docs>
        <param name="priority">The priority at which to begin shutting down the dispatcher.</param>
        <summary>Initiates shutdown of the <see cref="T:System.Windows.Threading.Dispatcher" /> asynchronously.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Threading.Dispatcher.BeginInvokeShutdown%2A> setzt uneingeschränkte Benutzeroberflächen-Berechtigungen.  
  
 Wenn die <xref:System.Windows.Threading.Dispatcher> zum Herunterfahren beginnt die <xref:System.Windows.Threading.Dispatcher.ShutdownStarted> Ereignis wird ausgelöst, und <xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> auf festgelegt ist `true`.  
  
 Die <xref:System.Windows.Threading.Dispatcher> ist nicht vollständig heruntergefahren, bis die Ereigniswarteschlange abgearbeitet wurde.  
  
 Nach Abschluss der Verteiler heruntergefahren wird, die <xref:System.Windows.Threading.Dispatcher.ShutdownFinished> Ereignis wird ausgelöst, und die <xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A> -Eigenschaftensatz auf `true`.  
  
 Nachdem der Prozess des Herunterfahrens eingeleitet wurde, werden alle anstehenden Arbeitsaufgaben Elemente in der Warteschlange abgebrochen.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">für den Verteiler beendet.  Zugeordnete Enumerationen:  <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CheckAccess">
      <MemberSignature Language="C#" Value="public bool CheckAccess ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CheckAccess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.CheckAccess" />
      <MemberSignature Language="VB.NET" Value="Public Function CheckAccess () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CheckAccess();" />
      <MemberSignature Language="F#" Value="member this.CheckAccess : unit -&gt; bool" Usage="dispatcher.CheckAccess " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Determines whether the calling thread is the thread associated with this <see cref="T:System.Windows.Threading.Dispatcher" />.</summary>
        <returns>
          <see langword="true" /> if the calling thread is the thread associated with this <see cref="T:System.Windows.Threading.Dispatcher" />; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nur die <xref:System.Windows.Threading.Dispatcher> , die eine <xref:System.Windows.Threading.DispatcherObject> wird erstellt, auf auf das Objekt zugreifen kann.  Verwendung <xref:System.Windows.Threading.Dispatcher.Invoke%2A> oder <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> auf das Objekt von einem anderen Thread zuzugreifen.  
  
 <xref:System.Windows.Threading.Dispatcher.CheckAccess%2A> kann von jedem Thread aufgerufen werden.  
  
 Der Unterschied zwischen <xref:System.Windows.Threading.Dispatcher.CheckAccess%2A> und <xref:System.Windows.Threading.Dispatcher.VerifyAccess%2A> ist <xref:System.Windows.Threading.Dispatcher.CheckAccess%2A> gibt einen booleschen Wert, der angibt, ob der aufrufende Thread Zugriff auf die <xref:System.Windows.Threading.Dispatcher> und <xref:System.Windows.Threading.Dispatcher.VerifyAccess%2A> löst eine Ausnahme aus.  
  
   
  
## Examples  
 Im folgenden Beispiel wird <xref:System.Windows.Threading.Dispatcher.CheckAccess%2A> zu bestimmen, ob ein Thread den Zugriff auf verfügt über eine <xref:System.Windows.Controls.Button>.  Der <xref:System.Windows.Threading.Dispatcher.CheckAccess%2A> Methode für die <xref:System.Windows.Threading.Dispatcher> zugeordneten der <xref:System.Windows.Controls.Button> wird aufgerufen, um den Zugriff auf den Thread zu überprüfen.  Verfügt der aufrufende Thread den Zugriff auf die <xref:System.Windows.Threading.Dispatcher>, die <xref:System.Windows.Controls.Button> wird aktualisiert, indem Sie den Zugriff auf die Mitglieder der der <xref:System.Windows.Controls.Button>ist, andernfalls ein Delegat, der akzeptiert eine <xref:System.Windows.Controls.Button> als Argument in platziert die <xref:System.Windows.Threading.Dispatcher>.  Die <xref:System.Windows.Threading.Dispatcher> delegiert die Arbeit aktualisieren die <xref:System.Windows.Controls.Button>.  
  
 [!code-csharp[DispatcherAccessSample#DispatcherAccessCheckAccess](~/samples/snippets/csharp/VS_Snippets_Wpf/DispatcherAccessSample/CSharp/Window1.xaml.cs#dispatcheraccesscheckaccess)]
 [!code-vb[DispatcherAccessSample#DispatcherAccessCheckAccess](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DispatcherAccessSample/visualbasic/window1.xaml.vb#dispatcheraccesscheckaccess)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Threading.Dispatcher.VerifyAccess" />
      </Docs>
    </Member>
    <Member MemberName="CurrentDispatcher">
      <MemberSignature Language="C#" Value="public static System.Windows.Threading.Dispatcher CurrentDispatcher { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Threading.Dispatcher CurrentDispatcher" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Threading.Dispatcher.CurrentDispatcher" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentDispatcher As Dispatcher" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Threading::Dispatcher ^ CurrentDispatcher { System::Windows::Threading::Dispatcher ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentDispatcher : System.Windows.Threading.Dispatcher" Usage="System.Windows.Threading.Dispatcher.CurrentDispatcher" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.Dispatcher</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the <see cref="T:System.Windows.Threading.Dispatcher" /> for the thread currently executing and creates a new <see cref="T:System.Windows.Threading.Dispatcher" /> if one is not already associated with the thread.</summary>
        <value>Der Verteiler, die dem aktuellen Thread zugeordnet.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn eine <xref:System.Windows.Threading.Dispatcher> ist nicht mit den aktuellen Thread verknüpft ein neues <xref:System.Windows.Threading.Dispatcher> erstellt werden.  Dies ist bei der <xref:System.Windows.Threading.Dispatcher.FromThread%2A>-Methode nicht der Fall.  <xref:System.Windows.Threading.Dispatcher.FromThread%2A> Gibt zurück, `null` besteht kein Verteiler den angegebenen Thread zugeordnet.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisableProcessing">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherProcessingDisabled DisableProcessing ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Threading.DispatcherProcessingDisabled DisableProcessing() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.DisableProcessing" />
      <MemberSignature Language="VB.NET" Value="Public Function DisableProcessing () As DispatcherProcessingDisabled" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Threading::DispatcherProcessingDisabled DisableProcessing();" />
      <MemberSignature Language="F#" Value="member this.DisableProcessing : unit -&gt; System.Windows.Threading.DispatcherProcessingDisabled" Usage="dispatcher.DisableProcessing " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherProcessingDisabled</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Disables processing of the <see cref="T:System.Windows.Threading.Dispatcher" /> queue.</summary>
        <returns>A structure used to re-enable dispatcher processing.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Deaktivieren von Verteiler, die Verarbeitung ist eine erweiterte Methode, die vorgesehen ist, um das Risiko von nicht verknüpfte Reentranz zu vermeiden.  
  
 Die Auswirkungen des Deaktivierens von Verarbeitung lauten wie folgt:  
  
-   CLR-Sperren werden Nachrichten nicht intern Datapump.  
  
-   <xref:System.Windows.Threading.DispatcherFrame> Objekte dürfen nicht verschoben werden.  
  
-   Verarbeitung von Nachrichten ist nicht zulässig.  
  
 Die <xref:System.Windows.Threading.DispatcherProcessingDisabled> Datenstruktur, <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A> zurückgegeben, wenn sie aufgerufen wird, können verwendet werden, um die Verarbeitung durch den Verteiler erneut zu aktivieren.  Aufrufen von <xref:System.Windows.Threading.DispatcherProcessingDisabled.Dispose%2A> auf die <xref:System.Windows.Threading.DispatcherProcessingDisabled> Struktur ermöglicht die Verarbeitung erneut.  
  
 <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A> kann nur auf dem Thread aufgerufen werden der <xref:System.Windows.Threading.Dispatcher> zugeordnet ist.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verarbeitung durch den Verteiler deaktivieren und erneutes Aktivieren Verarbeitung durch den Verteiler.  <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A> wird aufgerufen, einem **mit** Anweisung.  <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A> Gibt eine <xref:System.Windows.Threading.DispatcherProcessingDisabled> -Struktur, die dem Objekt verwendet wird, um freigegeben sein, wenn die **mit** -block abgeschlossen ist.  Wenn <xref:System.Windows.Threading.DispatcherProcessingDisabled.Dispose%2A> aufgerufen wird, auf die <xref:System.Windows.Threading.DispatcherProcessingDisabled> -Struktur, die Verarbeitung durch den Verteiler wird wieder aktiviert.  
  
 [!code-csharp[DispatcherSnippets#DispatcherDisableProcessing](~/samples/snippets/csharp/VS_Snippets_Wpf/DispatcherSnippets/CSharp/Window1.xaml.cs#dispatcherdisableprocessing)]
 [!code-vb[DispatcherSnippets#DispatcherDisableProcessing](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DispatcherSnippets/visualbasic/window1.xaml.vb#dispatcherdisableprocessing)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExitAllFrames">
      <MemberSignature Language="C#" Value="public static void ExitAllFrames ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ExitAllFrames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.ExitAllFrames" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ExitAllFrames ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ExitAllFrames();" />
      <MemberSignature Language="F#" Value="static member ExitAllFrames : unit -&gt; unit" Usage="System.Windows.Threading.Dispatcher.ExitAllFrames " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Requests that all frames exit, including nested frames.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">für das Aufrufen dieser Methode. Zugeordnete Enumerationen:  <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="M:System.Windows.Threading.Dispatcher.PushFrame(System.Windows.Threading.DispatcherFrame)" />
        <altmember cref="T:System.Windows.Threading.DispatcherFrame" />
      </Docs>
    </Member>
    <Member MemberName="FromThread">
      <MemberSignature Language="C#" Value="public static System.Windows.Threading.Dispatcher FromThread (System.Threading.Thread thread);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Threading.Dispatcher FromThread(class System.Threading.Thread thread) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.FromThread(System.Threading.Thread)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Threading::Dispatcher ^ FromThread(System::Threading::Thread ^ thread);" />
      <MemberSignature Language="F#" Value="static member FromThread : System.Threading.Thread -&gt; System.Windows.Threading.Dispatcher" Usage="System.Windows.Threading.Dispatcher.FromThread thread" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.Dispatcher</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="thread" Type="System.Threading.Thread" />
      </Parameters>
      <Docs>
        <param name="thread">The thread to obtain the <see cref="T:System.Windows.Threading.Dispatcher" /> from.</param>
        <summary>Gets the <see cref="T:System.Windows.Threading.Dispatcher" /> for the specified thread.</summary>
        <returns>The dispatcher for <paramref name="thread" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein Verteiler nicht verfügbar für den angegebenen Thread ist `null` zurückgegeben werden.  
  
 <xref:System.Windows.Threading.Dispatcher.FromThread%2A> erstellt keine <xref:System.Windows.Threading.Dispatcher> in einem Thread, der keinem <xref:System.Windows.Threading.Dispatcher>.   Ein neues <xref:System.Windows.Threading.Dispatcher> wird auf einen Thread, der noch nicht erstellt eine <xref:System.Windows.Threading.Dispatcher> beim Abrufen der <xref:System.Windows.Threading.Dispatcher> mithilfe der <xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A> Eigenschaft.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasShutdownFinished">
      <MemberSignature Language="C#" Value="public bool HasShutdownFinished { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasShutdownFinished" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Threading.Dispatcher.HasShutdownFinished" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasShutdownFinished As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasShutdownFinished { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasShutdownFinished : bool" Usage="System.Windows.Threading.Dispatcher.HasShutdownFinished" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Determines whether the <see cref="T:System.Windows.Threading.Dispatcher" /> has finished shutting down.</summary>
        <value>
          <see langword="true" /> Wenn der Verteiler die Beendigung abgeschlossen wurde; andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Windows.Threading.Dispatcher> zum Herunterfahren beginnt die <xref:System.Windows.Threading.Dispatcher.ShutdownStarted> Ereignis wird ausgelöst, und <xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> auf festgelegt ist `true`.  
  
 Die <xref:System.Windows.Threading.Dispatcher> wird vollständig beendet, bis die Ereigniswarteschlange abgearbeitet wurde.  
  
 Nach Abschluss der Verteiler heruntergefahren wird, die <xref:System.Windows.Threading.Dispatcher.ShutdownFinished> Ereignis wird ausgelöst, und die <xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A> -Eigenschaftensatz auf `true`.  
  
 Nachdem der Prozess des Herunterfahrens eingeleitet wurde, werden alle anstehenden Arbeitsaufgaben Elemente in der Warteschlange abgebrochen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasShutdownStarted">
      <MemberSignature Language="C#" Value="public bool HasShutdownStarted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasShutdownStarted" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Threading.Dispatcher.HasShutdownStarted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasShutdownStarted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasShutdownStarted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasShutdownStarted : bool" Usage="System.Windows.Threading.Dispatcher.HasShutdownStarted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Determines whether the <see cref="T:System.Windows.Threading.Dispatcher" /> is shutting down.</summary>
        <value>
          <see langword="true" /> Wenn die <see cref="T:System.Windows.Threading.Dispatcher" /> gestarteten heruntergefahren wird, andernfalls, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Windows.Threading.Dispatcher> zum Herunterfahren beginnt die <xref:System.Windows.Threading.Dispatcher.ShutdownStarted> Ereignis wird ausgelöst, und <xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> auf festgelegt ist `true`.  
  
 Die <xref:System.Windows.Threading.Dispatcher> ist nicht vollständig heruntergefahren, bis die Ereigniswarteschlange abgearbeitet wurde.  
  
 Nach Abschluss der Verteiler heruntergefahren wird, die <xref:System.Windows.Threading.Dispatcher.ShutdownFinished> Ereignis wird ausgelöst, und die <xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A> -Eigenschaftensatz auf `true`.  
  
 Nachdem der Prozess des Herunterfahrens eingeleitet wurde, werden alle anstehenden Arbeitsaufgaben Elemente in der Warteschlange abgebrochen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Hooks">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherHooks Hooks { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Threading.DispatcherHooks Hooks" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Threading.Dispatcher.Hooks" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Hooks As DispatcherHooks" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Threading::DispatcherHooks ^ Hooks { System::Windows::Threading::DispatcherHooks ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Hooks : System.Windows.Threading.DispatcherHooks" Usage="System.Windows.Threading.Dispatcher.Hooks" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherHooks</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the collection of hooks that provide additional event information about the <see cref="T:System.Windows.Threading.Dispatcher" />.</summary>
        <value>Die zugeordnete Hooks <see cref="T:System.Windows.Threading.Dispatcher" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Threading.DispatcherHooks> Klasse enthält weitere Informationen über die <xref:System.Windows.Threading.Dispatcher>, z. B. wenn die <xref:System.Windows.Threading.Dispatcher> inaktiv ist oder wenn ein Vorgang abgeschlossen wurde.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">zum Abrufen dieser Eigenschaft.  Zugeordnete Enumerationen:  <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Invoke">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Executes the specified delegate synchronously on the thread the <see cref="T:System.Windows.Threading.Dispatcher" /> is associated with.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], Threads, der erstellt eine <xref:System.Windows.Threading.DispatcherObject> kann dieses Objekt zugreifen.  Z. B. ein Hintergrundthread, der aus dem Hauptbenutzeroberflächen-Thread eröffnet kann nicht den Inhalt des aktualisiert eine <xref:System.Windows.Controls.Button> , die im UI-Thread erstellt wurde.  In der Reihenfolge des Hintergrundthreads, die Content-Eigenschaft für den Zugriff auf die <xref:System.Windows.Controls.Button>, der Hintergrundthread die Verarbeitung zur delegieren muss die <xref:System.Windows.Threading.Dispatcher> im UI-Thread zugeordnet.  Dies wird erreicht, indem Sie entweder <xref:System.Windows.Threading.Dispatcher.Invoke%2A> oder <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> ist synchron und <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> asynchron ist.  Der Vorgang wird hinzugefügt, auf die Ereigniswarteschlange von der <xref:System.Windows.Threading.Dispatcher> an der angegebenen <xref:System.Windows.Threading.DispatcherPriority>.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> ist ein synchroner Vorgang. aus diesem Grund gibt Steuerelement nicht an das aufrufende Objekt erst zurück, nachdem der Rückruf zurückgegeben.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Delegat auf eine <xref:System.Windows.Threading.Dispatcher> am <xref:System.Windows.Threading.DispatcherPriority.Normal> mit <xref:System.Windows.Threading.Dispatcher.Invoke%2A>.  
  
 [!code-csharp[invalidaterequerywithsystemtimer#SystemTimerDispatcherInvoke](~/samples/snippets/csharp/VS_Snippets_Wpf/InvalidateRequeryWithSystemTimer/CSharp/Window1.xaml.cs#systemtimerdispatcherinvoke)]
 [!code-vb[invalidaterequerywithsystemtimer#SystemTimerDispatcherInvoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InvalidateRequeryWithSystemTimer/visualbasic/window1.xaml.vb#systemtimerdispatcherinvoke)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public void Invoke (Action callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invoke(class System.Action callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Action)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Invoke (callback As Action)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Invoke(Action ^ callback);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Action -&gt; unit" Usage="dispatcher.Invoke callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action" />
      </Parameters>
      <Docs>
        <param name="callback">A delegate to invoke through the dispatcher.</param>
        <summary>Executes the specified <see cref="T:System.Action" /> synchronously on the thread the <see cref="T:System.Windows.Threading.Dispatcher" /> is associated with.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public void Invoke (Action callback, System.Windows.Threading.DispatcherPriority priority);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invoke(class System.Action callback, valuetype System.Windows.Threading.DispatcherPriority priority) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Action,System.Windows.Threading.DispatcherPriority)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Invoke (callback As Action, priority As DispatcherPriority)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Invoke(Action ^ callback, System::Windows::Threading::DispatcherPriority priority);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Action * System.Windows.Threading.DispatcherPriority -&gt; unit" Usage="dispatcher.Invoke (callback, priority)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
      </Parameters>
      <Docs>
        <param name="callback">A delegate to invoke through the dispatcher.</param>
        <param name="priority">The priority that determines in what order the specified callback is invoked relative to the other pending operations in the <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <summary>Executes the specified <see cref="T:System.Action" /> synchronously at the specified priority on the thread the <see cref="T:System.Windows.Threading.Dispatcher" /> is associated with.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (Delegate method, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(class System.Delegate method, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (method As Delegate, ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(Delegate ^ method, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Delegate * obj[] -&gt; obj" Usage="dispatcher.Invoke (method, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method">A delegate to a method that takes parameters specified in <c>args</c>, which is pushed onto the <see cref="T:System.Windows.Threading.Dispatcher" /> event queue.</param>
        <param name="args">An array of objects to pass as arguments to the given method. Can be <see langword="null" />.</param>
        <summary>Executes the specified delegate with the specified arguments synchronously on the thread the <see cref="T:System.Windows.Threading.Dispatcher" /> is associated with.</summary>
        <returns>The return value from the delegate being invoked or <see langword="null" /> if the delegate has no return value.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], Threads, der erstellt eine <xref:System.Windows.Threading.DispatcherObject> kann dieses Objekt zugreifen. Z. B. ein Hintergrundthread, der aus dem Hauptbenutzeroberflächen-Thread eröffnet kann nicht den Inhalt des aktualisiert eine <xref:System.Windows.Controls.Button> , die im UI-Thread erstellt wurde. In der Reihenfolge des Hintergrundthreads, die Content-Eigenschaft für den Zugriff auf die <xref:System.Windows.Controls.Button>, der Hintergrundthread die Verarbeitung zur delegieren muss die <xref:System.Windows.Threading.Dispatcher> im UI-Thread zugeordnet. Dies wird erreicht, indem Sie entweder <xref:System.Windows.Threading.Dispatcher.Invoke%2A> oder <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>. <xref:System.Windows.Threading.Dispatcher.Invoke%2A> ist synchron und <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> asynchron ist. Der Vorgang wird hinzugefügt, auf die Ereigniswarteschlange von der <xref:System.Windows.Threading.Dispatcher> an der angegebenen <xref:System.Windows.Threading.DispatcherPriority>.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> ist ein synchroner Vorgang. aus diesem Grund gibt Steuerelement nicht an das aufrufende Objekt erst zurück, nachdem der Rückruf zurückgegeben.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (System.Windows.Threading.DispatcherPriority priority, Delegate method);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(valuetype System.Windows.Threading.DispatcherPriority priority, class System.Delegate method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (priority As DispatcherPriority, method As Delegate) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(System::Windows::Threading::DispatcherPriority priority, Delegate ^ method);" />
      <MemberSignature Language="F#" Value="member this.Invoke : System.Windows.Threading.DispatcherPriority * Delegate -&gt; obj" Usage="dispatcher.Invoke (priority, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="method" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="priority">The priority, relative to the other pending operations in the <see cref="T:System.Windows.Threading.Dispatcher" /> event queue, the specified method is invoked.</param>
        <param name="method">A delegate to a method that takes no arguments, which is pushed onto the <see cref="T:System.Windows.Threading.Dispatcher" /> event queue.</param>
        <summary>Executes the specified delegate synchronously at the specified priority on the thread on which the <see cref="T:System.Windows.Threading.Dispatcher" /> is associated with.</summary>
        <returns>The return value from the delegate being invoked or <see langword="null" /> if the delegate has no return value.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], Threads, der erstellt eine <xref:System.Windows.Threading.DispatcherObject> kann dieses Objekt zugreifen.  Z. B. ein Hintergrundthread, der aus dem Hauptbenutzeroberflächen-Thread eröffnet kann nicht den Inhalt des aktualisiert eine <xref:System.Windows.Controls.Button> , die im UI-Thread erstellt wurde.  In der Reihenfolge des Hintergrundthreads, die Content-Eigenschaft für den Zugriff auf die <xref:System.Windows.Controls.Button>, der Hintergrundthread die Verarbeitung zur delegieren muss die <xref:System.Windows.Threading.Dispatcher> im UI-Thread zugeordnet.  Dies wird erreicht, indem Sie entweder <xref:System.Windows.Threading.Dispatcher.Invoke%2A> oder <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> ist synchron und <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> asynchron ist.  Der Vorgang wird hinzugefügt, auf die Ereigniswarteschlange von der <xref:System.Windows.Threading.Dispatcher> an der angegebenen <xref:System.Windows.Threading.DispatcherPriority>.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> ist ein synchroner Vorgang. aus diesem Grund gibt Steuerelement nicht an das aufrufende Objekt erst zurück, nachdem der Rückruf zurückgegeben.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Delegat auf eine <xref:System.Windows.Threading.Dispatcher> am <xref:System.Windows.Threading.DispatcherPriority.Normal> mit <xref:System.Windows.Threading.Dispatcher.Invoke%2A>.  
  
 [!code-csharp[invalidaterequerywithsystemtimer#SystemTimerDispatcherInvoke](~/samples/snippets/csharp/VS_Snippets_Wpf/InvalidateRequeryWithSystemTimer/CSharp/Window1.xaml.cs#systemtimerdispatcherinvoke)]
 [!code-vb[invalidaterequerywithsystemtimer#SystemTimerDispatcherInvoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InvalidateRequeryWithSystemTimer/visualbasic/window1.xaml.vb#systemtimerdispatcherinvoke)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="priority" /> is equal to <see cref="F:System.Windows.Threading.DispatcherPriority.Inactive" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="priority" /> is not a valid priority.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public void Invoke (Action callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invoke(class System.Action callback, valuetype System.Windows.Threading.DispatcherPriority priority, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Invoke(Action ^ callback, System::Windows::Threading::DispatcherPriority priority, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Action * System.Windows.Threading.DispatcherPriority * System.Threading.CancellationToken -&gt; unit" Usage="dispatcher.Invoke (callback, priority, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="callback">A delegate to invoke through the dispatcher.</param>
        <param name="priority">The priority that determines in what order the specified callback is invoked relative to the other pending operations in the <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <param name="cancellationToken">An object that indicates whether to cancel the action.</param>
        <summary>Executes the specified <see cref="T:System.Action" /> synchronously at the specified priority on the thread the <see cref="T:System.Windows.Threading.Dispatcher" /> is associated with.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (Delegate method, TimeSpan timeout, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(class System.Delegate method, valuetype System.TimeSpan timeout, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.TimeSpan,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (method As Delegate, timeout As TimeSpan, ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(Delegate ^ method, TimeSpan timeout, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Delegate * TimeSpan * obj[] -&gt; obj" Usage="dispatcher.Invoke (method, timeout, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method">A delegate to a method that takes parameters specified in <c>args</c>, which is pushed onto the <see cref="T:System.Windows.Threading.Dispatcher" /> event queue.</param>
        <param name="timeout">The maximum amount of time to wait for the operation to complete.</param>
        <param name="args">An array of objects to pass as arguments to the given method. Can be <see langword="null" />.</param>
        <summary>Executes the specified delegate within the designated time span at the specified priority with the specified arguments synchronously on the thread the <see cref="T:System.Windows.Threading.Dispatcher" /> is associated with.</summary>
        <returns>The return value from the delegate being invoked or <see langword="null" /> if the delegate has no return value.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], Threads, der erstellt eine <xref:System.Windows.Threading.DispatcherObject> kann dieses Objekt zugreifen. Z. B. ein Hintergrundthread, der aus dem Hauptbenutzeroberflächen-Thread eröffnet kann nicht den Inhalt des aktualisiert eine <xref:System.Windows.Controls.Button> , die im UI-Thread erstellt wurde. In der Reihenfolge des Hintergrundthreads, die Content-Eigenschaft für den Zugriff auf die <xref:System.Windows.Controls.Button>, der Hintergrundthread die Verarbeitung zur delegieren muss die <xref:System.Windows.Threading.Dispatcher> im UI-Thread zugeordnet. Dies wird erreicht, indem Sie entweder <xref:System.Windows.Threading.Dispatcher.Invoke%2A> oder <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>. <xref:System.Windows.Threading.Dispatcher.Invoke%2A> ist synchron und <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> asynchron ist. Der Vorgang wird hinzugefügt, auf die Ereigniswarteschlange von der <xref:System.Windows.Threading.Dispatcher> an der angegebenen <xref:System.Windows.Threading.DispatcherPriority>.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> ist ein synchroner Vorgang. aus diesem Grund gibt Steuerelement nicht an das aufrufende Objekt erst zurück, nachdem der Rückruf zurückgegeben.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (Delegate method, System.Windows.Threading.DispatcherPriority priority, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(class System.Delegate method, valuetype System.Windows.Threading.DispatcherPriority priority, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.Windows.Threading.DispatcherPriority,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (method As Delegate, priority As DispatcherPriority, ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(Delegate ^ method, System::Windows::Threading::DispatcherPriority priority, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Delegate * System.Windows.Threading.DispatcherPriority * obj[] -&gt; obj" Usage="dispatcher.Invoke (method, priority, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method">A delegate to a method that takes parameters specified in <c>args</c>, which is pushed onto the <see cref="T:System.Windows.Threading.Dispatcher" /> event queue.</param>
        <param name="priority">The priority, relative to the other pending operations in the <see cref="T:System.Windows.Threading.Dispatcher" /> event queue, the specified method is invoked.</param>
        <param name="args">An array of objects to pass as arguments to the given method. Can be <see langword="null" />.</param>
        <summary>Executes the specified delegate at the specified priority with the specified arguments synchronously on the thread the <see cref="T:System.Windows.Threading.Dispatcher" /> is associated with.</summary>
        <returns>The return value from the delegate being invoked or <see langword="null" /> if the delegate has no return value.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], Threads, der erstellt eine <xref:System.Windows.Threading.DispatcherObject> kann dieses Objekt zugreifen. Z. B. ein Hintergrundthread, der aus dem Hauptbenutzeroberflächen-Thread eröffnet kann nicht den Inhalt des aktualisiert eine <xref:System.Windows.Controls.Button> , die im UI-Thread erstellt wurde. In der Reihenfolge des Hintergrundthreads, die Content-Eigenschaft für den Zugriff auf die <xref:System.Windows.Controls.Button>, der Hintergrundthread die Verarbeitung zur delegieren muss die <xref:System.Windows.Threading.Dispatcher> im UI-Thread zugeordnet. Dies wird erreicht, indem Sie entweder <xref:System.Windows.Threading.Dispatcher.Invoke%2A> oder <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>. <xref:System.Windows.Threading.Dispatcher.Invoke%2A> ist synchron und <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> asynchron ist. Der Vorgang wird hinzugefügt, auf die Ereigniswarteschlange von der <xref:System.Windows.Threading.Dispatcher> an der angegebenen <xref:System.Windows.Threading.DispatcherPriority>.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> ist ein synchroner Vorgang. aus diesem Grund gibt Steuerelement nicht an das aufrufende Objekt erst zurück, nachdem der Rückruf zurückgegeben.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (System.Windows.Threading.DispatcherPriority priority, Delegate method, object arg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(valuetype System.Windows.Threading.DispatcherPriority priority, class System.Delegate method, object arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (priority As DispatcherPriority, method As Delegate, arg As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(System::Windows::Threading::DispatcherPriority priority, Delegate ^ method, System::Object ^ arg);" />
      <MemberSignature Language="F#" Value="member this.Invoke : System.Windows.Threading.DispatcherPriority * Delegate * obj -&gt; obj" Usage="dispatcher.Invoke (priority, method, arg)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="arg" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="priority">The priority, relative to the other pending operations in the <see cref="T:System.Windows.Threading.Dispatcher" /> event queue, the specified method is invoked.</param>
        <param name="method">A delegate to a method that takes one argument, which is pushed onto the <see cref="T:System.Windows.Threading.Dispatcher" /> event queue.</param>
        <param name="arg">An object to pass as an argument to the given method.</param>
        <summary>Executes the specified delegate at the specified priority with the specified argument synchronously on the thread the <see cref="T:System.Windows.Threading.Dispatcher" /> is associated with.</summary>
        <returns>The return value from the delegate being invoked or <see langword="null" /> if the delegate has no return value.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Arg` kann `null` Wenn ein Argument nicht benötigt wird  
  
 In [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], Threads, der erstellt eine <xref:System.Windows.Threading.DispatcherObject> kann dieses Objekt zugreifen.  Z. B. ein Hintergrundthread, der aus dem Hauptbenutzeroberflächen-Thread eröffnet kann nicht den Inhalt des aktualisiert eine <xref:System.Windows.Controls.Button> , die im UI-Thread erstellt wurde.  In der Reihenfolge des Hintergrundthreads, die Content-Eigenschaft für den Zugriff auf die <xref:System.Windows.Controls.Button>, der Hintergrundthread die Verarbeitung zur delegieren muss die <xref:System.Windows.Threading.Dispatcher> im UI-Thread zugeordnet.  Dies wird erreicht, indem Sie entweder <xref:System.Windows.Threading.Dispatcher.Invoke%2A> oder <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> ist synchron und <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> asynchron ist.  Der Vorgang wird hinzugefügt, auf die Ereigniswarteschlange von der <xref:System.Windows.Threading.Dispatcher> an der angegebenen <xref:System.Windows.Threading.DispatcherPriority>.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> ist ein synchroner Vorgang. aus diesem Grund gibt Steuerelement nicht an das aufrufende Objekt erst zurück, nachdem der Rückruf zurückgegeben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="priority" /> is equal to <see cref="F:System.Windows.Threading.DispatcherPriority.Inactive" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="priority" /> is not a valid priority.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (System.Windows.Threading.DispatcherPriority priority, TimeSpan timeout, Delegate method);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(valuetype System.Windows.Threading.DispatcherPriority priority, valuetype System.TimeSpan timeout, class System.Delegate method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (priority As DispatcherPriority, timeout As TimeSpan, method As Delegate) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(System::Windows::Threading::DispatcherPriority priority, TimeSpan timeout, Delegate ^ method);" />
      <MemberSignature Language="F#" Value="member this.Invoke : System.Windows.Threading.DispatcherPriority * TimeSpan * Delegate -&gt; obj" Usage="dispatcher.Invoke (priority, timeout, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="method" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="priority">The priority, relative to the other pending operations in the <see cref="T:System.Windows.Threading.Dispatcher" /> event queue, the specified method is invoked.</param>
        <param name="timeout">The maximum time to wait for the operation to finish.</param>
        <param name="method">The delegate to a method that takes no arguments, which is pushed onto the <see cref="T:System.Windows.Threading.Dispatcher" /> event queue.</param>
        <summary>Executes the specified delegate synchronously at the specified priority and with the specified time-out value on the thread the <see cref="T:System.Windows.Threading.Dispatcher" /> was created.</summary>
        <returns>The return value from the delegate being invoked or <see langword="null" /> if the delegate has no return value.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], Threads, der erstellt eine <xref:System.Windows.Threading.DispatcherObject> kann dieses Objekt zugreifen.  Z. B. ein Hintergrundthread, der aus dem Hauptbenutzeroberflächen-Thread eröffnet kann nicht den Inhalt des aktualisiert eine <xref:System.Windows.Controls.Button> , die im UI-Thread erstellt wurde.  In der Reihenfolge des Hintergrundthreads, die Content-Eigenschaft für den Zugriff auf die <xref:System.Windows.Controls.Button>, der Hintergrundthread die Verarbeitung zur delegieren muss die <xref:System.Windows.Threading.Dispatcher> im UI-Thread zugeordnet.  Dies wird erreicht, indem Sie entweder <xref:System.Windows.Threading.Dispatcher.Invoke%2A> oder <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> ist synchron und <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> asynchron ist.  Der Vorgang wird hinzugefügt, auf die Ereigniswarteschlange von der <xref:System.Windows.Threading.Dispatcher> an der angegebenen <xref:System.Windows.Threading.DispatcherPriority>.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> ist ein synchroner Vorgang. aus diesem Grund gibt Steuerelement nicht an das aufrufende Objekt erst zurück, nachdem der Rückruf zurückgegeben.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public void Invoke (Action callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invoke(class System.Action callback, valuetype System.Windows.Threading.DispatcherPriority priority, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken,System.TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Invoke(Action ^ callback, System::Windows::Threading::DispatcherPriority priority, System::Threading::CancellationToken cancellationToken, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Action * System.Windows.Threading.DispatcherPriority * System.Threading.CancellationToken * TimeSpan -&gt; unit" Usage="dispatcher.Invoke (callback, priority, cancellationToken, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="callback">A delegate to invoke through the dispatcher.</param>
        <param name="priority">The priority that determines in what order the specified callback is invoked relative to the other pending operations in the <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <param name="cancellationToken">An object that indicates whether to cancel the action.</param>
        <param name="timeout">The minimum amount of time to wait for the operation to start.</param>
        <summary>Executes the specified <see cref="T:System.Action" /> synchronously at the specified priority on the thread the <see cref="T:System.Windows.Threading.Dispatcher" /> is associated with.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (Delegate method, TimeSpan timeout, System.Windows.Threading.DispatcherPriority priority, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(class System.Delegate method, valuetype System.TimeSpan timeout, valuetype System.Windows.Threading.DispatcherPriority priority, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.TimeSpan,System.Windows.Threading.DispatcherPriority,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (method As Delegate, timeout As TimeSpan, priority As DispatcherPriority, ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(Delegate ^ method, TimeSpan timeout, System::Windows::Threading::DispatcherPriority priority, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Delegate * TimeSpan * System.Windows.Threading.DispatcherPriority * obj[] -&gt; obj" Usage="dispatcher.Invoke (method, timeout, priority, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method">A delegate to a method that takes parameters specified in <c>args</c>, which is pushed onto the <see cref="T:System.Windows.Threading.Dispatcher" /> event queue.</param>
        <param name="timeout">The maximum amount of time to wait for the operation to complete.</param>
        <param name="priority">The priority, relative to the other pending operations in the <see cref="T:System.Windows.Threading.Dispatcher" /> event queue, the specified method is invoked.</param>
        <param name="args">An array of objects to pass as arguments to the given method. Can be <see langword="null" />.</param>
        <summary>Executes the specified delegate within the designated time span at the specified priority with the specified arguments synchronously on the thread the <see cref="T:System.Windows.Threading.Dispatcher" /> is associated with.</summary>
        <returns>The return value from the delegate being invoked or <see langword="null" /> if the delegate has no return value.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], Threads, der erstellt eine <xref:System.Windows.Threading.DispatcherObject> kann dieses Objekt zugreifen. Z. B. ein Hintergrundthread, der aus dem Hauptbenutzeroberflächen-Thread eröffnet kann nicht den Inhalt des aktualisiert eine <xref:System.Windows.Controls.Button> , die im UI-Thread erstellt wurde. In der Reihenfolge des Hintergrundthreads, die Content-Eigenschaft für den Zugriff auf die <xref:System.Windows.Controls.Button>, der Hintergrundthread die Verarbeitung zur delegieren muss die <xref:System.Windows.Threading.Dispatcher> im UI-Thread zugeordnet. Dies wird erreicht, indem Sie entweder <xref:System.Windows.Threading.Dispatcher.Invoke%2A> oder <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>. <xref:System.Windows.Threading.Dispatcher.Invoke%2A> ist synchron und <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> asynchron ist. Der Vorgang wird hinzugefügt, auf die Ereigniswarteschlange von der <xref:System.Windows.Threading.Dispatcher> an der angegebenen <xref:System.Windows.Threading.DispatcherPriority>.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> ist ein synchroner Vorgang. aus diesem Grund gibt Steuerelement nicht an das aufrufende Objekt erst zurück, nachdem der Rückruf zurückgegeben.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (System.Windows.Threading.DispatcherPriority priority, Delegate method, object arg, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(valuetype System.Windows.Threading.DispatcherPriority priority, class System.Delegate method, object arg, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (priority As DispatcherPriority, method As Delegate, arg As Object, ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(System::Windows::Threading::DispatcherPriority priority, Delegate ^ method, System::Object ^ arg, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.Invoke : System.Windows.Threading.DispatcherPriority * Delegate * obj * obj[] -&gt; obj" Usage="dispatcher.Invoke (priority, method, arg, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="arg" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="priority">The priority, relative to the other pending operations in the <see cref="T:System.Windows.Threading.Dispatcher" /> event queue, the specified method is invoked.</param>
        <param name="method">A delegate to a method that takes multiple arguments, which is pushed onto the <see cref="T:System.Windows.Threading.Dispatcher" /> event queue.</param>
        <param name="arg">An object to pass as an argument to the given method.</param>
        <param name="args">An array of objects to pass as arguments to the given method.</param>
        <summary>Executes the specified delegate at the specified priority with the specified arguments synchronously on the thread the <see cref="T:System.Windows.Threading.Dispatcher" /> is associated with.</summary>
        <returns>The return value from the delegate being invoked or <see langword="null" /> if the delegate has no return value.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Arg` kann `null` Wenn ein Argument nicht benötigt wird  
  
 In [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], Threads, der erstellt eine <xref:System.Windows.Threading.DispatcherObject> kann dieses Objekt zugreifen.  Z. B. ein Hintergrundthread, der aus dem Hauptbenutzeroberflächen-Thread eröffnet kann nicht den Inhalt des aktualisiert eine <xref:System.Windows.Controls.Button> , die im UI-Thread erstellt wurde.  In der Reihenfolge des Hintergrundthreads, die Content-Eigenschaft für den Zugriff auf die <xref:System.Windows.Controls.Button>, der Hintergrundthread die Verarbeitung zur delegieren muss die <xref:System.Windows.Threading.Dispatcher> im UI-Thread zugeordnet.  Dies wird erreicht, indem Sie entweder <xref:System.Windows.Threading.Dispatcher.Invoke%2A> oder <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> ist synchron und <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> asynchron ist.  Der Vorgang wird hinzugefügt, auf die Ereigniswarteschlange von der <xref:System.Windows.Threading.Dispatcher> an der angegebenen <xref:System.Windows.Threading.DispatcherPriority>.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> ist ein synchroner Vorgang. aus diesem Grund gibt Steuerelement nicht an das aufrufende Objekt erst zurück, nachdem der Rückruf zurückgegeben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="priority" /> is equal to <see cref="F:System.Windows.Threading.DispatcherPriority.Inactive" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="priority" /> is not a valid priority.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (System.Windows.Threading.DispatcherPriority priority, TimeSpan timeout, Delegate method, object arg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(valuetype System.Windows.Threading.DispatcherPriority priority, valuetype System.TimeSpan timeout, class System.Delegate method, object arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (priority As DispatcherPriority, timeout As TimeSpan, method As Delegate, arg As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(System::Windows::Threading::DispatcherPriority priority, TimeSpan timeout, Delegate ^ method, System::Object ^ arg);" />
      <MemberSignature Language="F#" Value="member this.Invoke : System.Windows.Threading.DispatcherPriority * TimeSpan * Delegate * obj -&gt; obj" Usage="dispatcher.Invoke (priority, timeout, method, arg)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="arg" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="priority">The priority, relative to the other pending operations in the <see cref="T:System.Windows.Threading.Dispatcher" /> event queue, the specified method is invoked.</param>
        <param name="timeout">The maximum time to wait for the operation to finish.</param>
        <param name="method">A delegate to a method that takes multiple arguments, which is pushed onto the <see cref="T:System.Windows.Threading.Dispatcher" /> event queue.</param>
        <param name="arg">An object to pass as an argument to the given method. This can be <see langword="null" /> if no arguments are needed.</param>
        <summary>Executes the specified delegate at the specified priority with the specified argument synchronously on the thread the <see cref="T:System.Windows.Threading.Dispatcher" /> is associated with.</summary>
        <returns>The return value from the delegate being invoked or <see langword="null" /> if the delegate has no return value.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Arg` kann `null` Wenn ein Argument nicht benötigt wird  
  
 In [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], Threads, der erstellt eine <xref:System.Windows.Threading.DispatcherObject> kann dieses Objekt zugreifen.  Z. B. ein Hintergrundthread, der aus dem Hauptbenutzeroberflächen-Thread eröffnet kann nicht den Inhalt des aktualisiert eine <xref:System.Windows.Controls.Button> , die im UI-Thread erstellt wurde.  In der Reihenfolge des Hintergrundthreads, die Content-Eigenschaft für den Zugriff auf die <xref:System.Windows.Controls.Button>, der Hintergrundthread die Verarbeitung zur delegieren muss die <xref:System.Windows.Threading.Dispatcher> im UI-Thread zugeordnet.  Dies wird erreicht, indem Sie entweder <xref:System.Windows.Threading.Dispatcher.Invoke%2A> oder <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> ist synchron und <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> asynchron ist.  Der Vorgang wird hinzugefügt, auf die Ereigniswarteschlange von der <xref:System.Windows.Threading.Dispatcher> an der angegebenen <xref:System.Windows.Threading.DispatcherPriority>.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> ist ein synchroner Vorgang. aus diesem Grund gibt Steuerelement nicht an das aufrufende Objekt erst zurück, nachdem der Rückruf zurückgegeben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="priority" /> is equal to <see cref="F:System.Windows.Threading.DispatcherPriority.Inactive" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="priority" /> is not a valid priority.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (System.Windows.Threading.DispatcherPriority priority, TimeSpan timeout, Delegate method, object arg, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(valuetype System.Windows.Threading.DispatcherPriority priority, valuetype System.TimeSpan timeout, class System.Delegate method, object arg, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate,System.Object,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (priority As DispatcherPriority, timeout As TimeSpan, method As Delegate, arg As Object, ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(System::Windows::Threading::DispatcherPriority priority, TimeSpan timeout, Delegate ^ method, System::Object ^ arg, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.Invoke : System.Windows.Threading.DispatcherPriority * TimeSpan * Delegate * obj * obj[] -&gt; obj" Usage="dispatcher.Invoke (priority, timeout, method, arg, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="arg" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="priority">The priority, relative to the other pending operations in the <see cref="T:System.Windows.Threading.Dispatcher" /> event queue, the specified method is invoked.</param>
        <param name="timeout">The maximum time to wait for the operation to finish.</param>
        <param name="method">A delegate to a method that takes multiple arguments, which is pushed onto the <see cref="T:System.Windows.Threading.Dispatcher" /> event queue.</param>
        <param name="arg">An object to pass as an argument to the specified method.</param>
        <param name="args">An array of objects to pass as arguments to the specified method.</param>
        <summary>Executes the specified delegate at the specified priority with the specified arguments synchronously on the thread the <see cref="T:System.Windows.Threading.Dispatcher" /> is associated with.</summary>
        <returns>The return value from the delegate being invoked or <see langword="null" /> if the delegate has no return value.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Arg` kann `null` Wenn ein Argument nicht benötigt wird.  
  
 In [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], Threads, der erstellt eine <xref:System.Windows.Threading.DispatcherObject> kann dieses Objekt zugreifen.  Z. B. ein Hintergrundthread, der aus dem Hauptbenutzeroberflächen-Thread eröffnet kann nicht den Inhalt des aktualisiert eine <xref:System.Windows.Controls.Button> , die im UI-Thread erstellt wurde.  In der Reihenfolge des Hintergrundthreads, die Content-Eigenschaft für den Zugriff auf die <xref:System.Windows.Controls.Button>, der Hintergrundthread die Verarbeitung zur delegieren muss die <xref:System.Windows.Threading.Dispatcher> im UI-Thread zugeordnet.  Dies wird erreicht, indem Sie entweder <xref:System.Windows.Threading.Dispatcher.Invoke%2A> oder <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> ist synchron und <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> asynchron ist.  Der Vorgang wird hinzugefügt, auf die Ereigniswarteschlange von der <xref:System.Windows.Threading.Dispatcher> an der angegebenen <xref:System.Windows.Threading.DispatcherPriority>.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> ist ein synchroner Vorgang. aus diesem Grund gibt Steuerelement nicht an das aufrufende Objekt erst zurück, nachdem der Rückruf zurückgegeben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="priority" /> is equal to <see cref="F:System.Windows.Threading.DispatcherPriority.Inactive" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="priority" /> is not a valid <see cref="T:System.Windows.Threading.DispatcherPriority" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public TResult Invoke&lt;TResult&gt; (Func&lt;TResult&gt; callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !!TResult Invoke&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke(Of TResult) (callback As Func(Of TResult)) As TResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; TResult Invoke(Func&lt;TResult&gt; ^ callback);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Func&lt;'Result&gt; -&gt; 'Result" Usage="dispatcher.Invoke callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callback" Type="System.Func&lt;TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Rückgabewert-Typ, der den angegebenen Delegaten.</typeparam>
        <param name="callback">A delegate to invoke through the dispatcher.</param>
        <summary>Executes the specified <see cref="T:System.Func`1" /> synchronously on the thread the <see cref="T:System.Windows.Threading.Dispatcher" /> is associated with.</summary>
        <returns>To be added.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Rückgabewert von `callback`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public TResult Invoke&lt;TResult&gt; (Func&lt;TResult&gt; callback, System.Windows.Threading.DispatcherPriority priority);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !!TResult Invoke&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; callback, valuetype System.Windows.Threading.DispatcherPriority priority) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority)" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke(Of TResult) (callback As Func(Of TResult), priority As DispatcherPriority) As TResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; TResult Invoke(Func&lt;TResult&gt; ^ callback, System::Windows::Threading::DispatcherPriority priority);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Func&lt;'Result&gt; * System.Windows.Threading.DispatcherPriority -&gt; 'Result" Usage="dispatcher.Invoke (callback, priority)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callback" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Rückgabewert-Typ, der den angegebenen Delegaten.</typeparam>
        <param name="callback">A delegate to invoke through the dispatcher.</param>
        <param name="priority">The priority that determines in what order the specified callback is invoked relative to the other pending operations in the <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <summary>Executes the specified <see cref="T:System.Func`1" /> synchronously at the specified priority on the thread the <see cref="T:System.Windows.Threading.Dispatcher" /> is associated with.</summary>
        <returns>To be added.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Rückgabewert von `callback`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public TResult Invoke&lt;TResult&gt; (Func&lt;TResult&gt; callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !!TResult Invoke&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; callback, valuetype System.Windows.Threading.DispatcherPriority priority, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; TResult Invoke(Func&lt;TResult&gt; ^ callback, System::Windows::Threading::DispatcherPriority priority, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Func&lt;'Result&gt; * System.Windows.Threading.DispatcherPriority * System.Threading.CancellationToken -&gt; 'Result" Usage="dispatcher.Invoke (callback, priority, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callback" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Rückgabewert-Typ, der den angegebenen Delegaten.</typeparam>
        <param name="callback">A delegate to invoke through the dispatcher.</param>
        <param name="priority">The priority that determines in what order the specified callback is invoked relative to the other pending operations in the <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <param name="cancellationToken">An object that indicates whether to cancel the operation.</param>
        <summary>Executes the specified <see cref="T:System.Func`1" /> synchronously at the specified priority on the thread the <see cref="T:System.Windows.Threading.Dispatcher" /> is associated with.</summary>
        <returns>To be added.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Rückgabewert von `callback`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public TResult Invoke&lt;TResult&gt; (Func&lt;TResult&gt; callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !!TResult Invoke&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; callback, valuetype System.Windows.Threading.DispatcherPriority priority, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken,System.TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; TResult Invoke(Func&lt;TResult&gt; ^ callback, System::Windows::Threading::DispatcherPriority priority, System::Threading::CancellationToken cancellationToken, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Func&lt;'Result&gt; * System.Windows.Threading.DispatcherPriority * System.Threading.CancellationToken * TimeSpan -&gt; 'Result" Usage="dispatcher.Invoke (callback, priority, cancellationToken, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callback" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Rückgabewert-Typ, der den angegebenen Delegaten.</typeparam>
        <param name="callback">A delegate to invoke through the dispatcher.</param>
        <param name="priority">The priority that determines in what order the specified callback is invoked relative to the other pending operations in the <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <param name="cancellationToken">An object that indicates whether to cancel the operation.</param>
        <param name="timeout">The minimum amount of time to wait for the operation to start.</param>
        <summary>Executes the specified <see cref="T:System.Func`1" /> synchronously at the specified priority on the thread the <see cref="T:System.Windows.Threading.Dispatcher" /> is associated with.</summary>
        <returns>To be added.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Rückgabewert von `callback`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="InvokeAsync">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Executes the specified delegate asynchronously on the thread the <see cref="T:System.Windows.Threading.Dispatcher" /> is associated with.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="InvokeAsync">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation InvokeAsync (Action callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation InvokeAsync(class System.Action callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.InvokeAsync(System.Action)" />
      <MemberSignature Language="VB.NET" Value="Public Function InvokeAsync (callback As Action) As DispatcherOperation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Threading::DispatcherOperation ^ InvokeAsync(Action ^ callback);" />
      <MemberSignature Language="F#" Value="member this.InvokeAsync : Action -&gt; System.Windows.Threading.DispatcherOperation" Usage="dispatcher.InvokeAsync callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action" />
      </Parameters>
      <Docs>
        <param name="callback">A delegate to invoke through the dispatcher.</param>
        <summary>Executes the specified <see cref="T:System.Action" /> asynchronously on the thread the <see cref="T:System.Windows.Threading.Dispatcher" /> is associated with.</summary>
        <returns>An object, which is returned immediately after <see cref="M:System.Windows.Threading.Dispatcher.InvokeAsync(System.Action)" /> is called, that can be used to interact with the delegate as it is pending execution in the event queue.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeAsync">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation InvokeAsync (Action callback, System.Windows.Threading.DispatcherPriority priority);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation InvokeAsync(class System.Action callback, valuetype System.Windows.Threading.DispatcherPriority priority) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.InvokeAsync(System.Action,System.Windows.Threading.DispatcherPriority)" />
      <MemberSignature Language="VB.NET" Value="Public Function InvokeAsync (callback As Action, priority As DispatcherPriority) As DispatcherOperation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Threading::DispatcherOperation ^ InvokeAsync(Action ^ callback, System::Windows::Threading::DispatcherPriority priority);" />
      <MemberSignature Language="F#" Value="member this.InvokeAsync : Action * System.Windows.Threading.DispatcherPriority -&gt; System.Windows.Threading.DispatcherOperation" Usage="dispatcher.InvokeAsync (callback, priority)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
      </Parameters>
      <Docs>
        <param name="callback">A delegate to invoke through the dispatcher.</param>
        <param name="priority">The priority that determines in what order the specified callback is invoked relative to the other pending operations in the <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <summary>Executes the specified <see cref="T:System.Action" /> asynchronously at the specified priority on the thread the <see cref="T:System.Windows.Threading.Dispatcher" /> is associated with.</summary>
        <returns>An object, which is returned immediately after <see cref="M:System.Windows.Threading.Dispatcher.InvokeAsync(System.Action,System.Windows.Threading.DispatcherPriority)" /> is called, that can be used to interact with the delegate as it is pending execution in the event queue.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeAsync">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation InvokeAsync (Action callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation InvokeAsync(class System.Action callback, valuetype System.Windows.Threading.DispatcherPriority priority, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.InvokeAsync(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Threading::DispatcherOperation ^ InvokeAsync(Action ^ callback, System::Windows::Threading::DispatcherPriority priority, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.InvokeAsync : Action * System.Windows.Threading.DispatcherPriority * System.Threading.CancellationToken -&gt; System.Windows.Threading.DispatcherOperation" Usage="dispatcher.InvokeAsync (callback, priority, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="callback">A delegate to invoke through the dispatcher.</param>
        <param name="priority">The priority that determines in what order the specified callback is invoked relative to the other pending operations in the <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <param name="cancellationToken">An object that indicates whether to cancel the action.</param>
        <summary>Executes the specified <see cref="T:System.Action" /> asynchronously at the specified priority on the thread the <see cref="T:System.Windows.Threading.Dispatcher" /> is associated with.</summary>
        <returns>An object, which is returned immediately after <see cref="M:System.Windows.Threading.Dispatcher.InvokeAsync(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)" /> is called, that can be used to interact with the delegate as it is pending execution in the event queue.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeAsync&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation&lt;TResult&gt; InvokeAsync&lt;TResult&gt; (Func&lt;TResult&gt; callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation`1&lt;!!TResult&gt; InvokeAsync&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function InvokeAsync(Of TResult) (callback As Func(Of TResult)) As DispatcherOperation(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Windows::Threading::DispatcherOperation&lt;TResult&gt; ^ InvokeAsync(Func&lt;TResult&gt; ^ callback);" />
      <MemberSignature Language="F#" Value="member this.InvokeAsync : Func&lt;'Result&gt; -&gt; System.Windows.Threading.DispatcherOperation&lt;'Result&gt;" Usage="dispatcher.InvokeAsync callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callback" Type="System.Func&lt;TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Rückgabewert-Typ, der den angegebenen Delegaten.</typeparam>
        <param name="callback">A delegate to invoke through the dispatcher.</param>
        <summary>Executes the specified <see cref="T:System.Func`1" /> asynchronously on the thread the <see cref="T:System.Windows.Threading.Dispatcher" /> is associated with.</summary>
        <returns>An object, which is returned immediately after <see cref="M:System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0})" /> is called, that can be used to interact with the delegate as it is pending execution in the event queue.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeAsync&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation&lt;TResult&gt; InvokeAsync&lt;TResult&gt; (Func&lt;TResult&gt; callback, System.Windows.Threading.DispatcherPriority priority);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation`1&lt;!!TResult&gt; InvokeAsync&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; callback, valuetype System.Windows.Threading.DispatcherPriority priority) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0},System.Windows.Threading.DispatcherPriority)" />
      <MemberSignature Language="VB.NET" Value="Public Function InvokeAsync(Of TResult) (callback As Func(Of TResult), priority As DispatcherPriority) As DispatcherOperation(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Windows::Threading::DispatcherOperation&lt;TResult&gt; ^ InvokeAsync(Func&lt;TResult&gt; ^ callback, System::Windows::Threading::DispatcherPriority priority);" />
      <MemberSignature Language="F#" Value="member this.InvokeAsync : Func&lt;'Result&gt; * System.Windows.Threading.DispatcherPriority -&gt; System.Windows.Threading.DispatcherOperation&lt;'Result&gt;" Usage="dispatcher.InvokeAsync (callback, priority)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callback" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Rückgabewert-Typ, der den angegebenen Delegaten.</typeparam>
        <param name="callback">A delegate to invoke through the dispatcher.</param>
        <param name="priority">The priority that determines in what order the specified callback is invoked relative to the other pending operations in the <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <summary>Executes the specified <see cref="T:System.Func`1" /> asynchronously at the specified priority on the thread the <see cref="T:System.Windows.Threading.Dispatcher" /> is associated with.</summary>
        <returns>An object, which is returned immediately after <see cref="M:System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0},System.Windows.Threading.DispatcherPriority)" /> is called, that can be used to interact with the delegate as it is pending execution in the event queue.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeAsync&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation&lt;TResult&gt; InvokeAsync&lt;TResult&gt; (Func&lt;TResult&gt; callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation`1&lt;!!TResult&gt; InvokeAsync&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; callback, valuetype System.Windows.Threading.DispatcherPriority priority, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Windows::Threading::DispatcherOperation&lt;TResult&gt; ^ InvokeAsync(Func&lt;TResult&gt; ^ callback, System::Windows::Threading::DispatcherPriority priority, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.InvokeAsync : Func&lt;'Result&gt; * System.Windows.Threading.DispatcherPriority * System.Threading.CancellationToken -&gt; System.Windows.Threading.DispatcherOperation&lt;'Result&gt;" Usage="dispatcher.InvokeAsync (callback, priority, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callback" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Rückgabewert-Typ, der den angegebenen Delegaten.</typeparam>
        <param name="callback">A delegate to invoke through the dispatcher.</param>
        <param name="priority">The priority that determines in what order the specified callback is invoked relative to the other pending operations in the <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <param name="cancellationToken">An object that indicates whether to cancel the operation.</param>
        <summary>Executes the specified <see cref="T:System.Func`1" /> synchronously at the specified priority on the thread the <see cref="T:System.Windows.Threading.Dispatcher" /> is associated with.</summary>
        <returns>An object, which is returned immediately after <see cref="M:System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)" /> is called, that can be used to interact with the delegate as it is pending execution in the event queue.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeShutdown">
      <MemberSignature Language="C#" Value="public void InvokeShutdown ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InvokeShutdown() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.InvokeShutdown" />
      <MemberSignature Language="VB.NET" Value="Public Sub InvokeShutdown ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InvokeShutdown();" />
      <MemberSignature Language="F#" Value="member this.InvokeShutdown : unit -&gt; unit" Usage="dispatcher.InvokeShutdown " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Initiates the shutdown process of the <see cref="T:System.Windows.Threading.Dispatcher" /> synchronously.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Threading.Dispatcher.InvokeShutdown%2A> setzt uneingeschränkte Benutzeroberflächen-Berechtigungen.  
  
 Wenn die <xref:System.Windows.Threading.Dispatcher> zum Herunterfahren beginnt die <xref:System.Windows.Threading.Dispatcher.ShutdownStarted> Ereignis wird ausgelöst, und <xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> auf festgelegt ist `true`.  
  
 Die <xref:System.Windows.Threading.Dispatcher> ist nicht vollständig heruntergefahren, bis die Ereigniswarteschlange abgearbeitet wurde.  
  
 Nach Abschluss der Verteiler heruntergefahren wird, die <xref:System.Windows.Threading.Dispatcher.ShutdownFinished> Ereignis wird ausgelöst, und die <xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A> -Eigenschaftensatz auf `true`.  
  
 Nachdem der Prozess des Herunterfahrens eingeleitet wurde, werden alle anstehenden Arbeitsaufgaben Elemente in der Warteschlange abgebrochen.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">für den Verteiler beendet.  Zugeordnete Enumerationen:  <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="PushFrame">
      <MemberSignature Language="C#" Value="public static void PushFrame (System.Windows.Threading.DispatcherFrame frame);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PushFrame(class System.Windows.Threading.DispatcherFrame frame) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.PushFrame(System.Windows.Threading.DispatcherFrame)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PushFrame (frame As DispatcherFrame)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PushFrame(System::Windows::Threading::DispatcherFrame ^ frame);" />
      <MemberSignature Language="F#" Value="static member PushFrame : System.Windows.Threading.DispatcherFrame -&gt; unit" Usage="System.Windows.Threading.Dispatcher.PushFrame frame" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="frame" Type="System.Windows.Threading.DispatcherFrame" />
      </Parameters>
      <Docs>
        <param name="frame">The frame for the dispatcher to process.</param>
        <summary>Enters an execute loop.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Windows.Threading.DispatcherFrame> stellt eine Schleife, die anstehende Arbeitsaufgaben verarbeitet.  
  
 Der Verteiler verarbeitet die Warteschlange in einer Schleife.  Die Schleife wird als Frame bezeichnet.  Die ursprüngliche Schleife wird in der Regel durch Aufrufen von der Anwendung initiiert <xref:System.Windows.Threading.Dispatcher.Run%2A>.  
  
 <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> Wechselt in einer Schleife, die vom Parameter dargestellten `frame`.  Bei jeder Iteration der Schleife die <xref:System.Windows.Threading.Dispatcher> prüft die <xref:System.Windows.Threading.DispatcherFrame.Continue%2A> Eigenschaft auf die <xref:System.Windows.Threading.DispatcherFrame> Klasse, um zu bestimmen, ob die Schleife fortgesetzt werden soll oder ob er beendet werden sollte.  
  
 <xref:System.Windows.Threading.DispatcherFrame> ermöglicht die <xref:System.Windows.Threading.DispatcherFrame.Continue%2A> -Eigenschaft explizit festgelegt werden und berücksichtigt die <xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> Eigenschaft auf die <xref:System.Windows.Threading.Dispatcher>.  Dies bedeutet, dass bei der <xref:System.Windows.Threading.Dispatcher> startet, beendet, Frames, die die standardmäßige <xref:System.Windows.Threading.DispatcherFrame> Implementierung wird beendet, wodurch alle geschachtelten Frames zu beenden.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie eine <xref:System.Windows.Threading.DispatcherFrame> als ähnliche Ergebnisse erzielen die [!INCLUDE[TLA#tla_winforms](~/includes/tlasharptla-winforms-md.md)] <xref:System.Windows.Forms.Application.DoEvents%2A> Methode.  
  
 [!code-csharp[dispatchersnippets#DispatcherDispatcherFrameDoEvents](~/samples/snippets/csharp/VS_Snippets_Wpf/DispatcherSnippets/CSharp/Window1.xaml.cs#dispatcherdispatcherframedoevents)]
 [!code-vb[dispatchersnippets#DispatcherDispatcherFrameDoEvents](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DispatcherSnippets/visualbasic/window1.xaml.vb#dispatcherdispatcherframedoevents)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="frame" /> is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Windows.Threading.Dispatcher.HasShutdownFinished" /> is <see langword="true" />  -or-  <paramref name="frame" /> is running on a different <see cref="T:System.Windows.Threading.Dispatcher" />.  -or-  Dispatcher processing has been disabled.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">für betätigen einen Frame Ausführung.  Zugeordnete Enumerationen:  <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="M:System.Windows.Threading.Dispatcher.ExitAllFrames" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Run" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run();" />
      <MemberSignature Language="F#" Value="static member Run : unit -&gt; unit" Usage="System.Windows.Threading.Dispatcher.Run " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pushes the main execution frame on the event queue of the <see cref="T:System.Windows.Threading.Dispatcher" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Threading.Dispatcher> die Ereigniswarteschlange in einer Schleife verarbeitet.  Die Schleife wird als Frame bezeichnet.  Die ursprüngliche Schleife wird in der Regel durch Aufrufen von der Anwendung initiiert <xref:System.Windows.Threading.Dispatcher.Run%2A>.  
  
 Die Hauptausführungsframe wird fortgesetzt, bis die <xref:System.Windows.Threading.Dispatcher> heruntergefahren wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShutdownFinished">
      <MemberSignature Language="C#" Value="public event EventHandler ShutdownFinished;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ShutdownFinished" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Threading.Dispatcher.ShutdownFinished" />
      <MemberSignature Language="VB.NET" Value="Public Event ShutdownFinished As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ShutdownFinished;" />
      <MemberSignature Language="F#" Value="member this.ShutdownFinished : EventHandler " Usage="member this.ShutdownFinished : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when the <see cref="T:System.Windows.Threading.Dispatcher" /> finishes shutting down.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Prozess des Herunterfahrens von einer <xref:System.Windows.Threading.Dispatcher> gestartet wird, die <xref:System.Windows.Threading.Dispatcher.ShutdownStarted> Ereignis wird ausgelöst, und <xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> auf festgelegt ist `true`.  
  
 Die <xref:System.Windows.Threading.Dispatcher> wird vollständig beendet, bis die Ereigniswarteschlange abgearbeitet wurde.  
  
 Nach Abschluss der Verteiler heruntergefahren wird, die <xref:System.Windows.Threading.Dispatcher.ShutdownFinished> Ereignis wird ausgelöst, und die <xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A> -Eigenschaftensatz auf `true`.  
  
 Nachdem der Prozess des Herunterfahrens eingeleitet wurde, werden alle anstehenden Arbeitsaufgaben Elemente in der Warteschlange abgebrochen.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Threading.Dispatcher.HasShutdownFinished" />
        <altmember cref="P:System.Windows.Threading.Dispatcher.HasShutdownStarted" />
        <altmember cref="M:System.Windows.Threading.Dispatcher.BeginInvokeShutdown(System.Windows.Threading.DispatcherPriority)" />
        <altmember cref="M:System.Windows.Threading.Dispatcher.InvokeShutdown" />
      </Docs>
    </Member>
    <Member MemberName="ShutdownStarted">
      <MemberSignature Language="C#" Value="public event EventHandler ShutdownStarted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ShutdownStarted" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Threading.Dispatcher.ShutdownStarted" />
      <MemberSignature Language="VB.NET" Value="Public Event ShutdownStarted As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ShutdownStarted;" />
      <MemberSignature Language="F#" Value="member this.ShutdownStarted : EventHandler " Usage="member this.ShutdownStarted : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when the <see cref="T:System.Windows.Threading.Dispatcher" /> begins to shut down.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Prozess des Herunterfahrens von einer <xref:System.Windows.Threading.Dispatcher> gestartet wird, die <xref:System.Windows.Threading.Dispatcher.ShutdownStarted> Ereignis wird ausgelöst, und <xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> auf festgelegt ist `true`.  
  
 Die <xref:System.Windows.Threading.Dispatcher> wird vollständig beendet, bis die Ereigniswarteschlange abgearbeitet wurde.  
  
 Nach Abschluss der Verteiler heruntergefahren wird, die <xref:System.Windows.Threading.Dispatcher.ShutdownFinished> Ereignis wird ausgelöst, und die <xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A> -Eigenschaftensatz auf `true`.  
  
 Nachdem der Prozess des Herunterfahrens eingeleitet wurde, werden alle anstehenden Arbeitsaufgaben Elemente in der Warteschlange abgebrochen.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Threading.Dispatcher.HasShutdownStarted" />
        <altmember cref="E:System.Windows.Threading.Dispatcher.ShutdownFinished" />
        <altmember cref="M:System.Windows.Threading.Dispatcher.BeginInvokeShutdown(System.Windows.Threading.DispatcherPriority)" />
        <altmember cref="M:System.Windows.Threading.Dispatcher.InvokeShutdown" />
      </Docs>
    </Member>
    <Member MemberName="Thread">
      <MemberSignature Language="C#" Value="public System.Threading.Thread Thread { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.Thread Thread" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Threading.Dispatcher.Thread" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Thread As Thread" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::Thread ^ Thread { System::Threading::Thread ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Thread : System.Threading.Thread" Usage="System.Windows.Threading.Dispatcher.Thread" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Thread</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the thread this <see cref="T:System.Windows.Threading.Dispatcher" /> is associated with.</summary>
        <value>Der Thread.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnhandledException">
      <MemberSignature Language="C#" Value="public event System.Windows.Threading.DispatcherUnhandledExceptionEventHandler UnhandledException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Threading.DispatcherUnhandledExceptionEventHandler UnhandledException" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Threading.Dispatcher.UnhandledException" />
      <MemberSignature Language="VB.NET" Value="Public Event UnhandledException As DispatcherUnhandledExceptionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Threading::DispatcherUnhandledExceptionEventHandler ^ UnhandledException;" />
      <MemberSignature Language="F#" Value="member this.UnhandledException : System.Windows.Threading.DispatcherUnhandledExceptionEventHandler " Usage="member this.UnhandledException : System.Windows.Threading.DispatcherUnhandledExceptionEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherUnhandledExceptionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when a thread exception is thrown and uncaught during execution of a delegate by way of <see cref="Overload:System.Windows.Threading.Dispatcher.Invoke" /> or <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis wird ausgelöst, wenn eine Ausnahme, die ausgelöst wurde, während der Ausführung eines Delegaten von <xref:System.Windows.Threading.Dispatcher.Invoke%2A> oder <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> nicht abgefangen wird.  
  
 Ein Handler kann die Ausnahme als behandelt markiert, die interne Ausnahmehandler hindert aufgerufen werden.  
  
 Ereignishandler für dieses Ereignis müssen mit großer Sorgfalt zur Vermeidung der Erstellung der sekundären Ausnahmen und zum Abfangen, die auftreten, geschrieben werden. Es wird empfohlen, um zu vermeiden, belegen von Speicher oder ressourcenintensiven Operationen im Handler durchzuführen.  
  
 Die <xref:System.Windows.Threading.Dispatcher.UnhandledExceptionFilter> Ereignis bietet eine Möglichkeit zum Auslösen der <xref:System.Windows.Threading.Dispatcher.UnhandledException> Ereignis.  Die <xref:System.Windows.Threading.Dispatcher.UnhandledExceptionFilter> Ereignis wird zuerst ausgelöst und, wenn <xref:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs.RequestCatch%2A> auf die <xref:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs> auf festgelegt ist `false`, die <xref:System.Windows.Threading.Dispatcher.UnhandledException> -Ereignis wird nicht ausgelöst werden.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Threading.DispatcherUnhandledExceptionEventHandler" />
        <altmember cref="T:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="UnhandledExceptionFilter">
      <MemberSignature Language="C#" Value="public event System.Windows.Threading.DispatcherUnhandledExceptionFilterEventHandler UnhandledExceptionFilter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Threading.DispatcherUnhandledExceptionFilterEventHandler UnhandledExceptionFilter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Threading.Dispatcher.UnhandledExceptionFilter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event UnhandledExceptionFilter As DispatcherUnhandledExceptionFilterEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Threading::DispatcherUnhandledExceptionFilterEventHandler ^ UnhandledExceptionFilter;" />
      <MemberSignature Language="F#" Value="member this.UnhandledExceptionFilter : System.Windows.Threading.DispatcherUnhandledExceptionFilterEventHandler " Usage="member this.UnhandledExceptionFilter : System.Windows.Threading.DispatcherUnhandledExceptionFilterEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherUnhandledExceptionFilterEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when a thread exception is thrown and uncaught during execution of a delegate by way of <see cref="Overload:System.Windows.Threading.Dispatcher.Invoke" /> or <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" /> when in the filter stage.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis wird ausgelöst, während der Phase Filter für eine Ausnahme, die ausgelöst wird, während der Ausführung eines Delegaten mithilfe von <xref:System.Windows.Threading.Dispatcher.Invoke%2A> oder <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> und nicht abgefangen wird.  
  
 Die Aufrufliste wird nicht entladen an dieser Stelle (erste Chance Ausnahme).  
  
 Ereignishandler für dieses Ereignis müssen mit großer Sorgfalt zur Vermeidung der Erstellung der sekundären Ausnahmen und zum Abfangen, die auftreten, geschrieben werden.  Es wird empfohlen, um zu vermeiden, belegen von Speicher oder ressourcenintensiven Operationen im Handler durchzuführen.  
  
 Die <xref:System.Windows.Threading.Dispatcher.UnhandledExceptionFilter> Ereignis bietet eine Möglichkeit zum Auslösen der <xref:System.Windows.Threading.Dispatcher.UnhandledException> Ereignis.  Die <xref:System.Windows.Threading.Dispatcher.UnhandledExceptionFilter> Ereignis wird zuerst ausgelöst und, wenn <xref:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs.RequestCatch%2A> auf die <xref:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs> auf festgelegt ist `false`, die <xref:System.Windows.Threading.Dispatcher.UnhandledException> -Ereignis wird nicht ausgelöst werden.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">für das Hinzufügen oder entfernen einen Handler für dieses Ereignis.  Zugeordnete Enumerationen:  <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventHandler" />
        <altmember cref="T:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="ValidatePriority">
      <MemberSignature Language="C#" Value="public static void ValidatePriority (System.Windows.Threading.DispatcherPriority priority, string parameterName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ValidatePriority(valuetype System.Windows.Threading.DispatcherPriority priority, string parameterName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.ValidatePriority(System.Windows.Threading.DispatcherPriority,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ValidatePriority (priority As DispatcherPriority, parameterName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ValidatePriority(System::Windows::Threading::DispatcherPriority priority, System::String ^ parameterName);" />
      <MemberSignature Language="F#" Value="static member ValidatePriority : System.Windows.Threading.DispatcherPriority * string -&gt; unit" Usage="System.Windows.Threading.Dispatcher.ValidatePriority (priority, parameterName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="parameterName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="priority">The priority to check.</param>
        <param name="parameterName">A string that will be returned by the exception that occurs if the priority is invalid.</param>
        <summary>Determines whether the specified <see cref="T:System.Windows.Threading.DispatcherPriority" /> is a valid priority.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="priority" /> is not a valid <see cref="T:System.Windows.Threading.DispatcherPriority" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="VerifyAccess">
      <MemberSignature Language="C#" Value="public void VerifyAccess ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void VerifyAccess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.VerifyAccess" />
      <MemberSignature Language="VB.NET" Value="Public Sub VerifyAccess ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void VerifyAccess();" />
      <MemberSignature Language="F#" Value="member this.VerifyAccess : unit -&gt; unit" Usage="dispatcher.VerifyAccess " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Determines whether the calling thread has access to this <see cref="T:System.Windows.Threading.Dispatcher" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nur der Thread den <xref:System.Windows.Threading.Dispatcher> wird erstellt, auf kann zugegriffen werden, die <xref:System.Windows.Threading.Dispatcher>.  
  
 Diese Methode ist öffentlich. Jeder Thread kann daher überprüfen, um festzustellen, ob sie Zugriff auf hat die <xref:System.Windows.Threading.Dispatcher>.  
  
 Der Unterschied zwischen <xref:System.Windows.Threading.Dispatcher.CheckAccess%2A> und <xref:System.Windows.Threading.Dispatcher.VerifyAccess%2A> ist <xref:System.Windows.Threading.Dispatcher.CheckAccess%2A> gibt einen booleschen Wert zurück, wenn der aufrufende Thread keinen Zugriff auf die <xref:System.Windows.Threading.Dispatcher> und <xref:System.Windows.Threading.Dispatcher.VerifyAccess%2A> löst eine Ausnahme aus.  
  
   
  
## Examples  
 Im folgenden Beispiel wird <xref:System.Windows.Threading.Dispatcher.VerifyAccess%2A> bestimmen, ob ein Thread den Zugriff auf den Thread verfügt, die eine <xref:System.Windows.Controls.Button> erstellt wurde.  Die Methode nimmt ein Objekt als Argument, das in umgewandelt wird eine <xref:System.Windows.Controls.Button>.  Die <xref:System.Windows.Threading.Dispatcher.VerifyAccess%2A> Methode für die <xref:System.Windows.Threading.Dispatcher> von der <xref:System.Windows.Controls.Button> wird aufgerufen, um den Zugriff auf den Thread zu überprüfen.  
  
 Verfügt der aufrufende Thread den Zugriff auf die <xref:System.Windows.Threading.Dispatcher>, die <xref:System.Windows.Controls.Button> wird aktualisiert, indem Sie nur Zugriff auf die Mitglieder der <xref:System.Windows.Controls.Button>.  
  
 Wenn der aufrufende Thread nicht über Zugriff verfügt, wird eine <xref:System.InvalidOperationException> ausgelöst wird.  In diesem Beispiel fängt die Ausnahme ab und legt einen Delegaten, die akzeptiert eine <xref:System.Windows.Controls.Button> als Argument, auf die <xref:System.Windows.Threading.Dispatcher> von der <xref:System.Windows.Controls.Button>.  Dies <xref:System.Windows.Threading.Dispatcher> kommt die Arbeit aktualisieren die <xref:System.Windows.Controls.Button>.  
  
 [!code-csharp[DispatcherAccessSample#DispatcherAccessVerifyAccess](~/samples/snippets/csharp/VS_Snippets_Wpf/DispatcherAccessSample/CSharp/Window1.xaml.cs#dispatcheraccessverifyaccess)]
 [!code-vb[DispatcherAccessSample#DispatcherAccessVerifyAccess](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DispatcherAccessSample/visualbasic/window1.xaml.vb#dispatcheraccessverifyaccess)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The calling thread does not have access to this <see cref="T:System.Windows.Threading.Dispatcher" />.</exception>
        <altmember cref="M:System.Windows.Threading.Dispatcher.CheckAccess" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Yield">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Creates an awaitable object that asynchronously yields control back to the current dispatcher and provides an opportunity for the dispatcher to process other events.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Yield">
      <MemberSignature Language="C#" Value="public static System.Windows.Threading.DispatcherPriorityAwaitable Yield ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.Threading.DispatcherPriorityAwaitable Yield() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Yield" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Yield () As DispatcherPriorityAwaitable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Threading::DispatcherPriorityAwaitable Yield();" />
      <MemberSignature Language="F#" Value="static member Yield : unit -&gt; System.Windows.Threading.DispatcherPriorityAwaitable" Usage="System.Windows.Threading.Dispatcher.Yield " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherPriorityAwaitable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Creates an awaitable object that asynchronously yields control back to the current dispatcher and provides an opportunity for the dispatcher to process other events.</summary>
        <returns>An awaitable object that asynchronously yields control back to the current dispatcher and provides an opportunity for the dispatcher to process other events.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode bietet eine Möglichkeit, ausführungssteuerung an den aktuellen Verteiler vorübergehend freigegeben, sodass es andere arbeiten, wie z. B. andere Ereignisse verarbeiten durchführen kann. Verwenden der `await`, oder `Await` in Visual Basic Operator für den Rückgabewert, um die Steuerung an den aktuellen Verteiler zurückzugeben. Verwenden Sie diese Methode, wenn möchten, Ihre app zu ermöglichen, um Ereignisse zu verarbeiten, während Ihre app sehr viel Arbeit an der UI-Thread ausgeführt wird. Beispielsweise können Sie diese Methode in einer Schleife langer verwenden, die ein Steuerelement aktualisiert.  
  
 Diese Methode entspricht dem Aufrufen der <xref:System.Windows.Threading.Dispatcher.Yield%28System.Windows.Threading.DispatcherPriority%29> -Methode und übergeben <xref:System.Windows.Threading.DispatcherPriority.Background?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Yield">
      <MemberSignature Language="C#" Value="public static System.Windows.Threading.DispatcherPriorityAwaitable Yield (System.Windows.Threading.DispatcherPriority priority);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.Threading.DispatcherPriorityAwaitable Yield(valuetype System.Windows.Threading.DispatcherPriority priority) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Yield(System.Windows.Threading.DispatcherPriority)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Yield (priority As DispatcherPriority) As DispatcherPriorityAwaitable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Threading::DispatcherPriorityAwaitable Yield(System::Windows::Threading::DispatcherPriority priority);" />
      <MemberSignature Language="F#" Value="static member Yield : System.Windows.Threading.DispatcherPriority -&gt; System.Windows.Threading.DispatcherPriorityAwaitable" Usage="System.Windows.Threading.Dispatcher.Yield priority" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherPriorityAwaitable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
      </Parameters>
      <Docs>
        <param name="priority">The priority at which to schedule the continuation.</param>
        <summary>Creates an awaitable object that asynchronously yields control back to the current dispatcher and provides an opportunity for the dispatcher to process other events.  The work that occurs when control returns to the code awaiting the result of this method is scheduled with the specified priority.</summary>
        <returns>An awaitable object that asynchronously yields control back to the current dispatcher and provides an opportunity for the dispatcher to process other events.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode bietet eine Möglichkeit, ausführungssteuerung an den aktuellen Verteiler vorübergehend freigegeben, sodass es andere arbeiten, wie z. B. andere Ereignisse verarbeiten durchführen kann. Verwenden der `await`, oder `Await` in Visual Basic Operator für den Rückgabewert, um die Steuerung an den aktuellen Verteiler zurückzugeben. Verwenden Sie diese Methode, wenn möchten, Ihre app zu ermöglichen, um Ereignisse zu verarbeiten, während Ihre app sehr viel Arbeit an der UI-Thread ausgeführt wird. Beispielsweise können Sie diese Methode in einer Schleife langer verwenden, die ein Steuerelement aktualisiert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>