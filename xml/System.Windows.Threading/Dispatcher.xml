<Type Name="Dispatcher" FullName="System.Windows.Threading.Dispatcher">
  <Metadata><Meta Name="ms.openlocfilehash" Value="ab9a64e8091e1a2ec87eca8cf5d6ecdc6e07ca7c" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69435406" /></Metadata><TypeSignature Language="C#" Value="public sealed class Dispatcher" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed Dispatcher extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Threading.Dispatcher" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Dispatcher" />
  <TypeSignature Language="C++ CLI" Value="public ref class Dispatcher sealed" />
  <TypeSignature Language="F#" Value="type Dispatcher = class" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Stellt Dienste zum Verwalten der Warteschlange von Arbeitselementen für einen Thread bereit.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Threading.Dispatcher> Verwaltet eine priorisierte Warteschlange von Arbeitsaufgaben für einen bestimmten Thread.  
  
 Wenn ein <xref:System.Windows.Threading.Dispatcher> in einem Thread erstellt wird, wird es zum einzigen <xref:System.Windows.Threading.Dispatcher> , das dem Thread zugeordnet werden kann, auch wenn der <xref:System.Windows.Threading.Dispatcher> heruntergefahren wird.  
  
 Wenn Sie versuchen, die <xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A> für den aktuellen Thread zu erhalten, und ein <xref:System.Windows.Threading.Dispatcher> nicht mit dem Thread verknüpft ist <xref:System.Windows.Threading.Dispatcher> , wird ein erstellt. Eine <xref:System.Windows.Threading.Dispatcher> wird auch erstellt, wenn Sie einen <xref:System.Windows.Threading.DispatcherObject>erstellen. Wenn Sie ein <xref:System.Windows.Threading.Dispatcher> in einem Hintergrund Thread erstellen, müssen Sie den Verteiler beenden, bevor Sie den Thread beenden.  
  
 Wenn ein <xref:System.Windows.Threading.Dispatcher> heruntergefahren wird, kann es nicht neu gestartet werden.  
  
 In [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] <xref:System.Windows.Threading.DispatcherObject> kann nur von dem darauf zugegriffen werden, <xref:System.Windows.Threading.Dispatcher> dem es zugeordnet ist.  Ein Hintergrund Thread kann z. b. den Inhalt einer <xref:System.Windows.Controls.Button> nicht aktualisieren, die mit dem <xref:System.Windows.Threading.Dispatcher> im [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] Thread verknüpft ist.  Damit der Hintergrund <xref:System.Windows.Controls.ContentControl.Content%2A> Thread auf die-Eigenschaft <xref:System.Windows.Controls.Button>von zugreifen kann, muss der Hintergrund Thread die Arbeit [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] an die <xref:System.Windows.Threading.Dispatcher> dem Thread zugeordnete delegieren.  Dies wird mithilfe <xref:System.Windows.Threading.Dispatcher.Invoke%2A> von oder <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>erreicht. <xref:System.Windows.Threading.Dispatcher.Invoke%2A>ist synchron und <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> ist asynchron.  Der-Vorgang wird der-Warteschlange von <xref:System.Windows.Threading.Dispatcher> am angegebenen <xref:System.Windows.Threading.DispatcherPriority>hinzugefügt.  
  
 Wenn <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> für einen <xref:System.Windows.Threading.Dispatcher> aufgerufen wird, der heruntergefahren wurde, wird die Status-Eigenschaft <xref:System.Windows.Threading.DispatcherOperation> des zurückgegebenen <xref:System.Windows.Threading.DispatcherOperationStatus.Aborted>auf festgelegt.  
  
 Alle Methoden in <xref:System.Windows.Threading.Dispatcher>, mit Ausnahme von <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A>, sind frei Thread.  
  
 Objekte, die von <xref:System.Windows.Threading.DispatcherObject> abgeleitet werden, haben Thread Affinität.  
  
 Objekte, die von <xref:System.Windows.Freezable> abgeleitet werden, sind frei Thread, wenn Sie eingefroren werden.  Weitere Informationen finden Sie unter der [Übersicht über Freezable-Objekte](~/docs/framework/wpf/advanced/freezable-objects-overview.md).  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie Sie einen Vorgang auf <xref:System.Windows.Threading.Dispatcher>einem platzieren.  Den vollständigen Quellcode dieses Beispiels finden Sie unter Beispiel für [Single Thread-Anwendung mit langer Berechnung](https://go.microsoft.com/fwlink/?LinkID=160038).  
  
 Zuerst wird ein Delegat erstellt, der keine Argumente akzeptiert.  
  
 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberInit](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberinit)] 
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberInit](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberinit)]   
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%28System.Windows.Threading.DispatcherPriority%2CSystem.Delegate%29> Anschließend wird aufgerufen.  Dieser Aufruf von <xref:System.Windows.Threading.Dispatcher.BeginInvoke%28System.Windows.Threading.DispatcherPriority%2CSystem.Delegate%29> erfordert zwei Parameter: die Priorität, die auf <xref:System.Windows.Threading.DispatcherPriority.Normal?displayProperty=nameWithType>festgelegt ist, und der Rückruf, der durch `NextPrimeDelegate`eine Instanz des Delegaten übermittelt wird.  
  
 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberBeginInvoke](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberbegininvoke)] 
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberBeginInvoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberbegininvoke)]   
  
 ]]></format>
    </remarks>
    <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=160038">Beispiel für Single Thread-Anwendung mit langer Berechnung</related>
  </Docs>
  <Members>
    <MemberGroup MemberName="BeginInvoke">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Führt eine Delegaten asynchron auf dem Thread aus, dem der <see cref="T:System.Windows.Threading.Dispatcher" /> zugeordnet ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]kann nur der Thread, der einen <xref:System.Windows.Threading.DispatcherObject> erstellt hat, auf dieses Objekt zugreifen.  Beispielsweise kann ein Hintergrund Thread, der aus dem Hauptbenutzer Oberflächen-Thread ausgelöst wird, den Inhalt eines <xref:System.Windows.Controls.Button> nicht aktualisieren, der im UI-Thread erstellt wurde.  Damit der Hintergrund Thread auf die Content-Eigenschaft von <xref:System.Windows.Controls.Button>zugreifen kann, muss der Hintergrund Thread die Arbeit an die <xref:System.Windows.Threading.Dispatcher> mit dem UI-Thread zugeordnete delegieren.  Dies wird mithilfe <xref:System.Windows.Threading.Dispatcher.Invoke%2A> von oder <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>erreicht.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A>ist synchron und <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> ist asynchron.  Der-Vorgang wird der-Ereignis Warteschlange <xref:System.Windows.Threading.Dispatcher> von am angegebenen <xref:System.Windows.Threading.DispatcherPriority>hinzugefügt.  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>ist asynchron. Daher wird die Steuerung sofort an das aufrufenden Objekt zurückgegeben, nachdem es aufgerufen wurde.  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>Gibt ein <xref:System.Windows.Threading.DispatcherOperation> -Objekt zurück, das zum interagieren mit dem Delegaten verwendet werden kann, wenn sich der Delegat in der Ereignis Warteschlange befindet  
  
 Das <xref:System.Windows.Threading.DispatcherOperation> von<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> zurückgegebene-Objekt kann auf verschiedene Arten verwendet werden, um mit dem angegebenen Delegaten zu interagieren, z. b.:  
  
-   Ändern der <xref:System.Windows.Threading.DispatcherPriority> des Delegaten, während die Ausführung in der Ereignis Warteschlange ausstehend ist.  
  
-   Entfernen des Delegaten aus der Ereignis Warteschlange.  
  
-   Warten, bis der Delegat zurückgegeben wird.  
  
-   Abrufen des Werts, den der Delegat zurückgibt, nachdem er ausgeführt wurde.  
  
 Wenn mehrere <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> Aufrufe gleichzeitig <xref:System.Windows.Threading.DispatcherPriority>durchgeführt werden, werden Sie in der Reihenfolge ausgeführt, in der die Aufrufe durchgeführt wurden.  
  
 Wenn <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> für einen <xref:System.Windows.Threading.Dispatcher> aufgerufen wird, der heruntergefahren wurde, wird die Status-Eigenschaft <xref:System.Windows.Threading.DispatcherOperation> des zurückgegebenen <xref:System.Windows.Threading.DispatcherOperationStatus.Aborted>auf festgelegt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginInvoke">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation BeginInvoke (Delegate method, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation BeginInvoke(class System.Delegate method, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.BeginInvoke(System.Delegate,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginInvoke (method As Delegate, ParamArray args As Object()) As DispatcherOperation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Threading::DispatcherOperation ^ BeginInvoke(Delegate ^ method, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.BeginInvoke : Delegate * obj[] -&gt; System.Windows.Threading.DispatcherOperation" Usage="dispatcher.BeginInvoke (method, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method">Der Delegat für eine Methode, die in <paramref name="args" /> angegebene Parameter akzeptiert und in die <see cref="T:System.Windows.Threading.Dispatcher" />-Ereigniswarteschlange gestellt wird.</param>
        <param name="args">Ein Array von Objekten, die als Argumente an die angegebene Methode übergeben werden sollen. Kann <see langword="null" /> sein.</param>
        <summary>Führt den angegebenen Delegaten asynchron mit den angegebenen Argumenten für den Thread aus, für den der <see cref="T:System.Windows.Threading.Dispatcher" /> erstellt wurde.</summary>
        <returns>Ein Objekt, das unmittelbar nach dem Aufruf von <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" /> zurückgegeben wird und für die Interaktion mit dem Delegaten verwendet werden kann, während im Delegaten die Ausführung einer Aufgabe in der Warteschlange steht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das <xref:System.Windows.Threading.DispatcherOperation> von<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> zurückgegebene-Objekt kann auf verschiedene Arten verwendet werden, um mit dem angegebenen Delegaten zu interagieren, z. b.:  
  
-   Ändern der <xref:System.Windows.Threading.DispatcherPriority> des Delegaten, während die Ausführung in der Ereignis Warteschlange ausstehend ist.  
  
-   Entfernen des Delegaten aus der Ereignis Warteschlange.  
  
-   Warten, bis der Delegat zurückgegeben wird.  
  
-   Abrufen des Werts, den der Delegat zurückgibt, nachdem er ausgeführt wurde.  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>ist asynchron. Daher wird die Steuerung sofort an das aufrufenden Objekt zurückgegeben, nachdem es aufgerufen wurde.  
  
 In [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]kann nur der Thread, der einen <xref:System.Windows.Threading.DispatcherObject> erstellt hat, auf dieses Objekt zugreifen. Beispielsweise kann ein Hintergrund Thread, der aus dem Hauptbenutzer Oberflächen-Thread ausgelöst wird, den Inhalt eines <xref:System.Windows.Controls.Button> nicht aktualisieren, der im UI-Thread erstellt wurde. Damit der Hintergrund Thread auf die Content-Eigenschaft von <xref:System.Windows.Controls.Button>zugreifen kann, muss der Hintergrund Thread die Arbeit an die <xref:System.Windows.Threading.Dispatcher> mit dem UI-Thread zugeordnete delegieren. Dies wird mithilfe <xref:System.Windows.Threading.Dispatcher.Invoke%2A> von oder <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>erreicht. <xref:System.Windows.Threading.Dispatcher.Invoke%2A>ist synchron und <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> ist asynchron. Der-Vorgang wird der-Ereignis Warteschlange <xref:System.Windows.Threading.Dispatcher> von am angegebenen <xref:System.Windows.Threading.DispatcherPriority>hinzugefügt.  
  
 Wenn <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> für einen <xref:System.Windows.Threading.Dispatcher> aufgerufen wird, der heruntergefahren wurde, wird die Status-Eigenschaft <xref:System.Windows.Threading.DispatcherOperation> des zurückgegebenen <xref:System.Windows.Threading.DispatcherOperationStatus.Aborted>auf festgelegt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginInvoke">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation BeginInvoke (System.Windows.Threading.DispatcherPriority priority, Delegate method);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation BeginInvoke(valuetype System.Windows.Threading.DispatcherPriority priority, class System.Delegate method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginInvoke (priority As DispatcherPriority, method As Delegate) As DispatcherOperation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Threading::DispatcherOperation ^ BeginInvoke(System::Windows::Threading::DispatcherPriority priority, Delegate ^ method);" />
      <MemberSignature Language="F#" Value="member this.BeginInvoke : System.Windows.Threading.DispatcherPriority * Delegate -&gt; System.Windows.Threading.DispatcherOperation" Usage="dispatcher.BeginInvoke (priority, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="method" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="priority">Die Priorität, relativ zu den anderen anstehenden Operationen in der <see cref="T:System.Windows.Threading.Dispatcher" />-Ereigniswarteschlange, mit der die angegebene Methode aufgerufen wird.</param>
        <param name="method">Der Delegat zu einer Methode, die keine Argumente erwartet und in die <see cref="T:System.Windows.Threading.Dispatcher" />-Ereigniswarteschlange gestellt wird.</param>
        <summary>Führt den angegebenen Delegaten asynchron mit der angegebenen Priorität auf dem Thread aus, dem der <see cref="T:System.Windows.Threading.Dispatcher" /> zugeordnet ist.</summary>
        <returns>Ein Objekt, das unmittelbar nach dem Aufruf von <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" /> zurückgegeben wird und für die Interaktion mit dem Delegaten verwendet werden kann, während im Delegaten die Ausführung einer Aufgabe in der Warteschlange steht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn mehrere <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> Aufrufe gleichzeitig <xref:System.Windows.Threading.DispatcherPriority>durchgeführt werden, werden Sie in der Reihenfolge ausgeführt, in der die Aufrufe durchgeführt wurden.  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>Gibt ein <xref:System.Windows.Threading.DispatcherOperation> -Objekt zurück, das zum interagieren mit dem Delegaten verwendet werden kann, wenn sich der Delegat in der Ereignis Warteschlange befindet  
  
 Das <xref:System.Windows.Threading.DispatcherOperation> von<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> zurückgegebene-Objekt kann auf verschiedene Arten verwendet werden, um mit dem angegebenen Delegaten zu interagieren, z. b.:  
  
-   Ändern der <xref:System.Windows.Threading.DispatcherPriority> des Delegaten, während die Ausführung in der Ereignis Warteschlange ausstehend ist.  
  
-   Entfernen des Delegaten aus der Ereignis Warteschlange.  
  
-   Warten, bis der Delegat zurückgegeben wird.  
  
-   Abrufen des Werts, den der Delegat zurückgibt, nachdem er ausgeführt wurde.  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>ist asynchron. Daher wird die Steuerung sofort an das aufrufenden Objekt zurückgegeben, nachdem es aufgerufen wurde.  
  
 In [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]kann nur der Thread, der einen <xref:System.Windows.Threading.DispatcherObject> erstellt hat, auf dieses Objekt zugreifen.  Beispielsweise kann ein Hintergrund Thread, der aus dem Hauptbenutzer Oberflächen-Thread ausgelöst wird, den Inhalt eines <xref:System.Windows.Controls.Button> nicht aktualisieren, der im UI-Thread erstellt wurde.  Damit der Hintergrund Thread auf die Content-Eigenschaft von <xref:System.Windows.Controls.Button>zugreifen kann, muss der Hintergrund Thread die Arbeit an die <xref:System.Windows.Threading.Dispatcher> mit dem UI-Thread zugeordnete delegieren.  Dies wird mithilfe <xref:System.Windows.Threading.Dispatcher.Invoke%2A> von oder <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>erreicht.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A>ist synchron und <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> ist asynchron.  Der-Vorgang wird der-Ereignis Warteschlange <xref:System.Windows.Threading.Dispatcher> von am angegebenen <xref:System.Windows.Threading.DispatcherPriority>hinzugefügt.  
  
 Wenn <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> für einen <xref:System.Windows.Threading.Dispatcher> aufgerufen wird, der heruntergefahren wurde, wird die Status-Eigenschaft <xref:System.Windows.Threading.DispatcherOperation> des zurückgegebenen <xref:System.Windows.Threading.DispatcherOperationStatus.Aborted>auf festgelegt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie Sie einen Vorgang auf <xref:System.Windows.Threading.Dispatcher>einem platzieren.  Den vollständigen Quellcode dieses Beispiels finden Sie unter Beispiel für [Single Thread-Anwendung mit langer Berechnung](https://go.microsoft.com/fwlink/?LinkID=160038).  
  
 Zuerst wird ein Delegat erstellt, der keine Argumente akzeptiert.  
  
 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberInit](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberinit)] 
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberInit](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberinit)]   
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%28System.Windows.Threading.DispatcherPriority%2CSystem.Delegate%29> Anschließend wird aufgerufen.  Da jeder <xref:System.Windows.Threading.DispatcherObject> über eine-Eigenschaft verfügt, <xref:System.Windows.Threading.Dispatcher> die das-Objekt zurückgibt, <xref:System.Windows.Threading.Dispatcher> das ihm zugeordnet ist, wird <xref:System.Windows.Threading.DispatcherObject>das gewünschte abgerufen, indem <xref:System.Windows.Controls.Button> das `startStopButton`abgerufen wird, in diesem Fall ein mit dem Namen.   Der Aufruf von <xref:System.Windows.Threading.Dispatcher.BeginInvoke%28System.Windows.Threading.DispatcherPriority%2CSystem.Delegate%29> erfordert zwei Parameter: die Priorität, die auf <xref:System.Windows.Threading.DispatcherPriority.Normal?displayProperty=nameWithType>festgelegt ist, und der Rückruf, der über `NextPrimeDelegate`eine Instanz des Delegaten übermittelt wird.  
  
 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberBeginInvoke](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberbegininvoke)] 
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberBeginInvoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberbegininvoke)]   
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="method" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="priority" /> ist kein gültiger <see cref="T:System.Windows.Threading.DispatcherPriority" />.</exception>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=160038">Beispiel für Single Thread-Anwendung mit langer Berechnung</related>
      </Docs>
    </Member>
    <Member MemberName="BeginInvoke">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation BeginInvoke (Delegate method, System.Windows.Threading.DispatcherPriority priority, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation BeginInvoke(class System.Delegate method, valuetype System.Windows.Threading.DispatcherPriority priority, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.BeginInvoke(System.Delegate,System.Windows.Threading.DispatcherPriority,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginInvoke (method As Delegate, priority As DispatcherPriority, ParamArray args As Object()) As DispatcherOperation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Threading::DispatcherOperation ^ BeginInvoke(Delegate ^ method, System::Windows::Threading::DispatcherPriority priority, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.BeginInvoke : Delegate * System.Windows.Threading.DispatcherPriority * obj[] -&gt; System.Windows.Threading.DispatcherOperation" Usage="dispatcher.BeginInvoke (method, priority, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method">Der Delegat für eine Methode, die in <paramref name="args" /> angegebene Parameter akzeptiert und in die <see cref="T:System.Windows.Threading.Dispatcher" />-Ereigniswarteschlange gestellt wird.</param>
        <param name="priority">Die Priorität, relativ zu den anderen anstehenden Operationen in der <see cref="T:System.Windows.Threading.Dispatcher" />-Ereigniswarteschlange, mit der die angegebene Methode aufgerufen wird.</param>
        <param name="args">Ein Array von Objekten, die als Argumente an die angegebene Methode übergeben werden sollen. Kann <see langword="null" /> sein.</param>
        <summary>Führt den angegebenen Delegaten asynchron mit den angegebenen Argumenten und der angegebenen Priorität für den Thread aus, für den der <see cref="T:System.Windows.Threading.Dispatcher" /> erstellt wurde.</summary>
        <returns>Ein Objekt, das unmittelbar nach dem Aufruf von <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" /> zurückgegeben wird und für die Interaktion mit dem Delegaten verwendet werden kann, während im Delegaten die Ausführung einer Aufgabe in der Warteschlange steht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das <xref:System.Windows.Threading.DispatcherOperation> von<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> zurückgegebene-Objekt kann auf verschiedene Arten verwendet werden, um mit dem angegebenen Delegaten zu interagieren, z. b.:  
  
-   Ändern der <xref:System.Windows.Threading.DispatcherPriority> des Delegaten, während die Ausführung in der Ereignis Warteschlange ausstehend ist.  
  
-   Entfernen des Delegaten aus der Ereignis Warteschlange.  
  
-   Warten, bis der Delegat zurückgegeben wird.  
  
-   Abrufen des Werts, den der Delegat zurückgibt, nachdem er ausgeführt wurde.  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>ist asynchron. Daher wird die Steuerung sofort an das aufrufenden Objekt zurückgegeben, nachdem es aufgerufen wurde.  
  
 In [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]kann nur der Thread, der einen <xref:System.Windows.Threading.DispatcherObject> erstellt hat, auf dieses Objekt zugreifen. Beispielsweise kann ein Hintergrund Thread, der aus dem Hauptbenutzer Oberflächen-Thread ausgelöst wird, den Inhalt eines <xref:System.Windows.Controls.Button> nicht aktualisieren, der im UI-Thread erstellt wurde. Damit der Hintergrund Thread auf die Content-Eigenschaft von <xref:System.Windows.Controls.Button>zugreifen kann, muss der Hintergrund Thread die Arbeit an die <xref:System.Windows.Threading.Dispatcher> mit dem UI-Thread zugeordnete delegieren. Dies wird mithilfe <xref:System.Windows.Threading.Dispatcher.Invoke%2A> von oder <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>erreicht. <xref:System.Windows.Threading.Dispatcher.Invoke%2A>ist synchron und <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> ist asynchron. Der-Vorgang wird der-Ereignis Warteschlange <xref:System.Windows.Threading.Dispatcher> von am angegebenen <xref:System.Windows.Threading.DispatcherPriority>hinzugefügt.  
  
 Wenn <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> für einen <xref:System.Windows.Threading.Dispatcher> aufgerufen wird, der heruntergefahren wurde, wird die Status-Eigenschaft <xref:System.Windows.Threading.DispatcherOperation> des zurückgegebenen <xref:System.Windows.Threading.DispatcherOperationStatus.Aborted>auf festgelegt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginInvoke">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation BeginInvoke (System.Windows.Threading.DispatcherPriority priority, Delegate method, object arg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation BeginInvoke(valuetype System.Windows.Threading.DispatcherPriority priority, class System.Delegate method, object arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginInvoke (priority As DispatcherPriority, method As Delegate, arg As Object) As DispatcherOperation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Threading::DispatcherOperation ^ BeginInvoke(System::Windows::Threading::DispatcherPriority priority, Delegate ^ method, System::Object ^ arg);" />
      <MemberSignature Language="F#" Value="member this.BeginInvoke : System.Windows.Threading.DispatcherPriority * Delegate * obj -&gt; System.Windows.Threading.DispatcherOperation" Usage="dispatcher.BeginInvoke (priority, method, arg)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="arg" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="priority">Die Priorität, relativ zu den anderen anstehenden Operationen in der <see cref="T:System.Windows.Threading.Dispatcher" />-Ereigniswarteschlange, mit der die angegebene Methode aufgerufen wird.</param>
        <param name="method">Ein Delegat zu einer Methode, die ein Argument erwartet und in die <see cref="T:System.Windows.Threading.Dispatcher" />-Ereigniswarteschlange gestellt wird.</param>
        <param name="arg">Das Objekt, das als Argument an die angegebene Methode übergeben wird.</param>
        <summary>Führt den angegebenen Delegaten asynchron mit der angegebenen Priorität und dem angegebenen Argument auf dem Thread aus, dem der <see cref="T:System.Windows.Threading.Dispatcher" /> zugeordnet ist.</summary>
        <returns>Ein Objekt, das unmittelbar nach dem Aufruf von <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" /> zurückgegeben wird und für die Interaktion mit dem Delegaten verwendet werden kann, während im Delegaten die Ausführung einer Aufgabe in der Warteschlange steht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Arg`kann sein `null` , wenn keine Argumente benötigt werden.  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>Gibt ein <xref:System.Windows.Threading.DispatcherOperation> -Objekt zurück, das zum interagieren mit dem Delegaten verwendet werden kann, wenn sich der Delegat in der Ereignis Warteschlange befindet  
  
 Das <xref:System.Windows.Threading.DispatcherOperation> von<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> zurückgegebene-Objekt kann auf verschiedene Arten verwendet werden, um mit dem angegebenen Delegaten zu interagieren, z. b.:  
  
-   Ändern der <xref:System.Windows.Threading.DispatcherPriority> des Delegaten, während die Ausführung in der Ereignis Warteschlange ausstehend ist.  
  
-   Entfernen des Delegaten aus der Ereignis Warteschlange.  
  
-   Warten, bis der Delegat zurückgegeben wird.  
  
-   Abrufen des Werts, den der Delegat zurückgibt, nachdem er ausgeführt wurde.  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>ist asynchron. Daher wird die Steuerung sofort an das aufrufenden Objekt zurückgegeben, nachdem es aufgerufen wurde.  
  
 In [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]kann nur der Thread, der einen <xref:System.Windows.Threading.DispatcherObject> erstellt hat, auf dieses Objekt zugreifen.  Beispielsweise kann ein Hintergrund Thread, der aus dem Hauptbenutzer Oberflächen-Thread ausgelöst wird, den Inhalt eines <xref:System.Windows.Controls.Button> nicht aktualisieren, der im UI-Thread erstellt wurde.  Damit der Hintergrund Thread auf die Content-Eigenschaft von <xref:System.Windows.Controls.Button>zugreifen kann, muss der Hintergrund Thread die Arbeit an die <xref:System.Windows.Threading.Dispatcher> mit dem UI-Thread zugeordnete delegieren.  Dies wird mithilfe <xref:System.Windows.Threading.Dispatcher.Invoke%2A> von oder <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>erreicht.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A>ist synchron und <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> ist asynchron.  Der-Vorgang wird der-Ereignis Warteschlange <xref:System.Windows.Threading.Dispatcher> von am angegebenen <xref:System.Windows.Threading.DispatcherPriority>hinzugefügt.  
  
 Wenn mehrere <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> Aufrufe gleichzeitig <xref:System.Windows.Threading.DispatcherPriority>durchgeführt werden, werden Sie in der Reihenfolge ausgeführt, in der die Aufrufe durchgeführt wurden.  
  
 Wenn <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> für einen <xref:System.Windows.Threading.Dispatcher> aufgerufen wird, der heruntergefahren wurde, wird die Status-Eigenschaft <xref:System.Windows.Threading.DispatcherOperation> des zurückgegebenen <xref:System.Windows.Threading.DispatcherOperationStatus.Aborted>auf festgelegt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie Sie einen Vorgang auf <xref:System.Windows.Threading.Dispatcher>einem platzieren.  
  
 Zuerst wird ein Delegat erstellt, der ein Argument annimmt (in diesem Fall eine Zeichenfolge).  
  
 [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherDelegates](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherdelegates)]
 [!code-vb[ThreadingWeatherForecast#ThreadingWeatherDelegates](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherdelegates)]  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%28System.Windows.Threading.DispatcherPriority%2CSystem.Delegate%2CSystem.Object%29> Anschließend wird aufgerufen.  Da jeder <xref:System.Windows.Threading.DispatcherObject> über eine-Eigenschaft verfügt, <xref:System.Windows.Threading.Dispatcher> die das-Objekt zurückgibt, <xref:System.Windows.Threading.Dispatcher> das ihm zugeordnet ist, wird <xref:System.Windows.Threading.DispatcherObject>das gewünschte abgerufen, indem <xref:System.Windows.Controls.Grid> das `tomorrowsWeather`abgerufen wird, in diesem Fall ein mit dem Namen. Der Aufruf von <xref:System.Windows.Threading.Dispatcher.BeginInvoke%28System.Windows.Threading.DispatcherPriority%2CSystem.Delegate%2CSystem.Object%29> erfordert drei Parameter: die Priorität, die auf <xref:System.Windows.Threading.DispatcherPriority.Normal?displayProperty=nameWithType>festgelegt ist; der Rückruf, der durch `OneArgDelegate`eine Instanz des Delegaten übermittelt wird, und eine Zeichen `weather`Folge mit dem Namen, die das Argument für den Rückruf ist.  
  
 [!code-csharp[threadingweatherforecast#ThreadingWeatherDispatcherOneArge](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherdispatcheronearge)]
 [!code-vb[threadingweatherforecast#ThreadingWeatherDispatcherOneArge](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherdispatcheronearge)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="method" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="priority" /> ist kein gültiger <see cref="T:System.Windows.Threading.DispatcherPriority" />.</exception>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=160038">Beispiel für Single Thread-Anwendung mit langer Berechnung</related>
      </Docs>
    </Member>
    <Member MemberName="BeginInvoke">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation BeginInvoke (System.Windows.Threading.DispatcherPriority priority, Delegate method, object arg, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation BeginInvoke(valuetype System.Windows.Threading.DispatcherPriority priority, class System.Delegate method, object arg, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginInvoke (priority As DispatcherPriority, method As Delegate, arg As Object, ParamArray args As Object()) As DispatcherOperation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Threading::DispatcherOperation ^ BeginInvoke(System::Windows::Threading::DispatcherPriority priority, Delegate ^ method, System::Object ^ arg, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.BeginInvoke : System.Windows.Threading.DispatcherPriority * Delegate * obj * obj[] -&gt; System.Windows.Threading.DispatcherOperation" Usage="dispatcher.BeginInvoke (priority, method, arg, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="arg" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="priority">Die Priorität, relativ zu den anderen anstehenden Operationen in der <see cref="T:System.Windows.Threading.Dispatcher" />-Ereigniswarteschlange, mit der die angegebene Methode aufgerufen wird.</param>
        <param name="method">Ein Delegat zu einer Methode, die mehrere Argumente erwartet und in die <see cref="T:System.Windows.Threading.Dispatcher" />-Ereigniswarteschlange gestellt wird.</param>
        <param name="arg">Das Objekt, das als Argument an die angegebene Methode übergeben wird.</param>
        <param name="args">Ein Array von Objekten, die als Argumente an die angegebene Methode übergeben werden sollen.</param>
        <summary>Führt den angegebenen Delegaten asynchron mit der angegebenen Priorität und dem angegebenen Argumentarray auf dem Thread aus, dem der <see cref="T:System.Windows.Threading.Dispatcher" /> zugeordnet ist.</summary>
        <returns>Ein Objekt, das unmittelbar nach dem Aufruf von <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" /> zurückgegeben wird und für die Interaktion mit dem Delegaten verwendet werden kann, während im Delegaten die Ausführung einer Aufgabe in der <see cref="T:System.Windows.Threading.Dispatcher" />-Warteschlange steht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `arg` -Parameter kann `null` sein, wenn keine Argumente benötigt werden.  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>Gibt ein <xref:System.Windows.Threading.DispatcherOperation> -Objekt zurück, das zum interagieren mit dem Delegaten verwendet werden kann, wenn sich der Delegat in der Ereignis Warteschlange befindet  
  
 Das <xref:System.Windows.Threading.DispatcherOperation> von<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> zurückgegebene-Objekt kann auf verschiedene Arten verwendet werden, um mit dem angegebenen Delegaten zu interagieren, z. b.:  
  
-   Ändern der <xref:System.Windows.Threading.DispatcherPriority> des Delegaten, während die Ausführung in der Ereignis Warteschlange ausstehend ist.  
  
-   Entfernen des Delegaten aus der Ereignis Warteschlange.  
  
-   Warten, bis der Delegat zurückgegeben wird.  
  
-   Abrufen des Werts, den der Delegat zurückgibt, nachdem er ausgeführt wurde.  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>ist asynchron. Daher wird die Steuerung sofort an das aufrufenden Objekt zurückgegeben, nachdem es aufgerufen wurde.  
  
 In [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]kann nur der Thread, der einen <xref:System.Windows.Threading.DispatcherObject> erstellt hat, auf dieses Objekt zugreifen.  Beispielsweise kann ein Hintergrund Thread, der aus dem Hauptbenutzer Oberflächen-Thread ausgelöst wird, den Inhalt eines <xref:System.Windows.Controls.Button> nicht aktualisieren, der im UI-Thread erstellt wurde.  Damit der Hintergrund Thread auf die Content-Eigenschaft von <xref:System.Windows.Controls.Button>zugreifen kann, muss der Hintergrund Thread die Arbeit an die <xref:System.Windows.Threading.Dispatcher> mit dem UI-Thread zugeordnete delegieren.  Dies wird mithilfe <xref:System.Windows.Threading.Dispatcher.Invoke%2A> von oder <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>erreicht.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A>ist synchron und <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> ist asynchron.  Der-Vorgang wird der-Ereignis Warteschlange <xref:System.Windows.Threading.Dispatcher> von am angegebenen <xref:System.Windows.Threading.DispatcherPriority>hinzugefügt.  
  
 Wenn mehrere <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> Aufrufe gleichzeitig <xref:System.Windows.Threading.DispatcherPriority>durchgeführt werden, werden Sie in der Reihenfolge ausgeführt, in der die Aufrufe durchgeführt wurden.  
  
 Wenn <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> für einen <xref:System.Windows.Threading.Dispatcher> aufgerufen wird, der heruntergefahren wurde, wird die Status-Eigenschaft <xref:System.Windows.Threading.DispatcherOperation> des zurückgegebenen <xref:System.Windows.Threading.DispatcherOperationStatus.Aborted>auf festgelegt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="method" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><see cref="T:System.Windows.Threading.DispatcherPriority" /> ist keine gültige Priorität.</exception>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=160038">Beispiel für Single Thread-Anwendung mit langer Berechnung</related>
      </Docs>
    </Member>
    <Member MemberName="BeginInvokeShutdown">
      <MemberSignature Language="C#" Value="public void BeginInvokeShutdown (System.Windows.Threading.DispatcherPriority priority);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginInvokeShutdown(valuetype System.Windows.Threading.DispatcherPriority priority) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.BeginInvokeShutdown(System.Windows.Threading.DispatcherPriority)" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInvokeShutdown (priority As DispatcherPriority)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginInvokeShutdown(System::Windows::Threading::DispatcherPriority priority);" />
      <MemberSignature Language="F#" Value="member this.BeginInvokeShutdown : System.Windows.Threading.DispatcherPriority -&gt; unit" Usage="dispatcher.BeginInvokeShutdown priority" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
      </Parameters>
      <Docs>
        <param name="priority">Die Priorität, bei der mit dem Beenden des Verteilers begonnen wird.</param>
        <summary>Initiiert ein asynchrones Beenden des <see cref="T:System.Windows.Threading.Dispatcher" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Threading.Dispatcher.BeginInvokeShutdown%2A>erfordert uneingeschränkte Benutzeroberflächen Berechtigungen.  
  
 Wenn das <xref:System.Windows.Threading.Dispatcher> Herunterfahren von gestartet wird, <xref:System.Windows.Threading.Dispatcher.ShutdownStarted> wird das-Ereignis <xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> ausgelöst, und `true`wird auf festgelegt.  
  
 Der <xref:System.Windows.Threading.Dispatcher> wird nicht vollständig heruntergefahren, bis die Ereignis Warteschlange entlädt.  
  
 Wenn das Herunterfahren des Verteilers abgeschlossen ist <xref:System.Windows.Threading.Dispatcher.ShutdownFinished> , wird das-Ereignis <xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A> ausgelöst, und die `true`-Eigenschaft ist auf festgelegt.  
  
 Nachdem der Vorgang zum Herunterfahren begonnen hat, werden alle ausstehenden Arbeitselemente in der Warteschlange abgebrochen.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">zum Herunterfahren des Verteilers.  Zugehörige Enumerationen:<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CheckAccess">
      <MemberSignature Language="C#" Value="public bool CheckAccess ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CheckAccess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.CheckAccess" />
      <MemberSignature Language="VB.NET" Value="Public Function CheckAccess () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CheckAccess();" />
      <MemberSignature Language="F#" Value="member this.CheckAccess : unit -&gt; bool" Usage="dispatcher.CheckAccess " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Bestimmt, ob der aufrufende Thread diesem <see cref="T:System.Windows.Threading.Dispatcher" /> zugeordnet ist.</summary>
        <returns><see langword="true" />, wenn der aufrufende Thread diesem <see cref="T:System.Windows.Threading.Dispatcher" /> zugeordnet ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nur die <xref:System.Windows.Threading.Dispatcher> , für <xref:System.Windows.Threading.DispatcherObject> die ein erstellt wird, können auf das-Objekt zugreifen.  Verwenden <xref:System.Windows.Threading.Dispatcher.Invoke%2A> Sie <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> oder, um von einem anderen Thread aus auf das Objekt zuzugreifen.  
  
 <xref:System.Windows.Threading.Dispatcher.CheckAccess%2A>kann von jedem Thread aufgerufen werden.  
  
 Der Unterschied <xref:System.Windows.Threading.Dispatcher.CheckAccess%2A> zwischen <xref:System.Windows.Threading.Dispatcher.VerifyAccess%2A> und <xref:System.Windows.Threading.Dispatcher.CheckAccess%2A> ist ein boolescher Wert, der angibt, <xref:System.Windows.Threading.Dispatcher> ob der aufrufende Thread <xref:System.Windows.Threading.Dispatcher.VerifyAccess%2A> Zugriff auf hat und eine Ausnahme auslöst.  
  
   
  
## Examples  
 Im folgenden Beispiel wird <xref:System.Windows.Threading.Dispatcher.CheckAccess%2A> verwendet, um zu bestimmen, ob ein Thread <xref:System.Windows.Controls.Button>Zugriff auf einen hat.  Die <xref:System.Windows.Threading.Dispatcher.CheckAccess%2A> -Methode für <xref:System.Windows.Threading.Dispatcher> das, das <xref:System.Windows.Controls.Button> zugeordnet ist, wird aufgerufen, um den Zugriff auf den Thread zu überprüfen.  Wenn der Aufruf <xref:System.Windows.Threading.Dispatcher>Ende Thread auf das zugreifen kann, wird das <xref:System.Windows.Controls.Button> aktualisiert, indem auf die Member <xref:System.Windows.Controls.Button>der zugegriffen wird. <xref:System.Windows.Controls.Button> andernfalls wird ein Delegat, der als Argument akzeptiert, auf dem <xref:System.Windows.Threading.Dispatcher>platziert.  Der <xref:System.Windows.Threading.Dispatcher> delegiert die Arbeit der <xref:System.Windows.Controls.Button>Aktualisierung von.  
  
 [!code-csharp[DispatcherAccessSample#DispatcherAccessCheckAccess](~/samples/snippets/csharp/VS_Snippets_Wpf/DispatcherAccessSample/CSharp/Window1.xaml.cs#dispatcheraccesscheckaccess)]
 [!code-vb[DispatcherAccessSample#DispatcherAccessCheckAccess](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DispatcherAccessSample/visualbasic/window1.xaml.vb#dispatcheraccesscheckaccess)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Threading.Dispatcher.VerifyAccess" />
      </Docs>
    </Member>
    <Member MemberName="CurrentDispatcher">
      <MemberSignature Language="C#" Value="public static System.Windows.Threading.Dispatcher CurrentDispatcher { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Threading.Dispatcher CurrentDispatcher" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Threading.Dispatcher.CurrentDispatcher" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentDispatcher As Dispatcher" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Threading::Dispatcher ^ CurrentDispatcher { System::Windows::Threading::Dispatcher ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentDispatcher : System.Windows.Threading.Dispatcher" Usage="System.Windows.Threading.Dispatcher.CurrentDispatcher" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.Dispatcher</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den <see cref="T:System.Windows.Threading.Dispatcher" /> für den derzeit ausgeführten Thread ab bzw. erstellt einen neuen, wenn dem Thread noch kein <see cref="T:System.Windows.Threading.Dispatcher" /> zugeordnet ist.</summary>
        <value>Der Verteiler, der dem aktuellen Thread zugeordnet ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein <xref:System.Windows.Threading.Dispatcher> dem aktuellen Thread nicht zugeordnet ist, wird ein neuer <xref:System.Windows.Threading.Dispatcher> erstellt.  Dies ist nicht der Fall bei der <xref:System.Windows.Threading.Dispatcher.FromThread%2A>-Methode.  <xref:System.Windows.Threading.Dispatcher.FromThread%2A>Gibt zurück `null` , wenn dem angegebenen Thread kein Verteiler zugeordnet ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisableProcessing">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherProcessingDisabled DisableProcessing ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Threading.DispatcherProcessingDisabled DisableProcessing() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.DisableProcessing" />
      <MemberSignature Language="VB.NET" Value="Public Function DisableProcessing () As DispatcherProcessingDisabled" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Threading::DispatcherProcessingDisabled DisableProcessing();" />
      <MemberSignature Language="F#" Value="member this.DisableProcessing : unit -&gt; System.Windows.Threading.DispatcherProcessingDisabled" Usage="dispatcher.DisableProcessing " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherProcessingDisabled</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Deaktiviert Verarbeitung der <see cref="T:System.Windows.Threading.Dispatcher" />-Warteschlange.</summary>
        <returns>Eine Struktur, mit der die Dispatcherverarbeitung wieder aktiviert wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Deaktivierung der Verteiler Verarbeitung ist eine erweiterte Methode, mit der die Wahrscheinlichkeit eines nicht verknüpften erneuten eintreten vermieden werden soll.  
  
 Die Deaktivierung der Verarbeitung hat folgende Auswirkungen:  
  
-   CLR-Sperren leiten Nachrichten nicht intern.  
  
-   <xref:System.Windows.Threading.DispatcherFrame>Objekte dürfen nicht per pushübertragung übermittelt werden.  
  
-   Die Nachrichtenverarbeitung ist nicht zulässig.  
  
 Die <xref:System.Windows.Threading.DispatcherProcessingDisabled> -Struktur <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A> , die zurückgibt, wenn Sie aufgerufen wird, kann verwendet werden, um die Dispatcherverarbeitung erneut zu aktivieren.  Durch <xref:System.Windows.Threading.DispatcherProcessingDisabled.Dispose%2A> Aufrufen von <xref:System.Windows.Threading.DispatcherProcessingDisabled> für die-Struktur wird die Verarbeitung wieder aktiviert.  
  
 <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A>kann nur für den Thread aufgerufen werden, <xref:System.Windows.Threading.Dispatcher> dem der zugeordnet ist.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie die Verteiler Verarbeitung deaktiviert und die Verteiler Verarbeitung erneut aktiviert wird.  <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A>wird in einer **using** -Anweisung aufgerufen.  <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A>gibt eine <xref:System.Windows.Threading.DispatcherProcessingDisabled> -Struktur zurück, die als Objekt verwendet wird, das verworfen wird, wenn der **using** -Block beendet wird.  Wenn <xref:System.Windows.Threading.DispatcherProcessingDisabled.Dispose%2A> für die <xref:System.Windows.Threading.DispatcherProcessingDisabled> Struktur aufgerufen wird, wird die Dispatcherverarbeitung wieder aktiviert.  
  
 [!code-csharp[DispatcherSnippets#DispatcherDisableProcessing](~/samples/snippets/csharp/VS_Snippets_Wpf/DispatcherSnippets/CSharp/Window1.xaml.cs#dispatcherdisableprocessing)]
 [!code-vb[DispatcherSnippets#DispatcherDisableProcessing](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DispatcherSnippets/visualbasic/window1.xaml.vb#dispatcherdisableprocessing)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExitAllFrames">
      <MemberSignature Language="C#" Value="public static void ExitAllFrames ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ExitAllFrames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.ExitAllFrames" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ExitAllFrames ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ExitAllFrames();" />
      <MemberSignature Language="F#" Value="static member ExitAllFrames : unit -&gt; unit" Usage="System.Windows.Threading.Dispatcher.ExitAllFrames " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Anforderung zum Beenden aller Frames einschließlich geschachtelter Frames.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">zum Aufrufen dieser Methode. Zugehörige Enumerationen:<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="M:System.Windows.Threading.Dispatcher.PushFrame(System.Windows.Threading.DispatcherFrame)" />
        <altmember cref="T:System.Windows.Threading.DispatcherFrame" />
      </Docs>
    </Member>
    <Member MemberName="FromThread">
      <MemberSignature Language="C#" Value="public static System.Windows.Threading.Dispatcher FromThread (System.Threading.Thread thread);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Threading.Dispatcher FromThread(class System.Threading.Thread thread) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.FromThread(System.Threading.Thread)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Threading::Dispatcher ^ FromThread(System::Threading::Thread ^ thread);" />
      <MemberSignature Language="F#" Value="static member FromThread : System.Threading.Thread -&gt; System.Windows.Threading.Dispatcher" Usage="System.Windows.Threading.Dispatcher.FromThread thread" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.Dispatcher</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="thread" Type="System.Threading.Thread" />
      </Parameters>
      <Docs>
        <param name="thread">Der Thread, dessen <see cref="T:System.Windows.Threading.Dispatcher" /> abgerufen werden soll.</param>
        <summary>Ruft den <see cref="T:System.Windows.Threading.Dispatcher" /> für den angegebenen Thread ab.</summary>
        <returns>Der Verteiler für <paramref name="thread" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn für den angegebenen Thread kein Verteiler verfügbar ist, `null` wird zurückgegeben.  
  
 <xref:System.Windows.Threading.Dispatcher.FromThread%2A>erstellt <xref:System.Windows.Threading.Dispatcher> keinen in einem Thread, der <xref:System.Windows.Threading.Dispatcher>über keinen verfügt.   Ein neues <xref:System.Windows.Threading.Dispatcher> wird für einen Thread erstellt, <xref:System.Windows.Threading.Dispatcher> der nicht bereits über einen <xref:System.Windows.Threading.Dispatcher> verfügt, wenn versucht wird, mithilfe der <xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A> -Eigenschaft zu erhalten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasShutdownFinished">
      <MemberSignature Language="C#" Value="public bool HasShutdownFinished { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasShutdownFinished" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Threading.Dispatcher.HasShutdownFinished" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasShutdownFinished As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasShutdownFinished { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasShutdownFinished : bool" Usage="System.Windows.Threading.Dispatcher.HasShutdownFinished" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bestimmt, ob der <see cref="T:System.Windows.Threading.Dispatcher" /> die Beendigung abgeschlossen hat.</summary>
        <value><see langword="true" />, wenn der Verteiler die Beendigung abgeschlossen hat, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn das <xref:System.Windows.Threading.Dispatcher> Herunterfahren von gestartet wird, <xref:System.Windows.Threading.Dispatcher.ShutdownStarted> wird das-Ereignis <xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> ausgelöst, und `true`wird auf festgelegt.  
  
 Der <xref:System.Windows.Threading.Dispatcher> wird nicht vollständig heruntergefahren, bis die Ereignis Warteschlange entlädt.  
  
 Wenn das Herunterfahren des Verteilers abgeschlossen ist <xref:System.Windows.Threading.Dispatcher.ShutdownFinished> , wird das-Ereignis <xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A> ausgelöst, und die `true`-Eigenschaft ist auf festgelegt.  
  
 Nachdem der Vorgang zum Herunterfahren begonnen hat, werden alle ausstehenden Arbeitselemente in der Warteschlange abgebrochen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasShutdownStarted">
      <MemberSignature Language="C#" Value="public bool HasShutdownStarted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasShutdownStarted" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Threading.Dispatcher.HasShutdownStarted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasShutdownStarted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasShutdownStarted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasShutdownStarted : bool" Usage="System.Windows.Threading.Dispatcher.HasShutdownStarted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bestimmt, ob der <see cref="T:System.Windows.Threading.Dispatcher" /> gerade beendet wird.</summary>
        <value><see langword="true" />, wenn der <see cref="T:System.Windows.Threading.Dispatcher" /> gerade beendet wird, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn das <xref:System.Windows.Threading.Dispatcher> Herunterfahren von gestartet wird, <xref:System.Windows.Threading.Dispatcher.ShutdownStarted> wird das-Ereignis <xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> ausgelöst, und `true`wird auf festgelegt.  
  
 Der <xref:System.Windows.Threading.Dispatcher> wird nicht vollständig heruntergefahren, bis die Ereignis Warteschlange entlädt.  
  
 Wenn das Herunterfahren des Verteilers abgeschlossen ist <xref:System.Windows.Threading.Dispatcher.ShutdownFinished> , wird das-Ereignis <xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A> ausgelöst, und die `true`-Eigenschaft ist auf festgelegt.  
  
 Nachdem der Vorgang zum Herunterfahren begonnen hat, werden alle ausstehenden Arbeitselemente in der Warteschlange abgebrochen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Hooks">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherHooks Hooks { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Threading.DispatcherHooks Hooks" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Threading.Dispatcher.Hooks" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Hooks As DispatcherHooks" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Threading::DispatcherHooks ^ Hooks { System::Windows::Threading::DispatcherHooks ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Hooks : System.Windows.Threading.DispatcherHooks" Usage="System.Windows.Threading.Dispatcher.Hooks" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherHooks</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Auflistung von Hooks ab, die zusätzliche Ereignisinformationen zum <see cref="T:System.Windows.Threading.Dispatcher" /> bereitstellen.</summary>
        <value>Die Hooks, die diesem <see cref="T:System.Windows.Threading.Dispatcher" /> zugeordnet sind.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Threading.DispatcherHooks> -Klasse stellt zusätzliche Ereignis Informationen <xref:System.Windows.Threading.Dispatcher>zum bereit <xref:System.Windows.Threading.Dispatcher> , z. b. wenn inaktiv ist oder wenn ein Vorgang mit einem Vorgang abgeschlossen wurde.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">zum erhalten dieser Eigenschaft.  Zugehörige Enumerationen:<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Invoke">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Führt den angegebenen Delegaten synchron auf dem Thread aus, dem der <see cref="T:System.Windows.Threading.Dispatcher" /> zugeordnet ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]kann nur der Thread, der einen <xref:System.Windows.Threading.DispatcherObject> erstellt hat, auf dieses Objekt zugreifen.  Beispielsweise kann ein Hintergrund Thread, der aus dem Hauptbenutzer Oberflächen-Thread ausgelöst wird, den Inhalt eines <xref:System.Windows.Controls.Button> nicht aktualisieren, der im UI-Thread erstellt wurde.  Damit der Hintergrund Thread auf die Content-Eigenschaft von <xref:System.Windows.Controls.Button>zugreifen kann, muss der Hintergrund Thread die Arbeit an die <xref:System.Windows.Threading.Dispatcher> mit dem UI-Thread zugeordnete delegieren.  Dies wird mithilfe <xref:System.Windows.Threading.Dispatcher.Invoke%2A> von oder <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>erreicht.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A>ist synchron und <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> ist asynchron.  Der-Vorgang wird der-Ereignis Warteschlange <xref:System.Windows.Threading.Dispatcher> von am angegebenen <xref:System.Windows.Threading.DispatcherPriority>hinzugefügt.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A>ist ein synchroner Vorgang. Daher wird die Steuerung erst wieder an das aufrufende Objekt zurückgegeben, nachdem der Rückruf zurückgegeben wurde.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Delegat unter <xref:System.Windows.Threading.Dispatcher> Verwendung <xref:System.Windows.Threading.DispatcherPriority.Normal> <xref:System.Windows.Threading.Dispatcher.Invoke%2A>von auf einen platziert.  
  
 [!code-csharp[invalidaterequerywithsystemtimer#SystemTimerDispatcherInvoke](~/samples/snippets/csharp/VS_Snippets_Wpf/InvalidateRequeryWithSystemTimer/CSharp/Window1.xaml.cs#systemtimerdispatcherinvoke)]
 [!code-vb[invalidaterequerywithsystemtimer#SystemTimerDispatcherInvoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InvalidateRequeryWithSystemTimer/visualbasic/window1.xaml.vb#systemtimerdispatcherinvoke)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public void Invoke (Action callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invoke(class System.Action callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Action)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Invoke (callback As Action)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Invoke(Action ^ callback);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Action -&gt; unit" Usage="dispatcher.Invoke callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="callback">Ein Delegat, der über den Verteiler aufgerufen werden soll.</param>
        <summary>Führt die angegebene <see cref="T:System.Action" /> synchron auf dem Thread aus, dem der <see cref="T:System.Windows.Threading.Dispatcher" /> zugeordnet ist.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public void Invoke (Action callback, System.Windows.Threading.DispatcherPriority priority);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invoke(class System.Action callback, valuetype System.Windows.Threading.DispatcherPriority priority) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Action,System.Windows.Threading.DispatcherPriority)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Invoke (callback As Action, priority As DispatcherPriority)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Invoke(Action ^ callback, System::Windows::Threading::DispatcherPriority priority);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Action * System.Windows.Threading.DispatcherPriority -&gt; unit" Usage="dispatcher.Invoke (callback, priority)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="callback">Ein Delegat, der über den Verteiler aufgerufen werden soll.</param>
        <param name="priority">Die Priorität, die bestimmt, in welcher Reihenfolge der angegebene Rückruf relativ zu den anderen ausstehenden Vorgängen in <see cref="T:System.Windows.Threading.Dispatcher" /> aufgerufen wird.</param>
        <summary>Führt die angegebene <see cref="T:System.Action" /> synchron mit der angegebenen Priorität auf dem Thread aus, dem der <see cref="T:System.Windows.Threading.Dispatcher" /> zugeordnet ist.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (Delegate method, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(class System.Delegate method, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (method As Delegate, ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(Delegate ^ method, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Delegate * obj[] -&gt; obj" Usage="dispatcher.Invoke (method, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method">Ein Delegat für eine Methode, die in <paramref name="args" /> angegebene Parameter akzeptiert und in die <see cref="T:System.Windows.Threading.Dispatcher" />-Ereigniswarteschlange gestellt wird.</param>
        <param name="args">Ein Array von Objekten, die als Argumente an die angegebene Methode übergeben werden sollen. Kann <see langword="null" /> sein.</param>
        <summary>Führt den angegebenen Delegaten synchron mit den angegebenen Argumenten für den Thread aus, dem der <see cref="T:System.Windows.Threading.Dispatcher" /> zugeordnet ist.</summary>
        <returns>Der Rückgabewert des aufgerufenen Delegaten bzw. <see langword="null" />, wenn der Delegat keinen Wert zurückgibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]kann nur der Thread, der einen <xref:System.Windows.Threading.DispatcherObject> erstellt hat, auf dieses Objekt zugreifen. Beispielsweise kann ein Hintergrund Thread, der aus dem Hauptbenutzer Oberflächen-Thread ausgelöst wird, den Inhalt eines <xref:System.Windows.Controls.Button> nicht aktualisieren, der im UI-Thread erstellt wurde. Damit der Hintergrund Thread auf die Content-Eigenschaft von <xref:System.Windows.Controls.Button>zugreifen kann, muss der Hintergrund Thread die Arbeit an die <xref:System.Windows.Threading.Dispatcher> mit dem UI-Thread zugeordnete delegieren. Dies wird mithilfe <xref:System.Windows.Threading.Dispatcher.Invoke%2A> von oder <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>erreicht. <xref:System.Windows.Threading.Dispatcher.Invoke%2A>ist synchron und <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> ist asynchron. Der-Vorgang wird der-Ereignis Warteschlange <xref:System.Windows.Threading.Dispatcher> von am angegebenen <xref:System.Windows.Threading.DispatcherPriority>hinzugefügt.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A>ist ein synchroner Vorgang. Daher wird die Steuerung erst wieder an das aufrufende Objekt zurückgegeben, nachdem der Rückruf zurückgegeben wurde.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (System.Windows.Threading.DispatcherPriority priority, Delegate method);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(valuetype System.Windows.Threading.DispatcherPriority priority, class System.Delegate method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (priority As DispatcherPriority, method As Delegate) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(System::Windows::Threading::DispatcherPriority priority, Delegate ^ method);" />
      <MemberSignature Language="F#" Value="member this.Invoke : System.Windows.Threading.DispatcherPriority * Delegate -&gt; obj" Usage="dispatcher.Invoke (priority, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="method" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="priority">Die Priorität, relativ zu den anderen anstehenden Operationen in der <see cref="T:System.Windows.Threading.Dispatcher" />-Ereigniswarteschlange, mit der die angegebene Methode aufgerufen wird.</param>
        <param name="method">Ein Delegat zu einer Methode, die keine Argumente erwartet und in die <see cref="T:System.Windows.Threading.Dispatcher" />-Ereigniswarteschlange gestellt wird.</param>
        <summary>Führt den angegebenen Delegaten synchron mit der angegebenen Priorität auf dem Thread aus, dem der <see cref="T:System.Windows.Threading.Dispatcher" /> zugeordnet ist.</summary>
        <returns>Der Rückgabewert des aufgerufenen Delegaten bzw. <see langword="null" />, wenn der Delegat keinen Wert zurückgibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]kann nur der Thread, der einen <xref:System.Windows.Threading.DispatcherObject> erstellt hat, auf dieses Objekt zugreifen.  Beispielsweise kann ein Hintergrund Thread, der aus dem Hauptbenutzer Oberflächen-Thread ausgelöst wird, den Inhalt eines <xref:System.Windows.Controls.Button> nicht aktualisieren, der im UI-Thread erstellt wurde.  Damit der Hintergrund Thread auf die Content-Eigenschaft von <xref:System.Windows.Controls.Button>zugreifen kann, muss der Hintergrund Thread die Arbeit an die <xref:System.Windows.Threading.Dispatcher> mit dem UI-Thread zugeordnete delegieren.  Dies wird mithilfe <xref:System.Windows.Threading.Dispatcher.Invoke%2A> von oder <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>erreicht.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A>ist synchron und <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> ist asynchron.  Der-Vorgang wird der-Ereignis Warteschlange <xref:System.Windows.Threading.Dispatcher> von am angegebenen <xref:System.Windows.Threading.DispatcherPriority>hinzugefügt.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A>ist ein synchroner Vorgang. Daher wird die Steuerung erst wieder an das aufrufende Objekt zurückgegeben, nachdem der Rückruf zurückgegeben wurde.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Delegat unter <xref:System.Windows.Threading.Dispatcher> Verwendung <xref:System.Windows.Threading.DispatcherPriority.Normal> <xref:System.Windows.Threading.Dispatcher.Invoke%2A>von auf einen platziert.  
  
 [!code-csharp[invalidaterequerywithsystemtimer#SystemTimerDispatcherInvoke](~/samples/snippets/csharp/VS_Snippets_Wpf/InvalidateRequeryWithSystemTimer/CSharp/Window1.xaml.cs#systemtimerdispatcherinvoke)]
 [!code-vb[invalidaterequerywithsystemtimer#SystemTimerDispatcherInvoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InvalidateRequeryWithSystemTimer/visualbasic/window1.xaml.vb#systemtimerdispatcherinvoke)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="priority" /> ist gleich <see cref="F:System.Windows.Threading.DispatcherPriority.Inactive" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="priority" /> ist keine gültige Priorität.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="method" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public void Invoke (Action callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invoke(class System.Action callback, valuetype System.Windows.Threading.DispatcherPriority priority, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Invoke(Action ^ callback, System::Windows::Threading::DispatcherPriority priority, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Action * System.Windows.Threading.DispatcherPriority * System.Threading.CancellationToken -&gt; unit" Usage="dispatcher.Invoke (callback, priority, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="2" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="callback">Ein Delegat, der über den Verteiler aufgerufen werden soll.</param>
        <param name="priority">Die Priorität, die bestimmt, in welcher Reihenfolge der angegebene Rückruf relativ zu den anderen ausstehenden Vorgängen in <see cref="T:System.Windows.Threading.Dispatcher" /> aufgerufen wird.</param>
        <param name="cancellationToken">Ein Objekt, das angibt, ob die Aktion abgebrochen werden kann.</param>
        <summary>Führt die angegebene <see cref="T:System.Action" /> synchron mit der angegebenen Priorität auf dem Thread aus, dem der <see cref="T:System.Windows.Threading.Dispatcher" /> zugeordnet ist.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (Delegate method, TimeSpan timeout, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(class System.Delegate method, valuetype System.TimeSpan timeout, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.TimeSpan,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (method As Delegate, timeout As TimeSpan, ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(Delegate ^ method, TimeSpan timeout, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Delegate * TimeSpan * obj[] -&gt; obj" Usage="dispatcher.Invoke (method, timeout, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method">Ein Delegat für eine Methode, die in <paramref name="args" /> angegebene Parameter akzeptiert und in die <see cref="T:System.Windows.Threading.Dispatcher" />-Ereigniswarteschlange gestellt wird.</param>
        <param name="timeout">Die maximale Zeitspanne, die auf den Abschluss der Operation gewartet wird.</param>
        <param name="args">Ein Array von Objekten, die als Argumente an die angegebene Methode übergeben werden sollen. Kann <see langword="null" /> sein.</param>
        <summary>Führt den angegebenen Delegaten in der angegebenen Zeitspanne mit der angegebenen Priorität und den angegebenen Argumenten synchron für den Thread aus, dem der <see cref="T:System.Windows.Threading.Dispatcher" /> zugeordnet ist.</summary>
        <returns>Der Rückgabewert des aufgerufenen Delegaten bzw. <see langword="null" />, wenn der Delegat keinen Wert zurückgibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]kann nur der Thread, der einen <xref:System.Windows.Threading.DispatcherObject> erstellt hat, auf dieses Objekt zugreifen. Beispielsweise kann ein Hintergrund Thread, der aus dem Hauptbenutzer Oberflächen-Thread ausgelöst wird, den Inhalt eines <xref:System.Windows.Controls.Button> nicht aktualisieren, der im UI-Thread erstellt wurde. Damit der Hintergrund Thread auf die Content-Eigenschaft von <xref:System.Windows.Controls.Button>zugreifen kann, muss der Hintergrund Thread die Arbeit an die <xref:System.Windows.Threading.Dispatcher> mit dem UI-Thread zugeordnete delegieren. Dies wird mithilfe <xref:System.Windows.Threading.Dispatcher.Invoke%2A> von oder <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>erreicht. <xref:System.Windows.Threading.Dispatcher.Invoke%2A>ist synchron und <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> ist asynchron. Der-Vorgang wird der-Ereignis Warteschlange <xref:System.Windows.Threading.Dispatcher> von am angegebenen <xref:System.Windows.Threading.DispatcherPriority>hinzugefügt.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A>ist ein synchroner Vorgang. Daher wird die Steuerung erst wieder an das aufrufende Objekt zurückgegeben, nachdem der Rückruf zurückgegeben wurde.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (Delegate method, System.Windows.Threading.DispatcherPriority priority, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(class System.Delegate method, valuetype System.Windows.Threading.DispatcherPriority priority, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.Windows.Threading.DispatcherPriority,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (method As Delegate, priority As DispatcherPriority, ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(Delegate ^ method, System::Windows::Threading::DispatcherPriority priority, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Delegate * System.Windows.Threading.DispatcherPriority * obj[] -&gt; obj" Usage="dispatcher.Invoke (method, priority, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method">Ein Delegat für eine Methode, die in <paramref name="args" /> angegebene Parameter akzeptiert und in die <see cref="T:System.Windows.Threading.Dispatcher" />-Ereigniswarteschlange gestellt wird.</param>
        <param name="priority">Die Priorität, relativ zu den anderen anstehenden Operationen in der <see cref="T:System.Windows.Threading.Dispatcher" />-Ereigniswarteschlange, mit der die angegebene Methode aufgerufen wird.</param>
        <param name="args">Ein Array von Objekten, die als Argumente an die angegebene Methode übergeben werden sollen. Kann <see langword="null" /> sein.</param>
        <summary>Führt den angegebenen Delegaten mit der angegebenen Priorität und den angegebenen Argumenten synchron auf dem Thread aus, dem der <see cref="T:System.Windows.Threading.Dispatcher" /> zugeordnet ist.</summary>
        <returns>Der Rückgabewert des aufgerufenen Delegaten bzw. <see langword="null" />, wenn der Delegat keinen Wert zurückgibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]kann nur der Thread, der einen <xref:System.Windows.Threading.DispatcherObject> erstellt hat, auf dieses Objekt zugreifen. Beispielsweise kann ein Hintergrund Thread, der aus dem Hauptbenutzer Oberflächen-Thread ausgelöst wird, den Inhalt eines <xref:System.Windows.Controls.Button> nicht aktualisieren, der im UI-Thread erstellt wurde. Damit der Hintergrund Thread auf die Content-Eigenschaft von <xref:System.Windows.Controls.Button>zugreifen kann, muss der Hintergrund Thread die Arbeit an die <xref:System.Windows.Threading.Dispatcher> mit dem UI-Thread zugeordnete delegieren. Dies wird mithilfe <xref:System.Windows.Threading.Dispatcher.Invoke%2A> von oder <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>erreicht. <xref:System.Windows.Threading.Dispatcher.Invoke%2A>ist synchron und <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> ist asynchron. Der-Vorgang wird der-Ereignis Warteschlange <xref:System.Windows.Threading.Dispatcher> von am angegebenen <xref:System.Windows.Threading.DispatcherPriority>hinzugefügt.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A>ist ein synchroner Vorgang. Daher wird die Steuerung erst wieder an das aufrufende Objekt zurückgegeben, nachdem der Rückruf zurückgegeben wurde.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (System.Windows.Threading.DispatcherPriority priority, Delegate method, object arg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(valuetype System.Windows.Threading.DispatcherPriority priority, class System.Delegate method, object arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (priority As DispatcherPriority, method As Delegate, arg As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(System::Windows::Threading::DispatcherPriority priority, Delegate ^ method, System::Object ^ arg);" />
      <MemberSignature Language="F#" Value="member this.Invoke : System.Windows.Threading.DispatcherPriority * Delegate * obj -&gt; obj" Usage="dispatcher.Invoke (priority, method, arg)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="arg" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="priority">Die Priorität, relativ zu den anderen anstehenden Operationen in der <see cref="T:System.Windows.Threading.Dispatcher" />-Ereigniswarteschlange, mit der die angegebene Methode aufgerufen wird.</param>
        <param name="method">Ein Delegat zu einer Methode, die ein Argument erwartet und in die <see cref="T:System.Windows.Threading.Dispatcher" />-Ereigniswarteschlange gestellt wird.</param>
        <param name="arg">Ein Objekt, das als Argument an die angegebene Methode übergeben werden soll.</param>
        <summary>Führt den angegebenen Delegaten mit der angegebenen Priorität und dem angegebenen Argument synchron auf dem Thread aus, dem der <see cref="T:System.Windows.Threading.Dispatcher" /> zugeordnet ist.</summary>
        <returns>Der Rückgabewert des aufgerufenen Delegaten bzw. <see langword="null" />, wenn der Delegat keinen Wert zurückgibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Arg`kann sein `null` , wenn ein Argument nicht benötigt wird.  
  
 In [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]kann nur der Thread, der einen <xref:System.Windows.Threading.DispatcherObject> erstellt hat, auf dieses Objekt zugreifen.  Beispielsweise kann ein Hintergrund Thread, der aus dem Hauptbenutzer Oberflächen-Thread ausgelöst wird, den Inhalt eines <xref:System.Windows.Controls.Button> nicht aktualisieren, der im UI-Thread erstellt wurde.  Damit der Hintergrund Thread auf die Content-Eigenschaft von <xref:System.Windows.Controls.Button>zugreifen kann, muss der Hintergrund Thread die Arbeit an die <xref:System.Windows.Threading.Dispatcher> mit dem UI-Thread zugeordnete delegieren.  Dies wird mithilfe <xref:System.Windows.Threading.Dispatcher.Invoke%2A> von oder <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>erreicht.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A>ist synchron und <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> ist asynchron.  Der-Vorgang wird der-Ereignis Warteschlange <xref:System.Windows.Threading.Dispatcher> von am angegebenen <xref:System.Windows.Threading.DispatcherPriority>hinzugefügt.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A>ist ein synchroner Vorgang. Daher wird die Steuerung erst wieder an das aufrufende Objekt zurückgegeben, nachdem der Rückruf zurückgegeben wurde.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="priority" /> ist gleich <see cref="F:System.Windows.Threading.DispatcherPriority.Inactive" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="priority" /> ist keine gültige Priorität.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="method" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (System.Windows.Threading.DispatcherPriority priority, TimeSpan timeout, Delegate method);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(valuetype System.Windows.Threading.DispatcherPriority priority, valuetype System.TimeSpan timeout, class System.Delegate method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (priority As DispatcherPriority, timeout As TimeSpan, method As Delegate) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(System::Windows::Threading::DispatcherPriority priority, TimeSpan timeout, Delegate ^ method);" />
      <MemberSignature Language="F#" Value="member this.Invoke : System.Windows.Threading.DispatcherPriority * TimeSpan * Delegate -&gt; obj" Usage="dispatcher.Invoke (priority, timeout, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="method" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="priority">Die Priorität, relativ zu den anderen anstehenden Operationen in der <see cref="T:System.Windows.Threading.Dispatcher" />-Ereigniswarteschlange, mit der die angegebene Methode aufgerufen wird.</param>
        <param name="timeout">Die maximale Zeit, die auf den Abschluss der Operation gewartet wird.</param>
        <param name="method">Der Delegat zu einer Methode, die keine Argumente erwartet und in die <see cref="T:System.Windows.Threading.Dispatcher" />-Ereigniswarteschlange gestellt wird.</param>
        <summary>Führt den angegebenen Delegaten synchron mit der angegebenen Priorität und dem angegebenen Timeoutwert auf dem Thread aus, in dem der <see cref="T:System.Windows.Threading.Dispatcher" /> erstellt wurde.</summary>
        <returns>Der Rückgabewert des aufgerufenen Delegaten bzw. <see langword="null" />, wenn der Delegat keinen Wert zurückgibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]kann nur der Thread, der einen <xref:System.Windows.Threading.DispatcherObject> erstellt hat, auf dieses Objekt zugreifen.  Beispielsweise kann ein Hintergrund Thread, der aus dem Hauptbenutzer Oberflächen-Thread ausgelöst wird, den Inhalt eines <xref:System.Windows.Controls.Button> nicht aktualisieren, der im UI-Thread erstellt wurde.  Damit der Hintergrund Thread auf die Content-Eigenschaft von <xref:System.Windows.Controls.Button>zugreifen kann, muss der Hintergrund Thread die Arbeit an die <xref:System.Windows.Threading.Dispatcher> mit dem UI-Thread zugeordnete delegieren.  Dies wird mithilfe <xref:System.Windows.Threading.Dispatcher.Invoke%2A> von oder <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>erreicht.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A>ist synchron und <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> ist asynchron.  Der-Vorgang wird der-Ereignis Warteschlange <xref:System.Windows.Threading.Dispatcher> von am angegebenen <xref:System.Windows.Threading.DispatcherPriority>hinzugefügt.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A>ist ein synchroner Vorgang. Daher wird die Steuerung erst wieder an das aufrufende Objekt zurückgegeben, nachdem der Rückruf zurückgegeben wurde.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public void Invoke (Action callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invoke(class System.Action callback, valuetype System.Windows.Threading.DispatcherPriority priority, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken,System.TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Invoke(Action ^ callback, System::Windows::Threading::DispatcherPriority priority, System::Threading::CancellationToken cancellationToken, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Action * System.Windows.Threading.DispatcherPriority * System.Threading.CancellationToken * TimeSpan -&gt; unit" Usage="dispatcher.Invoke (callback, priority, cancellationToken, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="2" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="3" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="callback">Ein Delegat, der über den Verteiler aufgerufen werden soll.</param>
        <param name="priority">Die Priorität, die bestimmt, in welcher Reihenfolge der angegebene Rückruf relativ zu den anderen ausstehenden Vorgängen in <see cref="T:System.Windows.Threading.Dispatcher" /> aufgerufen wird.</param>
        <param name="cancellationToken">Ein Objekt, das angibt, ob die Aktion abgebrochen werden kann.</param>
        <param name="timeout">Die minimale Zeitspanne, die auf den Start des Vorgangs gewartet wird.</param>
        <summary>Führt die angegebene <see cref="T:System.Action" /> synchron mit der angegebenen Priorität auf dem Thread aus, dem der <see cref="T:System.Windows.Threading.Dispatcher" /> zugeordnet ist.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (Delegate method, TimeSpan timeout, System.Windows.Threading.DispatcherPriority priority, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(class System.Delegate method, valuetype System.TimeSpan timeout, valuetype System.Windows.Threading.DispatcherPriority priority, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.TimeSpan,System.Windows.Threading.DispatcherPriority,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (method As Delegate, timeout As TimeSpan, priority As DispatcherPriority, ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(Delegate ^ method, TimeSpan timeout, System::Windows::Threading::DispatcherPriority priority, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Delegate * TimeSpan * System.Windows.Threading.DispatcherPriority * obj[] -&gt; obj" Usage="dispatcher.Invoke (method, timeout, priority, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method">Ein Delegat für eine Methode, die in <paramref name="args" /> angegebene Parameter akzeptiert und in die <see cref="T:System.Windows.Threading.Dispatcher" />-Ereigniswarteschlange gestellt wird.</param>
        <param name="timeout">Die maximale Zeitspanne, die auf den Abschluss der Operation gewartet wird.</param>
        <param name="priority">Die Priorität, relativ zu den anderen anstehenden Operationen in der <see cref="T:System.Windows.Threading.Dispatcher" />-Ereigniswarteschlange, mit der die angegebene Methode aufgerufen wird.</param>
        <param name="args">Ein Array von Objekten, die als Argumente an die angegebene Methode übergeben werden sollen. Kann <see langword="null" /> sein.</param>
        <summary>Führt den angegebenen Delegaten in der angegebenen Zeitspanne mit der angegebenen Priorität und den angegebenen Argumenten synchron für den Thread aus, dem der <see cref="T:System.Windows.Threading.Dispatcher" /> zugeordnet ist.</summary>
        <returns>Der Rückgabewert des aufgerufenen Delegaten bzw. <see langword="null" />, wenn der Delegat keinen Wert zurückgibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]kann nur der Thread, der einen <xref:System.Windows.Threading.DispatcherObject> erstellt hat, auf dieses Objekt zugreifen. Beispielsweise kann ein Hintergrund Thread, der aus dem Hauptbenutzer Oberflächen-Thread ausgelöst wird, den Inhalt eines <xref:System.Windows.Controls.Button> nicht aktualisieren, der im UI-Thread erstellt wurde. Damit der Hintergrund Thread auf die Content-Eigenschaft von <xref:System.Windows.Controls.Button>zugreifen kann, muss der Hintergrund Thread die Arbeit an die <xref:System.Windows.Threading.Dispatcher> mit dem UI-Thread zugeordnete delegieren. Dies wird mithilfe <xref:System.Windows.Threading.Dispatcher.Invoke%2A> von oder <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>erreicht. <xref:System.Windows.Threading.Dispatcher.Invoke%2A>ist synchron und <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> ist asynchron. Der-Vorgang wird der-Ereignis Warteschlange <xref:System.Windows.Threading.Dispatcher> von am angegebenen <xref:System.Windows.Threading.DispatcherPriority>hinzugefügt.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A>ist ein synchroner Vorgang. Daher wird die Steuerung erst wieder an das aufrufende Objekt zurückgegeben, nachdem der Rückruf zurückgegeben wurde.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (System.Windows.Threading.DispatcherPriority priority, Delegate method, object arg, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(valuetype System.Windows.Threading.DispatcherPriority priority, class System.Delegate method, object arg, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (priority As DispatcherPriority, method As Delegate, arg As Object, ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(System::Windows::Threading::DispatcherPriority priority, Delegate ^ method, System::Object ^ arg, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.Invoke : System.Windows.Threading.DispatcherPriority * Delegate * obj * obj[] -&gt; obj" Usage="dispatcher.Invoke (priority, method, arg, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="arg" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="priority">Die Priorität, relativ zu den anderen anstehenden Operationen in der <see cref="T:System.Windows.Threading.Dispatcher" />-Ereigniswarteschlange, mit der die angegebene Methode aufgerufen wird.</param>
        <param name="method">Ein Delegat zu einer Methode, die mehrere Argumente erwartet und in die <see cref="T:System.Windows.Threading.Dispatcher" />-Ereigniswarteschlange gestellt wird.</param>
        <param name="arg">Ein Objekt, das als Argument an die angegebene Methode übergeben werden soll.</param>
        <param name="args">Ein Array von Objekten, die als Argumente an die angegebene Methode übergeben werden sollen.</param>
        <summary>Führt den angegebenen Delegaten mit der angegebenen Priorität und den angegebenen Argumenten synchron auf dem Thread aus, dem der <see cref="T:System.Windows.Threading.Dispatcher" /> zugeordnet ist.</summary>
        <returns>Der Rückgabewert des aufgerufenen Delegaten bzw. <see langword="null" />, wenn der Delegat keinen Wert zurückgibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Arg`kann sein `null` , wenn ein Argument nicht benötigt wird.  
  
 In [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]kann nur der Thread, der einen <xref:System.Windows.Threading.DispatcherObject> erstellt hat, auf dieses Objekt zugreifen.  Beispielsweise kann ein Hintergrund Thread, der aus dem Hauptbenutzer Oberflächen-Thread ausgelöst wird, den Inhalt eines <xref:System.Windows.Controls.Button> nicht aktualisieren, der im UI-Thread erstellt wurde.  Damit der Hintergrund Thread auf die Content-Eigenschaft von <xref:System.Windows.Controls.Button>zugreifen kann, muss der Hintergrund Thread die Arbeit an die <xref:System.Windows.Threading.Dispatcher> mit dem UI-Thread zugeordnete delegieren.  Dies wird mithilfe <xref:System.Windows.Threading.Dispatcher.Invoke%2A> von oder <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>erreicht.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A>ist synchron und <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> ist asynchron.  Der-Vorgang wird der-Ereignis Warteschlange <xref:System.Windows.Threading.Dispatcher> von am angegebenen <xref:System.Windows.Threading.DispatcherPriority>hinzugefügt.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A>ist ein synchroner Vorgang. Daher wird die Steuerung erst wieder an das aufrufende Objekt zurückgegeben, nachdem der Rückruf zurückgegeben wurde.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="priority" /> ist gleich <see cref="F:System.Windows.Threading.DispatcherPriority.Inactive" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="priority" /> ist keine gültige Priorität.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="method" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (System.Windows.Threading.DispatcherPriority priority, TimeSpan timeout, Delegate method, object arg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(valuetype System.Windows.Threading.DispatcherPriority priority, valuetype System.TimeSpan timeout, class System.Delegate method, object arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (priority As DispatcherPriority, timeout As TimeSpan, method As Delegate, arg As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(System::Windows::Threading::DispatcherPriority priority, TimeSpan timeout, Delegate ^ method, System::Object ^ arg);" />
      <MemberSignature Language="F#" Value="member this.Invoke : System.Windows.Threading.DispatcherPriority * TimeSpan * Delegate * obj -&gt; obj" Usage="dispatcher.Invoke (priority, timeout, method, arg)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="arg" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="priority">Die Priorität, relativ zu den anderen anstehenden Operationen in der <see cref="T:System.Windows.Threading.Dispatcher" />-Ereigniswarteschlange, mit der die angegebene Methode aufgerufen wird.</param>
        <param name="timeout">Die maximale Zeit, die auf den Abschluss der Operation gewartet wird.</param>
        <param name="method">Ein Delegat zu einer Methode, die mehrere Argumente erwartet und in die <see cref="T:System.Windows.Threading.Dispatcher" />-Ereigniswarteschlange gestellt wird.</param>
        <param name="arg">Ein Objekt, das als Argument an die angegebene Methode übergeben werden soll. Dies kann <see langword="null" /> sein, wenn keine Argumente benötigt werden.</param>
        <summary>Führt den angegebenen Delegaten mit der angegebenen Priorität und dem angegebenen Argument synchron auf dem Thread aus, dem der <see cref="T:System.Windows.Threading.Dispatcher" /> zugeordnet ist.</summary>
        <returns>Der Rückgabewert des aufgerufenen Delegaten bzw. <see langword="null" />, wenn der Delegat keinen Wert zurückgibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Arg`kann sein `null` , wenn ein Argument nicht benötigt wird.  
  
 In [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]kann nur der Thread, der einen <xref:System.Windows.Threading.DispatcherObject> erstellt hat, auf dieses Objekt zugreifen.  Beispielsweise kann ein Hintergrund Thread, der aus dem Hauptbenutzer Oberflächen-Thread ausgelöst wird, den Inhalt eines <xref:System.Windows.Controls.Button> nicht aktualisieren, der im UI-Thread erstellt wurde.  Damit der Hintergrund Thread auf die Content-Eigenschaft von <xref:System.Windows.Controls.Button>zugreifen kann, muss der Hintergrund Thread die Arbeit an die <xref:System.Windows.Threading.Dispatcher> mit dem UI-Thread zugeordnete delegieren.  Dies wird mithilfe <xref:System.Windows.Threading.Dispatcher.Invoke%2A> von oder <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>erreicht.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A>ist synchron und <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> ist asynchron.  Der-Vorgang wird der-Ereignis Warteschlange <xref:System.Windows.Threading.Dispatcher> von am angegebenen <xref:System.Windows.Threading.DispatcherPriority>hinzugefügt.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A>ist ein synchroner Vorgang. Daher wird die Steuerung erst wieder an das aufrufende Objekt zurückgegeben, nachdem der Rückruf zurückgegeben wurde.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="priority" /> ist gleich <see cref="F:System.Windows.Threading.DispatcherPriority.Inactive" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="priority" /> ist keine gültige Priorität.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="method" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (System.Windows.Threading.DispatcherPriority priority, TimeSpan timeout, Delegate method, object arg, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(valuetype System.Windows.Threading.DispatcherPriority priority, valuetype System.TimeSpan timeout, class System.Delegate method, object arg, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate,System.Object,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (priority As DispatcherPriority, timeout As TimeSpan, method As Delegate, arg As Object, ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(System::Windows::Threading::DispatcherPriority priority, TimeSpan timeout, Delegate ^ method, System::Object ^ arg, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.Invoke : System.Windows.Threading.DispatcherPriority * TimeSpan * Delegate * obj * obj[] -&gt; obj" Usage="dispatcher.Invoke (priority, timeout, method, arg, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="arg" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="priority">Die Priorität, relativ zu den anderen anstehenden Operationen in der <see cref="T:System.Windows.Threading.Dispatcher" />-Ereigniswarteschlange, mit der die angegebene Methode aufgerufen wird.</param>
        <param name="timeout">Die maximale Zeit, die auf den Abschluss der Operation gewartet wird.</param>
        <param name="method">Ein Delegat zu einer Methode, die mehrere Argumente erwartet und in die <see cref="T:System.Windows.Threading.Dispatcher" />-Ereigniswarteschlange gestellt wird.</param>
        <param name="arg">Ein Objekt, das als Argument an die angegebene Methode übergeben wird.</param>
        <param name="args">Ein Array von Objekten, die als Argumente an die angegebene Methode übergeben werden sollen.</param>
        <summary>Führt den angegebenen Delegaten mit der angegebenen Priorität und den angegebenen Argumenten synchron auf dem Thread aus, dem der <see cref="T:System.Windows.Threading.Dispatcher" /> zugeordnet ist.</summary>
        <returns>Der Rückgabewert des aufgerufenen Delegaten bzw. <see langword="null" />, wenn der Delegat keinen Wert zurückgibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Arg`kann sein `null` , wenn kein Argument benötigt wird.  
  
 In [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]kann nur der Thread, der einen <xref:System.Windows.Threading.DispatcherObject> erstellt hat, auf dieses Objekt zugreifen.  Beispielsweise kann ein Hintergrund Thread, der aus dem Hauptbenutzer Oberflächen-Thread ausgelöst wird, den Inhalt eines <xref:System.Windows.Controls.Button> nicht aktualisieren, der im UI-Thread erstellt wurde.  Damit der Hintergrund Thread auf die Content-Eigenschaft von <xref:System.Windows.Controls.Button>zugreifen kann, muss der Hintergrund Thread die Arbeit an die <xref:System.Windows.Threading.Dispatcher> mit dem UI-Thread zugeordnete delegieren.  Dies wird mithilfe <xref:System.Windows.Threading.Dispatcher.Invoke%2A> von oder <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>erreicht.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A>ist synchron und <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> ist asynchron.  Der-Vorgang wird der-Ereignis Warteschlange <xref:System.Windows.Threading.Dispatcher> von am angegebenen <xref:System.Windows.Threading.DispatcherPriority>hinzugefügt.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A>ist ein synchroner Vorgang. Daher wird die Steuerung erst wieder an das aufrufende Objekt zurückgegeben, nachdem der Rückruf zurückgegeben wurde.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="priority" /> ist gleich <see cref="F:System.Windows.Threading.DispatcherPriority.Inactive" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="priority" /> ist kein gültiger <see cref="T:System.Windows.Threading.DispatcherPriority" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="method" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public TResult Invoke&lt;TResult&gt; (Func&lt;TResult&gt; callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !!TResult Invoke&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke(Of TResult) (callback As Func(Of TResult)) As TResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; TResult Invoke(Func&lt;TResult&gt; ^ callback);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Func&lt;'Result&gt; -&gt; 'Result" Usage="dispatcher.Invoke callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callback" Type="System.Func&lt;TResult&gt;" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Rückgabewerts des angegebenen Delegaten.</typeparam>
        <param name="callback">Ein Delegat, der über den Verteiler aufgerufen werden soll.</param>
        <summary>Führt die angegebene <see cref="T:System.Func`1" /> synchron auf dem Thread aus, dem der <see cref="T:System.Windows.Threading.Dispatcher" /> zugeordnet ist.</summary>
        <returns>To be added.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der von `callback`zurückgegebene Wert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public TResult Invoke&lt;TResult&gt; (Func&lt;TResult&gt; callback, System.Windows.Threading.DispatcherPriority priority);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !!TResult Invoke&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; callback, valuetype System.Windows.Threading.DispatcherPriority priority) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority)" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke(Of TResult) (callback As Func(Of TResult), priority As DispatcherPriority) As TResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; TResult Invoke(Func&lt;TResult&gt; ^ callback, System::Windows::Threading::DispatcherPriority priority);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Func&lt;'Result&gt; * System.Windows.Threading.DispatcherPriority -&gt; 'Result" Usage="dispatcher.Invoke (callback, priority)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callback" Type="System.Func&lt;TResult&gt;" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Rückgabewerts des angegebenen Delegaten.</typeparam>
        <param name="callback">Ein Delegat, der über den Verteiler aufgerufen werden soll.</param>
        <param name="priority">Die Priorität, die bestimmt, in welcher Reihenfolge der angegebene Rückruf relativ zu den anderen ausstehenden Vorgängen in <see cref="T:System.Windows.Threading.Dispatcher" /> aufgerufen wird.</param>
        <summary>Führt die angegebene <see cref="T:System.Func`1" /> synchron mit der angegebenen Priorität auf dem Thread aus, dem der <see cref="T:System.Windows.Threading.Dispatcher" /> zugeordnet ist.</summary>
        <returns>To be added.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der von `callback`zurückgegebene Wert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public TResult Invoke&lt;TResult&gt; (Func&lt;TResult&gt; callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !!TResult Invoke&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; callback, valuetype System.Windows.Threading.DispatcherPriority priority, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; TResult Invoke(Func&lt;TResult&gt; ^ callback, System::Windows::Threading::DispatcherPriority priority, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Func&lt;'Result&gt; * System.Windows.Threading.DispatcherPriority * System.Threading.CancellationToken -&gt; 'Result" Usage="dispatcher.Invoke (callback, priority, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callback" Type="System.Func&lt;TResult&gt;" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="2" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Rückgabewerts des angegebenen Delegaten.</typeparam>
        <param name="callback">Ein Delegat, der über den Verteiler aufgerufen werden soll.</param>
        <param name="priority">Die Priorität, die bestimmt, in welcher Reihenfolge der angegebene Rückruf relativ zu den anderen ausstehenden Vorgängen in <see cref="T:System.Windows.Threading.Dispatcher" /> aufgerufen wird.</param>
        <param name="cancellationToken">Ein Objekt, das angibt, ob der Vorgang abgebrochen werden kann.</param>
        <summary>Führt die angegebene <see cref="T:System.Func`1" /> synchron mit der angegebenen Priorität auf dem Thread aus, dem der <see cref="T:System.Windows.Threading.Dispatcher" /> zugeordnet ist.</summary>
        <returns>To be added.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der von `callback`zurückgegebene Wert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public TResult Invoke&lt;TResult&gt; (Func&lt;TResult&gt; callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !!TResult Invoke&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; callback, valuetype System.Windows.Threading.DispatcherPriority priority, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken,System.TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; TResult Invoke(Func&lt;TResult&gt; ^ callback, System::Windows::Threading::DispatcherPriority priority, System::Threading::CancellationToken cancellationToken, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Func&lt;'Result&gt; * System.Windows.Threading.DispatcherPriority * System.Threading.CancellationToken * TimeSpan -&gt; 'Result" Usage="dispatcher.Invoke (callback, priority, cancellationToken, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callback" Type="System.Func&lt;TResult&gt;" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="2" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="3" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Rückgabewerts des angegebenen Delegaten.</typeparam>
        <param name="callback">Ein Delegat, der über den Verteiler aufgerufen werden soll.</param>
        <param name="priority">Die Priorität, die bestimmt, in welcher Reihenfolge der angegebene Rückruf relativ zu den anderen ausstehenden Vorgängen in <see cref="T:System.Windows.Threading.Dispatcher" /> aufgerufen wird.</param>
        <param name="cancellationToken">Ein Objekt, das angibt, ob der Vorgang abgebrochen werden kann.</param>
        <param name="timeout">Die minimale Zeitspanne, die auf den Start des Vorgangs gewartet wird.</param>
        <summary>Führt die angegebene <see cref="T:System.Func`1" /> synchron mit der angegebenen Priorität auf dem Thread aus, dem der <see cref="T:System.Windows.Threading.Dispatcher" /> zugeordnet ist.</summary>
        <returns>To be added.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der von `callback`zurückgegebene Wert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="InvokeAsync">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Führt den angegebenen Delegaten asynchron auf dem Thread aus, dem der <see cref="T:System.Windows.Threading.Dispatcher" /> zugeordnet ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="InvokeAsync">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation InvokeAsync (Action callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation InvokeAsync(class System.Action callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.InvokeAsync(System.Action)" />
      <MemberSignature Language="VB.NET" Value="Public Function InvokeAsync (callback As Action) As DispatcherOperation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Threading::DispatcherOperation ^ InvokeAsync(Action ^ callback);" />
      <MemberSignature Language="F#" Value="member this.InvokeAsync : Action -&gt; System.Windows.Threading.DispatcherOperation" Usage="dispatcher.InvokeAsync callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="callback">Ein Delegat, der über den Verteiler aufgerufen werden soll.</param>
        <summary>Führt die angegebene <see cref="T:System.Action" /> asynchron auf dem Thread aus, dem der <see cref="T:System.Windows.Threading.Dispatcher" /> zugeordnet ist.</summary>
        <returns>Ein Objekt, das unmittelbar nach dem Aufruf von <see cref="M:System.Windows.Threading.Dispatcher.InvokeAsync(System.Action)" /> zurückgegeben wird und für die Interaktion mit dem Delegaten verwendet werden kann, während im Delegaten die Ausführung einer Aufgabe in der Warteschlange steht.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeAsync">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation InvokeAsync (Action callback, System.Windows.Threading.DispatcherPriority priority);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation InvokeAsync(class System.Action callback, valuetype System.Windows.Threading.DispatcherPriority priority) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.InvokeAsync(System.Action,System.Windows.Threading.DispatcherPriority)" />
      <MemberSignature Language="VB.NET" Value="Public Function InvokeAsync (callback As Action, priority As DispatcherPriority) As DispatcherOperation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Threading::DispatcherOperation ^ InvokeAsync(Action ^ callback, System::Windows::Threading::DispatcherPriority priority);" />
      <MemberSignature Language="F#" Value="member this.InvokeAsync : Action * System.Windows.Threading.DispatcherPriority -&gt; System.Windows.Threading.DispatcherOperation" Usage="dispatcher.InvokeAsync (callback, priority)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="callback">Ein Delegat, der über den Verteiler aufgerufen werden soll.</param>
        <param name="priority">Die Priorität, die bestimmt, in welcher Reihenfolge der angegebene Rückruf relativ zu den anderen ausstehenden Vorgängen in <see cref="T:System.Windows.Threading.Dispatcher" /> aufgerufen wird.</param>
        <summary>Führt die angegebene <see cref="T:System.Action" /> asynchron mit der angegebenen Priorität auf dem Thread aus, dem der <see cref="T:System.Windows.Threading.Dispatcher" /> zugeordnet ist.</summary>
        <returns>Ein Objekt, das unmittelbar nach dem Aufruf von <see cref="M:System.Windows.Threading.Dispatcher.InvokeAsync(System.Action,System.Windows.Threading.DispatcherPriority)" /> zurückgegeben wird und für die Interaktion mit dem Delegaten verwendet werden kann, während im Delegaten die Ausführung einer Aufgabe in der Warteschlange steht.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeAsync">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation InvokeAsync (Action callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation InvokeAsync(class System.Action callback, valuetype System.Windows.Threading.DispatcherPriority priority, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.InvokeAsync(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Threading::DispatcherOperation ^ InvokeAsync(Action ^ callback, System::Windows::Threading::DispatcherPriority priority, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.InvokeAsync : Action * System.Windows.Threading.DispatcherPriority * System.Threading.CancellationToken -&gt; System.Windows.Threading.DispatcherOperation" Usage="dispatcher.InvokeAsync (callback, priority, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="2" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="callback">Ein Delegat, der über den Verteiler aufgerufen werden soll.</param>
        <param name="priority">Die Priorität, die bestimmt, in welcher Reihenfolge der angegebene Rückruf relativ zu den anderen ausstehenden Vorgängen in <see cref="T:System.Windows.Threading.Dispatcher" /> aufgerufen wird.</param>
        <param name="cancellationToken">Ein Objekt, das angibt, ob die Aktion abgebrochen werden kann.</param>
        <summary>Führt die angegebene <see cref="T:System.Action" /> asynchron mit der angegebenen Priorität auf dem Thread aus, dem der <see cref="T:System.Windows.Threading.Dispatcher" /> zugeordnet ist.</summary>
        <returns>Ein Objekt, das unmittelbar nach dem Aufruf von <see cref="M:System.Windows.Threading.Dispatcher.InvokeAsync(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)" /> zurückgegeben wird und für die Interaktion mit dem Delegaten verwendet werden kann, während im Delegaten die Ausführung einer Aufgabe in der Warteschlange steht.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeAsync&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation&lt;TResult&gt; InvokeAsync&lt;TResult&gt; (Func&lt;TResult&gt; callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation`1&lt;!!TResult&gt; InvokeAsync&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function InvokeAsync(Of TResult) (callback As Func(Of TResult)) As DispatcherOperation(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Windows::Threading::DispatcherOperation&lt;TResult&gt; ^ InvokeAsync(Func&lt;TResult&gt; ^ callback);" />
      <MemberSignature Language="F#" Value="member this.InvokeAsync : Func&lt;'Result&gt; -&gt; System.Windows.Threading.DispatcherOperation&lt;'Result&gt;" Usage="dispatcher.InvokeAsync callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callback" Type="System.Func&lt;TResult&gt;" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Rückgabewerts des angegebenen Delegaten.</typeparam>
        <param name="callback">Ein Delegat, der über den Verteiler aufgerufen werden soll.</param>
        <summary>Führt die angegebene <see cref="T:System.Func`1" /> asynchron auf dem Thread aus, dem der <see cref="T:System.Windows.Threading.Dispatcher" /> zugeordnet ist.</summary>
        <returns>Ein Objekt, das unmittelbar nach dem Aufruf von <see cref="M:System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0})" /> zurückgegeben wird und für die Interaktion mit dem Delegaten verwendet werden kann, während im Delegaten die Ausführung einer Aufgabe in der Warteschlange steht.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeAsync&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation&lt;TResult&gt; InvokeAsync&lt;TResult&gt; (Func&lt;TResult&gt; callback, System.Windows.Threading.DispatcherPriority priority);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation`1&lt;!!TResult&gt; InvokeAsync&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; callback, valuetype System.Windows.Threading.DispatcherPriority priority) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0},System.Windows.Threading.DispatcherPriority)" />
      <MemberSignature Language="VB.NET" Value="Public Function InvokeAsync(Of TResult) (callback As Func(Of TResult), priority As DispatcherPriority) As DispatcherOperation(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Windows::Threading::DispatcherOperation&lt;TResult&gt; ^ InvokeAsync(Func&lt;TResult&gt; ^ callback, System::Windows::Threading::DispatcherPriority priority);" />
      <MemberSignature Language="F#" Value="member this.InvokeAsync : Func&lt;'Result&gt; * System.Windows.Threading.DispatcherPriority -&gt; System.Windows.Threading.DispatcherOperation&lt;'Result&gt;" Usage="dispatcher.InvokeAsync (callback, priority)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callback" Type="System.Func&lt;TResult&gt;" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Rückgabewerts des angegebenen Delegaten.</typeparam>
        <param name="callback">Ein Delegat, der über den Verteiler aufgerufen werden soll.</param>
        <param name="priority">Die Priorität, die bestimmt, in welcher Reihenfolge der angegebene Rückruf relativ zu den anderen ausstehenden Vorgängen in <see cref="T:System.Windows.Threading.Dispatcher" /> aufgerufen wird.</param>
        <summary>Führt die angegebene <see cref="T:System.Func`1" /> asynchron mit der angegebenen Priorität auf dem Thread aus, dem der <see cref="T:System.Windows.Threading.Dispatcher" /> zugeordnet ist.</summary>
        <returns>Ein Objekt, das unmittelbar nach dem Aufruf von <see cref="M:System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0},System.Windows.Threading.DispatcherPriority)" /> zurückgegeben wird und für die Interaktion mit dem Delegaten verwendet werden kann, während im Delegaten die Ausführung einer Aufgabe in der Warteschlange steht.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeAsync&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation&lt;TResult&gt; InvokeAsync&lt;TResult&gt; (Func&lt;TResult&gt; callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation`1&lt;!!TResult&gt; InvokeAsync&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; callback, valuetype System.Windows.Threading.DispatcherPriority priority, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Windows::Threading::DispatcherOperation&lt;TResult&gt; ^ InvokeAsync(Func&lt;TResult&gt; ^ callback, System::Windows::Threading::DispatcherPriority priority, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.InvokeAsync : Func&lt;'Result&gt; * System.Windows.Threading.DispatcherPriority * System.Threading.CancellationToken -&gt; System.Windows.Threading.DispatcherOperation&lt;'Result&gt;" Usage="dispatcher.InvokeAsync (callback, priority, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callback" Type="System.Func&lt;TResult&gt;" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="2" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Rückgabewerts des angegebenen Delegaten.</typeparam>
        <param name="callback">Ein Delegat, der über den Verteiler aufgerufen werden soll.</param>
        <param name="priority">Die Priorität, die bestimmt, in welcher Reihenfolge der angegebene Rückruf relativ zu den anderen ausstehenden Vorgängen in <see cref="T:System.Windows.Threading.Dispatcher" /> aufgerufen wird.</param>
        <param name="cancellationToken">Ein Objekt, das angibt, ob der Vorgang abgebrochen werden kann.</param>
        <summary>Führt die angegebene <see cref="T:System.Func`1" /> asynchron mit der angegebenen Priorität auf dem Thread aus, dem der <see cref="T:System.Windows.Threading.Dispatcher" /> zugeordnet ist.</summary>
        <returns>Ein Objekt, das unmittelbar nach dem Aufruf von <see cref="M:System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)" /> zurückgegeben wird und für die Interaktion mit dem Delegaten verwendet werden kann, während im Delegaten die Ausführung einer Aufgabe in der Warteschlange steht.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeShutdown">
      <MemberSignature Language="C#" Value="public void InvokeShutdown ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InvokeShutdown() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.InvokeShutdown" />
      <MemberSignature Language="VB.NET" Value="Public Sub InvokeShutdown ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InvokeShutdown();" />
      <MemberSignature Language="F#" Value="member this.InvokeShutdown : unit -&gt; unit" Usage="dispatcher.InvokeShutdown " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Initiiert die synchrone Beendigung des <see cref="T:System.Windows.Threading.Dispatcher" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Threading.Dispatcher.InvokeShutdown%2A>erfordert uneingeschränkte Benutzeroberflächen Berechtigungen.  
  
 Wenn das <xref:System.Windows.Threading.Dispatcher> Herunterfahren von gestartet wird, <xref:System.Windows.Threading.Dispatcher.ShutdownStarted> wird das-Ereignis <xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> ausgelöst, und `true`wird auf festgelegt.  
  
 Der <xref:System.Windows.Threading.Dispatcher> wird nicht vollständig heruntergefahren, bis die Ereignis Warteschlange entlädt.  
  
 Wenn das Herunterfahren des Verteilers abgeschlossen ist <xref:System.Windows.Threading.Dispatcher.ShutdownFinished> , wird das-Ereignis <xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A> ausgelöst, und die `true`-Eigenschaft ist auf festgelegt.  
  
 Nachdem der Vorgang zum Herunterfahren begonnen hat, werden alle ausstehenden Arbeitselemente in der Warteschlange abgebrochen.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">zum Herunterfahren des Verteilers.  Zugehörige Enumerationen:<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="PushFrame">
      <MemberSignature Language="C#" Value="public static void PushFrame (System.Windows.Threading.DispatcherFrame frame);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PushFrame(class System.Windows.Threading.DispatcherFrame frame) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.PushFrame(System.Windows.Threading.DispatcherFrame)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PushFrame (frame As DispatcherFrame)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PushFrame(System::Windows::Threading::DispatcherFrame ^ frame);" />
      <MemberSignature Language="F#" Value="static member PushFrame : System.Windows.Threading.DispatcherFrame -&gt; unit" Usage="System.Windows.Threading.Dispatcher.PushFrame frame" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="frame" Type="System.Windows.Threading.DispatcherFrame" />
      </Parameters>
      <Docs>
        <param name="frame">Der Frame, den der Verteiler verarbeiten soll.</param>
        <summary>Tritt in eine Ausführungsschleife ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine <xref:System.Windows.Threading.DispatcherFrame> stellt eine-Schleife dar, die ausstehende Arbeitselemente verarbeitet.  
  
 Der Verteiler verarbeitet die Arbeitsaufgaben Warteschlange in einer-Schleife.  Die Schleife wird als Frame bezeichnet.  Die ursprüngliche Schleife wird in der Regel von der Anwendung initiiert <xref:System.Windows.Threading.Dispatcher.Run%2A>, indem aufgerufen wird.  
  
 <xref:System.Windows.Threading.Dispatcher.PushFrame%2A>gibt eine durch den-Parameter `frame`dargestellte Schleife ein.  Bei jeder Iterationen der Schleife <xref:System.Windows.Threading.Dispatcher> <xref:System.Windows.Threading.DispatcherFrame.Continue%2A> prüft die-Eigenschaft <xref:System.Windows.Threading.DispatcherFrame> der-Klasse, um zu bestimmen, ob die Schleife fortgesetzt werden soll, oder ob Sie beendet werden soll.  
  
 <xref:System.Windows.Threading.DispatcherFrame>ermöglicht, dass <xref:System.Windows.Threading.DispatcherFrame.Continue%2A> die-Eigenschaft explizit festgelegt wird und die <xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> -Eigenschaft auf <xref:System.Windows.Threading.Dispatcher>dem-Objekt respektiert.  Dies bedeutet, dass <xref:System.Windows.Threading.Dispatcher> beim Herunterfahren von Rahmen, die die Standard <xref:System.Windows.Threading.DispatcherFrame> Implementierung verwenden, beendet werden, sodass alle geschalbten Frames beendet werden können.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie ein <xref:System.Windows.Threading.DispatcherFrame> verwendet wird, um ähnliche Ergebnisse [!INCLUDE[TLA#tla_winforms](~/includes/tlasharptla-winforms-md.md)] wie die <xref:System.Windows.Forms.Application.DoEvents%2A> -Methode zu erzielen.  
  
 [!code-csharp[dispatchersnippets#DispatcherDispatcherFrameDoEvents](~/samples/snippets/csharp/VS_Snippets_Wpf/DispatcherSnippets/CSharp/Window1.xaml.cs#dispatcherdispatcherframedoevents)]
 [!code-vb[dispatchersnippets#DispatcherDispatcherFrameDoEvents](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DispatcherSnippets/visualbasic/window1.xaml.vb#dispatcherdispatcherframedoevents)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="frame" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Windows.Threading.Dispatcher.HasShutdownFinished" /> ist gleich <see langword="true" />.  
  
- oder - 
 <paramref name="frame" /> wird auf einem anderen <see cref="T:System.Windows.Threading.Dispatcher" /> ausgeführt.  
  
- oder - 
Verteilerverarbeitung wurde deaktiviert.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">zum Übertragen eines Ausführungs Rahmens.  Zugehörige Enumerationen:<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="M:System.Windows.Threading.Dispatcher.ExitAllFrames" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Run" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run();" />
      <MemberSignature Language="F#" Value="static member Run : unit -&gt; unit" Usage="System.Windows.Threading.Dispatcher.Run " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Stellt den Hauptausführungsframe in die Ereigniswarteschlange von <see cref="T:System.Windows.Threading.Dispatcher" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Windows.Threading.Dispatcher> verarbeitet die Ereignis Warteschlange in einer-Schleife.  Die Schleife wird als Frame bezeichnet.  Die ursprüngliche Schleife wird in der Regel von der Anwendung initiiert <xref:System.Windows.Threading.Dispatcher.Run%2A>, indem aufgerufen wird.  
  
 Der Haupt Ausführungs Rahmen wird fortgesetzt, <xref:System.Windows.Threading.Dispatcher> bis das heruntergefahren wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShutdownFinished">
      <MemberSignature Language="C#" Value="public event EventHandler ShutdownFinished;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ShutdownFinished" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Threading.Dispatcher.ShutdownFinished" />
      <MemberSignature Language="VB.NET" Value="Public Event ShutdownFinished As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ShutdownFinished;" />
      <MemberSignature Language="F#" Value="member this.ShutdownFinished : EventHandler " Usage="member this.ShutdownFinished : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn der <see cref="T:System.Windows.Threading.Dispatcher" /> die Beendigung abschließt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn das <xref:System.Windows.Threading.Dispatcher> Herunterfahren eines gestartet wird, wird das <xref:System.Windows.Threading.Dispatcher.ShutdownStarted> -Ereignis ausgelöst, und <xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> wird auf `true`festgelegt.  
  
 Der <xref:System.Windows.Threading.Dispatcher> wird nicht vollständig heruntergefahren, bis die Ereignis Warteschlange entlädt.  
  
 Wenn das Herunterfahren des Verteilers abgeschlossen ist <xref:System.Windows.Threading.Dispatcher.ShutdownFinished> , wird das-Ereignis <xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A> ausgelöst, und die `true`-Eigenschaft ist auf festgelegt.  
  
 Nachdem der Vorgang zum Herunterfahren begonnen hat, werden alle ausstehenden Arbeitselemente in der Warteschlange abgebrochen.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Threading.Dispatcher.HasShutdownFinished" />
        <altmember cref="P:System.Windows.Threading.Dispatcher.HasShutdownStarted" />
        <altmember cref="M:System.Windows.Threading.Dispatcher.BeginInvokeShutdown(System.Windows.Threading.DispatcherPriority)" />
        <altmember cref="M:System.Windows.Threading.Dispatcher.InvokeShutdown" />
      </Docs>
    </Member>
    <Member MemberName="ShutdownStarted">
      <MemberSignature Language="C#" Value="public event EventHandler ShutdownStarted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ShutdownStarted" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Threading.Dispatcher.ShutdownStarted" />
      <MemberSignature Language="VB.NET" Value="Public Event ShutdownStarted As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ShutdownStarted;" />
      <MemberSignature Language="F#" Value="member this.ShutdownStarted : EventHandler " Usage="member this.ShutdownStarted : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn der <see cref="T:System.Windows.Threading.Dispatcher" /> die Beendigung beginnt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn das <xref:System.Windows.Threading.Dispatcher> Herunterfahren eines gestartet wird, wird das <xref:System.Windows.Threading.Dispatcher.ShutdownStarted> -Ereignis ausgelöst, und <xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> wird auf `true`festgelegt.  
  
 Der <xref:System.Windows.Threading.Dispatcher> wird nicht vollständig heruntergefahren, bis die Ereignis Warteschlange entlädt.  
  
 Wenn das Herunterfahren des Verteilers abgeschlossen ist <xref:System.Windows.Threading.Dispatcher.ShutdownFinished> , wird das-Ereignis <xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A> ausgelöst, und die `true`-Eigenschaft ist auf festgelegt.  
  
 Nachdem der Vorgang zum Herunterfahren begonnen hat, werden alle ausstehenden Arbeitselemente in der Warteschlange abgebrochen.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Threading.Dispatcher.HasShutdownStarted" />
        <altmember cref="E:System.Windows.Threading.Dispatcher.ShutdownFinished" />
        <altmember cref="M:System.Windows.Threading.Dispatcher.BeginInvokeShutdown(System.Windows.Threading.DispatcherPriority)" />
        <altmember cref="M:System.Windows.Threading.Dispatcher.InvokeShutdown" />
      </Docs>
    </Member>
    <Member MemberName="Thread">
      <MemberSignature Language="C#" Value="public System.Threading.Thread Thread { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.Thread Thread" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Threading.Dispatcher.Thread" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Thread As Thread" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::Thread ^ Thread { System::Threading::Thread ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Thread : System.Threading.Thread" Usage="System.Windows.Threading.Dispatcher.Thread" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Thread</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Thread ab, dem dieser <see cref="T:System.Windows.Threading.Dispatcher" /> zugeordnet ist.</summary>
        <value>Der Thread.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnhandledException">
      <MemberSignature Language="C#" Value="public event System.Windows.Threading.DispatcherUnhandledExceptionEventHandler UnhandledException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Threading.DispatcherUnhandledExceptionEventHandler UnhandledException" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Threading.Dispatcher.UnhandledException" />
      <MemberSignature Language="VB.NET" Value="Public Event UnhandledException As DispatcherUnhandledExceptionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Threading::DispatcherUnhandledExceptionEventHandler ^ UnhandledException;" />
      <MemberSignature Language="F#" Value="member this.UnhandledException : System.Windows.Threading.DispatcherUnhandledExceptionEventHandler " Usage="member this.UnhandledException : System.Windows.Threading.DispatcherUnhandledExceptionEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherUnhandledExceptionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn eine Threadausnahme ausgelöst und während der Ausführung eines Delegaten mit <see cref="Overload:System.Windows.Threading.Dispatcher.Invoke" /> oder <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" /> nicht abgefangen wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis wird ausgelöst, wenn eine Ausnahme ausgelöst wird, die während der Ausführung eines Delegaten <xref:System.Windows.Threading.Dispatcher.Invoke%2A> mithilfe <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> von oder nicht abgefangen wurde.  
  
 Ein Handler kann die Ausnahme als behandelt markieren, wodurch verhindert wird, dass der interne Ausnahmehandler aufgerufen wird.  
  
 Ereignishandler für dieses Ereignis müssen mit Bedacht geschrieben werden, um zu vermeiden, dass sekundäre Ausnahmen erstellt werden, und alle auftretenden Ereignisse zu erfassen. Es wird empfohlen, Speicherplatz zu vermeiden oder ressourcenintensive Vorgänge im-Handler durchzusetzen.  
  
 Das <xref:System.Windows.Threading.Dispatcher.UnhandledExceptionFilter> -Ereignis bietet die Möglichkeit, das <xref:System.Windows.Threading.Dispatcher.UnhandledException> -Ereignis nicht zu erhöhen.  Das <xref:System.Windows.Threading.Dispatcher.UnhandledExceptionFilter> -Ereignis wird zuerst ausgelöst, und <xref:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs.RequestCatch%2A> Wenn `false`für <xref:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs> auf festgelegt ist, <xref:System.Windows.Threading.Dispatcher.UnhandledException> wird das-Ereignis nicht ausgelöst.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Threading.DispatcherUnhandledExceptionEventHandler" />
        <altmember cref="T:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="UnhandledExceptionFilter">
      <MemberSignature Language="C#" Value="public event System.Windows.Threading.DispatcherUnhandledExceptionFilterEventHandler UnhandledExceptionFilter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Threading.DispatcherUnhandledExceptionFilterEventHandler UnhandledExceptionFilter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Threading.Dispatcher.UnhandledExceptionFilter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event UnhandledExceptionFilter As DispatcherUnhandledExceptionFilterEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Threading::DispatcherUnhandledExceptionFilterEventHandler ^ UnhandledExceptionFilter;" />
      <MemberSignature Language="F#" Value="member this.UnhandledExceptionFilter : System.Windows.Threading.DispatcherUnhandledExceptionFilterEventHandler " Usage="member this.UnhandledExceptionFilter : System.Windows.Threading.DispatcherUnhandledExceptionFilterEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherUnhandledExceptionFilterEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn eine Threadausnahme ausgelöst und nicht abgefangen wird, während ein Delegat mit <see cref="Overload:System.Windows.Threading.Dispatcher.Invoke" /> oder <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" /> ausgeführt wird und sich in der Filterstufe befindet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis wird während der Filter Phase für eine Ausnahme ausgelöst, die während der Ausführung eines Delegaten mithilfe von <xref:System.Windows.Threading.Dispatcher.Invoke%2A> oder <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> ausgelöst wird und nicht abgefangen wird.  
  
 Die aufzurufende aufrufsstapel wird an dieser Stelle nicht entwickelt (Ausnahme der ersten Chance).  
  
 Ereignishandler für dieses Ereignis müssen mit Bedacht geschrieben werden, um zu vermeiden, dass sekundäre Ausnahmen erstellt werden, und alle auftretenden Ereignisse zu erfassen.  Es wird empfohlen, Speicherplatz zu vermeiden oder ressourcenintensive Vorgänge im-Handler durchzusetzen.  
  
 Das <xref:System.Windows.Threading.Dispatcher.UnhandledExceptionFilter> -Ereignis bietet die Möglichkeit, das <xref:System.Windows.Threading.Dispatcher.UnhandledException> -Ereignis nicht zu erhöhen.  Das <xref:System.Windows.Threading.Dispatcher.UnhandledExceptionFilter> -Ereignis wird zuerst ausgelöst, und <xref:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs.RequestCatch%2A> Wenn `false`für <xref:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs> auf festgelegt ist, <xref:System.Windows.Threading.Dispatcher.UnhandledException> wird das-Ereignis nicht ausgelöst.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">zum Hinzufügen oder Entfernen eines Handlers für dieses Ereignis.  Zugehörige Enumerationen:<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventHandler" />
        <altmember cref="T:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="ValidatePriority">
      <MemberSignature Language="C#" Value="public static void ValidatePriority (System.Windows.Threading.DispatcherPriority priority, string parameterName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ValidatePriority(valuetype System.Windows.Threading.DispatcherPriority priority, string parameterName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.ValidatePriority(System.Windows.Threading.DispatcherPriority,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ValidatePriority (priority As DispatcherPriority, parameterName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ValidatePriority(System::Windows::Threading::DispatcherPriority priority, System::String ^ parameterName);" />
      <MemberSignature Language="F#" Value="static member ValidatePriority : System.Windows.Threading.DispatcherPriority * string -&gt; unit" Usage="System.Windows.Threading.Dispatcher.ValidatePriority (priority, parameterName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="parameterName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="priority">Die zu überprüfende Priorität.</param>
        <param name="parameterName">Eine Zeichenfolge, die von der Ausnahme zurückgegeben wird, die auftritt, wenn die Priorität ungültig ist.</param>
        <summary>Ermittelt, ob die angegebene <see cref="T:System.Windows.Threading.DispatcherPriority" /> eine gültige Priorität ist.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="priority" /> ist kein gültiger <see cref="T:System.Windows.Threading.DispatcherPriority" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="VerifyAccess">
      <MemberSignature Language="C#" Value="public void VerifyAccess ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void VerifyAccess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.VerifyAccess" />
      <MemberSignature Language="VB.NET" Value="Public Sub VerifyAccess ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void VerifyAccess();" />
      <MemberSignature Language="F#" Value="member this.VerifyAccess : unit -&gt; unit" Usage="dispatcher.VerifyAccess " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Bestimmt, ob der aufrufende Thread auf dieses <see cref="T:System.Windows.Threading.Dispatcher" /> zugreifen kann.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nur der Thread, <xref:System.Windows.Threading.Dispatcher> auf dem der erstellt wird, <xref:System.Windows.Threading.Dispatcher>kann auf das zugreifen.  
  
 Diese Methode ist öffentlich. Daher kann jeder Thread überprüfen, ob er auf <xref:System.Windows.Threading.Dispatcher>zugreifen kann.  
  
 Der Unterschied <xref:System.Windows.Threading.Dispatcher.CheckAccess%2A> zwischen <xref:System.Windows.Threading.Dispatcher.VerifyAccess%2A> und <xref:System.Windows.Threading.Dispatcher.CheckAccess%2A> ist ein boolescher Wert, wenn der aufrufende Thread keinen Zugriff auf <xref:System.Windows.Threading.Dispatcher> den <xref:System.Windows.Threading.Dispatcher.VerifyAccess%2A> hat und eine Ausnahme auslöst.  
  
   
  
## Examples  
 Im folgenden Beispiel wird <xref:System.Windows.Threading.Dispatcher.VerifyAccess%2A> verwendet, um zu bestimmen, ob ein Thread Zugriff auf den <xref:System.Windows.Controls.Button> Thread hat, in dem eine erstellt wurde.  Die-Methode nimmt ein-Objekt als Argument an, das in einen <xref:System.Windows.Controls.Button>umgewandelt wird.  Die <xref:System.Windows.Threading.Dispatcher.VerifyAccess%2A> -Methode für <xref:System.Windows.Threading.Dispatcher> den <xref:System.Windows.Controls.Button> wird aufgerufen, um den Zugriff auf den Thread zu überprüfen.  
  
 Wenn der aufrufenden Thread Zugriff auf das <xref:System.Windows.Threading.Dispatcher>-Element <xref:System.Windows.Controls.Button> hat, wird das aktualisiert, indem nur auf <xref:System.Windows.Controls.Button>die Member der zugegriffen wird.  
  
 Wenn der aufrufende Thread keinen Zugriff hat, wird <xref:System.InvalidOperationException> eine ausgelöst.  In diesem Beispiel wird die-Ausnahme abgefangen und ein Delegat, <xref:System.Windows.Controls.Button> der einen als Argument annimmt, <xref:System.Windows.Threading.Dispatcher> auf die <xref:System.Windows.Controls.Button>der-Klasse von übertragen.  Dadurch <xref:System.Windows.Threading.Dispatcher> wird das <xref:System.Windows.Controls.Button>aktualisiert.  
  
 [!code-csharp[DispatcherAccessSample#DispatcherAccessVerifyAccess](~/samples/snippets/csharp/VS_Snippets_Wpf/DispatcherAccessSample/CSharp/Window1.xaml.cs#dispatcheraccessverifyaccess)]
 [!code-vb[DispatcherAccessSample#DispatcherAccessVerifyAccess](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DispatcherAccessSample/visualbasic/window1.xaml.vb#dispatcheraccessverifyaccess)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der aufrufende Thread kann nicht auf diesen <see cref="T:System.Windows.Threading.Dispatcher" /> zugreifen.</exception>
        <altmember cref="M:System.Windows.Threading.Dispatcher.CheckAccess" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Yield">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt ein Awaitable-Objekt, welches ansynchron das Steuerelement an den aktuellen Verteiler zurückgibt und dem Verteiler die Gelegenheit gibt, andere Ereignisse zu verarbeiten.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Yield">
      <MemberSignature Language="C#" Value="public static System.Windows.Threading.DispatcherPriorityAwaitable Yield ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.Threading.DispatcherPriorityAwaitable Yield() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Yield" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Yield () As DispatcherPriorityAwaitable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Threading::DispatcherPriorityAwaitable Yield();" />
      <MemberSignature Language="F#" Value="static member Yield : unit -&gt; System.Windows.Threading.DispatcherPriorityAwaitable" Usage="System.Windows.Threading.Dispatcher.Yield " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherPriorityAwaitable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt ein Awaitable-Objekt, welches ansynchron das Steuerelement an den aktuellen Verteiler zurückgibt und dem Verteiler die Gelegenheit gibt, andere Ereignisse zu verarbeiten.</summary>
        <returns>Ein awaitable-Objekt, das asynchron dem aktuellen Verteiler Steuerelemente zurückgibt und dem Verteiler die Gelegenheit gibt, andere Ereignisse zu verarbeiten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode bietet Ihnen die Möglichkeit, die Ausführungs Steuerung vorübergehend für den aktuellen Verteiler freizugeben, damit andere Aufgaben ausgeführt werden können, z. b. andere Ereignisse verarbeiten. Verwenden Sie `await`den Operator `Await` , oder in Visual Basic, Operator für den Rückgabewert, um die Steuerung an den aktuellen Verteiler zurückzugeben. Verwenden Sie diese Methode, wenn Sie Ihrer APP die Möglichkeit einräumen möchten, Ereignisse zu verarbeiten, während Ihre APP viel Arbeit im UI-Thread leistet. Beispielsweise können Sie diese Methode in einer Schleife mit langer Laufzeit verwenden, die ein-Steuerelement aktualisiert.  
  
 Diese Methode entspricht dem Aufrufen der- <xref:System.Windows.Threading.Dispatcher.Yield%28System.Windows.Threading.DispatcherPriority%29> Methode und der <xref:System.Windows.Threading.DispatcherPriority.Background?displayProperty=nameWithType>Übergabe von.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Yield">
      <MemberSignature Language="C#" Value="public static System.Windows.Threading.DispatcherPriorityAwaitable Yield (System.Windows.Threading.DispatcherPriority priority);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.Threading.DispatcherPriorityAwaitable Yield(valuetype System.Windows.Threading.DispatcherPriority priority) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Yield(System.Windows.Threading.DispatcherPriority)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Yield (priority As DispatcherPriority) As DispatcherPriorityAwaitable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Threading::DispatcherPriorityAwaitable Yield(System::Windows::Threading::DispatcherPriority priority);" />
      <MemberSignature Language="F#" Value="static member Yield : System.Windows.Threading.DispatcherPriority -&gt; System.Windows.Threading.DispatcherPriorityAwaitable" Usage="System.Windows.Threading.Dispatcher.Yield priority" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherPriorityAwaitable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="priority">Die Priorität, mit der die Fortsetzung geplant werden soll.</param>
        <summary>Erstellt ein Awaitable-Objekt, welches ansynchron das Steuerelement an den aktuellen Verteiler zurückgibt und dem Verteiler die Gelegenheit gibt, andere Ereignisse zu verarbeiten.  Die Arbeit, welche auftritt, wenn das Steuerelement an den Code zurückgibt, der auf das Ergebnis dieser Methode wartet, die mit der angegebenen Priorität geplant wurde.</summary>
        <returns>Ein awaitable-Objekt, das asynchron dem aktuellen Verteiler Steuerelemente zurückgibt und dem Verteiler die Gelegenheit gibt, andere Ereignisse zu verarbeiten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode bietet Ihnen die Möglichkeit, die Ausführungs Steuerung vorübergehend für den aktuellen Verteiler freizugeben, damit andere Aufgaben ausgeführt werden können, z. b. andere Ereignisse verarbeiten. Verwenden Sie `await`den Operator `Await` , oder in Visual Basic, Operator für den Rückgabewert, um die Steuerung an den aktuellen Verteiler zurückzugeben. Verwenden Sie diese Methode, wenn Sie Ihrer APP die Möglichkeit einräumen möchten, Ereignisse zu verarbeiten, während Ihre APP viel Arbeit im UI-Thread leistet. Beispielsweise können Sie diese Methode in einer Schleife mit langer Laufzeit verwenden, die ein-Steuerelement aktualisiert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
