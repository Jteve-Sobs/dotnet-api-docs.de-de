<Type Name="Dispatcher" FullName="System.Windows.Threading.Dispatcher">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="3d486d574a6809448fc2fa2979413fc2f42880f3" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52199918" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Dispatcher" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed Dispatcher extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Threading.Dispatcher" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Dispatcher" />
  <TypeSignature Language="C++ CLI" Value="public ref class Dispatcher sealed" />
  <TypeSignature Language="F#" Value="type Dispatcher = class" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Stellt Dienste zum Verwalten der Warteschlange von Arbeitsaufgaben für einen Thread bereit.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Threading.Dispatcher> eine Priorität versehenen Warteschlange von Arbeitsaufgaben für einen bestimmten Thread verwaltet.  
  
 Bei der eine <xref:System.Windows.Threading.Dispatcher> wird erstellt in einem Thread, es wird nur <xref:System.Windows.Threading.Dispatcher> , die können den Thread zugeordnet werden. selbst wenn der <xref:System.Windows.Threading.Dispatcher> wird heruntergefahren.  
  
 Wenn Sie versuchen, erhalten die <xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A> für den aktuellen Thread und einen <xref:System.Windows.Threading.Dispatcher> ist nicht mit dem Thread verknüpft eine <xref:System.Windows.Threading.Dispatcher> erstellt werden. Ein <xref:System.Windows.Threading.Dispatcher> wird auch erstellt, bei der Erstellung einer <xref:System.Windows.Threading.DispatcherObject>. Bei der Erstellung einer <xref:System.Windows.Threading.Dispatcher> in einem Hintergrundthread, achten Sie darauf, den Verteiler herunterzufahren, vor dem Beenden des Threads.  
  
 Wenn eine <xref:System.Windows.Threading.Dispatcher> wird beendet, es kann nicht neu gestartet werden.  
  
 In [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], <xref:System.Windows.Threading.DispatcherObject> kann nur zugegriffen werden, indem die <xref:System.Windows.Threading.Dispatcher> es zugeordnet ist.  Z. B. ein Hintergrundthread kann nicht aktualisiert werden der Inhalt des eine <xref:System.Windows.Controls.Button> zugeordnete der <xref:System.Windows.Threading.Dispatcher> auf die [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] Thread.  In der Reihenfolge für den Hintergrundthread den Zugriff auf die <xref:System.Windows.Controls.ContentControl.Content%2A> Eigenschaft der <xref:System.Windows.Controls.Button>, der Hintergrundthread die Verarbeitung zur delegieren muss die <xref:System.Windows.Threading.Dispatcher> zugeordnet der [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] Thread.  Dies wird erreicht, indem Sie entweder <xref:System.Windows.Threading.Dispatcher.Invoke%2A> oder <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>. <xref:System.Windows.Threading.Dispatcher.Invoke%2A> ist synchron und <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> ist asynchron.  Der Vorgang wurde an die Warteschlange die <xref:System.Windows.Threading.Dispatcher> an der angegebenen <xref:System.Windows.Threading.DispatcherPriority>.  
  
 Wenn <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> aufgerufen wird, auf eine <xref:System.Windows.Threading.Dispatcher> , die heruntergefahren wurde, der Status-Eigenschaft des zurückgegebenen <xref:System.Windows.Threading.DispatcherOperation> nastaven NA hodnotu <xref:System.Windows.Threading.DispatcherOperationStatus.Aborted>.  
  
 Alle Methoden auf <xref:System.Windows.Threading.Dispatcher>, mit Ausnahme von <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A>, Freethreadobjekten.  
  
 Objekte, die abgeleitet <xref:System.Windows.Threading.DispatcherObject> Threadaffinität.  
  
 Objekte, die abgeleitet <xref:System.Windows.Freezable> sind Freethread-Wenn sie fixiert werden.  Weitere Informationen finden Sie unter der [Übersicht über Freezable-Objekte](~/docs/framework/wpf/advanced/freezable-objects-overview.md).  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie einen Vorgang auf Platzieren einer <xref:System.Windows.Threading.Dispatcher>.  Der vollständige Quellcode dieses Beispiels, finden Sie unter [Single-Threaded Application with Long-Running Calculation Sample](https://go.microsoft.com/fwlink/?LinkID=160038).  
  
 Zuerst wird ein Delegat erstellt, die keine Argumente akzeptiert.  
  
 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberInit](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberinit)] 
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberInit](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberinit)]   
  
 Als Nächstes <xref:System.Windows.Threading.Dispatcher.BeginInvoke%28System.Windows.Threading.DispatcherPriority%2CSystem.Delegate%29> aufgerufen wird.  Dieser Aufruf <xref:System.Windows.Threading.Dispatcher.BeginInvoke%28System.Windows.Threading.DispatcherPriority%2CSystem.Delegate%29> akzeptiert zwei Parameter: die Priorität, die auf <xref:System.Windows.Threading.DispatcherPriority.Normal?displayProperty=nameWithType>, und der Rückruf, der durch eine Instanz des Delegaten übergeben wird `NextPrimeDelegate`.  
  
 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberBeginInvoke](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberbegininvoke)] 
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberBeginInvoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberbegininvoke)]   
  
 ]]></format>
    </remarks>
    <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=160038">Singlethread-Anwendung mit Long-Running Calculation Sample</related>
  </Docs>
  <Members>
    <MemberGroup MemberName="BeginInvoke">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Führt eine Delegaten asynchron auf dem Thread aus, dem der <see cref="T:System.Windows.Threading.Dispatcher" /> zugeordnet ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], nur der Thread, der erstellt eine <xref:System.Windows.Threading.DispatcherObject> können auf dieses Objekt zugreifen.  Z. B. ein Hintergrundthread, der aus dem Hauptbenutzeroberflächen-Thread, deaktivieren erstellt wurde kann nicht aktualisiert werden den Inhalt einer <xref:System.Windows.Controls.Button> , die im UI-Thread erstellt wurde.  In der Hintergrundthread die Content-Eigenschaft der Zugriff auf die <xref:System.Windows.Controls.Button>, der Hintergrundthread die Verarbeitung zur delegieren muss die <xref:System.Windows.Threading.Dispatcher> im UI-Thread zugeordnet.  Dies wird erreicht, indem Sie entweder <xref:System.Windows.Threading.Dispatcher.Invoke%2A> oder <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> ist synchron und <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> ist asynchron.  Der Vorgang wurde an die Ereigniswarteschlange von der <xref:System.Windows.Threading.Dispatcher> an der angegebenen <xref:System.Windows.Threading.DispatcherPriority>.  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> ist asynchron. aus diesem Grund sofort die steuerelementrückgabe an das aufrufende Objekt nach dem sie aufgerufen wird.  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> Gibt eine <xref:System.Windows.Threading.DispatcherOperation> -Objekt, das verwendet werden kann, um mit dem Delegaten zu interagieren, wenn der Delegat in der Warteschlange befindet.  
  
 Die <xref:System.Windows.Threading.DispatcherOperation> zurückgegebenes Objekt <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> kann auf verschiedene Weise für die Interaktion mit den angegebenen Delegaten verwendet werden:  
  
-   Ändern der <xref:System.Windows.Threading.DispatcherPriority> des Delegaten wie ausstehende Ausführung in der Ereigniswarteschlange abgerufen.  
  
-   Entfernen den Delegaten aus der Ereigniswarteschlange.  
  
-   Es wird darauf gewartet, dass der Delegat, der zurückgegeben.  
  
-   Abrufen des Werts, die der Delegat, nachdem sie zurückgegeben ausgeführt wird.  
  
 Wenn mehrere <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> Aufrufe gleichzeitig <xref:System.Windows.Threading.DispatcherPriority>, werden sie in der Reihenfolge der Aufrufe wurden ausgeführt.  
  
 Wenn <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> aufgerufen wird, auf eine <xref:System.Windows.Threading.Dispatcher> , die heruntergefahren wurde, der Status-Eigenschaft des zurückgegebenen <xref:System.Windows.Threading.DispatcherOperation> nastaven NA hodnotu <xref:System.Windows.Threading.DispatcherOperationStatus.Aborted>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginInvoke">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation BeginInvoke (Delegate method, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation BeginInvoke(class System.Delegate method, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.BeginInvoke(System.Delegate,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginInvoke (method As Delegate, ParamArray args As Object()) As DispatcherOperation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Threading::DispatcherOperation ^ BeginInvoke(Delegate ^ method, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.BeginInvoke : Delegate * obj[] -&gt; System.Windows.Threading.DispatcherOperation" Usage="dispatcher.BeginInvoke (method, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method">Der Delegat für eine Methode, die in <paramref name="args" /> angegebene Parameter akzeptiert und in die <see cref="T:System.Windows.Threading.Dispatcher" />-Ereigniswarteschlange gestellt wird.</param>
        <param name="args">Ein Array von Objekten, die als Argumente an die angegebene Methode übergeben werden sollen. Kann <see langword="null" /> sein.</param>
        <summary>Führt den angegebenen Delegaten asynchron mit den angegebenen Argumenten für den Thread aus, für den der <see cref="T:System.Windows.Threading.Dispatcher" /> erstellt wurde.</summary>
        <returns>Ein Objekt, das unmittelbar nach dem Aufruf von <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" /> zurückgegeben wird und für die Interaktion mit dem Delegaten verwendet werden kann, während im Delegaten die Ausführung einer Aufgabe in der Warteschlange steht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Threading.DispatcherOperation> zurückgegebenes Objekt <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> kann auf verschiedene Weise für die Interaktion mit den angegebenen Delegaten verwendet werden:  
  
-   Ändern der <xref:System.Windows.Threading.DispatcherPriority> des Delegaten wie ausstehende Ausführung in der Ereigniswarteschlange abgerufen.  
  
-   Entfernen den Delegaten aus der Ereigniswarteschlange.  
  
-   Es wird darauf gewartet, dass der Delegat, der zurückgegeben.  
  
-   Abrufen des Werts, die der Delegat, nachdem sie zurückgegeben ausgeführt wird.  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> ist asynchron. aus diesem Grund sofort die steuerelementrückgabe an das aufrufende Objekt nach dem sie aufgerufen wird.  
  
 In [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], nur der Thread, der erstellt eine <xref:System.Windows.Threading.DispatcherObject> können auf dieses Objekt zugreifen. Z. B. ein Hintergrundthread, der aus dem Hauptbenutzeroberflächen-Thread, deaktivieren erstellt wurde kann nicht aktualisiert werden den Inhalt einer <xref:System.Windows.Controls.Button> , die im UI-Thread erstellt wurde. In der Hintergrundthread die Content-Eigenschaft der Zugriff auf die <xref:System.Windows.Controls.Button>, der Hintergrundthread die Verarbeitung zur delegieren muss die <xref:System.Windows.Threading.Dispatcher> im UI-Thread zugeordnet. Dies wird erreicht, indem Sie entweder <xref:System.Windows.Threading.Dispatcher.Invoke%2A> oder <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>. <xref:System.Windows.Threading.Dispatcher.Invoke%2A> ist synchron und <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> ist asynchron. Der Vorgang wurde an die Ereigniswarteschlange von der <xref:System.Windows.Threading.Dispatcher> an der angegebenen <xref:System.Windows.Threading.DispatcherPriority>.  
  
 Wenn <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> aufgerufen wird, auf eine <xref:System.Windows.Threading.Dispatcher> , die heruntergefahren wurde, der Status-Eigenschaft des zurückgegebenen <xref:System.Windows.Threading.DispatcherOperation> nastaven NA hodnotu <xref:System.Windows.Threading.DispatcherOperationStatus.Aborted>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginInvoke">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation BeginInvoke (System.Windows.Threading.DispatcherPriority priority, Delegate method);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation BeginInvoke(valuetype System.Windows.Threading.DispatcherPriority priority, class System.Delegate method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginInvoke (priority As DispatcherPriority, method As Delegate) As DispatcherOperation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Threading::DispatcherOperation ^ BeginInvoke(System::Windows::Threading::DispatcherPriority priority, Delegate ^ method);" />
      <MemberSignature Language="F#" Value="member this.BeginInvoke : System.Windows.Threading.DispatcherPriority * Delegate -&gt; System.Windows.Threading.DispatcherOperation" Usage="dispatcher.BeginInvoke (priority, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="method" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="priority">Die Priorität, relativ zu den anderen anstehenden Operationen in der <see cref="T:System.Windows.Threading.Dispatcher" />-Ereigniswarteschlange, mit der die angegebene Methode aufgerufen wird.</param>
        <param name="method">Der Delegat zu einer Methode, die keine Argumente erwartet und in die <see cref="T:System.Windows.Threading.Dispatcher" />-Ereigniswarteschlange gestellt wird.</param>
        <summary>Führt den angegebenen Delegaten asynchron mit der angegebenen Priorität auf dem Thread aus, dem der <see cref="T:System.Windows.Threading.Dispatcher" /> zugeordnet ist.</summary>
        <returns>Ein Objekt, das unmittelbar nach dem Aufruf von <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" /> zurückgegeben wird und für die Interaktion mit dem Delegaten verwendet werden kann, während im Delegaten die Ausführung einer Aufgabe in der Warteschlange steht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn mehrere <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> Aufrufe gleichzeitig <xref:System.Windows.Threading.DispatcherPriority>, werden sie in der Reihenfolge der Aufrufe wurden ausgeführt.  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> Gibt eine <xref:System.Windows.Threading.DispatcherOperation> -Objekt, das verwendet werden kann, um mit dem Delegaten zu interagieren, wenn der Delegat in der Warteschlange befindet.  
  
 Die <xref:System.Windows.Threading.DispatcherOperation> zurückgegebenes Objekt <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> kann auf verschiedene Weise für die Interaktion mit den angegebenen Delegaten verwendet werden:  
  
-   Ändern der <xref:System.Windows.Threading.DispatcherPriority> des Delegaten wie ausstehende Ausführung in der Ereigniswarteschlange abgerufen.  
  
-   Entfernen den Delegaten aus der Ereigniswarteschlange.  
  
-   Es wird darauf gewartet, dass der Delegat, der zurückgegeben.  
  
-   Abrufen des Werts, die der Delegat, nachdem sie zurückgegeben ausgeführt wird.  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> ist asynchron. aus diesem Grund sofort die steuerelementrückgabe an das aufrufende Objekt nach dem sie aufgerufen wird.  
  
 In [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], nur der Thread, der erstellt eine <xref:System.Windows.Threading.DispatcherObject> können auf dieses Objekt zugreifen.  Z. B. ein Hintergrundthread, der aus dem Hauptbenutzeroberflächen-Thread, deaktivieren erstellt wurde kann nicht aktualisiert werden den Inhalt einer <xref:System.Windows.Controls.Button> , die im UI-Thread erstellt wurde.  In der Hintergrundthread die Content-Eigenschaft der Zugriff auf die <xref:System.Windows.Controls.Button>, der Hintergrundthread die Verarbeitung zur delegieren muss die <xref:System.Windows.Threading.Dispatcher> im UI-Thread zugeordnet.  Dies wird erreicht, indem Sie entweder <xref:System.Windows.Threading.Dispatcher.Invoke%2A> oder <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> ist synchron und <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> ist asynchron.  Der Vorgang wurde an die Ereigniswarteschlange von der <xref:System.Windows.Threading.Dispatcher> an der angegebenen <xref:System.Windows.Threading.DispatcherPriority>.  
  
 Wenn <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> aufgerufen wird, auf eine <xref:System.Windows.Threading.Dispatcher> , die heruntergefahren wurde, der Status-Eigenschaft des zurückgegebenen <xref:System.Windows.Threading.DispatcherOperation> nastaven NA hodnotu <xref:System.Windows.Threading.DispatcherOperationStatus.Aborted>.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie einen Vorgang auf Platzieren einer <xref:System.Windows.Threading.Dispatcher>.  Der vollständige Quellcode dieses Beispiels, finden Sie unter [Single-Threaded Application with Long-Running Calculation Sample](https://go.microsoft.com/fwlink/?LinkID=160038).  
  
 Zuerst wird ein Delegat erstellt, die keine Argumente akzeptiert.  
  
 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberInit](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberinit)] 
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberInit](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberinit)]   
  
 Als Nächstes <xref:System.Windows.Threading.Dispatcher.BeginInvoke%28System.Windows.Threading.DispatcherPriority%2CSystem.Delegate%29> aufgerufen wird.  Da jede <xref:System.Windows.Threading.DispatcherObject> verfügt über eine Eigenschaft, die zurückgibt der <xref:System.Windows.Threading.Dispatcher> zugeordnet ist, den gewünschten <xref:System.Windows.Threading.Dispatcher> durch Abfragen des der <xref:System.Windows.Threading.DispatcherObject>, in diesem Fall eine <xref:System.Windows.Controls.Button> mit dem Namen `startStopButton`.   Der Aufruf von <xref:System.Windows.Threading.Dispatcher.BeginInvoke%28System.Windows.Threading.DispatcherPriority%2CSystem.Delegate%29> akzeptiert zwei Parameter: die Priorität, die auf <xref:System.Windows.Threading.DispatcherPriority.Normal?displayProperty=nameWithType>, und der Rückruf, der durch eine Instanz des Delegaten übergeben wird `NextPrimeDelegate`.  
  
 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberBeginInvoke](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberbegininvoke)] 
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberBeginInvoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberbegininvoke)]   
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="priority" /> ist kein gültiger <see cref="T:System.Windows.Threading.DispatcherPriority" />.</exception>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=160038">Singlethread-Anwendung mit Long-Running Calculation Sample</related>
      </Docs>
    </Member>
    <Member MemberName="BeginInvoke">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation BeginInvoke (Delegate method, System.Windows.Threading.DispatcherPriority priority, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation BeginInvoke(class System.Delegate method, valuetype System.Windows.Threading.DispatcherPriority priority, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.BeginInvoke(System.Delegate,System.Windows.Threading.DispatcherPriority,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginInvoke (method As Delegate, priority As DispatcherPriority, ParamArray args As Object()) As DispatcherOperation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Threading::DispatcherOperation ^ BeginInvoke(Delegate ^ method, System::Windows::Threading::DispatcherPriority priority, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.BeginInvoke : Delegate * System.Windows.Threading.DispatcherPriority * obj[] -&gt; System.Windows.Threading.DispatcherOperation" Usage="dispatcher.BeginInvoke (method, priority, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method">Der Delegat für eine Methode, die in <paramref name="args" /> angegebene Parameter akzeptiert und in die <see cref="T:System.Windows.Threading.Dispatcher" />-Ereigniswarteschlange gestellt wird.</param>
        <param name="priority">Die Priorität, relativ zu den anderen anstehenden Operationen in der <see cref="T:System.Windows.Threading.Dispatcher" />-Ereigniswarteschlange, mit der die angegebene Methode aufgerufen wird.</param>
        <param name="args">Ein Array von Objekten, die als Argumente an die angegebene Methode übergeben werden sollen. Kann <see langword="null" /> sein.</param>
        <summary>Führt den angegebenen Delegaten asynchron mit den angegebenen Argumenten und der angegebenen Priorität für den Thread aus, für den der <see cref="T:System.Windows.Threading.Dispatcher" /> erstellt wurde.</summary>
        <returns>Ein Objekt, das unmittelbar nach dem Aufruf von <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" /> zurückgegeben wird und für die Interaktion mit dem Delegaten verwendet werden kann, während im Delegaten die Ausführung einer Aufgabe in der Warteschlange steht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Threading.DispatcherOperation> zurückgegebenes Objekt <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> kann auf verschiedene Weise für die Interaktion mit den angegebenen Delegaten verwendet werden:  
  
-   Ändern der <xref:System.Windows.Threading.DispatcherPriority> des Delegaten wie ausstehende Ausführung in der Ereigniswarteschlange abgerufen.  
  
-   Entfernen den Delegaten aus der Ereigniswarteschlange.  
  
-   Es wird darauf gewartet, dass der Delegat, der zurückgegeben.  
  
-   Abrufen des Werts, die der Delegat, nachdem sie zurückgegeben ausgeführt wird.  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> ist asynchron. aus diesem Grund sofort die steuerelementrückgabe an das aufrufende Objekt nach dem sie aufgerufen wird.  
  
 In [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], nur der Thread, der erstellt eine <xref:System.Windows.Threading.DispatcherObject> können auf dieses Objekt zugreifen. Z. B. ein Hintergrundthread, der aus dem Hauptbenutzeroberflächen-Thread, deaktivieren erstellt wurde kann nicht aktualisiert werden den Inhalt einer <xref:System.Windows.Controls.Button> , die im UI-Thread erstellt wurde. In der Hintergrundthread die Content-Eigenschaft der Zugriff auf die <xref:System.Windows.Controls.Button>, der Hintergrundthread die Verarbeitung zur delegieren muss die <xref:System.Windows.Threading.Dispatcher> im UI-Thread zugeordnet. Dies wird erreicht, indem Sie entweder <xref:System.Windows.Threading.Dispatcher.Invoke%2A> oder <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>. <xref:System.Windows.Threading.Dispatcher.Invoke%2A> ist synchron und <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> ist asynchron. Der Vorgang wurde an die Ereigniswarteschlange von der <xref:System.Windows.Threading.Dispatcher> an der angegebenen <xref:System.Windows.Threading.DispatcherPriority>.  
  
 Wenn <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> aufgerufen wird, auf eine <xref:System.Windows.Threading.Dispatcher> , die heruntergefahren wurde, der Status-Eigenschaft des zurückgegebenen <xref:System.Windows.Threading.DispatcherOperation> nastaven NA hodnotu <xref:System.Windows.Threading.DispatcherOperationStatus.Aborted>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginInvoke">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation BeginInvoke (System.Windows.Threading.DispatcherPriority priority, Delegate method, object arg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation BeginInvoke(valuetype System.Windows.Threading.DispatcherPriority priority, class System.Delegate method, object arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginInvoke (priority As DispatcherPriority, method As Delegate, arg As Object) As DispatcherOperation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Threading::DispatcherOperation ^ BeginInvoke(System::Windows::Threading::DispatcherPriority priority, Delegate ^ method, System::Object ^ arg);" />
      <MemberSignature Language="F#" Value="member this.BeginInvoke : System.Windows.Threading.DispatcherPriority * Delegate * obj -&gt; System.Windows.Threading.DispatcherOperation" Usage="dispatcher.BeginInvoke (priority, method, arg)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="arg" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="priority">Die Priorität, relativ zu den anderen anstehenden Operationen in der <see cref="T:System.Windows.Threading.Dispatcher" />-Ereigniswarteschlange, mit der die angegebene Methode aufgerufen wird.</param>
        <param name="method">Ein Delegat zu einer Methode, die ein Argument erwartet und in die <see cref="T:System.Windows.Threading.Dispatcher" />-Ereigniswarteschlange gestellt wird.</param>
        <param name="arg">Das Objekt, das als Argument an die angegebene Methode übergeben wird.</param>
        <summary>Führt den angegebenen Delegaten asynchron mit der angegebenen Priorität und dem angegebenen Argument auf dem Thread aus, dem der <see cref="T:System.Windows.Threading.Dispatcher" /> zugeordnet ist.</summary>
        <returns>Ein Objekt, das unmittelbar nach dem Aufruf von <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" /> zurückgegeben wird und für die Interaktion mit dem Delegaten verwendet werden kann, während im Delegaten die Ausführung einer Aufgabe in der Warteschlange steht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Arg` kann `null` , wenn keine Argumente erforderlich sind.  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> Gibt eine <xref:System.Windows.Threading.DispatcherOperation> -Objekt, das verwendet werden kann, um mit dem Delegaten zu interagieren, wenn der Delegat in der Warteschlange befindet.  
  
 Die <xref:System.Windows.Threading.DispatcherOperation> zurückgegebenes Objekt <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> kann auf verschiedene Weise für die Interaktion mit den angegebenen Delegaten verwendet werden:  
  
-   Ändern der <xref:System.Windows.Threading.DispatcherPriority> des Delegaten wie ausstehende Ausführung in der Ereigniswarteschlange abgerufen.  
  
-   Entfernen den Delegaten aus der Ereigniswarteschlange.  
  
-   Es wird darauf gewartet, dass der Delegat, der zurückgegeben.  
  
-   Abrufen des Werts, die der Delegat, nachdem sie zurückgegeben ausgeführt wird.  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> ist asynchron. aus diesem Grund sofort die steuerelementrückgabe an das aufrufende Objekt nach dem sie aufgerufen wird.  
  
 In [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], nur der Thread, der erstellt eine <xref:System.Windows.Threading.DispatcherObject> können auf dieses Objekt zugreifen.  Z. B. ein Hintergrundthread, der aus dem Hauptbenutzeroberflächen-Thread, deaktivieren erstellt wurde kann nicht aktualisiert werden den Inhalt einer <xref:System.Windows.Controls.Button> , die im UI-Thread erstellt wurde.  In der Hintergrundthread die Content-Eigenschaft der Zugriff auf die <xref:System.Windows.Controls.Button>, der Hintergrundthread die Verarbeitung zur delegieren muss die <xref:System.Windows.Threading.Dispatcher> im UI-Thread zugeordnet.  Dies wird erreicht, indem Sie entweder <xref:System.Windows.Threading.Dispatcher.Invoke%2A> oder <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> ist synchron und <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> ist asynchron.  Der Vorgang wurde an die Ereigniswarteschlange von der <xref:System.Windows.Threading.Dispatcher> an der angegebenen <xref:System.Windows.Threading.DispatcherPriority>.  
  
 Wenn mehrere <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> Aufrufe gleichzeitig <xref:System.Windows.Threading.DispatcherPriority>, werden sie in der Reihenfolge der Aufrufe wurden ausgeführt.  
  
 Wenn <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> aufgerufen wird, auf eine <xref:System.Windows.Threading.Dispatcher> , die heruntergefahren wurde, der Status-Eigenschaft des zurückgegebenen <xref:System.Windows.Threading.DispatcherOperation> nastaven NA hodnotu <xref:System.Windows.Threading.DispatcherOperationStatus.Aborted>.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie einen Vorgang auf Platzieren einer <xref:System.Windows.Threading.Dispatcher>.  
  
 Zuerst wird ein Delegat erstellt, die ein Argument, in diesem Fall eine Zeichenfolge akzeptiert.  
  
 [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherDelegates](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherdelegates)]
 [!code-vb[ThreadingWeatherForecast#ThreadingWeatherDelegates](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherdelegates)]  
  
 Als Nächstes <xref:System.Windows.Threading.Dispatcher.BeginInvoke%28System.Windows.Threading.DispatcherPriority%2CSystem.Delegate%2CSystem.Object%29> aufgerufen wird.  Da jede <xref:System.Windows.Threading.DispatcherObject> verfügt über eine Eigenschaft, die zurückgibt der <xref:System.Windows.Threading.Dispatcher> zugeordnet ist, den gewünschten <xref:System.Windows.Threading.Dispatcher> durch Abfragen des der <xref:System.Windows.Threading.DispatcherObject>, in diesem Fall eine <xref:System.Windows.Controls.Grid> mit dem Namen `tomorrowsWeather`. Der Aufruf von <xref:System.Windows.Threading.Dispatcher.BeginInvoke%28System.Windows.Threading.DispatcherPriority%2CSystem.Delegate%2CSystem.Object%29> akzeptiert drei Parameter: die Priorität, die auf <xref:System.Windows.Threading.DispatcherPriority.Normal?displayProperty=nameWithType>; der Rückruf, der durch eine Instanz des Delegaten übergebenen `OneArgDelegate`; und eine Zeichenfolge, die mit dem Namen `weather`, dies ist das Argument für den Rückruf.  
  
 [!code-csharp[threadingweatherforecast#ThreadingWeatherDispatcherOneArge](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherdispatcheronearge)]
 [!code-vb[threadingweatherforecast#ThreadingWeatherDispatcherOneArge](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherdispatcheronearge)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="priority" /> ist kein gültiger <see cref="T:System.Windows.Threading.DispatcherPriority" />.</exception>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=160038">Singlethread-Anwendung mit Long-Running Calculation Sample</related>
      </Docs>
    </Member>
    <Member MemberName="BeginInvoke">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation BeginInvoke (System.Windows.Threading.DispatcherPriority priority, Delegate method, object arg, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation BeginInvoke(valuetype System.Windows.Threading.DispatcherPriority priority, class System.Delegate method, object arg, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginInvoke (priority As DispatcherPriority, method As Delegate, arg As Object, ParamArray args As Object()) As DispatcherOperation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Threading::DispatcherOperation ^ BeginInvoke(System::Windows::Threading::DispatcherPriority priority, Delegate ^ method, System::Object ^ arg, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.BeginInvoke : System.Windows.Threading.DispatcherPriority * Delegate * obj * obj[] -&gt; System.Windows.Threading.DispatcherOperation" Usage="dispatcher.BeginInvoke (priority, method, arg, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="arg" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="priority">Die Priorität, relativ zu den anderen anstehenden Operationen in der <see cref="T:System.Windows.Threading.Dispatcher" />-Ereigniswarteschlange, mit der die angegebene Methode aufgerufen wird.</param>
        <param name="method">Ein Delegat zu einer Methode, die mehrere Argumente erwartet und in die <see cref="T:System.Windows.Threading.Dispatcher" />-Ereigniswarteschlange gestellt wird.</param>
        <param name="arg">Das Objekt, das als Argument an die angegebene Methode übergeben wird.</param>
        <param name="args">Ein Array von Objekten, die als Argumente an die angegebene Methode übergeben werden sollen.</param>
        <summary>Führt den angegebenen Delegaten asynchron mit der angegebenen Priorität und dem angegebenen Argumentarray auf dem Thread aus, dem der <see cref="T:System.Windows.Threading.Dispatcher" /> zugeordnet ist.</summary>
        <returns>Ein Objekt, das unmittelbar nach dem Aufruf von <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" /> zurückgegeben wird und für die Interaktion mit dem Delegaten verwendet werden kann, während im Delegaten die Ausführung einer Aufgabe in der <see cref="T:System.Windows.Threading.Dispatcher" />-Warteschlange steht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `arg` -Parameters auch `null` , wenn keine Argumente erforderlich sind.  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> Gibt eine <xref:System.Windows.Threading.DispatcherOperation> -Objekt, das verwendet werden kann, um mit dem Delegaten zu interagieren, wenn der Delegat in der Warteschlange befindet.  
  
 Die <xref:System.Windows.Threading.DispatcherOperation> zurückgegebenes Objekt <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> kann auf verschiedene Weise für die Interaktion mit den angegebenen Delegaten verwendet werden:  
  
-   Ändern der <xref:System.Windows.Threading.DispatcherPriority> des Delegaten wie ausstehende Ausführung in der Ereigniswarteschlange abgerufen.  
  
-   Entfernen den Delegaten aus der Ereigniswarteschlange.  
  
-   Es wird darauf gewartet, dass der Delegat, der zurückgegeben.  
  
-   Abrufen des Werts, die der Delegat, nachdem sie zurückgegeben ausgeführt wird.  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> ist asynchron. aus diesem Grund sofort die steuerelementrückgabe an das aufrufende Objekt nach dem sie aufgerufen wird.  
  
 In [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], nur der Thread, der erstellt eine <xref:System.Windows.Threading.DispatcherObject> können auf dieses Objekt zugreifen.  Z. B. ein Hintergrundthread, der aus dem Hauptbenutzeroberflächen-Thread, deaktivieren erstellt wurde kann nicht aktualisiert werden den Inhalt einer <xref:System.Windows.Controls.Button> , die im UI-Thread erstellt wurde.  In der Hintergrundthread die Content-Eigenschaft der Zugriff auf die <xref:System.Windows.Controls.Button>, der Hintergrundthread die Verarbeitung zur delegieren muss die <xref:System.Windows.Threading.Dispatcher> im UI-Thread zugeordnet.  Dies wird erreicht, indem Sie entweder <xref:System.Windows.Threading.Dispatcher.Invoke%2A> oder <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> ist synchron und <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> ist asynchron.  Der Vorgang wurde an die Ereigniswarteschlange von der <xref:System.Windows.Threading.Dispatcher> an der angegebenen <xref:System.Windows.Threading.DispatcherPriority>.  
  
 Wenn mehrere <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> Aufrufe gleichzeitig <xref:System.Windows.Threading.DispatcherPriority>, werden sie in der Reihenfolge der Aufrufe wurden ausgeführt.  
  
 Wenn <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> aufgerufen wird, auf eine <xref:System.Windows.Threading.Dispatcher> , die heruntergefahren wurde, der Status-Eigenschaft des zurückgegebenen <xref:System.Windows.Threading.DispatcherOperation> nastaven NA hodnotu <xref:System.Windows.Threading.DispatcherOperationStatus.Aborted>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <see cref="T:System.Windows.Threading.DispatcherPriority" /> ist keine gültige Priorität.</exception>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=160038">Singlethread-Anwendung mit Long-Running Calculation Sample</related>
      </Docs>
    </Member>
    <Member MemberName="BeginInvokeShutdown">
      <MemberSignature Language="C#" Value="public void BeginInvokeShutdown (System.Windows.Threading.DispatcherPriority priority);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginInvokeShutdown(valuetype System.Windows.Threading.DispatcherPriority priority) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.BeginInvokeShutdown(System.Windows.Threading.DispatcherPriority)" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInvokeShutdown (priority As DispatcherPriority)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginInvokeShutdown(System::Windows::Threading::DispatcherPriority priority);" />
      <MemberSignature Language="F#" Value="member this.BeginInvokeShutdown : System.Windows.Threading.DispatcherPriority -&gt; unit" Usage="dispatcher.BeginInvokeShutdown priority" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
      </Parameters>
      <Docs>
        <param name="priority">Die Priorität, bei der mit dem Beenden des Verteilers begonnen wird.</param>
        <summary>Initiiert ein asynchrones Beenden des <see cref="T:System.Windows.Threading.Dispatcher" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Threading.Dispatcher.BeginInvokeShutdown%2A> setzt uneingeschränkte Berechtigungen in der Benutzeroberfläche.  
  
 Wenn die <xref:System.Windows.Threading.Dispatcher> zum Herunterfahren beginnt die <xref:System.Windows.Threading.Dispatcher.ShutdownStarted> Ereignis wird ausgelöst, und <xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> nastaven NA hodnotu `true`.  
  
 Die <xref:System.Windows.Threading.Dispatcher> ist nicht vollständig heruntergefahren, bis die Ereigniswarteschlange entladen.  
  
 Wenn der Verteiler die Beendigung, die <xref:System.Windows.Threading.Dispatcher.ShutdownFinished> Ereignis wird ausgelöst, und die <xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A> -Eigenschaftensatz auf `true`.  
  
 Nachdem der Prozess des Herunterfahrens eingeleitet wurde, werden alle ausstehenden Arbeit Elemente in der Warteschlange abgebrochen.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">für den Verteiler beendet.  Zugeordnete Enumerationen:  <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CheckAccess">
      <MemberSignature Language="C#" Value="public bool CheckAccess ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CheckAccess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.CheckAccess" />
      <MemberSignature Language="VB.NET" Value="Public Function CheckAccess () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CheckAccess();" />
      <MemberSignature Language="F#" Value="member this.CheckAccess : unit -&gt; bool" Usage="dispatcher.CheckAccess " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Bestimmt, ob der aufrufende Thread diesem <see cref="T:System.Windows.Threading.Dispatcher" /> zugeordnet ist.</summary>
        <returns>
          <see langword="true" />, wenn der aufrufende Thread diesem <see cref="T:System.Windows.Threading.Dispatcher" /> zugeordnet ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nur die <xref:System.Windows.Threading.Dispatcher> , die eine <xref:System.Windows.Threading.DispatcherObject> wird erstellt, auf auf das Objekt zugreifen kann.  Verwendung <xref:System.Windows.Threading.Dispatcher.Invoke%2A> oder <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> auf das Objekt von einem anderen Thread zuzugreifen.  
  
 <xref:System.Windows.Threading.Dispatcher.CheckAccess%2A> kann von jedem Thread aufgerufen werden.  
  
 Der Unterschied zwischen <xref:System.Windows.Threading.Dispatcher.CheckAccess%2A> und <xref:System.Windows.Threading.Dispatcher.VerifyAccess%2A> ist <xref:System.Windows.Threading.Dispatcher.CheckAccess%2A> gibt einen booleschen Wert, der angibt, ob der aufrufende Thread den Zugriff auf die <xref:System.Windows.Threading.Dispatcher> und <xref:System.Windows.Threading.Dispatcher.VerifyAccess%2A> löst eine Ausnahme aus.  
  
   
  
## Examples  
 Im folgenden Beispiel wird <xref:System.Windows.Threading.Dispatcher.CheckAccess%2A> um zu bestimmen, ob ein Thread den Zugriff auf eine <xref:System.Windows.Controls.Button>.  Die <xref:System.Windows.Threading.Dispatcher.CheckAccess%2A> Methode für die <xref:System.Windows.Threading.Dispatcher> zugeordneten der <xref:System.Windows.Controls.Button> wird aufgerufen, um den Zugriff auf den Thread zu überprüfen.  Verfügt der aufrufende Thread den Zugriff auf die <xref:System.Windows.Threading.Dispatcher>, wird die <xref:System.Windows.Controls.Button> wird aktualisiert, indem Sie Zugriff auf die Member des der <xref:System.Windows.Controls.Button>ist, andernfalls ein Delegat, der erwartet eine <xref:System.Windows.Controls.Button> als Argument befindet sich auf die <xref:System.Windows.Threading.Dispatcher>.  Die <xref:System.Windows.Threading.Dispatcher> delegiert die Arbeit der Aktualisierung der <xref:System.Windows.Controls.Button>.  
  
 [!code-csharp[DispatcherAccessSample#DispatcherAccessCheckAccess](~/samples/snippets/csharp/VS_Snippets_Wpf/DispatcherAccessSample/CSharp/Window1.xaml.cs#dispatcheraccesscheckaccess)]
 [!code-vb[DispatcherAccessSample#DispatcherAccessCheckAccess](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DispatcherAccessSample/visualbasic/window1.xaml.vb#dispatcheraccesscheckaccess)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Threading.Dispatcher.VerifyAccess" />
      </Docs>
    </Member>
    <Member MemberName="CurrentDispatcher">
      <MemberSignature Language="C#" Value="public static System.Windows.Threading.Dispatcher CurrentDispatcher { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Threading.Dispatcher CurrentDispatcher" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Threading.Dispatcher.CurrentDispatcher" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentDispatcher As Dispatcher" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Threading::Dispatcher ^ CurrentDispatcher { System::Windows::Threading::Dispatcher ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentDispatcher : System.Windows.Threading.Dispatcher" Usage="System.Windows.Threading.Dispatcher.CurrentDispatcher" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.Dispatcher</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den <see cref="T:System.Windows.Threading.Dispatcher" /> für den derzeit ausgeführten Thread ab bzw. erstellt einen neuen, wenn dem Thread noch kein <see cref="T:System.Windows.Threading.Dispatcher" /> zugeordnet ist.</summary>
        <value>Der Verteiler, der dem aktuellen Thread zugeordnet ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn eine <xref:System.Windows.Threading.Dispatcher> ist nicht mit den aktuellen Thread verknüpft ein neues <xref:System.Windows.Threading.Dispatcher> erstellt werden.  Dies ist bei der <xref:System.Windows.Threading.Dispatcher.FromThread%2A>-Methode nicht der Fall.  <xref:System.Windows.Threading.Dispatcher.FromThread%2A> Gibt `null` besteht kein Verteiler den angegebenen Thread zugeordnet.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisableProcessing">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherProcessingDisabled DisableProcessing ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Threading.DispatcherProcessingDisabled DisableProcessing() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.DisableProcessing" />
      <MemberSignature Language="VB.NET" Value="Public Function DisableProcessing () As DispatcherProcessingDisabled" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Threading::DispatcherProcessingDisabled DisableProcessing();" />
      <MemberSignature Language="F#" Value="member this.DisableProcessing : unit -&gt; System.Windows.Threading.DispatcherProcessingDisabled" Usage="dispatcher.DisableProcessing " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherProcessingDisabled</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Deaktiviert Verarbeitung der <see cref="T:System.Windows.Threading.Dispatcher" />-Warteschlange.</summary>
        <returns>Eine Struktur, mit der die Dispatcherverarbeitung wieder aktiviert wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Deaktiviert Verarbeitung durch den Verteiler ist eine erweiterte Methode, die vorgesehen ist, um die Wahrscheinlichkeit, dass nicht verknüpfte Eintrittsinvarianz zu vermeiden.  
  
 Die Auswirkungen des Deaktivierens von Verarbeitung lauten wie folgt aus:  
  
-   CLR-Sperren werden intern keine Nachrichten senden.  
  
-   <xref:System.Windows.Threading.DispatcherFrame> Objekte sind nicht zulässig, mithilfe von Push übertragen werden.  
  
-   Verarbeitung von Nachrichten ist nicht zulässig.  
  
 Die <xref:System.Windows.Threading.DispatcherProcessingDisabled> Datenstruktur, <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A> zurückgegeben, wenn sie aufgerufen wird, können verwendet werden, um die dispatcherverarbeitung wieder aktiviert.  Aufrufen von <xref:System.Windows.Threading.DispatcherProcessingDisabled.Dispose%2A> auf die <xref:System.Windows.Threading.DispatcherProcessingDisabled> Struktur erneut verarbeiten aktiviert.  
  
 <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A> kann nur aufgerufen werden, auf dem Thread der <xref:System.Windows.Threading.Dispatcher> zugeordnet ist.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie verteilerverarbeitung deaktivieren und reaktivieren die Verarbeitung durch den Verteiler.  <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A> wird aufgerufen, einem **mit** Anweisung.  <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A> Gibt eine <xref:System.Windows.Threading.DispatcherProcessingDisabled> Struktur, wie das Objekt verwendet wird, um freigegeben sein, wenn, die **mit** -block abgeschlossen ist.  Wenn <xref:System.Windows.Threading.DispatcherProcessingDisabled.Dispose%2A> aufgerufen wird, auf die <xref:System.Windows.Threading.DispatcherProcessingDisabled> Struktur, die Verarbeitung durch den Verteiler ist wieder aktiviert.  
  
 [!code-csharp[DispatcherSnippets#DispatcherDisableProcessing](~/samples/snippets/csharp/VS_Snippets_Wpf/DispatcherSnippets/CSharp/Window1.xaml.cs#dispatcherdisableprocessing)]
 [!code-vb[DispatcherSnippets#DispatcherDisableProcessing](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DispatcherSnippets/visualbasic/window1.xaml.vb#dispatcherdisableprocessing)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExitAllFrames">
      <MemberSignature Language="C#" Value="public static void ExitAllFrames ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ExitAllFrames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.ExitAllFrames" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ExitAllFrames ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ExitAllFrames();" />
      <MemberSignature Language="F#" Value="static member ExitAllFrames : unit -&gt; unit" Usage="System.Windows.Threading.Dispatcher.ExitAllFrames " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Anforderung zum Beenden aller Frames einschließlich geschachtelter Frames.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">für das Aufrufen dieser Methode. Zugeordnete Enumerationen:  <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="M:System.Windows.Threading.Dispatcher.PushFrame(System.Windows.Threading.DispatcherFrame)" />
        <altmember cref="T:System.Windows.Threading.DispatcherFrame" />
      </Docs>
    </Member>
    <Member MemberName="FromThread">
      <MemberSignature Language="C#" Value="public static System.Windows.Threading.Dispatcher FromThread (System.Threading.Thread thread);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Threading.Dispatcher FromThread(class System.Threading.Thread thread) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.FromThread(System.Threading.Thread)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Threading::Dispatcher ^ FromThread(System::Threading::Thread ^ thread);" />
      <MemberSignature Language="F#" Value="static member FromThread : System.Threading.Thread -&gt; System.Windows.Threading.Dispatcher" Usage="System.Windows.Threading.Dispatcher.FromThread thread" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.Dispatcher</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="thread" Type="System.Threading.Thread" />
      </Parameters>
      <Docs>
        <param name="thread">Der Thread, dessen <see cref="T:System.Windows.Threading.Dispatcher" /> abgerufen werden soll.</param>
        <summary>Ruft den <see cref="T:System.Windows.Threading.Dispatcher" /> für den angegebenen Thread ab.</summary>
        <returns>Der Verteiler für <paramref name="thread" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein Verteiler nicht verfügbar für den angegebenen Thread ist `null` zurückgegeben werden.  
  
 <xref:System.Windows.Threading.Dispatcher.FromThread%2A> erstellt keine <xref:System.Windows.Threading.Dispatcher> in einem Thread, der keinem <xref:System.Windows.Threading.Dispatcher>.   Ein neues <xref:System.Windows.Threading.Dispatcher> wird auf einen Thread, der noch nicht erstellt eine <xref:System.Windows.Threading.Dispatcher> beim Abrufen der <xref:System.Windows.Threading.Dispatcher> mithilfe der <xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A> Eigenschaft.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasShutdownFinished">
      <MemberSignature Language="C#" Value="public bool HasShutdownFinished { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasShutdownFinished" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Threading.Dispatcher.HasShutdownFinished" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasShutdownFinished As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasShutdownFinished { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasShutdownFinished : bool" Usage="System.Windows.Threading.Dispatcher.HasShutdownFinished" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bestimmt, ob der <see cref="T:System.Windows.Threading.Dispatcher" /> die Beendigung abgeschlossen hat.</summary>
        <value>
          <see langword="true" />, wenn der Verteiler die Beendigung abgeschlossen hat, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Windows.Threading.Dispatcher> zum Herunterfahren beginnt die <xref:System.Windows.Threading.Dispatcher.ShutdownStarted> Ereignis wird ausgelöst, und <xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> nastaven NA hodnotu `true`.  
  
 Die <xref:System.Windows.Threading.Dispatcher> wird vollständig beendet, bis die Ereigniswarteschlange entladen.  
  
 Wenn der Verteiler die Beendigung, die <xref:System.Windows.Threading.Dispatcher.ShutdownFinished> Ereignis wird ausgelöst, und die <xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A> -Eigenschaftensatz auf `true`.  
  
 Nachdem der Prozess des Herunterfahrens eingeleitet wurde, werden alle ausstehenden Arbeit Elemente in der Warteschlange abgebrochen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasShutdownStarted">
      <MemberSignature Language="C#" Value="public bool HasShutdownStarted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasShutdownStarted" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Threading.Dispatcher.HasShutdownStarted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasShutdownStarted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasShutdownStarted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasShutdownStarted : bool" Usage="System.Windows.Threading.Dispatcher.HasShutdownStarted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bestimmt, ob der <see cref="T:System.Windows.Threading.Dispatcher" /> gerade beendet wird.</summary>
        <value>
          <see langword="true" />, wenn der <see cref="T:System.Windows.Threading.Dispatcher" /> gerade beendet wird, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Windows.Threading.Dispatcher> zum Herunterfahren beginnt die <xref:System.Windows.Threading.Dispatcher.ShutdownStarted> Ereignis wird ausgelöst, und <xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> nastaven NA hodnotu `true`.  
  
 Die <xref:System.Windows.Threading.Dispatcher> ist nicht vollständig heruntergefahren, bis die Ereigniswarteschlange entladen.  
  
 Wenn der Verteiler die Beendigung, die <xref:System.Windows.Threading.Dispatcher.ShutdownFinished> Ereignis wird ausgelöst, und die <xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A> -Eigenschaftensatz auf `true`.  
  
 Nachdem der Prozess des Herunterfahrens eingeleitet wurde, werden alle ausstehenden Arbeit Elemente in der Warteschlange abgebrochen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Hooks">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherHooks Hooks { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Threading.DispatcherHooks Hooks" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Threading.Dispatcher.Hooks" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Hooks As DispatcherHooks" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Threading::DispatcherHooks ^ Hooks { System::Windows::Threading::DispatcherHooks ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Hooks : System.Windows.Threading.DispatcherHooks" Usage="System.Windows.Threading.Dispatcher.Hooks" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherHooks</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Auflistung von Hooks ab, die zusätzliche Ereignisinformationen zum <see cref="T:System.Windows.Threading.Dispatcher" /> bereitstellen.</summary>
        <value>Die Hooks, die diesem <see cref="T:System.Windows.Threading.Dispatcher" /> zugeordnet sind.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Threading.DispatcherHooks> Klasse bietet zusätzliche Ereignisinformationen über die <xref:System.Windows.Threading.Dispatcher>, z. B. wenn die <xref:System.Windows.Threading.Dispatcher> inaktiv ist oder wenn ein Vorgang abgeschlossen wurde.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">zum Abrufen dieser Eigenschaft.  Zugeordnete Enumerationen:  <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Invoke">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Führt den angegebenen Delegaten synchron auf dem Thread aus, dem der <see cref="T:System.Windows.Threading.Dispatcher" /> zugeordnet ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], nur der Thread, der erstellt eine <xref:System.Windows.Threading.DispatcherObject> können auf dieses Objekt zugreifen.  Z. B. ein Hintergrundthread, der aus dem Hauptbenutzeroberflächen-Thread, deaktivieren erstellt wurde kann nicht aktualisiert werden den Inhalt einer <xref:System.Windows.Controls.Button> , die im UI-Thread erstellt wurde.  In der Hintergrundthread die Content-Eigenschaft der Zugriff auf die <xref:System.Windows.Controls.Button>, der Hintergrundthread die Verarbeitung zur delegieren muss die <xref:System.Windows.Threading.Dispatcher> im UI-Thread zugeordnet.  Dies wird erreicht, indem Sie entweder <xref:System.Windows.Threading.Dispatcher.Invoke%2A> oder <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> ist synchron und <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> ist asynchron.  Der Vorgang wurde an die Ereigniswarteschlange von der <xref:System.Windows.Threading.Dispatcher> an der angegebenen <xref:System.Windows.Threading.DispatcherPriority>.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> ist ein synchroner Vorgang. aus diesem Grund wird nicht auf das aufrufende Objekt bis Steuerung nach der Rückgabe des Rückrufs.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Delegat auf eine <xref:System.Windows.Threading.Dispatcher> am <xref:System.Windows.Threading.DispatcherPriority.Normal> mit <xref:System.Windows.Threading.Dispatcher.Invoke%2A>.  
  
 [!code-csharp[invalidaterequerywithsystemtimer#SystemTimerDispatcherInvoke](~/samples/snippets/csharp/VS_Snippets_Wpf/InvalidateRequeryWithSystemTimer/CSharp/Window1.xaml.cs#systemtimerdispatcherinvoke)]
 [!code-vb[invalidaterequerywithsystemtimer#SystemTimerDispatcherInvoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InvalidateRequeryWithSystemTimer/visualbasic/window1.xaml.vb#systemtimerdispatcherinvoke)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public void Invoke (Action callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invoke(class System.Action callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Action)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Invoke (callback As Action)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Invoke(Action ^ callback);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Action -&gt; unit" Usage="dispatcher.Invoke callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action" />
      </Parameters>
      <Docs>
        <param name="callback">Ein Delegat, der über den Verteiler aufgerufen werden soll.</param>
        <summary>Führt die angegebene <see cref="T:System.Action" /> synchron auf dem Thread aus, dem der <see cref="T:System.Windows.Threading.Dispatcher" /> zugeordnet ist.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public void Invoke (Action callback, System.Windows.Threading.DispatcherPriority priority);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invoke(class System.Action callback, valuetype System.Windows.Threading.DispatcherPriority priority) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Action,System.Windows.Threading.DispatcherPriority)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Invoke (callback As Action, priority As DispatcherPriority)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Invoke(Action ^ callback, System::Windows::Threading::DispatcherPriority priority);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Action * System.Windows.Threading.DispatcherPriority -&gt; unit" Usage="dispatcher.Invoke (callback, priority)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
      </Parameters>
      <Docs>
        <param name="callback">Ein Delegat, der über den Verteiler aufgerufen werden soll.</param>
        <param name="priority">Die Priorität, die bestimmt, in welcher Reihenfolge der angegebene Rückruf relativ zu den anderen ausstehenden Vorgängen in <see cref="T:System.Windows.Threading.Dispatcher" /> aufgerufen wird.</param>
        <summary>Führt die angegebene <see cref="T:System.Action" /> synchron mit der angegebenen Priorität auf dem Thread aus, dem der <see cref="T:System.Windows.Threading.Dispatcher" /> zugeordnet ist.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (Delegate method, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(class System.Delegate method, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (method As Delegate, ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(Delegate ^ method, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Delegate * obj[] -&gt; obj" Usage="dispatcher.Invoke (method, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method">Ein Delegat für eine Methode, die in <paramref name="args" /> angegebene Parameter akzeptiert und in die <see cref="T:System.Windows.Threading.Dispatcher" />-Ereigniswarteschlange gestellt wird.</param>
        <param name="args">Ein Array von Objekten, die als Argumente an die angegebene Methode übergeben werden sollen. Kann <see langword="null" /> sein.</param>
        <summary>Führt den angegebenen Delegaten synchron mit den angegebenen Argumenten für den Thread aus, dem der <see cref="T:System.Windows.Threading.Dispatcher" /> zugeordnet ist.</summary>
        <returns>Der Rückgabewert des aufgerufenen Delegaten bzw. <see langword="null" />, wenn der Delegat keinen Wert zurückgibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], nur der Thread, der erstellt eine <xref:System.Windows.Threading.DispatcherObject> können auf dieses Objekt zugreifen. Z. B. ein Hintergrundthread, der aus dem Hauptbenutzeroberflächen-Thread, deaktivieren erstellt wurde kann nicht aktualisiert werden den Inhalt einer <xref:System.Windows.Controls.Button> , die im UI-Thread erstellt wurde. In der Hintergrundthread die Content-Eigenschaft der Zugriff auf die <xref:System.Windows.Controls.Button>, der Hintergrundthread die Verarbeitung zur delegieren muss die <xref:System.Windows.Threading.Dispatcher> im UI-Thread zugeordnet. Dies wird erreicht, indem Sie entweder <xref:System.Windows.Threading.Dispatcher.Invoke%2A> oder <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>. <xref:System.Windows.Threading.Dispatcher.Invoke%2A> ist synchron und <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> ist asynchron. Der Vorgang wurde an die Ereigniswarteschlange von der <xref:System.Windows.Threading.Dispatcher> an der angegebenen <xref:System.Windows.Threading.DispatcherPriority>.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> ist ein synchroner Vorgang. aus diesem Grund wird nicht auf das aufrufende Objekt bis Steuerung nach der Rückgabe des Rückrufs.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (System.Windows.Threading.DispatcherPriority priority, Delegate method);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(valuetype System.Windows.Threading.DispatcherPriority priority, class System.Delegate method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (priority As DispatcherPriority, method As Delegate) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(System::Windows::Threading::DispatcherPriority priority, Delegate ^ method);" />
      <MemberSignature Language="F#" Value="member this.Invoke : System.Windows.Threading.DispatcherPriority * Delegate -&gt; obj" Usage="dispatcher.Invoke (priority, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="method" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="priority">Die Priorität, relativ zu den anderen anstehenden Operationen in der <see cref="T:System.Windows.Threading.Dispatcher" />-Ereigniswarteschlange, mit der die angegebene Methode aufgerufen wird.</param>
        <param name="method">Ein Delegat zu einer Methode, die keine Argumente erwartet und in die <see cref="T:System.Windows.Threading.Dispatcher" />-Ereigniswarteschlange gestellt wird.</param>
        <summary>Führt den angegebenen Delegaten synchron mit der angegebenen Priorität auf dem Thread aus, dem der <see cref="T:System.Windows.Threading.Dispatcher" /> zugeordnet ist.</summary>
        <returns>Der Rückgabewert des aufgerufenen Delegaten bzw. <see langword="null" />, wenn der Delegat keinen Wert zurückgibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], nur der Thread, der erstellt eine <xref:System.Windows.Threading.DispatcherObject> können auf dieses Objekt zugreifen.  Z. B. ein Hintergrundthread, der aus dem Hauptbenutzeroberflächen-Thread, deaktivieren erstellt wurde kann nicht aktualisiert werden den Inhalt einer <xref:System.Windows.Controls.Button> , die im UI-Thread erstellt wurde.  In der Hintergrundthread die Content-Eigenschaft der Zugriff auf die <xref:System.Windows.Controls.Button>, der Hintergrundthread die Verarbeitung zur delegieren muss die <xref:System.Windows.Threading.Dispatcher> im UI-Thread zugeordnet.  Dies wird erreicht, indem Sie entweder <xref:System.Windows.Threading.Dispatcher.Invoke%2A> oder <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> ist synchron und <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> ist asynchron.  Der Vorgang wurde an die Ereigniswarteschlange von der <xref:System.Windows.Threading.Dispatcher> an der angegebenen <xref:System.Windows.Threading.DispatcherPriority>.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> ist ein synchroner Vorgang. aus diesem Grund wird nicht auf das aufrufende Objekt bis Steuerung nach der Rückgabe des Rückrufs.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Delegat auf eine <xref:System.Windows.Threading.Dispatcher> am <xref:System.Windows.Threading.DispatcherPriority.Normal> mit <xref:System.Windows.Threading.Dispatcher.Invoke%2A>.  
  
 [!code-csharp[invalidaterequerywithsystemtimer#SystemTimerDispatcherInvoke](~/samples/snippets/csharp/VS_Snippets_Wpf/InvalidateRequeryWithSystemTimer/CSharp/Window1.xaml.cs#systemtimerdispatcherinvoke)]
 [!code-vb[invalidaterequerywithsystemtimer#SystemTimerDispatcherInvoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InvalidateRequeryWithSystemTimer/visualbasic/window1.xaml.vb#systemtimerdispatcherinvoke)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="priority" /> ist gleich <see cref="F:System.Windows.Threading.DispatcherPriority.Inactive" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="priority" /> ist keine gültige Priorität.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public void Invoke (Action callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invoke(class System.Action callback, valuetype System.Windows.Threading.DispatcherPriority priority, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Invoke(Action ^ callback, System::Windows::Threading::DispatcherPriority priority, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Action * System.Windows.Threading.DispatcherPriority * System.Threading.CancellationToken -&gt; unit" Usage="dispatcher.Invoke (callback, priority, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="callback">Ein Delegat, der über den Verteiler aufgerufen werden soll.</param>
        <param name="priority">Die Priorität, die bestimmt, in welcher Reihenfolge der angegebene Rückruf relativ zu den anderen ausstehenden Vorgängen in <see cref="T:System.Windows.Threading.Dispatcher" /> aufgerufen wird.</param>
        <param name="cancellationToken">Ein Objekt, das angibt, ob die Aktion abgebrochen werden kann.</param>
        <summary>Führt die angegebene <see cref="T:System.Action" /> synchron mit der angegebenen Priorität auf dem Thread aus, dem der <see cref="T:System.Windows.Threading.Dispatcher" /> zugeordnet ist.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (Delegate method, TimeSpan timeout, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(class System.Delegate method, valuetype System.TimeSpan timeout, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.TimeSpan,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (method As Delegate, timeout As TimeSpan, ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(Delegate ^ method, TimeSpan timeout, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Delegate * TimeSpan * obj[] -&gt; obj" Usage="dispatcher.Invoke (method, timeout, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method">Ein Delegat für eine Methode, die in <paramref name="args" /> angegebene Parameter akzeptiert und in die <see cref="T:System.Windows.Threading.Dispatcher" />-Ereigniswarteschlange gestellt wird.</param>
        <param name="timeout">Die maximale Zeitspanne, die auf den Abschluss der Operation gewartet wird.</param>
        <param name="args">Ein Array von Objekten, die als Argumente an die angegebene Methode übergeben werden sollen. Kann <see langword="null" /> sein.</param>
        <summary>Führt den angegebenen Delegaten in der angegebenen Zeitspanne mit der angegebenen Priorität und den angegebenen Argumenten synchron für den Thread aus, dem der <see cref="T:System.Windows.Threading.Dispatcher" /> zugeordnet ist.</summary>
        <returns>Der Rückgabewert des aufgerufenen Delegaten bzw. <see langword="null" />, wenn der Delegat keinen Wert zurückgibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], nur der Thread, der erstellt eine <xref:System.Windows.Threading.DispatcherObject> können auf dieses Objekt zugreifen. Z. B. ein Hintergrundthread, der aus dem Hauptbenutzeroberflächen-Thread, deaktivieren erstellt wurde kann nicht aktualisiert werden den Inhalt einer <xref:System.Windows.Controls.Button> , die im UI-Thread erstellt wurde. In der Hintergrundthread die Content-Eigenschaft der Zugriff auf die <xref:System.Windows.Controls.Button>, der Hintergrundthread die Verarbeitung zur delegieren muss die <xref:System.Windows.Threading.Dispatcher> im UI-Thread zugeordnet. Dies wird erreicht, indem Sie entweder <xref:System.Windows.Threading.Dispatcher.Invoke%2A> oder <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>. <xref:System.Windows.Threading.Dispatcher.Invoke%2A> ist synchron und <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> ist asynchron. Der Vorgang wurde an die Ereigniswarteschlange von der <xref:System.Windows.Threading.Dispatcher> an der angegebenen <xref:System.Windows.Threading.DispatcherPriority>.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> ist ein synchroner Vorgang. aus diesem Grund wird nicht auf das aufrufende Objekt bis Steuerung nach der Rückgabe des Rückrufs.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (Delegate method, System.Windows.Threading.DispatcherPriority priority, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(class System.Delegate method, valuetype System.Windows.Threading.DispatcherPriority priority, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.Windows.Threading.DispatcherPriority,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (method As Delegate, priority As DispatcherPriority, ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(Delegate ^ method, System::Windows::Threading::DispatcherPriority priority, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Delegate * System.Windows.Threading.DispatcherPriority * obj[] -&gt; obj" Usage="dispatcher.Invoke (method, priority, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method">Ein Delegat für eine Methode, die in <paramref name="args" /> angegebene Parameter akzeptiert und in die <see cref="T:System.Windows.Threading.Dispatcher" />-Ereigniswarteschlange gestellt wird.</param>
        <param name="priority">Die Priorität, relativ zu den anderen anstehenden Operationen in der <see cref="T:System.Windows.Threading.Dispatcher" />-Ereigniswarteschlange, mit der die angegebene Methode aufgerufen wird.</param>
        <param name="args">Ein Array von Objekten, die als Argumente an die angegebene Methode übergeben werden sollen. Kann <see langword="null" /> sein.</param>
        <summary>Führt den angegebenen Delegaten mit der angegebenen Priorität und den angegebenen Argumenten synchron auf dem Thread aus, dem der <see cref="T:System.Windows.Threading.Dispatcher" /> zugeordnet ist.</summary>
        <returns>Der Rückgabewert des aufgerufenen Delegaten bzw. <see langword="null" />, wenn der Delegat keinen Wert zurückgibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], nur der Thread, der erstellt eine <xref:System.Windows.Threading.DispatcherObject> können auf dieses Objekt zugreifen. Z. B. ein Hintergrundthread, der aus dem Hauptbenutzeroberflächen-Thread, deaktivieren erstellt wurde kann nicht aktualisiert werden den Inhalt einer <xref:System.Windows.Controls.Button> , die im UI-Thread erstellt wurde. In der Hintergrundthread die Content-Eigenschaft der Zugriff auf die <xref:System.Windows.Controls.Button>, der Hintergrundthread die Verarbeitung zur delegieren muss die <xref:System.Windows.Threading.Dispatcher> im UI-Thread zugeordnet. Dies wird erreicht, indem Sie entweder <xref:System.Windows.Threading.Dispatcher.Invoke%2A> oder <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>. <xref:System.Windows.Threading.Dispatcher.Invoke%2A> ist synchron und <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> ist asynchron. Der Vorgang wurde an die Ereigniswarteschlange von der <xref:System.Windows.Threading.Dispatcher> an der angegebenen <xref:System.Windows.Threading.DispatcherPriority>.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> ist ein synchroner Vorgang. aus diesem Grund wird nicht auf das aufrufende Objekt bis Steuerung nach der Rückgabe des Rückrufs.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (System.Windows.Threading.DispatcherPriority priority, Delegate method, object arg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(valuetype System.Windows.Threading.DispatcherPriority priority, class System.Delegate method, object arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (priority As DispatcherPriority, method As Delegate, arg As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(System::Windows::Threading::DispatcherPriority priority, Delegate ^ method, System::Object ^ arg);" />
      <MemberSignature Language="F#" Value="member this.Invoke : System.Windows.Threading.DispatcherPriority * Delegate * obj -&gt; obj" Usage="dispatcher.Invoke (priority, method, arg)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="arg" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="priority">Die Priorität, relativ zu den anderen anstehenden Operationen in der <see cref="T:System.Windows.Threading.Dispatcher" />-Ereigniswarteschlange, mit der die angegebene Methode aufgerufen wird.</param>
        <param name="method">Ein Delegat zu einer Methode, die ein Argument erwartet und in die <see cref="T:System.Windows.Threading.Dispatcher" />-Ereigniswarteschlange gestellt wird.</param>
        <param name="arg">Ein Objekt, das als Argument an die angegebene Methode übergeben werden soll.</param>
        <summary>Führt den angegebenen Delegaten mit der angegebenen Priorität und dem angegebenen Argument synchron auf dem Thread aus, dem der <see cref="T:System.Windows.Threading.Dispatcher" /> zugeordnet ist.</summary>
        <returns>Der Rückgabewert des aufgerufenen Delegaten bzw. <see langword="null" />, wenn der Delegat keinen Wert zurückgibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Arg` kann `null` Wenn ein Argument nicht erforderlich ist  
  
 In [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], nur der Thread, der erstellt eine <xref:System.Windows.Threading.DispatcherObject> können auf dieses Objekt zugreifen.  Z. B. ein Hintergrundthread, der aus dem Hauptbenutzeroberflächen-Thread, deaktivieren erstellt wurde kann nicht aktualisiert werden den Inhalt einer <xref:System.Windows.Controls.Button> , die im UI-Thread erstellt wurde.  In der Hintergrundthread die Content-Eigenschaft der Zugriff auf die <xref:System.Windows.Controls.Button>, der Hintergrundthread die Verarbeitung zur delegieren muss die <xref:System.Windows.Threading.Dispatcher> im UI-Thread zugeordnet.  Dies wird erreicht, indem Sie entweder <xref:System.Windows.Threading.Dispatcher.Invoke%2A> oder <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> ist synchron und <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> ist asynchron.  Der Vorgang wurde an die Ereigniswarteschlange von der <xref:System.Windows.Threading.Dispatcher> an der angegebenen <xref:System.Windows.Threading.DispatcherPriority>.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> ist ein synchroner Vorgang. aus diesem Grund wird nicht auf das aufrufende Objekt bis Steuerung nach der Rückgabe des Rückrufs.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="priority" /> ist gleich <see cref="F:System.Windows.Threading.DispatcherPriority.Inactive" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="priority" /> ist keine gültige Priorität.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (System.Windows.Threading.DispatcherPriority priority, TimeSpan timeout, Delegate method);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(valuetype System.Windows.Threading.DispatcherPriority priority, valuetype System.TimeSpan timeout, class System.Delegate method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (priority As DispatcherPriority, timeout As TimeSpan, method As Delegate) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(System::Windows::Threading::DispatcherPriority priority, TimeSpan timeout, Delegate ^ method);" />
      <MemberSignature Language="F#" Value="member this.Invoke : System.Windows.Threading.DispatcherPriority * TimeSpan * Delegate -&gt; obj" Usage="dispatcher.Invoke (priority, timeout, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="method" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="priority">Die Priorität, relativ zu den anderen anstehenden Operationen in der <see cref="T:System.Windows.Threading.Dispatcher" />-Ereigniswarteschlange, mit der die angegebene Methode aufgerufen wird.</param>
        <param name="timeout">Die maximale Zeit, die auf den Abschluss der Operation gewartet wird.</param>
        <param name="method">Der Delegat zu einer Methode, die keine Argumente erwartet und in die <see cref="T:System.Windows.Threading.Dispatcher" />-Ereigniswarteschlange gestellt wird.</param>
        <summary>Führt den angegebenen Delegaten synchron mit der angegebenen Priorität und dem angegebenen Timeoutwert auf dem Thread aus, in dem der <see cref="T:System.Windows.Threading.Dispatcher" /> erstellt wurde.</summary>
        <returns>Der Rückgabewert des aufgerufenen Delegaten bzw. <see langword="null" />, wenn der Delegat keinen Wert zurückgibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], nur der Thread, der erstellt eine <xref:System.Windows.Threading.DispatcherObject> können auf dieses Objekt zugreifen.  Z. B. ein Hintergrundthread, der aus dem Hauptbenutzeroberflächen-Thread, deaktivieren erstellt wurde kann nicht aktualisiert werden den Inhalt einer <xref:System.Windows.Controls.Button> , die im UI-Thread erstellt wurde.  In der Hintergrundthread die Content-Eigenschaft der Zugriff auf die <xref:System.Windows.Controls.Button>, der Hintergrundthread die Verarbeitung zur delegieren muss die <xref:System.Windows.Threading.Dispatcher> im UI-Thread zugeordnet.  Dies wird erreicht, indem Sie entweder <xref:System.Windows.Threading.Dispatcher.Invoke%2A> oder <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> ist synchron und <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> ist asynchron.  Der Vorgang wurde an die Ereigniswarteschlange von der <xref:System.Windows.Threading.Dispatcher> an der angegebenen <xref:System.Windows.Threading.DispatcherPriority>.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> ist ein synchroner Vorgang. aus diesem Grund wird nicht auf das aufrufende Objekt bis Steuerung nach der Rückgabe des Rückrufs.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public void Invoke (Action callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invoke(class System.Action callback, valuetype System.Windows.Threading.DispatcherPriority priority, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken,System.TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Invoke(Action ^ callback, System::Windows::Threading::DispatcherPriority priority, System::Threading::CancellationToken cancellationToken, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Action * System.Windows.Threading.DispatcherPriority * System.Threading.CancellationToken * TimeSpan -&gt; unit" Usage="dispatcher.Invoke (callback, priority, cancellationToken, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="callback">Ein Delegat, der über den Verteiler aufgerufen werden soll.</param>
        <param name="priority">Die Priorität, die bestimmt, in welcher Reihenfolge der angegebene Rückruf relativ zu den anderen ausstehenden Vorgängen in <see cref="T:System.Windows.Threading.Dispatcher" /> aufgerufen wird.</param>
        <param name="cancellationToken">Ein Objekt, das angibt, ob die Aktion abgebrochen werden kann.</param>
        <param name="timeout">Die minimale Zeitspanne, die auf den Start des Vorgangs gewartet wird.</param>
        <summary>Führt die angegebene <see cref="T:System.Action" /> synchron mit der angegebenen Priorität auf dem Thread aus, dem der <see cref="T:System.Windows.Threading.Dispatcher" /> zugeordnet ist.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (Delegate method, TimeSpan timeout, System.Windows.Threading.DispatcherPriority priority, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(class System.Delegate method, valuetype System.TimeSpan timeout, valuetype System.Windows.Threading.DispatcherPriority priority, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.TimeSpan,System.Windows.Threading.DispatcherPriority,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (method As Delegate, timeout As TimeSpan, priority As DispatcherPriority, ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(Delegate ^ method, TimeSpan timeout, System::Windows::Threading::DispatcherPriority priority, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Delegate * TimeSpan * System.Windows.Threading.DispatcherPriority * obj[] -&gt; obj" Usage="dispatcher.Invoke (method, timeout, priority, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method">Ein Delegat für eine Methode, die in <paramref name="args" /> angegebene Parameter akzeptiert und in die <see cref="T:System.Windows.Threading.Dispatcher" />-Ereigniswarteschlange gestellt wird.</param>
        <param name="timeout">Die maximale Zeitspanne, die auf den Abschluss der Operation gewartet wird.</param>
        <param name="priority">Die Priorität, relativ zu den anderen anstehenden Operationen in der <see cref="T:System.Windows.Threading.Dispatcher" />-Ereigniswarteschlange, mit der die angegebene Methode aufgerufen wird.</param>
        <param name="args">Ein Array von Objekten, die als Argumente an die angegebene Methode übergeben werden sollen. Kann <see langword="null" /> sein.</param>
        <summary>Führt den angegebenen Delegaten in der angegebenen Zeitspanne mit der angegebenen Priorität und den angegebenen Argumenten synchron für den Thread aus, dem der <see cref="T:System.Windows.Threading.Dispatcher" /> zugeordnet ist.</summary>
        <returns>Der Rückgabewert des aufgerufenen Delegaten bzw. <see langword="null" />, wenn der Delegat keinen Wert zurückgibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], nur der Thread, der erstellt eine <xref:System.Windows.Threading.DispatcherObject> können auf dieses Objekt zugreifen. Z. B. ein Hintergrundthread, der aus dem Hauptbenutzeroberflächen-Thread, deaktivieren erstellt wurde kann nicht aktualisiert werden den Inhalt einer <xref:System.Windows.Controls.Button> , die im UI-Thread erstellt wurde. In der Hintergrundthread die Content-Eigenschaft der Zugriff auf die <xref:System.Windows.Controls.Button>, der Hintergrundthread die Verarbeitung zur delegieren muss die <xref:System.Windows.Threading.Dispatcher> im UI-Thread zugeordnet. Dies wird erreicht, indem Sie entweder <xref:System.Windows.Threading.Dispatcher.Invoke%2A> oder <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>. <xref:System.Windows.Threading.Dispatcher.Invoke%2A> ist synchron und <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> ist asynchron. Der Vorgang wurde an die Ereigniswarteschlange von der <xref:System.Windows.Threading.Dispatcher> an der angegebenen <xref:System.Windows.Threading.DispatcherPriority>.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> ist ein synchroner Vorgang. aus diesem Grund wird nicht auf das aufrufende Objekt bis Steuerung nach der Rückgabe des Rückrufs.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (System.Windows.Threading.DispatcherPriority priority, Delegate method, object arg, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(valuetype System.Windows.Threading.DispatcherPriority priority, class System.Delegate method, object arg, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (priority As DispatcherPriority, method As Delegate, arg As Object, ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(System::Windows::Threading::DispatcherPriority priority, Delegate ^ method, System::Object ^ arg, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.Invoke : System.Windows.Threading.DispatcherPriority * Delegate * obj * obj[] -&gt; obj" Usage="dispatcher.Invoke (priority, method, arg, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="arg" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="priority">Die Priorität, relativ zu den anderen anstehenden Operationen in der <see cref="T:System.Windows.Threading.Dispatcher" />-Ereigniswarteschlange, mit der die angegebene Methode aufgerufen wird.</param>
        <param name="method">Ein Delegat zu einer Methode, die mehrere Argumente erwartet und in die <see cref="T:System.Windows.Threading.Dispatcher" />-Ereigniswarteschlange gestellt wird.</param>
        <param name="arg">Ein Objekt, das als Argument an die angegebene Methode übergeben werden soll.</param>
        <param name="args">Ein Array von Objekten, die als Argumente an die angegebene Methode übergeben werden sollen.</param>
        <summary>Führt den angegebenen Delegaten mit der angegebenen Priorität und den angegebenen Argumenten synchron auf dem Thread aus, dem der <see cref="T:System.Windows.Threading.Dispatcher" /> zugeordnet ist.</summary>
        <returns>Der Rückgabewert des aufgerufenen Delegaten bzw. <see langword="null" />, wenn der Delegat keinen Wert zurückgibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Arg` kann `null` Wenn ein Argument nicht erforderlich ist  
  
 In [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], nur der Thread, der erstellt eine <xref:System.Windows.Threading.DispatcherObject> können auf dieses Objekt zugreifen.  Z. B. ein Hintergrundthread, der aus dem Hauptbenutzeroberflächen-Thread, deaktivieren erstellt wurde kann nicht aktualisiert werden den Inhalt einer <xref:System.Windows.Controls.Button> , die im UI-Thread erstellt wurde.  In der Hintergrundthread die Content-Eigenschaft der Zugriff auf die <xref:System.Windows.Controls.Button>, der Hintergrundthread die Verarbeitung zur delegieren muss die <xref:System.Windows.Threading.Dispatcher> im UI-Thread zugeordnet.  Dies wird erreicht, indem Sie entweder <xref:System.Windows.Threading.Dispatcher.Invoke%2A> oder <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> ist synchron und <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> ist asynchron.  Der Vorgang wurde an die Ereigniswarteschlange von der <xref:System.Windows.Threading.Dispatcher> an der angegebenen <xref:System.Windows.Threading.DispatcherPriority>.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> ist ein synchroner Vorgang. aus diesem Grund wird nicht auf das aufrufende Objekt bis Steuerung nach der Rückgabe des Rückrufs.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="priority" /> ist gleich <see cref="F:System.Windows.Threading.DispatcherPriority.Inactive" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="priority" /> ist keine gültige Priorität.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (System.Windows.Threading.DispatcherPriority priority, TimeSpan timeout, Delegate method, object arg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(valuetype System.Windows.Threading.DispatcherPriority priority, valuetype System.TimeSpan timeout, class System.Delegate method, object arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (priority As DispatcherPriority, timeout As TimeSpan, method As Delegate, arg As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(System::Windows::Threading::DispatcherPriority priority, TimeSpan timeout, Delegate ^ method, System::Object ^ arg);" />
      <MemberSignature Language="F#" Value="member this.Invoke : System.Windows.Threading.DispatcherPriority * TimeSpan * Delegate * obj -&gt; obj" Usage="dispatcher.Invoke (priority, timeout, method, arg)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="arg" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="priority">Die Priorität, relativ zu den anderen anstehenden Operationen in der <see cref="T:System.Windows.Threading.Dispatcher" />-Ereigniswarteschlange, mit der die angegebene Methode aufgerufen wird.</param>
        <param name="timeout">Die maximale Zeit, die auf den Abschluss der Operation gewartet wird.</param>
        <param name="method">Ein Delegat zu einer Methode, die mehrere Argumente erwartet und in die <see cref="T:System.Windows.Threading.Dispatcher" />-Ereigniswarteschlange gestellt wird.</param>
        <param name="arg">Ein Objekt, das als Argument an die angegebene Methode übergeben werden soll. Dies kann <see langword="null" /> sein, wenn keine Argumente benötigt werden.</param>
        <summary>Führt den angegebenen Delegaten mit der angegebenen Priorität und dem angegebenen Argument synchron auf dem Thread aus, dem der <see cref="T:System.Windows.Threading.Dispatcher" /> zugeordnet ist.</summary>
        <returns>Der Rückgabewert des aufgerufenen Delegaten bzw. <see langword="null" />, wenn der Delegat keinen Wert zurückgibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Arg` kann `null` Wenn ein Argument nicht erforderlich ist  
  
 In [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], nur der Thread, der erstellt eine <xref:System.Windows.Threading.DispatcherObject> können auf dieses Objekt zugreifen.  Z. B. ein Hintergrundthread, der aus dem Hauptbenutzeroberflächen-Thread, deaktivieren erstellt wurde kann nicht aktualisiert werden den Inhalt einer <xref:System.Windows.Controls.Button> , die im UI-Thread erstellt wurde.  In der Hintergrundthread die Content-Eigenschaft der Zugriff auf die <xref:System.Windows.Controls.Button>, der Hintergrundthread die Verarbeitung zur delegieren muss die <xref:System.Windows.Threading.Dispatcher> im UI-Thread zugeordnet.  Dies wird erreicht, indem Sie entweder <xref:System.Windows.Threading.Dispatcher.Invoke%2A> oder <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> ist synchron und <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> ist asynchron.  Der Vorgang wurde an die Ereigniswarteschlange von der <xref:System.Windows.Threading.Dispatcher> an der angegebenen <xref:System.Windows.Threading.DispatcherPriority>.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> ist ein synchroner Vorgang. aus diesem Grund wird nicht auf das aufrufende Objekt bis Steuerung nach der Rückgabe des Rückrufs.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="priority" /> ist gleich <see cref="F:System.Windows.Threading.DispatcherPriority.Inactive" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="priority" /> ist keine gültige Priorität.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (System.Windows.Threading.DispatcherPriority priority, TimeSpan timeout, Delegate method, object arg, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(valuetype System.Windows.Threading.DispatcherPriority priority, valuetype System.TimeSpan timeout, class System.Delegate method, object arg, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate,System.Object,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (priority As DispatcherPriority, timeout As TimeSpan, method As Delegate, arg As Object, ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(System::Windows::Threading::DispatcherPriority priority, TimeSpan timeout, Delegate ^ method, System::Object ^ arg, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.Invoke : System.Windows.Threading.DispatcherPriority * TimeSpan * Delegate * obj * obj[] -&gt; obj" Usage="dispatcher.Invoke (priority, timeout, method, arg, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="arg" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="priority">Die Priorität, relativ zu den anderen anstehenden Operationen in der <see cref="T:System.Windows.Threading.Dispatcher" />-Ereigniswarteschlange, mit der die angegebene Methode aufgerufen wird.</param>
        <param name="timeout">Die maximale Zeit, die auf den Abschluss der Operation gewartet wird.</param>
        <param name="method">Ein Delegat zu einer Methode, die mehrere Argumente erwartet und in die <see cref="T:System.Windows.Threading.Dispatcher" />-Ereigniswarteschlange gestellt wird.</param>
        <param name="arg">Ein Objekt, das als Argument an die angegebene Methode übergeben wird.</param>
        <param name="args">Ein Array von Objekten, die als Argumente an die angegebene Methode übergeben werden sollen.</param>
        <summary>Führt den angegebenen Delegaten mit der angegebenen Priorität und den angegebenen Argumenten synchron auf dem Thread aus, dem der <see cref="T:System.Windows.Threading.Dispatcher" /> zugeordnet ist.</summary>
        <returns>Der Rückgabewert des aufgerufenen Delegaten bzw. <see langword="null" />, wenn der Delegat keinen Wert zurückgibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Arg` kann `null` Wenn ein Argument nicht erforderlich ist.  
  
 In [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], nur der Thread, der erstellt eine <xref:System.Windows.Threading.DispatcherObject> können auf dieses Objekt zugreifen.  Z. B. ein Hintergrundthread, der aus dem Hauptbenutzeroberflächen-Thread, deaktivieren erstellt wurde kann nicht aktualisiert werden den Inhalt einer <xref:System.Windows.Controls.Button> , die im UI-Thread erstellt wurde.  In der Hintergrundthread die Content-Eigenschaft der Zugriff auf die <xref:System.Windows.Controls.Button>, der Hintergrundthread die Verarbeitung zur delegieren muss die <xref:System.Windows.Threading.Dispatcher> im UI-Thread zugeordnet.  Dies wird erreicht, indem Sie entweder <xref:System.Windows.Threading.Dispatcher.Invoke%2A> oder <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> ist synchron und <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> ist asynchron.  Der Vorgang wurde an die Ereigniswarteschlange von der <xref:System.Windows.Threading.Dispatcher> an der angegebenen <xref:System.Windows.Threading.DispatcherPriority>.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> ist ein synchroner Vorgang. aus diesem Grund wird nicht auf das aufrufende Objekt bis Steuerung nach der Rückgabe des Rückrufs.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="priority" /> ist gleich <see cref="F:System.Windows.Threading.DispatcherPriority.Inactive" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="priority" /> ist kein gültiger <see cref="T:System.Windows.Threading.DispatcherPriority" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public TResult Invoke&lt;TResult&gt; (Func&lt;TResult&gt; callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !!TResult Invoke&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke(Of TResult) (callback As Func(Of TResult)) As TResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; TResult Invoke(Func&lt;TResult&gt; ^ callback);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Func&lt;'Result&gt; -&gt; 'Result" Usage="dispatcher.Invoke callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callback" Type="System.Func&lt;TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Rückgabewerts des angegebenen Delegaten.</typeparam>
        <param name="callback">Ein Delegat, der über den Verteiler aufgerufen werden soll.</param>
        <summary>Führt die angegebene <see cref="T:System.Func`1" /> synchron auf dem Thread aus, dem der <see cref="T:System.Windows.Threading.Dispatcher" /> zugeordnet ist.</summary>
        <returns>To be added.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Rückgabewert von `callback`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public TResult Invoke&lt;TResult&gt; (Func&lt;TResult&gt; callback, System.Windows.Threading.DispatcherPriority priority);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !!TResult Invoke&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; callback, valuetype System.Windows.Threading.DispatcherPriority priority) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority)" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke(Of TResult) (callback As Func(Of TResult), priority As DispatcherPriority) As TResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; TResult Invoke(Func&lt;TResult&gt; ^ callback, System::Windows::Threading::DispatcherPriority priority);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Func&lt;'Result&gt; * System.Windows.Threading.DispatcherPriority -&gt; 'Result" Usage="dispatcher.Invoke (callback, priority)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callback" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Rückgabewerts des angegebenen Delegaten.</typeparam>
        <param name="callback">Ein Delegat, der über den Verteiler aufgerufen werden soll.</param>
        <param name="priority">Die Priorität, die bestimmt, in welcher Reihenfolge der angegebene Rückruf relativ zu den anderen ausstehenden Vorgängen in <see cref="T:System.Windows.Threading.Dispatcher" /> aufgerufen wird.</param>
        <summary>Führt die angegebene <see cref="T:System.Func`1" /> synchron mit der angegebenen Priorität auf dem Thread aus, dem der <see cref="T:System.Windows.Threading.Dispatcher" /> zugeordnet ist.</summary>
        <returns>To be added.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Rückgabewert von `callback`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public TResult Invoke&lt;TResult&gt; (Func&lt;TResult&gt; callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !!TResult Invoke&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; callback, valuetype System.Windows.Threading.DispatcherPriority priority, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; TResult Invoke(Func&lt;TResult&gt; ^ callback, System::Windows::Threading::DispatcherPriority priority, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Func&lt;'Result&gt; * System.Windows.Threading.DispatcherPriority * System.Threading.CancellationToken -&gt; 'Result" Usage="dispatcher.Invoke (callback, priority, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callback" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Rückgabewerts des angegebenen Delegaten.</typeparam>
        <param name="callback">Ein Delegat, der über den Verteiler aufgerufen werden soll.</param>
        <param name="priority">Die Priorität, die bestimmt, in welcher Reihenfolge der angegebene Rückruf relativ zu den anderen ausstehenden Vorgängen in <see cref="T:System.Windows.Threading.Dispatcher" /> aufgerufen wird.</param>
        <param name="cancellationToken">Ein Objekt, das angibt, ob der Vorgang abgebrochen werden kann.</param>
        <summary>Führt die angegebene <see cref="T:System.Func`1" /> synchron mit der angegebenen Priorität auf dem Thread aus, dem der <see cref="T:System.Windows.Threading.Dispatcher" /> zugeordnet ist.</summary>
        <returns>To be added.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Rückgabewert von `callback`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public TResult Invoke&lt;TResult&gt; (Func&lt;TResult&gt; callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !!TResult Invoke&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; callback, valuetype System.Windows.Threading.DispatcherPriority priority, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken,System.TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; TResult Invoke(Func&lt;TResult&gt; ^ callback, System::Windows::Threading::DispatcherPriority priority, System::Threading::CancellationToken cancellationToken, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Func&lt;'Result&gt; * System.Windows.Threading.DispatcherPriority * System.Threading.CancellationToken * TimeSpan -&gt; 'Result" Usage="dispatcher.Invoke (callback, priority, cancellationToken, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callback" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Rückgabewerts des angegebenen Delegaten.</typeparam>
        <param name="callback">Ein Delegat, der über den Verteiler aufgerufen werden soll.</param>
        <param name="priority">Die Priorität, die bestimmt, in welcher Reihenfolge der angegebene Rückruf relativ zu den anderen ausstehenden Vorgängen in <see cref="T:System.Windows.Threading.Dispatcher" /> aufgerufen wird.</param>
        <param name="cancellationToken">Ein Objekt, das angibt, ob der Vorgang abgebrochen werden kann.</param>
        <param name="timeout">Die minimale Zeitspanne, die auf den Start des Vorgangs gewartet wird.</param>
        <summary>Führt die angegebene <see cref="T:System.Func`1" /> synchron mit der angegebenen Priorität auf dem Thread aus, dem der <see cref="T:System.Windows.Threading.Dispatcher" /> zugeordnet ist.</summary>
        <returns>To be added.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Rückgabewert von `callback`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="InvokeAsync">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Führt den angegebenen Delegaten asynchron auf dem Thread aus, dem der <see cref="T:System.Windows.Threading.Dispatcher" /> zugeordnet ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="InvokeAsync">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation InvokeAsync (Action callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation InvokeAsync(class System.Action callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.InvokeAsync(System.Action)" />
      <MemberSignature Language="VB.NET" Value="Public Function InvokeAsync (callback As Action) As DispatcherOperation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Threading::DispatcherOperation ^ InvokeAsync(Action ^ callback);" />
      <MemberSignature Language="F#" Value="member this.InvokeAsync : Action -&gt; System.Windows.Threading.DispatcherOperation" Usage="dispatcher.InvokeAsync callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action" />
      </Parameters>
      <Docs>
        <param name="callback">Ein Delegat, der über den Verteiler aufgerufen werden soll.</param>
        <summary>Führt die angegebene <see cref="T:System.Action" /> asynchron auf dem Thread aus, dem der <see cref="T:System.Windows.Threading.Dispatcher" /> zugeordnet ist.</summary>
        <returns>Ein Objekt, das unmittelbar nach dem Aufruf von <see cref="M:System.Windows.Threading.Dispatcher.InvokeAsync(System.Action)" /> zurückgegeben wird und für die Interaktion mit dem Delegaten verwendet werden kann, während im Delegaten die Ausführung einer Aufgabe in der Warteschlange steht.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeAsync">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation InvokeAsync (Action callback, System.Windows.Threading.DispatcherPriority priority);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation InvokeAsync(class System.Action callback, valuetype System.Windows.Threading.DispatcherPriority priority) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.InvokeAsync(System.Action,System.Windows.Threading.DispatcherPriority)" />
      <MemberSignature Language="VB.NET" Value="Public Function InvokeAsync (callback As Action, priority As DispatcherPriority) As DispatcherOperation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Threading::DispatcherOperation ^ InvokeAsync(Action ^ callback, System::Windows::Threading::DispatcherPriority priority);" />
      <MemberSignature Language="F#" Value="member this.InvokeAsync : Action * System.Windows.Threading.DispatcherPriority -&gt; System.Windows.Threading.DispatcherOperation" Usage="dispatcher.InvokeAsync (callback, priority)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
      </Parameters>
      <Docs>
        <param name="callback">Ein Delegat, der über den Verteiler aufgerufen werden soll.</param>
        <param name="priority">Die Priorität, die bestimmt, in welcher Reihenfolge der angegebene Rückruf relativ zu den anderen ausstehenden Vorgängen in <see cref="T:System.Windows.Threading.Dispatcher" /> aufgerufen wird.</param>
        <summary>Führt die angegebene <see cref="T:System.Action" /> asynchron mit der angegebenen Priorität auf dem Thread aus, dem der <see cref="T:System.Windows.Threading.Dispatcher" /> zugeordnet ist.</summary>
        <returns>Ein Objekt, das unmittelbar nach dem Aufruf von <see cref="M:System.Windows.Threading.Dispatcher.InvokeAsync(System.Action,System.Windows.Threading.DispatcherPriority)" /> zurückgegeben wird und für die Interaktion mit dem Delegaten verwendet werden kann, während im Delegaten die Ausführung einer Aufgabe in der Warteschlange steht.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeAsync">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation InvokeAsync (Action callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation InvokeAsync(class System.Action callback, valuetype System.Windows.Threading.DispatcherPriority priority, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.InvokeAsync(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Threading::DispatcherOperation ^ InvokeAsync(Action ^ callback, System::Windows::Threading::DispatcherPriority priority, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.InvokeAsync : Action * System.Windows.Threading.DispatcherPriority * System.Threading.CancellationToken -&gt; System.Windows.Threading.DispatcherOperation" Usage="dispatcher.InvokeAsync (callback, priority, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="callback">Ein Delegat, der über den Verteiler aufgerufen werden soll.</param>
        <param name="priority">Die Priorität, die bestimmt, in welcher Reihenfolge der angegebene Rückruf relativ zu den anderen ausstehenden Vorgängen in <see cref="T:System.Windows.Threading.Dispatcher" /> aufgerufen wird.</param>
        <param name="cancellationToken">Ein Objekt, das angibt, ob die Aktion abgebrochen werden kann.</param>
        <summary>Führt die angegebene <see cref="T:System.Action" /> asynchron mit der angegebenen Priorität auf dem Thread aus, dem der <see cref="T:System.Windows.Threading.Dispatcher" /> zugeordnet ist.</summary>
        <returns>Ein Objekt, das unmittelbar nach dem Aufruf von <see cref="M:System.Windows.Threading.Dispatcher.InvokeAsync(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)" /> zurückgegeben wird und für die Interaktion mit dem Delegaten verwendet werden kann, während im Delegaten die Ausführung einer Aufgabe in der Warteschlange steht.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeAsync&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation&lt;TResult&gt; InvokeAsync&lt;TResult&gt; (Func&lt;TResult&gt; callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation`1&lt;!!TResult&gt; InvokeAsync&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function InvokeAsync(Of TResult) (callback As Func(Of TResult)) As DispatcherOperation(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Windows::Threading::DispatcherOperation&lt;TResult&gt; ^ InvokeAsync(Func&lt;TResult&gt; ^ callback);" />
      <MemberSignature Language="F#" Value="member this.InvokeAsync : Func&lt;'Result&gt; -&gt; System.Windows.Threading.DispatcherOperation&lt;'Result&gt;" Usage="dispatcher.InvokeAsync callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callback" Type="System.Func&lt;TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Rückgabewerts des angegebenen Delegaten.</typeparam>
        <param name="callback">Ein Delegat, der über den Verteiler aufgerufen werden soll.</param>
        <summary>Führt die angegebene <see cref="T:System.Func`1" /> asynchron auf dem Thread aus, dem der <see cref="T:System.Windows.Threading.Dispatcher" /> zugeordnet ist.</summary>
        <returns>Ein Objekt, das unmittelbar nach dem Aufruf von <see cref="M:System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0})" /> zurückgegeben wird und für die Interaktion mit dem Delegaten verwendet werden kann, während im Delegaten die Ausführung einer Aufgabe in der Warteschlange steht.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeAsync&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation&lt;TResult&gt; InvokeAsync&lt;TResult&gt; (Func&lt;TResult&gt; callback, System.Windows.Threading.DispatcherPriority priority);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation`1&lt;!!TResult&gt; InvokeAsync&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; callback, valuetype System.Windows.Threading.DispatcherPriority priority) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0},System.Windows.Threading.DispatcherPriority)" />
      <MemberSignature Language="VB.NET" Value="Public Function InvokeAsync(Of TResult) (callback As Func(Of TResult), priority As DispatcherPriority) As DispatcherOperation(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Windows::Threading::DispatcherOperation&lt;TResult&gt; ^ InvokeAsync(Func&lt;TResult&gt; ^ callback, System::Windows::Threading::DispatcherPriority priority);" />
      <MemberSignature Language="F#" Value="member this.InvokeAsync : Func&lt;'Result&gt; * System.Windows.Threading.DispatcherPriority -&gt; System.Windows.Threading.DispatcherOperation&lt;'Result&gt;" Usage="dispatcher.InvokeAsync (callback, priority)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callback" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Rückgabewerts des angegebenen Delegaten.</typeparam>
        <param name="callback">Ein Delegat, der über den Verteiler aufgerufen werden soll.</param>
        <param name="priority">Die Priorität, die bestimmt, in welcher Reihenfolge der angegebene Rückruf relativ zu den anderen ausstehenden Vorgängen in <see cref="T:System.Windows.Threading.Dispatcher" /> aufgerufen wird.</param>
        <summary>Führt die angegebene <see cref="T:System.Func`1" /> asynchron mit der angegebenen Priorität auf dem Thread aus, dem der <see cref="T:System.Windows.Threading.Dispatcher" /> zugeordnet ist.</summary>
        <returns>Ein Objekt, das unmittelbar nach dem Aufruf von <see cref="M:System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0},System.Windows.Threading.DispatcherPriority)" /> zurückgegeben wird und für die Interaktion mit dem Delegaten verwendet werden kann, während im Delegaten die Ausführung einer Aufgabe in der Warteschlange steht.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeAsync&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation&lt;TResult&gt; InvokeAsync&lt;TResult&gt; (Func&lt;TResult&gt; callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation`1&lt;!!TResult&gt; InvokeAsync&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; callback, valuetype System.Windows.Threading.DispatcherPriority priority, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Windows::Threading::DispatcherOperation&lt;TResult&gt; ^ InvokeAsync(Func&lt;TResult&gt; ^ callback, System::Windows::Threading::DispatcherPriority priority, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.InvokeAsync : Func&lt;'Result&gt; * System.Windows.Threading.DispatcherPriority * System.Threading.CancellationToken -&gt; System.Windows.Threading.DispatcherOperation&lt;'Result&gt;" Usage="dispatcher.InvokeAsync (callback, priority, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callback" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Rückgabewerts des angegebenen Delegaten.</typeparam>
        <param name="callback">Ein Delegat, der über den Verteiler aufgerufen werden soll.</param>
        <param name="priority">Die Priorität, die bestimmt, in welcher Reihenfolge der angegebene Rückruf relativ zu den anderen ausstehenden Vorgängen in <see cref="T:System.Windows.Threading.Dispatcher" /> aufgerufen wird.</param>
        <param name="cancellationToken">Ein Objekt, das angibt, ob der Vorgang abgebrochen werden kann.</param>
        <summary>Führt die angegebene <see cref="T:System.Func`1" /> asynchron mit der angegebenen Priorität auf dem Thread aus, dem der <see cref="T:System.Windows.Threading.Dispatcher" /> zugeordnet ist.</summary>
        <returns>Ein Objekt, das unmittelbar nach dem Aufruf von <see cref="M:System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)" /> zurückgegeben wird und für die Interaktion mit dem Delegaten verwendet werden kann, während im Delegaten die Ausführung einer Aufgabe in der Warteschlange steht.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeShutdown">
      <MemberSignature Language="C#" Value="public void InvokeShutdown ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InvokeShutdown() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.InvokeShutdown" />
      <MemberSignature Language="VB.NET" Value="Public Sub InvokeShutdown ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InvokeShutdown();" />
      <MemberSignature Language="F#" Value="member this.InvokeShutdown : unit -&gt; unit" Usage="dispatcher.InvokeShutdown " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Initiiert die synchrone Beendigung des <see cref="T:System.Windows.Threading.Dispatcher" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Threading.Dispatcher.InvokeShutdown%2A> setzt uneingeschränkte Berechtigungen in der Benutzeroberfläche.  
  
 Wenn die <xref:System.Windows.Threading.Dispatcher> zum Herunterfahren beginnt die <xref:System.Windows.Threading.Dispatcher.ShutdownStarted> Ereignis wird ausgelöst, und <xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> nastaven NA hodnotu `true`.  
  
 Die <xref:System.Windows.Threading.Dispatcher> ist nicht vollständig heruntergefahren, bis die Ereigniswarteschlange entladen.  
  
 Wenn der Verteiler die Beendigung, die <xref:System.Windows.Threading.Dispatcher.ShutdownFinished> Ereignis wird ausgelöst, und die <xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A> -Eigenschaftensatz auf `true`.  
  
 Nachdem der Prozess des Herunterfahrens eingeleitet wurde, werden alle ausstehenden Arbeit Elemente in der Warteschlange abgebrochen.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">für den Verteiler beendet.  Zugeordnete Enumerationen:  <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="PushFrame">
      <MemberSignature Language="C#" Value="public static void PushFrame (System.Windows.Threading.DispatcherFrame frame);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PushFrame(class System.Windows.Threading.DispatcherFrame frame) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.PushFrame(System.Windows.Threading.DispatcherFrame)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PushFrame (frame As DispatcherFrame)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PushFrame(System::Windows::Threading::DispatcherFrame ^ frame);" />
      <MemberSignature Language="F#" Value="static member PushFrame : System.Windows.Threading.DispatcherFrame -&gt; unit" Usage="System.Windows.Threading.Dispatcher.PushFrame frame" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="frame" Type="System.Windows.Threading.DispatcherFrame" />
      </Parameters>
      <Docs>
        <param name="frame">Der Frame, den der Verteiler verarbeiten soll.</param>
        <summary>Tritt in eine Ausführungsschleife ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Windows.Threading.DispatcherFrame> stellt eine Schleife, die anstehende Arbeitsaufgaben verarbeitet.  
  
 Der Verteiler verarbeitet die Warteschlange für Arbeitsaufgaben in einer Schleife.  Die Schleife wird als Frame bezeichnet.  Die ersten Schleife wird in der Regel von der Anwendung durch den Aufruf initiiert <xref:System.Windows.Threading.Dispatcher.Run%2A>.  
  
 <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> Tritt in eine Schleife, die vom Parameter dargestellten `frame`.  Bei jeder Iteration der Schleife die <xref:System.Windows.Threading.Dispatcher> prüft die <xref:System.Windows.Threading.DispatcherFrame.Continue%2A> Eigenschaft für die <xref:System.Windows.Threading.DispatcherFrame> Klasse, um zu bestimmen, ob die Schleife fortgesetzt werden soll, oder wenn er beendet werden soll.  
  
 <xref:System.Windows.Threading.DispatcherFrame> ermöglicht die <xref:System.Windows.Threading.DispatcherFrame.Continue%2A> -Eigenschaft explizit festgelegt werden und berücksichtigt die <xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> Eigenschaft für die <xref:System.Windows.Threading.Dispatcher>.  Dies bedeutet, wenn die <xref:System.Windows.Threading.Dispatcher> startet, beendet, Frames, die den vorgegebenen <xref:System.Windows.Threading.DispatcherFrame> Implementierung wird beendet, wodurch alle geschachtelten Frames zu beenden.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie mit einem <xref:System.Windows.Threading.DispatcherFrame> ähnliche Ergebnisse wie erzielen die [!INCLUDE[TLA#tla_winforms](~/includes/tlasharptla-winforms-md.md)] <xref:System.Windows.Forms.Application.DoEvents%2A> Methode.  
  
 [!code-csharp[dispatchersnippets#DispatcherDispatcherFrameDoEvents](~/samples/snippets/csharp/VS_Snippets_Wpf/DispatcherSnippets/CSharp/Window1.xaml.cs#dispatcherdispatcherframedoevents)]
 [!code-vb[dispatchersnippets#DispatcherDispatcherFrameDoEvents](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DispatcherSnippets/visualbasic/window1.xaml.vb#dispatcherdispatcherframedoevents)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="frame" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Windows.Threading.Dispatcher.HasShutdownFinished" /> ist gleich <see langword="true" />.  
  
- oder -  
 <paramref name="frame" /> wird auf einem anderen <see cref="T:System.Windows.Threading.Dispatcher" /> ausgeführt.  
  
- oder -  
Verteilerverarbeitung wurde deaktiviert.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">zur pushübertragung eines Frames für die Ausführung an.  Zugeordnete Enumerationen:  <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="M:System.Windows.Threading.Dispatcher.ExitAllFrames" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Run" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run();" />
      <MemberSignature Language="F#" Value="static member Run : unit -&gt; unit" Usage="System.Windows.Threading.Dispatcher.Run " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Stellt den Hauptausführungsframe in die Ereigniswarteschlange von <see cref="T:System.Windows.Threading.Dispatcher" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Threading.Dispatcher> die Ereigniswarteschlange in einer Schleife verarbeitet.  Die Schleife wird als Frame bezeichnet.  Die ersten Schleife wird in der Regel von der Anwendung durch den Aufruf initiiert <xref:System.Windows.Threading.Dispatcher.Run%2A>.  
  
 Der Hauptausführungsframe wird fortgesetzt, bis die <xref:System.Windows.Threading.Dispatcher> beendet wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShutdownFinished">
      <MemberSignature Language="C#" Value="public event EventHandler ShutdownFinished;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ShutdownFinished" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Threading.Dispatcher.ShutdownFinished" />
      <MemberSignature Language="VB.NET" Value="Public Event ShutdownFinished As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ShutdownFinished;" />
      <MemberSignature Language="F#" Value="member this.ShutdownFinished : EventHandler " Usage="member this.ShutdownFinished : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn der <see cref="T:System.Windows.Threading.Dispatcher" /> die Beendigung abschließt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Prozess des Herunterfahrens von eine <xref:System.Windows.Threading.Dispatcher> gestartet wird, der <xref:System.Windows.Threading.Dispatcher.ShutdownStarted> Ereignis wird ausgelöst, und <xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> nastaven NA hodnotu `true`.  
  
 Die <xref:System.Windows.Threading.Dispatcher> wird vollständig beendet, bis die Ereigniswarteschlange entladen.  
  
 Wenn der Verteiler die Beendigung, die <xref:System.Windows.Threading.Dispatcher.ShutdownFinished> Ereignis wird ausgelöst, und die <xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A> -Eigenschaftensatz auf `true`.  
  
 Nachdem der Prozess des Herunterfahrens eingeleitet wurde, werden alle ausstehenden Arbeit Elemente in der Warteschlange abgebrochen.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Threading.Dispatcher.HasShutdownFinished" />
        <altmember cref="P:System.Windows.Threading.Dispatcher.HasShutdownStarted" />
        <altmember cref="M:System.Windows.Threading.Dispatcher.BeginInvokeShutdown(System.Windows.Threading.DispatcherPriority)" />
        <altmember cref="M:System.Windows.Threading.Dispatcher.InvokeShutdown" />
      </Docs>
    </Member>
    <Member MemberName="ShutdownStarted">
      <MemberSignature Language="C#" Value="public event EventHandler ShutdownStarted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ShutdownStarted" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Threading.Dispatcher.ShutdownStarted" />
      <MemberSignature Language="VB.NET" Value="Public Event ShutdownStarted As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ShutdownStarted;" />
      <MemberSignature Language="F#" Value="member this.ShutdownStarted : EventHandler " Usage="member this.ShutdownStarted : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn der <see cref="T:System.Windows.Threading.Dispatcher" /> die Beendigung beginnt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Prozess des Herunterfahrens von eine <xref:System.Windows.Threading.Dispatcher> gestartet wird, der <xref:System.Windows.Threading.Dispatcher.ShutdownStarted> Ereignis wird ausgelöst, und <xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> nastaven NA hodnotu `true`.  
  
 Die <xref:System.Windows.Threading.Dispatcher> wird vollständig beendet, bis die Ereigniswarteschlange entladen.  
  
 Wenn der Verteiler die Beendigung, die <xref:System.Windows.Threading.Dispatcher.ShutdownFinished> Ereignis wird ausgelöst, und die <xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A> -Eigenschaftensatz auf `true`.  
  
 Nachdem der Prozess des Herunterfahrens eingeleitet wurde, werden alle ausstehenden Arbeit Elemente in der Warteschlange abgebrochen.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Threading.Dispatcher.HasShutdownStarted" />
        <altmember cref="E:System.Windows.Threading.Dispatcher.ShutdownFinished" />
        <altmember cref="M:System.Windows.Threading.Dispatcher.BeginInvokeShutdown(System.Windows.Threading.DispatcherPriority)" />
        <altmember cref="M:System.Windows.Threading.Dispatcher.InvokeShutdown" />
      </Docs>
    </Member>
    <Member MemberName="Thread">
      <MemberSignature Language="C#" Value="public System.Threading.Thread Thread { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.Thread Thread" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Threading.Dispatcher.Thread" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Thread As Thread" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::Thread ^ Thread { System::Threading::Thread ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Thread : System.Threading.Thread" Usage="System.Windows.Threading.Dispatcher.Thread" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Thread</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Thread ab, dem dieser <see cref="T:System.Windows.Threading.Dispatcher" /> zugeordnet ist.</summary>
        <value>Der Thread.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnhandledException">
      <MemberSignature Language="C#" Value="public event System.Windows.Threading.DispatcherUnhandledExceptionEventHandler UnhandledException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Threading.DispatcherUnhandledExceptionEventHandler UnhandledException" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Threading.Dispatcher.UnhandledException" />
      <MemberSignature Language="VB.NET" Value="Public Event UnhandledException As DispatcherUnhandledExceptionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Threading::DispatcherUnhandledExceptionEventHandler ^ UnhandledException;" />
      <MemberSignature Language="F#" Value="member this.UnhandledException : System.Windows.Threading.DispatcherUnhandledExceptionEventHandler " Usage="member this.UnhandledException : System.Windows.Threading.DispatcherUnhandledExceptionEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherUnhandledExceptionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn eine Threadausnahme ausgelöst und während der Ausführung eines Delegaten mit <see cref="Overload:System.Windows.Threading.Dispatcher.Invoke" /> oder <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" /> nicht abgefangen wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis wird ausgelöst, wenn eine Ausnahme, die während der Ausführung eines Delegaten, der ausgelöst wurde <xref:System.Windows.Threading.Dispatcher.Invoke%2A> oder <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> nicht abgefangen wird.  
  
 Ein Handler kann die Ausnahme als behandelt markieren, die wird die interne Ausnahme-Handler nicht aufgerufen wird.  
  
 Ereignishandler für dieses Ereignis müssen mit Vorsicht zu vermeiden, Erstellen von sekundären Ausnahmen und abfängt alle, die auftreten, geschrieben werden. Es wird empfohlen, um zu vermeiden, Zuweisen von Speicher oder keine im Ereignishandler-intensive Vorgänge durchzuführen.  
  
 Die <xref:System.Windows.Threading.Dispatcher.UnhandledExceptionFilter> Ereignis bietet eine Möglichkeit zum Auslösen der <xref:System.Windows.Threading.Dispatcher.UnhandledException> Ereignis.  Die <xref:System.Windows.Threading.Dispatcher.UnhandledExceptionFilter> Ereignis wird zuerst ausgelöst und, wenn <xref:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs.RequestCatch%2A> auf die <xref:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs> nastaven NA hodnotu `false`, <xref:System.Windows.Threading.Dispatcher.UnhandledException> Ereignis nicht ausgelöst.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Threading.DispatcherUnhandledExceptionEventHandler" />
        <altmember cref="T:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="UnhandledExceptionFilter">
      <MemberSignature Language="C#" Value="public event System.Windows.Threading.DispatcherUnhandledExceptionFilterEventHandler UnhandledExceptionFilter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Threading.DispatcherUnhandledExceptionFilterEventHandler UnhandledExceptionFilter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Threading.Dispatcher.UnhandledExceptionFilter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event UnhandledExceptionFilter As DispatcherUnhandledExceptionFilterEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Threading::DispatcherUnhandledExceptionFilterEventHandler ^ UnhandledExceptionFilter;" />
      <MemberSignature Language="F#" Value="member this.UnhandledExceptionFilter : System.Windows.Threading.DispatcherUnhandledExceptionFilterEventHandler " Usage="member this.UnhandledExceptionFilter : System.Windows.Threading.DispatcherUnhandledExceptionFilterEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherUnhandledExceptionFilterEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn eine Threadausnahme ausgelöst und nicht abgefangen wird, während ein Delegat mit <see cref="Overload:System.Windows.Threading.Dispatcher.Invoke" /> oder <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" /> ausgeführt wird und sich in der Filterstufe befindet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis wird ausgelöst, während der Phase der Filter für eine Ausnahme, die ausgelöst wird, während der Ausführung eines Delegaten mit <xref:System.Windows.Threading.Dispatcher.Invoke%2A> oder <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> und nicht abgefangen wird.  
  
 Die Aufrufliste ist nicht an dieser Stelle (erste Chance Ausnahme) entladen.  
  
 Ereignishandler für dieses Ereignis müssen mit Vorsicht zu vermeiden, Erstellen von sekundären Ausnahmen und abfängt alle, die auftreten, geschrieben werden.  Es wird empfohlen, um zu vermeiden, Zuweisen von Speicher oder keine im Ereignishandler-intensive Vorgänge durchzuführen.  
  
 Die <xref:System.Windows.Threading.Dispatcher.UnhandledExceptionFilter> Ereignis bietet eine Möglichkeit zum Auslösen der <xref:System.Windows.Threading.Dispatcher.UnhandledException> Ereignis.  Die <xref:System.Windows.Threading.Dispatcher.UnhandledExceptionFilter> Ereignis wird zuerst ausgelöst und, wenn <xref:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs.RequestCatch%2A> auf die <xref:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs> nastaven NA hodnotu `false`, <xref:System.Windows.Threading.Dispatcher.UnhandledException> Ereignis nicht ausgelöst.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">für das Hinzufügen oder entfernen einen Handler für dieses Ereignis.  Zugeordnete Enumerationen:  <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventHandler" />
        <altmember cref="T:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="ValidatePriority">
      <MemberSignature Language="C#" Value="public static void ValidatePriority (System.Windows.Threading.DispatcherPriority priority, string parameterName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ValidatePriority(valuetype System.Windows.Threading.DispatcherPriority priority, string parameterName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.ValidatePriority(System.Windows.Threading.DispatcherPriority,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ValidatePriority (priority As DispatcherPriority, parameterName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ValidatePriority(System::Windows::Threading::DispatcherPriority priority, System::String ^ parameterName);" />
      <MemberSignature Language="F#" Value="static member ValidatePriority : System.Windows.Threading.DispatcherPriority * string -&gt; unit" Usage="System.Windows.Threading.Dispatcher.ValidatePriority (priority, parameterName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="parameterName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="priority">Die zu überprüfende Priorität.</param>
        <param name="parameterName">Eine Zeichenfolge, die von der Ausnahme zurückgegeben wird, die auftritt, wenn die Priorität ungültig ist.</param>
        <summary>Ermittelt, ob die angegebene <see cref="T:System.Windows.Threading.DispatcherPriority" /> eine gültige Priorität ist.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="priority" /> ist kein gültiger <see cref="T:System.Windows.Threading.DispatcherPriority" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="VerifyAccess">
      <MemberSignature Language="C#" Value="public void VerifyAccess ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void VerifyAccess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.VerifyAccess" />
      <MemberSignature Language="VB.NET" Value="Public Sub VerifyAccess ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void VerifyAccess();" />
      <MemberSignature Language="F#" Value="member this.VerifyAccess : unit -&gt; unit" Usage="dispatcher.VerifyAccess " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Bestimmt, ob der aufrufende Thread auf dieses <see cref="T:System.Windows.Threading.Dispatcher" /> zugreifen kann.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nur der Thread die <xref:System.Windows.Threading.Dispatcher> wird erstellt, auf der möglicherweise Zugriff auf die <xref:System.Windows.Threading.Dispatcher>.  
  
 Diese Methode ist öffentlich. Jeder Thread kann daher überprüfen, um festzustellen, ob Zugriff hat die <xref:System.Windows.Threading.Dispatcher>.  
  
 Der Unterschied zwischen <xref:System.Windows.Threading.Dispatcher.CheckAccess%2A> und <xref:System.Windows.Threading.Dispatcher.VerifyAccess%2A> ist <xref:System.Windows.Threading.Dispatcher.CheckAccess%2A> gibt einen booleschen Wert zurück, wenn der aufrufende Thread keinen Zugriff auf die <xref:System.Windows.Threading.Dispatcher> und <xref:System.Windows.Threading.Dispatcher.VerifyAccess%2A> löst eine Ausnahme aus.  
  
   
  
## Examples  
 Im folgenden Beispiel wird <xref:System.Windows.Threading.Dispatcher.VerifyAccess%2A> bestimmen, ob ein Thread Zugriff auf den Thread verfügt, die eine <xref:System.Windows.Controls.Button> erstellt wurde.  Die Methode akzeptiert ein Objekt als Argument, das umgewandelt wird eine <xref:System.Windows.Controls.Button>.  Die <xref:System.Windows.Threading.Dispatcher.VerifyAccess%2A> Methode für die <xref:System.Windows.Threading.Dispatcher> von der <xref:System.Windows.Controls.Button> wird aufgerufen, um den Zugriff auf den Thread zu überprüfen.  
  
 Verfügt der aufrufende Thread den Zugriff auf die <xref:System.Windows.Threading.Dispatcher>, <xref:System.Windows.Controls.Button> wird aktualisiert, indem Sie auf die Member, der die <xref:System.Windows.Controls.Button>.  
  
 Wenn der aufrufende Thread keinen Zugriff auf eine <xref:System.InvalidOperationException> ausgelöst.  In diesem Beispiel fängt die Ausnahme ab und legt einen Delegaten, die akzeptiert eine <xref:System.Windows.Controls.Button> als Argument auf den <xref:System.Windows.Threading.Dispatcher> von der <xref:System.Windows.Controls.Button>.  Dies <xref:System.Windows.Threading.Dispatcher> erfolgt die Arbeit der Aktualisierung der <xref:System.Windows.Controls.Button>.  
  
 [!code-csharp[DispatcherAccessSample#DispatcherAccessVerifyAccess](~/samples/snippets/csharp/VS_Snippets_Wpf/DispatcherAccessSample/CSharp/Window1.xaml.cs#dispatcheraccessverifyaccess)]
 [!code-vb[DispatcherAccessSample#DispatcherAccessVerifyAccess](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DispatcherAccessSample/visualbasic/window1.xaml.vb#dispatcheraccessverifyaccess)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der aufrufende Thread kann nicht auf diesen <see cref="T:System.Windows.Threading.Dispatcher" /> zugreifen.</exception>
        <altmember cref="M:System.Windows.Threading.Dispatcher.CheckAccess" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Yield">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt ein Awaitable-Objekt, welches ansynchron das Steuerelement an den aktuellen Verteiler zurückgibt und dem Verteiler die Gelegenheit gibt, andere Ereignisse zu verarbeiten.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Yield">
      <MemberSignature Language="C#" Value="public static System.Windows.Threading.DispatcherPriorityAwaitable Yield ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.Threading.DispatcherPriorityAwaitable Yield() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Yield" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Yield () As DispatcherPriorityAwaitable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Threading::DispatcherPriorityAwaitable Yield();" />
      <MemberSignature Language="F#" Value="static member Yield : unit -&gt; System.Windows.Threading.DispatcherPriorityAwaitable" Usage="System.Windows.Threading.Dispatcher.Yield " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherPriorityAwaitable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt ein Awaitable-Objekt, welches ansynchron das Steuerelement an den aktuellen Verteiler zurückgibt und dem Verteiler die Gelegenheit gibt, andere Ereignisse zu verarbeiten.</summary>
        <returns>Ein awaitable-Objekt, das asynchron dem aktuellen Verteiler Steuerelemente zurückgibt und dem Verteiler die Gelegenheit gibt, andere Ereignisse zu verarbeiten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode bietet eine Möglichkeit für Sie vorübergehend die ausführungssteuerung an den aktuellen Verteiler freigegeben, damit hierfür andere Aufgaben, z. B. andere Ereignisse zu verarbeiten. Verwenden der `await`, oder `Await` in Visual Basic Operator für den Rückgabewert, um die Steuerung an den aktuellen Verteiler zurückzugeben. Verwenden Sie diese Methode, wenn Ihrer app bieten die Möglichkeit, Ereignisse zu verarbeiten, während Ihre app sehr viel Arbeit im UI-Thread ausführt werden soll. Beispielsweise können diese Methode in einer lang andauernden Schleife Sie, die ein Steuerelement aktualisiert.  
  
 Diese Methode entspricht dem Aufrufen der <xref:System.Windows.Threading.Dispatcher.Yield%28System.Windows.Threading.DispatcherPriority%29> -Methode und übergeben <xref:System.Windows.Threading.DispatcherPriority.Background?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Yield">
      <MemberSignature Language="C#" Value="public static System.Windows.Threading.DispatcherPriorityAwaitable Yield (System.Windows.Threading.DispatcherPriority priority);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.Threading.DispatcherPriorityAwaitable Yield(valuetype System.Windows.Threading.DispatcherPriority priority) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Yield(System.Windows.Threading.DispatcherPriority)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Yield (priority As DispatcherPriority) As DispatcherPriorityAwaitable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Threading::DispatcherPriorityAwaitable Yield(System::Windows::Threading::DispatcherPriority priority);" />
      <MemberSignature Language="F#" Value="static member Yield : System.Windows.Threading.DispatcherPriority -&gt; System.Windows.Threading.DispatcherPriorityAwaitable" Usage="System.Windows.Threading.Dispatcher.Yield priority" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherPriorityAwaitable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
      </Parameters>
      <Docs>
        <param name="priority">Die Priorität, mit der die Fortsetzung geplant werden soll.</param>
        <summary>Erstellt ein Awaitable-Objekt, welches ansynchron das Steuerelement an den aktuellen Verteiler zurückgibt und dem Verteiler die Gelegenheit gibt, andere Ereignisse zu verarbeiten.  Die Arbeit, welche auftritt, wenn das Steuerelement an den Code zurückgibt, der auf das Ergebnis dieser Methode wartet, die mit der angegebenen Priorität geplant wurde.</summary>
        <returns>Ein awaitable-Objekt, das asynchron dem aktuellen Verteiler Steuerelemente zurückgibt und dem Verteiler die Gelegenheit gibt, andere Ereignisse zu verarbeiten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode bietet eine Möglichkeit für Sie vorübergehend die ausführungssteuerung an den aktuellen Verteiler freigegeben, damit hierfür andere Aufgaben, z. B. andere Ereignisse zu verarbeiten. Verwenden der `await`, oder `Await` in Visual Basic Operator für den Rückgabewert, um die Steuerung an den aktuellen Verteiler zurückzugeben. Verwenden Sie diese Methode, wenn Ihrer app bieten die Möglichkeit, Ereignisse zu verarbeiten, während Ihre app sehr viel Arbeit im UI-Thread ausführt werden soll. Beispielsweise können diese Methode in einer lang andauernden Schleife Sie, die ein Steuerelement aktualisiert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>