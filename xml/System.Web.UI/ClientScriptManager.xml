<Type Name="ClientScriptManager" FullName="System.Web.UI.ClientScriptManager">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="595c533e1f99dcfb2145f168002ef3ab46df3d2d" />
    <Meta Name="ms.sourcegitcommit" Value="16d2d159872fd213cae4b8f371d7ae9c8b027c89" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="11/17/2018" />
    <Meta Name="ms.locfileid" Value="51886211" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class ClientScriptManager" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ClientScriptManager extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.ClientScriptManager" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ClientScriptManager" />
  <TypeSignature Language="C++ CLI" Value="public ref class ClientScriptManager sealed" />
  <TypeSignature Language="F#" Value="type ClientScriptManager = class" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Definiert Methoden zum Verwalten von Clientskripts in Webanwendungen.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.ClientScriptManager> Klasse wird verwendet, um das Verwalten von Clientskripts und Webanwendungen hinzufügen. Erhalten Sie einen Verweis auf die <xref:System.Web.UI.ClientScriptManager> -Klasse aus der <xref:System.Web.UI.Page.ClientScript%2A> Eigenschaft der <xref:System.Web.UI.Page> Objekt.  
  
 Sie können ein Clientskript deklarativ zu einer Webseite hinzufügen, indem Sie das Skript in das HTML-Markup der Seite einschließen. Es gibt jedoch Situationen, in dynamisch Hinzufügen eines Clientskripts erforderlich ist. Um ein Skript dynamisch hinzuzufügen, verwenden die <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> -Methode, die <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> -Methode, die <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> -Methode, oder die <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A> -Methode, je nachdem, wann und wie Sie das Skript hinzufügen möchten. Weitere Informationen finden Sie unter [Vorgehensweise: Hinzufügen Client Skript dynamisch für ASP.NET Web Pages](https://msdn.microsoft.com/library/e89f1306-e43d-49ae-a66a-e18b71007666).  
  
 Die <xref:System.Web.UI.ClientScriptManager> Klasse eindeutig identifiziert Skripts mit einem Schlüssel <xref:System.String> und <xref:System.Type>. Skripts mit den gleichen Schlüssel und Typ werden als Duplikate betrachtet. Mithilfe von Skripttyp auswählen können, um verwirrend ähnliche Skripts von verschiedenen Benutzersteuerelemente zu vermeiden, die auf der Seite verwendet werden kann.  
  
 Die <xref:System.Web.UI.ClientScriptManager> Klasse kann verwendet werden, um Clientrückrufe in Situationen Servercode ohne einen Postback vom Client ausgeführt werden. Dies wird als einen Out-of-Band-Rückruf an den Server ausführen bezeichnet. Bei einem Clientrückruf sendet eine Clientskriptfunktion eine asynchrone Anforderung auf einer ASP.NET-Webseite an. Die Webseite wird eine geänderte Version des normalen Lebenszyklus den Prozess der Rückruf ausgeführt. Verwenden der <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> Methode, um einem Verweis auf eine Clientfunktion abzurufen, die beim Aufrufen, wird ein Clientrückrufs an ein Serverereignis initiiert. Weitere Informationen finden Sie unter [implementieren Sie Client-Callbacks ohne Postbacks](https://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185).  
  
> [!NOTE]
>  Skript-Rückrufe funktioniert nicht in älteren Browsern, die nicht (DOKUMENTOBJEKTMODELL unterstützen), und sie erfordern, dass ECMAScript auf dem Client aktiviert ist. Verwenden, um festzustellen, ob der Browser Rückrufe unterstützt, die <xref:System.Web.Configuration.HttpCapabilitiesBase.SupportsCallback%2A> Eigenschaft, die über die <xref:System.Web.HttpRequest.Browser%2A> -Eigenschaft des ASP.NET-systeminterne <xref:System.Web.HttpContext.Request%2A> Objekt.  
  
 Verwenden der <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> Methode und die <xref:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink%2A> Methode, um ein postback-Ereignis des Clients zu definieren. Diese Methoden ermöglichen die Client-Skriptfunktionen, wenn aufgerufen, um die dazu führen, dass den Server zum Zurücksenden an die Seite. Ein Client-postback-Ereignis unterscheidet sich von einem Clientrückruf, dass die Webseite einen normalen Lebenszyklus, den Prozess der Client-postback-Ereignis abgeschlossen ist.  
  
> [!NOTE]
>  Bei Verwendung einer <xref:System.Web.UI.WebControls.Button> Steuerelement und die <xref:System.Web.UI.WebControls.Button.UseSubmitBehavior%2A> -Eigenschaftensatz auf `false`, anschließend können Sie die <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> Methode, um den Client zurückzugeben postback-Ereignis für die <xref:System.Web.UI.WebControls.Button> Steuerelement.  
  
 Die <xref:System.Web.UI.WebControls.Button.OnClientClick%2A> Eigenschaft der <xref:System.Web.UI.WebControls.Button> Steuerelement <xref:System.Web.UI.WebControls.ImageButton> -Steuerelement, und <xref:System.Web.UI.WebControls.LinkButton> -Steuerelement kann verwendet werden, um Clientskript auszuführen.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> Methode der <xref:System.Web.UI.ClientScriptManager> Klasse. Zwei Clientskripts auf der Seite definiert sind: `PopupScript`, die eine Warnmeldung zeigt an, wenn die Seite geladen wird, und `ButtonClickScript`, das definiert, dass eines Client-Handlers für einer HTML-Schaltfläche `onClick` Ereignis.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb.aspx#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Web.UI.Page" />
    <altmember cref="P:System.Web.Configuration.HttpCapabilitiesBase.SupportsCallback" />
    <altmember cref="P:System.Web.Configuration.HttpCapabilitiesBase.SupportsXmlHttp" />
    <related type="Article" href="https://msdn.microsoft.com/library/13edb6b9-2dea-43c6-b8c1-a47207de19aa">Clientskript in ASP.NET Web Pages</related>
    <related type="Article" href="https://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185">Clientrückrufe ohne Postbacks in ASP.NET-Seiten</related>
  </Docs>
  <Members>
    <MemberGroup MemberName="GetCallbackEventReference">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft einen Verweis auf eine Clientfunktion ab, die beim Aufruf einen Clientrückruf für ein Serverereignis initiiert.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCallbackEventReference">
      <MemberSignature Language="C#" Value="public string GetCallbackEventReference (System.Web.UI.Control control, string argument, string clientCallback, string context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetCallbackEventReference(class System.Web.UI.Control control, string argument, string clientCallback, string context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetCallbackEventReference(System.Web.UI.Control,System.String,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetCallbackEventReference(System::Web::UI::Control ^ control, System::String ^ argument, System::String ^ clientCallback, System::String ^ context);" />
      <MemberSignature Language="F#" Value="member this.GetCallbackEventReference : System.Web.UI.Control * string * string * string -&gt; string" Usage="clientScriptManager.GetCallbackEventReference (control, argument, clientCallback, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="clientCallback" Type="System.String" />
        <Parameter Name="context" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">Das Server-<see cref="T:System.Web.UI.Control" />, das den Clientrückruf behandelt. Das Steuerelement muss die <see cref="T:System.Web.UI.ICallbackEventHandler" />-Schnittstelle implementieren und eine <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" />-Methode bereitstellen.</param>
        <param name="argument">Ein Argument, das vom Clientskript an den Server übergeben wird. 
 <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" /> -Methode.</param>
        <param name="clientCallback">Der Name des Clientereignishandlers, der das Ergebnis des erfolgreich ausgeführten Serverereignisses empfängt.</param>
        <param name="context">Clientskript, das auf dem Client vor der Initialisierung des Rückrufs ausgewertet wird. Das Ergebnis des Skripts wird an den Clientereignishandler zurückgegeben.</param>
        <summary>Ruft einen Verweis auf eine Clientfunktion ab, die beim Aufruf einen Clientrückruf für ein Serverereignis initiiert. Die Clientfunktion für diese überladene Methode schließt ein angegebenes Steuerelement, ein Argument, ein Clientskript sowie einen Kontext ein.</summary>
        <returns>Der Name einer Clientfunktion, die den Clientrückruf ausführt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%28System.Web.UI.Control%2CSystem.String%2CSystem.String%2CSystem.String%29> -Methode führt einen Out-of-Band-Rückruf an den Server, die eine geänderte Version des normalen Lebenszyklus einer Seite ist. Weitere Informationen finden Sie unter [implementieren Sie Client-Callbacks ohne Postbacks](https://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185).  
  
> [!NOTE]
>  Wenn der Browser Microsoft Internet Explorer (Version 5.0 oder höher) ist, wird der Skriptrückrufmechanismus wird über das Microsoft.XmlHttp COM-Objekt implementiert und verlangt, dass der Browser zur Ausführung von ActiveX-Steuerelemente. Für andere Browser wird ein XMLHttpRequest mithilfe des Browsers lokalen (DOKUMENTOBJEKTMODELL) verwendet. Verwenden Sie zum Überprüfen, ob ein Browser Clientrückrufe unterstützt die <xref:System.Web.Configuration.HttpCapabilitiesBase.SupportsCallback%2A> Eigenschaft. Verwenden Sie zum Überprüfen, ob ein Browser XML über HTTP unterstützt die <xref:System.Web.Configuration.HttpCapabilitiesBase.SupportsXmlHttp%2A> Eigenschaft. Beide Eigenschaften stehen über die <xref:System.Web.HttpRequest.Browser%2A> Eigenschaft des systeminternen ASP <xref:System.Web.HttpContext.Request%2A> Objekt.  
  
 Die <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> Überladung von der <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> -Methode führt einen Rückruf synchron mit XML über HTTP. Beim Senden von Daten synchron in ein Szenario, synchrone Rückrufe sofort zurückgegeben, und blockieren sich nicht auf den Browser. Keine zwei synchrone Rückrufe kann zur gleichen Zeit im Browser ausführen. Ein zweiter synchroner Rückruf ausgelöst, während eine zurzeit aussteht, der zweiten synchronen Rückruf abgebrochen, die erste und nur der zweite Rückruf zurück.  
  
 Um Daten asynchron senden zu können, verwenden Sie eine der Überladungen, die die `useAsync` -Parameter, der ein boolescher Wert ist Wert, der dieses Verhalten steuern. In einem asynchronen Szenario haben Sie mehrere ausstehende Rückrufe; Allerdings ist die Reihenfolge, in der sie zurückgibt, nicht garantiert, entsprechend die Reihenfolge, in der sie initiiert wurden.  
  
 Darüber hinaus diese Überladung von der <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> Methode gibt keine Clientfunktion zur Verarbeitung der Fehlerzustand generiert, indem Sie der Groß-/Kleinschreibung der <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A> Methode. Um einen Rückrufhandler für Client-Fehler anzugeben, verwenden Sie eine der Überladungen, die die `clientErrorCallback` Parameter.  
  
 Die <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%28System.Web.UI.Control%2CSystem.String%2CSystem.String%2CSystem.String%29> Methode akzeptiert eine optionale Zeichenfolge `argument` Parameter und gibt eine Zeichenfolge zurück. Übergeben oder mehrere Werte zu erhalten, verketten Sie die Werte in der Eingabe oder jeweils.  
  
> [!NOTE]
>  Verwenden Sie den Ansichtszustand in der Implementierung der Seite oder das Steuerelement Eigenschaften, die während der Skriptvorgänge-Rückruf aktualisiert werden müssen. Wenn die Eigenschaften sind Seitenanforderungen überstehen, können Sie den Sitzungsstatus verwenden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit zwei Überladungen der <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> -Methode in einem Clientrückruf an, die ganzen Zahlen inkrementiert.  
  
 Es werden zwei Rückrufmechanismen zur angezeigt; der Unterschied zwischen ihnen ist die Verwendung von der `context` Parameter. Ein `ReceiveServerData1` Client Callback-Funktion wird bereitgestellt, mit der `context` Parameter. Im Gegensatz dazu die `ReceiveServerData2` Client Callback-Funktion wird definiert, einem `<script>` -Block auf der Seite. Ein <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A> Methode ist der Serverhandler, der der Wert erhöht wird, die an ihn übergeben wird und die <xref:System.Web.UI.ICallbackEventHandler.GetCallbackResult%2A> Methode gibt den inkrementierten Wert als Zeichenfolge zurück. Wenn die <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A> Methode ein Fehler zurückgegeben, und klicken Sie dann die `ProcessCallBackError` Clientfunktion wird aufgerufen.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager7#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager7/cs/getcallbackeventreference.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager7#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager7/vb/getcallbackeventreference.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der angegebene <see cref="T:System.Web.UI.Control" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Das angegebene <see cref="T:System.Web.UI.Control" /> implementiert die <see cref="T:System.Web.UI.ICallbackEventHandler" />-Schnittstelle nicht.</exception>
        <altmember cref="T:System.Web.UI.ICallbackEventHandler" />
        <related type="Article" href="https://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185">Clientrückrufe ohne Postbacks in ASP.NET-Seiten</related>
      </Docs>
    </Member>
    <Member MemberName="GetCallbackEventReference">
      <MemberSignature Language="C#" Value="public string GetCallbackEventReference (System.Web.UI.Control control, string argument, string clientCallback, string context, bool useAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetCallbackEventReference(class System.Web.UI.Control control, string argument, string clientCallback, string context, bool useAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetCallbackEventReference(System.Web.UI.Control,System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetCallbackEventReference(System::Web::UI::Control ^ control, System::String ^ argument, System::String ^ clientCallback, System::String ^ context, bool useAsync);" />
      <MemberSignature Language="F#" Value="member this.GetCallbackEventReference : System.Web.UI.Control * string * string * string * bool -&gt; string" Usage="clientScriptManager.GetCallbackEventReference (control, argument, clientCallback, context, useAsync)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="clientCallback" Type="System.String" />
        <Parameter Name="context" Type="System.String" />
        <Parameter Name="useAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">Das Server-<see cref="T:System.Web.UI.Control" />, das den Clientrückruf behandelt. Das Steuerelement muss die <see cref="T:System.Web.UI.ICallbackEventHandler" />-Schnittstelle implementieren und eine <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" />-Methode bereitstellen.</param>
        <param name="argument">Ein Argument, das vom Clientskript an den Server übergeben wird. 
 <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" /> -Methode.</param>
        <param name="clientCallback">Der Name des Clientereignishandlers, der das Ergebnis des erfolgreich ausgeführten Serverereignisses empfängt.</param>
        <param name="context">Clientskript, das auf dem Client vor der Initialisierung des Rückrufs ausgewertet wird. Das Ergebnis des Skripts wird an den Clientereignishandler zurückgegeben.</param>
        <param name="useAsync">
          <see langword="true" />, um den Rückruf asynchron auszuführen, <see langword="false" />, um den Rückruf synchron auszuführen.</param>
        <summary>Ruft einen Verweis auf eine Clientfunktion ab, die beim Aufruf einen Clientrückruf für Serverereignisse initiiert. Die Clientfunktion für diese überladene Methode schließt ein angegebenes Steuerelement, ein Argument, ein Clientskript, einen Kontext sowie einen booleschen Wert ein.</summary>
        <returns>Der Name einer Clientfunktion, die den Clientrückruf ausführt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung von der <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> Methode erfordert eine `useAsync` -Parameter, der Ihnen ermöglicht, das den Clientrückruf asynchron ausführen, durch Festlegen des Werts auf `true`. Die Überladungsversionen dieser Methode, die keine erfordern die `useAsync` Parameter legen Sie den Wert `false` standardmäßig.  
  
 Weitere Informationen zu dieser Methode finden Sie unter den Hinweisen für die Überladung <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der angegebene <see cref="T:System.Web.UI.Control" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Das angegebene <see cref="T:System.Web.UI.Control" /> implementiert die <see cref="T:System.Web.UI.ICallbackEventHandler" />-Schnittstelle nicht.</exception>
        <altmember cref="T:System.Web.UI.ICallbackEventHandler" />
        <related type="Article" href="https://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185">Clientrückrufe ohne Postbacks in ASP.NET-Seiten</related>
      </Docs>
    </Member>
    <Member MemberName="GetCallbackEventReference">
      <MemberSignature Language="C#" Value="public string GetCallbackEventReference (string target, string argument, string clientCallback, string context, string clientErrorCallback, bool useAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetCallbackEventReference(string target, string argument, string clientCallback, string context, string clientErrorCallback, bool useAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetCallbackEventReference(System.String,System.String,System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCallbackEventReference (target As String, argument As String, clientCallback As String, context As String, clientErrorCallback As String, useAsync As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetCallbackEventReference(System::String ^ target, System::String ^ argument, System::String ^ clientCallback, System::String ^ context, System::String ^ clientErrorCallback, bool useAsync);" />
      <MemberSignature Language="F#" Value="member this.GetCallbackEventReference : string * string * string * string * string * bool -&gt; string" Usage="clientScriptManager.GetCallbackEventReference (target, argument, clientCallback, context, clientErrorCallback, useAsync)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.String" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="clientCallback" Type="System.String" />
        <Parameter Name="context" Type="System.String" />
        <Parameter Name="clientErrorCallback" Type="System.String" />
        <Parameter Name="useAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="target">Der Name von einem Server-<see cref="T:System.Web.UI.Control" />, das den Clientrückruf behandelt. Das Steuerelement muss die <see cref="T:System.Web.UI.ICallbackEventHandler" />-Schnittstelle implementieren und eine <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" />-Methode bereitstellen.</param>
        <param name="argument">Ein Argument, das vom Clientskript an den Server übergeben wird. 
 <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" /> -Methode.</param>
        <param name="clientCallback">Der Name des Clientereignishandlers, der das Ergebnis des erfolgreich ausgeführten Serverereignisses empfängt.</param>
        <param name="context">Clientskript, das auf dem Client vor der Initialisierung des Rückrufs ausgewertet wird. Das Ergebnis des Skripts wird an den Clientereignishandler zurückgegeben.</param>
        <param name="clientErrorCallback">Der Name des Clientereignishandlers, der das Ergebnis empfängt, wenn ein Fehler im Serverereignishandler auftritt.</param>
        <param name="useAsync">
          <see langword="true" />, um den Rückruf asynchron auszuführen, <see langword="false" />, um den Rückruf synchron auszuführen.</param>
        <summary>Ruft einen Verweis auf eine Clientfunktion ab, die beim Aufruf einen Clientrückruf für Serverereignisse initiiert. Die Clientfunktion für diese überladene Methode schließt ein angegebenes Ziel, ein Argument, ein Clientskript, einen Kontext, einen Fehlerhandler sowie einen booleschen Wert ein.</summary>
        <returns>Der Name einer Clientfunktion, die den Clientrückruf ausführt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung von der <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> -Methode übernimmt eine `target` Zeichenfolgenparameter anstelle von einer <xref:System.Web.UI.Control> Parameter. Wenn Sie den Rückruf zu etwas anderes als eine Zeichenfolge mit zurückkehren möchten, verwenden Sie diese Überladung der <xref:System.Web.UI.Control.UniqueID%2A> des Steuerelements.  
  
 Darüber hinaus diese Überladung von der <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> Methode erfordert eine `useAsync` und `clientErrorCallback` Parameter. Die `useAsync` Parameter können Sie den Clientrückruf asynchron durchführen, indem Sie den Wert auf `true`. Die Überladungsversionen dieser Methode, die keine erfordern die `useAsync` Parameter legen Sie den Wert `false` standardmäßig. Die `clientErrorCallback` Parameter können Sie den Namen der Clientfunktion zu definieren, die aufgerufen wird, wenn den Serverhandler für, die <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A> -Methode gibt einen Fehler zurück. Die Überladungsversionen dieser Methode, die keine erfordern die `clientErrorCallback` -Parameter den Wert auf null festgelegt.  
  
 Weitere Informationen zu dieser Methode finden Sie unter den Hinweisen für die Überladung <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> Methode.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit zwei Überladungen der <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> -Methode in einem Clientrückruf an, die ganzen Zahlen inkrementiert.  
  
 Es werden zwei Rückrufmechanismen zur angezeigt; der Unterschied zwischen ihnen ist die Verwendung von der `context` Parameter. Ein `ReceiveServerData1` Client Callback-Funktion wird bereitgestellt, mit der `context` Parameter. Im Gegensatz dazu die `ReceiveServerData2` Client Callback-Funktion wird definiert, einem `<script>` -Block auf der Seite. Ein <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A> Methode ist der Serverhandler, der der Wert erhöht wird, die an ihn übergeben wird und die <xref:System.Web.UI.ICallbackEventHandler.GetCallbackResult%2A> Methode gibt den inkrementierten Wert als Zeichenfolge zurück. Wenn die <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A> Methode gibt einen Fehler, und klicken Sie dann auf die Clientfunktion `ProcessCallBackError` aufgerufen wird.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager7#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager7/cs/getcallbackeventreference.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager7#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager7/vb/getcallbackeventreference.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.ICallbackEventHandler" />
        <altmember cref="P:System.Web.UI.Control.UniqueID" />
        <related type="Article" href="https://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185">Clientrückrufe ohne Postbacks in ASP.NET-Seiten</related>
      </Docs>
    </Member>
    <Member MemberName="GetCallbackEventReference">
      <MemberSignature Language="C#" Value="public string GetCallbackEventReference (System.Web.UI.Control control, string argument, string clientCallback, string context, string clientErrorCallback, bool useAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetCallbackEventReference(class System.Web.UI.Control control, string argument, string clientCallback, string context, string clientErrorCallback, bool useAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetCallbackEventReference(System.Web.UI.Control,System.String,System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetCallbackEventReference(System::Web::UI::Control ^ control, System::String ^ argument, System::String ^ clientCallback, System::String ^ context, System::String ^ clientErrorCallback, bool useAsync);" />
      <MemberSignature Language="F#" Value="member this.GetCallbackEventReference : System.Web.UI.Control * string * string * string * string * bool -&gt; string" Usage="clientScriptManager.GetCallbackEventReference (control, argument, clientCallback, context, clientErrorCallback, useAsync)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="clientCallback" Type="System.String" />
        <Parameter Name="context" Type="System.String" />
        <Parameter Name="clientErrorCallback" Type="System.String" />
        <Parameter Name="useAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">Das Server-<see cref="T:System.Web.UI.Control" />, das den Clientrückruf behandelt. Das Steuerelement muss die <see cref="T:System.Web.UI.ICallbackEventHandler" />-Schnittstelle implementieren und eine <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" />-Methode bereitstellen.</param>
        <param name="argument">Ein Argument, das vom Clientskript an die <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" />-Methode des Servers übergeben wird.</param>
        <param name="clientCallback">Der Name des Clientereignishandlers, der das Ergebnis des erfolgreich ausgeführten Serverereignisses empfängt.</param>
        <param name="context">Clientskript, das auf dem Client vor der Initialisierung des Rückrufs ausgewertet wird. Das Ergebnis des Skripts wird an den Clientereignishandler zurückgegeben.</param>
        <param name="clientErrorCallback">Der Name des Clientereignishandlers, der das Ergebnis empfängt, wenn ein Fehler im Serverereignishandler auftritt.</param>
        <param name="useAsync">
          <see langword="true" />, um den Rückruf asynchron auszuführen, <see langword="false" />, um den Rückruf synchron auszuführen.</param>
        <summary>Ruft einen Verweis auf eine Clientfunktion ab, die beim Aufruf einen Clientrückruf für Serverereignisse initiiert. Die Clientfunktion für diese überladene Methode schließt ein angegebenes Steuerelement, ein Argument, ein Clientskript, einen Kontext, einen Fehlerhandler sowie einen booleschen Wert ein.</summary>
        <returns>Der Name einer Clientfunktion, die den Clientrückruf ausführt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung von der <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> Methode erfordert eine `useAsync` und `clientErrorCallback` Parameter. Die `useAsync` Parameter können Sie den Clientrückruf asynchron durchführen, indem Sie den Wert auf `true`. Die Überladungsversionen dieser Methode, die keine erfordern die `useAsync` Parameter legen Sie den Wert `false` standardmäßig. Die `clientErrorCallback` Parameter können Sie den Namen der Clientfunktion zu definieren, die aufgerufen wird, wenn der Server-Handler (den <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A> Methode) gibt einen Fehler zurück. Die Überladungsversionen dieser Methode, die keine erfordern die `clientErrorCallback` -Parameter den Wert auf null festgelegt.  
  
 Weitere Informationen zu dieser Methode finden Sie unter den Hinweisen für die Überladung <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der angegebene <see cref="T:System.Web.UI.Control" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Das angegebene <see cref="T:System.Web.UI.Control" /> implementiert die <see cref="T:System.Web.UI.ICallbackEventHandler" />-Schnittstelle nicht.</exception>
        <altmember cref="T:System.Web.UI.ICallbackEventHandler" />
        <related type="Article" href="https://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185">Clientrückrufe ohne Postbacks in ASP.NET-Seiten</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetPostBackClientHyperlink">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft einen Verweis ab, an dessen Beginn <see langword="javascript:" /> angefügt ist und der in einem Clientereignis für das Postback an den Server verwendet werden kann.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetPostBackClientHyperlink">
      <MemberSignature Language="C#" Value="public string GetPostBackClientHyperlink (System.Web.UI.Control control, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackClientHyperlink(class System.Web.UI.Control control, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink(System.Web.UI.Control,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackClientHyperlink(System::Web::UI::Control ^ control, System::String ^ argument);" />
      <MemberSignature Language="F#" Value="member this.GetPostBackClientHyperlink : System.Web.UI.Control * string -&gt; string" Usage="clientScriptManager.GetPostBackClientHyperlink (control, argument)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">Das Serversteuerelement, das das Postback verarbeiten soll.</param>
        <param name="argument">Der an das Serversteuerelement übergebene Parameter.</param>
        <summary>Ruft einen Verweis ab, an dessen Beginn <see langword="javascript:" /> angefügt ist und der in einem Clientereignis verwendet werden kann, das für das angegebene Steuerelement und mit den angegebenen Ereignisargumenten an den Server zurückgesendet werden soll.</summary>
        <returns>Eine Zeichenfolge, die einen JavaScript-Aufruf der Postbackfunktion darstellt, die ID und Ereignisargumente des Zielsteuerelements enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mithilfe der <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> Methode muss das Steuerelement, das das Postback implementieren behandelt die <xref:System.Web.UI.IPostBackEventHandler> Schnittstelle. Zum Implementieren der <xref:System.Web.UI.IPostBackEventHandler> eine Schnittstelle für eine <xref:System.Web.UI.Page>, verwenden Sie die Direktive.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der <xref:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink%2A> Methode. Das benutzerdefinierte Steuerelement, `MyControl`, implementiert die <xref:System.Web.UI.IPostBackEventHandler> Schnittstelle. Wenn das HTML-Anchor-Element auf der Seite klicken, wird die <xref:System.Web.UI.IPostBackEventHandler.RaisePostBackEvent%2A> Methode des benutzerdefinierten Steuerelements wird aufgerufen.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager8#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/cs/getpostbackeventreferencecs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager8#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/vb/getpostbackeventreferencevb.aspx#1)]  
  
 Im folgenden Codebeispiel wird hat die gleiche Funktion wie im vorangehenden, außer dass ein benutzerdefiniertes Steuerelement, das <xref:System.Web.UI.Page> -Klasse implementiert die <xref:System.Web.UI.IPostBackEventHandler> Schnittstelle.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager8#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/cs/getpostbackeventreference2cs.aspx#2)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager8#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/vb/getpostbackeventreference2vb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.GetPostBackEventReference" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink(System.Web.UI.Control,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="GetPostBackClientHyperlink">
      <MemberSignature Language="C#" Value="public string GetPostBackClientHyperlink (System.Web.UI.Control control, string argument, bool registerForEventValidation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackClientHyperlink(class System.Web.UI.Control control, string argument, bool registerForEventValidation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink(System.Web.UI.Control,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackClientHyperlink(System::Web::UI::Control ^ control, System::String ^ argument, bool registerForEventValidation);" />
      <MemberSignature Language="F#" Value="member this.GetPostBackClientHyperlink : System.Web.UI.Control * string * bool -&gt; string" Usage="clientScriptManager.GetPostBackClientHyperlink (control, argument, registerForEventValidation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="registerForEventValidation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">Das Serversteuerelement, das das Postback verarbeiten soll.</param>
        <param name="argument">Der an das Serversteuerelement übergebene Parameter.</param>
        <param name="registerForEventValidation">
          <see langword="true" />, um das Postbackergebnis für die Validierung zu registrieren, andernfalls <see langword="false" />.</param>
        <summary>Ruft einen Verweis ab, an dessen Beginn <see langword="javascript:" /> angefügt ist und der in einem Clientereignis verwendet werden kann, das für das angegebene Steuerelement mit den angegebenen Ereignisargumenten und dem booleschen Wert, der angibt, ob das Postback für die Ereignisvalidierung registriert werden soll, an den Server zurückgesendet wird.</summary>
        <returns>Eine Zeichenfolge, die einen JavaScript-Aufruf der Postbackfunktion darstellt, die ID und Ereignisargumente des Zielsteuerelements enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mithilfe der <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> Methode muss das Steuerelement, das das Postback implementieren behandelt die <xref:System.Web.UI.IPostBackEventHandler> Schnittstelle. Zum Implementieren der <xref:System.Web.UI.IPostBackEventHandler> eine Schnittstelle für eine <xref:System.Web.UI.Page>, verwenden Sie die Direktive.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.GetPostBackEventReference" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink(System.Web.UI.Control,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetPostBackEventReference">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt eine Zeichenfolge zurück, die in einem Clientereignis zum Auslösen eines Postbacks an den Server verwendet werden kann.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetPostBackEventReference">
      <MemberSignature Language="C#" Value="public string GetPostBackEventReference (System.Web.UI.PostBackOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackEventReference(class System.Web.UI.PostBackOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackEventReference(System.Web.UI.PostBackOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPostBackEventReference (options As PostBackOptions) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackEventReference(System::Web::UI::PostBackOptions ^ options);" />
      <MemberSignature Language="F#" Value="member this.GetPostBackEventReference : System.Web.UI.PostBackOptions -&gt; string" Usage="clientScriptManager.GetPostBackEventReference options" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.Web.UI.PostBackOptions" />
      </Parameters>
      <Docs>
        <param name="options">Eine Instanz von <see cref="T:System.Web.UI.PostBackOptions" />, die das Postback definiert.</param>
        <summary>Gibt eine Zeichenfolge zurück, die in einem Clientereignis zum Auslösen eines Postbacks an den Server verwendet werden kann. Die Verweiszeichenfolge wird von der angegebenen <see cref="T:System.Web.UI.PostBackOptions" />-Instanz definiert.</summary>
        <returns>Eine Zeichenfolge, die das Clientpostback initiiert, wenn sie auf dem Client als Skript behandelt wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zum Implementieren der <xref:System.Web.UI.IPostBackEventHandler> eine Schnittstelle für eine <xref:System.Web.UI.Page>, verwenden Sie die Direktive.  
  
 Die <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> Methode kann verwendet werden, mit der <xref:System.Web.UI.WebControls.Button> steuern, wann die <xref:System.Web.UI.WebControls.Button.UseSubmitBehavior%2A> Eigenschaft `false`. In diesem Szenario die <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> Methodenrückgabe, die das Clientpostback-Ereignis für die <xref:System.Web.UI.WebControls.Button> Steuerelement.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <see cref="T:System.Web.UI.PostBackOptions" />-Parameter ist <see langword="null" />.</exception>
        <altmember cref="T:System.Web.UI.PostBackOptions" />
        <altmember cref="T:System.Web.UI.IPostBackEventHandler" />
        <altmember cref="T:System.Web.UI.WebControls.Button" />
        <related type="Article" href="https://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185">Clientrückrufe ohne Postbacks in ASP.NET-Seiten</related>
      </Docs>
    </Member>
    <Member MemberName="GetPostBackEventReference">
      <MemberSignature Language="C#" Value="public string GetPostBackEventReference (System.Web.UI.Control control, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackEventReference(class System.Web.UI.Control control, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackEventReference(System.Web.UI.Control,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackEventReference(System::Web::UI::Control ^ control, System::String ^ argument);" />
      <MemberSignature Language="F#" Value="member this.GetPostBackEventReference : System.Web.UI.Control * string -&gt; string" Usage="clientScriptManager.GetPostBackEventReference (control, argument)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">Das Server-<see cref="T:System.Web.UI.Control" />, das das Postback auf dem Server verarbeitet.</param>
        <param name="argument">Eine Zeichenfolge optionaler Argumente, die an das Steuerelement übergeben werden soll, das das Postback verarbeitet.</param>
        <summary>Gibt eine Zeichenfolge zurück, die in einem Clientereignis zum Auslösen eines Postbacks an den Server verwendet werden kann. Die Verweiszeichenfolge wird durch das angegebene Steuerelement definiert, das das Postback behandelt, und einem Zeichenfolgenargument mit weiteren Ereignisinformationen.</summary>
        <returns>Eine Zeichenfolge, die das Postback initiiert, wenn sie auf dem Client als Skript behandelt wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zum Implementieren der <xref:System.Web.UI.IPostBackEventHandler> eine Schnittstelle für eine <xref:System.Web.UI.Page>, verwenden Sie die Direktive.  
  
 Die <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> Methode kann verwendet werden, mit der <xref:System.Web.UI.WebControls.Button> steuern, wann die <xref:System.Web.UI.WebControls.Button.UseSubmitBehavior%2A> Eigenschaft `false`. In diesem Szenario die <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> Methodenrückgabe, die das Clientpostback-Ereignis für die <xref:System.Web.UI.WebControls.Button> Steuerelement.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> Methode. Das benutzerdefinierte Steuerelement, `MyControl`, implementiert die <xref:System.Web.UI.IPostBackEventHandler> Schnittstelle. Wenn die Schaltfläche auf der Seite geklickt wird, die <xref:System.Web.UI.IPostBackEventHandler.RaisePostBackEvent%2A> Methode des benutzerdefinierten Steuerelements wird aufgerufen.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager8#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/cs/getpostbackeventreferencecs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager8#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/vb/getpostbackeventreferencevb.aspx#1)]  
  
 Im folgenden Codebeispiel wird hat die gleiche Funktion wie im vorangehenden, außer dass ein benutzerdefiniertes Steuerelement, das <xref:System.Web.UI.Page> -Klasse implementiert die <xref:System.Web.UI.IPostBackEventHandler> Schnittstelle.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager8#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/cs/getpostbackeventreference2cs.aspx#2)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager8#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/vb/getpostbackeventreference2vb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der angegebene <see cref="T:System.Web.UI.Control" /> ist gleich <see langword="null" />.</exception>
        <altmember cref="T:System.Web.UI.PostBackOptions" />
        <altmember cref="T:System.Web.UI.IPostBackEventHandler" />
        <related type="Article" href="https://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185">Clientrückrufe ohne Postbacks in ASP.NET-Seiten</related>
      </Docs>
    </Member>
    <Member MemberName="GetPostBackEventReference">
      <MemberSignature Language="C#" Value="public string GetPostBackEventReference (System.Web.UI.PostBackOptions options, bool registerForEventValidation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackEventReference(class System.Web.UI.PostBackOptions options, bool registerForEventValidation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackEventReference(System.Web.UI.PostBackOptions,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPostBackEventReference (options As PostBackOptions, registerForEventValidation As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackEventReference(System::Web::UI::PostBackOptions ^ options, bool registerForEventValidation);" />
      <MemberSignature Language="F#" Value="member this.GetPostBackEventReference : System.Web.UI.PostBackOptions * bool -&gt; string" Usage="clientScriptManager.GetPostBackEventReference (options, registerForEventValidation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.Web.UI.PostBackOptions" />
        <Parameter Name="registerForEventValidation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="options">Eine Instanz von <see cref="T:System.Web.UI.PostBackOptions" />, die das Postback definiert.</param>
        <param name="registerForEventValidation">
          <see langword="true" />, um den Ereignisverweis für die Validierung zu registrieren, andernfalls <see langword="false" />.</param>
        <summary>Gibt eine Zeichenfolge zurück, die in einem Clientereignis zum Auslösen eines Postbacks an den Server verwendet werden kann. Die Verweiszeichenfolge wird vom angegebenen <see cref="T:System.Web.UI.PostBackOptions" />-Objekt definiert. Registriert den Ereignisverweis optional für die Validierung.</summary>
        <returns>Eine Zeichenfolge, die das Clientpostback initiiert, wenn sie auf dem Client als Skript behandelt wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zum Implementieren der <xref:System.Web.UI.IPostBackEventHandler> eine Schnittstelle für eine <xref:System.Web.UI.Page> Objekt, verwenden Sie die Direktive.  
  
 Die <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> Methode kann verwendet werden, mit der <xref:System.Web.UI.WebControls.Button> steuern, wann die <xref:System.Web.UI.WebControls.Button.UseSubmitBehavior%2A> Eigenschaft `false`. In diesem Szenario die <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> Methodenrückgabe, die das Clientpostback-Ereignis für die <xref:System.Web.UI.WebControls.Button> Steuerelement.  
  
 Wenn `registerForEventValidation` ist `true`, <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%28System.Web.UI.PostBackOptions%2CSystem.Boolean%29> Methodenaufrufe der <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%28System.String%2CSystem.String%29> Methode, um den Ereignisverweis für die Überprüfung mit einer eindeutigen Steuerelement-ID zu registrieren, die das Clientsteuerelement darstellt, die das Ereignis generiert.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="T:System.Web.UI.PostBackOptions" /> ist <see langword="null" />.</exception>
        <altmember cref="T:System.Web.UI.PostBackOptions" />
        <altmember cref="T:System.Web.UI.IPostBackEventHandler" />
        <altmember cref="T:System.Web.UI.WebControls.Button" />
        <related type="Article" href="https://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185">Clientrückrufe ohne Postbacks in ASP.NET-Seiten</related>
      </Docs>
    </Member>
    <Member MemberName="GetPostBackEventReference">
      <MemberSignature Language="C#" Value="public string GetPostBackEventReference (System.Web.UI.Control control, string argument, bool registerForEventValidation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackEventReference(class System.Web.UI.Control control, string argument, bool registerForEventValidation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackEventReference(System.Web.UI.Control,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackEventReference(System::Web::UI::Control ^ control, System::String ^ argument, bool registerForEventValidation);" />
      <MemberSignature Language="F#" Value="member this.GetPostBackEventReference : System.Web.UI.Control * string * bool -&gt; string" Usage="clientScriptManager.GetPostBackEventReference (control, argument, registerForEventValidation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="registerForEventValidation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">Das Server-<see cref="T:System.Web.UI.Control" />, das das Postback auf dem Server verarbeitet.</param>
        <param name="argument">Eine Zeichenfolge optionaler Argumente, die an <c>control</c> übergeben werden sollen.</param>
        <param name="registerForEventValidation">
          <see langword="true" />, um den Ereignisverweis für die Validierung zu registrieren, andernfalls <see langword="false" />.</param>
        <summary>Gibt eine Zeichenfolge zurück, die in einem Clientereignis zum Auslösen eines Postbacks an den Server verwendet werden kann. Die Verweiszeichenfolge wird durch das angegebene Steuerelement definiert, das das Postback behandelt, und einem Zeichenfolgenargument mit weiteren Ereignisinformationen. Registriert den Ereignisverweis optional für die Validierung.</summary>
        <returns>Eine Zeichenfolge, die das Postback initiiert, wenn sie auf dem Client als Skript behandelt wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zum Implementieren der <xref:System.Web.UI.IPostBackEventHandler> eine Schnittstelle für eine <xref:System.Web.UI.Page>, verwenden Sie die Direktive.  
  
 Die <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> Methode kann verwendet werden, mit der <xref:System.Web.UI.WebControls.Button> steuern, wann die <xref:System.Web.UI.WebControls.Button.UseSubmitBehavior%2A> Eigenschaft `false`. In diesem Szenario die <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> Methodenrückgabe, die das Clientpostback-Ereignis für die <xref:System.Web.UI.WebControls.Button> Steuerelement.  
  
 Wenn `registerForEventValidation` ist "true", die <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%28System.Web.UI.PostBackOptions%2CSystem.Boolean%29> Methodenaufrufe der <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%28System.String%2CSystem.String%29> Methode, um den Ereignisverweis für die Überprüfung mit einer eindeutigen Steuerelement-ID zu registrieren, die das Clientsteuerelement darstellt, die das Ereignis generiert.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der angegebene <see cref="T:System.Web.UI.Control" /> ist gleich <see langword="null" />.</exception>
        <altmember cref="T:System.Web.UI.PostBackOptions" />
        <altmember cref="T:System.Web.UI.IPostBackEventHandler" />
        <related type="Article" href="https://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185">Clientrückrufe ohne Postbacks in ASP.NET-Seiten</related>
      </Docs>
    </Member>
    <Member MemberName="GetWebResourceUrl">
      <MemberSignature Language="C#" Value="public string GetWebResourceUrl (Type type, string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetWebResourceUrl(class System.Type type, string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetWebResourceUrl(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetWebResourceUrl(Type ^ type, System::String ^ resourceName);" />
      <MemberSignature Language="F#" Value="member this.GetWebResourceUrl : Type * string -&gt; string" Usage="clientScriptManager.GetWebResourceUrl (type, resourceName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="resourceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Der Typ der Ressource.</param>
        <param name="resourceName">Der vollqualifizierte Name der Ressource in der Assembly.</param>
        <summary>Ruft einen URL-Verweis auf eine Ressource in einer Assembly ab.</summary>
        <returns>Der URL-Verweis auf die Ressource.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.ClientScriptManager.GetWebResourceUrl%2A> Methode gibt einen URL-Verweis auf eine Ressource in eine Assembly eingebettet. Der zurückgegebene Verweis ist nicht die URL-codiert. Ressourcen können Skriptdateien, Bilder oder statische Datei sein. Sie geben den Typ basierend auf das Objekt, das die Ressource zugegriffen wird.  
  
 Eine Webressource, die mit der Seite registriert wird durch den Typ und den Namen eindeutig identifiziert. Nur eine Ressource mit einem angegebenen Typ und Name-Paar kann mit der Seite registriert werden. Versucht, eine Ressource zu registrieren, die bereits registriert ist, wird ein Duplikat der registrierten Ressource nicht erstellt.  
  
 Die <xref:System.Web.UI.ClientScriptManager.GetWebResourceUrl%2A> Methode wird verwendet, in Verbindung mit der <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptResource%2A> -Methode für den Zugriff auf Ressourcen in Assemblys eingebettet. Weitere Informationen zur Verwendung von Ressourcen in Anwendungen finden Sie unter [ASP.NET Web Page Resources Overview](https://msdn.microsoft.com/library/0936b3b2-9e6e-4abe-9c06-364efef9dbbd).  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der <xref:System.Web.UI.ClientScriptManager.GetWebResourceUrl%2A> Methode. Die *Typ* Parameter in diesem Beispiel wird festgelegt, in den Typ der Klasse in der Assembly, die mit der Ressource. Die `resourceName` Parameter wird angegeben, durch den vollqualifizierten Pfad zu der Ressource, die den Standardnamespace enthält.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager4#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/cs/clientscriptwebresource.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager4#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/vb/clientscriptwebresource.aspx#1)]  
  
 Im folgenden Codebeispiel wird veranschaulicht, wie programmgesteuert Anwenden der <xref:System.Web.UI.WebResourceAttribute> Attribut für die Metadaten die Assembly für die Ressourcen markieren, die verarbeitet wird. Kompilieren Sie die folgende Klasse in einer Klassenbibliothek mit einem Standardnamespace festgelegt `Samples.AspNet.CS.Controls` oder `Samples.AspNet.VB.Controls`, je nachdem, in welcher Sprache Sie verwenden.  
  
 [!code-csharp[System.Web.UI.ClientScriptManager4#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/cs/resource.cs#2)]
 [!code-vb[System.Web.UI.ClientScriptManager4#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/vb/resource.vb#2)]  
  
 Dieses Beispiel erfordert eine JavaScript-Datei mit dem Namen `Script_include.js`. Die JS-Datei ist eine eingebettete Ressource in die Assembly mit der `ClientScriptResourceLabel` Objekt. Wenn Sie Visual Studio im Fenster "Eigenschaften" das Klassenbibliotheksprojekt verwenden, legen Sie **Buildvorgang** zu **eingebettete Ressource** Wenn die Skript-Datei ausgewählt ist. Wenn Sie die Bibliothek in der Befehlszeile kompilieren, verwenden Sie den Schalter zum Einbetten der Ressource.  
  
```  
function DoClick() {Form1.Message.value='Text from resource script.'}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der Webressourcenname ist <see langword="null" />.  
  
\- oder – 
Der Webressourcenname hat eine Länge von 0 (null).</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterClientScriptResource(System.Type,System.String)" />
        <altmember cref="T:System.Web.UI.WebResourceAttribute" />
        <altmember cref="T:System.Web.Handlers.AssemblyResourceLoader" />
        <related type="Article" href="https://msdn.microsoft.com/library/0936b3b2-9e6e-4abe-9c06-364efef9dbbd">ASP.NET Web Page Resources Overview</related>
        <related type="Article" href="https://msdn.microsoft.com/library/5212666e-98ab-47e4-a497-b5545ab15c7f">/ Resource (Ressourcendatei in Ausgabe einbetten) (C#-Compileroptionen)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/eee2f227-91f2-4f2b-a9d6-1c51c5320858">/resource (Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsClientScriptBlockRegistered">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Bestimmt, ob der Clientskriptblock für das <see cref="T:System.Web.UI.Page" />-Objekt registriert ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsClientScriptBlockRegistered">
      <MemberSignature Language="C#" Value="public bool IsClientScriptBlockRegistered (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsClientScriptBlockRegistered(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsClientScriptBlockRegistered (key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsClientScriptBlockRegistered(System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsClientScriptBlockRegistered : string -&gt; bool" Usage="clientScriptManager.IsClientScriptBlockRegistered key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Der Schlüssel des zu suchenden Clientskriptblocks.</param>
        <summary>Bestimmt unter Verwendung des angegebenen Schlüssels, ob der Clientskriptblock für das <see cref="T:System.Web.UI.Page" />-Objekt registriert ist.</summary>
        <returns>
          <see langword="true" />, wenn der Clientskriptblock registriert ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie diese Methode vor dem Aufruf der <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> Methode zur Vermeidung doppelter Skripts registrieren. Dies ist besonders wichtig, wenn das Skript eine große Menge der zu erstellenden Serverressourcen erfordert.  
  
 Ein Clientskript wird durch seinen Schlüssel und seinen Typ eindeutig identifiziert. Skripts mit den gleichen Schlüssel und Typ werden als Duplikate betrachtet.  
  
 Diese Überladung von der <xref:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered%2A> -Methode ruft die Überladung, die beide akzeptiert eine `key` und `type` Parameter mit dem Typ festgelegt wird, als eine <xref:System.Web.UI.Page> Objekt  
  
   
  
## Examples  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs2.aspx#2)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb2.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered(System.Type,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock" />
      </Docs>
    </Member>
    <Member MemberName="IsClientScriptBlockRegistered">
      <MemberSignature Language="C#" Value="public bool IsClientScriptBlockRegistered (Type type, string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsClientScriptBlockRegistered(class System.Type type, string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsClientScriptBlockRegistered(Type ^ type, System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsClientScriptBlockRegistered : Type * string -&gt; bool" Usage="clientScriptManager.IsClientScriptBlockRegistered (type, key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Der Typ des zu suchenden Clientskriptblocks.</param>
        <param name="key">Der Schlüssel des zu suchenden Clientskriptblocks.</param>
        <summary>Bestimmt unter Verwendung des Schlüssels und des Typs, ob der Clientskriptblock für das <see cref="T:System.Web.UI.Page" />-Objekt registriert ist.</summary>
        <returns>
          <see langword="true" />, wenn der Clientskriptblock registriert ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie diese Methode vor dem Aufruf der <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> Methode zur Vermeidung doppelter Skripts registrieren. Dies ist besonders wichtig, wenn das Skript eine große Menge der zu erstellenden Serverressourcen erfordert.  
  
 Ein Clientskript wird durch seinen Schlüssel und seinen Typ eindeutig identifiziert. Skripts mit den gleichen Schlüssel und Typ werden als Duplikate betrachtet. Sie geben den Typ basierend auf das Objekt, das die Ressource zugegriffen wird. Z. B. bei Verwendung einer `Page` Instanz Zugriff auf die Ressource, Sie geben die `Page` Typ.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der <xref:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered%2A> Methode. Beachten Sie, dass, wenn die Logik zum Prüfen, ob des Clientskriptblocks für vorhandene entfernt wurden, es wäre nicht zwei doppelte Client-Skripts im HTML-Quellcode der gerenderten Seite da die <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> Methode, die auf Duplikate überprüft. Der Vorteil der Überprüfung ist unnötiger Berechnungen zu reduzieren.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der Clientskripttyp ist <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered(System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsClientScriptIncludeRegistered">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Bestimmt, ob der Clientskriptinclude für das <see cref="T:System.Web.UI.Page" />-Objekt registriert ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsClientScriptIncludeRegistered">
      <MemberSignature Language="C#" Value="public bool IsClientScriptIncludeRegistered (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsClientScriptIncludeRegistered(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsClientScriptIncludeRegistered (key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsClientScriptIncludeRegistered(System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsClientScriptIncludeRegistered : string -&gt; bool" Usage="clientScriptManager.IsClientScriptIncludeRegistered key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Der Schlüssel des zu suchenden Clientskriptincludes.</param>
        <summary>Bestimmt unter Verwendung des angegebenen Schlüssels, ob der Clientskriptinclude für das <see cref="T:System.Web.UI.Page" />-Objekt registriert ist.</summary>
        <returns>
          <see langword="true" />, wenn der Clientskriptinclude registriert ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie diese Methode vor dem Aufruf der <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> Methode zur Vermeidung doppelter Skripts registrieren. Dies ist besonders wichtig, wenn das Skript eine große Menge der zu erstellenden Serverressourcen erfordert.  
  
 Ein Clientskriptinclude wird durch seinen Schlüssel und seinen Typ eindeutig identifiziert. Skripts mit den gleichen Schlüssel und Typ werden als Duplikate betrachtet.  
  
 Diese Überladung von der <xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A> -Methode ruft die Überladung, die beide akzeptiert eine `key` und `type` Parameter mit dem Typ festgelegt wird, als eine <xref:System.Web.UI.Page> Objekt.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered(System.Type,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude" />
      </Docs>
    </Member>
    <Member MemberName="IsClientScriptIncludeRegistered">
      <MemberSignature Language="C#" Value="public bool IsClientScriptIncludeRegistered (Type type, string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsClientScriptIncludeRegistered(class System.Type type, string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsClientScriptIncludeRegistered(Type ^ type, System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsClientScriptIncludeRegistered : Type * string -&gt; bool" Usage="clientScriptManager.IsClientScriptIncludeRegistered (type, key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Der Typ des zu suchenden Clientskriptincludes.</param>
        <param name="key">Der Schlüssel des zu suchenden Clientskriptincludes.</param>
        <summary>Bestimmt unter Verwendung des Schlüssels und des Typs, ob der Clientskriptinclude für das <see cref="T:System.Web.UI.Page" />-Objekt registriert ist.</summary>
        <returns>
          <see langword="true" />, wenn der Clientskriptinclude registriert ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie diese Methode vor dem Aufruf der <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> Methode, um zu vermeiden, Registrierung doppelter enthält. Dies ist besonders wichtig, wenn das Skript eine große Menge der zu erstellenden Serverressourcen erfordert.  
  
 Ein Clientskriptinclude wird durch seinen Schlüssel und seinen Typ eindeutig identifiziert. Skripts mit den gleichen Schlüssel und Typ werden als Duplikate betrachtet. Sie geben den Typ basierend auf das Objekt, das die Ressource zugegriffen wird. Z. B. wenn eine Seiteninstanz verwenden, um die Ressource zugreifen, Sie geben die `Page` Typ.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der <xref:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered%2A> Methode. Beachten Sie, dass, wenn die Logik zum Überprüfen der vorhandenen Clientskriptinclude entfernt wurden, es wäre nicht zwei doppelte Client-Skripts im HTML-Quellcode der gerenderten Seite da die <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> Methode, die auf Duplikate überprüft. Der Vorteil der Überprüfung ist unnötiger Berechnungen zu reduzieren.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager2#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager2/cs/clientscriptincludes.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager2#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager2/vb/clientscriptincludes.aspx#1)]  
  
 Dieses Beispiel erfordert eine JavaScript-Datei mit dem Namen `Script_include.js`, mit dem folgenden Inhalt:  
  
```  
function DoClick() {Form1.Message.value='Text from include script.'}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der Typ des Clientskriptincludes ist <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered(System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsOnSubmitStatementRegistered">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Bestimmt, ob die OnSubmit-Anweisung für das <see cref="T:System.Web.UI.Page" />-Objekt registriert ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsOnSubmitStatementRegistered">
      <MemberSignature Language="C#" Value="public bool IsOnSubmitStatementRegistered (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsOnSubmitStatementRegistered(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsOnSubmitStatementRegistered (key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsOnSubmitStatementRegistered(System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsOnSubmitStatementRegistered : string -&gt; bool" Usage="clientScriptManager.IsOnSubmitStatementRegistered key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Der Schlüssel der zu suchenden OnSubmit-Anweisung.</param>
        <summary>Bestimmt anhand des angegebenen Schlüssels, ob die OnSubmit-Anweisung für das <see cref="T:System.Web.UI.Page" />-Objekt registriert ist.</summary>
        <returns>
          <see langword="true" />, wenn die OnSubmit-Anweisung registriert ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie diese Methode vor dem Aufruf der <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A> Methode zur Vermeidung von doppelten OnSubmit-Anweisungen registrieren. Dies ist besonders wichtig, wenn die Anweisung eine große Menge der zu erstellenden Serverressourcen erfordert.  
  
 Eine Anweisung wird durch seinen Schlüssel und seinen Typ eindeutig identifiziert. Anweisungen mit den gleichen Schlüssel und Typ werden als Duplikate betrachtet.  
  
 Diese Überladung von der <xref:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered%2A> -Methode ruft die Überladung, die beide akzeptiert eine `key` und `type` Parameter mit dem Typ festgelegt wird, als eine <xref:System.Web.UI.Page> Objekt  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered(System.Type,System.String)" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement(System.Type,System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsOnSubmitStatementRegistered">
      <MemberSignature Language="C#" Value="public bool IsOnSubmitStatementRegistered (Type type, string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsOnSubmitStatementRegistered(class System.Type type, string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsOnSubmitStatementRegistered(Type ^ type, System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsOnSubmitStatementRegistered : Type * string -&gt; bool" Usage="clientScriptManager.IsOnSubmitStatementRegistered (type, key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Der Typ der zu suchenden OnSubmit-Anweisung.</param>
        <param name="key">Der Schlüssel der zu suchenden OnSubmit-Anweisung.</param>
        <summary>Bestimmt unter Verwendung des angegebenen Schlüssels und Typs, ob die OnSubmit-Anweisung für das <see cref="T:System.Web.UI.Page" />-Objekt registriert ist.</summary>
        <returns>
          <see langword="true" />, wenn die OnSubmit-Anweisung registriert ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie diese Methode vor dem Aufruf der <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A> Methode zur Vermeidung von doppelten-Anweisungen registrieren. Dies ist besonders wichtig, wenn die Anweisung eine große Menge der zu erstellenden Serverressourcen erfordert.  
  
 Eine Anweisung wird durch seinen Schlüssel und seinen Typ eindeutig identifiziert. Anweisungen mit den gleichen Schlüssel und Typ werden als Duplikate betrachtet. Sie geben den Typ basierend auf das Objekt, das die Ressource zugegriffen wird. Z. B. bei Verwendung einer `Page` Instanz Zugriff auf die Ressource, Sie geben die `Page` Typ.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der <xref:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered%2A> Methode. Ein Skript namens `OnSubmitScript` registriert ist, mit der <xref:System.Web.UI.Page> , damit bei der Seite-Formular übermittelt wird. das Skript wird aufgerufen.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager3#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager3/cs/clientscriptonsubmit.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager3#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager3/vb/clientscriptonsubmit.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der Typ der OnSubmit-Anweisung ist <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered(System.String)" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement(System.Type,System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsStartupScriptRegistered">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Bestimmt, ob das Startskript für das <see cref="T:System.Web.UI.Page" />-Objekt registriert ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsStartupScriptRegistered">
      <MemberSignature Language="C#" Value="public bool IsStartupScriptRegistered (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsStartupScriptRegistered(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsStartupScriptRegistered (key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsStartupScriptRegistered(System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsStartupScriptRegistered : string -&gt; bool" Usage="clientScriptManager.IsStartupScriptRegistered key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Der Schlüssel des zu suchenden Startskripts.</param>
        <summary>Bestimmt unter Verwendung des angegebenen Schlüssels, ob das Startskript für das <see cref="T:System.Web.UI.Page" />-Objekt registriert ist.</summary>
        <returns>
          <see langword="true" />, wenn das Startskript registriert ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie diese Methode vor dem Aufruf der <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> Methode zur Vermeidung doppelter Skripts registrieren. Dies ist besonders wichtig, wenn das Skript eine große Menge der zu erstellenden Serverressourcen erfordert.  
  
 Ein Startskript wird durch seinen Schlüssel und seinen Typ eindeutig identifiziert. Skripts mit den gleichen Schlüssel und Typ werden als Duplikate betrachtet.  
  
 Diese Überladung von der <xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A> Methode ruft die Überladung, die sowohl eine Zeichenfolge akzeptiert `key` und `type` Parameter mit dem Typ festgelegt wird, als eine <xref:System.Web.UI.Page> Objekt  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered(System.Type,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterStartupScript" />
      </Docs>
    </Member>
    <Member MemberName="IsStartupScriptRegistered">
      <MemberSignature Language="C#" Value="public bool IsStartupScriptRegistered (Type type, string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsStartupScriptRegistered(class System.Type type, string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsStartupScriptRegistered(Type ^ type, System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsStartupScriptRegistered : Type * string -&gt; bool" Usage="clientScriptManager.IsStartupScriptRegistered (type, key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Der Typ des zu suchenden Startskripts.</param>
        <param name="key">Der Schlüssel des zu suchenden Startskripts.</param>
        <summary>Bestimmt unter Verwendung des angegebenen Schlüssels und Typs, ob das Startskript für das <see cref="T:System.Web.UI.Page" />-Objekt registriert ist.</summary>
        <returns>
          <see langword="true" />, wenn das Startskript registriert ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie diese Methode vor dem Aufruf der <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> Methode zur Vermeidung doppelter Skripts registrieren. Dies ist besonders wichtig, wenn das Skript eine große Menge der zu erstellenden Serverressourcen erfordert.  
  
 Ein Client-Startskript wird durch seinen Schlüssel und seinen Typ eindeutig identifiziert. Skripts mit den gleichen Schlüssel und Typ werden als Duplikate betrachtet.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der <xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A> Methode. Beachten Sie, dass, wenn die Logik zum Prüfen, ob die vorhandenen Startskriptblock entfernt wurden, es wäre nicht zwei doppelte Startskripts im HTML-Quellcode der gerenderten Seite da die <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> Methode, die auf Duplikate überprüft. Der Vorteil der Überprüfung ist unnötiger Berechnungen zu reduzieren.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der Startskripttyp ist <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered(System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterStartupScript" />
      </Docs>
    </Member>
    <Member MemberName="RegisterArrayDeclaration">
      <MemberSignature Language="C#" Value="public void RegisterArrayDeclaration (string arrayName, string arrayValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterArrayDeclaration(string arrayName, string arrayValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterArrayDeclaration (arrayName As String, arrayValue As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterArrayDeclaration(System::String ^ arrayName, System::String ^ arrayValue);" />
      <MemberSignature Language="F#" Value="member this.RegisterArrayDeclaration : string * string -&gt; unit" Usage="clientScriptManager.RegisterArrayDeclaration (arrayName, arrayValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arrayName" Type="System.String" />
        <Parameter Name="arrayValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="arrayName">Der zu registrierende Arrayname.</param>
        <param name="arrayValue">Der zu registrierende Arraywert bzw. die zu registrierenden Arraywerte.</param>
        <summary>Registriert unter Verwendung eines Arraynamens und eines Arraytyps eine JavaScript-Arraydeklaration für ein <see cref="T:System.Web.UI.Page" />-Objekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A> überprüft, ob ein registriertes Array mit den gleichen Namen wie den in angegebenen Namen vorhanden ist die `arrayName` Parameter und, wenn dies der Fall ist, fügt im angegebenen Werte die `arrayValue` Parameter. Da die zugrunde liegenden Speichermechanismus basiert eine <xref:System.Collections.ArrayList>, Duplikate sind zulässig. Wenn kein registriertes Array mit den gleichen Namen wie die `arrayName` Parameter ist nicht vorhanden, wird Sie erstellt und die Werte in der `arrayValue` Parameter hinzugefügt wird.  
  
 Wenn Sie Zeichenfolgenliterale in der sich ergebenden JavaScript-Array, einfache Anführungszeichen (') enthalten oder mit Escapezeichen versehen doppelte Anführungszeichen (\\") in der `arrayValue` Parameter. Der Wert des der `arrayValue` Parameter muss ein einzelnes Element sein. Wenn mehr als einen Wert in das Array hinzugefügt werden muss, stellen Sie mehrere Aufrufe, die mit der <xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A> Methode.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der <xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A> und <xref:System.Web.UI.ClientScriptManager.RegisterHiddenField%2A> Methoden. Im Beispiel wird ein Array und einen ausgeblendeten Wert registriert und definiert die `OnClick` Ereignis eine `<input>` Schaltfläche, um die Summe der beiden Werte des Arrays und dem ausgeblendeten Wert zu berechnen.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager5#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager5/cs/clientscriptregisterarray.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager5#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager5/vb/clientscriptregisterarray.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="arrayName" /> ist <see langword="null" />.</exception>
        <altmember cref="Overload:System.String.Split" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterClientScriptBlock">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Registriert das Clientskript für das <see cref="T:System.Web.UI.Page" />-Objekt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterClientScriptBlock">
      <MemberSignature Language="C#" Value="public void RegisterClientScriptBlock (Type type, string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClientScriptBlock(class System.Type type, string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock(System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterClientScriptBlock(Type ^ type, System::String ^ key, System::String ^ script);" />
      <MemberSignature Language="F#" Value="member this.RegisterClientScriptBlock : Type * string * string -&gt; unit" Usage="clientScriptManager.RegisterClientScriptBlock (type, key, script)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Der Typ des zu registrierenden Clientskripts.</param>
        <param name="key">Der Schlüssel des zu registrierenden Clientskripts.</param>
        <param name="script">Das zu registrierende Clientskriptliteral.</param>
        <summary>Registriert unter Verwendung eines Typs, eines Schlüssels und eines Skriptliterals das Clientskript für das <see cref="T:System.Web.UI.Page" />-Objekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Clientskript wird durch seinen Schlüssel und seinen Typ eindeutig identifiziert. Skripts mit den gleichen Schlüssel und Typ werden als Duplikate betrachtet. Nur ein Skript mit einem angegebenen Typ und das Schlüsselpaar kann mit der Seite registriert werden. Versucht, ein Skript zu registrieren, die bereits registriert ist, wird ein Duplikat des Skripts nicht erstellt.  
  
 Rufen Sie die <xref:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered%2A> Methode, um zu bestimmen, ob ein Clientskript mit einem angegebenen Paar aus Schlüssel und Typ bereits registriert ist und nicht unnötigerweise das Skript hinzugefügt.  
  
 In dieser Überladung der der <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> -Methode, Sie müssen sicherstellen, dass das Skript, in bereitgestellt der `script` Parameter als Wrapper versehen einer `<script>` Elementblock.  
  
 Die <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> Methode fügt einen Skriptblock an den Anfang der gerenderten Seite. Skriptblöcke werden nicht unbedingt in der Reihenfolge ausgegeben werden, die sie registriert sind. Wenn die Reihenfolge der Skriptblöcke wichtig ist, verwenden Sie eine <xref:System.Text.StringBuilder> das Objekt, für die Skripts in einer einzelnen Zeichenfolge zusammenfassen, und registrieren Sie sie alle in einem einzelnen Client-Skriptblock.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> Methode.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager12#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.ui.clientscriptmanager12/cs/default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager12#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.ui.clientscriptmanager12/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock(System.Type,System.String,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScriptBlock">
      <MemberSignature Language="C#" Value="public void RegisterClientScriptBlock (Type type, string key, string script, bool addScriptTags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClientScriptBlock(class System.Type type, string key, string script, bool addScriptTags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock(System.Type,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterClientScriptBlock(Type ^ type, System::String ^ key, System::String ^ script, bool addScriptTags);" />
      <MemberSignature Language="F#" Value="member this.RegisterClientScriptBlock : Type * string * string * bool -&gt; unit" Usage="clientScriptManager.RegisterClientScriptBlock (type, key, script, addScriptTags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
        <Parameter Name="addScriptTags" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">Der Typ des zu registrierenden Clientskripts.</param>
        <param name="key">Der Schlüssel des zu registrierenden Clientskripts.</param>
        <param name="script">Das zu registrierende Clientskriptliteral.</param>
        <param name="addScriptTags">Ein boolescher Wert, der angibt, ob Skripttags hinzugefügt werden sollen.</param>
        <summary>Registriert unter Verwendung eines Typs, eines Schlüssels, eines Skriptliterals sowie eines booleschen Werts, der angibt, ob Skripttags hinzugefügt werden sollen, das Clientskript für das <see cref="T:System.Web.UI.Page" />-Objekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Clientskript wird durch seinen Schlüssel und seinen Typ eindeutig identifiziert. Skripts mit den gleichen Schlüssel und Typ werden als Duplikate betrachtet. Nur ein Skript mit einem angegebenen Typ und das Schlüsselpaar kann mit der Seite registriert werden. Versucht, ein Skript zu registrieren, die bereits registriert ist, wird ein Duplikat des Skripts nicht erstellt.  
  
 Rufen Sie die <xref:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered%2A> Methode, um zu bestimmen, ob ein Clientskript mit einem angegebenen Paar aus Schlüssel und Typ bereits registriert ist. Dadurch können Sie nicht unnötigerweise das Skript hinzugefügt.  
  
 In dieser Überladung der der <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> -Methode können Sie angeben, ob das Skript, in bereitgestellt der `script` Parameter in gesetzt ist eine `<script>` Elementblock mithilfe der `addScriptTags` Parameter. Festlegen von `addScriptTags` zu `true` gibt an, dass die Skripttags automatisch hinzugefügt werden.  
  
 Die <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> Methode fügt einen Skriptblock an den Anfang der gerenderten Seite. Skriptblöcke werden nicht unbedingt in der Reihenfolge ausgegeben werden, die sie registriert sind. Wenn die Reihenfolge der Skriptblöcke wichtig ist, verwenden Sie eine <xref:System.Text.StringBuilder> das Objekt, für die Skripts in einer einzelnen Zeichenfolge zusammenfassen, und registrieren Sie sie alle in einem einzelnen Client-Skriptblock.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> Methode. Beachten Sie, dass die `addScriptTags` Parametersatz zu `true` , damit die öffnenden und schließenden Skripttags nicht enthalten sind die `script` Parameter.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der Typ des Clientskriptblocks ist <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock(System.Type,System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterClientScriptInclude">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Registriert den Clientskriptinclude für das <see cref="T:System.Web.UI.Page" />-Objekt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterClientScriptInclude">
      <MemberSignature Language="C#" Value="public void RegisterClientScriptInclude (string key, string url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClientScriptInclude(string key, string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterClientScriptInclude (key As String, url As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterClientScriptInclude(System::String ^ key, System::String ^ url);" />
      <MemberSignature Language="F#" Value="member this.RegisterClientScriptInclude : string * string -&gt; unit" Usage="clientScriptManager.RegisterClientScriptInclude (key, url)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Der Schlüssel des zu registrierenden Clientskriptincludes.</param>
        <param name="url">Die URL des zu registrierenden Clientskriptincludes.</param>
        <summary>Registriert das Clientskript beim <see cref="T:System.Web.UI.Page" />-Objekt mit einem Schlüssel und einer URL, wodurch das Skript vom Client aufgerufen werden kann.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Clientskriptinclude wird durch seinen Schlüssel und seinen Typ eindeutig identifiziert. Skripts mit den gleichen Schlüssel und Typ werden als Duplikate betrachtet. Nur ein Skript mit einem angegebenen Typ und das Schlüsselpaar kann mit der Seite registriert werden. Versucht, ein Skript zu registrieren, die bereits registriert ist, wird ein Duplikat des Skripts nicht erstellt.  
  
 Rufen Sie die <xref:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered%2A> Methode, um zu bestimmen, ob der Clientskriptinclude mit einem angegebenen Schlüssel und Typ-Paar ist bereits registriert und nicht unnötigerweise das Skript hinzugefügt.  
  
> [!NOTE]
>  Um die Client-URL zu beheben, verwenden Sie die <xref:System.Web.UI.Control.ResolveClientUrl%2A> Methode. Diese Methode verwendet den Kontext der URL auf dem sie aufgerufen wird, um den Pfad zu beheben.  
  
 Diese Überladung von der <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> Methode ruft die Überladung mit einer `key`, `URL`, und ein `type` Parameter.  
  
 Die Methode fügt einen Skriptblock am oberen Rand der gerenderten Seite.  
  
   
  
## Examples  
 Weitere Informationen sowie zu Syntax, Nutzung und ein Beispiel finden Sie unter <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude(System.Type,System.String,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered" />
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScriptInclude">
      <MemberSignature Language="C#" Value="public void RegisterClientScriptInclude (Type type, string key, string url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClientScriptInclude(class System.Type type, string key, string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude(System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterClientScriptInclude(Type ^ type, System::String ^ key, System::String ^ url);" />
      <MemberSignature Language="F#" Value="member this.RegisterClientScriptInclude : Type * string * string -&gt; unit" Usage="clientScriptManager.RegisterClientScriptInclude (type, key, url)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Der Typ des zu registrierenden Clientskriptincludes.</param>
        <param name="key">Der Schlüssel des zu registrierenden Clientskriptincludes.</param>
        <param name="url">Die URL des zu registrierenden Clientskriptincludes.</param>
        <summary>Registriert unter Verwendung eines Typs, eines Schlüssels sowie einer URL den Clientskriptinclude für das <see cref="T:System.Web.UI.Page" />-Objekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung von der <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> -Methode übernimmt *Schlüssel* und *Url* Parameter zum Identifizieren des Skripts, als auch ein `type` enthalten Parameter, um die Kennung des Clientskripts anzugeben. Sie geben den Typ basierend auf das Objekt, das die Ressource zugegriffen wird. Z. B. bei Verwendung einer `Page` Instanz Zugriff auf die Ressource, Sie geben die `Page` Typ.  
  
> [!NOTE]
>  Um die Client-URL zu beheben, verwenden Sie die <xref:System.Web.UI.Control.ResolveClientUrl%2A> Methode. Diese Methode verwendet den Kontext der URL auf dem sie aufgerufen wird, um den Pfad zu beheben.  
  
 Diese Methode fügt einen Skriptblock am oberen Rand der gerenderten Seite.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> Methode. Beachten Sie, dass, wenn die Logik zum Überprüfen der vorhandenen Clientskriptinclude entfernt wurden, es wäre immer noch nicht, doppelte Clientskripts auf der gerenderten Seite da die <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> Methode, die auf Duplikate überprüft. Der Vorteil der Überprüfung ist unnötiger Berechnungen zu reduzieren.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager2#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager2/cs/clientscriptincludes.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager2#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager2/vb/clientscriptincludes.aspx#1)]  
  
 Dieses Beispiel erfordert eine JavaScript-Datei mit dem Namen Script_include.js mit dem folgenden Inhalt:  
  
```  
function DoClick() {Form1.Message.value='Text from include script.'}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der Typ des Clientskriptincludes ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die URL ist <see langword="null" />.  
  
\- oder – 
Der URL ist leer.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude(System.String,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered" />
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScriptResource">
      <MemberSignature Language="C#" Value="public void RegisterClientScriptResource (Type type, string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClientScriptResource(class System.Type type, string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterClientScriptResource(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterClientScriptResource(Type ^ type, System::String ^ resourceName);" />
      <MemberSignature Language="F#" Value="member this.RegisterClientScriptResource : Type * string -&gt; unit" Usage="clientScriptManager.RegisterClientScriptResource (type, resourceName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="resourceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Der Typ der zu registrierenden Clientskriptressource.</param>
        <param name="resourceName">Der Name der zu registrierenden Clientskriptressource.</param>
        <summary>Registriert die Clientskriptressource unter Verwendung eines Typ und eines Ressourcennamens für das <see cref="T:System.Web.UI.Page" />-Objekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptResource%2A> Methode wird verwendet, wenn Sie kompilierte Ressourcen aus Assemblys, die über der WebResource.axd-HTTP-Handler zugreifen. Die <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptResource%2A> Methode registriert das Skript mit dem <xref:System.Web.UI.Page> Objekt aus, und verhindert, dass doppelte Skripts. Diese Methode dient als Wrapper für den Inhalt des Ressourcen-URL mit einem `<script>` Elementblock.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptResource%2A> Methode.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager4#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/cs/clientscriptwebresource.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager4#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/vb/clientscriptwebresource.aspx#1)]  
  
 Im folgenden Codebeispiel wird veranschaulicht, wie programmgesteuert Anwenden der <xref:System.Web.UI.WebResourceAttribute> Attribut für die Metadaten die Assembly für die Ressourcen markieren, die verarbeitet wird.  
  
 [!code-csharp[System.Web.UI.ClientScriptManager4#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/cs/resource.cs#2)]
 [!code-vb[System.Web.UI.ClientScriptManager4#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/vb/resource.vb#2)]  
  
 Dieses Beispiel erfordert eine JavaScript-Datei mit dem Namen `Script_include.js`, mit dem folgenden Inhalt:  
  
```  
function DoClick() {Form1.Message.value='Text from resource script.'}  
```  
  
 Kompilieren Sie die `Script_include.js` -Datei als Ressource in der `Samples.AspNet.CS.Controls` Assembly mit der `ClientScriptResourceLabel` Klasse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der Clientressourcenname ist <see langword="null" />.  
  
\- oder – 
Der Clientressourcenname hat eine Länge von 0 (null).</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.GetWebResourceUrl(System.Type,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude" />
        <altmember cref="T:System.Web.Handlers.AssemblyResourceLoader" />
        <altmember cref="T:System.Web.UI.WebResourceAttribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterExpandoAttribute">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Registriert ein Name-Wert-Paar als benutzerdefiniertes Attribut (Expando-Attribut) des angegebenen Steuerelements.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterExpandoAttribute">
      <MemberSignature Language="C#" Value="public void RegisterExpandoAttribute (string controlId, string attributeName, string attributeValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterExpandoAttribute(string controlId, string attributeName, string attributeValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterExpandoAttribute (controlId As String, attributeName As String, attributeValue As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterExpandoAttribute(System::String ^ controlId, System::String ^ attributeName, System::String ^ attributeValue);" />
      <MemberSignature Language="F#" Value="member this.RegisterExpandoAttribute : string * string * string -&gt; unit" Usage="clientScriptManager.RegisterExpandoAttribute (controlId, attributeName, attributeValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="controlId" Type="System.String" />
        <Parameter Name="attributeName" Type="System.String" />
        <Parameter Name="attributeValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="controlId">Das <see cref="T:System.Web.UI.Control" /> auf der Seite, die das benutzerdefinierte Attribut enthält.</param>
        <param name="attributeName">Der Name des zu registrierenden benutzerdefinierten Attributs.</param>
        <param name="attributeValue">Der Wert des benutzerdefinierten Attributs.</param>
        <summary>Registriert ein Name-Wert-Paar mithilfe einer bestimmten Steuerelement-ID, eines Attributnamens und eines Attributwerts als benutzerdefiniertes Attribut (Expando-Attribut) des angegebenen Steuerelements.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute%2A> Methode registriert ein Name/Wert-Paar als benutzerdefiniertes (Expando) Attribut für den angegebenen <xref:System.Web.UI.Control>. Das Expando-Attribut wird von JavaScript dynamisch festgelegt, XHTML-Kompatibilität für das gerenderte Markup des Steuerelements beibehalten wird. Anführungszeichen und umgekehrte Schrägstriche in Attributwerten den benutzerdefinierten (Expando) werden mit Escapezeichen versehen. Wenn Sie keine Anführungszeichen und umgekehrte Schrägstriche mit Escapezeichen versehen möchten, rufen Sie die <xref:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute%2A> Überladungsmethode, und legen Sie die `encode` Parameter, um `false`.  
  
 Wenn das Expando-Attribut nicht gefunden wurde oder das Steuerelement, das Expando-Attribut hinzugefügt wurde nicht gefunden, das Clientskript wird immer noch ausgegeben, aber das Steuerelement sind davon nicht betroffen.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:Microsoft.JScript.Expando" />
      </Docs>
    </Member>
    <Member MemberName="RegisterExpandoAttribute">
      <MemberSignature Language="C#" Value="public void RegisterExpandoAttribute (string controlId, string attributeName, string attributeValue, bool encode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterExpandoAttribute(string controlId, string attributeName, string attributeValue, bool encode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute(System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterExpandoAttribute (controlId As String, attributeName As String, attributeValue As String, encode As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterExpandoAttribute(System::String ^ controlId, System::String ^ attributeName, System::String ^ attributeValue, bool encode);" />
      <MemberSignature Language="F#" Value="member this.RegisterExpandoAttribute : string * string * string * bool -&gt; unit" Usage="clientScriptManager.RegisterExpandoAttribute (controlId, attributeName, attributeValue, encode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="controlId" Type="System.String" />
        <Parameter Name="attributeName" Type="System.String" />
        <Parameter Name="attributeValue" Type="System.String" />
        <Parameter Name="encode" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="controlId">Das <see cref="T:System.Web.UI.Control" /> auf der Seite, die das benutzerdefinierte Attribut enthält.</param>
        <param name="attributeName">Der Name des zu registrierenden benutzerdefinierten Attributs.</param>
        <param name="attributeValue">Der Wert des benutzerdefinierten Attributs.</param>
        <param name="encode">Ein boolescher Wert, der angibt, ob das zu registrierende benutzerdefinierte Attribut codiert werden soll.</param>
        <summary>Registriert ein Name-Wert-Paar mithilfe einer bestimmten Steuerelement-ID, eines Attributnamens und eines Attributwerts sowie eines booleschen Werts (der angibt, ob der Attributwert codiert werden soll) als benutzerdefiniertes Attribut (Expando-Attribut) des angegebenen Steuerelements.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute%2A> Methode registriert ein Name/Wert-Paar als benutzerdefiniertes (Expando) Attribut für den angegebenen <xref:System.Web.UI.Control>. Das Expando-Attribut wird von JavaScript dynamisch festgelegt, XHTML-Kompatibilität für das gerenderte Markup des Steuerelements beibehalten wird. Legen Sie die `encode` Parameter `true` Anführungszeichen und umgekehrte Schrägstriche in Ihre Expando-Attribut-Wert mit Escapezeichen versehen werden sollen.  
  
 Wenn das Expando-Attribut nicht gefunden wurde oder das Steuerelement, das Expando-Attribut hinzugefügt wurde nicht gefunden, das Clientskript wird immer noch ausgegeben, aber das Steuerelement sind davon nicht betroffen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie Sie mit der <xref:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute%2A> Methode der <xref:System.Web.UI.ClientScriptManager> Klasse. Das Clientskript in der gerenderten Seite legt die `title` Attribut eine `<span>` Element.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager6#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager6/cs/clientscriptexpando.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager6#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager6/vb/clientscriptexpando.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:Microsoft.JScript.Expando" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterForEventValidation">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Registriert einen Ereignisverweis für die Validierung.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterForEventValidation">
      <MemberSignature Language="C#" Value="public void RegisterForEventValidation (string uniqueId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterForEventValidation(string uniqueId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterForEventValidation (uniqueId As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterForEventValidation(System::String ^ uniqueId);" />
      <MemberSignature Language="F#" Value="member this.RegisterForEventValidation : string -&gt; unit" Usage="clientScriptManager.RegisterForEventValidation uniqueId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uniqueId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uniqueId">Eine eindeutige ID, die das Clientsteuerelement darstellt, das das Ereignis generiert.</param>
        <summary>Registriert einen Ereignisverweis für die Validierung bei einer eindeutigen Steuerelement-ID, die das Clientsteuerelement darstellt, das das Ereignis generiert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen und Beispiele finden Sie unter den <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A> Methode.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie mit der <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A> Methode und die <xref:System.Web.UI.ClientScriptManager.ValidateEvent%2A> Methode zum Registrieren eines Rückrufs für die Überprüfung, und überprüfen Sie, dass der Rückruf über die Seite stammt.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager9#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/cs/eventvalidation2cs.aspx#2)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager9#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/vb/eventvalidation2vb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.ValidateEvent(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterForEventValidation">
      <MemberSignature Language="C#" Value="public void RegisterForEventValidation (System.Web.UI.PostBackOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterForEventValidation(class System.Web.UI.PostBackOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.Web.UI.PostBackOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterForEventValidation (options As PostBackOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterForEventValidation(System::Web::UI::PostBackOptions ^ options);" />
      <MemberSignature Language="F#" Value="member this.RegisterForEventValidation : System.Web.UI.PostBackOptions -&gt; unit" Usage="clientScriptManager.RegisterForEventValidation options" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.Web.UI.PostBackOptions" />
      </Parameters>
      <Docs>
        <param name="options">Ein <see cref="T:System.Web.UI.PostBackOptions" />-Objekt, das angibt, wie clientseitiges JavaScript zum Initiieren eines Postbackereignisses generiert wird.</param>
        <summary>Registriert einen Ereignisverweis für die Validierung bei <see cref="T:System.Web.UI.PostBackOptions" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen und Beispiele finden Sie unter den <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A> Methode.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.ValidateEvent" />
      </Docs>
    </Member>
    <Member MemberName="RegisterForEventValidation">
      <MemberSignature Language="C#" Value="public void RegisterForEventValidation (string uniqueId, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterForEventValidation(string uniqueId, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterForEventValidation (uniqueId As String, argument As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterForEventValidation(System::String ^ uniqueId, System::String ^ argument);" />
      <MemberSignature Language="F#" Value="member this.RegisterForEventValidation : string * string -&gt; unit" Usage="clientScriptManager.RegisterForEventValidation (uniqueId, argument)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uniqueId" Type="System.String" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uniqueId">Eine eindeutige ID, die das Clientsteuerelement darstellt, das das Ereignis generiert.</param>
        <param name="argument">An das Clientereignis übergebene Ereignisargumente.</param>
        <summary>Registriert einen Ereignisverweis für die Validierung bei einer eindeutigen Steuerelement-ID und Ereignisargumenten, die das Clientsteuerelement darstellen, das das Ereignis generiert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung der <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A> Methode und die <xref:System.Web.UI.ClientScriptManager.ValidateEvent%2A> Methode zum Registrieren eines Rückrufs für die Validierung und um sicherzustellen, dass der Rückruf von der Seite stammen. Zur Verbesserung der für die Validierung, die im Beispiel gezeigt, Sie könnten die Validierung ändern `argument` Parameter, um Informationen zu Benutzer z. B. einer Identität oder Rolle enthalten  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager9#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/cs/EventValidationCS.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager9#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/vb/EventValidationVB.aspx#1)]  
  
 Das folgende Codebeispiel veranschaulicht die Verwendung der <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A> Methode, um einen Rückruf für die Validierung zu registrieren.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager10#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.ui.clientscriptmanager10/cs/default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager10#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.ui.clientscriptmanager10/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Methode wird vor der <see cref="M:System.Web.UI.Page.Render(System.Web.UI.HtmlTextWriter)" />-Methode aufgerufen.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.ValidateEvent(System.String,System.String)" />
        <related type="Article" href="https://msdn.microsoft.com/library/18fc94c9-56fc-46c3-9f29-7358f18667df">Clientrückruf mit Beispiel für die Implementierung von Validierung</related>
      </Docs>
    </Member>
    <Member MemberName="RegisterHiddenField">
      <MemberSignature Language="C#" Value="public void RegisterHiddenField (string hiddenFieldName, string hiddenFieldInitialValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterHiddenField(string hiddenFieldName, string hiddenFieldInitialValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterHiddenField(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterHiddenField (hiddenFieldName As String, hiddenFieldInitialValue As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterHiddenField(System::String ^ hiddenFieldName, System::String ^ hiddenFieldInitialValue);" />
      <MemberSignature Language="F#" Value="member this.RegisterHiddenField : string * string -&gt; unit" Usage="clientScriptManager.RegisterHiddenField (hiddenFieldName, hiddenFieldInitialValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hiddenFieldName" Type="System.String" />
        <Parameter Name="hiddenFieldInitialValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="hiddenFieldName">Der Name des zu registrierenden ausgeblendeten Felds.</param>
        <param name="hiddenFieldInitialValue">Der Anfangswert des zu registrierenden Felds.</param>
        <summary>Registriert einen ausgeblendeten Wert für das <see cref="T:System.Web.UI.Page" />-Objekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.ClientScriptManager.RegisterHiddenField%2A> erstellt die Methode ein ausgeblendetes `<input>` Element auf der gerenderten HTML-Seite.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der <xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A> und <xref:System.Web.UI.ClientScriptManager.RegisterHiddenField%2A> Methoden. Im Beispiel wird ein Array und einen ausgeblendeten Wert registriert und definiert die `OnClick` Ereignis eine `<input>` Schaltfläche, um die Summe der beiden Werte des Arrays und dem ausgeblendeten Wert zu berechnen.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager5#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager5/cs/clientscriptregisterarray.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager5#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager5/vb/clientscriptregisterarray.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="hiddenFieldName" /> ist <see langword="null" />.</exception>
        <altmember cref="T:System.Web.UI.WebControls.HiddenField" />
      </Docs>
    </Member>
    <Member MemberName="RegisterOnSubmitStatement">
      <MemberSignature Language="C#" Value="public void RegisterOnSubmitStatement (Type type, string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterOnSubmitStatement(class System.Type type, string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement(System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterOnSubmitStatement(Type ^ type, System::String ^ key, System::String ^ script);" />
      <MemberSignature Language="F#" Value="member this.RegisterOnSubmitStatement : Type * string * string -&gt; unit" Usage="clientScriptManager.RegisterOnSubmitStatement (type, key, script)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Der Typ der zu registrierenden OnSubmit-Anweisung.</param>
        <param name="key">Der Schlüssel der zu registrierenden OnSubmit-Anweisung.</param>
        <param name="script">Das Skriptliteral der zu registrierenden OnSubmit-Anweisung.</param>
        <summary>Registriert unter Verwendung eines Typs, eines Schlüssels sowie eines Skriptliterals eine OnSubmit-Anweisung für das <see cref="T:System.Web.UI.Page" />-Objekt. Die Anweisung wird beim Übermitteln des <see cref="T:System.Web.UI.HtmlControls.HtmlForm" /> ausgeführt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine OnSubmit-Anweisung wird durch seinen Schlüssel und seinen Typ eindeutig identifiziert. Anweisungen mit den gleichen Schlüssel und Typ werden als Duplikate betrachtet. Nur eine Anweisung mit einem angegebenen Typ und das Schlüsselpaar kann mit der Seite registriert werden. Versucht, eine Anweisung zu registrieren, die bereits registriert ist, wird ein Duplikat der Anweisung nicht erstellt.  
  
 Rufen Sie die <xref:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered%2A> Methode, um zu bestimmen, ob eine OnSubmit-Anweisung mit einem angegebenen Paar aus Schlüssel und Typ bereits registriert ist und nicht unnötigerweise das Skript hinzugefügt.  
  
 Die `script` Parameter, der die <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A> Methode kann mehrere Skriptbefehle enthalten, solange sie ordnungsgemäß mit einem Semikolon (;) getrennte sind.  
  
 Die <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A> Fügt ein Skript, das ausgeführt wird, bevor die Seite übermittelt wird, und bietet Ihnen die Möglichkeit der Übermittlung.  
  
 Weitere Informationen zum HTML-Formulare und `OnSubmit` Attribut, finden Sie unter den [World Wide Web Consortium (W3C)-Website](https://go.microsoft.com/fwlink/?linkid=37125).  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A> Methode.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager3#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager3/cs/clientscriptonsubmit.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager3#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager3/vb/clientscriptonsubmit.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> ist <see langword="null" />.</exception>
        <altmember cref="T:System.Web.UI.HtmlControls.HtmlForm" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterStartupScript">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Registriert das Startskript für das <see cref="T:System.Web.UI.Page" />-Objekt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterStartupScript">
      <MemberSignature Language="C#" Value="public void RegisterStartupScript (Type type, string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterStartupScript(class System.Type type, string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterStartupScript(System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterStartupScript(Type ^ type, System::String ^ key, System::String ^ script);" />
      <MemberSignature Language="F#" Value="member this.RegisterStartupScript : Type * string * string -&gt; unit" Usage="clientScriptManager.RegisterStartupScript (type, key, script)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Der Typ des zu registrierenden Startskripts.</param>
        <param name="key">Der Schlüssel des zu registrierenden Startskripts.</param>
        <param name="script">Das zu registrierende Startskriptliteral.</param>
        <summary>Registriert unter Verwendung eines Typs, eines Schlüssels und eines Skriptliterals das Startskript für das <see cref="T:System.Web.UI.Page" />-Objekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Clientskript wird durch seinen Schlüssel und seinen Typ eindeutig identifiziert. Skripts mit den gleichen Schlüssel und Typ werden als Duplikate betrachtet. Nur ein Skript mit einem angegebenen Typ und das Schlüsselpaar kann mit der Seite registriert werden. Versucht, ein Skript zu registrieren, die bereits registriert ist, wird ein Duplikat des Skripts nicht erstellt.  
  
 Rufen Sie die <xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A> Methode, um zu bestimmen, ob ein Startskript mit einem angegebenen Paar aus Schlüssel und Typ bereits registriert ist und nicht unnötigerweise das Skript hinzugefügt.  
  
 In dieser Überladung der der <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> -Methode, Sie müssen sicherstellen, dass das Skript, in bereitgestellt der `script` Parameter in gesetzt ist eine `<script>` Elementblock.  
  
 Der Skriptblock hinzugefügt, indem die <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> Methode ausgeführt wird, wenn die Seite geladen wurde, aber vor der Seite <xref:System.Web.UI.Control.OnLoad%2A> Ereignis wird ausgelöst. Skriptblöcke werden nicht unbedingt in der Reihenfolge ausgegeben werden, die sie registriert sind. Wenn die Reihenfolge der Skriptblöcke wichtig ist, verwenden Sie eine <xref:System.Text.StringBuilder> das Objekt, für die Skripts in einer einzelnen Zeichenfolge zusammenfassen, und registrieren Sie sie alle in einem einzelnen Client-Skriptblock.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> Methode. Beachten Sie, die die öffnenden und schließenden Skripttags, in enthalten sind der `script` Parameter. Um das Skript zu erhalten, basierend auf einem zusätzlichen Parameter-Einstellung, Tags hinzugefügt wurden, finden Sie unter, den <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> Methode.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager11#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.ui.clientscriptmanager11/cs/default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager11#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.ui.clientscriptmanager11/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterStartupScript(System.Type,System.String,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterStartupScript">
      <MemberSignature Language="C#" Value="public void RegisterStartupScript (Type type, string key, string script, bool addScriptTags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterStartupScript(class System.Type type, string key, string script, bool addScriptTags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterStartupScript(System.Type,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterStartupScript(Type ^ type, System::String ^ key, System::String ^ script, bool addScriptTags);" />
      <MemberSignature Language="F#" Value="member this.RegisterStartupScript : Type * string * string * bool -&gt; unit" Usage="clientScriptManager.RegisterStartupScript (type, key, script, addScriptTags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
        <Parameter Name="addScriptTags" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">Der Typ des zu registrierenden Startskripts.</param>
        <param name="key">Der Schlüssel des zu registrierenden Startskripts.</param>
        <param name="script">Das zu registrierende Startskriptliteral.</param>
        <param name="addScriptTags">Ein boolescher Wert, der angibt, ob Skripttags hinzugefügt werden sollen.</param>
        <summary>Registriert unter Verwendung eines Typs, eines Schlüssels, eines Skriptliterals sowie eines booleschen Werts, der angibt, ob Skripttags hinzugefügt werden sollen, das Startskript für das <see cref="T:System.Web.UI.Page" />-Objekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Startskript wird durch seinen Schlüssel und seinen Typ eindeutig identifiziert. Skripts mit den gleichen Schlüssel und Typ werden als Duplikate betrachtet. Nur ein Skript mit einem angegebenen Typ und das Schlüsselpaar kann mit der Seite registriert werden. Versucht, ein Skript zu registrieren, die bereits registriert ist, wird ein Duplikat des Skripts nicht erstellt.  
  
 Rufen Sie die <xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A> Methode, um zu bestimmen, ob ein Startskript mit einem angegebenen Paar aus Schlüssel und Typ bereits registriert ist und nicht unnötigerweise das Skript hinzugefügt.  
  
 In dieser Überladung der der <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> -Methode können Sie angeben, ob das Skript, in bereitgestellt der `script` Parameter in gesetzt ist eine `<script>` Elementblock mithilfe der `addScriptTags` Parameter. Festlegen von `addScriptTags` zu `true` gibt an, dass die Skripttags automatisch hinzugefügt werden.  
  
 Der Skriptblock hinzugefügt, indem die <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> Methode ausgeführt wird, wenn die Seite geladen wurde, aber vor der Seite <xref:System.Web.UI.Control.OnLoad%2A> Ereignis wird ausgelöst. Skriptblöcke werden nicht unbedingt in der Reihenfolge ausgegeben werden, die sie registriert sind. Wenn die Reihenfolge der Skriptblöcke wichtig ist, verwenden Sie eine <xref:System.Text.StringBuilder> das Objekt, für die Skripts in einer einzelnen Zeichenfolge zusammenfassen, und registrieren Sie sie alle in einem einzelnen Client-Skriptblock.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> Methode. Beachten Sie, dass die `addScriptTags` Parametersatz zu `false` , damit die öffnenden und schließenden Skripttags enthalten sind die `script` Parameter.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterStartupScript(System.Type,System.String,System.String)" />
        <altmember cref="F:System.Web.UI.HtmlTextWriterTag.Script" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ValidateEvent">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Validiert ein Clientereignis.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ValidateEvent">
      <MemberSignature Language="C#" Value="public void ValidateEvent (string uniqueId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ValidateEvent(string uniqueId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.ValidateEvent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ValidateEvent (uniqueId As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ValidateEvent(System::String ^ uniqueId);" />
      <MemberSignature Language="F#" Value="member this.ValidateEvent : string -&gt; unit" Usage="clientScriptManager.ValidateEvent uniqueId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uniqueId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uniqueId">Eine eindeutige ID, die das Clientsteuerelement darstellt, das das Ereignis generiert.</param>
        <summary>Validiert ein Clientereignis, das mit der <see cref="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String)" />-Methode für die Ereignisvalidierung registriert wurde.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ValidateEvent">
      <MemberSignature Language="C#" Value="public void ValidateEvent (string uniqueId, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ValidateEvent(string uniqueId, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.ValidateEvent(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ValidateEvent (uniqueId As String, argument As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ValidateEvent(System::String ^ uniqueId, System::String ^ argument);" />
      <MemberSignature Language="F#" Value="member this.ValidateEvent : string * string -&gt; unit" Usage="clientScriptManager.ValidateEvent (uniqueId, argument)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uniqueId" Type="System.String" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uniqueId">Eine eindeutige ID, die das Clientsteuerelement darstellt, das das Ereignis generiert.</param>
        <param name="argument">An das Clientereignis übergebene Ereignisargumente.</param>
        <summary>Validiert ein Clientereignis, das mit der <see cref="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String,System.String)" />-Methode für die Ereignisvalidierung registriert wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung der <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A> Methode und die <xref:System.Web.UI.ClientScriptManager.ValidateEvent%2A> Methode zum Registrieren eines Rückrufs für die Validierung und um sicherzustellen, dass der Rückruf von der Seite stammen. Zur Verbesserung der für die Validierung, die hier gezeigten können Sie die Überprüfung ändern `argument` Parameter, um Informationen zu Benutzer z. B. einer Identität oder Rolle enthalten  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager9#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/cs/EventValidationCS.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager9#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/vb/EventValidationVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="uniqueId" /> ist <see langword="null" /> oder eine leere Zeichenfolge ("").</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String,System.String)" />
      </Docs>
    </Member>
  </Members>
</Type>