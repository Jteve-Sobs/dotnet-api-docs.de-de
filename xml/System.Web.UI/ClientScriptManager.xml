<Type Name="ClientScriptManager" FullName="System.Web.UI.ClientScriptManager">
  <Metadata><Meta Name="ms.openlocfilehash" Value="247741a791bcc13dd2c749f7a1c5806e39fc908e" /><Meta Name="ms.sourcegitcommit" Value="1b924db57b3a1cf768d98c21f9b988d6966a0f2b" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="03/06/2020" /><Meta Name="ms.locfileid" Value="78760782" /></Metadata><TypeSignature Language="C#" Value="public sealed class ClientScriptManager" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ClientScriptManager extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.ClientScriptManager" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ClientScriptManager" />
  <TypeSignature Language="C++ CLI" Value="public ref class ClientScriptManager sealed" />
  <TypeSignature Language="F#" Value="type ClientScriptManager = class" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Definiert Methoden zum Verwalten von Clientskripts in Webanwendungen.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.ClientScriptManager>-Klasse wird zum Verwalten von Client Skripts und zum Hinzufügen zu Webanwendungen verwendet. Sie können einen Verweis auf die <xref:System.Web.UI.ClientScriptManager>-Klasse von der <xref:System.Web.UI.Page.ClientScript%2A>-Eigenschaft des <xref:System.Web.UI.Page>-Objekts erhalten.  
  
 Sie können einer Webseite ein Client Skript deklarativ hinzufügen, indem Sie das Skript in das HTML-Markup der Seite einschließen. Es gibt jedoch Situationen, in denen das dynamische Hinzufügen von Client Skripts erforderlich ist. Wenn Sie ein Skript dynamisch hinzufügen möchten, verwenden Sie die <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A>-Methode, die <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A>-Methode, die <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A>-Methode oder die <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A>-Methode, je nachdem, wann und wie Sie das Skript hinzufügen möchten. Weitere Informationen finden Sie unter Gewusst [wie: Dynamisches Hinzufügen von Client Skripts zu ASP.net Web Pages](https://msdn.microsoft.com/library/e89f1306-e43d-49ae-a66a-e18b71007666).  
  
 Die <xref:System.Web.UI.ClientScriptManager>-Klasse identifiziert Skripts eindeutig durch einen Schlüssel <xref:System.String> und eine <xref:System.Type>. Skripts mit demselben Schlüssel und Typ werden als Duplikate angesehen. Mit dem Skripttyp können Sie vermeiden, dass ähnliche Skripts von unterschiedlichen Benutzer Steuerelementen verwechselt werden, die auf der Seite verwendet werden könnten.  
  
 Die <xref:System.Web.UI.ClientScriptManager>-Klasse kann verwendet werden, um Client Rückrufe in Situationen aufzurufen, in denen es wünschenswert ist, Servercode vom Client auszuführen, ohne ein Postback auszuführen. Dies wird als Ausführen eines Out-of-Band-Rückrufs an den Server bezeichnet. Bei einem Client Rückruf sendet eine Client Skriptfunktion eine asynchrone Anforderung an eine ASP.NET-Webseite. Die Webseite führt eine geänderte Version des normalen Lebenszyklus aus, um den Rückruf zu verarbeiten. Verwenden Sie die <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A>-Methode zum Abrufen eines Verweises auf eine Client Funktion, die beim Aufrufen einen Client Rückruf für ein Server Ereignis initiiert. Weitere Informationen finden Sie unter [Implementieren von Client Rückrufen ohne Postbacks](https://docs.microsoft.com/previous-versions/aspnet/ms178208(v=vs.100)).  
  
> [!NOTE]
>  Skript Rückrufe funktionieren in älteren Browsern nicht, die die Dokumentobjektmodell (DOM) nicht unterstützen, und erfordern, dass ECMAScript auf dem Client aktiviert ist. Um zu überprüfen, ob der Browser Rückrufe unterstützt, verwenden Sie die <xref:System.Web.Configuration.HttpCapabilitiesBase.SupportsCallback%2A>-Eigenschaft, auf die über die <xref:System.Web.HttpRequest.Browser%2A>-Eigenschaft des systeminternen ASP.net <xref:System.Web.HttpContext.Request%2A>-Objekts zugegriffen werden kann.  
  
 Verwenden Sie die <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A>-Methode und die <xref:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink%2A>-Methode, um ein Client-Post Back Ereignis zu definieren. Diese Methoden aktivieren Client Skriptfunktionen, wenn Sie aufgerufen werden, um den Server zur Seite zurückzukehren. Ein Client-Post Back Ereignis unterscheidet sich von einem Client Rückruf darin, dass die Webseite einen normalen Lebenszyklus für die Verarbeitung des Client Postback-Ereignisses abschließt.  
  
> [!NOTE]
>  Wenn Sie ein <xref:System.Web.UI.WebControls.Button>-Steuerelement verwenden und die <xref:System.Web.UI.WebControls.Button.UseSubmitBehavior%2A>-Eigenschaft auf `false`festgelegt ist, können Sie die <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A>-Methode verwenden, um das Client Postback-Ereignis für das <xref:System.Web.UI.WebControls.Button>-Steuerelement zurückzugeben.  
  
 Die <xref:System.Web.UI.WebControls.Button.OnClientClick%2A>-Eigenschaft des <xref:System.Web.UI.WebControls.Button> Steuer Elements, <xref:System.Web.UI.WebControls.ImageButton>-Steuer Elements und <xref:System.Web.UI.WebControls.LinkButton>-Steuerelement kann zum Ausführen des Client Skripts verwendet werden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung der <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A>-Methode der <xref:System.Web.UI.ClientScriptManager>-Klasse veranschaulicht. Auf der Seite sind zwei Client Skripts definiert: `PopupScript`, das eine Warnmeldung anzeigt, wenn die Seite geladen wird, und `ButtonClickScript`, die einen Client Handler für das `onClick` Ereignis einer HTML-Schaltfläche definiert.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb.aspx#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Web.UI.Page" />
    <altmember cref="P:System.Web.Configuration.HttpCapabilitiesBase.SupportsCallback" />
    <altmember cref="P:System.Web.Configuration.HttpCapabilitiesBase.SupportsXmlHttp" />
    <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/3hc29e2a(v=vs.100)">Client Skript in ASP.net Web Pages</related>
    <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/ms178208(v=vs.100)">Client Rückrufe ohne Postbacks auf ASP.NET Seiten</related>
  </Docs>
  <Members>
    <MemberGroup MemberName="GetCallbackEventReference">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft einen Verweis auf eine Clientfunktion ab, die beim Aufruf einen Clientrückruf für ein Serverereignis initiiert.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCallbackEventReference">
      <MemberSignature Language="C#" Value="public string GetCallbackEventReference (System.Web.UI.Control control, string argument, string clientCallback, string context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetCallbackEventReference(class System.Web.UI.Control control, string argument, string clientCallback, string context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetCallbackEventReference(System.Web.UI.Control,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCallbackEventReference (control As Control, argument As String, clientCallback As String, context As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetCallbackEventReference(System::Web::UI::Control ^ control, System::String ^ argument, System::String ^ clientCallback, System::String ^ context);" />
      <MemberSignature Language="F#" Value="member this.GetCallbackEventReference : System.Web.UI.Control * string * string * string -&gt; string" Usage="clientScriptManager.GetCallbackEventReference (control, argument, clientCallback, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="clientCallback" Type="System.String" />
        <Parameter Name="context" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">Das Server-<see cref="T:System.Web.UI.Control" />, das den Clientrückruf behandelt. Das Steuerelement muss die <see cref="T:System.Web.UI.ICallbackEventHandler" />-Schnittstelle implementieren und eine <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" />-Methode bereitstellen.</param>
        <param name="argument">Ein Argument, das vom Clientskript an den Server übergeben wird. 
 <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" /> -Methode.</param>
        <param name="clientCallback">Der Name des Clientereignishandlers, der das Ergebnis des erfolgreich ausgeführten Serverereignisses empfängt.</param>
        <param name="context">Clientskript, das auf dem Client vor der Initialisierung des Rückrufs ausgewertet wird. Das Ergebnis des Skripts wird an den Clientereignishandler zurückgegeben.</param>
        <summary>Ruft einen Verweis auf eine Clientfunktion ab, die beim Aufruf einen Clientrückruf für ein Serverereignis initiiert. Die Clientfunktion für diese überladene Methode schließt ein angegebenes Steuerelement, ein Argument, ein Clientskript sowie einen Kontext ein.</summary>
        <returns>Der Name einer Clientfunktion, die den Clientrückruf ausführt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%28System.Web.UI.Control%2CSystem.String%2CSystem.String%2CSystem.String%29>-Methode führt einen Out-of-Band-Rückruf an den Server aus, bei dem es sich um eine geänderte Version des normalen Lebenszyklus einer Seite handelt. Weitere Informationen finden Sie unter [Implementieren von Client Rückrufen ohne Postbacks](https://docs.microsoft.com/previous-versions/aspnet/ms178208(v=vs.100)).  
  
> [!NOTE]
>  Wenn es sich bei dem Browser um Microsoft Internet Explorer (Version 5,0 oder höher) handelt, wird der Skript Rückrufmechanismus über das COM-Objekt "Microsoft. XMLHTTP" implementiert und erfordert, dass der Browser für die Ausführung von ActiveX-Steuerelementen festgelegt wird. Bei anderen Browsern wird ein XMLHttpRequest-Objekt verwendet, das den lokalen Dokumentobjektmodell (DOM) des Browsers verwendet. Verwenden Sie die <xref:System.Web.Configuration.HttpCapabilitiesBase.SupportsCallback%2A>-Eigenschaft, um zu überprüfen, ob ein Browser Client Rückrufe unterstützt. Verwenden Sie die <xref:System.Web.Configuration.HttpCapabilitiesBase.SupportsXmlHttp%2A>-Eigenschaft, um zu überprüfen, ob ein Browser XML über HTTP unterstützt. Beide Eigenschaften sind über die <xref:System.Web.HttpRequest.Browser%2A>-Eigenschaft des intrinsischen ASP.net <xref:System.Web.HttpContext.Request%2A>-Objekts zugänglich.  
  
 Die <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> Überladung der <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A>-Methode führt einen Rückruf synchron mithilfe von XML über HTTP aus. Beim synchronen Senden von Daten in einem Rückruf Szenario geben synchrone Rückrufe sofort zurück und blockieren den Browser nicht. Es können nicht zwei synchrone Rückruf Rückrufe gleichzeitig im Browser ausgeführt werden. Wenn eine zweite synchrone Rückruffunktion ausgelöst wird, während eine derzeit aussteht, wird der zweite synchrone Rückruf den ersten abbrechen, und nur der zweite Rückruf gibt zurück.  
  
 Verwenden Sie zum asynchronen Senden von Daten eine der-über Ladungen, die den `useAsync`-Parameter verwendet, bei dem es sich um einen booleschen Wert handelt, der dieses Verhalten steuert. Im asynchronen Szenario können mehrere ausstehende Rückrufe vorhanden sein. die Reihenfolge, in der Sie zurückgeben, entspricht jedoch nicht der Reihenfolge, in der Sie initiiert wurden.  
  
 Außerdem gibt diese Überladung der <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A>-Methode keine Client Funktion an, um die Groß-/Kleinschreibung eines von der <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A>-Methode generierten Fehler Zustands zu behandeln. Um einen Client Fehler-Rückruf Handler anzugeben, verwenden Sie eine der-über Ladungen, die den `clientErrorCallback`-Parameter annimmt.  
  
 Die <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%28System.Web.UI.Control%2CSystem.String%2CSystem.String%2CSystem.String%29>-Methode nimmt einen optionalen String-`argument` Parameter an und gibt eine Zeichenfolge zurück. Zum Übergeben von oder zum empfangen mehrerer Werte verketten Sie Werte in der Eingabe-oder Rückgabe Zeichenfolge.  
  
> [!NOTE]
>  Vermeiden Sie die Verwendung des Ansichts Zustands in der Implementierung von Seiten-oder Steuerelement Eigenschaften, die bei Skript Rückruf Vorgängen aktualisiert werden müssen. Wenn die Eigenschaften Seiten Anforderungen überstehen, können Sie den Sitzungszustand verwenden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie zwei über Ladungen der <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A>-Methode in einem Client Rückruf Szenario verwendet werden, in dem ganze Zahlen Inkrementen werden.  
  
 Zwei Rückruf Mechanismen werden angezeigt. der Unterschied besteht darin, dass der `context`-Parameter verwendet wird. Eine `ReceiveServerData1` Client-Rückruffunktion wird mithilfe des `context`-Parameters bereitgestellt. Im Gegensatz dazu wird die Rückruffunktion des `ReceiveServerData2` Clients in einem `<script>` Block auf der Seite definiert. Eine <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A>-Methode ist der Server Handler, der den an ihn über gebenden Wert inkrementiert, und die <xref:System.Web.UI.ICallbackEventHandler.GetCallbackResult%2A>-Methode gibt den inkrementierten Wert als Zeichenfolge zurück. Wenn die <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A>-Methode einen Fehler zurückgibt, wird die `ProcessCallBackError` Client-Funktion aufgerufen.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager7#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager7/cs/getcallbackeventreference.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager7#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager7/vb/getcallbackeventreference.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der angegebene <see cref="T:System.Web.UI.Control" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Das angegebene <see cref="T:System.Web.UI.Control" /> implementiert die <see cref="T:System.Web.UI.ICallbackEventHandler" />-Schnittstelle nicht.</exception>
        <altmember cref="T:System.Web.UI.ICallbackEventHandler" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/ms178208(v=vs.100)">Client Rückrufe ohne Postbacks auf ASP.NET Seiten</related>
      </Docs>
    </Member>
    <Member MemberName="GetCallbackEventReference">
      <MemberSignature Language="C#" Value="public string GetCallbackEventReference (System.Web.UI.Control control, string argument, string clientCallback, string context, bool useAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetCallbackEventReference(class System.Web.UI.Control control, string argument, string clientCallback, string context, bool useAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetCallbackEventReference(System.Web.UI.Control,System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCallbackEventReference (control As Control, argument As String, clientCallback As String, context As String, useAsync As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetCallbackEventReference(System::Web::UI::Control ^ control, System::String ^ argument, System::String ^ clientCallback, System::String ^ context, bool useAsync);" />
      <MemberSignature Language="F#" Value="member this.GetCallbackEventReference : System.Web.UI.Control * string * string * string * bool -&gt; string" Usage="clientScriptManager.GetCallbackEventReference (control, argument, clientCallback, context, useAsync)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="clientCallback" Type="System.String" />
        <Parameter Name="context" Type="System.String" />
        <Parameter Name="useAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">Das Server-<see cref="T:System.Web.UI.Control" />, das den Clientrückruf behandelt. Das Steuerelement muss die <see cref="T:System.Web.UI.ICallbackEventHandler" />-Schnittstelle implementieren und eine <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" />-Methode bereitstellen.</param>
        <param name="argument">Ein Argument, das vom Clientskript an den Server übergeben wird. 
 <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" /> -Methode.</param>
        <param name="clientCallback">Der Name des Clientereignishandlers, der das Ergebnis des erfolgreich ausgeführten Serverereignisses empfängt.</param>
        <param name="context">Clientskript, das auf dem Client vor der Initialisierung des Rückrufs ausgewertet wird. Das Ergebnis des Skripts wird an den Clientereignishandler zurückgegeben.</param>
        <param name="useAsync"><see langword="true" />, um den Rückruf asynchron auszuführen, <see langword="false" />, um den Rückruf synchron auszuführen.</param>
        <summary>Ruft einen Verweis auf eine Clientfunktion ab, die beim Aufruf einen Clientrückruf für Serverereignisse initiiert. Die Clientfunktion für diese überladene Methode schließt ein angegebenes Steuerelement, ein Argument, ein Clientskript, einen Kontext sowie einen booleschen Wert ein.</summary>
        <returns>Der Name einer Clientfunktion, die den Clientrückruf ausführt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung der <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A>-Methode erfordert einen `useAsync`-Parameter, mit dem Sie den Client Rückruf asynchron ausführen können, indem Sie den Wert auf `true`festlegen. Die Überladungs Versionen dieser Methode, die den `useAsync`-Parameter nicht benötigen, legen den Wert standardmäßig auf `false` fest.  
  
 Weitere Informationen zu dieser Methode finden Sie in den Hinweisen für die Überladungs <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der angegebene <see cref="T:System.Web.UI.Control" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Das angegebene <see cref="T:System.Web.UI.Control" /> implementiert die <see cref="T:System.Web.UI.ICallbackEventHandler" />-Schnittstelle nicht.</exception>
        <altmember cref="T:System.Web.UI.ICallbackEventHandler" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/ms178208(v=vs.100)">Client Rückrufe ohne Postbacks auf ASP.NET Seiten</related>
      </Docs>
    </Member>
    <Member MemberName="GetCallbackEventReference">
      <MemberSignature Language="C#" Value="public string GetCallbackEventReference (string target, string argument, string clientCallback, string context, string clientErrorCallback, bool useAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetCallbackEventReference(string target, string argument, string clientCallback, string context, string clientErrorCallback, bool useAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetCallbackEventReference(System.String,System.String,System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCallbackEventReference (target As String, argument As String, clientCallback As String, context As String, clientErrorCallback As String, useAsync As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetCallbackEventReference(System::String ^ target, System::String ^ argument, System::String ^ clientCallback, System::String ^ context, System::String ^ clientErrorCallback, bool useAsync);" />
      <MemberSignature Language="F#" Value="member this.GetCallbackEventReference : string * string * string * string * string * bool -&gt; string" Usage="clientScriptManager.GetCallbackEventReference (target, argument, clientCallback, context, clientErrorCallback, useAsync)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.String" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="clientCallback" Type="System.String" />
        <Parameter Name="context" Type="System.String" />
        <Parameter Name="clientErrorCallback" Type="System.String" />
        <Parameter Name="useAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="target">Der Name von einem Server-<see cref="T:System.Web.UI.Control" />, das den Clientrückruf behandelt. Das Steuerelement muss die <see cref="T:System.Web.UI.ICallbackEventHandler" />-Schnittstelle implementieren und eine <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" />-Methode bereitstellen.</param>
        <param name="argument">Ein Argument, das vom Clientskript an den Server übergeben wird. 
 <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" /> -Methode.</param>
        <param name="clientCallback">Der Name des Clientereignishandlers, der das Ergebnis des erfolgreich ausgeführten Serverereignisses empfängt.</param>
        <param name="context">Clientskript, das auf dem Client vor der Initialisierung des Rückrufs ausgewertet wird. Das Ergebnis des Skripts wird an den Clientereignishandler zurückgegeben.</param>
        <param name="clientErrorCallback">Der Name des Clientereignishandlers, der das Ergebnis empfängt, wenn ein Fehler im Serverereignishandler auftritt.</param>
        <param name="useAsync"><see langword="true" />, um den Rückruf asynchron auszuführen, <see langword="false" />, um den Rückruf synchron auszuführen.</param>
        <summary>Ruft einen Verweis auf eine Clientfunktion ab, die beim Aufruf einen Clientrückruf für Serverereignisse initiiert. Die Clientfunktion für diese überladene Methode schließt ein angegebenes Ziel, ein Argument, ein Clientskript, einen Kontext, einen Fehlerhandler sowie einen booleschen Wert ein.</summary>
        <returns>Der Name einer Clientfunktion, die den Clientrückruf ausführt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung der <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A>-Methode nimmt anstelle eines <xref:System.Web.UI.Control>-Parameters einen `target` String-Parameter an. Verwenden Sie diese Überladung, wenn Sie möchten, dass der Rückruf auf einen anderen Wert als eine Zeichenfolge zurückgeht, die die <xref:System.Web.UI.Control.UniqueID%2A> des Steuer Elements enthält.  
  
 Außerdem ist für diese Überladung der <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A>-Methode ein `useAsync` und ein `clientErrorCallback`-Parameter erforderlich. Mit dem `useAsync`-Parameter können Sie den Client Rückruf asynchron ausführen, indem Sie den Wert auf `true`festlegen. Die Überladungs Versionen dieser Methode, die den `useAsync`-Parameter nicht benötigen, legen den Wert standardmäßig auf `false` fest. Mit dem `clientErrorCallback`-Parameter können Sie den Namen der Client Funktion definieren, die aufgerufen wird, wenn der Server Handler, die <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A>-Methode, einen Fehler zurückgibt. Die Überladungs Versionen dieser Methode, die den `clientErrorCallback`-Parameter nicht benötigen, legen den Wert auf NULL fest.  
  
 Weitere Informationen zu dieser Methode finden Sie in den Hinweisen für die Überladungs <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> Methode.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie zwei über Ladungen der <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A>-Methode in einem Client Rückruf Szenario verwendet werden, in dem ganze Zahlen Inkrementen werden.  
  
 Zwei Rückruf Mechanismen werden angezeigt. der Unterschied besteht darin, dass der `context`-Parameter verwendet wird. Eine `ReceiveServerData1` Client-Rückruffunktion wird mithilfe des `context`-Parameters bereitgestellt. Im Gegensatz dazu wird die Rückruffunktion des `ReceiveServerData2` Clients in einem `<script>` Block auf der Seite definiert. Eine <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A>-Methode ist der Server Handler, der den an ihn über gebenden Wert inkrementiert, und die <xref:System.Web.UI.ICallbackEventHandler.GetCallbackResult%2A>-Methode gibt den inkrementierten Wert als Zeichenfolge zurück. Wenn die <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A>-Methode einen Fehler zurückgibt, wird die Client Funktion `ProcessCallBackError` aufgerufen.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager7#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager7/cs/getcallbackeventreference.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager7#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager7/vb/getcallbackeventreference.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.ICallbackEventHandler" />
        <altmember cref="P:System.Web.UI.Control.UniqueID" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/ms178208(v=vs.100)">Client Rückrufe ohne Postbacks auf ASP.NET Seiten</related>
      </Docs>
    </Member>
    <Member MemberName="GetCallbackEventReference">
      <MemberSignature Language="C#" Value="public string GetCallbackEventReference (System.Web.UI.Control control, string argument, string clientCallback, string context, string clientErrorCallback, bool useAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetCallbackEventReference(class System.Web.UI.Control control, string argument, string clientCallback, string context, string clientErrorCallback, bool useAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetCallbackEventReference(System.Web.UI.Control,System.String,System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCallbackEventReference (control As Control, argument As String, clientCallback As String, context As String, clientErrorCallback As String, useAsync As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetCallbackEventReference(System::Web::UI::Control ^ control, System::String ^ argument, System::String ^ clientCallback, System::String ^ context, System::String ^ clientErrorCallback, bool useAsync);" />
      <MemberSignature Language="F#" Value="member this.GetCallbackEventReference : System.Web.UI.Control * string * string * string * string * bool -&gt; string" Usage="clientScriptManager.GetCallbackEventReference (control, argument, clientCallback, context, clientErrorCallback, useAsync)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="clientCallback" Type="System.String" />
        <Parameter Name="context" Type="System.String" />
        <Parameter Name="clientErrorCallback" Type="System.String" />
        <Parameter Name="useAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">Das Server-<see cref="T:System.Web.UI.Control" />, das den Clientrückruf behandelt. Das Steuerelement muss die <see cref="T:System.Web.UI.ICallbackEventHandler" />-Schnittstelle implementieren und eine <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" />-Methode bereitstellen.</param>
        <param name="argument">Ein Argument, das vom Clientskript an die <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" />-Methode des Servers übergeben wird.</param>
        <param name="clientCallback">Der Name des Clientereignishandlers, der das Ergebnis des erfolgreich ausgeführten Serverereignisses empfängt.</param>
        <param name="context">Clientskript, das auf dem Client vor der Initialisierung des Rückrufs ausgewertet wird. Das Ergebnis des Skripts wird an den Clientereignishandler zurückgegeben.</param>
        <param name="clientErrorCallback">Der Name des Clientereignishandlers, der das Ergebnis empfängt, wenn ein Fehler im Serverereignishandler auftritt.</param>
        <param name="useAsync"><see langword="true" />, um den Rückruf asynchron auszuführen, <see langword="false" />, um den Rückruf synchron auszuführen.</param>
        <summary>Ruft einen Verweis auf eine Clientfunktion ab, die beim Aufruf einen Clientrückruf für Serverereignisse initiiert. Die Clientfunktion für diese überladene Methode schließt ein angegebenes Steuerelement, ein Argument, ein Clientskript, einen Kontext, einen Fehlerhandler sowie einen booleschen Wert ein.</summary>
        <returns>Der Name einer Clientfunktion, die den Clientrückruf ausführt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung der <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A>-Methode erfordert eine `useAsync` und einen `clientErrorCallback`-Parameter. Mit dem `useAsync`-Parameter können Sie den Client Rückruf asynchron ausführen, indem Sie den Wert auf `true`festlegen. Die Überladungs Versionen dieser Methode, die den `useAsync`-Parameter nicht benötigen, legen den Wert standardmäßig auf `false` fest. Mit dem `clientErrorCallback`-Parameter können Sie den Namen der Client Funktion definieren, die aufgerufen wird, wenn der Server Handler (<xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A>-Methode) einen Fehler zurückgibt. Die Überladungs Versionen dieser Methode, die den `clientErrorCallback`-Parameter nicht benötigen, legen den Wert auf NULL fest.  
  
 Weitere Informationen zu dieser Methode finden Sie in den Hinweisen für die Überladungs <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der angegebene <see cref="T:System.Web.UI.Control" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Das angegebene <see cref="T:System.Web.UI.Control" /> implementiert die <see cref="T:System.Web.UI.ICallbackEventHandler" />-Schnittstelle nicht.</exception>
        <altmember cref="T:System.Web.UI.ICallbackEventHandler" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/ms178208(v=vs.100)">Client Rückrufe ohne Postbacks auf ASP.NET Seiten</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetPostBackClientHyperlink">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft einen Verweis ab, an dessen Beginn <see langword="javascript:" /> angefügt ist und der in einem Clientereignis für das Postback an den Server verwendet werden kann.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetPostBackClientHyperlink">
      <MemberSignature Language="C#" Value="public string GetPostBackClientHyperlink (System.Web.UI.Control control, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackClientHyperlink(class System.Web.UI.Control control, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink(System.Web.UI.Control,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPostBackClientHyperlink (control As Control, argument As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackClientHyperlink(System::Web::UI::Control ^ control, System::String ^ argument);" />
      <MemberSignature Language="F#" Value="member this.GetPostBackClientHyperlink : System.Web.UI.Control * string -&gt; string" Usage="clientScriptManager.GetPostBackClientHyperlink (control, argument)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">Das Serversteuerelement, das das Postback verarbeiten soll.</param>
        <param name="argument">Der an das Serversteuerelement übergebene Parameter.</param>
        <summary>Ruft einen Verweis ab, an dessen Beginn <see langword="javascript:" /> angefügt ist und der in einem Clientereignis verwendet werden kann, das für das angegebene Steuerelement und mit den angegebenen Ereignisargumenten an den Server zurückgesendet werden soll.</summary>
        <returns>Eine Zeichenfolge, die einen JavaScript-Aufruf der Postbackfunktion darstellt, die ID und Ereignisargumente des Zielsteuerelements enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Verwendung der <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A>-Methode erfordert, dass das Steuerelement, das das Postback behandelt, die <xref:System.Web.UI.IPostBackEventHandler>-Schnittstelle implementiert Um die <xref:System.Web.UI.IPostBackEventHandler>-Schnittstelle für eine <xref:System.Web.UI.Page>zu implementieren, verwenden Sie die-Direktive.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung der <xref:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink%2A>-Methode veranschaulicht. Das benutzerdefinierte Steuerelement, `MyControl`, implementiert die <xref:System.Web.UI.IPostBackEventHandler>-Schnittstelle. Wenn auf das HTML-Anker Element auf der Seite geklickt wird, wird die <xref:System.Web.UI.IPostBackEventHandler.RaisePostBackEvent%2A>-Methode des benutzerdefinierten Steuer Elements aufgerufen.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager8#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/cs/getpostbackeventreferencecs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager8#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/vb/getpostbackeventreferencevb.aspx#1)]  
  
 Das folgende Codebeispiel verfügt über die gleiche Funktionalität wie die vorherige, mit dem Unterschied, dass die <xref:System.Web.UI.Page>-Klasse anstelle eines benutzerdefinierten Steuer Elements die <xref:System.Web.UI.IPostBackEventHandler>-Schnittstelle implementiert.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager8#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/cs/getpostbackeventreference2cs.aspx#2)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager8#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/vb/getpostbackeventreference2vb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.GetPostBackEventReference" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink(System.Web.UI.Control,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="GetPostBackClientHyperlink">
      <MemberSignature Language="C#" Value="public string GetPostBackClientHyperlink (System.Web.UI.Control control, string argument, bool registerForEventValidation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackClientHyperlink(class System.Web.UI.Control control, string argument, bool registerForEventValidation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink(System.Web.UI.Control,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPostBackClientHyperlink (control As Control, argument As String, registerForEventValidation As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackClientHyperlink(System::Web::UI::Control ^ control, System::String ^ argument, bool registerForEventValidation);" />
      <MemberSignature Language="F#" Value="member this.GetPostBackClientHyperlink : System.Web.UI.Control * string * bool -&gt; string" Usage="clientScriptManager.GetPostBackClientHyperlink (control, argument, registerForEventValidation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="registerForEventValidation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">Das Serversteuerelement, das das Postback verarbeiten soll.</param>
        <param name="argument">Der an das Serversteuerelement übergebene Parameter.</param>
        <param name="registerForEventValidation"><see langword="true" />, um das Postbackergebnis für die Validierung zu registrieren, andernfalls <see langword="false" />.</param>
        <summary>Ruft einen Verweis ab, an dessen Beginn <see langword="javascript:" /> angefügt ist und der in einem Clientereignis verwendet werden kann, das für das angegebene Steuerelement mit den angegebenen Ereignisargumenten und dem booleschen Wert, der angibt, ob das Postback für die Ereignisvalidierung registriert werden soll, an den Server zurückgesendet wird.</summary>
        <returns>Eine Zeichenfolge, die einen JavaScript-Aufruf der Postbackfunktion darstellt, die ID und Ereignisargumente des Zielsteuerelements enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Verwendung der <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A>-Methode erfordert, dass das Steuerelement, das das Postback behandelt, die <xref:System.Web.UI.IPostBackEventHandler>-Schnittstelle implementiert Um die <xref:System.Web.UI.IPostBackEventHandler>-Schnittstelle für eine <xref:System.Web.UI.Page>zu implementieren, verwenden Sie die-Direktive.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.GetPostBackEventReference" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink(System.Web.UI.Control,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetPostBackEventReference">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt eine Zeichenfolge zurück, die in einem Clientereignis zum Auslösen eines Postbacks an den Server verwendet werden kann.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetPostBackEventReference">
      <MemberSignature Language="C#" Value="public string GetPostBackEventReference (System.Web.UI.PostBackOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackEventReference(class System.Web.UI.PostBackOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackEventReference(System.Web.UI.PostBackOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPostBackEventReference (options As PostBackOptions) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackEventReference(System::Web::UI::PostBackOptions ^ options);" />
      <MemberSignature Language="F#" Value="member this.GetPostBackEventReference : System.Web.UI.PostBackOptions -&gt; string" Usage="clientScriptManager.GetPostBackEventReference options" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.Web.UI.PostBackOptions" />
      </Parameters>
      <Docs>
        <param name="options">Eine Instanz von <see cref="T:System.Web.UI.PostBackOptions" />, die das Postback definiert.</param>
        <summary>Gibt eine Zeichenfolge zurück, die in einem Clientereignis zum Auslösen eines Postbacks an den Server verwendet werden kann. Die Verweiszeichenfolge wird von der angegebenen <see cref="T:System.Web.UI.PostBackOptions" />-Instanz definiert.</summary>
        <returns>Eine Zeichenfolge, die das Clientpostback initiiert, wenn sie auf dem Client als Skript behandelt wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um die <xref:System.Web.UI.IPostBackEventHandler>-Schnittstelle für eine <xref:System.Web.UI.Page>zu implementieren, verwenden Sie die-Direktive.  
  
 Die <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A>-Methode kann mit dem <xref:System.Web.UI.WebControls.Button>-Steuerelement verwendet werden, wenn die <xref:System.Web.UI.WebControls.Button.UseSubmitBehavior%2A>-Eigenschaft `false`ist. In diesem Szenario gibt die <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A>-Methode das Client-Post Back Ereignis für das <xref:System.Web.UI.WebControls.Button>-Steuerelement zurück.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <see cref="T:System.Web.UI.PostBackOptions" />-Parameter ist <see langword="null" />.</exception>
        <altmember cref="T:System.Web.UI.PostBackOptions" />
        <altmember cref="T:System.Web.UI.IPostBackEventHandler" />
        <altmember cref="T:System.Web.UI.WebControls.Button" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/ms178208(v=vs.100)">Client Rückrufe ohne Postbacks auf ASP.NET Seiten</related>
      </Docs>
    </Member>
    <Member MemberName="GetPostBackEventReference">
      <MemberSignature Language="C#" Value="public string GetPostBackEventReference (System.Web.UI.Control control, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackEventReference(class System.Web.UI.Control control, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackEventReference(System.Web.UI.Control,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPostBackEventReference (control As Control, argument As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackEventReference(System::Web::UI::Control ^ control, System::String ^ argument);" />
      <MemberSignature Language="F#" Value="member this.GetPostBackEventReference : System.Web.UI.Control * string -&gt; string" Usage="clientScriptManager.GetPostBackEventReference (control, argument)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">Das Server-<see cref="T:System.Web.UI.Control" />, das das Postback auf dem Server verarbeitet.</param>
        <param name="argument">Eine Zeichenfolge optionaler Argumente, die an das Steuerelement übergeben werden soll, das das Postback verarbeitet.</param>
        <summary>Gibt eine Zeichenfolge zurück, die in einem Clientereignis zum Auslösen eines Postbacks an den Server verwendet werden kann. Die Verweiszeichenfolge wird durch das angegebene Steuerelement definiert, das das Postback behandelt, und einem Zeichenfolgenargument mit weiteren Ereignisinformationen.</summary>
        <returns>Eine Zeichenfolge, die das Postback initiiert, wenn sie auf dem Client als Skript behandelt wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um die <xref:System.Web.UI.IPostBackEventHandler>-Schnittstelle für eine <xref:System.Web.UI.Page>zu implementieren, verwenden Sie die-Direktive.  
  
 Die <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A>-Methode kann mit dem <xref:System.Web.UI.WebControls.Button>-Steuerelement verwendet werden, wenn die <xref:System.Web.UI.WebControls.Button.UseSubmitBehavior%2A>-Eigenschaft `false`ist. In diesem Szenario gibt die <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A>-Methode das Client-Post Back Ereignis für das <xref:System.Web.UI.WebControls.Button>-Steuerelement zurück.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung der <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A>-Methode veranschaulicht. Das benutzerdefinierte Steuerelement, `MyControl`, implementiert die <xref:System.Web.UI.IPostBackEventHandler>-Schnittstelle. Wenn auf die Schaltfläche auf der Seite geklickt wird, wird die <xref:System.Web.UI.IPostBackEventHandler.RaisePostBackEvent%2A>-Methode des benutzerdefinierten Steuer Elements aufgerufen.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager8#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/cs/getpostbackeventreferencecs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager8#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/vb/getpostbackeventreferencevb.aspx#1)]  
  
 Das folgende Codebeispiel verfügt über die gleiche Funktionalität wie die vorherige, mit dem Unterschied, dass die <xref:System.Web.UI.Page>-Klasse anstelle eines benutzerdefinierten Steuer Elements die <xref:System.Web.UI.IPostBackEventHandler>-Schnittstelle implementiert.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager8#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/cs/getpostbackeventreference2cs.aspx#2)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager8#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/vb/getpostbackeventreference2vb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der angegebene <see cref="T:System.Web.UI.Control" /> ist gleich <see langword="null" />.</exception>
        <altmember cref="T:System.Web.UI.PostBackOptions" />
        <altmember cref="T:System.Web.UI.IPostBackEventHandler" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/ms178208(v=vs.100)">Client Rückrufe ohne Postbacks auf ASP.NET Seiten</related>
      </Docs>
    </Member>
    <Member MemberName="GetPostBackEventReference">
      <MemberSignature Language="C#" Value="public string GetPostBackEventReference (System.Web.UI.PostBackOptions options, bool registerForEventValidation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackEventReference(class System.Web.UI.PostBackOptions options, bool registerForEventValidation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackEventReference(System.Web.UI.PostBackOptions,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPostBackEventReference (options As PostBackOptions, registerForEventValidation As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackEventReference(System::Web::UI::PostBackOptions ^ options, bool registerForEventValidation);" />
      <MemberSignature Language="F#" Value="member this.GetPostBackEventReference : System.Web.UI.PostBackOptions * bool -&gt; string" Usage="clientScriptManager.GetPostBackEventReference (options, registerForEventValidation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.Web.UI.PostBackOptions" />
        <Parameter Name="registerForEventValidation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="options">Eine Instanz von <see cref="T:System.Web.UI.PostBackOptions" />, die das Postback definiert.</param>
        <param name="registerForEventValidation"><see langword="true" />, um den Ereignisverweis für die Validierung zu registrieren, andernfalls <see langword="false" />.</param>
        <summary>Gibt eine Zeichenfolge zurück, die in einem Clientereignis zum Auslösen eines Postbacks an den Server verwendet werden kann. Die Verweiszeichenfolge wird vom angegebenen <see cref="T:System.Web.UI.PostBackOptions" />-Objekt definiert. Registriert den Ereignisverweis optional für die Validierung.</summary>
        <returns>Eine Zeichenfolge, die das Clientpostback initiiert, wenn sie auf dem Client als Skript behandelt wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie die-Direktive, um die <xref:System.Web.UI.IPostBackEventHandler>-Schnittstelle für ein <xref:System.Web.UI.Page> Objekt zu implementieren.  
  
 Die <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A>-Methode kann mit dem <xref:System.Web.UI.WebControls.Button>-Steuerelement verwendet werden, wenn die <xref:System.Web.UI.WebControls.Button.UseSubmitBehavior%2A>-Eigenschaft `false`ist. In diesem Szenario gibt die <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A>-Methode das Client-Post Back Ereignis für das <xref:System.Web.UI.WebControls.Button>-Steuerelement zurück.  
  
 Wenn `registerForEventValidation` `true`ist, ruft die <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%28System.Web.UI.PostBackOptions%2CSystem.Boolean%29>-Methode die <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%28System.String%2CSystem.String%29>-Methode auf, um den Ereignis Verweis für die Validierung mit einer eindeutigen Steuerelement-ID zu registrieren, die das Client Steuerelement darstellt, das das Ereignis erzeugt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der Jointyp (<see cref="T:System.Web.UI.PostBackOptions" />) lautet <see langword="null" />.</exception>
        <altmember cref="T:System.Web.UI.PostBackOptions" />
        <altmember cref="T:System.Web.UI.IPostBackEventHandler" />
        <altmember cref="T:System.Web.UI.WebControls.Button" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/ms178208(v=vs.100)">Client Rückrufe ohne Postbacks auf ASP.NET Seiten</related>
      </Docs>
    </Member>
    <Member MemberName="GetPostBackEventReference">
      <MemberSignature Language="C#" Value="public string GetPostBackEventReference (System.Web.UI.Control control, string argument, bool registerForEventValidation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackEventReference(class System.Web.UI.Control control, string argument, bool registerForEventValidation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackEventReference(System.Web.UI.Control,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPostBackEventReference (control As Control, argument As String, registerForEventValidation As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackEventReference(System::Web::UI::Control ^ control, System::String ^ argument, bool registerForEventValidation);" />
      <MemberSignature Language="F#" Value="member this.GetPostBackEventReference : System.Web.UI.Control * string * bool -&gt; string" Usage="clientScriptManager.GetPostBackEventReference (control, argument, registerForEventValidation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="registerForEventValidation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">Das Server-<see cref="T:System.Web.UI.Control" />, das das Postback auf dem Server verarbeitet.</param>
        <param name="argument">Eine Zeichenfolge optionaler Argumente, die an <paramref name="control" /> übergeben werden sollen.</param>
        <param name="registerForEventValidation"><see langword="true" />, um den Ereignisverweis für die Validierung zu registrieren, andernfalls <see langword="false" />.</param>
        <summary>Gibt eine Zeichenfolge zurück, die in einem Clientereignis zum Auslösen eines Postbacks an den Server verwendet werden kann. Die Verweiszeichenfolge wird durch das angegebene Steuerelement definiert, das das Postback behandelt, und einem Zeichenfolgenargument mit weiteren Ereignisinformationen. Registriert den Ereignisverweis optional für die Validierung.</summary>
        <returns>Eine Zeichenfolge, die das Postback initiiert, wenn sie auf dem Client als Skript behandelt wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um die <xref:System.Web.UI.IPostBackEventHandler>-Schnittstelle für eine <xref:System.Web.UI.Page>zu implementieren, verwenden Sie die-Direktive.  
  
 Die <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A>-Methode kann mit dem <xref:System.Web.UI.WebControls.Button>-Steuerelement verwendet werden, wenn die <xref:System.Web.UI.WebControls.Button.UseSubmitBehavior%2A>-Eigenschaft `false`ist. In diesem Szenario gibt die <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A>-Methode das Client-Post Back Ereignis für das <xref:System.Web.UI.WebControls.Button>-Steuerelement zurück.  
  
 Wenn `registerForEventValidation` true ist, ruft die <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%28System.Web.UI.PostBackOptions%2CSystem.Boolean%29>-Methode die <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%28System.String%2CSystem.String%29>-Methode auf, um den Ereignis Verweis für die Validierung mit einer eindeutigen Steuerelement-ID zu registrieren, die das Client Steuerelement darstellt, das das Ereignis erzeugt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der angegebene <see cref="T:System.Web.UI.Control" /> ist gleich <see langword="null" />.</exception>
        <altmember cref="T:System.Web.UI.PostBackOptions" />
        <altmember cref="T:System.Web.UI.IPostBackEventHandler" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/ms178208(v=vs.100)">Client Rückrufe ohne Postbacks auf ASP.NET Seiten</related>
      </Docs>
    </Member>
    <Member MemberName="GetWebResourceUrl">
      <MemberSignature Language="C#" Value="public string GetWebResourceUrl (Type type, string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetWebResourceUrl(class System.Type type, string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetWebResourceUrl(System.Type,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetWebResourceUrl (type As Type, resourceName As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetWebResourceUrl(Type ^ type, System::String ^ resourceName);" />
      <MemberSignature Language="F#" Value="member this.GetWebResourceUrl : Type * string -&gt; string" Usage="clientScriptManager.GetWebResourceUrl (type, resourceName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="resourceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Der Typ der Ressource.</param>
        <param name="resourceName">Der vollqualifizierte Name der Ressource in der Assembly.</param>
        <summary>Ruft einen URL-Verweis auf eine Ressource in einer Assembly ab.</summary>
        <returns>Der URL-Verweis auf die Ressource.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.ClientScriptManager.GetWebResourceUrl%2A>-Methode gibt einen URL-Verweis auf eine Ressource zurück, die in eine Assembly eingebettet ist. Der zurückgegebene Verweis ist nicht URL-codiert. Ressourcen können Skriptdateien, Bilder oder eine beliebige statische Datei sein. Sie geben den Typ basierend auf dem Objekt an, das auf die Ressource zugreift.  
  
 Eine Webressource, die bei der Seite registriert ist, wird durch ihren Typ und Namen eindeutig identifiziert. Bei der Seite kann nur eine Ressource mit einem bestimmten Typ und namens paar registriert werden. Wenn Sie versuchen, eine Ressource zu registrieren, die bereits registriert ist, wird kein Duplikat der registrierten Ressource erstellt.  
  
 Die <xref:System.Web.UI.ClientScriptManager.GetWebResourceUrl%2A>-Methode wird in Verbindung mit der <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptResource%2A>-Methode für den Zugriff auf in Assemblys eingebettete Ressourcen verwendet. Weitere Informationen zur Verwendung von Ressourcen in Anwendungen finden Sie unter [Übersicht über ASP.NET Webseiten Ressourcen](https://msdn.microsoft.com/library/0936b3b2-9e6e-4abe-9c06-364efef9dbbd).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung der <xref:System.Web.UI.ClientScriptManager.GetWebResourceUrl%2A>-Methode veranschaulicht. Der *Typparameter* in diesem Beispiel wird auf den Typ der Klasse in der Assembly festgelegt, die die Ressource enthält. Der `resourceName`-Parameter wird mit dem voll qualifizierten Pfad der Ressource angegeben, die den Standard Namespace enthält.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager4#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/cs/clientscriptwebresource.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager4#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/vb/clientscriptwebresource.aspx#1)]  
  
 Im folgenden Codebeispiel wird veranschaulicht, wie das <xref:System.Web.UI.WebResourceAttribute> Metadata-Attribut Programm gesteuert angewendet wird, um die Assembly für die zu verwendenden Ressourcen zu markieren. Kompilieren Sie die folgende Klasse in einer Klassenbibliothek mit einem Standard Namespace, der auf `Samples.AspNet.CS.Controls` oder `Samples.AspNet.VB.Controls`festgelegt ist, je nachdem, welche Sprache Sie verwenden.  
  
 [!code-csharp[System.Web.UI.ClientScriptManager4#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/cs/resource.cs#2)]
 [!code-vb[System.Web.UI.ClientScriptManager4#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/vb/resource.vb#2)]  
  
 Für dieses Beispiel ist eine JavaScript-Datei mit dem Namen `Script_include.js`erforderlich. Die JS-Datei ist eine eingebettete Ressource in der Assembly, die das `ClientScriptResourceLabel` Objekt enthält. Wenn Sie Visual Studio verwenden, legen Sie in der Eigenschaftenfenster des Klassen Bibliotheks Projekts **Buildaktion** auf **eingebettete Ressource** fest, wenn die Skriptdatei ausgewählt ist. Wenn Sie die Bibliothek in der Befehlszeile kompilieren, verwenden Sie den Schalter [/Resource](~/docs/csharp/language-reference/compiler-options/resource-compiler-option.md) , um die Ressource einzubetten.  
  
```  
function DoClick() {Form1.Message.value='Text from resource script.'}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der Webressourcentyp ist <see langword="null" />.

Oder

Der Webressourcenname ist <see langword="null" />.  
  
Oder 
Der Webressourcenname hat eine Länge von 0 (null).</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterClientScriptResource(System.Type,System.String)" />
        <altmember cref="T:System.Web.UI.WebResourceAttribute" />
        <altmember cref="T:System.Web.Handlers.AssemblyResourceLoader" />
        <related type="Article" href="https://msdn.microsoft.com/library/0936b3b2-9e6e-4abe-9c06-364efef9dbbd">Übersicht über ASP.NET Webseiten Ressourcen</related>
        <related type="Article" href="https://msdn.microsoft.com/library/5212666e-98ab-47e4-a497-b5545ab15c7f">/Resource (Ressourcen Datei in Ausgabe einbetten)C# (Compileroptionen)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/eee2f227-91f2-4f2b-a9d6-1c51c5320858">/resource (Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsClientScriptBlockRegistered">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Bestimmt, ob der Clientskriptblock für das <see cref="T:System.Web.UI.Page" />-Objekt registriert ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsClientScriptBlockRegistered">
      <MemberSignature Language="C#" Value="public bool IsClientScriptBlockRegistered (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsClientScriptBlockRegistered(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsClientScriptBlockRegistered (key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsClientScriptBlockRegistered(System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsClientScriptBlockRegistered : string -&gt; bool" Usage="clientScriptManager.IsClientScriptBlockRegistered key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Der Schlüssel des zu suchenden Clientskriptblocks.</param>
        <summary>Bestimmt unter Verwendung des angegebenen Schlüssels, ob der Clientskriptblock für das <see cref="T:System.Web.UI.Page" />-Objekt registriert ist.</summary>
        <returns><see langword="true" />, wenn der Clientskriptblock registriert ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie diese Methode auf, bevor Sie die <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A>-Methode aufrufen, damit doppelte Skripts nicht registriert Dies ist besonders wichtig, wenn das Skript eine große Menge an Server Ressourcen benötigt, die erstellt werden müssen.  
  
 Ein Client Skript wird durch seinen Schlüssel und dessen Typ eindeutig identifiziert. Skripts mit demselben Schlüssel und Typ werden als Duplikate angesehen.  
  
 Diese Überladung der <xref:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered%2A>-Methode ruft die-Überladung auf, die sowohl einen `key` als auch einen `type`-Parameter mit dem Typ als <xref:System.Web.UI.Page> Objekt annimmt.  
  
   
  
## Examples  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs2.aspx#2)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb2.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered(System.Type,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock" />
      </Docs>
    </Member>
    <Member MemberName="IsClientScriptBlockRegistered">
      <MemberSignature Language="C#" Value="public bool IsClientScriptBlockRegistered (Type type, string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsClientScriptBlockRegistered(class System.Type type, string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered(System.Type,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsClientScriptBlockRegistered (type As Type, key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsClientScriptBlockRegistered(Type ^ type, System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsClientScriptBlockRegistered : Type * string -&gt; bool" Usage="clientScriptManager.IsClientScriptBlockRegistered (type, key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Der Typ des zu suchenden Clientskriptblocks.</param>
        <param name="key">Der Schlüssel des zu suchenden Clientskriptblocks.</param>
        <summary>Bestimmt unter Verwendung des Schlüssels und des Typs, ob der Clientskriptblock für das <see cref="T:System.Web.UI.Page" />-Objekt registriert ist.</summary>
        <returns><see langword="true" />, wenn der Clientskriptblock registriert ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie diese Methode auf, bevor Sie die <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A>-Methode aufrufen, damit doppelte Skripts nicht registriert Dies ist besonders wichtig, wenn das Skript eine große Menge an Server Ressourcen benötigt, die erstellt werden müssen.  
  
 Ein Client Skript wird durch seinen Schlüssel und dessen Typ eindeutig identifiziert. Skripts mit demselben Schlüssel und Typ werden als Duplikate angesehen. Sie geben den Typ basierend auf dem Objekt an, das auf die Ressource zugreift. Wenn Sie beispielsweise für den Zugriff auf die Ressource eine `Page` Instanz verwenden, geben Sie den `Page` Typ an.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung der <xref:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered%2A>-Methode veranschaulicht. Beachten Sie Folgendes: Wenn die Logik zum Überprüfen des vorhandenen Client Skript Blocks entfernt wurde, sind im HTML-Quellcode der gerenderten Seite nicht zwei doppelte Client Skripts vorhanden, da die <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> Methode auf Duplikate prüft. Der Vorteil der Überprüfung besteht darin, unnötige Berechnungen zu verringern.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der Clientskripttyp ist <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered(System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsClientScriptIncludeRegistered">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Bestimmt, ob der Clientskriptinclude für das <see cref="T:System.Web.UI.Page" />-Objekt registriert ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsClientScriptIncludeRegistered">
      <MemberSignature Language="C#" Value="public bool IsClientScriptIncludeRegistered (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsClientScriptIncludeRegistered(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsClientScriptIncludeRegistered (key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsClientScriptIncludeRegistered(System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsClientScriptIncludeRegistered : string -&gt; bool" Usage="clientScriptManager.IsClientScriptIncludeRegistered key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Der Schlüssel des zu suchenden Clientskriptincludes.</param>
        <summary>Bestimmt unter Verwendung des angegebenen Schlüssels, ob der Clientskriptinclude für das <see cref="T:System.Web.UI.Page" />-Objekt registriert ist.</summary>
        <returns><see langword="true" />, wenn der Clientskriptinclude registriert ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie diese Methode auf, bevor Sie die <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A>-Methode aufrufen, damit doppelte Skripts nicht registriert Dies ist besonders wichtig, wenn das Skript eine große Menge an Server Ressourcen benötigt, die erstellt werden müssen.  
  
 Ein Clientskriptinclude wird durch seinen Schlüssel und dessen Typ eindeutig identifiziert. Skripts mit demselben Schlüssel und Typ werden als Duplikate angesehen.  
  
 Diese Überladung der <xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A>-Methode ruft die-Überladung auf, die sowohl einen `key` als auch einen `type`-Parameter mit dem Typ als <xref:System.Web.UI.Page> Objekt annimmt.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered(System.Type,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude" />
      </Docs>
    </Member>
    <Member MemberName="IsClientScriptIncludeRegistered">
      <MemberSignature Language="C#" Value="public bool IsClientScriptIncludeRegistered (Type type, string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsClientScriptIncludeRegistered(class System.Type type, string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered(System.Type,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsClientScriptIncludeRegistered (type As Type, key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsClientScriptIncludeRegistered(Type ^ type, System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsClientScriptIncludeRegistered : Type * string -&gt; bool" Usage="clientScriptManager.IsClientScriptIncludeRegistered (type, key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Der Typ des zu suchenden Clientskriptincludes.</param>
        <param name="key">Der Schlüssel des zu suchenden Clientskriptincludes.</param>
        <summary>Bestimmt unter Verwendung des Schlüssels und des Typs, ob der Clientskriptinclude für das <see cref="T:System.Web.UI.Page" />-Objekt registriert ist.</summary>
        <returns><see langword="true" />, wenn der Clientskriptinclude registriert ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie diese Methode auf, bevor Sie die <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A>-Methode aufrufen, um zu vermeiden, dass doppelte Client Skript- Dies ist besonders wichtig, wenn das Skript eine große Menge an Server Ressourcen benötigt, die erstellt werden müssen.  
  
 Ein Clientskriptinclude wird durch seinen Schlüssel und dessen Typ eindeutig identifiziert. Skripts mit demselben Schlüssel und Typ werden als Duplikate angesehen. Sie geben den Typ basierend auf dem Objekt an, das auf die Ressource zugreift. Wenn Sie z. b. für den Zugriff auf die Ressource eine Seiten Instanz verwenden, geben Sie den `Page` Typ an.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung der <xref:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered%2A>-Methode veranschaulicht. Beachten Sie Folgendes: Wenn die Logik zum Überprüfen des vorhandenen Client Skripts entfernt wurde, sind im HTML-Quellcode der gerenderten Seite nicht zwei doppelte Client Skripts vorhanden, da die <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A>-Methode auf Duplikate prüft. Der Vorteil der Überprüfung besteht darin, unnötige Berechnungen zu verringern.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager2#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager2/cs/clientscriptincludes.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager2#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager2/vb/clientscriptincludes.aspx#1)]  
  
 Dieses Beispiel erfordert eine JavaScript-Datei mit dem Namen `Script_include.js`mit folgendem Inhalt:  
  
```  
function DoClick() {Form1.Message.value='Text from include script.'}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der Typ des Clientskriptincludes ist <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered(System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsOnSubmitStatementRegistered">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Bestimmt, ob die OnSubmit-Anweisung für das <see cref="T:System.Web.UI.Page" />-Objekt registriert ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsOnSubmitStatementRegistered">
      <MemberSignature Language="C#" Value="public bool IsOnSubmitStatementRegistered (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsOnSubmitStatementRegistered(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsOnSubmitStatementRegistered (key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsOnSubmitStatementRegistered(System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsOnSubmitStatementRegistered : string -&gt; bool" Usage="clientScriptManager.IsOnSubmitStatementRegistered key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Der Schlüssel der zu suchenden OnSubmit-Anweisung.</param>
        <summary>Bestimmt anhand des angegebenen Schlüssels, ob die OnSubmit-Anweisung für das <see cref="T:System.Web.UI.Page" />-Objekt registriert ist.</summary>
        <returns><see langword="true" />, wenn die OnSubmit-Anweisung registriert ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie diese Methode auf, bevor Sie die <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A>-Methode aufrufen, um zu vermeiden, doppelte OnSubmit-Anweisungen Dies ist besonders wichtig, wenn für die-Anweisung eine große Menge an Server Ressourcen erstellt werden muss.  
  
 Eine-Anweisung wird eindeutig durch Ihren Schlüssel und deren Typ identifiziert. Anweisungen mit dem gleichen Schlüssel und Typ werden als Duplikate angesehen.  
  
 Diese Überladung der <xref:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered%2A>-Methode ruft die-Überladung auf, die sowohl einen `key` als auch einen `type`-Parameter mit dem Typ als <xref:System.Web.UI.Page> Objekt annimmt.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered(System.Type,System.String)" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement(System.Type,System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsOnSubmitStatementRegistered">
      <MemberSignature Language="C#" Value="public bool IsOnSubmitStatementRegistered (Type type, string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsOnSubmitStatementRegistered(class System.Type type, string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered(System.Type,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsOnSubmitStatementRegistered (type As Type, key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsOnSubmitStatementRegistered(Type ^ type, System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsOnSubmitStatementRegistered : Type * string -&gt; bool" Usage="clientScriptManager.IsOnSubmitStatementRegistered (type, key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Der Typ der zu suchenden OnSubmit-Anweisung.</param>
        <param name="key">Der Schlüssel der zu suchenden OnSubmit-Anweisung.</param>
        <summary>Bestimmt unter Verwendung des angegebenen Schlüssels und Typs, ob die OnSubmit-Anweisung für das <see cref="T:System.Web.UI.Page" />-Objekt registriert ist.</summary>
        <returns><see langword="true" />, wenn die OnSubmit-Anweisung registriert ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie diese Methode auf, bevor Sie die <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A>-Methode aufrufen, um zu vermeiden, doppelte Anweisungen Dies ist besonders wichtig, wenn für die-Anweisung eine große Menge an Server Ressourcen erstellt werden muss.  
  
 Eine-Anweisung wird eindeutig durch Ihren Schlüssel und deren Typ identifiziert. Anweisungen mit dem gleichen Schlüssel und Typ werden als Duplikate angesehen. Sie geben den Typ basierend auf dem Objekt an, das auf die Ressource zugreift. Wenn Sie beispielsweise für den Zugriff auf die Ressource eine `Page` Instanz verwenden, geben Sie den `Page` Typ an.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung der <xref:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered%2A>-Methode veranschaulicht. Ein Skript mit dem Namen `OnSubmitScript` wird beim <xref:System.Web.UI.Page> registriert, sodass das Skript aufgerufen wird, wenn das Formular der Seite übermittelt wird.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager3#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager3/cs/clientscriptonsubmit.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager3#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager3/vb/clientscriptonsubmit.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der Typ der OnSubmit-Anweisung ist <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered(System.String)" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement(System.Type,System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsStartupScriptRegistered">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Bestimmt, ob das Startskript für das <see cref="T:System.Web.UI.Page" />-Objekt registriert ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsStartupScriptRegistered">
      <MemberSignature Language="C#" Value="public bool IsStartupScriptRegistered (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsStartupScriptRegistered(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsStartupScriptRegistered (key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsStartupScriptRegistered(System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsStartupScriptRegistered : string -&gt; bool" Usage="clientScriptManager.IsStartupScriptRegistered key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Der Schlüssel des zu suchenden Startskripts.</param>
        <summary>Bestimmt unter Verwendung des angegebenen Schlüssels, ob das Startskript für das <see cref="T:System.Web.UI.Page" />-Objekt registriert ist.</summary>
        <returns><see langword="true" />, wenn das Startskript registriert ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie diese Methode auf, bevor Sie die <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A>-Methode aufrufen, damit doppelte Skripts nicht registriert Dies ist besonders wichtig, wenn das Skript eine große Menge an Server Ressourcen benötigt, die erstellt werden müssen.  
  
 Ein Startskript wird durch seinen Schlüssel und dessen Typ eindeutig identifiziert. Skripts mit demselben Schlüssel und Typ werden als Duplikate angesehen.  
  
 Diese Überladung der <xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A>-Methode ruft die-Überladung auf, die sowohl eine Zeichenfolge `key` als auch einen `type`-Parameter mit dem Typ als <xref:System.Web.UI.Page> Objekt annimmt.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered(System.Type,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterStartupScript" />
      </Docs>
    </Member>
    <Member MemberName="IsStartupScriptRegistered">
      <MemberSignature Language="C#" Value="public bool IsStartupScriptRegistered (Type type, string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsStartupScriptRegistered(class System.Type type, string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered(System.Type,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsStartupScriptRegistered (type As Type, key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsStartupScriptRegistered(Type ^ type, System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsStartupScriptRegistered : Type * string -&gt; bool" Usage="clientScriptManager.IsStartupScriptRegistered (type, key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Der Typ des zu suchenden Startskripts.</param>
        <param name="key">Der Schlüssel des zu suchenden Startskripts.</param>
        <summary>Bestimmt unter Verwendung des angegebenen Schlüssels und Typs, ob das Startskript für das <see cref="T:System.Web.UI.Page" />-Objekt registriert ist.</summary>
        <returns><see langword="true" />, wenn das Startskript registriert ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie diese Methode auf, bevor Sie die <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A>-Methode aufrufen, damit doppelte Skripts nicht registriert Dies ist besonders wichtig, wenn das Skript eine große Menge an Server Ressourcen benötigt, die erstellt werden müssen.  
  
 Ein Client Startskript wird durch seinen Schlüssel und dessen Typ eindeutig identifiziert. Skripts mit demselben Schlüssel und Typ werden als Duplikate angesehen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung der <xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A>-Methode veranschaulicht. Beachten Sie Folgendes: Wenn die Logik zum Überprüfen des vorhandenen Startskript Blocks entfernt wurde, sind im HTML-Quellcode der gerenderten Seite nicht zwei doppelte Start Skripts vorhanden, da die <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> Methode auf Duplikate prüft. Der Vorteil der Überprüfung besteht darin, unnötige Berechnungen zu verringern.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der Startskripttyp ist <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered(System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterStartupScript" />
      </Docs>
    </Member>
    <Member MemberName="RegisterArrayDeclaration">
      <MemberSignature Language="C#" Value="public void RegisterArrayDeclaration (string arrayName, string arrayValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterArrayDeclaration(string arrayName, string arrayValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterArrayDeclaration (arrayName As String, arrayValue As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterArrayDeclaration(System::String ^ arrayName, System::String ^ arrayValue);" />
      <MemberSignature Language="F#" Value="member this.RegisterArrayDeclaration : string * string -&gt; unit" Usage="clientScriptManager.RegisterArrayDeclaration (arrayName, arrayValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arrayName" Type="System.String" />
        <Parameter Name="arrayValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="arrayName">Der zu registrierende Arrayname.</param>
        <param name="arrayValue">Der zu registrierende Arraywert bzw. die zu registrierenden Arraywerte.</param>
        <summary>Registriert unter Verwendung eines Arraynamens und eines Arraytyps eine JavaScript-Arraydeklaration für ein <see cref="T:System.Web.UI.Page" />-Objekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A> überprüft, ob ein registriertes Array mit demselben Namen wie der im `arrayName`-Parameter angegebene Name vorhanden ist, und fügt, wenn dies der Fall ist, die im `arrayValue`-Parameter angegebenen Werte hinzu. Da der zugrunde liegende Speichermechanismus auf einem <xref:System.Collections.ArrayList>basiert, sind Duplikate zulässig. Wenn ein registriertes Array mit dem gleichen Namen wie der `arrayName`-Parameter nicht vorhanden ist, wird es erstellt, und die Werte im `arrayValue` Parameter werden hinzugefügt.  
  
 Wenn Sie Zeichen folgen Literale im resultierenden JavaScript-Array wünschen, schließen Sie einfache Anführungszeichen (') oder doppelte Anführungszeichen (\\") in den `arrayValue`-Parameter ein. Der Wert des `arrayValue`-Parameters muss ein einzelnes Element sein. Wenn mehr als ein Wert zum Array hinzugefügt werden muss, führen Sie mehrere Aufrufe mithilfe der <xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A>-Methode aus.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung der Methoden <xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A> und <xref:System.Web.UI.ClientScriptManager.RegisterHiddenField%2A> veranschaulicht. Im Beispiel wird ein Array und ein ausgeblendeter Wert registriert und das `OnClick`-Ereignis einer Schaltfläche `<input>` definiert, um die Summe von zwei Werten des Arrays und des verborgenen Werts zu berechnen.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager5#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager5/cs/clientscriptregisterarray.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager5#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager5/vb/clientscriptregisterarray.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="arrayName" /> ist <see langword="null" /></exception>
        <altmember cref="Overload:System.String.Split" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterClientScriptBlock">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Registriert das Clientskript für das <see cref="T:System.Web.UI.Page" />-Objekt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterClientScriptBlock">
      <MemberSignature Language="C#" Value="public void RegisterClientScriptBlock (Type type, string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClientScriptBlock(class System.Type type, string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock(System.Type,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterClientScriptBlock (type As Type, key As String, script As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterClientScriptBlock(Type ^ type, System::String ^ key, System::String ^ script);" />
      <MemberSignature Language="F#" Value="member this.RegisterClientScriptBlock : Type * string * string -&gt; unit" Usage="clientScriptManager.RegisterClientScriptBlock (type, key, script)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Der Typ des zu registrierenden Clientskripts.</param>
        <param name="key">Der Schlüssel des zu registrierenden Clientskripts.</param>
        <param name="script">Das zu registrierende Clientskriptliteral.</param>
        <summary>Registriert unter Verwendung eines Typs, eines Schlüssels und eines Skriptliterals das Clientskript für das <see cref="T:System.Web.UI.Page" />-Objekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Client Skript wird durch seinen Schlüssel und dessen Typ eindeutig identifiziert. Skripts mit demselben Schlüssel und Typ werden als Duplikate angesehen. Bei der Seite kann nur ein Skript mit einem bestimmten Typ und Schlüsselpaar registriert werden. Wenn Sie versuchen, ein Skript zu registrieren, das bereits registriert ist, wird kein Duplikat des Skripts erstellt.  
  
 Ruft die <xref:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered%2A>-Methode auf, um zu bestimmen, ob ein Client Skript mit einem angegebenen Schlüssel-und typpaar bereits registriert ist, und vermeidet unnötige Versuche, das Skript hinzuzufügen.  
  
 In dieser Überladung der <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A>-Methode müssen Sie sicherstellen, dass das Skript, das im `script`-Parameter bereitgestellt wird, in einen `<script>`-Element Block umschließt.  
  
 Die <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A>-Methode fügt am oberen Rand der gerenderten Seite einen Skriptblock hinzu. Es ist nicht garantiert, dass die Skriptblöcke in der Reihenfolge ausgegeben werden, in der Sie registriert sind. Wenn die Reihenfolge der Skriptblöcke wichtig ist, verwenden Sie ein <xref:System.Text.StringBuilder> Objekt, um die Skripts in einer einzelnen Zeichenfolge zusammenzufassen, und registrieren Sie Sie dann alle in einem einzelnen Client Skriptblock.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung der <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A>-Methode veranschaulicht.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager12#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.ui.clientscriptmanager12/cs/default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager12#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.ui.clientscriptmanager12/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock(System.Type,System.String,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScriptBlock">
      <MemberSignature Language="C#" Value="public void RegisterClientScriptBlock (Type type, string key, string script, bool addScriptTags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClientScriptBlock(class System.Type type, string key, string script, bool addScriptTags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock(System.Type,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterClientScriptBlock (type As Type, key As String, script As String, addScriptTags As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterClientScriptBlock(Type ^ type, System::String ^ key, System::String ^ script, bool addScriptTags);" />
      <MemberSignature Language="F#" Value="member this.RegisterClientScriptBlock : Type * string * string * bool -&gt; unit" Usage="clientScriptManager.RegisterClientScriptBlock (type, key, script, addScriptTags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
        <Parameter Name="addScriptTags" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">Der Typ des zu registrierenden Clientskripts.</param>
        <param name="key">Der Schlüssel des zu registrierenden Clientskripts.</param>
        <param name="script">Das zu registrierende Clientskriptliteral.</param>
        <param name="addScriptTags">Ein boolescher Wert, der angibt, ob Skripttags hinzugefügt werden sollen.</param>
        <summary>Registriert unter Verwendung eines Typs, eines Schlüssels, eines Skriptliterals sowie eines booleschen Werts, der angibt, ob Skripttags hinzugefügt werden sollen, das Clientskript für das <see cref="T:System.Web.UI.Page" />-Objekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Client Skript wird durch seinen Schlüssel und dessen Typ eindeutig identifiziert. Skripts mit demselben Schlüssel und Typ werden als Duplikate angesehen. Bei der Seite kann nur ein Skript mit einem bestimmten Typ und Schlüsselpaar registriert werden. Wenn Sie versuchen, ein Skript zu registrieren, das bereits registriert ist, wird kein Duplikat des Skripts erstellt.  
  
 Ruft die <xref:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered%2A>-Methode auf, um zu bestimmen, ob ein Client Skript mit einem angegebenen Schlüssel-und typpaar bereits registriert ist. Auf diese Weise können Sie unnötigerweise versuchen, das Skript hinzuzufügen.  
  
 In dieser Überladung der <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A>-Methode können Sie angeben, ob das Skript, das im `script`-Parameter bereitgestellt wird, mithilfe des `addScriptTags`-Parameters mit einem `<script>`-Element Block umschließt. Wenn Sie `addScriptTags` auf `true` festlegen, wird angegeben, dass Skript Tags automatisch hinzugefügt werden.  
  
 Die <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A>-Methode fügt am oberen Rand der gerenderten Seite einen Skriptblock hinzu. Es ist nicht garantiert, dass die Skriptblöcke in der Reihenfolge ausgegeben werden, in der Sie registriert sind. Wenn die Reihenfolge der Skriptblöcke wichtig ist, verwenden Sie ein <xref:System.Text.StringBuilder> Objekt, um die Skripts in einer einzelnen Zeichenfolge zusammenzufassen, und registrieren Sie Sie dann alle in einem einzelnen Client Skriptblock.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung der <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A>-Methode veranschaulicht. Beachten Sie, dass der `addScriptTags`-Parameter auf festgelegt ist `true` sodass die Tags für das Start-und schließende Skript nicht im `script`-Parameter enthalten sind.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der Typ des Clientskriptblocks ist <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock(System.Type,System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterClientScriptInclude">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Registriert den Clientskriptinclude für das <see cref="T:System.Web.UI.Page" />-Objekt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterClientScriptInclude">
      <MemberSignature Language="C#" Value="public void RegisterClientScriptInclude (string key, string url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClientScriptInclude(string key, string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterClientScriptInclude (key As String, url As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterClientScriptInclude(System::String ^ key, System::String ^ url);" />
      <MemberSignature Language="F#" Value="member this.RegisterClientScriptInclude : string * string -&gt; unit" Usage="clientScriptManager.RegisterClientScriptInclude (key, url)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Der Schlüssel des zu registrierenden Clientskriptincludes.</param>
        <param name="url">Die URL des zu registrierenden Clientskriptincludes.</param>
        <summary>Registriert das Clientskript beim <see cref="T:System.Web.UI.Page" />-Objekt mit einem Schlüssel und einer URL, wodurch das Skript vom Client aufgerufen werden kann.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Clientskriptinclude wird durch seinen Schlüssel und dessen Typ eindeutig identifiziert. Skripts mit demselben Schlüssel und Typ werden als Duplikate angesehen. Bei der Seite kann nur ein Skript mit einem bestimmten Typ und Schlüsselpaar registriert werden. Wenn Sie versuchen, ein Skript zu registrieren, das bereits registriert ist, wird kein Duplikat des Skripts erstellt.  
  
 Ruft die <xref:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered%2A>-Methode auf, um zu bestimmen, ob ein Client Skript mit einem bestimmten Schlüssel und typpaar bereits registriert ist, und vermeidet unnötige Versuche, das Skript hinzuzufügen.  
  
> [!NOTE]
>  Verwenden Sie die <xref:System.Web.UI.Control.ResolveClientUrl%2A>-Methode, um die Client-URL aufzulösen. Diese Methode verwendet den Kontext der URL, für die Sie aufgerufen wird, um den Pfad aufzulösen.  
  
 Diese Überladung der <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A>-Methode ruft die-Überladung auf, die eine `key`, eine `URL`und einen `type` Parameter annimmt.  
  
 Die-Methode fügt am oberen Rand der gerenderten Seite einen Skriptblock hinzu.  
  
   
  
## Examples  
 Weitere Informationen, einschließlich Syntax, Verwendung und einem Beispiel, finden Sie unter <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude(System.Type,System.String,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered" />
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScriptInclude">
      <MemberSignature Language="C#" Value="public void RegisterClientScriptInclude (Type type, string key, string url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClientScriptInclude(class System.Type type, string key, string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude(System.Type,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterClientScriptInclude (type As Type, key As String, url As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterClientScriptInclude(Type ^ type, System::String ^ key, System::String ^ url);" />
      <MemberSignature Language="F#" Value="member this.RegisterClientScriptInclude : Type * string * string -&gt; unit" Usage="clientScriptManager.RegisterClientScriptInclude (type, key, url)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Der Typ des zu registrierenden Clientskriptincludes.</param>
        <param name="key">Der Schlüssel des zu registrierenden Clientskriptincludes.</param>
        <param name="url">Die URL des zu registrierenden Clientskriptincludes.</param>
        <summary>Registriert unter Verwendung eines Typs, eines Schlüssels sowie einer URL den Clientskriptinclude für das <see cref="T:System.Web.UI.Page" />-Objekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung der <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A>-Methode übernimmt *Key* -und *URL* -Parameter, um das Skript zu identifizieren, sowie einen `type` Parameter, um die Identifizierung des Client Skripts anzugeben. Sie geben den Typ basierend auf dem Objekt an, das auf die Ressource zugreift. Wenn Sie beispielsweise für den Zugriff auf die Ressource eine `Page` Instanz verwenden, geben Sie den `Page` Typ an.  
  
> [!NOTE]
>  Verwenden Sie die <xref:System.Web.UI.Control.ResolveClientUrl%2A>-Methode, um die Client-URL aufzulösen. Diese Methode verwendet den Kontext der URL, für die Sie aufgerufen wird, um den Pfad aufzulösen.  
  
 Diese Methode fügt am oberen Rand der gerenderten Seite einen Skriptblock hinzu.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung der <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A>-Methode veranschaulicht. Beachten Sie Folgendes: Wenn die Logik zum Überprüfen der vorhandenen Client Skripts entfernt wurde, sind auf der gerenderten Seite immer noch keine doppelten Client Skripts vorhanden, da die <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A>-Methode auf Duplikate prüft. Der Vorteil der Überprüfung besteht darin, unnötige Berechnungen zu verringern.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager2#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager2/cs/clientscriptincludes.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager2#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager2/vb/clientscriptincludes.aspx#1)]  
  
 Für dieses Beispiel ist eine JavaScript-Datei mit dem Namen "Script_include. js" mit folgendem Inhalt erforderlich:  
  
```  
function DoClick() {Form1.Message.value='Text from include script.'}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der Typ des Clientskriptincludes ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die URL ist <see langword="null" />.  
  
Oder 
Der URL ist leer.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude(System.String,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered" />
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScriptResource">
      <MemberSignature Language="C#" Value="public void RegisterClientScriptResource (Type type, string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClientScriptResource(class System.Type type, string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterClientScriptResource(System.Type,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterClientScriptResource (type As Type, resourceName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterClientScriptResource(Type ^ type, System::String ^ resourceName);" />
      <MemberSignature Language="F#" Value="member this.RegisterClientScriptResource : Type * string -&gt; unit" Usage="clientScriptManager.RegisterClientScriptResource (type, resourceName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="resourceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Der Typ der zu registrierenden Clientskriptressource.</param>
        <param name="resourceName">Der Name der zu registrierenden Clientskriptressource.</param>
        <summary>Registriert die Clientskriptressource unter Verwendung eines Typ und eines Ressourcennamens für das <see cref="T:System.Web.UI.Page" />-Objekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptResource%2A>-Methode wird beim Zugriff auf kompilierte Ressourcen aus Assemblys über den WebResource. axd-HTTP-Handler verwendet. Die <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptResource%2A>-Methode registriert das Skript beim <xref:System.Web.UI.Page>-Objekt und verhindert doppelte Skripts. Diese Methode umschließt den Inhalt der Ressourcen-URL mit einem `<script>`-Element-Block.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung der <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptResource%2A>-Methode veranschaulicht.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager4#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/cs/clientscriptwebresource.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager4#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/vb/clientscriptwebresource.aspx#1)]  
  
 Im folgenden Codebeispiel wird veranschaulicht, wie das <xref:System.Web.UI.WebResourceAttribute> Metadata-Attribut Programm gesteuert angewendet wird, um die Assembly für die zu verwendenden Ressourcen zu markieren.  
  
 [!code-csharp[System.Web.UI.ClientScriptManager4#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/cs/resource.cs#2)]
 [!code-vb[System.Web.UI.ClientScriptManager4#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/vb/resource.vb#2)]  
  
 Dieses Beispiel erfordert eine JavaScript-Datei mit dem Namen `Script_include.js`mit folgendem Inhalt:  
  
```  
function DoClick() {Form1.Message.value='Text from resource script.'}  
```  
  
 Kompilieren Sie die `Script_include.js` Datei als Ressource in der `Samples.AspNet.CS.Controls` Assembly, die die `ClientScriptResourceLabel`-Klasse enthält.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der Clientressourcentyp ist <see langword="null" />.

Oder

Der Clientressourcenname ist <see langword="null" />.  
  
Oder 
Der Clientressourcenname hat eine Länge von 0 (null).</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.GetWebResourceUrl(System.Type,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude" />
        <altmember cref="T:System.Web.Handlers.AssemblyResourceLoader" />
        <altmember cref="T:System.Web.UI.WebResourceAttribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterExpandoAttribute">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Registriert ein Name-Wert-Paar als benutzerdefiniertes Attribut (Expando-Attribut) des angegebenen Steuerelements.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterExpandoAttribute">
      <MemberSignature Language="C#" Value="public void RegisterExpandoAttribute (string controlId, string attributeName, string attributeValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterExpandoAttribute(string controlId, string attributeName, string attributeValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterExpandoAttribute (controlId As String, attributeName As String, attributeValue As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterExpandoAttribute(System::String ^ controlId, System::String ^ attributeName, System::String ^ attributeValue);" />
      <MemberSignature Language="F#" Value="member this.RegisterExpandoAttribute : string * string * string -&gt; unit" Usage="clientScriptManager.RegisterExpandoAttribute (controlId, attributeName, attributeValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="controlId" Type="System.String" />
        <Parameter Name="attributeName" Type="System.String" />
        <Parameter Name="attributeValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="controlId">Das <see cref="T:System.Web.UI.Control" /> auf der Seite, die das benutzerdefinierte Attribut enthält.</param>
        <param name="attributeName">Der Name des zu registrierenden benutzerdefinierten Attributs.</param>
        <param name="attributeValue">Der Wert des benutzerdefinierten Attributs.</param>
        <summary>Registriert ein Name-Wert-Paar mithilfe einer bestimmten Steuerelement-ID, eines Attributnamens und eines Attributwerts als benutzerdefiniertes Attribut (Expando-Attribut) des angegebenen Steuerelements.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute%2A>-Methode registriert ein Name-Wert-Paar als benutzerdefiniertes Attribut (Expando) für die angegebene <xref:System.Web.UI.Control>. Das Expando-Attribut wird dynamisch von JavaScript festgelegt, um die XHTML-Kompatibilität für das Markup des gerenderten Steuer Elements beizubehalten. Anführungszeichen und umgekehrte Schrägstriche in den Werten des benutzerdefinierten Attributs (Expando) werden mit Escapezeichen versehen. Wenn Sie keine Anführungszeichen und umgekehrten Schrägstriche mit Escapezeichen versehen möchten, können Sie die <xref:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute%2A> Überladungs Methode aufrufen und den `encode`-Parameter auf `false`festlegen.  
  
 Wenn das Expando-Attribut nicht gefunden wird oder das Steuerelement, dem das Expando-Attribut hinzugefügt werden soll, nicht gefunden wird, wird das Client Skript weiterhin ausgegeben, wirkt sich jedoch nicht auf das-Steuerelement aus.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:Microsoft.JScript.Expando" />
      </Docs>
    </Member>
    <Member MemberName="RegisterExpandoAttribute">
      <MemberSignature Language="C#" Value="public void RegisterExpandoAttribute (string controlId, string attributeName, string attributeValue, bool encode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterExpandoAttribute(string controlId, string attributeName, string attributeValue, bool encode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute(System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterExpandoAttribute (controlId As String, attributeName As String, attributeValue As String, encode As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterExpandoAttribute(System::String ^ controlId, System::String ^ attributeName, System::String ^ attributeValue, bool encode);" />
      <MemberSignature Language="F#" Value="member this.RegisterExpandoAttribute : string * string * string * bool -&gt; unit" Usage="clientScriptManager.RegisterExpandoAttribute (controlId, attributeName, attributeValue, encode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="controlId" Type="System.String" />
        <Parameter Name="attributeName" Type="System.String" />
        <Parameter Name="attributeValue" Type="System.String" />
        <Parameter Name="encode" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="controlId">Das <see cref="T:System.Web.UI.Control" /> auf der Seite, die das benutzerdefinierte Attribut enthält.</param>
        <param name="attributeName">Der Name des zu registrierenden benutzerdefinierten Attributs.</param>
        <param name="attributeValue">Der Wert des benutzerdefinierten Attributs.</param>
        <param name="encode">Ein boolescher Wert, der angibt, ob das zu registrierende benutzerdefinierte Attribut codiert werden soll.</param>
        <summary>Registriert ein Name-Wert-Paar mithilfe einer bestimmten Steuerelement-ID, eines Attributnamens und eines Attributwerts sowie eines booleschen Werts (der angibt, ob der Attributwert codiert werden soll) als benutzerdefiniertes Attribut (Expando-Attribut) des angegebenen Steuerelements.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute%2A>-Methode registriert ein Name-Wert-Paar als benutzerdefiniertes Attribut (Expando) für die angegebene <xref:System.Web.UI.Control>. Das Expando-Attribut wird dynamisch von JavaScript festgelegt, um die XHTML-Kompatibilität für das Markup des gerenderten Steuer Elements beizubehalten. Legen Sie den `encode`-Parameter auf `true` fest, wenn Sie Anführungszeichen und umgekehrte Schrägstriche im Wert Ihres expando-Attributs mit Escapezeichen versehen müssen.  
  
 Wenn das Expando-Attribut nicht gefunden wird oder das Steuerelement, dem das Expando-Attribut hinzugefügt werden soll, nicht gefunden wird, wird das Client Skript weiterhin ausgegeben, wirkt sich jedoch nicht auf das-Steuerelement aus.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute%2A>-Methode der <xref:System.Web.UI.ClientScriptManager>-Klasse verwendet wird. Das Client Skript auf der gerenderten Seite legt das `title`-Attribut eines `<span>`-Elements fest.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager6#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager6/cs/clientscriptexpando.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager6#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager6/vb/clientscriptexpando.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:Microsoft.JScript.Expando" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterForEventValidation">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Registriert einen Ereignisverweis für die Validierung.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterForEventValidation">
      <MemberSignature Language="C#" Value="public void RegisterForEventValidation (string uniqueId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterForEventValidation(string uniqueId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterForEventValidation (uniqueId As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterForEventValidation(System::String ^ uniqueId);" />
      <MemberSignature Language="F#" Value="member this.RegisterForEventValidation : string -&gt; unit" Usage="clientScriptManager.RegisterForEventValidation uniqueId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uniqueId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uniqueId">Eine eindeutige ID, die das Clientsteuerelement darstellt, das das Ereignis generiert.</param>
        <summary>Registriert einen Ereignisverweis für die Validierung bei einer eindeutigen Steuerelement-ID, die das Clientsteuerelement darstellt, das das Ereignis generiert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen und Beispiele finden Sie in der <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A>-Methode.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie die <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A>-Methode und die <xref:System.Web.UI.ClientScriptManager.ValidateEvent%2A>-Methode verwendet werden, um einen Rückruf für die Validierung zu registrieren und zu überprüfen, ob der Rückruf von der Seite stammt.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager9#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/cs/eventvalidation2cs.aspx#2)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager9#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/vb/eventvalidation2vb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.ValidateEvent(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterForEventValidation">
      <MemberSignature Language="C#" Value="public void RegisterForEventValidation (System.Web.UI.PostBackOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterForEventValidation(class System.Web.UI.PostBackOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.Web.UI.PostBackOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterForEventValidation (options As PostBackOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterForEventValidation(System::Web::UI::PostBackOptions ^ options);" />
      <MemberSignature Language="F#" Value="member this.RegisterForEventValidation : System.Web.UI.PostBackOptions -&gt; unit" Usage="clientScriptManager.RegisterForEventValidation options" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.Web.UI.PostBackOptions" />
      </Parameters>
      <Docs>
        <param name="options">Ein <see cref="T:System.Web.UI.PostBackOptions" />-Objekt, das angibt, wie clientseitiges JavaScript zum Initiieren eines Postbackereignisses generiert wird.</param>
        <summary>Registriert einen Ereignisverweis für die Validierung bei <see cref="T:System.Web.UI.PostBackOptions" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen und Beispiele finden Sie in der <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A>-Methode.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.ValidateEvent" />
      </Docs>
    </Member>
    <Member MemberName="RegisterForEventValidation">
      <MemberSignature Language="C#" Value="public void RegisterForEventValidation (string uniqueId, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterForEventValidation(string uniqueId, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterForEventValidation (uniqueId As String, argument As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterForEventValidation(System::String ^ uniqueId, System::String ^ argument);" />
      <MemberSignature Language="F#" Value="member this.RegisterForEventValidation : string * string -&gt; unit" Usage="clientScriptManager.RegisterForEventValidation (uniqueId, argument)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uniqueId" Type="System.String" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uniqueId">Eine eindeutige ID, die das Clientsteuerelement darstellt, das das Ereignis generiert.</param>
        <param name="argument">An das Clientereignis übergebene Ereignisargumente.</param>
        <summary>Registriert einen Ereignisverweis für die Validierung bei einer eindeutigen Steuerelement-ID und Ereignisargumenten, die das Clientsteuerelement darstellen, das das Ereignis generiert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung der <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A>-Methode und der <xref:System.Web.UI.ClientScriptManager.ValidateEvent%2A>-Methode, um einen Rückruf für die Validierung zu registrieren und zu überprüfen, ob der Rückruf von der Seite stammt. Um die im Beispiel gezeigte Validierung zu verbessern, können Sie den Überprüfungs `argument` Parameter so ändern, dass er spezifische Informationen für den Benutzer enthält, z. b. eine Identität oder eine Rolle.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager9#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/cs/EventValidationCS.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager9#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/vb/EventValidationVB.aspx#1)]  
  
 Im folgenden Codebeispiel wird die Verwendung der <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A>-Methode zum Registrieren eines Rückrufs für die Validierung veranschaulicht.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager10#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.ui.clientscriptmanager10/cs/default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager10#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.ui.clientscriptmanager10/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Methode wird vor der <see cref="M:System.Web.UI.Page.Render(System.Web.UI.HtmlTextWriter)" />-Methode aufgerufen.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.ValidateEvent(System.String,System.String)" />
        <related type="Article" href="https://msdn.microsoft.com/library/18fc94c9-56fc-46c3-9f29-7358f18667df">Beispiel für Client Rückruf mit Überprüfungs Implementierung</related>
      </Docs>
    </Member>
    <Member MemberName="RegisterHiddenField">
      <MemberSignature Language="C#" Value="public void RegisterHiddenField (string hiddenFieldName, string hiddenFieldInitialValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterHiddenField(string hiddenFieldName, string hiddenFieldInitialValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterHiddenField(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterHiddenField (hiddenFieldName As String, hiddenFieldInitialValue As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterHiddenField(System::String ^ hiddenFieldName, System::String ^ hiddenFieldInitialValue);" />
      <MemberSignature Language="F#" Value="member this.RegisterHiddenField : string * string -&gt; unit" Usage="clientScriptManager.RegisterHiddenField (hiddenFieldName, hiddenFieldInitialValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hiddenFieldName" Type="System.String" />
        <Parameter Name="hiddenFieldInitialValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="hiddenFieldName">Der Name des zu registrierenden ausgeblendeten Felds.</param>
        <param name="hiddenFieldInitialValue">Der Anfangswert des zu registrierenden Felds.</param>
        <summary>Registriert einen ausgeblendeten Wert für das <see cref="T:System.Web.UI.Page" />-Objekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.ClientScriptManager.RegisterHiddenField%2A>-Methode erstellt ein verborgenes `<input>` Element auf der gerenderten HTML-Seite.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung der Methoden <xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A> und <xref:System.Web.UI.ClientScriptManager.RegisterHiddenField%2A> veranschaulicht. Im Beispiel wird ein Array und ein ausgeblendeter Wert registriert und das `OnClick`-Ereignis einer Schaltfläche `<input>` definiert, um die Summe von zwei Werten des Arrays und des verborgenen Werts zu berechnen.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager5#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager5/cs/clientscriptregisterarray.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager5#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager5/vb/clientscriptregisterarray.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="hiddenFieldName" /> ist <see langword="null" /></exception>
        <altmember cref="T:System.Web.UI.WebControls.HiddenField" />
      </Docs>
    </Member>
    <Member MemberName="RegisterOnSubmitStatement">
      <MemberSignature Language="C#" Value="public void RegisterOnSubmitStatement (Type type, string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterOnSubmitStatement(class System.Type type, string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement(System.Type,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterOnSubmitStatement (type As Type, key As String, script As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterOnSubmitStatement(Type ^ type, System::String ^ key, System::String ^ script);" />
      <MemberSignature Language="F#" Value="member this.RegisterOnSubmitStatement : Type * string * string -&gt; unit" Usage="clientScriptManager.RegisterOnSubmitStatement (type, key, script)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Der Typ der zu registrierenden OnSubmit-Anweisung.</param>
        <param name="key">Der Schlüssel der zu registrierenden OnSubmit-Anweisung.</param>
        <param name="script">Das Skriptliteral der zu registrierenden OnSubmit-Anweisung.</param>
        <summary>Registriert unter Verwendung eines Typs, eines Schlüssels sowie eines Skriptliterals eine OnSubmit-Anweisung für das <see cref="T:System.Web.UI.Page" />-Objekt. Die Anweisung wird beim Übermitteln des <see cref="T:System.Web.UI.HtmlControls.HtmlForm" /> ausgeführt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine OnSubmit-Anweisung wird eindeutig durch Ihren Schlüssel und deren Typ identifiziert. Anweisungen mit dem gleichen Schlüssel und Typ werden als Duplikate angesehen. Bei der Seite kann nur eine Anweisung mit einem bestimmten Typ und Schlüsselpaar registriert werden. Wenn Sie versuchen, eine Anweisung zu registrieren, die bereits registriert ist, wird kein Duplikat der-Anweisung erstellt.  
  
 Ruft die <xref:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered%2A>-Methode auf, um zu bestimmen, ob eine OnSubmit-Anweisung bereits mit einem bestimmten Schlüssel und typpaar registriert ist, und vermeidet unnötige Versuche, das Skript hinzuzufügen.  
  
 Der `script`-Parameter der <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A>-Methode kann mehrere Skript Befehle enthalten, solange Sie durch ein Semikolon (;) ordnungsgemäß getrennt sind.  
  
 Der <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A> fügt ein Skript hinzu, das vor dem übermitteln der Seite ausgeführt wird, und bietet Ihnen die Möglichkeit, die Übermittlung abzubrechen.  
  
 Weitere Informationen zu HTML-Formularen und zum `OnSubmit`-Attribut finden Sie auf der [Website World Wide Web Consortium (W3C)](https://go.microsoft.com/fwlink/?linkid=37125).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung der <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A>-Methode veranschaulicht.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager3#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager3/cs/clientscriptonsubmit.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager3#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager3/vb/clientscriptonsubmit.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> ist <see langword="null" /></exception>
        <altmember cref="T:System.Web.UI.HtmlControls.HtmlForm" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterStartupScript">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Registriert das Startskript für das <see cref="T:System.Web.UI.Page" />-Objekt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterStartupScript">
      <MemberSignature Language="C#" Value="public void RegisterStartupScript (Type type, string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterStartupScript(class System.Type type, string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterStartupScript(System.Type,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterStartupScript (type As Type, key As String, script As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterStartupScript(Type ^ type, System::String ^ key, System::String ^ script);" />
      <MemberSignature Language="F#" Value="member this.RegisterStartupScript : Type * string * string -&gt; unit" Usage="clientScriptManager.RegisterStartupScript (type, key, script)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Der Typ des zu registrierenden Startskripts.</param>
        <param name="key">Der Schlüssel des zu registrierenden Startskripts.</param>
        <param name="script">Das zu registrierende Startskriptliteral.</param>
        <summary>Registriert unter Verwendung eines Typs, eines Schlüssels und eines Skriptliterals das Startskript für das <see cref="T:System.Web.UI.Page" />-Objekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Client Skript wird durch seinen Schlüssel und dessen Typ eindeutig identifiziert. Skripts mit demselben Schlüssel und Typ werden als Duplikate angesehen. Bei der Seite kann nur ein Skript mit einem bestimmten Typ und Schlüsselpaar registriert werden. Wenn Sie versuchen, ein Skript zu registrieren, das bereits registriert ist, wird kein Duplikat des Skripts erstellt.  
  
 Ruft die <xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A>-Methode auf, um zu bestimmen, ob ein Startskript mit einem angegebenen Schlüssel-und typpaar bereits registriert ist, und vermeidet unnötige Versuche, das Skript hinzuzufügen.  
  
 In dieser Überladung der <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A>-Methode müssen Sie sicherstellen, dass das Skript, das im `script`-Parameter bereitgestellt wird, mit einem `<script>`-Element Block umschließt.  
  
 Der durch die <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A>-Methode hinzugefügte Skriptblock wird ausgeführt, wenn das Laden der Seite abgeschlossen ist, aber bevor das <xref:System.Web.UI.Control.OnLoad%2A> Ereignis der Seite ausgelöst wird. Es ist nicht garantiert, dass die Skriptblöcke in der Reihenfolge ausgegeben werden, in der Sie registriert sind. Wenn die Reihenfolge der Skriptblöcke wichtig ist, verwenden Sie ein <xref:System.Text.StringBuilder> Objekt, um die Skripts in einer einzelnen Zeichenfolge zusammenzufassen, und registrieren Sie Sie dann alle in einem einzelnen Client Skriptblock.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung der <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A>-Methode veranschaulicht. Beachten Sie, dass die Tags für das Start-und schließende Skript im `script`-Parameter enthalten sind. Informationen dazu, wie Sie die Skript Tags auf der Grundlage einer zusätzlichen Parametereinstellung hinzufügen, finden Sie unter <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A>-Methode.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager11#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.ui.clientscriptmanager11/cs/default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager11#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.ui.clientscriptmanager11/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterStartupScript(System.Type,System.String,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterStartupScript">
      <MemberSignature Language="C#" Value="public void RegisterStartupScript (Type type, string key, string script, bool addScriptTags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterStartupScript(class System.Type type, string key, string script, bool addScriptTags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterStartupScript(System.Type,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterStartupScript (type As Type, key As String, script As String, addScriptTags As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterStartupScript(Type ^ type, System::String ^ key, System::String ^ script, bool addScriptTags);" />
      <MemberSignature Language="F#" Value="member this.RegisterStartupScript : Type * string * string * bool -&gt; unit" Usage="clientScriptManager.RegisterStartupScript (type, key, script, addScriptTags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
        <Parameter Name="addScriptTags" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">Der Typ des zu registrierenden Startskripts.</param>
        <param name="key">Der Schlüssel des zu registrierenden Startskripts.</param>
        <param name="script">Das zu registrierende Startskriptliteral.</param>
        <param name="addScriptTags">Ein boolescher Wert, der angibt, ob Skripttags hinzugefügt werden sollen.</param>
        <summary>Registriert unter Verwendung eines Typs, eines Schlüssels, eines Skriptliterals sowie eines booleschen Werts, der angibt, ob Skripttags hinzugefügt werden sollen, das Startskript für das <see cref="T:System.Web.UI.Page" />-Objekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Startskript wird durch seinen Schlüssel und dessen Typ eindeutig identifiziert. Skripts mit demselben Schlüssel und Typ werden als Duplikate angesehen. Bei der Seite kann nur ein Skript mit einem bestimmten Typ und Schlüsselpaar registriert werden. Wenn Sie versuchen, ein Skript zu registrieren, das bereits registriert ist, wird kein Duplikat des Skripts erstellt.  
  
 Ruft die <xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A>-Methode auf, um zu bestimmen, ob ein Startskript mit einem angegebenen Schlüssel-und typpaar bereits registriert ist, und vermeidet unnötige Versuche, das Skript hinzuzufügen.  
  
 In dieser Überladung der <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A>-Methode können Sie angeben, ob das Skript, das im `script`-Parameter bereitgestellt wird, mithilfe des `addScriptTags`-Parameters mit einem `<script>`-Element Block umschließt. Wenn Sie `addScriptTags` auf `true` festlegen, wird angegeben, dass Skript Tags automatisch hinzugefügt werden.  
  
 Der durch die <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A>-Methode hinzugefügte Skriptblock wird ausgeführt, wenn das Laden der Seite abgeschlossen ist, aber bevor das <xref:System.Web.UI.Control.OnLoad%2A> Ereignis der Seite ausgelöst wird. Es ist nicht garantiert, dass die Skriptblöcke in der Reihenfolge ausgegeben werden, in der Sie registriert sind. Wenn die Reihenfolge der Skriptblöcke wichtig ist, verwenden Sie ein <xref:System.Text.StringBuilder> Objekt, um die Skripts in einer einzelnen Zeichenfolge zusammenzufassen, und registrieren Sie Sie dann alle in einem einzelnen Client Skriptblock.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung der <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A>-Methode veranschaulicht. Beachten Sie, dass der `addScriptTags`-Parameter auf `false` festgelegt ist, damit die Start-und schließenden Skript Tags im `script`-Parameter enthalten sind.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> ist <see langword="null" /></exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterStartupScript(System.Type,System.String,System.String)" />
        <altmember cref="F:System.Web.UI.HtmlTextWriterTag.Script" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ValidateEvent">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Validiert ein Clientereignis.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ValidateEvent">
      <MemberSignature Language="C#" Value="public void ValidateEvent (string uniqueId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ValidateEvent(string uniqueId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.ValidateEvent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ValidateEvent (uniqueId As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ValidateEvent(System::String ^ uniqueId);" />
      <MemberSignature Language="F#" Value="member this.ValidateEvent : string -&gt; unit" Usage="clientScriptManager.ValidateEvent uniqueId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uniqueId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uniqueId">Eine eindeutige ID, die das Clientsteuerelement darstellt, das das Ereignis generiert.</param>
        <summary>Validiert ein Clientereignis, das mit der <see cref="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String)" />-Methode für die Ereignisvalidierung registriert wurde.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ValidateEvent">
      <MemberSignature Language="C#" Value="public void ValidateEvent (string uniqueId, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ValidateEvent(string uniqueId, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.ValidateEvent(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ValidateEvent (uniqueId As String, argument As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ValidateEvent(System::String ^ uniqueId, System::String ^ argument);" />
      <MemberSignature Language="F#" Value="member this.ValidateEvent : string * string -&gt; unit" Usage="clientScriptManager.ValidateEvent (uniqueId, argument)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uniqueId" Type="System.String" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uniqueId">Eine eindeutige ID, die das Clientsteuerelement darstellt, das das Ereignis generiert.</param>
        <param name="argument">An das Clientereignis übergebene Ereignisargumente.</param>
        <summary>Validiert ein Clientereignis, das mit der <see cref="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String,System.String)" />-Methode für die Ereignisvalidierung registriert wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung der <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A>-Methode und der <xref:System.Web.UI.ClientScriptManager.ValidateEvent%2A>-Methode, um einen Rückruf für die Validierung zu registrieren und zu überprüfen, ob der Rückruf von der Seite stammt. Um die hier gezeigte Validierung zu verbessern, können Sie den Validierungs `argument` Parameter so ändern, dass er spezifische Informationen für den Benutzer enthält, z. b. eine Identität oder eine Rolle.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager9#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/cs/EventValidationCS.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager9#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/vb/EventValidationVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="uniqueId" /> ist <see langword="null" /> oder eine leere Zeichenfolge ("").</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String,System.String)" />
      </Docs>
    </Member>
  </Members>
</Type>
