<Type Name="ImmutableSortedDictionary&lt;TKey,TValue&gt;" FullName="System.Collections.Immutable.ImmutableSortedDictionary&lt;TKey,TValue&gt;">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="70b383d84b095aea98743239e8943dc145830ef7" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52225076" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class ImmutableSortedDictionary&lt;TKey,TValue&gt; : System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;, System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;, System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;, System.Collections.Generic.IReadOnlyCollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;, System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;, System.Collections.IDictionary, System.Collections.Immutable.IImmutableDictionary&lt;TKey,TValue&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ImmutableSortedDictionary`2&lt;TKey, TValue&gt; extends System.Object implements class System.Collections.Generic.ICollection`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt;, class System.Collections.Generic.IDictionary`2&lt;!TKey, !TValue&gt;, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt;, class System.Collections.Generic.IReadOnlyCollection`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt;, class System.Collections.Generic.IReadOnlyDictionary`2&lt;!TKey, !TValue&gt;, class System.Collections.ICollection, class System.Collections.IDictionary, class System.Collections.IEnumerable, class System.Collections.Immutable.IImmutableDictionary`2&lt;!TKey, !TValue&gt;" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Immutable.ImmutableSortedDictionary`2" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ImmutableSortedDictionary(Of TKey, TValue)&#xA;Implements ICollection(Of KeyValuePair(Of TKey, TValue)), IDictionary, IDictionary(Of TKey, TValue), IEnumerable(Of KeyValuePair(Of TKey, TValue)), IImmutableDictionary(Of TKey, TValue), IReadOnlyCollection(Of KeyValuePair(Of TKey, TValue)), IReadOnlyDictionary(Of TKey, TValue)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename TKey, typename TValue&gt;&#xA;public ref class ImmutableSortedDictionary sealed : System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;, System::Collections::Generic::IDictionary&lt;TKey, TValue&gt;, System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;, System::Collections::Generic::IReadOnlyCollection&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;, System::Collections::Generic::IReadOnlyDictionary&lt;TKey, TValue&gt;, System::Collections::IDictionary, System::Collections::Immutable::IImmutableDictionary&lt;TKey, TValue&gt;" />
  <TypeSignature Language="F#" Value="type ImmutableSortedDictionary&lt;'Key, 'Value&gt; = class&#xA;    interface ICollection&lt;KeyValuePair&lt;'Key, 'Value&gt;&gt;&#xA;    interface seq&lt;KeyValuePair&lt;'Key, 'Value&gt;&gt;&#xA;    interface IEnumerable&#xA;    interface IDictionary&lt;'Key, 'Value&gt;&#xA;    interface IReadOnlyCollection&lt;KeyValuePair&lt;'Key, 'Value&gt;&gt;&#xA;    interface IReadOnlyDictionary&lt;'Key, 'Value&gt;&#xA;    interface ICollection&#xA;    interface IDictionary&#xA;    interface IImmutableDictionary&lt;'Key, 'Value&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Collections.Immutable</AssemblyName>
    <AssemblyVersion>1.2.0.0</AssemblyVersion>
    <AssemblyVersion>1.2.1.0</AssemblyVersion>
    <AssemblyVersion>1.2.2.0</AssemblyVersion>
    <AssemblyVersion>1.2.3.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="TKey" />
    <TypeParameter Name="TValue" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyCollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IDictionary</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Immutable.IImmutableDictionary&lt;TKey,TValue&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Immutable.ImmutableSortedDictionaryDebuggerProxy`2))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="TKey">Der Typ des im Wörterbuch enthaltenen Schlüssels.</typeparam>
    <typeparam name="TValue">Der Typ des im Wörterbuch enthaltenen Werts.</typeparam>
    <summary>Stellt ein unveränderlich sortiertes Wörterbuch dar.  
  
 **NuGet-Paket**: <see href="https://www.nuget.org/packages/System.Collections.Immutable/">System.Collections.Immutable</see> (<see href="https://docs.microsoft.com/dotnet/api/system.collections.immutable?#remarks">Grundlegendes zu unveränderlichen Sammlungen und deren Installation</see>)</summary>
    <remarks>To be added.</remarks>
    <threadsafe>Dieser Typ ist threadsicher.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public System.Collections.Immutable.ImmutableSortedDictionary&lt;TKey,TValue&gt; Add (TKey key, TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Immutable.ImmutableSortedDictionary`2&lt;!TKey, !TValue&gt; Add(!TKey key, !TValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableSortedDictionary`2.Add(`0,`1)" />
      <MemberSignature Language="VB.NET" Value="Public Function Add (key As TKey, value As TValue) As ImmutableSortedDictionary(Of TKey, TValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Immutable::ImmutableSortedDictionary&lt;TKey, TValue&gt; ^ Add(TKey key, TValue value);" />
      <MemberSignature Language="F#" Value="member this.Add : 'Key * 'Value -&gt; System.Collections.Immutable.ImmutableSortedDictionary&lt;'Key, 'Value&gt;" Usage="immutableSortedDictionary.Add (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.ImmutableSortedDictionary&lt;TKey,TValue&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue" />
      </Parameters>
      <Docs>
        <param name="key">Der Schlüssel des hinzuzufügenden Eintrags.</param>
        <param name="value">Der Wert des hinzuzufügenden Eintrags.</param>
        <summary>Fügt ein Element mit dem angegebenen Schlüssel und Wert zum unveränderlich sortierten Wörterbuch hinzu.</summary>
        <returns>Ein neues unveränderlich sortiertes Wörterbuch, das das zusätzliche Schlüssel-Wert-Paar enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn das angegebene Schlüssel/Wert-Paar im Wörterbuch bereits vorhanden ist, wird die vorhandene Instanz des Wörterbuchs zurückgegeben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der angegebene Schlüssel ist bereits im Wörterbuch vorhanden, hat jedoch einen anderen Wert.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public System.Collections.Immutable.ImmutableSortedDictionary&lt;TKey,TValue&gt; AddRange (System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt; items);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Immutable.ImmutableSortedDictionary`2&lt;!TKey, !TValue&gt; AddRange(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt; items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableSortedDictionary`2.AddRange(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})" />
      <MemberSignature Language="VB.NET" Value="Public Function AddRange (items As IEnumerable(Of KeyValuePair(Of TKey, TValue))) As ImmutableSortedDictionary(Of TKey, TValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Immutable::ImmutableSortedDictionary&lt;TKey, TValue&gt; ^ AddRange(System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt; ^ items);" />
      <MemberSignature Language="F#" Value="member this.AddRange : seq&lt;System.Collections.Generic.KeyValuePair&lt;'Key, 'Value&gt;&gt; -&gt; System.Collections.Immutable.ImmutableSortedDictionary&lt;'Key, 'Value&gt;" Usage="immutableSortedDictionary.AddRange items" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.ImmutableSortedDictionary&lt;TKey,TValue&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="items" Type="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="items">Die Schlüssel-Wert-Paare, die hinzugefügt werden sollen.</param>
        <summary>Fügt dem unveränderlich sortierten Wörterbuch die angegebenen Schlüssel-Wert-Paare hinzu.</summary>
        <returns>Ein neues unveränderliches Wörterbuch, das die zusätzlichen Schlüssel-Wert-Paare enthält.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Einer der angegebenen Schlüssel ist bereits im Wörterbuch vorhanden, hat jedoch einen anderen Wert.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public System.Collections.Immutable.ImmutableSortedDictionary&lt;TKey,TValue&gt; Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Immutable.ImmutableSortedDictionary`2&lt;!TKey, !TValue&gt; Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableSortedDictionary`2.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Function Clear () As ImmutableSortedDictionary(Of TKey, TValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Immutable::ImmutableSortedDictionary&lt;TKey, TValue&gt; ^ Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; System.Collections.Immutable.ImmutableSortedDictionary&lt;'Key, 'Value&gt;" Usage="immutableSortedDictionary.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.ImmutableSortedDictionary&lt;TKey,TValue&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft ein leeres unveränderlich sortiertes Wörterbuch ab, das über dieselben Sortier- und Schlüssel-Wert-Vergleichsregeln wie diese Wörterbuchinstanz verfügt.</summary>
        <returns>Ein leeres Wörterbuch mit äquivalenten Sortier- und Schlüssel-Wert-Vergleichsregeln.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt; pair);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt; pair) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableSortedDictionary`2.Contains(System.Collections.Generic.KeyValuePair{`0,`1})" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (pair As KeyValuePair(Of TKey, TValue)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt; pair);" />
      <MemberSignature Language="F#" Value="abstract member Contains : System.Collections.Generic.KeyValuePair&lt;'Key, 'Value&gt; -&gt; bool&#xA;override this.Contains : System.Collections.Generic.KeyValuePair&lt;'Key, 'Value&gt; -&gt; bool" Usage="immutableSortedDictionary.Contains pair" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Contains(`0)</InterfaceMember>
        <InterfaceMember>M:System.Collections.Immutable.IImmutableDictionary`2.Contains(System.Collections.Generic.KeyValuePair{`0,`1})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pair" Type="System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;" />
      </Parameters>
      <Docs>
        <param name="pair">Das Schlüssel-Wert-Paar, das gesucht werden soll.</param>
        <summary>Bestimmt, ob dieses unveränderlich sortierte Wörterbuch das angegebene Schlüssel-Wert-Paar enthält.</summary>
        <returns>
          <see langword="true" />, wenn das angegebene Schlüssel-Wert-Paar im Wörterbuch gefunden wird, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ContainsKey">
      <MemberSignature Language="C#" Value="public bool ContainsKey (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ContainsKey(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableSortedDictionary`2.ContainsKey(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContainsKey (key As TKey) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ContainsKey(TKey key);" />
      <MemberSignature Language="F#" Value="abstract member ContainsKey : 'Key -&gt; bool&#xA;override this.ContainsKey : 'Key -&gt; bool" Usage="immutableSortedDictionary.ContainsKey key" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IDictionary`2.ContainsKey(`0)</InterfaceMember>
        <InterfaceMember>M:System.Collections.Generic.IReadOnlyDictionary`2.ContainsKey(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">Der zu suchende Schlüssel.</param>
        <summary>Ermittelt, ob diese unveränderlich sortierte Zuordnung den angegebenen Schlüssel enthält.</summary>
        <returns>
          <see langword="true" />, wenn das unveränderliche Wörterbuch den angegebenen Schlüssel enthält, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ContainsValue">
      <MemberSignature Language="C#" Value="public bool ContainsValue (TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ContainsValue(!TValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableSortedDictionary`2.ContainsValue(`1)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContainsValue (value As TValue) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ContainsValue(TValue value);" />
      <MemberSignature Language="F#" Value="member this.ContainsValue : 'Value -&gt; bool" Usage="immutableSortedDictionary.ContainsValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="TValue" />
      </Parameters>
      <Docs>
        <param name="value">Der zu suchende Wert. Der Wert kann für Verweistypen <see langword="null" /> sein.</param>
        <summary>Ermittelt, ob das unveränderlich sortierte Wörterbuch ein Element mit dem angegebenen Wert enthält.</summary>
        <returns>
          <see langword="true" />, wenn das Wörterbuch ein Element mit dem angegebenen Wert enthält, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Immutable.ImmutableSortedDictionary`2.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Collections.Immutable.ImmutableSortedDictionary&lt;'Key, 'Value&gt;.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.Count</InterfaceMember>
        <InterfaceMember>P:System.Collections.Generic.IReadOnlyCollection`1.Count</InterfaceMember>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anzahl der Schlüssel-Wert-Paare im unveränderlich sortierten Wörterbuch ab.</summary>
        <value>Die Anzahl der Schlüssel-Wert-Paare im Wörterbuch.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Empty">
      <MemberSignature Language="C#" Value="public static readonly System.Collections.Immutable.ImmutableSortedDictionary&lt;TKey,TValue&gt; Empty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Collections.Immutable.ImmutableSortedDictionary`2&lt;!TKey, !TValue&gt; Empty" />
      <MemberSignature Language="DocId" Value="F:System.Collections.Immutable.ImmutableSortedDictionary`2.Empty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Empty As ImmutableSortedDictionary(Of TKey, TValue) " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Collections::Immutable::ImmutableSortedDictionary&lt;TKey, TValue&gt; ^ Empty;" />
      <MemberSignature Language="F#" Value=" staticval mutable Empty : System.Collections.Immutable.ImmutableSortedDictionary&lt;'Key, 'Value&gt;" Usage="System.Collections.Immutable.ImmutableSortedDictionary&lt;'Key, 'Value&gt;.Empty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.ImmutableSortedDictionary&lt;TKey,TValue&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein leeres unveränderlich sortiertes Wörterbuch ab.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Immutable.ImmutableSortedDictionary&lt;TKey,TValue&gt;.Enumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Collections.Immutable.ImmutableSortedDictionary`2/Enumerator&lt;!TKey, !TValue&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableSortedDictionary`2.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As ImmutableSortedDictionary(Of TKey, TValue).Enumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Immutable::ImmutableSortedDictionary&lt;TKey, TValue&gt;::Enumerator GetEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; System.Collections.Immutable.ImmutableSortedDictionary&lt;'Key, 'Value&gt;.Enumerator" Usage="immutableSortedDictionary.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.ImmutableSortedDictionary&lt;TKey,TValue&gt;+Enumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Enumerator zurück, der das unveränderlich sortierte Wörterbuch durchläuft.</summary>
        <returns>Ein Enumerator, mit dem das Wörterbuch durchlaufen werden kann.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEmpty">
      <MemberSignature Language="C#" Value="public bool IsEmpty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEmpty" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Immutable.ImmutableSortedDictionary`2.IsEmpty" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsEmpty As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEmpty { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEmpty : bool" Usage="System.Collections.Immutable.ImmutableSortedDictionary&lt;'Key, 'Value&gt;.IsEmpty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob diese Instanz des unveränderlich sortierten Wörterbuchs leer ist.</summary>
        <value>
          <see langword="true" />, wenn diese Instanz leer ist, andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public TValue this[TKey key] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !TValue Item(!TKey)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Immutable.ImmutableSortedDictionary`2.Item(`0)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(key As TKey) As TValue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TValue default[TKey] { TValue get(TKey key); };" />
      <MemberSignature Language="F#" Value="member this.Item('Key) : 'Value" Usage="System.Collections.Immutable.ImmutableSortedDictionary&lt;'Key, 'Value&gt;.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IReadOnlyDictionary`2.Item(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TValue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">Der Schlüssel, dessen Wert abgerufen werden soll.</param>
        <summary>Ruft den <paramref name="TValue" />-Wert ab, der dem angegebenen Schlüssel zugeordnet ist.</summary>
        <value>Der dem angegebenen Schlüssel zugeordnete Wert. Wenn keine Ergebnisse gefunden werden, löst der Vorgang eine Ausnahme aus.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyComparer">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IComparer&lt;TKey&gt; KeyComparer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IComparer`1&lt;!TKey&gt; KeyComparer" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Immutable.ImmutableSortedDictionary`2.KeyComparer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property KeyComparer As IComparer(Of TKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IComparer&lt;TKey&gt; ^ KeyComparer { System::Collections::Generic::IComparer&lt;TKey&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.KeyComparer : System.Collections.Generic.IComparer&lt;'Key&gt;" Usage="System.Collections.Immutable.ImmutableSortedDictionary&lt;'Key, 'Value&gt;.KeyComparer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IComparer&lt;TKey&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Schlüsselvergleich für das unveränderlich sortierte Wörterbuch ab.</summary>
        <value>Der Schlüsselvergleich für das Wörterbuch.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Keys">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;TKey&gt; Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;!TKey&gt; Keys" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Immutable.ImmutableSortedDictionary`2.Keys" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Keys As IEnumerable(Of TKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEnumerable&lt;TKey&gt; ^ Keys { System::Collections::Generic::IEnumerable&lt;TKey&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Keys : seq&lt;'Key&gt;" Usage="System.Collections.Immutable.ImmutableSortedDictionary&lt;'Key, 'Value&gt;.Keys" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IReadOnlyDictionary`2.Keys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TKey&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Schlüssel im unveränderlich sortierten Wörterbuch ab.</summary>
        <value>Die Schlüssel im unveränderlichen Wörterbuch.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public System.Collections.Immutable.ImmutableSortedDictionary&lt;TKey,TValue&gt; Remove (TKey value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Immutable.ImmutableSortedDictionary`2&lt;!TKey, !TValue&gt; Remove(!TKey value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableSortedDictionary`2.Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (value As TKey) As ImmutableSortedDictionary(Of TKey, TValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Immutable::ImmutableSortedDictionary&lt;TKey, TValue&gt; ^ Remove(TKey value);" />
      <MemberSignature Language="F#" Value="member this.Remove : 'Key -&gt; System.Collections.Immutable.ImmutableSortedDictionary&lt;'Key, 'Value&gt;" Usage="immutableSortedDictionary.Remove value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.ImmutableSortedDictionary&lt;TKey,TValue&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert des zu entfernenden Elements.</param>
        <summary>Entfernt das Element mit dem angegebenen Wert aus dem unveränderlich sortierten Wörterbuch.</summary>
        <returns>Ein neues unveränderliches Wörterbuch, aus dem das angegebene Element entfernt wurde, oder diese Instanz, wenn der angegebene Wert im Wörterbuch nicht gefunden wurde.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveRange">
      <MemberSignature Language="C#" Value="public System.Collections.Immutable.ImmutableSortedDictionary&lt;TKey,TValue&gt; RemoveRange (System.Collections.Generic.IEnumerable&lt;TKey&gt; keys);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Immutable.ImmutableSortedDictionary`2&lt;!TKey, !TValue&gt; RemoveRange(class System.Collections.Generic.IEnumerable`1&lt;!TKey&gt; keys) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableSortedDictionary`2.RemoveRange(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveRange (keys As IEnumerable(Of TKey)) As ImmutableSortedDictionary(Of TKey, TValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Immutable::ImmutableSortedDictionary&lt;TKey, TValue&gt; ^ RemoveRange(System::Collections::Generic::IEnumerable&lt;TKey&gt; ^ keys);" />
      <MemberSignature Language="F#" Value="member this.RemoveRange : seq&lt;'Key&gt; -&gt; System.Collections.Immutable.ImmutableSortedDictionary&lt;'Key, 'Value&gt;" Usage="immutableSortedDictionary.RemoveRange keys" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.ImmutableSortedDictionary&lt;TKey,TValue&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Collections.Generic.IEnumerable&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <param name="keys">Die Schlüssel der zu entfernenden Elemente.</param>
        <summary>Entfernt die Elemente mit den angegebenen Schlüsseln aus dem unveränderlich sortierten Wörterbuch.</summary>
        <returns>Ein neues unveränderliches Wörterbuch, aus dem die angegebenen Schlüssel entfernt wurden, oder diese Instanz, wenn die angegebenen Schlüssel im Wörterbuch nicht gefunden wurden.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetItem">
      <MemberSignature Language="C#" Value="public System.Collections.Immutable.ImmutableSortedDictionary&lt;TKey,TValue&gt; SetItem (TKey key, TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Immutable.ImmutableSortedDictionary`2&lt;!TKey, !TValue&gt; SetItem(!TKey key, !TValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableSortedDictionary`2.SetItem(`0,`1)" />
      <MemberSignature Language="VB.NET" Value="Public Function SetItem (key As TKey, value As TValue) As ImmutableSortedDictionary(Of TKey, TValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Immutable::ImmutableSortedDictionary&lt;TKey, TValue&gt; ^ SetItem(TKey key, TValue value);" />
      <MemberSignature Language="F#" Value="member this.SetItem : 'Key * 'Value -&gt; System.Collections.Immutable.ImmutableSortedDictionary&lt;'Key, 'Value&gt;" Usage="immutableSortedDictionary.SetItem (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.ImmutableSortedDictionary&lt;TKey,TValue&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue" />
      </Parameters>
      <Docs>
        <param name="key">Der Schlüssel des hinzuzufügenden Eintrags.</param>
        <param name="value">Der Schlüsselwert, der festgelegt werden soll.</param>
        <summary>Legt den angegebenen Schlüssel und Wert im unveränderlich sortierten Wörterbuch fest, wobei ein vorhandener Wert für den Schlüssel überschrieben werden kann.</summary>
        <returns>Ein neues unveränderlich sortiertes Wörterbuch, das das angegebene Schlüssel-Wert-Paar enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn das angegebene Schlüssel-Wert-Paar im Wörterbuch bereits vorhanden ist, gibt diese Methode die vorhandene Instanz des Wörterbuchs. Wenn der Schlüssel bereits vorhanden ist, aber einen anderen Wert aufweist, gibt diese Methode eine neue Instanz der dem Wörterbuch mit dem Wert überschrieben.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetItems">
      <MemberSignature Language="C#" Value="public System.Collections.Immutable.ImmutableSortedDictionary&lt;TKey,TValue&gt; SetItems (System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt; items);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Immutable.ImmutableSortedDictionary`2&lt;!TKey, !TValue&gt; SetItems(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt; items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableSortedDictionary`2.SetItems(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})" />
      <MemberSignature Language="VB.NET" Value="Public Function SetItems (items As IEnumerable(Of KeyValuePair(Of TKey, TValue))) As ImmutableSortedDictionary(Of TKey, TValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Immutable::ImmutableSortedDictionary&lt;TKey, TValue&gt; ^ SetItems(System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt; ^ items);" />
      <MemberSignature Language="F#" Value="member this.SetItems : seq&lt;System.Collections.Generic.KeyValuePair&lt;'Key, 'Value&gt;&gt; -&gt; System.Collections.Immutable.ImmutableSortedDictionary&lt;'Key, 'Value&gt;" Usage="immutableSortedDictionary.SetItems items" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.ImmutableSortedDictionary&lt;TKey,TValue&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="items" Type="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="items">Die Schlüssel-Wert-Paare, die im Wörterbuch festgelegt werden sollen. Falls ein Schlüssel bereits im Wörterbuch vorhanden ist, überschreibt diese Methode dessen vorherigen Wert.</param>
        <summary>Legt die angegebenen Schlüssel-Wert-Paare im unveränderlich sortierten Wörterbuch fest, wobei vorhandene Werte für die Schlüssel überschrieben werden können.</summary>
        <returns>Ein unveränderliches Wörterbuch, das die angegebenen Schlüssel-Wert-Paare enthält.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Add">
      <MemberSignature Language="C#" Value="void ICollection&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;.Add (System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt; item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Add(valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt; item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableSortedDictionary`2.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#Add(System.Collections.Generic.KeyValuePair{`0,`1})" />
      <MemberSignature Language="VB.NET" Value="Sub Add (item As KeyValuePair(Of TKey, TValue)) Implements ICollection(Of KeyValuePair(Of TKey, TValue)).Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Add(System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt; item) = System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;" />
      </Parameters>
      <Docs>
        <param name="item">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Clear">
      <MemberSignature Language="C#" Value="void ICollection&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;.Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableSortedDictionary`2.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#Clear" />
      <MemberSignature Language="VB.NET" Value="Sub Clear () Implements ICollection(Of KeyValuePair(Of TKey, TValue)).Clear" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Clear() = System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;::Clear;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;.CopyTo (System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;[] array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.CopyTo(valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;[] array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableSortedDictionary`2.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Sub CopyTo (array As KeyValuePair(Of TKey, TValue)(), arrayIndex As Integer) Implements ICollection(Of KeyValuePair(Of TKey, TValue)).CopyTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.CopyTo(cli::array &lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt; ^ array, int arrayIndex) = System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;::CopyTo;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">To be added.</param>
        <param name="arrayIndex">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Immutable.ImmutableSortedDictionary`2.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements ICollection(Of KeyValuePair(Of TKey, TValue)).IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;TKey,TValue&gt;&gt;::IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Remove">
      <MemberSignature Language="C#" Value="bool ICollection&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;.Remove (System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt; item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Remove(valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt; item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableSortedDictionary`2.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#Remove(System.Collections.Generic.KeyValuePair{`0,`1})" />
      <MemberSignature Language="VB.NET" Value="Function Remove (item As KeyValuePair(Of TKey, TValue)) As Boolean Implements ICollection(Of KeyValuePair(Of TKey, TValue)).Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Remove(System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt; item) = System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;" />
      </Parameters>
      <Docs>
        <param name="item">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Add">
      <MemberSignature Language="C#" Value="void IDictionary&lt;TKey,TValue&gt;.Add (TKey key, TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Add(!TKey key, !TValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableSortedDictionary`2.System#Collections#Generic#IDictionary&lt;TKey,TValue&gt;#Add(`0,`1)" />
      <MemberSignature Language="VB.NET" Value="Sub Add (key As TKey, value As TValue) Implements IDictionary(Of TKey, TValue).Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Add(TKey key, TValue value) = System::Collections::Generic::IDictionary&lt;TKey, TValue&gt;::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IDictionary`2.Add(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue" />
      </Parameters>
      <Docs>
        <param name="key">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Item">
      <MemberSignature Language="C#" Value="TValue System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Item[TKey key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !TValue System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Item(!TKey)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Immutable.ImmutableSortedDictionary`2.System#Collections#Generic#IDictionary&lt;TKey,TValue&gt;#Item(`0)" />
      <MemberSignature Language="VB.NET" Value=" Property Item(key As TKey) As TValue Implements IDictionary(Of TKey, TValue).Item" />
      <MemberSignature Language="C++ CLI" Value="property TValue System::Collections::Generic::IDictionary&lt;TKey,TValue&gt;::Item[TKey] { TValue get(TKey key); void set(TKey key, TValue value); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IDictionary`2.Item(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TValue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">To be added.</param>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Keys">
      <MemberSignature Language="C#" Value="System.Collections.Generic.ICollection&lt;TKey&gt; System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;!TKey&gt; System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Keys" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Immutable.ImmutableSortedDictionary`2.System#Collections#Generic#IDictionary&lt;TKey,TValue&gt;#Keys" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Keys As ICollection(Of TKey) Implements IDictionary(Of TKey, TValue).Keys" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::Generic::ICollection&lt;TKey&gt; ^ System::Collections::Generic::IDictionary&lt;TKey,TValue&gt;::Keys { System::Collections::Generic::ICollection&lt;TKey&gt; ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Keys" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IDictionary`2.Keys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;TKey&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Remove">
      <MemberSignature Language="C#" Value="bool IDictionary&lt;TKey,TValue&gt;.Remove (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Remove(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableSortedDictionary`2.System#Collections#Generic#IDictionary&lt;TKey,TValue&gt;#Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Function Remove (key As TKey) As Boolean Implements IDictionary(Of TKey, TValue).Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Remove(TKey key) = System::Collections::Generic::IDictionary&lt;TKey, TValue&gt;::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IDictionary`2.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Values">
      <MemberSignature Language="C#" Value="System.Collections.Generic.ICollection&lt;TValue&gt; System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;!TValue&gt; System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Values" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Immutable.ImmutableSortedDictionary`2.System#Collections#Generic#IDictionary&lt;TKey,TValue&gt;#Values" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Values As ICollection(Of TValue) Implements IDictionary(Of TKey, TValue).Values" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::Generic::ICollection&lt;TValue&gt; ^ System::Collections::Generic::IDictionary&lt;TKey,TValue&gt;::Values { System::Collections::Generic::ICollection&lt;TValue&gt; ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Values" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IDictionary`2.Values</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;TValue&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt; IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt; System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableSortedDictionary`2.System#Collections#Generic#IEnumerable&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of KeyValuePair(Of TKey, TValue)) Implements IEnumerable(Of KeyValuePair(Of TKey, TValue)).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt; ^ System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableSortedDictionary`2.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.ICollection.CopyTo(Array ^ array, int index) = System::Collections::ICollection::CopyTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Das eindimensionale Array, welches das Ziel der aus dem Wörterbuch kopierten Elemente ist. Für das Array muss eine nullbasierte Indizierung verwendet werden.</param>
        <param name="index">Der nullbasierte Index im <paramref name="array" />, bei dem der Kopiervorgang beginnt.</param>
        <summary>Kopiert die Elemente des Wörterbuchs in ein Array, wobei an einem bestimmten Arrayindex begonnen wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Collections.Immutable.ImmutableSortedDictionary%602>-Instanz in eine <xref:System.Collections.ICollection>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Immutable.ImmutableSortedDictionary`2.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::ICollection::IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1">
          <AttributeName>System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Zugriff auf die <see cref="T:System.Collections.ICollection" /> synchronisiert (threadsicher) ist.</summary>
        <value>"true", wenn der Zugriff auf die <see cref="T:System.Collections.ICollection" />-Klasse synchronisiert ist (threadsicher), andernfalls "false".</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Immutable.ImmutableSortedDictionary`2.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::ICollection::SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1">
          <AttributeName>System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein Objekt ab, mit dem der Zugriff auf <see cref="T:System.Collections.ICollection" /> synchronisiert werden kann.</summary>
        <value>Ein Objekt, mit dem der Zugriff auf die <see cref="T:System.Collections.ICollection" /> synchronisiert werden kann.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Add">
      <MemberSignature Language="C#" Value="void IDictionary.Add (object key, object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IDictionary.Add(object key, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableSortedDictionary`2.System#Collections#IDictionary#Add(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Add (key As Object, value As Object) Implements IDictionary.Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IDictionary.Add(System::Object ^ key, System::Object ^ value) = System::Collections::IDictionary::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Add(System.Object,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Das Objekt, das als Schlüssel des hinzuzufügenden Elements verwendet werden soll.</param>
        <param name="value">Das Objekt, das als Wert des hinzuzufügenden Elements verwendet werden soll.</param>
        <summary>Fügt dem Wörterbuchobjekt ein Element mit dem angegebenen Schlüssel und Wert hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Collections.Immutable.ImmutableSortedDictionary%602>-Instanz in eine <xref:System.Collections.IDictionary>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Clear">
      <MemberSignature Language="C#" Value="void IDictionary.Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IDictionary.Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableSortedDictionary`2.System#Collections#IDictionary#Clear" />
      <MemberSignature Language="VB.NET" Value="Sub Clear () Implements IDictionary.Clear" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IDictionary.Clear() = System::Collections::IDictionary::Clear;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Löscht diese Instanz.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Collections.Immutable.ImmutableSortedDictionary%602>-Instanz in eine <xref:System.Collections.IDictionary>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Das Wörterbuchobjekt ist schreibgeschützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Contains">
      <MemberSignature Language="C#" Value="bool IDictionary.Contains (object key);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IDictionary.Contains(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableSortedDictionary`2.System#Collections#IDictionary#Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Contains (key As Object) As Boolean Implements IDictionary.Contains" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IDictionary.Contains(System::Object ^ key) = System::Collections::IDictionary::Contains;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Der im Dictionary-Objekt zu suchende Schlüssel.</param>
        <summary>Bestimmt, ob das unveränderliche Dictionary-Objekt ein Element enthält, das über den angegebenen Schlüssel verfügt.</summary>
        <returns>
          <see langword="true" />, wenn das Wörterbuch ein Element mit dem Schlüssel enthält, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Collections.Immutable.ImmutableSortedDictionary%602>-Instanz in eine <xref:System.Collections.IDictionary>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IDictionaryEnumerator IDictionary.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableSortedDictionary`2.System#Collections#IDictionary#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IDictionaryEnumerator Implements IDictionary.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IDictionaryEnumerator ^ System.Collections.IDictionary.GetEnumerator() = System::Collections::IDictionary::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionaryEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt ein <see cref="T:System.Collections.IDictionaryEnumerator" />-Objekt für das unveränderliche Dictionary-Objekt zurück.</summary>
        <returns>Ein Enumeratorobjekt für das Dictionary-Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Collections.Immutable.ImmutableSortedDictionary%602>-Instanz in eine <xref:System.Collections.IDictionary>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.IsFixedSize">
      <MemberSignature Language="C#" Value="bool System.Collections.IDictionary.IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IDictionary.IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Immutable.ImmutableSortedDictionary`2.System#Collections#IDictionary#IsFixedSize" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFixedSize As Boolean Implements IDictionary.IsFixedSize" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::IDictionary::IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IDictionary.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das <see cref="T:System.Collections.IDictionary" />-Objekt eine feste Größe hat.</summary>
        <value>True, wenn die <see cref="T:System.Collections.IDictionary" /> Objekt verfügt über eine feste Größe; andernfalls "false".</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.IDictionary.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IDictionary.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Immutable.ImmutableSortedDictionary`2.System#Collections#IDictionary#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements IDictionary.IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::IDictionary::IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IDictionary.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das <see cref="T:System.Collections.Generic.ICollection`1" /> schreibgeschützt ist.</summary>
        <value>True, wenn die <see cref="T:System.Collections.Generic.ICollection`1" /> ist sie schreibgeschützt ist; andernfalls "false".</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Item">
      <MemberSignature Language="C#" Value="object System.Collections.IDictionary.Item[object key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IDictionary.Item(object)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Immutable.ImmutableSortedDictionary`2.System#Collections#IDictionary#Item(System.Object)" />
      <MemberSignature Language="VB.NET" Value=" Property Item(key As Object) As Object Implements IDictionary.Item" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::IDictionary::Item[System::Object ^] { System::Object ^ get(System::Object ^ key); void set(System::Object ^ key, System::Object ^ value); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IDictionary.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Item(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Der Schlüssel.</param>
        <summary>Ruft das Element mit dem angegebenen Schlüssel ab oder legt dieses fest.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Keys">
      <MemberSignature Language="C#" Value="System.Collections.ICollection System.Collections.IDictionary.Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection System.Collections.IDictionary.Keys" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Immutable.ImmutableSortedDictionary`2.System#Collections#IDictionary#Keys" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Keys As ICollection Implements IDictionary.Keys" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::ICollection ^ System::Collections::IDictionary::Keys { System::Collections::ICollection ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IDictionary.Keys" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Keys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine <see cref="T:System.Collections.Generic.ICollection`1" /> ab, die die Schlüssel des <see cref="T:System.Collections.Generic.IDictionary`2" /> enthält.</summary>
        <value>Eine <see cref="T:System.Collections.Generic.ICollection`1" />, die die Schlüssel des Objekts enthält, das <see cref="T:System.Collections.Generic.IDictionary`2" /> implementiert.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Remove">
      <MemberSignature Language="C#" Value="void IDictionary.Remove (object key);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IDictionary.Remove(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableSortedDictionary`2.System#Collections#IDictionary#Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Remove (key As Object) Implements IDictionary.Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IDictionary.Remove(System::Object ^ key) = System::Collections::IDictionary::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Der Schlüssel des zu entfernenden Elements.</param>
        <summary>Entfernt das Element mit dem angegebenen Schlüssel aus dem unveränderlichen Dictionary-Objekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Collections.Immutable.ImmutableSortedDictionary%602>-Instanz in eine <xref:System.Collections.IDictionary>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Values">
      <MemberSignature Language="C#" Value="System.Collections.ICollection System.Collections.IDictionary.Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection System.Collections.IDictionary.Values" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Immutable.ImmutableSortedDictionary`2.System#Collections#IDictionary#Values" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Values As ICollection Implements IDictionary.Values" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::ICollection ^ System::Collections::IDictionary::Values { System::Collections::ICollection ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IDictionary.Values" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Values</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine <see cref="T:System.Collections.Generic.ICollection`1" /> ab, die die Werte im <see cref="T:System.Collections.Generic.IDictionary`2" /> enthält.</summary>
        <value>Eine <see cref="T:System.Collections.Generic.ICollection`1" />, die die Werte des Objekts enthält, das <see cref="T:System.Collections.Generic.IDictionary`2" /> implementiert.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableSortedDictionary`2.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Enumerator zurück, der eine Auflistung durchläuft.</summary>
        <returns>Ein Enumeratorobjekt, mit dessen Hilfe die Auflistung durchlaufen werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Collections.Immutable.ImmutableSortedDictionary%602>-Instanz in eine <xref:System.Collections.IEnumerable>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Immutable.IImmutableDictionary&lt;TKey,TValue&gt;.Add">
      <MemberSignature Language="C#" Value="System.Collections.Immutable.IImmutableDictionary&lt;TKey,TValue&gt; IImmutableDictionary&lt;TKey,TValue&gt;.Add (TKey key, TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Immutable.IImmutableDictionary`2&lt;!TKey, !TValue&gt; System.Collections.Immutable.IImmutableDictionary&lt;TKey,TValue&gt;.Add(!TKey key, !TValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableSortedDictionary`2.System#Collections#Immutable#IImmutableDictionary&lt;TKey,TValue&gt;#Add(`0,`1)" />
      <MemberSignature Language="VB.NET" Value="Function Add (key As TKey, value As TValue) As IImmutableDictionary(Of TKey, TValue) Implements IImmutableDictionary(Of TKey, TValue).Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Immutable::IImmutableDictionary&lt;TKey, TValue&gt; ^ System.Collections.Immutable.IImmutableDictionary&lt;TKey,TValue&gt;.Add(TKey key, TValue value) = System::Collections::Immutable::IImmutableDictionary&lt;TKey, TValue&gt;::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Immutable.IImmutableDictionary`2.Add(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.IImmutableDictionary&lt;TKey,TValue&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue" />
      </Parameters>
      <Docs>
        <param name="key">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Immutable.IImmutableDictionary&lt;TKey,TValue&gt;.AddRange">
      <MemberSignature Language="C#" Value="System.Collections.Immutable.IImmutableDictionary&lt;TKey,TValue&gt; IImmutableDictionary&lt;TKey,TValue&gt;.AddRange (System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt; pairs);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Immutable.IImmutableDictionary`2&lt;!TKey, !TValue&gt; System.Collections.Immutable.IImmutableDictionary&lt;TKey,TValue&gt;.AddRange(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt; pairs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableSortedDictionary`2.System#Collections#Immutable#IImmutableDictionary&lt;TKey,TValue&gt;#AddRange(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})" />
      <MemberSignature Language="VB.NET" Value="Function AddRange (pairs As IEnumerable(Of KeyValuePair(Of TKey, TValue))) As IImmutableDictionary(Of TKey, TValue) Implements IImmutableDictionary(Of TKey, TValue).AddRange" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Immutable::IImmutableDictionary&lt;TKey, TValue&gt; ^ System.Collections.Immutable.IImmutableDictionary&lt;TKey,TValue&gt;.AddRange(System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt; ^ pairs) = System::Collections::Immutable::IImmutableDictionary&lt;TKey, TValue&gt;::AddRange;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Immutable.IImmutableDictionary`2.AddRange(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.IImmutableDictionary&lt;TKey,TValue&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pairs" Type="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="pairs">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Immutable.IImmutableDictionary&lt;TKey,TValue&gt;.Clear">
      <MemberSignature Language="C#" Value="System.Collections.Immutable.IImmutableDictionary&lt;TKey,TValue&gt; IImmutableDictionary&lt;TKey,TValue&gt;.Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Immutable.IImmutableDictionary`2&lt;!TKey, !TValue&gt; System.Collections.Immutable.IImmutableDictionary&lt;TKey,TValue&gt;.Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableSortedDictionary`2.System#Collections#Immutable#IImmutableDictionary&lt;TKey,TValue&gt;#Clear" />
      <MemberSignature Language="VB.NET" Value="Function Clear () As IImmutableDictionary(Of TKey, TValue) Implements IImmutableDictionary(Of TKey, TValue).Clear" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Immutable::IImmutableDictionary&lt;TKey, TValue&gt; ^ System.Collections.Immutable.IImmutableDictionary&lt;TKey,TValue&gt;.Clear() = System::Collections::Immutable::IImmutableDictionary&lt;TKey, TValue&gt;::Clear;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Immutable.IImmutableDictionary`2.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.IImmutableDictionary&lt;TKey,TValue&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Immutable.IImmutableDictionary&lt;TKey,TValue&gt;.Remove">
      <MemberSignature Language="C#" Value="System.Collections.Immutable.IImmutableDictionary&lt;TKey,TValue&gt; IImmutableDictionary&lt;TKey,TValue&gt;.Remove (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Immutable.IImmutableDictionary`2&lt;!TKey, !TValue&gt; System.Collections.Immutable.IImmutableDictionary&lt;TKey,TValue&gt;.Remove(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableSortedDictionary`2.System#Collections#Immutable#IImmutableDictionary&lt;TKey,TValue&gt;#Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Function Remove (key As TKey) As IImmutableDictionary(Of TKey, TValue) Implements IImmutableDictionary(Of TKey, TValue).Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Immutable::IImmutableDictionary&lt;TKey, TValue&gt; ^ System.Collections.Immutable.IImmutableDictionary&lt;TKey,TValue&gt;.Remove(TKey key) = System::Collections::Immutable::IImmutableDictionary&lt;TKey, TValue&gt;::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Immutable.IImmutableDictionary`2.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.IImmutableDictionary&lt;TKey,TValue&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Immutable.IImmutableDictionary&lt;TKey,TValue&gt;.RemoveRange">
      <MemberSignature Language="C#" Value="System.Collections.Immutable.IImmutableDictionary&lt;TKey,TValue&gt; IImmutableDictionary&lt;TKey,TValue&gt;.RemoveRange (System.Collections.Generic.IEnumerable&lt;TKey&gt; keys);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Immutable.IImmutableDictionary`2&lt;!TKey, !TValue&gt; System.Collections.Immutable.IImmutableDictionary&lt;TKey,TValue&gt;.RemoveRange(class System.Collections.Generic.IEnumerable`1&lt;!TKey&gt; keys) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableSortedDictionary`2.System#Collections#Immutable#IImmutableDictionary&lt;TKey,TValue&gt;#RemoveRange(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Function RemoveRange (keys As IEnumerable(Of TKey)) As IImmutableDictionary(Of TKey, TValue) Implements IImmutableDictionary(Of TKey, TValue).RemoveRange" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Immutable::IImmutableDictionary&lt;TKey, TValue&gt; ^ System.Collections.Immutable.IImmutableDictionary&lt;TKey,TValue&gt;.RemoveRange(System::Collections::Generic::IEnumerable&lt;TKey&gt; ^ keys) = System::Collections::Immutable::IImmutableDictionary&lt;TKey, TValue&gt;::RemoveRange;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Immutable.IImmutableDictionary`2.RemoveRange(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.IImmutableDictionary&lt;TKey,TValue&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Collections.Generic.IEnumerable&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <param name="keys">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Immutable.IImmutableDictionary&lt;TKey,TValue&gt;.SetItem">
      <MemberSignature Language="C#" Value="System.Collections.Immutable.IImmutableDictionary&lt;TKey,TValue&gt; IImmutableDictionary&lt;TKey,TValue&gt;.SetItem (TKey key, TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Immutable.IImmutableDictionary`2&lt;!TKey, !TValue&gt; System.Collections.Immutable.IImmutableDictionary&lt;TKey,TValue&gt;.SetItem(!TKey key, !TValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableSortedDictionary`2.System#Collections#Immutable#IImmutableDictionary&lt;TKey,TValue&gt;#SetItem(`0,`1)" />
      <MemberSignature Language="VB.NET" Value="Function SetItem (key As TKey, value As TValue) As IImmutableDictionary(Of TKey, TValue) Implements IImmutableDictionary(Of TKey, TValue).SetItem" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Immutable::IImmutableDictionary&lt;TKey, TValue&gt; ^ System.Collections.Immutable.IImmutableDictionary&lt;TKey,TValue&gt;.SetItem(TKey key, TValue value) = System::Collections::Immutable::IImmutableDictionary&lt;TKey, TValue&gt;::SetItem;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Immutable.IImmutableDictionary`2.SetItem(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.IImmutableDictionary&lt;TKey,TValue&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue" />
      </Parameters>
      <Docs>
        <param name="key">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Immutable.IImmutableDictionary&lt;TKey,TValue&gt;.SetItems">
      <MemberSignature Language="C#" Value="System.Collections.Immutable.IImmutableDictionary&lt;TKey,TValue&gt; IImmutableDictionary&lt;TKey,TValue&gt;.SetItems (System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt; items);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Immutable.IImmutableDictionary`2&lt;!TKey, !TValue&gt; System.Collections.Immutable.IImmutableDictionary&lt;TKey,TValue&gt;.SetItems(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt; items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableSortedDictionary`2.System#Collections#Immutable#IImmutableDictionary&lt;TKey,TValue&gt;#SetItems(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})" />
      <MemberSignature Language="VB.NET" Value="Function SetItems (items As IEnumerable(Of KeyValuePair(Of TKey, TValue))) As IImmutableDictionary(Of TKey, TValue) Implements IImmutableDictionary(Of TKey, TValue).SetItems" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Immutable::IImmutableDictionary&lt;TKey, TValue&gt; ^ System.Collections.Immutable.IImmutableDictionary&lt;TKey,TValue&gt;.SetItems(System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt; ^ items) = System::Collections::Immutable::IImmutableDictionary&lt;TKey, TValue&gt;::SetItems;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Immutable.IImmutableDictionary`2.SetItems(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.IImmutableDictionary&lt;TKey,TValue&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="items" Type="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="items">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToBuilder">
      <MemberSignature Language="C#" Value="public System.Collections.Immutable.ImmutableSortedDictionary&lt;TKey,TValue&gt;.Builder ToBuilder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Immutable.ImmutableSortedDictionary`2/Builder&lt;!TKey, !TValue&gt; ToBuilder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableSortedDictionary`2.ToBuilder" />
      <MemberSignature Language="VB.NET" Value="Public Function ToBuilder () As ImmutableSortedDictionary(Of TKey, TValue).Builder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Immutable::ImmutableSortedDictionary&lt;TKey, TValue&gt;::Builder ^ ToBuilder();" />
      <MemberSignature Language="F#" Value="member this.ToBuilder : unit -&gt; System.Collections.Immutable.ImmutableSortedDictionary&lt;'Key, 'Value&gt;.Builder" Usage="immutableSortedDictionary.ToBuilder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.ImmutableSortedDictionary&lt;TKey,TValue&gt;+Builder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt ein unveränderlich sortiertes Wörterbuch, das den gleichen Inhalt wie dieses Wörterbuch aufweist und über mehrere Vorgänge mithilfe änderbarer Standardschnittstellen effizient verändert werden kann.</summary>
        <returns>Eine Auflistung mit dem gleichen Inhalt wie dieses Wörterbuch.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist ein o(1)-Vorgang und führt nur eine (kleine) speicherbelegung. Die änderbare Auflistung, die zurückgegeben wird, ist nicht threadsicher.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetKey">
      <MemberSignature Language="C#" Value="public bool TryGetKey (TKey equalKey, out TKey actualKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryGetKey(!TKey equalKey, [out] !TKey&amp; actualKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableSortedDictionary`2.TryGetKey(`0,`0@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetKey (equalKey As TKey, ByRef actualKey As TKey) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryGetKey(TKey equalKey, [Runtime::InteropServices::Out] TKey % actualKey);" />
      <MemberSignature Language="F#" Value="abstract member TryGetKey : 'Key *  -&gt; bool&#xA;override this.TryGetKey : 'Key *  -&gt; bool" Usage="immutableSortedDictionary.TryGetKey (equalKey, actualKey)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Immutable.IImmutableDictionary`2.TryGetKey(`0,`0@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="equalKey" Type="TKey" />
        <Parameter Name="actualKey" Type="TKey" RefType="out" />
      </Parameters>
      <Docs>
        <param name="equalKey">Der zu suchende Schlüssel.</param>
        <param name="actualKey">Der übereinstimmende Schlüssel im Wörterbuch, wenn gefunden, oder <c>equalkey</c>, wenn keine Übereinstimmung gefunden wird.</param>
        <summary>Ermittelt, ob das Wörterbuch einen bestimmten Schlüssel enthält.</summary>
        <returns>
          <see langword="true" />, wenn eine Übereinstimmung für <paramref name="equalKey" /> gefunden wird, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es folgen einige Szenarien, in denen <xref:System.Collections.Immutable.ImmutableSortedDictionary%602.TryGetKey%2A> kann nützlich sein:  
  
-   Möchten Sie einen zuvor gespeicherten Objektverweis, statt einen neuen Verweis wiederverwenden.  
  
-   Der kanonische Wert eines Objekts gesucht werden sollen.  
  
-   Vollständigere Daten über ein Objekt abgerufen werden soll  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetValue">
      <MemberSignature Language="C#" Value="public bool TryGetValue (TKey key, out TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryGetValue(!TKey key, [out] !TValue&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableSortedDictionary`2.TryGetValue(`0,`1@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetValue (key As TKey, ByRef value As TValue) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryGetValue(TKey key, [Runtime::InteropServices::Out] TValue % value);" />
      <MemberSignature Language="F#" Value="abstract member TryGetValue : 'Key *  -&gt; bool&#xA;override this.TryGetValue : 'Key *  -&gt; bool" Usage="immutableSortedDictionary.TryGetValue (key, value)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IDictionary`2.TryGetValue(`0,`1@)</InterfaceMember>
        <InterfaceMember>M:System.Collections.Generic.IReadOnlyDictionary`2.TryGetValue(`0,`1@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue" RefType="out" />
      </Parameters>
      <Docs>
        <param name="key">Der Schlüssel, dessen Wert abgerufen wird.</param>
        <param name="value">Enthält nach dem Beenden dieser Methode den Wert, der dem angegebenen Schlüssel zugeordnet ist (wenn der Schlüssel gefunden wurde), oder andernfalls den Standardwert für den Typ des <paramref name="value" />-Parameters.</param>
        <summary>Ruft den dem angegebenen Schlüssel zugeordneten Wert ab.</summary>
        <returns>
          <see langword="true" />, wenn das Wörterbuch ein Element mit dem angegebenen Schlüssel enthält, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ValueComparer">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEqualityComparer&lt;TValue&gt; ValueComparer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEqualityComparer`1&lt;!TValue&gt; ValueComparer" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Immutable.ImmutableSortedDictionary`2.ValueComparer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ValueComparer As IEqualityComparer(Of TValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEqualityComparer&lt;TValue&gt; ^ ValueComparer { System::Collections::Generic::IEqualityComparer&lt;TValue&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ValueComparer : System.Collections.Generic.IEqualityComparer&lt;'Value&gt;" Usage="System.Collections.Immutable.ImmutableSortedDictionary&lt;'Key, 'Value&gt;.ValueComparer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEqualityComparer&lt;TValue&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Wertevergleich ab, mit dem bestimmt wird, ob Werte identisch sind.</summary>
        <value>Der Wertevergleich, mit dem bestimmt wird, ob Werte identisch sind.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ValueRef">
      <MemberSignature Language="C#" Value="public TValue&amp; ValueRef (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance TValue&amp; modreq(System.Runtime.InteropServices.InAttribute) ValueRef(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableSortedDictionary`2.ValueRef(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function ValueRef (key As TKey) As TValue&amp;" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TValue&amp; ^ ValueRef(TKey key);" />
      <MemberSignature Language="F#" Value="member this.ValueRef : 'Key -&gt; TValue&amp;" Usage="immutableSortedDictionary.ValueRef key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue RefType="Readonly">
        <ReturnType>TValue</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="netcore-2.1">
            <AttributeName>System.Runtime.CompilerServices.IsReadOnly</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Values">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;TValue&gt; Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;!TValue&gt; Values" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Immutable.ImmutableSortedDictionary`2.Values" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Values As IEnumerable(Of TValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEnumerable&lt;TValue&gt; ^ Values { System::Collections::Generic::IEnumerable&lt;TValue&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Values : seq&lt;'Value&gt;" Usage="System.Collections.Immutable.ImmutableSortedDictionary&lt;'Key, 'Value&gt;.Values" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IReadOnlyDictionary`2.Values</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TValue&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Werte im unveränderlich sortierten Wörterbuch ab.</summary>
        <value>Die Werte im Wörterbuch.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WithComparers">
      <MemberSignature Language="C#" Value="public System.Collections.Immutable.ImmutableSortedDictionary&lt;TKey,TValue&gt; WithComparers (System.Collections.Generic.IComparer&lt;TKey&gt; keyComparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Immutable.ImmutableSortedDictionary`2&lt;!TKey, !TValue&gt; WithComparers(class System.Collections.Generic.IComparer`1&lt;!TKey&gt; keyComparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableSortedDictionary`2.WithComparers(System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function WithComparers (keyComparer As IComparer(Of TKey)) As ImmutableSortedDictionary(Of TKey, TValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Immutable::ImmutableSortedDictionary&lt;TKey, TValue&gt; ^ WithComparers(System::Collections::Generic::IComparer&lt;TKey&gt; ^ keyComparer);" />
      <MemberSignature Language="F#" Value="member this.WithComparers : System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; System.Collections.Immutable.ImmutableSortedDictionary&lt;'Key, 'Value&gt;" Usage="immutableSortedDictionary.WithComparers keyComparer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.ImmutableSortedDictionary&lt;TKey,TValue&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyComparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <param name="keyComparer">Der zu verwendende Schlüsselvergleich.</param>
        <summary>Ruft eine Instanz des unveränderlich sortierten Wörterbuchs ab, die den angegebenen Schlüsselvergleich verwendet.</summary>
        <returns>Eine Instanz des unveränderlichen Wörterbuchs, die den angegebenen Vergleich verwendet.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WithComparers">
      <MemberSignature Language="C#" Value="public System.Collections.Immutable.ImmutableSortedDictionary&lt;TKey,TValue&gt; WithComparers (System.Collections.Generic.IComparer&lt;TKey&gt; keyComparer, System.Collections.Generic.IEqualityComparer&lt;TValue&gt; valueComparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Immutable.ImmutableSortedDictionary`2&lt;!TKey, !TValue&gt; WithComparers(class System.Collections.Generic.IComparer`1&lt;!TKey&gt; keyComparer, class System.Collections.Generic.IEqualityComparer`1&lt;!TValue&gt; valueComparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.ImmutableSortedDictionary`2.WithComparers(System.Collections.Generic.IComparer{`0},System.Collections.Generic.IEqualityComparer{`1})" />
      <MemberSignature Language="VB.NET" Value="Public Function WithComparers (keyComparer As IComparer(Of TKey), valueComparer As IEqualityComparer(Of TValue)) As ImmutableSortedDictionary(Of TKey, TValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Immutable::ImmutableSortedDictionary&lt;TKey, TValue&gt; ^ WithComparers(System::Collections::Generic::IComparer&lt;TKey&gt; ^ keyComparer, System::Collections::Generic::IEqualityComparer&lt;TValue&gt; ^ valueComparer);" />
      <MemberSignature Language="F#" Value="member this.WithComparers : System.Collections.Generic.IComparer&lt;'Key&gt; * System.Collections.Generic.IEqualityComparer&lt;'Value&gt; -&gt; System.Collections.Immutable.ImmutableSortedDictionary&lt;'Key, 'Value&gt;" Usage="immutableSortedDictionary.WithComparers (keyComparer, valueComparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.ImmutableSortedDictionary&lt;TKey,TValue&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyComparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
        <Parameter Name="valueComparer" Type="System.Collections.Generic.IEqualityComparer&lt;TValue&gt;" />
      </Parameters>
      <Docs>
        <param name="keyComparer">Der zu verwendende Schlüsselvergleich.</param>
        <param name="valueComparer">Der zu verwendende Wertevergleich.</param>
        <summary>Ruft eine Instanz des unveränderlich sortierten Wörterbuchs ab, die die angegebenen Schlüssel- und Wertevergleiche verwendet.</summary>
        <returns>Eine Instanz des unveränderlichen Wörterbuchs, die die angegebenen Vergleiche verwendet.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>