<Type Name="Project" FullName="Microsoft.Build.Evaluation.Project">
  <Metadata><Meta Name="ms.openlocfilehash" Value="fadacea692f5841d93eab99cf32f6ff5b86bb4d5" /><Meta Name="ms.sourcegitcommit" Value="756d085f27705e86604f1bba5f2086ee23761acf" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="01/30/2019" /><Meta Name="ms.locfileid" Value="55423744" /></Metadata><TypeSignature Language="C#" Value="public class Project" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Project extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.Build.Evaluation.Project" />
  <TypeSignature Language="VB.NET" Value="Public Class Project" />
  <TypeSignature Language="C++ CLI" Value="public ref class Project" />
  <TypeSignature Language="F#" Value="type Project = class" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.Build</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("{FullPath} EffectiveToolsVersion={ToolsVersion} #GlobalProperties={data.globalProperties.Count} #Properties={data.Properties.Count} #ItemTypes={data.ItemTypes.Count} #ItemDefinitions={data.ItemDefinitions.Count} #Items={data.Items.Count} #Targets={data.Targets.Count}")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt ein Projekt mit Entwurfszeitsemantik dar. Mit dieser Klasse können Projektdateien geladen, Elemente und Eigenschaften bearbeitet und Projekte erstellt werden.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt ein leeres Projekt mit den globalen Eigenschaften der globalen Projektauflistung und der Standardtoolsversion.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Project ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Project();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Erstellt ein leeres Projekt mit den globalen Eigenschaften der globalen Projektauflistung und der Standardtoolsversion.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Projekt wird der globalen projektauflistung hinzugefügt, wenn sie den vollständigen Pfad zur Quellprojektdatei, in der Regel durch Speichern des Projekts, angegeben wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Project (Microsoft.Build.Construction.ProjectRootElement xml);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Build.Construction.ProjectRootElement xml) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.#ctor(Microsoft.Build.Construction.ProjectRootElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (xml As ProjectRootElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Project(Microsoft::Build::Construction::ProjectRootElement ^ xml);" />
      <MemberSignature Language="F#" Value="new Microsoft.Build.Evaluation.Project : Microsoft.Build.Construction.ProjectRootElement -&gt; Microsoft.Build.Evaluation.Project" Usage="new Microsoft.Build.Evaluation.Project xml" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="xml" Type="Microsoft.Build.Construction.ProjectRootElement" />
      </Parameters>
      <Docs>
        <param name="xml">Für die Auswertung zu verwendendes ProjectRootElement.</param>
        <summary>Erstellt ein leeres Projekt und wertet es anhand des angegebenen Projektstamms und der globalen Eigenschaften der globalen Projektauflistung und der Standardtoolsversion aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Projekt wird der globalen projektauflistung hinzugefügt, wenn dieses Projekt oder des angegebenen Projektstamms den vollständigen Pfad zur Quellprojektdatei angegeben wird.  
  
 Löst InvalidProjectFileException aus, wenn die Auswertung fehlschlägt. InvalidOperationException ausgelöst, wenn bereits ein entsprechendes Projekt vorhanden ist, die in der projektauflistung geladen werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Project (Microsoft.Build.Evaluation.ProjectCollection projectCollection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Build.Evaluation.ProjectCollection projectCollection) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.#ctor(Microsoft.Build.Evaluation.ProjectCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Project(Microsoft::Build::Evaluation::ProjectCollection ^ projectCollection);" />
      <MemberSignature Language="F#" Value="new Microsoft.Build.Evaluation.Project : Microsoft.Build.Evaluation.ProjectCollection -&gt; Microsoft.Build.Evaluation.Project" Usage="new Microsoft.Build.Evaluation.Project projectCollection" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="projectCollection" Type="Microsoft.Build.Evaluation.ProjectCollection" />
      </Parameters>
      <Docs>
        <param name="projectCollection">Die Projektauflistung, der das neue Projekt hinzugefügt wird.</param>
        <summary>Erstellt ein leeres Projekt mit den globalen Eigenschaften der angegebenen Projektauflistung und der Standardtoolsversion.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Projekt wird mit der angegebenen projektauflistung hinzugefügt, wenn sie den vollständigen Pfad zur Quellprojektdatei, in der Regel durch Speichern des Projekts, angegeben wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Project (string projectFile);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string projectFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (projectFile As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Project(System::String ^ projectFile);" />
      <MemberSignature Language="F#" Value="new Microsoft.Build.Evaluation.Project : string -&gt; Microsoft.Build.Evaluation.Project" Usage="new Microsoft.Build.Evaluation.Project projectFile" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="projectFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="projectFile">Die Quellprojektdatei, die ausgewertet werden soll.</param>
        <summary>Erstellt ein Projekt und wertet es anhand der angegebenen Quellprojektdatei und mit den globalen Eigenschaften der globalen Projektauflistung und der Standardtoolsversion aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Projekt wird der globalen projektauflistung hinzugefügt.  
  
 Löst eine InvalidOperationException, wenn es ist bereits ein Projekt in der projektauflistung, die diese Quelldatei für das Projekt ausgewertet wird. Können e/a-bezogenen Ausnahmen auslösen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:Microsoft.Build.Exceptions.InvalidProjectFileException">Wenn die Evaluierung fehlschlägt.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Project (System.Xml.XmlReader xmlReader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xml.XmlReader xmlReader) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.#ctor(System.Xml.XmlReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Project(System::Xml::XmlReader ^ xmlReader);" />
      <MemberSignature Language="F#" Value="new Microsoft.Build.Evaluation.Project : System.Xml.XmlReader -&gt; Microsoft.Build.Evaluation.Project" Usage="new Microsoft.Build.Evaluation.Project xmlReader" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="xmlReader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="xmlReader">XML-Reader zum Lesen von Projektquellcode.</param>
        <summary>Erstellt ein Projekt und wertet den Quellcode vom angegebenen XML-Reader aus. Der Quellcode wird mit den globalen Eigenschaften der globalen Projektauflistung und der Standardtoolsversion ausgewertet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Projekt wird der globalen projektauflistung hinzugefügt, wenn sie den vollständigen Pfad zur Quellprojektdatei, in der Regel durch Speichern des Projekts, angegeben wird.  
  
 Löst InvalidProjectFileException aus, wenn die Auswertung fehlschlägt. InvalidOperationException ausgelöst, wenn bereits ein entsprechendes Projekt vorhanden ist, die in der projektauflistung geladen werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Project (Microsoft.Build.Construction.ProjectRootElement xml, System.Collections.Generic.IDictionary&lt;string,string&gt; globalProperties, string toolsVersion);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Build.Construction.ProjectRootElement xml, class System.Collections.Generic.IDictionary`2&lt;string, string&gt; globalProperties, string toolsVersion) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.#ctor(Microsoft.Build.Construction.ProjectRootElement,System.Collections.Generic.IDictionary{System.String,System.String},System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (xml As ProjectRootElement, globalProperties As IDictionary(Of String, String), toolsVersion As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Project(Microsoft::Build::Construction::ProjectRootElement ^ xml, System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ globalProperties, System::String ^ toolsVersion);" />
      <MemberSignature Language="F#" Value="new Microsoft.Build.Evaluation.Project : Microsoft.Build.Construction.ProjectRootElement * System.Collections.Generic.IDictionary&lt;string, string&gt; * string -&gt; Microsoft.Build.Evaluation.Project" Usage="new Microsoft.Build.Evaluation.Project (xml, globalProperties, toolsVersion)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="xml" Type="Microsoft.Build.Construction.ProjectRootElement" />
        <Parameter Name="globalProperties" Type="System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;" />
        <Parameter Name="toolsVersion" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="xml">Der Projektstamm, der für die Auswertung verwendet werden soll.</param>
        <param name="globalProperties">Globale Eigenschaften für die Auswertung. Ist möglicherweise NULL, in diesem Fall werden die globalen Eigenschaften der enthaltenden Projektauflistung verwendet.</param>
        <param name="toolsVersion">Toolsversion für die Auswertung. Ist möglicherweise NULL.</param>
        <summary>Erstellt ein leeres Projekt und wertet es anhand des angegebenen Projektstamms und mit den angegebenen globalen Eigenschaften und der angegebenen Toolsversion aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Projekt wird der globalen projektauflistung hinzugefügt, wenn dieses Projekt oder des angegebenen Projektstamms den vollständigen Pfad zur Quellprojektdatei angegeben wird.  
  
 Löst InvalidProjectFileException aus, wenn die Auswertung fehlschlägt. InvalidOperationException ausgelöst, wenn bereits ein entsprechendes Projekt vorhanden ist, die in der projektauflistung geladen werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Project (System.Collections.Generic.IDictionary&lt;string,string&gt; globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IDictionary`2&lt;string, string&gt; globalProperties, string toolsVersion, class Microsoft.Build.Evaluation.ProjectCollection projectCollection) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.#ctor(System.Collections.Generic.IDictionary{System.String,System.String},System.String,Microsoft.Build.Evaluation.ProjectCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Project(System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ globalProperties, System::String ^ toolsVersion, Microsoft::Build::Evaluation::ProjectCollection ^ projectCollection);" />
      <MemberSignature Language="F#" Value="new Microsoft.Build.Evaluation.Project : System.Collections.Generic.IDictionary&lt;string, string&gt; * string * Microsoft.Build.Evaluation.ProjectCollection -&gt; Microsoft.Build.Evaluation.Project" Usage="new Microsoft.Build.Evaluation.Project (globalProperties, toolsVersion, projectCollection)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="globalProperties" Type="System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;" />
        <Parameter Name="toolsVersion" Type="System.String" />
        <Parameter Name="projectCollection" Type="Microsoft.Build.Evaluation.ProjectCollection" />
      </Parameters>
      <Docs>
        <param name="globalProperties">Globale Eigenschaften für die Auswertung. Ist möglicherweise NULL, in diesem Fall werden die globalen Eigenschaften der enthaltenden Projektauflistung verwendet.</param>
        <param name="toolsVersion">Die zum Auswerten des Projekts verwendete Toolsversion. Ist möglicherweise NULL.</param>
        <param name="projectCollection">Die Projektauflistung, der das neue Projekt hinzugefügt wird.</param>
        <summary>Erstellt ein leeres Projekt, das mit der angegebenen Projektauflistung, den angegebenen globalen Eigenschaften und der angegebenen Toolsversion ausgewertet werden soll.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Projekt wird mit der angegebenen projektauflistung hinzugefügt, wenn sie den vollständigen Pfad zur Quellprojektdatei, in der Regel durch Speichern des Projekts, angegeben wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Project (string projectFile, System.Collections.Generic.IDictionary&lt;string,string&gt; globalProperties, string toolsVersion);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string projectFile, class System.Collections.Generic.IDictionary`2&lt;string, string&gt; globalProperties, string toolsVersion) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.#ctor(System.String,System.Collections.Generic.IDictionary{System.String,System.String},System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (projectFile As String, globalProperties As IDictionary(Of String, String), toolsVersion As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Project(System::String ^ projectFile, System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ globalProperties, System::String ^ toolsVersion);" />
      <MemberSignature Language="F#" Value="new Microsoft.Build.Evaluation.Project : string * System.Collections.Generic.IDictionary&lt;string, string&gt; * string -&gt; Microsoft.Build.Evaluation.Project" Usage="new Microsoft.Build.Evaluation.Project (projectFile, globalProperties, toolsVersion)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="projectFile" Type="System.String" />
        <Parameter Name="globalProperties" Type="System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;" />
        <Parameter Name="toolsVersion" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="projectFile">Der Pfad zur Quellprojektdatei, die ausgewertet werden soll.</param>
        <param name="globalProperties">Globale Eigenschaften für die Auswertung. Ist möglicherweise NULL, in diesem Fall werden die globalen Eigenschaften der enthaltenden Projektauflistung verwendet.</param>
        <param name="toolsVersion">Toolsversion für die Auswertung. Ist möglicherweise NULL.</param>
        <summary>Erstellt ein Projekt und wertet es anhand der angegebenen Quellprojektdatei und mit den angegebenen globalen Eigenschaften und der angegebenen Toolsversion aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Projekt wird der globalen projektauflistung hinzugefügt.  
  
 Löst InvalidProjectFileException aus, wenn die Auswertung fehlschlägt. InvalidOperationException ausgelöst, wenn bereits ein entsprechendes Projekt vorhanden ist, die in der projektauflistung geladen werden. Können e/a-bezogenen Ausnahmen auslösen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Project (System.Xml.XmlReader xmlReader, System.Collections.Generic.IDictionary&lt;string,string&gt; globalProperties, string toolsVersion);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xml.XmlReader xmlReader, class System.Collections.Generic.IDictionary`2&lt;string, string&gt; globalProperties, string toolsVersion) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.#ctor(System.Xml.XmlReader,System.Collections.Generic.IDictionary{System.String,System.String},System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Project(System::Xml::XmlReader ^ xmlReader, System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ globalProperties, System::String ^ toolsVersion);" />
      <MemberSignature Language="F#" Value="new Microsoft.Build.Evaluation.Project : System.Xml.XmlReader * System.Collections.Generic.IDictionary&lt;string, string&gt; * string -&gt; Microsoft.Build.Evaluation.Project" Usage="new Microsoft.Build.Evaluation.Project (xmlReader, globalProperties, toolsVersion)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="xmlReader" Type="System.Xml.XmlReader" />
        <Parameter Name="globalProperties" Type="System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;" />
        <Parameter Name="toolsVersion" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="xmlReader">XML-Reader zum Lesen von Projektquellcode.</param>
        <param name="globalProperties">Globale Eigenschaften für die Auswertung. Ist möglicherweise NULL, in diesem Fall werden die globalen Eigenschaften der enthaltenden Projektauflistung verwendet.</param>
        <param name="toolsVersion">Toolsversion für die Auswertung. Ist möglicherweise NULL.</param>
        <summary>Erstellt ein Projekt und wertet den Quellcode vom angegebenen XML-Reader aus. Der Quellcode wird mit den angegebenen globalen Eigenschaften und der angegebenen Toolsversion ausgewertet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Projekt wird der globalen projektauflistung hinzugefügt, wenn sie den vollständigen Pfad zur Quellprojektdatei, in der Regel durch Speichern des Projekts, angegeben wird.  
  
 Löst InvalidProjectFileException aus, wenn die Auswertung fehlschlägt. InvalidOperationException ausgelöst, wenn bereits ein entsprechendes Projekt vorhanden ist, die in der projektauflistung geladen werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Project (Microsoft.Build.Construction.ProjectRootElement xml, System.Collections.Generic.IDictionary&lt;string,string&gt; globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Build.Construction.ProjectRootElement xml, class System.Collections.Generic.IDictionary`2&lt;string, string&gt; globalProperties, string toolsVersion, class Microsoft.Build.Evaluation.ProjectCollection projectCollection) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.#ctor(Microsoft.Build.Construction.ProjectRootElement,System.Collections.Generic.IDictionary{System.String,System.String},System.String,Microsoft.Build.Evaluation.ProjectCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Project(Microsoft::Build::Construction::ProjectRootElement ^ xml, System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ globalProperties, System::String ^ toolsVersion, Microsoft::Build::Evaluation::ProjectCollection ^ projectCollection);" />
      <MemberSignature Language="F#" Value="new Microsoft.Build.Evaluation.Project : Microsoft.Build.Construction.ProjectRootElement * System.Collections.Generic.IDictionary&lt;string, string&gt; * string * Microsoft.Build.Evaluation.ProjectCollection -&gt; Microsoft.Build.Evaluation.Project" Usage="new Microsoft.Build.Evaluation.Project (xml, globalProperties, toolsVersion, projectCollection)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="xml" Type="Microsoft.Build.Construction.ProjectRootElement" />
        <Parameter Name="globalProperties" Type="System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;" />
        <Parameter Name="toolsVersion" Type="System.String" />
        <Parameter Name="projectCollection" Type="Microsoft.Build.Evaluation.ProjectCollection" />
      </Parameters>
      <Docs>
        <param name="xml">Der Projektstamm, der für die Auswertung verwendet werden soll.</param>
        <param name="globalProperties">Globale Eigenschaften für die Auswertung. Ist möglicherweise NULL, in diesem Fall werden die globalen Eigenschaften der enthaltenden Projektauflistung verwendet.</param>
        <param name="toolsVersion">Toolsversion für die Auswertung. Ist möglicherweise NULL.</param>
        <param name="projectCollection">Die Projektauflistung, der das Projekt hinzugefügt wird.</param>
        <summary>Erstellt ein Projekt und wertet es anhand des angegebenen Projektstamms und mit den angegebenen globalen Eigenschaften und der angegebenen Toolsversion aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Projekt wird mit der angegebenen projektauflistung hinzugefügt, wenn dieses Projekt oder des angegebenen Projektstamms den vollständigen Pfad zur Quellprojektdatei angegeben wird.  
  
 Löst InvalidProjectFileException aus, wenn die Auswertung fehlschlägt. InvalidOperationException ausgelöst, wenn bereits ein entsprechendes Projekt vorhanden ist, die in der projektauflistung geladen werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Project (string projectFile, System.Collections.Generic.IDictionary&lt;string,string&gt; globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string projectFile, class System.Collections.Generic.IDictionary`2&lt;string, string&gt; globalProperties, string toolsVersion, class Microsoft.Build.Evaluation.ProjectCollection projectCollection) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.#ctor(System.String,System.Collections.Generic.IDictionary{System.String,System.String},System.String,Microsoft.Build.Evaluation.ProjectCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Project(System::String ^ projectFile, System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ globalProperties, System::String ^ toolsVersion, Microsoft::Build::Evaluation::ProjectCollection ^ projectCollection);" />
      <MemberSignature Language="F#" Value="new Microsoft.Build.Evaluation.Project : string * System.Collections.Generic.IDictionary&lt;string, string&gt; * string * Microsoft.Build.Evaluation.ProjectCollection -&gt; Microsoft.Build.Evaluation.Project" Usage="new Microsoft.Build.Evaluation.Project (projectFile, globalProperties, toolsVersion, projectCollection)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="projectFile" Type="System.String" />
        <Parameter Name="globalProperties" Type="System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;" />
        <Parameter Name="toolsVersion" Type="System.String" />
        <Parameter Name="projectCollection" Type="Microsoft.Build.Evaluation.ProjectCollection" />
      </Parameters>
      <Docs>
        <param name="projectFile">Der Pfad zur Quellprojektdatei, die ausgewertet werden soll.</param>
        <param name="globalProperties">Die globalen Eigenschaften. Ist möglicherweise NULL.</param>
        <param name="toolsVersion">Die Toolsversion. Ist möglicherweise NULL.</param>
        <param name="projectCollection">Die Projektauflistung, der das Projekt hinzugefügt wird. Darf nicht NULL sein.</param>
        <summary>Erstellt ein Projekt und wertet es anhand der angegebenen Quellprojektdatei und mit den angegebenen globalen Eigenschaften und der angegebenen Toolsversion aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Projekt wird mit der angegebenen projektauflistung hinzugefügt.  
  
 Löst InvalidProjectFileException aus, wenn die Auswertung fehlschlägt. InvalidOperationException ausgelöst, wenn bereits ein entsprechendes Projekt vorhanden ist, die in der projektauflistung geladen werden. Können e/a-bezogenen Ausnahmen auslösen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Project (System.Xml.XmlReader xmlReader, System.Collections.Generic.IDictionary&lt;string,string&gt; globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xml.XmlReader xmlReader, class System.Collections.Generic.IDictionary`2&lt;string, string&gt; globalProperties, string toolsVersion, class Microsoft.Build.Evaluation.ProjectCollection projectCollection) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.#ctor(System.Xml.XmlReader,System.Collections.Generic.IDictionary{System.String,System.String},System.String,Microsoft.Build.Evaluation.ProjectCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Project(System::Xml::XmlReader ^ xmlReader, System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ globalProperties, System::String ^ toolsVersion, Microsoft::Build::Evaluation::ProjectCollection ^ projectCollection);" />
      <MemberSignature Language="F#" Value="new Microsoft.Build.Evaluation.Project : System.Xml.XmlReader * System.Collections.Generic.IDictionary&lt;string, string&gt; * string * Microsoft.Build.Evaluation.ProjectCollection -&gt; Microsoft.Build.Evaluation.Project" Usage="new Microsoft.Build.Evaluation.Project (xmlReader, globalProperties, toolsVersion, projectCollection)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="xmlReader" Type="System.Xml.XmlReader" />
        <Parameter Name="globalProperties" Type="System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;" />
        <Parameter Name="toolsVersion" Type="System.String" />
        <Parameter Name="projectCollection" Type="Microsoft.Build.Evaluation.ProjectCollection" />
      </Parameters>
      <Docs>
        <param name="xmlReader">XML-Reader zum Lesen von Projektquellcode.</param>
        <param name="globalProperties">Globale Eigenschaften für die Auswertung. Ist möglicherweise NULL, in diesem Fall werden die globalen Eigenschaften der enthaltenden Projektauflistung verwendet.</param>
        <param name="toolsVersion">Toolsversion für die Auswertung. Ist möglicherweise NULL.</param>
        <param name="projectCollection">Die Projektauflistung, der das Projekt hinzugefügt wird. Darf nicht NULL sein.</param>
        <summary>Erstellt ein Projekt und wertet den Quellcode vom angegebenen XML-Reader aus. Der Quellcode wird mit den angegebenen globalen Eigenschaften und der angegebenen Toolsversion ausgewertet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Projekt wird mit der angegebenen projektauflistung hinzugefügt, wenn dieses Projekt oder des angegebenen Projektstamms den vollständigen Pfad zur Quellprojektdatei angegeben wird.  
  
 Löst InvalidProjectFileException aus, wenn die Auswertung fehlschlägt. InvalidOperationException ausgelöst, wenn bereits ein entsprechendes Projekt vorhanden ist, die in der projektauflistung geladen werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Project (Microsoft.Build.Construction.ProjectRootElement xml, System.Collections.Generic.IDictionary&lt;string,string&gt; globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Build.Construction.ProjectRootElement xml, class System.Collections.Generic.IDictionary`2&lt;string, string&gt; globalProperties, string toolsVersion, class Microsoft.Build.Evaluation.ProjectCollection projectCollection, valuetype Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.#ctor(Microsoft.Build.Construction.ProjectRootElement,System.Collections.Generic.IDictionary{System.String,System.String},System.String,Microsoft.Build.Evaluation.ProjectCollection,Microsoft.Build.Evaluation.ProjectLoadSettings)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Project(Microsoft::Build::Construction::ProjectRootElement ^ xml, System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ globalProperties, System::String ^ toolsVersion, Microsoft::Build::Evaluation::ProjectCollection ^ projectCollection, Microsoft::Build::Evaluation::ProjectLoadSettings loadSettings);" />
      <MemberSignature Language="F#" Value="new Microsoft.Build.Evaluation.Project : Microsoft.Build.Construction.ProjectRootElement * System.Collections.Generic.IDictionary&lt;string, string&gt; * string * Microsoft.Build.Evaluation.ProjectCollection * Microsoft.Build.Evaluation.ProjectLoadSettings -&gt; Microsoft.Build.Evaluation.Project" Usage="new Microsoft.Build.Evaluation.Project (xml, globalProperties, toolsVersion, projectCollection, loadSettings)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="xml" Type="Microsoft.Build.Construction.ProjectRootElement" />
        <Parameter Name="globalProperties" Type="System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;" />
        <Parameter Name="toolsVersion" Type="System.String" />
        <Parameter Name="projectCollection" Type="Microsoft.Build.Evaluation.ProjectCollection" />
        <Parameter Name="loadSettings" Type="Microsoft.Build.Evaluation.ProjectLoadSettings" />
      </Parameters>
      <Docs>
        <param name="xml">Der Projektstamm, der für die Auswertung verwendet werden soll.</param>
        <param name="globalProperties">Globale Eigenschaften für die Auswertung. Ist möglicherweise NULL, in diesem Fall werden die globalen Eigenschaften der enthaltenden Projektauflistung verwendet.</param>
        <param name="toolsVersion">Toolsversion für die Auswertung. Ist möglicherweise NULL.</param>
        <param name="projectCollection">Die Projektauflistung, der das Projekt hinzugefügt wird. Darf nicht NULL sein.</param>
        <param name="loadSettings">Die für die Auswertung zu verwendenden Einstellungen für das Laden.</param>
        <summary>Erstellt ein Projekt und wertet es anhand des angegebenen Projektstamms und mit den angegebenen globalen Eigenschaften, der angegebenen Toolsversion und den angegebenen Einstellungen für das Laden aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Projekt wird mit der angegebenen projektauflistung hinzugefügt, wenn dieses Projekt oder des angegebenen Projektstamms den vollständigen Pfad zur Quellprojektdatei angegeben wird.  
  
 Löst InvalidProjectFileException aus, wenn die Auswertung fehlschlägt. InvalidOperationException ausgelöst, wenn bereits ein entsprechendes Projekt vorhanden ist, die in der projektauflistung geladen werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Project (string projectFile, System.Collections.Generic.IDictionary&lt;string,string&gt; globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string projectFile, class System.Collections.Generic.IDictionary`2&lt;string, string&gt; globalProperties, string toolsVersion, class Microsoft.Build.Evaluation.ProjectCollection projectCollection, valuetype Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.#ctor(System.String,System.Collections.Generic.IDictionary{System.String,System.String},System.String,Microsoft.Build.Evaluation.ProjectCollection,Microsoft.Build.Evaluation.ProjectLoadSettings)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Project(System::String ^ projectFile, System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ globalProperties, System::String ^ toolsVersion, Microsoft::Build::Evaluation::ProjectCollection ^ projectCollection, Microsoft::Build::Evaluation::ProjectLoadSettings loadSettings);" />
      <MemberSignature Language="F#" Value="new Microsoft.Build.Evaluation.Project : string * System.Collections.Generic.IDictionary&lt;string, string&gt; * string * Microsoft.Build.Evaluation.ProjectCollection * Microsoft.Build.Evaluation.ProjectLoadSettings -&gt; Microsoft.Build.Evaluation.Project" Usage="new Microsoft.Build.Evaluation.Project (projectFile, globalProperties, toolsVersion, projectCollection, loadSettings)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="projectFile" Type="System.String" />
        <Parameter Name="globalProperties" Type="System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;" />
        <Parameter Name="toolsVersion" Type="System.String" />
        <Parameter Name="projectCollection" Type="Microsoft.Build.Evaluation.ProjectCollection" />
        <Parameter Name="loadSettings" Type="Microsoft.Build.Evaluation.ProjectLoadSettings" />
      </Parameters>
      <Docs>
        <param name="projectFile">Der Pfad zur Quellprojektdatei, die ausgewertet werden soll.</param>
        <param name="globalProperties">Globale Eigenschaften für die Auswertung. Ist möglicherweise NULL, in diesem Fall werden die globalen Eigenschaften der enthaltenden Projektauflistung verwendet.</param>
        <param name="toolsVersion">Die Toolsversion. Ist möglicherweise NULL.</param>
        <param name="projectCollection">Die Projektauflistung, der das Projekt hinzugefügt wird. Darf nicht NULL sein.</param>
        <param name="loadSettings">Die für die Auswertung zu verwendenden Einstellungen für das Laden.</param>
        <summary>Erstellt ein Projekt und wertet es anhand der angegebenen Quellprojektdatei und mit den angegebenen globalen Eigenschaften, der angegebenen Toolsversion und den angegebenen Einstellungen für das Laden aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Projekt wird mit der angegebenen projektauflistung hinzugefügt.  
  
 Löst InvalidProjectFileException aus, wenn die Auswertung fehlschlägt. InvalidOperationException ausgelöst, wenn bereits ein entsprechendes Projekt vorhanden ist, die in der projektauflistung geladen werden. Können e/a-bezogenen Ausnahmen auslösen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Project (System.Xml.XmlReader xmlReader, System.Collections.Generic.IDictionary&lt;string,string&gt; globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xml.XmlReader xmlReader, class System.Collections.Generic.IDictionary`2&lt;string, string&gt; globalProperties, string toolsVersion, class Microsoft.Build.Evaluation.ProjectCollection projectCollection, valuetype Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.#ctor(System.Xml.XmlReader,System.Collections.Generic.IDictionary{System.String,System.String},System.String,Microsoft.Build.Evaluation.ProjectCollection,Microsoft.Build.Evaluation.ProjectLoadSettings)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Project(System::Xml::XmlReader ^ xmlReader, System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ globalProperties, System::String ^ toolsVersion, Microsoft::Build::Evaluation::ProjectCollection ^ projectCollection, Microsoft::Build::Evaluation::ProjectLoadSettings loadSettings);" />
      <MemberSignature Language="F#" Value="new Microsoft.Build.Evaluation.Project : System.Xml.XmlReader * System.Collections.Generic.IDictionary&lt;string, string&gt; * string * Microsoft.Build.Evaluation.ProjectCollection * Microsoft.Build.Evaluation.ProjectLoadSettings -&gt; Microsoft.Build.Evaluation.Project" Usage="new Microsoft.Build.Evaluation.Project (xmlReader, globalProperties, toolsVersion, projectCollection, loadSettings)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="xmlReader" Type="System.Xml.XmlReader" />
        <Parameter Name="globalProperties" Type="System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;" />
        <Parameter Name="toolsVersion" Type="System.String" />
        <Parameter Name="projectCollection" Type="Microsoft.Build.Evaluation.ProjectCollection" />
        <Parameter Name="loadSettings" Type="Microsoft.Build.Evaluation.ProjectLoadSettings" />
      </Parameters>
      <Docs>
        <param name="xmlReader">XML-Reader zum Lesen von Projektquellcode.</param>
        <param name="globalProperties">Globale Eigenschaften für die Auswertung. Ist möglicherweise NULL, in diesem Fall werden die globalen Eigenschaften der enthaltenden Projektauflistung verwendet.</param>
        <param name="toolsVersion">Toolsversion für die Auswertung. Ist möglicherweise NULL.</param>
        <param name="projectCollection">Die Projektauflistung, der das Projekt hinzugefügt wird. Darf nicht NULL sein.</param>
        <param name="loadSettings">Die für die Auswertung zu verwendenden Einstellungen für das Laden.</param>
        <summary>Erstellt ein Projekt und wertet den Quellcode vom angegebenen XML-Reader aus. Der Quellcode wird mit den angegebenen globalen Eigenschaften und der angegebenen Toolsversion ausgewertet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Projekt wird mit der angegebenen projektauflistung hinzugefügt, wenn dieses Projekt oder des angegebenen Projektstamms den vollständigen Pfad zur Quellprojektdatei angegeben wird.  
  
 Löst InvalidProjectFileException aus, wenn die Auswertung fehlschlägt. InvalidOperationException ausgelöst, wenn bereits ein entsprechendes Projekt vorhanden ist, die in der projektauflistung geladen werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Project (Microsoft.Build.Construction.ProjectRootElement xml, System.Collections.Generic.IDictionary&lt;string,string&gt; globalProperties, string toolsVersion, string subToolsetVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Build.Construction.ProjectRootElement xml, class System.Collections.Generic.IDictionary`2&lt;string, string&gt; globalProperties, string toolsVersion, string subToolsetVersion, class Microsoft.Build.Evaluation.ProjectCollection projectCollection, valuetype Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.#ctor(Microsoft.Build.Construction.ProjectRootElement,System.Collections.Generic.IDictionary{System.String,System.String},System.String,System.String,Microsoft.Build.Evaluation.ProjectCollection,Microsoft.Build.Evaluation.ProjectLoadSettings)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Project(Microsoft::Build::Construction::ProjectRootElement ^ xml, System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ globalProperties, System::String ^ toolsVersion, System::String ^ subToolsetVersion, Microsoft::Build::Evaluation::ProjectCollection ^ projectCollection, Microsoft::Build::Evaluation::ProjectLoadSettings loadSettings);" />
      <MemberSignature Language="F#" Value="new Microsoft.Build.Evaluation.Project : Microsoft.Build.Construction.ProjectRootElement * System.Collections.Generic.IDictionary&lt;string, string&gt; * string * string * Microsoft.Build.Evaluation.ProjectCollection * Microsoft.Build.Evaluation.ProjectLoadSettings -&gt; Microsoft.Build.Evaluation.Project" Usage="new Microsoft.Build.Evaluation.Project (xml, globalProperties, toolsVersion, subToolsetVersion, projectCollection, loadSettings)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="xml" Type="Microsoft.Build.Construction.ProjectRootElement" />
        <Parameter Name="globalProperties" Type="System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;" />
        <Parameter Name="toolsVersion" Type="System.String" />
        <Parameter Name="subToolsetVersion" Type="System.String" />
        <Parameter Name="projectCollection" Type="Microsoft.Build.Evaluation.ProjectCollection" />
        <Parameter Name="loadSettings" Type="Microsoft.Build.Evaluation.ProjectLoadSettings" />
      </Parameters>
      <Docs>
        <param name="xml">Der Projektstamm, der für die Auswertung verwendet werden soll.</param>
        <param name="globalProperties">Globale Eigenschaften für die Auswertung. Ist möglicherweise NULL, in diesem Fall werden die globalen Eigenschaften der enthaltenden Projektauflistung verwendet.</param>
        <param name="toolsVersion">Toolsversion für die Auswertung. Ist möglicherweise NULL.</param>
        <param name="subToolsetVersion">Sub-Toolsetversion für die Auswertung. Ist möglicherweise NULL.</param>
        <param name="projectCollection">Die Projektauflistung, der das Projekt hinzugefügt wird. Darf nicht NULL sein.</param>
        <param name="loadSettings">Die für die Auswertung zu verwendenden Einstellungen für das Laden.</param>
        <summary>Erstellt ein Projekt und wertet es anhand des angegebenen Projektstamms und mit den angegebenen globalen Eigenschaften, den Tool- und Unter-Toolset-Versionen, der Projektauflistung und den angegebenen Einstellungen für das Laden aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Projekt wird mit der angegebenen projektauflistung hinzugefügt, wenn dieses Projekt oder des angegebenen Projektstamms den vollständigen Pfad zur Quellprojektdatei angegeben wird.  
  
 Löst InvalidProjectFileException aus, wenn die Auswertung fehlschlägt. InvalidOperationException ausgelöst, wenn bereits ein entsprechendes Projekt vorhanden ist, die in der projektauflistung geladen werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Project (string projectFile, System.Collections.Generic.IDictionary&lt;string,string&gt; globalProperties, string toolsVersion, string subToolsetVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string projectFile, class System.Collections.Generic.IDictionary`2&lt;string, string&gt; globalProperties, string toolsVersion, string subToolsetVersion, class Microsoft.Build.Evaluation.ProjectCollection projectCollection, valuetype Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.#ctor(System.String,System.Collections.Generic.IDictionary{System.String,System.String},System.String,System.String,Microsoft.Build.Evaluation.ProjectCollection,Microsoft.Build.Evaluation.ProjectLoadSettings)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Project(System::String ^ projectFile, System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ globalProperties, System::String ^ toolsVersion, System::String ^ subToolsetVersion, Microsoft::Build::Evaluation::ProjectCollection ^ projectCollection, Microsoft::Build::Evaluation::ProjectLoadSettings loadSettings);" />
      <MemberSignature Language="F#" Value="new Microsoft.Build.Evaluation.Project : string * System.Collections.Generic.IDictionary&lt;string, string&gt; * string * string * Microsoft.Build.Evaluation.ProjectCollection * Microsoft.Build.Evaluation.ProjectLoadSettings -&gt; Microsoft.Build.Evaluation.Project" Usage="new Microsoft.Build.Evaluation.Project (projectFile, globalProperties, toolsVersion, subToolsetVersion, projectCollection, loadSettings)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="projectFile" Type="System.String" />
        <Parameter Name="globalProperties" Type="System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;" />
        <Parameter Name="toolsVersion" Type="System.String" />
        <Parameter Name="subToolsetVersion" Type="System.String" />
        <Parameter Name="projectCollection" Type="Microsoft.Build.Evaluation.ProjectCollection" />
        <Parameter Name="loadSettings" Type="Microsoft.Build.Evaluation.ProjectLoadSettings" />
      </Parameters>
      <Docs>
        <param name="projectFile">Der Pfad zur Quellprojektdatei, die ausgewertet werden soll.</param>
        <param name="globalProperties">Globale Eigenschaften für die Auswertung. Ist möglicherweise NULL, in diesem Fall werden die globalen Eigenschaften der enthaltenden Projektauflistung verwendet.</param>
        <param name="toolsVersion">Die Toolsversion. Ist möglicherweise NULL.</param>
        <param name="subToolsetVersion">Die Version des Sub-Toolsets. Ist möglicherweise NULL.</param>
        <param name="projectCollection">Die Projektauflistung, der das Projekt hinzugefügt wird. Darf nicht NULL sein.</param>
        <param name="loadSettings">Die für die Auswertung zu verwendenden Einstellungen für das Laden.</param>
        <summary>Erstellt ein Projekt und wertet es anhand der angegebenen Quellprojektdatei und mit den angegebenen globalen Eigenschaften, den Tool- und Unter-Toolset-Versionen, der Projektauflistung und den angegebenen Einstellungen für das Laden aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Projekt wird mit der angegebenen projektauflistung hinzugefügt.  
  
 Löst InvalidProjectFileException aus, wenn die Auswertung fehlschlägt. InvalidOperationException ausgelöst, wenn bereits ein entsprechendes Projekt vorhanden ist, die in der projektauflistung geladen werden. Können e/a-bezogenen Ausnahmen auslösen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Project (System.Xml.XmlReader xmlReader, System.Collections.Generic.IDictionary&lt;string,string&gt; globalProperties, string toolsVersion, string subToolsetVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xml.XmlReader xmlReader, class System.Collections.Generic.IDictionary`2&lt;string, string&gt; globalProperties, string toolsVersion, string subToolsetVersion, class Microsoft.Build.Evaluation.ProjectCollection projectCollection, valuetype Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.#ctor(System.Xml.XmlReader,System.Collections.Generic.IDictionary{System.String,System.String},System.String,System.String,Microsoft.Build.Evaluation.ProjectCollection,Microsoft.Build.Evaluation.ProjectLoadSettings)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Project(System::Xml::XmlReader ^ xmlReader, System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ globalProperties, System::String ^ toolsVersion, System::String ^ subToolsetVersion, Microsoft::Build::Evaluation::ProjectCollection ^ projectCollection, Microsoft::Build::Evaluation::ProjectLoadSettings loadSettings);" />
      <MemberSignature Language="F#" Value="new Microsoft.Build.Evaluation.Project : System.Xml.XmlReader * System.Collections.Generic.IDictionary&lt;string, string&gt; * string * string * Microsoft.Build.Evaluation.ProjectCollection * Microsoft.Build.Evaluation.ProjectLoadSettings -&gt; Microsoft.Build.Evaluation.Project" Usage="new Microsoft.Build.Evaluation.Project (xmlReader, globalProperties, toolsVersion, subToolsetVersion, projectCollection, loadSettings)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="xmlReader" Type="System.Xml.XmlReader" />
        <Parameter Name="globalProperties" Type="System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;" />
        <Parameter Name="toolsVersion" Type="System.String" />
        <Parameter Name="subToolsetVersion" Type="System.String" />
        <Parameter Name="projectCollection" Type="Microsoft.Build.Evaluation.ProjectCollection" />
        <Parameter Name="loadSettings" Type="Microsoft.Build.Evaluation.ProjectLoadSettings" />
      </Parameters>
      <Docs>
        <param name="xmlReader">XML-Reader zum Lesen von Projektquellcode.</param>
        <param name="globalProperties">Globale Eigenschaften für die Auswertung. Ist möglicherweise NULL, in diesem Fall werden die globalen Eigenschaften der enthaltenden Projektauflistung verwendet.</param>
        <param name="toolsVersion">Toolsversion für die Auswertung. Ist möglicherweise NULL.</param>
        <param name="subToolsetVersion">Sub-Toolsetversion für die Auswertung. Ist möglicherweise NULL.</param>
        <param name="projectCollection">Die Projektauflistung, der das Projekt hinzugefügt wird. Darf nicht NULL sein.</param>
        <param name="loadSettings">Die für die Auswertung zu verwendenden Einstellungen für das Laden.</param>
        <summary>Erstellt ein Projekt und wertet den Quellcode vom angegebenen XML-Reader aus. Der Quellcode wird mit den gegebenen globalen Eigenschaften, Tool- und Unter-Toolset-Versionen, der Projektauflistung und den Ladeeinstellungen ausgewertet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Projekt wird mit der angegebenen projektauflistung hinzugefügt, wenn dieses Projekt oder des angegebenen Projektstamms den vollständigen Pfad zur Quellprojektdatei angegeben wird.  
  
 Löst InvalidProjectFileException aus, wenn die Auswertung fehlschlägt. InvalidOperationException ausgelöst, wenn bereits ein entsprechendes Projekt vorhanden ist, die in der projektauflistung geladen werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddItem">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Fügt ein Element hinzu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddItem">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;Microsoft.Build.Evaluation.ProjectItem&gt; AddItem (string itemType, string unevaluatedInclude);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IList`1&lt;class Microsoft.Build.Evaluation.ProjectItem&gt; AddItem(string itemType, string unevaluatedInclude) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.AddItem(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddItem (itemType As String, unevaluatedInclude As String) As IList(Of ProjectItem)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IList&lt;Microsoft::Build::Evaluation::ProjectItem ^&gt; ^ AddItem(System::String ^ itemType, System::String ^ unevaluatedInclude);" />
      <MemberSignature Language="F#" Value="member this.AddItem : string * string -&gt; System.Collections.Generic.IList&lt;Microsoft.Build.Evaluation.ProjectItem&gt;" Usage="project.AddItem (itemType, unevaluatedInclude)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;Microsoft.Build.Evaluation.ProjectItem&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="itemType" Type="System.String" />
        <Parameter Name="unevaluatedInclude" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="itemType">Der Elementtyp des hinzugefügten Elements.</param>
        <param name="unevaluatedInclude">Include-Attribut des hinzuzufügenden Elements.</param>
        <summary>Fügt dem Projekt ein Element ohne Metadaten hinzu.</summary>
        <returns>Das hinzugefügte Element.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metadaten kann später hinzugefügt werden. Die Quelldateien des Projekts werden nicht geändert werden, wenn bereits ein Platzhalterausdruck das neue Element enthält.  
  
 Auswertung erfolgt auf Grundlage der besten Leistung. Elemente, die die Quelldateien des Projekts befolgen das neue Element definiert sind, können für die Evaluierung verwendet werden. Nur dieses Element wird ausgewertet. Andere Elemente, die davon abhängen, möglicherweise sind nicht betroffen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddItem">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;Microsoft.Build.Evaluation.ProjectItem&gt; AddItem (string itemType, string unevaluatedInclude, System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;string,string&gt;&gt; metadata);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IList`1&lt;class Microsoft.Build.Evaluation.ProjectItem&gt; AddItem(string itemType, string unevaluatedInclude, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, string&gt;&gt; metadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.AddItem(System.String,System.String,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}})" />
      <MemberSignature Language="VB.NET" Value="Public Function AddItem (itemType As String, unevaluatedInclude As String, metadata As IEnumerable(Of KeyValuePair(Of String, String))) As IList(Of ProjectItem)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IList&lt;Microsoft::Build::Evaluation::ProjectItem ^&gt; ^ AddItem(System::String ^ itemType, System::String ^ unevaluatedInclude, System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::String ^&gt;&gt; ^ metadata);" />
      <MemberSignature Language="F#" Value="member this.AddItem : string * string * seq&lt;System.Collections.Generic.KeyValuePair&lt;string, string&gt;&gt; -&gt; System.Collections.Generic.IList&lt;Microsoft.Build.Evaluation.ProjectItem&gt;" Usage="project.AddItem (itemType, unevaluatedInclude, metadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;Microsoft.Build.Evaluation.ProjectItem&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="itemType" Type="System.String" />
        <Parameter Name="unevaluatedInclude" Type="System.String" />
        <Parameter Name="metadata" Type="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.String&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="itemType">Der Elementtyp des hinzugefügten Elements.</param>
        <param name="unevaluatedInclude">Include-Attribut des hinzuzufügenden Elements.</param>
        <param name="metadata">Die Metadaten des hinzugefügten Elements.</param>
        <summary>Fügt dem Projekt ein Element mit den angegebenen Metadaten hinzu.</summary>
        <returns>Das hinzugefügte Element.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Metadaten möglicherweise null und gibt keine Metadaten an.  
  
 Auswertung erfolgt auf Grundlage der besten Leistung. Elemente, die die Quelldateien des Projekts befolgen das neue Element definiert sind, können für die Evaluierung verwendet werden. Nur dieses Element wird ausgewertet. Andere Elemente, die davon abhängen, möglicherweise sind nicht betroffen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddItemFast">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Fügt dem Projekt ein Element ohne Metadaten hinzu.  Ermittelt nicht, ob ein vorhandener Platzhalter bereits mit dem neuen Element übereinstimmt, außer wenn es das erste Element in einer Elementgruppe ist.  Sucht das neue Element nicht in der Nähe ähnlicher Elemente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddItemFast">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;Microsoft.Build.Evaluation.ProjectItem&gt; AddItemFast (string itemType, string unevaluatedInclude);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IList`1&lt;class Microsoft.Build.Evaluation.ProjectItem&gt; AddItemFast(string itemType, string unevaluatedInclude) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.AddItemFast(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddItemFast (itemType As String, unevaluatedInclude As String) As IList(Of ProjectItem)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IList&lt;Microsoft::Build::Evaluation::ProjectItem ^&gt; ^ AddItemFast(System::String ^ itemType, System::String ^ unevaluatedInclude);" />
      <MemberSignature Language="F#" Value="member this.AddItemFast : string * string -&gt; System.Collections.Generic.IList&lt;Microsoft.Build.Evaluation.ProjectItem&gt;" Usage="project.AddItemFast (itemType, unevaluatedInclude)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;Microsoft.Build.Evaluation.ProjectItem&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="itemType" Type="System.String" />
        <Parameter Name="unevaluatedInclude" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="itemType">Der hinzuzufügende Elementtyp.</param>
        <param name="unevaluatedInclude">Das nicht ausgewertete Include-Attribut, das dem Element hinzugefügt werden soll.</param>
        <summary>Fügt dem Projekt ein Element ohne Metadaten hinzu.  Ermittelt nicht, ob ein vorhandener Platzhalter bereits mit dem neuen Element übereinstimmt, außer wenn es das erste Element in einer Elementgruppe ist.  Sucht das neue Element nicht in der Nähe ähnlicher Elemente.</summary>
        <returns>Eine Liste der hinzugefügten Projektelemente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Fügt das Element an die erste Elementgruppe, die eine Bedingung verfügt nicht über und verfügt über keine untergeordneten Elemente oder, deren erste untergeordnete Element ein Element desselben Typs ist, an.  
  
 Best-Effort-Basis ergibt:-mit allen Elementen erweitert. Elemente, die in der XML-Code unter dem neuen Element definiert werden können verwendet werden, auch wenn in einer wirklichen Auswertung nicht werden würde.  
  
 Nur dieses Element wird ausgewertet. Andere Elemente, die davon abhängen, möglicherweise sind nicht betroffen.  
  
 Dies ist eine Annehmlichkeit, dass es verstanden wird werden nicht unbedingt lassen das Projekt in eine vollkommen selbstständigen Zustand bis eine erneute Auswertung.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddItemFast">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;Microsoft.Build.Evaluation.ProjectItem&gt; AddItemFast (string itemType, string unevaluatedInclude, System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;string,string&gt;&gt; metadata);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IList`1&lt;class Microsoft.Build.Evaluation.ProjectItem&gt; AddItemFast(string itemType, string unevaluatedInclude, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, string&gt;&gt; metadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.AddItemFast(System.String,System.String,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}})" />
      <MemberSignature Language="VB.NET" Value="Public Function AddItemFast (itemType As String, unevaluatedInclude As String, metadata As IEnumerable(Of KeyValuePair(Of String, String))) As IList(Of ProjectItem)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IList&lt;Microsoft::Build::Evaluation::ProjectItem ^&gt; ^ AddItemFast(System::String ^ itemType, System::String ^ unevaluatedInclude, System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::String ^&gt;&gt; ^ metadata);" />
      <MemberSignature Language="F#" Value="member this.AddItemFast : string * string * seq&lt;System.Collections.Generic.KeyValuePair&lt;string, string&gt;&gt; -&gt; System.Collections.Generic.IList&lt;Microsoft.Build.Evaluation.ProjectItem&gt;" Usage="project.AddItemFast (itemType, unevaluatedInclude, metadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;Microsoft.Build.Evaluation.ProjectItem&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="itemType" Type="System.String" />
        <Parameter Name="unevaluatedInclude" Type="System.String" />
        <Parameter Name="metadata" Type="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.String&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="itemType">Der hinzuzufügende Elementtyp.</param>
        <param name="unevaluatedInclude">Das nicht ausgewertete Include-Attribut, das dem Element hinzugefügt werden soll.</param>
        <param name="metadata">Die Metadaten, die hinzugefügt werden sollen.</param>
        <summary>Fügt dem Projekt ein Element mit Metadaten hinzu. Metadaten sind möglicherweise NULL und geben keine Metadaten an. Ermittelt nicht, ob ein vorhandener Platzhalter bereits mit dem neuen Element übereinstimmt, außer wenn es das erste Element in einer Elementgruppe ist. Sucht das neue Element nicht in der Nähe ähnlicher Elemente.</summary>
        <returns>Eine Liste der hinzugefügten Projektelemente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Fügt das Element an die erste Elementgruppe, die eine Bedingung verfügt nicht über und verfügt über keine untergeordneten Elemente oder, deren erste untergeordnete Element ein Element desselben Typs ist, an.  
  
 Best-Effort-Basis ergibt:-mit allen Elementen erweitert. Elemente, die in der XML-Code unter dem neuen Element definiert werden können verwendet werden, auch wenn in einer wirklichen Auswertung nicht werden würde.  
  
 Nur dieses Element wird ausgewertet. Andere Elemente, die davon abhängen, möglicherweise ist nicht betroffen.  
  
 Dies ist eine Annehmlichkeit, dass es verstanden wird werden nicht unbedingt lassen das Projekt in eine vollkommen selbstständigen Zustand bis eine erneute Auswertung.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllEvaluatedItemDefinitionMetadata">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectMetadata&gt; AllEvaluatedItemDefinitionMetadata { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;class Microsoft.Build.Evaluation.ProjectMetadata&gt; AllEvaluatedItemDefinitionMetadata" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.AllEvaluatedItemDefinitionMetadata" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AllEvaluatedItemDefinitionMetadata As ICollection(Of ProjectMetadata)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::ICollection&lt;Microsoft::Build::Evaluation::ProjectMetadata ^&gt; ^ AllEvaluatedItemDefinitionMetadata { System::Collections::Generic::ICollection&lt;Microsoft::Build::Evaluation::ProjectMetadata ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AllEvaluatedItemDefinitionMetadata : System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectMetadata&gt;" Usage="Microsoft.Build.Evaluation.Project.AllEvaluatedItemDefinitionMetadata" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectMetadata&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft alle Elementdefinitionsmetadaten ab, die bei der Auswertung gefunden wurden.</summary>
        <value>Alle Elementdefinitionsmetadaten bei der Auswertung gefunden. Dies schließt keine Elemente ein, deren Bedingungen nicht true ergeben haben, und keine seit der letzten Auswertung hinzugefügten Elementdefinitionsmetadaten.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Elementmetadaten werden beim zweiten Auswertungsdurchlauf gelesen. Im Gegensatz zu den Metadaten, die von der ItemDefinitions-Eigenschaft zurückgegeben werden diese Metadaten sortiert ist, und enthält alle Metadaten, die anschließend mit dem gleichen Namen und den Elementtyp überschrieben.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllEvaluatedItems">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectItem&gt; AllEvaluatedItems { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;class Microsoft.Build.Evaluation.ProjectItem&gt; AllEvaluatedItems" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.AllEvaluatedItems" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AllEvaluatedItems As ICollection(Of ProjectItem)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::ICollection&lt;Microsoft::Build::Evaluation::ProjectItem ^&gt; ^ AllEvaluatedItems { System::Collections::Generic::ICollection&lt;Microsoft::Build::Evaluation::ProjectItem ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AllEvaluatedItems : System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectItem&gt;" Usage="Microsoft.Build.Evaluation.Project.AllEvaluatedItems" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectItem&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Enumerator über alle bei der Auswertung gefundenen Elemente ab. Diese werden beim dritten Auswertungsdurchlauf gelesen.</summary>
        <value>Ein Enumerator über alle bei der Auswertung gefundenen Elemente. Diese werden beim dritten Auswertungsdurchlauf gelesen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Im Gegensatz zu diesen Elementen, die von der Items-Eigenschaft zurückgegeben wird werden diese in Bezug auf alle anderen Elemente, die während der Auswertung, nicht nur in Bezug auf die Elemente des gleichen Elementtyps sortiert gefundenen sortiert.  
  
 In einigen Anwendungen können dieser vollständige gegenseitigen Reihenfolge von Bedeutung ist, und solche Hosts, die diese Eigenschaft verwenden.  
  
 Die Enumeration enthält keine Elemente, deren Bedingungen nicht True ergeben haben, und umfasst auch alle seit der letzten Auswertung hinzugefügten Elemente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllEvaluatedProperties">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectProperty&gt; AllEvaluatedProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;class Microsoft.Build.Evaluation.ProjectProperty&gt; AllEvaluatedProperties" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.AllEvaluatedProperties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AllEvaluatedProperties As ICollection(Of ProjectProperty)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::ICollection&lt;Microsoft::Build::Evaluation::ProjectProperty ^&gt; ^ AllEvaluatedProperties { System::Collections::Generic::ICollection&lt;Microsoft::Build::Evaluation::ProjectProperty ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AllEvaluatedProperties : System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectProperty&gt;" Usage="Microsoft.Build.Evaluation.Project.AllEvaluatedProperties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectProperty&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft alle während der Auswertung gefundenen Eigenschaften ab.</summary>
        <value>Alle Eigenschaften, die bei der Auswertung gefunden werden. Dies schließt keine Eigenschaften ein, deren Bedingungen nicht true ergeben haben, und keine seit der letzten Auswertung hinzugefügten Eigenschaften.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaften werden beim ersten Auswertungsdurchlauf gelesen. Im Gegensatz zu Eigenschaften, die durch die Properties-Eigenschaft zurückgegeben werden diese sind sortiert und enthält alle Eigenschaften, die anschließend mit dem gleichen Namen überschrieben.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Build">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt dieses Projekt mit den Standardzielen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Build">
      <MemberSignature Language="C#" Value="public bool Build ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Build() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.Build" />
      <MemberSignature Language="VB.NET" Value="Public Function Build () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Build();" />
      <MemberSignature Language="F#" Value="member this.Build : unit -&gt; bool" Usage="project.Build " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt dieses Projekt mit den Standardzielen.</summary>
        <returns><see langword="true" /> bei Erfolg, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um festzulegen, oder rufen die virtuelle Elemente zu Erstellungszwecken, Klonen Sie eine Projektinstanz explizit, und erstellen Sie, die aus. Diese Methode ändert nicht das Projektobjekt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Build">
      <MemberSignature Language="C#" Value="public bool Build (Microsoft.Build.Framework.ILogger logger);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Build(class Microsoft.Build.Framework.ILogger logger) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.Build(Microsoft.Build.Framework.ILogger)" />
      <MemberSignature Language="VB.NET" Value="Public Function Build (logger As ILogger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Build(Microsoft::Build::Framework::ILogger ^ logger);" />
      <MemberSignature Language="F#" Value="member this.Build : Microsoft.Build.Framework.ILogger -&gt; bool" Usage="project.Build logger" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logger" Type="Microsoft.Build.Framework.ILogger" />
      </Parameters>
      <Docs>
        <param name="logger">Die Protokollierung, die bei der Builderstellung verwendet werden soll.</param>
        <summary>Erstellt dieses Projekt mit den Standardzielen und der angegebenen Protokollierung.</summary>
        <returns><see langword="true" /> bei Erfolg, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um festzulegen, oder rufen die virtuelle Elemente zu Erstellungszwecken, Klonen Sie eine Projektinstanz explizit, und erstellen Sie, die aus. Diese Methode ändert nicht das Projektobjekt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Build">
      <MemberSignature Language="C#" Value="public bool Build (System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Framework.ILogger&gt; loggers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Build(class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.Build.Framework.ILogger&gt; loggers) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.Build(System.Collections.Generic.IEnumerable{Microsoft.Build.Framework.ILogger})" />
      <MemberSignature Language="VB.NET" Value="Public Function Build (loggers As IEnumerable(Of ILogger)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Build(System::Collections::Generic::IEnumerable&lt;Microsoft::Build::Framework::ILogger ^&gt; ^ loggers);" />
      <MemberSignature Language="F#" Value="member this.Build : seq&lt;Microsoft.Build.Framework.ILogger&gt; -&gt; bool" Usage="project.Build loggers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="loggers" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Framework.ILogger&gt;" />
      </Parameters>
      <Docs>
        <param name="loggers">Ein Enumerator über alle Protokollierungen, die bei der Builderstellung verwendet werden sollen.</param>
        <summary>Erstellt dieses Projekt mit den Standardzielen und den angegebenen Protokollierungen.</summary>
        <returns><see langword="true" /> bei Erfolg, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um festzulegen, oder rufen die virtuelle Elemente zu Erstellungszwecken, Klonen Sie eine Projektinstanz explizit, und erstellen Sie, die aus. Diese Methode ändert nicht das Projektobjekt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Build">
      <MemberSignature Language="C#" Value="public bool Build (string target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Build(string target) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.Build(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Build (target As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Build(System::String ^ target);" />
      <MemberSignature Language="F#" Value="member this.Build : string -&gt; bool" Usage="project.Build target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="target">Das zu erstellende Ziel.</param>
        <summary>Erstellt dieses Projekt und erstellt dabei das angegebene Ziel.</summary>
        <returns><see langword="true" /> bei Erfolg, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um festzulegen, oder rufen die virtuelle Elemente zu Erstellungszwecken, Klonen Sie eine Projektinstanz explizit, und erstellen Sie, die aus. Diese Methode ändert nicht das Projektobjekt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Build">
      <MemberSignature Language="C#" Value="public bool Build (string[] targets);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Build(string[] targets) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.Build(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Build (targets As String()) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Build(cli::array &lt;System::String ^&gt; ^ targets);" />
      <MemberSignature Language="F#" Value="member this.Build : string[] -&gt; bool" Usage="project.Build targets" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targets" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="targets">Ein Array von Zielen, das erstellt werden soll.</param>
        <summary>Erstellt dieses Projekt und erstellt dabei die angegebenen Ziele.</summary>
        <returns><see langword="true" /> bei Erfolg, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um festzulegen, oder rufen die virtuelle Elemente zu Erstellungszwecken, Klonen Sie eine Projektinstanz explizit, und erstellen Sie, die aus. Diese Methode ändert nicht das Projektobjekt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Build">
      <MemberSignature Language="C#" Value="public bool Build (System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Framework.ILogger&gt; loggers, System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Logging.ForwardingLoggerRecord&gt; remoteLoggers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Build(class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.Build.Framework.ILogger&gt; loggers, class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.Build.Logging.ForwardingLoggerRecord&gt; remoteLoggers) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.Build(System.Collections.Generic.IEnumerable{Microsoft.Build.Framework.ILogger},System.Collections.Generic.IEnumerable{Microsoft.Build.Logging.ForwardingLoggerRecord})" />
      <MemberSignature Language="VB.NET" Value="Public Function Build (loggers As IEnumerable(Of ILogger), remoteLoggers As IEnumerable(Of ForwardingLoggerRecord)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Build(System::Collections::Generic::IEnumerable&lt;Microsoft::Build::Framework::ILogger ^&gt; ^ loggers, System::Collections::Generic::IEnumerable&lt;Microsoft::Build::Logging::ForwardingLoggerRecord ^&gt; ^ remoteLoggers);" />
      <MemberSignature Language="F#" Value="member this.Build : seq&lt;Microsoft.Build.Framework.ILogger&gt; * seq&lt;Microsoft.Build.Logging.ForwardingLoggerRecord&gt; -&gt; bool" Usage="project.Build (loggers, remoteLoggers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="loggers" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Framework.ILogger&gt;" />
        <Parameter Name="remoteLoggers" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Logging.ForwardingLoggerRecord&gt;" />
      </Parameters>
      <Docs>
        <param name="loggers">Die Protokollierungen, die bei der Builderstellung verwendet werden sollen.</param>
        <param name="remoteLoggers">Die Remoteprotokollierungen, die bei der Builderstellung verwendet werden sollen.</param>
        <summary>Erstellt dieses Projekt mit den Standardzielen sowie den angegebenen Protokollierungen und Remoteprotokollierungen.</summary>
        <returns><see langword="true" /> bei Erfolg, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um festzulegen, oder rufen die virtuelle Elemente zu Erstellungszwecken, Klonen Sie eine Projektinstanz explizit, und erstellen Sie, die aus. Diese Methode ändert nicht das Projektobjekt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Build">
      <MemberSignature Language="C#" Value="public bool Build (string target, System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Framework.ILogger&gt; loggers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Build(string target, class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.Build.Framework.ILogger&gt; loggers) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.Build(System.String,System.Collections.Generic.IEnumerable{Microsoft.Build.Framework.ILogger})" />
      <MemberSignature Language="VB.NET" Value="Public Function Build (target As String, loggers As IEnumerable(Of ILogger)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Build(System::String ^ target, System::Collections::Generic::IEnumerable&lt;Microsoft::Build::Framework::ILogger ^&gt; ^ loggers);" />
      <MemberSignature Language="F#" Value="member this.Build : string * seq&lt;Microsoft.Build.Framework.ILogger&gt; -&gt; bool" Usage="project.Build (target, loggers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.String" />
        <Parameter Name="loggers" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Framework.ILogger&gt;" />
      </Parameters>
      <Docs>
        <param name="target">Das zu erstellende Ziel.</param>
        <param name="loggers">Die Protokollierungen, die bei der Builderstellung verwendet werden sollen.</param>
        <summary>Erstellt dieses Projekt, erstellt dabei das angegebene Ziel und verwendet die angegebenen Protokollierungen.</summary>
        <returns><see langword="true" /> bei Erfolg, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um festzulegen, oder rufen die virtuelle Elemente zu Erstellungszwecken, Klonen Sie eine Projektinstanz explizit, und erstellen Sie, die aus. Diese Methode ändert nicht das Projektobjekt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Build">
      <MemberSignature Language="C#" Value="public bool Build (string[] targets, System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Framework.ILogger&gt; loggers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Build(string[] targets, class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.Build.Framework.ILogger&gt; loggers) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.Build(System.String[],System.Collections.Generic.IEnumerable{Microsoft.Build.Framework.ILogger})" />
      <MemberSignature Language="VB.NET" Value="Public Function Build (targets As String(), loggers As IEnumerable(Of ILogger)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Build(cli::array &lt;System::String ^&gt; ^ targets, System::Collections::Generic::IEnumerable&lt;Microsoft::Build::Framework::ILogger ^&gt; ^ loggers);" />
      <MemberSignature Language="F#" Value="member this.Build : string[] * seq&lt;Microsoft.Build.Framework.ILogger&gt; -&gt; bool" Usage="project.Build (targets, loggers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targets" Type="System.String[]" />
        <Parameter Name="loggers" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Framework.ILogger&gt;" />
      </Parameters>
      <Docs>
        <param name="targets">Die zu erstellenden Ziele.</param>
        <param name="loggers">Die Protokollierungen, die bei der Builderstellung verwendet werden sollen.</param>
        <summary>Erstellt dieses Projekt, erstellt dabei die angegebenen Ziele und verwendet die angegebenen Protokollierungen.</summary>
        <returns><see langword="true" /> bei Erfolg, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um festzulegen, oder rufen die virtuelle Elemente zu Erstellungszwecken, Klonen Sie eine Projektinstanz explizit, und erstellen Sie, die aus. Diese Methode ändert nicht das Projektobjekt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Build">
      <MemberSignature Language="C#" Value="public bool Build (string target, System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Framework.ILogger&gt; loggers, System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Logging.ForwardingLoggerRecord&gt; remoteLoggers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Build(string target, class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.Build.Framework.ILogger&gt; loggers, class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.Build.Logging.ForwardingLoggerRecord&gt; remoteLoggers) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.Build(System.String,System.Collections.Generic.IEnumerable{Microsoft.Build.Framework.ILogger},System.Collections.Generic.IEnumerable{Microsoft.Build.Logging.ForwardingLoggerRecord})" />
      <MemberSignature Language="VB.NET" Value="Public Function Build (target As String, loggers As IEnumerable(Of ILogger), remoteLoggers As IEnumerable(Of ForwardingLoggerRecord)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Build(System::String ^ target, System::Collections::Generic::IEnumerable&lt;Microsoft::Build::Framework::ILogger ^&gt; ^ loggers, System::Collections::Generic::IEnumerable&lt;Microsoft::Build::Logging::ForwardingLoggerRecord ^&gt; ^ remoteLoggers);" />
      <MemberSignature Language="F#" Value="member this.Build : string * seq&lt;Microsoft.Build.Framework.ILogger&gt; * seq&lt;Microsoft.Build.Logging.ForwardingLoggerRecord&gt; -&gt; bool" Usage="project.Build (target, loggers, remoteLoggers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.String" />
        <Parameter Name="loggers" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Framework.ILogger&gt;" />
        <Parameter Name="remoteLoggers" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Logging.ForwardingLoggerRecord&gt;" />
      </Parameters>
      <Docs>
        <param name="target">Das zu erstellende Ziel.</param>
        <param name="loggers">Die Protokollierungen, die bei der Builderstellung verwendet werden sollen.</param>
        <param name="remoteLoggers">Die Remoteprotokollierungen, die bei der Builderstellung verwendet werden sollen.</param>
        <summary>Erstellt dieses Projekt, erstellt dabei das angegebene Ziel und verwendet die angegebenen Protokollierungen und Remoteprotokollierungen.</summary>
        <returns><see langword="true" /> bei Erfolg, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um festzulegen, oder rufen die virtuelle Elemente zu Erstellungszwecken, Klonen Sie eine Projektinstanz explizit, und erstellen Sie, die aus. Diese Methode ändert nicht das Projektobjekt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Build">
      <MemberSignature Language="C#" Value="public bool Build (string[] targets, System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Framework.ILogger&gt; loggers, System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Logging.ForwardingLoggerRecord&gt; remoteLoggers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Build(string[] targets, class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.Build.Framework.ILogger&gt; loggers, class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.Build.Logging.ForwardingLoggerRecord&gt; remoteLoggers) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.Build(System.String[],System.Collections.Generic.IEnumerable{Microsoft.Build.Framework.ILogger},System.Collections.Generic.IEnumerable{Microsoft.Build.Logging.ForwardingLoggerRecord})" />
      <MemberSignature Language="VB.NET" Value="Public Function Build (targets As String(), loggers As IEnumerable(Of ILogger), remoteLoggers As IEnumerable(Of ForwardingLoggerRecord)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Build(cli::array &lt;System::String ^&gt; ^ targets, System::Collections::Generic::IEnumerable&lt;Microsoft::Build::Framework::ILogger ^&gt; ^ loggers, System::Collections::Generic::IEnumerable&lt;Microsoft::Build::Logging::ForwardingLoggerRecord ^&gt; ^ remoteLoggers);" />
      <MemberSignature Language="F#" Value="member this.Build : string[] * seq&lt;Microsoft.Build.Framework.ILogger&gt; * seq&lt;Microsoft.Build.Logging.ForwardingLoggerRecord&gt; -&gt; bool" Usage="project.Build (targets, loggers, remoteLoggers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targets" Type="System.String[]" />
        <Parameter Name="loggers" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Framework.ILogger&gt;" />
        <Parameter Name="remoteLoggers" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Logging.ForwardingLoggerRecord&gt;" />
      </Parameters>
      <Docs>
        <param name="targets">Die zu erstellenden Ziele.</param>
        <param name="loggers">Die Protokollierungen, die bei der Builderstellung verwendet werden sollen.</param>
        <param name="remoteLoggers">Die Remoteprotokollierungen, die bei der Builderstellung verwendet werden sollen.</param>
        <summary>Erstellt dieses Projekt, erstellt dabei die angegebene Ziele und verwendet die angegebenen Protokollierungen und Remoteprotokollierungen.</summary>
        <returns><see langword="true" /> bei Erfolg, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um festzulegen, oder rufen die virtuelle Elemente zu Erstellungszwecken, Klonen Sie eine Projektinstanz explizit, und erstellen Sie, die aus. Diese Methode ändert nicht das Projektobjekt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ConditionedProperties">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IDictionary&lt;string,System.Collections.Generic.List&lt;string&gt;&gt; ConditionedProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IDictionary`2&lt;string, class System.Collections.Generic.List`1&lt;string&gt;&gt; ConditionedProperties" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.ConditionedProperties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ConditionedProperties As IDictionary(Of String, List(Of String))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IDictionary&lt;System::String ^, System::Collections::Generic::List&lt;System::String ^&gt; ^&gt; ^ ConditionedProperties { System::Collections::Generic::IDictionary&lt;System::String ^, System::Collections::Generic::List&lt;System::String ^&gt; ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ConditionedProperties : System.Collections.Generic.IDictionary&lt;string, System.Collections.Generic.List&lt;string&gt;&gt;" Usage="Microsoft.Build.Evaluation.Project.ConditionedProperties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.Collections.Generic.List&lt;System.String&gt;&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Auflistung möglicher Eigenschaftswerte für Eigenschaften ab, die zur Auswertung von in Eigenschaften, Eigenschaftengruppen, Importen und whens gefundenen Bedingungen verwendet werden.</summary>
        <value>Eine Auflistung möglicher Eigenschaftswerte für Eigenschaften verwendet, um finden Sie auf Eigenschaften, Eigenschaftengruppen, Importen, Bedingungen auszuwerten und wann die. Die Auflistung erfolgt in kanonischer Form. Der Name des Eintrags ist der Name der auszuwertenden Eigenschaft, und der Wert ist eine Liste möglicher Eigenschaftswerte.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn beispielsweise die folgenden Bedingungen auf Eigenschaften in einem Projekt vorhanden waren: Condition="'$(Configuration)'&#124;$(Plattform)" == "Debuggen&#124;x 86'" Condition="'$(Configuration)'" "Release" == "in der Tabelle wird aufgefüllt werden, {"Konfiguration", {"Debug","Release"}} {"Platform", {"X86"}} diese Auflistung wird vom Visual verwendet Studio, um zu bestimmen, die im Projekt definierten Konfigurationen  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateProjectInstance">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt eine Projektinstanz auf Grundlage dieses Projekts, aber vollständig davon getrennt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kann verwendet werden, um unabhängig zu erstellen. Das ursprüngliche Projekt wird vor dem Erstellen der Instanz ausgewertet, falls erforderlich, damit, dass das ursprüngliche Projekt als markiert ist unverändert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateProjectInstance">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Execution.ProjectInstance CreateProjectInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Build.Execution.ProjectInstance CreateProjectInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.CreateProjectInstance" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateProjectInstance () As ProjectInstance" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Build::Execution::ProjectInstance ^ CreateProjectInstance();" />
      <MemberSignature Language="F#" Value="member this.CreateProjectInstance : unit -&gt; Microsoft.Build.Execution.ProjectInstance" Usage="project.CreateProjectInstance " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Execution.ProjectInstance</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt eine Projektinstanz auf Grundlage dieses Projekts, aber vollständig davon getrennt.</summary>
        <returns>Die Projektinstanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kann verwendet werden, um unabhängig zu erstellen. Das ursprüngliche Projekt wird vor dem Erstellen der Instanz ausgewertet, falls erforderlich, damit, dass das ursprüngliche Projekt als markiert ist unverändert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateProjectInstance">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Execution.ProjectInstance CreateProjectInstance (Microsoft.Build.Execution.ProjectInstanceSettings settings);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Build.Execution.ProjectInstance CreateProjectInstance(valuetype Microsoft.Build.Execution.ProjectInstanceSettings settings) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.CreateProjectInstance(Microsoft.Build.Execution.ProjectInstanceSettings)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateProjectInstance (settings As ProjectInstanceSettings) As ProjectInstance" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Build::Execution::ProjectInstance ^ CreateProjectInstance(Microsoft::Build::Execution::ProjectInstanceSettings settings);" />
      <MemberSignature Language="F#" Value="member this.CreateProjectInstance : Microsoft.Build.Execution.ProjectInstanceSettings -&gt; Microsoft.Build.Execution.ProjectInstance" Usage="project.CreateProjectInstance settings" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Execution.ProjectInstance</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="settings" Type="Microsoft.Build.Execution.ProjectInstanceSettings" />
      </Parameters>
      <Docs>
        <param name="settings">Bestimmt, ob die erstellte Projektinstanz unveränderlich ist und ob sie eine Nachschlagetabelle zur Verbesserung der Leistung enthält.</param>
        <summary>Erstellt eine Projektinstanz auf Grundlage dieses Projekts, aber vollständig davon getrennt.</summary>
        <returns>Die Projektinstanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kann verwendet werden, um unabhängig zu erstellen. Das ursprüngliche Projekt wird vor dem Erstellen der Instanz ausgewertet, falls erforderlich, damit, dass das ursprüngliche Projekt als markiert ist unverändert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DirectoryPath">
      <MemberSignature Language="C#" Value="public string DirectoryPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DirectoryPath" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.DirectoryPath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DirectoryPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DirectoryPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DirectoryPath : string" Usage="Microsoft.Build.Evaluation.Project.DirectoryPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Stammverzeichnis für dieses Projekt ab.</summary>
        <value>Das Stammverzeichnis für dieses Projekt. Das Stammverzeichnis ist nie NULL, Projekte im Speicher verwenden das aktuelle Verzeichnis beim Laden des Projekts.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DisableMarkDirty">
      <MemberSignature Language="C#" Value="public bool DisableMarkDirty { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisableMarkDirty" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.DisableMarkDirty" />
      <MemberSignature Language="VB.NET" Value="Public Property DisableMarkDirty As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DisableMarkDirty { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DisableMarkDirty : bool with get, set" Usage="Microsoft.Build.Evaluation.Project.DisableMarkDirty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob <see cref="M:Microsoft.Build.Evaluation.Project.MarkDirty" /> temporär deaktiviert ist, oder legt diesen fest. Dies ermöglicht z. B. das Festlegen einer globalen Eigenschaft, ohne dass das Projekt für eine erneute Auswertung entsprechend als geändert markiert wird.</summary>
        <value><see langword="true" /> an <see langword="MarkDirty" /> ist vorübergehend deaktiviert ist, andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EvaluationCounter">
      <MemberSignature Language="C#" Value="public int EvaluationCounter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 EvaluationCounter" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.EvaluationCounter" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property EvaluationCounter As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int EvaluationCounter { int get(); };" />
      <MemberSignature Language="F#" Value="member this.EvaluationCounter : int" Usage="Microsoft.Build.Evaluation.Project.EvaluationCounter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Zahl ab, die bei jeder erneuten Auswertung des Projekts inkrementiert wird.</summary>
        <value>Der inkrementierte Wert.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Wert sollte verglichen werden, mit der vorherigen Werte, um festzustellen, ob das Projekt erneut ausgewertet wurde. Es sollte nicht verwendet werden, um zu bestimmen, wie oft das Projekt wurde neu ausgewertet, da es mehr als für einen bestimmten erneute Auswertung um eins erhöht werden kann.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExpandString">
      <MemberSignature Language="C#" Value="public string ExpandString (string unexpandedValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ExpandString(string unexpandedValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.ExpandString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExpandString (unexpandedValue As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ExpandString(System::String ^ unexpandedValue);" />
      <MemberSignature Language="F#" Value="member this.ExpandString : string -&gt; string" Usage="project.ExpandString unexpandedValue" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unexpandedValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="unexpandedValue">Die auszuwertende Zeichenfolge.</param>
        <summary>Wertet die angegebene Zeichenfolge aus, indem Elemente und Eigenschaften erweitert werden. Die Zeichenfolge wird ausgewertet, als ob sie ganz am Ende der Projektdatei gefunden wurde.</summary>
        <returns>Die ausgewertete Zeichenfolge.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann verwendet werden, wenn die Auswertung von Best-Effort-Prinzip ausreichend ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FullPath">
      <MemberSignature Language="C#" Value="public string FullPath { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullPath" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.FullPath" />
      <MemberSignature Language="VB.NET" Value="Public Property FullPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ FullPath { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.FullPath : string with get, set" Usage="Microsoft.Build.Evaluation.Project.FullPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den vollständigen Pfad zur Projektquelldatei ab oder legt ihn fest.</summary>
        <value>Der vollständige Pfad der Projektdatei für die Quelle oder eine leere Zeichenfolge, wenn das Projekt nicht vom Datenträger geladen wurde.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch Festlegen dieser Eigenschaft für ein Projekt in einer Projektsammlung wird das Projekt umbenannt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvaluatedItemIncludeEscaped">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft den ausgewerteten, mit Escapezeichen versehenen Wert des Include-Attributs der bereitgestellten Elemente ab.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvaluatedItemIncludeEscaped">
      <MemberSignature Language="C#" Value="public static string GetEvaluatedItemIncludeEscaped (Microsoft.Build.Evaluation.ProjectItem item);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetEvaluatedItemIncludeEscaped(class Microsoft.Build.Evaluation.ProjectItem item) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.GetEvaluatedItemIncludeEscaped(Microsoft.Build.Evaluation.ProjectItem)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEvaluatedItemIncludeEscaped (item As ProjectItem) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetEvaluatedItemIncludeEscaped(Microsoft::Build::Evaluation::ProjectItem ^ item);" />
      <MemberSignature Language="F#" Value="static member GetEvaluatedItemIncludeEscaped : Microsoft.Build.Evaluation.ProjectItem -&gt; string" Usage="Microsoft.Build.Evaluation.Project.GetEvaluatedItemIncludeEscaped item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="Microsoft.Build.Evaluation.ProjectItem" />
      </Parameters>
      <Docs>
        <param name="item">Das Element, das ausgewertet und mit Escapezeichen versehen werden soll.</param>
        <summary>Ruft den ausgewerteten, mit Escapezeichen versehenen Wert des Include-Attributs der bereitgestellten Elemente ab.</summary>
        <returns>Der ausgewertete, mit Escapezeichen versehene Wert des Include-Attributs der bereitgestellten Elemente.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEvaluatedItemIncludeEscaped">
      <MemberSignature Language="C#" Value="public static string GetEvaluatedItemIncludeEscaped (Microsoft.Build.Evaluation.ProjectItemDefinition item);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetEvaluatedItemIncludeEscaped(class Microsoft.Build.Evaluation.ProjectItemDefinition item) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.GetEvaluatedItemIncludeEscaped(Microsoft.Build.Evaluation.ProjectItemDefinition)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEvaluatedItemIncludeEscaped (item As ProjectItemDefinition) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetEvaluatedItemIncludeEscaped(Microsoft::Build::Evaluation::ProjectItemDefinition ^ item);" />
      <MemberSignature Language="F#" Value="static member GetEvaluatedItemIncludeEscaped : Microsoft.Build.Evaluation.ProjectItemDefinition -&gt; string" Usage="Microsoft.Build.Evaluation.Project.GetEvaluatedItemIncludeEscaped item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="Microsoft.Build.Evaluation.ProjectItemDefinition" />
      </Parameters>
      <Docs>
        <param name="item">Die Elementdefinition, die ausgewertet und mit Escapezeichen versehen werden soll.</param>
        <summary>Ruft den ausgewerteten, mit Escapezeichen versehenen Wert des Include-Attributs der bereitgestellten Elementdefinition ab.</summary>
        <returns>Der Wert des Include-Attributs.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetItems">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectItem&gt; GetItems (string itemType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.ICollection`1&lt;class Microsoft.Build.Evaluation.ProjectItem&gt; GetItems(string itemType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.GetItems(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetItems (itemType As String) As ICollection(Of ProjectItem)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::ICollection&lt;Microsoft::Build::Evaluation::ProjectItem ^&gt; ^ GetItems(System::String ^ itemType);" />
      <MemberSignature Language="F#" Value="member this.GetItems : string -&gt; System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectItem&gt;" Usage="project.GetItems itemType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectItem&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="itemType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="itemType">Der Elementtyp, der abgerufen werden soll.</param>
        <summary>Ruft alle Elemente im Projekt mit dem angegebenen Elementtyp ab. Gibt eine leere Liste zurück, wenn keine Elemente vorhanden sind. Mit AddItem oder RemoveItem können Elemente in diesem Projekt geändert werden.</summary>
        <returns>Alle Elemente im Projekt mit dem angegebenen Elementtyp oder eine leere Liste, wenn keine Elemente mit dem angegebenen Namen vorhanden sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit AddItem oder RemoveItem können Elemente in diesem Projekt geändert werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetItemsByEvaluatedInclude">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectItem&gt; GetItemsByEvaluatedInclude (string evaluatedInclude);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.ICollection`1&lt;class Microsoft.Build.Evaluation.ProjectItem&gt; GetItemsByEvaluatedInclude(string evaluatedInclude) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.GetItemsByEvaluatedInclude(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetItemsByEvaluatedInclude (evaluatedInclude As String) As ICollection(Of ProjectItem)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::ICollection&lt;Microsoft::Build::Evaluation::ProjectItem ^&gt; ^ GetItemsByEvaluatedInclude(System::String ^ evaluatedInclude);" />
      <MemberSignature Language="F#" Value="member this.GetItemsByEvaluatedInclude : string -&gt; System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectItem&gt;" Usage="project.GetItemsByEvaluatedInclude evaluatedInclude" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectItem&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="evaluatedInclude" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="evaluatedInclude">Das ausgewertete Include-Attribut.</param>
        <summary>Ruft alle Elemente mit dem angegebenen ausgewerteten Include-Attribut ab.</summary>
        <returns>Alle Elemente mit dem angegebenen ausgewerteten Include-Attribut.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann beispielsweise alle Elemente zurück, die das ausgewertete Include-Attribut "component.cpp" aufweisen. In der Regel sind NULL oder ein Element zurückgegeben. Allerdings gibt es möglicherweise mehrere Elemente mit den gleichen Pfad und die verschiedenen Elementtypen oder auch mit den gleichen Elementtypen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetItemsIgnoringCondition">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectItem&gt; GetItemsIgnoringCondition (string itemType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.ICollection`1&lt;class Microsoft.Build.Evaluation.ProjectItem&gt; GetItemsIgnoringCondition(string itemType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.GetItemsIgnoringCondition(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetItemsIgnoringCondition (itemType As String) As ICollection(Of ProjectItem)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::ICollection&lt;Microsoft::Build::Evaluation::ProjectItem ^&gt; ^ GetItemsIgnoringCondition(System::String ^ itemType);" />
      <MemberSignature Language="F#" Value="member this.GetItemsIgnoringCondition : string -&gt; System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectItem&gt;" Usage="project.GetItemsIgnoringCondition itemType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectItem&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="itemType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="itemType">Der Elementtyp, der abgerufen werden soll.</param>
        <summary>Ruft alle Elemente im Projekt mit dem angegebenen Typ ab, unabhängig davon, ob ihr Condition-Attribut true ergibt. Dies ist eine schreibgeschützte Liste, mit AddItem oder RemoveItem können Elemente in diesem Projekt geändert werden.</summary>
        <returns>Alle Elemente im Projekt mit dem angegebenen Typ, unabhängig davon, ob ihr Condition-Attribut als „true“ ausgewertet wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist eine schreibgeschützte Liste. Mit AddItem oder RemoveItem können Elemente in diesem Projekt geändert werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLogicalProject">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Construction.ProjectElement&gt; GetLogicalProject ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.Build.Construction.ProjectElement&gt; GetLogicalProject() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.GetLogicalProject" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLogicalProject () As IEnumerable(Of ProjectElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;Microsoft::Build::Construction::ProjectElement ^&gt; ^ GetLogicalProject();" />
      <MemberSignature Language="F#" Value="member this.GetLogicalProject : unit -&gt; seq&lt;Microsoft.Build.Construction.ProjectElement&gt;" Usage="project.GetLogicalProject " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Construction.ProjectElement&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft einen Enumerator über alle Elemente im "logischen Projekt" ab. Das logische Projekt wird definiert als das nicht ausgewertete Projekt, das aus der einzelnen MSBuild-Datei abgerufen wurde, die das Ergebnis des Inlinings des Texts aller Importe der ursprünglichen MSBuild-Projektmanifestdatei ist.</summary>
        <returns>Ein Enumerator über alle Elemente im „logischen Projekt“.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das logische Projekt wird definiert, wie das nicht ausgewertete Projekt, die aus der einzelnen MSBuild-Datei, die das Ergebnis des Inline den Text aller Importe der ursprünglichen MSBuild-Projektmanifestdatei abgerufen haben.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMetadataValueEscaped">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft den Wert mit Escapezeichen des Metadatums mit dem angegebenen Namen im bereitgestellten Element ab.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMetadataValueEscaped">
      <MemberSignature Language="C#" Value="public static string GetMetadataValueEscaped (Microsoft.Build.Evaluation.ProjectMetadata metadatum);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetMetadataValueEscaped(class Microsoft.Build.Evaluation.ProjectMetadata metadatum) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.GetMetadataValueEscaped(Microsoft.Build.Evaluation.ProjectMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMetadataValueEscaped (metadatum As ProjectMetadata) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetMetadataValueEscaped(Microsoft::Build::Evaluation::ProjectMetadata ^ metadatum);" />
      <MemberSignature Language="F#" Value="static member GetMetadataValueEscaped : Microsoft.Build.Evaluation.ProjectMetadata -&gt; string" Usage="Microsoft.Build.Evaluation.Project.GetMetadataValueEscaped metadatum" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadatum" Type="Microsoft.Build.Evaluation.ProjectMetadata" />
      </Parameters>
      <Docs>
        <param name="metadatum">Das Metadatum, das mit Escapezeichen versehen werden soll.</param>
        <summary>Ruft den Wert mit Escapezeichen des bereitgestellten Metadatums ab.</summary>
        <returns>Der Wert mit Escapezeichen des bereitgestellten Metadatums.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMetadataValueEscaped">
      <MemberSignature Language="C#" Value="public static string GetMetadataValueEscaped (Microsoft.Build.Evaluation.ProjectItem item, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetMetadataValueEscaped(class Microsoft.Build.Evaluation.ProjectItem item, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.GetMetadataValueEscaped(Microsoft.Build.Evaluation.ProjectItem,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMetadataValueEscaped (item As ProjectItem, name As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetMetadataValueEscaped(Microsoft::Build::Evaluation::ProjectItem ^ item, System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member GetMetadataValueEscaped : Microsoft.Build.Evaluation.ProjectItem * string -&gt; string" Usage="Microsoft.Build.Evaluation.Project.GetMetadataValueEscaped (item, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="Microsoft.Build.Evaluation.ProjectItem" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="item">Das Element, dessen Metadaten mit Escapezeichen versehen werden sollen.</param>
        <param name="name">Der Name der Metadaten, die mit Escapezeichen versehen werden sollen.</param>
        <summary>Ruft den Wert mit Escapezeichen des Metadatums mit dem angegebenen Namen im bereitgestellten Element ab.</summary>
        <returns>Der Wert mit Escapezeichen des Metadatums mit dem angegebenen Namen im bereitgestellten Element.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMetadataValueEscaped">
      <MemberSignature Language="C#" Value="public static string GetMetadataValueEscaped (Microsoft.Build.Evaluation.ProjectItemDefinition item, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetMetadataValueEscaped(class Microsoft.Build.Evaluation.ProjectItemDefinition item, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.GetMetadataValueEscaped(Microsoft.Build.Evaluation.ProjectItemDefinition,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMetadataValueEscaped (item As ProjectItemDefinition, name As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetMetadataValueEscaped(Microsoft::Build::Evaluation::ProjectItemDefinition ^ item, System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member GetMetadataValueEscaped : Microsoft.Build.Evaluation.ProjectItemDefinition * string -&gt; string" Usage="Microsoft.Build.Evaluation.Project.GetMetadataValueEscaped (item, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="Microsoft.Build.Evaluation.ProjectItemDefinition" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="item">Die Elementdefinition, deren Metadaten mit Escapezeichen versehen werden sollen.</param>
        <param name="name">Der Name der Metadaten, die mit Escapezeichen versehen werden sollen.</param>
        <summary>Ruft den Wert mit Escapezeichen des Metadatums mit dem angegebenen Namen in der bereitgestellten Elementdefinition ab.</summary>
        <returns>Der Wert mit Escapezeichen des Metadatums mit dem angegebenen Namen in der bereitgestellten Elementdefinition.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Evaluation.ProjectProperty GetProperty (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Build.Evaluation.ProjectProperty GetProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.GetProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String) As ProjectProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Build::Evaluation::ProjectProperty ^ GetProperty(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GetProperty : string -&gt; Microsoft.Build.Evaluation.ProjectProperty" Usage="project.GetProperty name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Evaluation.ProjectProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der abzurufenden Eigenschaft.</param>
        <summary>Ruft jede Eigenschaft im Projekt mit dem angegebenen Namen ab.</summary>
        <returns>Jede Eigenschaft im Projekt, die den angegebenen Namen aufweist, oder <see langword="null" />, wenn keine Eigenschaft mit diesem Namen vorhanden ist.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPropertyValue">
      <MemberSignature Language="C#" Value="public string GetPropertyValue (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPropertyValue(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.GetPropertyValue(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPropertyValue (name As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPropertyValue(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GetPropertyValue : string -&gt; string" Usage="project.GetPropertyValue name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der Eigenschaft, deren Wert abgerufen wird.</param>
        <summary>Ruft den Wert der angegebenen Eigenschaft in diesem Projekt ab.</summary>
        <returns>Der Wert der angegebenen Eigenschaft in diesem Projekt oder eine leere Zeichenfolge, wenn keine Eigenschaft mit diesem Namen existiert. Escapesequenzen werden vor dem Zurückgeben der Zeichenfolge umgewandelt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Eigenschaft mit einem Wert von leere Zeichenfolge und keine Eigenschaft überhaupt nicht voneinander unterschieden zwischen von dieser Methode. Um festzustellen, ob eine Eigenschaft alle im Projekt enthalten ist, verwenden Sie GetProperty(name).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPropertyValueEscaped">
      <MemberSignature Language="C#" Value="public static string GetPropertyValueEscaped (Microsoft.Build.Evaluation.ProjectProperty property);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetPropertyValueEscaped(class Microsoft.Build.Evaluation.ProjectProperty property) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.GetPropertyValueEscaped(Microsoft.Build.Evaluation.ProjectProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPropertyValueEscaped (property As ProjectProperty) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetPropertyValueEscaped(Microsoft::Build::Evaluation::ProjectProperty ^ property);" />
      <MemberSignature Language="F#" Value="static member GetPropertyValueEscaped : Microsoft.Build.Evaluation.ProjectProperty -&gt; string" Usage="Microsoft.Build.Evaluation.Project.GetPropertyValueEscaped property" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="Microsoft.Build.Evaluation.ProjectProperty" />
      </Parameters>
      <Docs>
        <param name="property">Die Eigenschaft, die mit Escapezeichen versehen werden soll.</param>
        <summary>Ruft den Wert mit Escapezeichen der bereitgestellten Eigenschaft ab.</summary>
        <returns>Der Wert mit Escapezeichen der bereitgestellten Eigenschaft.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GlobalProperties">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IDictionary&lt;string,string&gt; GlobalProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IDictionary`2&lt;string, string&gt; GlobalProperties" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.GlobalProperties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property GlobalProperties As IDictionary(Of String, String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ GlobalProperties { System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.GlobalProperties : System.Collections.Generic.IDictionary&lt;string, string&gt;" Usage="Microsoft.Build.Evaluation.Project.GlobalProperties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein Wörterbuch der für die Auswertung dieses Projekts verwendeten globalen Eigenschaften ab.</summary>
        <value>Ein Wörterbuch der für die Auswertung dieses Projekts verwendeten globalen Eigenschaften.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist die öffentlich verfügbar gemachte abrufen, die in einem nur-Lese dead IDictionary übersetzt\<Zeichenfolge, Zeichenfolge >.  
  
 Damit Sie leicht erkennen, wenn Fehler auftreten, festlegen und Entfernen von globalen Eigenschaften erfolgt mit <xref:Microsoft.Build.Evaluation.Project.SetGlobalProperty%2A> und <xref:Microsoft.Build.Evaluation.Project.RemoveGlobalProperty%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Imports">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;Microsoft.Build.Evaluation.ResolvedImport&gt; Imports { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;valuetype Microsoft.Build.Evaluation.ResolvedImport&gt; Imports" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.Imports" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Imports As IList(Of ResolvedImport)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;Microsoft::Build::Evaluation::ResolvedImport&gt; ^ Imports { System::Collections::Generic::IList&lt;Microsoft::Build::Evaluation::ResolvedImport&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Imports : System.Collections.Generic.IList&lt;Microsoft.Build.Evaluation.ResolvedImport&gt;" Usage="Microsoft.Build.Evaluation.Project.Imports" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;Microsoft.Build.Evaluation.ResolvedImport&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Liste aller Dateien ab, die in die Auswertung dieses Projekts einbezogen wurden.</summary>
        <value>Eine Liste aller Dateien, die in die Auswertung dieses Projekts beigetragen haben.  
  
Der Name jedes Elements ist das Import-Element, das den Import der Datei verursacht hat. Der Wert jedes Elements ist der Projektstamm des importierten Projekts. Import-Elemente, deren Condition-Attribut false ergeben hat, werden nicht eingeschlossen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Stammverzeichnis des Projekts dieses Projekts ist nicht enthalten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ImportsIncludingDuplicates">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;Microsoft.Build.Evaluation.ResolvedImport&gt; ImportsIncludingDuplicates { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;valuetype Microsoft.Build.Evaluation.ResolvedImport&gt; ImportsIncludingDuplicates" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.ImportsIncludingDuplicates" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ImportsIncludingDuplicates As IList(Of ResolvedImport)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;Microsoft::Build::Evaluation::ResolvedImport&gt; ^ ImportsIncludingDuplicates { System::Collections::Generic::IList&lt;Microsoft::Build::Evaluation::ResolvedImport&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ImportsIncludingDuplicates : System.Collections.Generic.IList&lt;Microsoft.Build.Evaluation.ResolvedImport&gt;" Usage="Microsoft.Build.Evaluation.Project.ImportsIncludingDuplicates" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;Microsoft.Build.Evaluation.ResolvedImport&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Liste doppelter Importe ab, wenn ein Import mehrmals importiert wurde. Allerdings wurde nur der erste Import zur Auswertung verwendet.</summary>
        <value>Eine Liste doppelter Importe.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBuildEnabled">
      <MemberSignature Language="C#" Value="public bool IsBuildEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBuildEnabled" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.IsBuildEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property IsBuildEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBuildEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsBuildEnabled : bool with get, set" Usage="Microsoft.Build.Evaluation.Project.IsBuildEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Eigenschaft ab, die auswählt, ob die Ziele und die Aufgaben dieses Projekts erstellt werden können, oder legt sie fest.</summary>
        <value><see langword="true" /> Wenn die Ziele und Aufgaben dieses Projekts erstellt werden können; andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kann für Sicherheitszwecke verwendet werden. Ein neues Projekt verfügt standardmäßig über die gleiche Einstellung IsBuildEnabled den Wert der übergeordneten Projekts-Auflistung, die sie enthält. IsBuildEnabled den Wert falsch ist, schlägt die Build-Methode in diesem Projekt fehl.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDirty">
      <MemberSignature Language="C#" Value="public bool IsDirty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDirty" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.IsDirty" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDirty As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDirty { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDirty : bool" Usage="Microsoft.Build.Evaluation.Project.IsDirty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob dieses Projekt geändert wurde, sodass es neu ausgewertet werden muss.</summary>
        <value><see langword="true" /> Wenn dieses Projekt geändert wurde, damit es neu ausgewertet werden muss; andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Projekt wird geändert und muss neu ausgewertet werden, wenn die zugrunde liegenden Projektquellcode, einschließlich der Änderungen an Dateien importiert. Ein Projekt wird ebenfalls geändert, müssen neu ausgewertet werden, wenn das Projekt Tool Änderungen festgelegt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ItemDefinitions">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IDictionary&lt;string,Microsoft.Build.Evaluation.ProjectItemDefinition&gt; ItemDefinitions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IDictionary`2&lt;string, class Microsoft.Build.Evaluation.ProjectItemDefinition&gt; ItemDefinitions" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.ItemDefinitions" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ItemDefinitions As IDictionary(Of String, ProjectItemDefinition)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IDictionary&lt;System::String ^, Microsoft::Build::Evaluation::ProjectItemDefinition ^&gt; ^ ItemDefinitions { System::Collections::Generic::IDictionary&lt;System::String ^, Microsoft::Build::Evaluation::ProjectItemDefinition ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ItemDefinitions : System.Collections.Generic.IDictionary&lt;string, Microsoft.Build.Evaluation.ProjectItemDefinition&gt;" Usage="Microsoft.Build.Evaluation.Project.ItemDefinitions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,Microsoft.Build.Evaluation.ProjectItemDefinition&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein Wörterbuch von Elementdefinitionen in diesem Projekt ab, sortiert nach Elementtyp.</summary>
        <value>Ein Wörterbuch von Elementdefinitionen in diesem Projekt, sortiert nach Elementtyp.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Items">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectItem&gt; Items { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;class Microsoft.Build.Evaluation.ProjectItem&gt; Items" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.Items" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Items As ICollection(Of ProjectItem)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::ICollection&lt;Microsoft::Build::Evaluation::ProjectItem ^&gt; ^ Items { System::Collections::Generic::ICollection&lt;Microsoft::Build::Evaluation::ProjectItem ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Items : System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectItem&gt;" Usage="Microsoft.Build.Evaluation.Project.Items" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectItem&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Enumerator über alle Elemente in diesem Projekt ab, geordnet in Gruppen von Elementtypen.</summary>
        <value>Ein Enumerator über alle Elemente in diesem Projekt geordnet in Gruppen von Elementtypen.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ItemsIgnoringCondition">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectItem&gt; ItemsIgnoringCondition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;class Microsoft.Build.Evaluation.ProjectItem&gt; ItemsIgnoringCondition" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.ItemsIgnoringCondition" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ItemsIgnoringCondition As ICollection(Of ProjectItem)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::ICollection&lt;Microsoft::Build::Evaluation::ProjectItem ^&gt; ^ ItemsIgnoringCondition { System::Collections::Generic::ICollection&lt;Microsoft::Build::Evaluation::ProjectItem ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ItemsIgnoringCondition : System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectItem&gt;" Usage="Microsoft.Build.Evaluation.Project.ItemsIgnoringCondition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectItem&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Enumerator über alle Elemente in diesem Projekt ab, geordnet in Gruppen von Elementtypen.</summary>
        <value>Ein Enumerator für alle Elemente in diesem Projekt geordnet in Gruppen von Elementtypen, einschließlich der Elemente, deren Bedingungen zu False ausgewertet wird, oder befinden sich in Elementgruppen, deren Bedingung ergibt <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dient zum Anzeigen aller Elemente, auch wenn sie nicht Teil des Builds in der aktuellen Konfiguration sind.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ItemTypes">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;string&gt; ItemTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;string&gt; ItemTypes" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.ItemTypes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ItemTypes As ICollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::ICollection&lt;System::String ^&gt; ^ ItemTypes { System::Collections::Generic::ICollection&lt;System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ItemTypes : System.Collections.Generic.ICollection&lt;string&gt;" Usage="Microsoft.Build.Evaluation.Project.ItemTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Enumerator über alle Elementtypen in diesem Projekt ab.</summary>
        <value>Ein Enumerator über alle Elementtypen in diesem Projekt. Dies ist eine geordnete Auflistung.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MarkDirty">
      <MemberSignature Language="C#" Value="public void MarkDirty ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MarkDirty() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.MarkDirty" />
      <MemberSignature Language="VB.NET" Value="Public Sub MarkDirty ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MarkDirty();" />
      <MemberSignature Language="F#" Value="member this.MarkDirty : unit -&gt; unit" Usage="project.MarkDirty " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Markiert dieses Projekt als geändert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es ist selten notwendig, diese Methode explizit aufzurufen, da alle Änderungen, die Auswirkungen auf ein Projekt automatisch als geändert markiert.  
  
 In einigen Fällen muss jedoch diese Methode aufgerufen werden. Ein Projekt kann z. B. ein Import-Element sein, eine Datei, deren Bedingung abhängig, die auf einem Datenträger vorhanden ist. Wenn diese Datei zum Zeitpunkt der Auswertung nicht vorhanden, und es wird nach der Auswertung erstellt, und klicken Sie dann das Projekt explizit als geändert markiert werden muss.  
  
 Die <xref:Microsoft.Build.Evaluation.Project.ReevaluateIfNecessary%2A> Methode verwendet diese Eigenschaft, um festzustellen, ob eine Auswertung notwendig ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProjectCollection">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Evaluation.ProjectCollection ProjectCollection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Build.Evaluation.ProjectCollection ProjectCollection" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.ProjectCollection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProjectCollection As ProjectCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Build::Evaluation::ProjectCollection ^ ProjectCollection { Microsoft::Build::Evaluation::ProjectCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProjectCollection : Microsoft.Build.Evaluation.ProjectCollection" Usage="Microsoft.Build.Evaluation.Project.ProjectCollection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Evaluation.ProjectCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Projektauflistung ab, die dieses Projekt enthält.</summary>
        <value>Die projektauflistung, der dieses Projekt enthält, der nie ist <see langword="null" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ProjectFileLocation">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Construction.ElementLocation ProjectFileLocation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Build.Construction.ElementLocation ProjectFileLocation" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.ProjectFileLocation" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProjectFileLocation As ElementLocation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Build::Construction::ElementLocation ^ ProjectFileLocation { Microsoft::Build::Construction::ElementLocation ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProjectFileLocation : Microsoft.Build.Construction.ElementLocation" Usage="Microsoft.Build.Evaluation.Project.ProjectFileLocation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Construction.ElementLocation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Der Speicherort der ursprünglichen Datei selbst, nicht der eines bestimmter Inhalts in der Datei. Wenn der Datei kein Name zugewiesen wurde, ist dies ein leerer Speicherort. Dies ist ein legitimer Fall für das Fehlen eines Speicherorts.</summary>
        <value>Ursprünglichen Datei Speicherort oder eine leere Position, wenn die Datei kein Name zugewiesen wurde.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Properties">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectProperty&gt; Properties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;class Microsoft.Build.Evaluation.ProjectProperty&gt; Properties" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.Properties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Properties As ICollection(Of ProjectProperty)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::ICollection&lt;Microsoft::Build::Evaluation::ProjectProperty ^&gt; ^ Properties { System::Collections::Generic::ICollection&lt;Microsoft::Build::Evaluation::ProjectProperty ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Properties : System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectProperty&gt;" Usage="Microsoft.Build.Evaluation.Project.Properties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectProperty&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Enumerator über alle Eigenschaften in diesem Projekt ab. Dies ist eine ungeordnete Auflistung.</summary>
        <value>Ein Enumerator für alle Eigenschaften in diesem Projekt. Da Eigenschaften entsprechend der Anzeige ausgewertet werden, ist dies eine ungeordnete Auflistung.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReevaluateIfNecessary">
      <MemberSignature Language="C#" Value="public void ReevaluateIfNecessary ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReevaluateIfNecessary() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.ReevaluateIfNecessary" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReevaluateIfNecessary ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReevaluateIfNecessary();" />
      <MemberSignature Language="F#" Value="member this.ReevaluateIfNecessary : unit -&gt; unit" Usage="project.ReevaluateIfNecessary " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wertet das Projekt neu aus, um Änderungen aufzunehmen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Projekt wird neu ausgewertet werden, nur dann, wenn er als geändert markiert ist. Eine erneute Auswertung enthält alle Änderungen, die auf den Quellcode des Projekts.  
  
 Löst InvalidProjectFileException aus, wenn die Auswertung fehlschlägt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveGlobalProperty">
      <MemberSignature Language="C#" Value="public bool RemoveGlobalProperty (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RemoveGlobalProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.RemoveGlobalProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveGlobalProperty (name As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RemoveGlobalProperty(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.RemoveGlobalProperty : string -&gt; bool" Usage="project.RemoveGlobalProperty name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der zu entfernenden globalen Eigenschaft.</param>
        <summary>Entfernt eine globale Eigenschaft und markiert das Projekt als geändert.</summary>
        <returns><see langword="true" />, wenn der Wert der globalen Eigenschaft festgelegt wurde.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveItem">
      <MemberSignature Language="C#" Value="public bool RemoveItem (Microsoft.Build.Evaluation.ProjectItem item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RemoveItem(class Microsoft.Build.Evaluation.ProjectItem item) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.RemoveItem(Microsoft.Build.Evaluation.ProjectItem)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveItem (item As ProjectItem) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RemoveItem(Microsoft::Build::Evaluation::ProjectItem ^ item);" />
      <MemberSignature Language="F#" Value="member this.RemoveItem : Microsoft.Build.Evaluation.ProjectItem -&gt; bool" Usage="project.RemoveItem item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="Microsoft.Build.Evaluation.ProjectItem" />
      </Parameters>
      <Docs>
        <param name="item">Das zu entfernende Element.</param>
        <summary>Entfernt ein Element aus dem Projekt. Das zu entfernende Element muss im Projekt vorhanden sein und darf nicht aus einer importierten Datei stammen.</summary>
        <returns><see langword="true" />, wenn das Element in diesem ausgewerteten Projekt vorhanden ist, andernfalls <see langword="false" />. Normalerweise gibt diese Methode true zurück, da die Methode eine Ausnahme auslöst, wenn das angeforderte Element nicht vorhanden ist. Wenn das Element nur in der ItemsIgnoringCondition-Auflistung vorhanden ist, gibt die Methode jedoch false zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Elementgruppe, die mit dem Element leer ist, wird sie auch entfernt.  
  
 Wenn das Element aus einem Platzhalter oder eine durch Semikolons getrennte Ausdruck stammt, wird der Ausdruck zuerst in mehrere Elemente erweitert.  
  
 Das Projekt wird aktualisiert, aber keine weiteren Auswertung erfolgt, bis eine erneute Auswertung. Z. B. wenn ein Element des Typs "i" wird entfernt, "j" der Auswertung von "@(i)" wird nicht geändert werden, bis eine erneute Auswertung.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveItems">
      <MemberSignature Language="C#" Value="public void RemoveItems (System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Evaluation.ProjectItem&gt; items);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveItems(class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.Build.Evaluation.ProjectItem&gt; items) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.RemoveItems(System.Collections.Generic.IEnumerable{Microsoft.Build.Evaluation.ProjectItem})" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveItems (items As IEnumerable(Of ProjectItem))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveItems(System::Collections::Generic::IEnumerable&lt;Microsoft::Build::Evaluation::ProjectItem ^&gt; ^ items);" />
      <MemberSignature Language="F#" Value="member this.RemoveItems : seq&lt;Microsoft.Build.Evaluation.ProjectItem&gt; -&gt; unit" Usage="project.RemoveItems items" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="items" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Evaluation.ProjectItem&gt;" />
      </Parameters>
      <Docs>
        <param name="items">Die zu entfernenden Elemente.</param>
        <summary>Entfernt alle angegebenen Elemente aus dem Projekt, außer wenn sie aus einem importierten Projekt stammen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein Element aus einem importierten Projekt stammt, ist es einfach übersprungen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveProperty">
      <MemberSignature Language="C#" Value="public bool RemoveProperty (Microsoft.Build.Evaluation.ProjectProperty property);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RemoveProperty(class Microsoft.Build.Evaluation.ProjectProperty property) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.RemoveProperty(Microsoft.Build.Evaluation.ProjectProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveProperty (property As ProjectProperty) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RemoveProperty(Microsoft::Build::Evaluation::ProjectProperty ^ property);" />
      <MemberSignature Language="F#" Value="member this.RemoveProperty : Microsoft.Build.Evaluation.ProjectProperty -&gt; bool" Usage="project.RemoveProperty property" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="Microsoft.Build.Evaluation.ProjectProperty" />
      </Parameters>
      <Docs>
        <param name="property">Die zu entfernende Eigenschaft.</param>
        <summary>Entfernt eine Eigenschaft aus dem Projekt. Die zu entfernende Eigenschaft muss im Projekt vorhanden sein und darf nicht aus einer importierten Datei stammen.</summary>
        <returns><see langword="true" />, wenn die Eigenschaft in diesem ausgewerteten Projekt vorhanden ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Eigenschaftengruppe, die mit der Eigenschaft leer ist, wird sie auch entfernt.  
  
 Das Projekt wird aktualisiert, aber keine weiteren Auswertung erfolgt, bis eine erneute Auswertung. Wenn "p" entfernt wird, wird "Q" der von "$(p)" ausgewertet wird beispielsweise nicht bis zum erneuten bereitstellungsbewertung geändert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Save">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Speichert das Projekt mit der Standardzeichencodierung im Dateisystem, wenn es geändert wurde.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.Save" />
      <MemberSignature Language="VB.NET" Value="Public Sub Save ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save();" />
      <MemberSignature Language="F#" Value="member this.Save : unit -&gt; unit" Usage="project.Save " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Speichert das Projekt mit der Standardzeichencodierung im Dateisystem, wenn es geändert wurde.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.Save(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Save (writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::IO::TextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.Save : System.IO.TextWriter -&gt; unit" Usage="project.Save writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Der TextWriter zum Speichern des Projekts.</param>
        <summary>Speichert das Projekt im bereitgestellten TextWriter, unabhängig davon, ob das Projekt geändert wurde. Verwendet die Zeichencodierung des TextWriters und markiert das Projekt als nicht geändert.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.Save(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Save (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.Save : string -&gt; unit" Usage="project.Save path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der Pfad zum Projektquellcode.</param>
        <summary>Speichert das Projekt mit der Standardzeichencodierung im Dateisystem, wenn es geändert wurde oder wenn der Pfad zum Projektquellcode geändert wird.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.Save(System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="member this.Save : System.Text.Encoding -&gt; unit" Usage="project.Save encoding" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="encoding">Die zum Speichern des Projekts verwendete Zeichencodierung.</param>
        <summary>Speichert das Projekt mit der angegebenen Zeichencodierung im Dateisystem, wenn es geändert wurde.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (string path, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(string path, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.Save(System.String,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::String ^ path, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="member this.Save : string * System.Text.Encoding -&gt; unit" Usage="project.Save (path, encoding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="path">Der Pfad zum Projektquellcode.</param>
        <param name="encoding">Die zum Speichern des Projekts verwendete Zeichencodierung.</param>
        <summary>Speichert das Projekt mit der angegebenen Zeichencodierung im Dateisystem, wenn es geändert wurde oder wenn der Pfad zum Projektquellcode geändert wird.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveLogicalProject">
      <MemberSignature Language="C#" Value="public void SaveLogicalProject (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SaveLogicalProject(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.SaveLogicalProject(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SaveLogicalProject (writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SaveLogicalProject(System::IO::TextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.SaveLogicalProject : System.IO.TextWriter -&gt; unit" Usage="project.SaveLogicalProject writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Der Writer, der die Projektdatei speichert.</param>
        <summary>Speichert eine "logische" oder "vorverarbeitete" Projektdatei, die alle importierten Dateien so einschließt, als würden sie eine einzige Datei bilden.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetGlobalProperty">
      <MemberSignature Language="C#" Value="public bool SetGlobalProperty (string name, string escapedValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SetGlobalProperty(string name, string escapedValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.SetGlobalProperty(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function SetGlobalProperty (name As String, escapedValue As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SetGlobalProperty(System::String ^ name, System::String ^ escapedValue);" />
      <MemberSignature Language="F#" Value="member this.SetGlobalProperty : string * string -&gt; bool" Usage="project.SetGlobalProperty (name, escapedValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="escapedValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der festzulegenden globalen Eigenschaft.</param>
        <param name="escapedValue">Der neue Wert der globalen Eigenschaft.</param>
        <summary>Legt eine globale Eigenschaft fest, nachdem das Projekt ausgewertet wurde. Wenn sich der Wert ändert, wird das Projekt für eine erforderliche Neuauswertung markiert.</summary>
        <returns><see langword="true" />, wenn sich der Wert ändert, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetProperty">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Evaluation.ProjectProperty SetProperty (string name, string unevaluatedValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Build.Evaluation.ProjectProperty SetProperty(string name, string unevaluatedValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.SetProperty(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function SetProperty (name As String, unevaluatedValue As String) As ProjectProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Build::Evaluation::ProjectProperty ^ SetProperty(System::String ^ name, System::String ^ unevaluatedValue);" />
      <MemberSignature Language="F#" Value="member this.SetProperty : string * string -&gt; Microsoft.Build.Evaluation.ProjectProperty" Usage="project.SetProperty (name, unevaluatedValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Evaluation.ProjectProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="unevaluatedValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der festzulegenden Eigenschaft.</param>
        <param name="unevaluatedValue">Der neue nicht ausgewertete Wert der Eigenschaft.</param>
        <summary>Legt eine Eigenschaft mit dem angegebenen Namen und Wert fest oder fügt sie dem Projekt hinzu. Überschreibt den Wert einer Eigenschaft mit dem gleichen Namen, wenn sie nicht aus einer importierten Datei stammt.</summary>
        <returns>Die Eigenschaft.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn keine Eigenschaft mit dem angegebenen Namen vorhanden ist, wird die letzte vorhandene Eigenschaft mit dem angegebenen Namen, die keine Bedingung für sich selbst oder die Eigenschaftengruppe aktualisiert, es sei denn, sie aus einer importierten Datei stammt.  
  
 Andernfalls Fügt eine neue Eigenschaft in der ersten Eigenschaftengruppe ohne Bedingung, erstellen eine Eigenschaftengruppe, die bei Bedarf nach der letzten vorhandenen Eigenschaftengruppe, andere zu Beginn des Projekts ein.  
  
 Auswertung erfolgt auf Grundlage der besten Leistung. Eigenschaften, die die Quelldateien des Projekts befolgen die neue Eigenschaft definiert sind, können für die Evaluierung verwendet werden. Nur für diese Eigenschaft wird ausgewertet. Andere Eigenschaften, die davon abhängen, möglicherweise sind nicht betroffen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SkipEvaluation">
      <MemberSignature Language="C#" Value="public bool SkipEvaluation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SkipEvaluation" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.SkipEvaluation" />
      <MemberSignature Language="VB.NET" Value="Public Property SkipEvaluation As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SkipEvaluation { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SkipEvaluation : bool with get, set" Usage="Microsoft.Build.Evaluation.Project.SkipEvaluation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der bestimmt, ob ReevaluateIfNecessary vorübergehend deaktiviert ist, oder legt ihn fest. Dies ist nützlich, wenn der Host Lese- und Schreibvorgänge für das Projekt erwartet und vorübergehend Richtigkeit zugunsten von Leistung geopfert werden soll.</summary>
        <value>Ein Flag, das bestimmt, ob ReevaluateIfNecessary vorübergehend deaktiviert ist.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SubToolsetVersion">
      <MemberSignature Language="C#" Value="public string SubToolsetVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SubToolsetVersion" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.SubToolsetVersion" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SubToolsetVersion As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ SubToolsetVersion { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SubToolsetVersion : string" Usage="Microsoft.Build.Evaluation.Project.SubToolsetVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Wert des SubToolsetVersion-Attributs ab, sofern vorhanden. Dieser Wert wurde mit dem Wert des ToolsVersion-Attributs kombiniert, um die Toolseteigenschaften für dieses Projekt zu bestimmen.</summary>
        <value>Der Wert des SubToolsetVersion-Attributs, oder eine leere Zeichenfolge, wenn das Attribut nicht vorhanden ist.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Targets">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IDictionary&lt;string,Microsoft.Build.Execution.ProjectTargetInstance&gt; Targets { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IDictionary`2&lt;string, class Microsoft.Build.Execution.ProjectTargetInstance&gt; Targets" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.Targets" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Targets As IDictionary(Of String, ProjectTargetInstance)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IDictionary&lt;System::String ^, Microsoft::Build::Execution::ProjectTargetInstance ^&gt; ^ Targets { System::Collections::Generic::IDictionary&lt;System::String ^, Microsoft::Build::Execution::ProjectTargetInstance ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Targets : System.Collections.Generic.IDictionary&lt;string, Microsoft.Build.Execution.ProjectTargetInstance&gt;" Usage="Microsoft.Build.Evaluation.Project.Targets" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,Microsoft.Build.Execution.ProjectTargetInstance&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein Wörterbuch aller Ziele in diesem Projekt ab, sortiert nach Zielnamen.</summary>
        <value>Ein schreibgeschütztes Wörterbuch aller Ziele in diesem Projekt, sortiert nach Zielnamen. Überschriebene Ziele sind in dieser Auflistung nicht enthalten.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolsVersion">
      <MemberSignature Language="C#" Value="public string ToolsVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ToolsVersion" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.ToolsVersion" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ToolsVersion As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ToolsVersion { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ToolsVersion : string" Usage="Microsoft.Build.Evaluation.Project.ToolsVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Toolsversion ab, mit der dieses Projekt ausgewertet wurde, falls vorhanden.</summary>
        <value>Die ToolsVersion, der dieses Projekt ausgewertet wurde, sofern vorhanden.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch den Konstruktor festgelegt. Dies ist nicht unbedingt identisch mit dem Tools-Version auf der projektregisterkarte, sofern vorhanden; Es wurden möglicherweise extern angegeben, z. B. mit einem/TV-Switch in der Befehlszeile. Die tatsächlichen Tools-Version auf der projektregisterkarte erhalten <xref:Microsoft.Build.Evaluation.Project.Xml%2A>. Die Tools-Version kann nicht geändert werden, nachdem das Projekt erstellt wurde.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Xml">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Construction.ProjectRootElement Xml { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Build.Construction.ProjectRootElement Xml" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.Xml" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Xml As ProjectRootElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Build::Construction::ProjectRootElement ^ Xml { Microsoft::Build::Construction::ProjectRootElement ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Xml : Microsoft.Build.Construction.ProjectRootElement" Usage="Microsoft.Build.Evaluation.Project.Xml" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Construction.ProjectRootElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das diesem Projekt zugeordnete Stammprojekt ab. Kann nie <see langword="null" /> sein.</summary>
        <value>Dieses Projekts, das nie möglich zugeordnete Stammprojekt <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es gibt keine Möglichkeit zum Festlegen dieser Eigenschaft. Wenn Sie einen neuen Projektstamm verfügen, bewerten Sie es in ein neues Projekt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>