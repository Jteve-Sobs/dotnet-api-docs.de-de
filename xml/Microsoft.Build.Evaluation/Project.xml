<Type Name="Project" FullName="Microsoft.Build.Evaluation.Project">
  <Metadata><Meta Name="ms.openlocfilehash" Value="4a0d9d219cc38b93512fc7bf4d50bf7eea7390ec" /><Meta Name="ms.sourcegitcommit" Value="b53d35b4a410c949742abd4c6a989d1af5357bca" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="07/21/2020" /><Meta Name="ms.locfileid" Value="86855277" /></Metadata><TypeSignature Language="C#" Value="public class Project" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Project extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.Build.Evaluation.Project" />
  <TypeSignature Language="VB.NET" Value="Public Class Project" />
  <TypeSignature Language="C++ CLI" Value="public ref class Project" />
  <TypeSignature Language="F#" Value="type Project = class" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.Build</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>15.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore">
      <AttributeName Language="C#">[System.Diagnostics.DebuggerDisplay("{FullPath} EffectiveToolsVersion={ToolsVersion} #GlobalProperties={_data.GlobalPropertiesDictionary.Count} #Properties={_data.Properties.Count} #ItemTypes={_data.ItemTypes.Count} #ItemDefinitions={_data.ItemDefinitions.Count} #Items={_data.Items.Count} #Targets={_data.Targets.Count}")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerDisplay("{FullPath} EffectiveToolsVersion={ToolsVersion} #GlobalProperties={_data.GlobalPropertiesDictionary.Count} #Properties={_data.Properties.Count} #ItemTypes={_data.ItemTypes.Count} #ItemDefinitions={_data.ItemDefinitions.Count} #Items={_data.Items.Count} #Targets={_data.Targets.Count}")&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName Language="C#">[System.Diagnostics.DebuggerDisplay("{FullPath} EffectiveToolsVersion={ToolsVersion} #GlobalProperties={data.globalProperties.Count} #Properties={data.Properties.Count} #ItemTypes={data.ItemTypes.Count} #ItemDefinitions={data.ItemDefinitions.Count} #Items={data.Items.Count} #Targets={data.Targets.Count}")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerDisplay("{FullPath} EffectiveToolsVersion={ToolsVersion} #GlobalProperties={data.globalProperties.Count} #Properties={data.Properties.Count} #ItemTypes={data.ItemTypes.Count} #ItemDefinitions={data.ItemDefinitions.Count} #Items={data.Items.Count} #Targets={data.Targets.Count}")&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt ein ausgewertetes Projekt mit Entwurfszeitsemantik dar.
Stets von XML unterstützt. Kann direkt integriert werden, oder eine Instanz davon kann geklont werden, um virtuelle Elemente/Eigenschaften hinzuzufügen und zu erstellen.
Bei Änderungen an diesem Projekt wird immer die unterstützende XML aktualisiert.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt ein leeres Projekt mit den globalen Eigenschaften der globalen Projektauflistung und der Standardtoolsversion.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Project ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Project();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Erstellt ein leeres Projekt, das mit den globalen Eigenschaften der globalen Projektsammlung und der Standardversion der Tools ausgewertet wird.
Das Projekt wird der globalen Projektsammlung hinzugefügt, wenn es benannt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Projekt wird der globalen Projekt Auflistung hinzugefügt, wenn es den vollständigen Pfad zur Quell Projektdatei erhält, in der Regel durch Speichern des Projekts.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Project (Microsoft.Build.Construction.ProjectRootElement xml);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Build.Construction.ProjectRootElement xml) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.#ctor(Microsoft.Build.Construction.ProjectRootElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (xml As ProjectRootElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Project(Microsoft::Build::Construction::ProjectRootElement ^ xml);" />
      <MemberSignature Language="F#" Value="new Microsoft.Build.Evaluation.Project : Microsoft.Build.Construction.ProjectRootElement -&gt; Microsoft.Build.Evaluation.Project" Usage="new Microsoft.Build.Evaluation.Project xml" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="xml" Type="Microsoft.Build.Construction.ProjectRootElement" />
      </Parameters>
      <Docs>
        <param name="xml">Zu verwendendes ProjectRootElement</param>
        <summary>Wird über ein ProjectRootElement-Objekt erstellt, das mit den globalen Eigenschaften der globalen Projektsammlung und der Standardversion der Tools ausgewertet wird.
Projekt wird der globalen Projektsammlung hinzugefügt, wenn es einen Namen hat, oder andernfalls wenn es benannt wird.
Löst InvalidProjectFileException aus, wenn die Auswertung fehlschlägt.
Löst InvalidOperationException aus, wenn bereits ein äquivalentes Projekt in die Projektsammlung geladen wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Projekt wird der globalen Projekt Auflistung hinzugefügt, wenn diesem Projekt oder dem angegebenen Projektstamm der vollständige Pfad zur Quell Projektdatei zugewiesen wird.  
  
 Löst InvalidProjectFileException aus, wenn die Auswertung fehlschlägt. Löst InvalidOperationException aus, wenn in der Projekt Auflistung bereits ein entsprechendes Projekt geladen ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Project (Microsoft.Build.Evaluation.NewProjectFileOptions newProjectFileOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype Microsoft.Build.Evaluation.NewProjectFileOptions newProjectFileOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.#ctor(Microsoft.Build.Evaluation.NewProjectFileOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (newProjectFileOptions As NewProjectFileOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Project(Microsoft::Build::Evaluation::NewProjectFileOptions newProjectFileOptions);" />
      <MemberSignature Language="F#" Value="new Microsoft.Build.Evaluation.Project : Microsoft.Build.Evaluation.NewProjectFileOptions -&gt; Microsoft.Build.Evaluation.Project" Usage="new Microsoft.Build.Evaluation.Project newProjectFileOptions" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="newProjectFileOptions" Type="Microsoft.Build.Evaluation.NewProjectFileOptions" Index="0" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
      </Parameters>
      <Docs>
        <param name="newProjectFileOptions">To be added.</param>
        <summary>Erstellt ein leeres Projekt, das mit den globalen Eigenschaften der globalen Projektsammlung und der Standardversion der Tools ausgewertet wird.
Das Projekt wird der globalen Projektsammlung hinzugefügt, wenn es benannt wird.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Project (Microsoft.Build.Evaluation.ProjectCollection projectCollection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Build.Evaluation.ProjectCollection projectCollection) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.#ctor(Microsoft.Build.Evaluation.ProjectCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (projectCollection As ProjectCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Project(Microsoft::Build::Evaluation::ProjectCollection ^ projectCollection);" />
      <MemberSignature Language="F#" Value="new Microsoft.Build.Evaluation.Project : Microsoft.Build.Evaluation.ProjectCollection -&gt; Microsoft.Build.Evaluation.Project" Usage="new Microsoft.Build.Evaluation.Project projectCollection" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="projectCollection" Type="Microsoft.Build.Evaluation.ProjectCollection" />
      </Parameters>
      <Docs>
        <param name="projectCollection">Die Projektauflistung, der das neue Projekt hinzugefügt wird.</param>
        <summary>Erstellt ein leeres Projekt, das mit den globalen Eigenschaften der angegebenen Projektsammlung und der Standardversion der Tools ausgewertet wird.
Das Projekt wird der angegebenen Projektsammlung hinzugefügt, wenn es benannt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Projekt wird der angegebenen Projekt Auflistung hinzugefügt, wenn es den vollständigen Pfad zur Quell Projektdatei erhält, in der Regel durch Speichern des Projekts.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Project (string projectFile);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string projectFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (projectFile As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Project(System::String ^ projectFile);" />
      <MemberSignature Language="F#" Value="new Microsoft.Build.Evaluation.Project : string -&gt; Microsoft.Build.Evaluation.Project" Usage="new Microsoft.Build.Evaluation.Project projectFile" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="projectFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="projectFile">Die Quellprojektdatei, die ausgewertet werden soll.</param>
        <summary>Wird über eine vorhandene Projektdatei erstellt und mit den globalen Eigenschaften der globalen Projektsammlung und der Standardversion der Tools ausgewertet.
Das Projekt wird der globalen Projektsammlung hinzugefügt.
Löst InvalidProjectFileException aus, wenn die Auswertung fehlschlägt.
Löst InvalidOperationException aus, wenn bereits ein äquivalentes Projekt in die Projektsammlung geladen wurde.
Kann E/A-bezogene Ausnahmen auslösen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Projekt wird der globalen Projekt Auflistung hinzugefügt.  
  
 Löst InvalidOperationException aus, wenn bereits ein Projekt in der Projekt Auflistung vorhanden ist, das diese Quell Projektdatei auswertet. Kann e/a-bezogene Ausnahmen auslösen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:Microsoft.Build.Exceptions.InvalidProjectFileException">Wenn die Evaluierung fehlschlägt.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Project (System.Xml.XmlReader xmlReader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xml.XmlReader xmlReader) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.#ctor(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (xmlReader As XmlReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Project(System::Xml::XmlReader ^ xmlReader);" />
      <MemberSignature Language="F#" Value="new Microsoft.Build.Evaluation.Project : System.Xml.XmlReader -&gt; Microsoft.Build.Evaluation.Project" Usage="new Microsoft.Build.Evaluation.Project xmlReader" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="xmlReader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="xmlReader">XML-Reader zum Lesen von Projekten.</param>
        <summary>Konstrukt über einen Textreader über Projekt-XML, mit dem die globalen Eigenschaften der globalen Projektsammlung und die Standardversion der Tools ausgewertet werden.
Das Projekt wird der globalen Projektsammlung hinzugefügt, wenn es benannt wird.
Löst InvalidProjectFileException aus, wenn die Auswertung fehlschlägt.
Löst InvalidOperationException aus, wenn bereits ein äquivalentes Projekt in die Projektsammlung geladen wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Projekt wird der globalen Projekt Auflistung hinzugefügt, wenn es den vollständigen Pfad zur Quell Projektdatei erhält, in der Regel durch Speichern des Projekts.  
  
 Löst InvalidProjectFileException aus, wenn die Auswertung fehlschlägt. Löst InvalidOperationException aus, wenn in der Projekt Auflistung bereits ein entsprechendes Projekt geladen ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Project (Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.NewProjectFileOptions newProjectFileOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Build.Evaluation.ProjectCollection projectCollection, valuetype Microsoft.Build.Evaluation.NewProjectFileOptions newProjectFileOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.#ctor(Microsoft.Build.Evaluation.ProjectCollection,Microsoft.Build.Evaluation.NewProjectFileOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (projectCollection As ProjectCollection, newProjectFileOptions As NewProjectFileOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Project(Microsoft::Build::Evaluation::ProjectCollection ^ projectCollection, Microsoft::Build::Evaluation::NewProjectFileOptions newProjectFileOptions);" />
      <MemberSignature Language="F#" Value="new Microsoft.Build.Evaluation.Project : Microsoft.Build.Evaluation.ProjectCollection * Microsoft.Build.Evaluation.NewProjectFileOptions -&gt; Microsoft.Build.Evaluation.Project" Usage="new Microsoft.Build.Evaluation.Project (projectCollection, newProjectFileOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="projectCollection" Type="Microsoft.Build.Evaluation.ProjectCollection" Index="0" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
        <Parameter Name="newProjectFileOptions" Type="Microsoft.Build.Evaluation.NewProjectFileOptions" Index="1" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
      </Parameters>
      <Docs>
        <param name="projectCollection">To be added.</param>
        <param name="newProjectFileOptions">To be added.</param>
        <summary>Erstellt ein leeres Projekt, das mit den globalen Eigenschaften der angegebenen Projektsammlung und der Standardversion der Tools ausgewertet wird.
Das Projekt wird der angegebenen Projektsammlung hinzugefügt, wenn es benannt wird.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Project (Microsoft.Build.Construction.ProjectRootElement xml, System.Collections.Generic.IDictionary&lt;string,string&gt; globalProperties, string toolsVersion);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Build.Construction.ProjectRootElement xml, class System.Collections.Generic.IDictionary`2&lt;string, string&gt; globalProperties, string toolsVersion) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.#ctor(Microsoft.Build.Construction.ProjectRootElement,System.Collections.Generic.IDictionary{System.String,System.String},System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (xml As ProjectRootElement, globalProperties As IDictionary(Of String, String), toolsVersion As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Project(Microsoft::Build::Construction::ProjectRootElement ^ xml, System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ globalProperties, System::String ^ toolsVersion);" />
      <MemberSignature Language="F#" Value="new Microsoft.Build.Evaluation.Project : Microsoft.Build.Construction.ProjectRootElement * System.Collections.Generic.IDictionary&lt;string, string&gt; * string -&gt; Microsoft.Build.Evaluation.Project" Usage="new Microsoft.Build.Evaluation.Project (xml, globalProperties, toolsVersion)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="xml" Type="Microsoft.Build.Construction.ProjectRootElement" />
        <Parameter Name="globalProperties" Type="System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;" />
        <Parameter Name="toolsVersion" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="xml">Zu verwendendes ProjectRootElement</param>
        <param name="globalProperties">Globale Eigenschaften für die Auswertung. Ist möglicherweise NULL, in diesem Fall werden die globalen Eigenschaften der enthaltenden Projektauflistung verwendet.</param>
        <param name="toolsVersion">Toolsversion für die Auswertung. Kann NULL sein</param>
        <summary>Wird über ein ProjectRootElement-Objekt erstellt und mit den angegebenen globalen Eigenschaften und dem Toolset ausgewertet, die einzeln oder beide NULL sein können.
Projekt wird der globalen Projektsammlung hinzugefügt, wenn es einen Namen hat, oder andernfalls wenn es benannt wird.
Löst InvalidProjectFileException aus, wenn die Auswertung fehlschlägt.
Löst InvalidOperationException aus, wenn bereits ein äquivalentes Projekt in die Projektsammlung geladen wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Projekt wird der globalen Projekt Auflistung hinzugefügt, wenn diesem Projekt oder dem angegebenen Projektstamm der vollständige Pfad zur Quell Projektdatei zugewiesen wird.  
  
 Löst InvalidProjectFileException aus, wenn die Auswertung fehlschlägt. Löst InvalidOperationException aus, wenn in der Projekt Auflistung bereits ein entsprechendes Projekt geladen ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Project (System.Collections.Generic.IDictionary&lt;string,string&gt; globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IDictionary`2&lt;string, string&gt; globalProperties, string toolsVersion, class Microsoft.Build.Evaluation.ProjectCollection projectCollection) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.#ctor(System.Collections.Generic.IDictionary{System.String,System.String},System.String,Microsoft.Build.Evaluation.ProjectCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (globalProperties As IDictionary(Of String, String), toolsVersion As String, projectCollection As ProjectCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Project(System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ globalProperties, System::String ^ toolsVersion, Microsoft::Build::Evaluation::ProjectCollection ^ projectCollection);" />
      <MemberSignature Language="F#" Value="new Microsoft.Build.Evaluation.Project : System.Collections.Generic.IDictionary&lt;string, string&gt; * string * Microsoft.Build.Evaluation.ProjectCollection -&gt; Microsoft.Build.Evaluation.Project" Usage="new Microsoft.Build.Evaluation.Project (globalProperties, toolsVersion, projectCollection)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="globalProperties" Type="System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;" />
        <Parameter Name="toolsVersion" Type="System.String" />
        <Parameter Name="projectCollection" Type="Microsoft.Build.Evaluation.ProjectCollection" />
      </Parameters>
      <Docs>
        <param name="globalProperties">Globale Eigenschaften für die Auswertung. Ist möglicherweise NULL, in diesem Fall werden die globalen Eigenschaften der enthaltenden Projektauflistung verwendet.</param>
        <param name="toolsVersion">Toolsversion für die Auswertung. Kann NULL sein</param>
        <param name="projectCollection">Das <see cref="P:Microsoft.Build.Evaluation.Project.ProjectCollection" />, dem das Projekt hinzugefügt wird.</param>
        <summary>Erstellt ein leeres Projekt, das mit der angegebenen Projektsammlung und den angegebenen globalen Eigenschaften und der vorgegebenen Toolversion ausgewertet wird, wobei beide NULL sein können.
Das Projekt wird der angegebenen Projektsammlung hinzugefügt, wenn es benannt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Projekt wird der angegebenen Projekt Auflistung hinzugefügt, wenn es den vollständigen Pfad zur Quell Projektdatei erhält, in der Regel durch Speichern des Projekts.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Project (string projectFile, System.Collections.Generic.IDictionary&lt;string,string&gt; globalProperties, string toolsVersion);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string projectFile, class System.Collections.Generic.IDictionary`2&lt;string, string&gt; globalProperties, string toolsVersion) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.#ctor(System.String,System.Collections.Generic.IDictionary{System.String,System.String},System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (projectFile As String, globalProperties As IDictionary(Of String, String), toolsVersion As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Project(System::String ^ projectFile, System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ globalProperties, System::String ^ toolsVersion);" />
      <MemberSignature Language="F#" Value="new Microsoft.Build.Evaluation.Project : string * System.Collections.Generic.IDictionary&lt;string, string&gt; * string -&gt; Microsoft.Build.Evaluation.Project" Usage="new Microsoft.Build.Evaluation.Project (projectFile, globalProperties, toolsVersion)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="projectFile" Type="System.String" />
        <Parameter Name="globalProperties" Type="System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;" />
        <Parameter Name="toolsVersion" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="projectFile">Der Pfad zur Quellprojektdatei, die ausgewertet werden soll.</param>
        <param name="globalProperties">Globale Eigenschaften für die Auswertung. Ist möglicherweise NULL, in diesem Fall werden die globalen Eigenschaften der enthaltenden Projektauflistung verwendet.</param>
        <param name="toolsVersion">Toolsversion für die Auswertung. Ist möglicherweise NULL.</param>
        <summary>Konstrukt über eine vorhandene Projektdatei, das mit angegebenen globalen Eigenschaften und dem Toolset ausgewertet wird, die jeweils oder beide NULL sein können.
Das Projekt wird der globalen Projektsammlung hinzugefügt.
Löst InvalidProjectFileException aus, wenn die Auswertung fehlschlägt.
Löst InvalidOperationException aus, wenn bereits ein äquivalentes Projekt in die Projektsammlung geladen wurde.
Kann E/A-bezogene Ausnahmen auslösen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Projekt wird der globalen Projekt Auflistung hinzugefügt.  
  
 Löst InvalidProjectFileException aus, wenn die Auswertung fehlschlägt. Löst InvalidOperationException aus, wenn in der Projekt Auflistung bereits ein entsprechendes Projekt geladen ist. Kann e/a-bezogene Ausnahmen auslösen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Project (System.Xml.XmlReader xmlReader, System.Collections.Generic.IDictionary&lt;string,string&gt; globalProperties, string toolsVersion);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xml.XmlReader xmlReader, class System.Collections.Generic.IDictionary`2&lt;string, string&gt; globalProperties, string toolsVersion) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.#ctor(System.Xml.XmlReader,System.Collections.Generic.IDictionary{System.String,System.String},System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (xmlReader As XmlReader, globalProperties As IDictionary(Of String, String), toolsVersion As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Project(System::Xml::XmlReader ^ xmlReader, System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ globalProperties, System::String ^ toolsVersion);" />
      <MemberSignature Language="F#" Value="new Microsoft.Build.Evaluation.Project : System.Xml.XmlReader * System.Collections.Generic.IDictionary&lt;string, string&gt; * string -&gt; Microsoft.Build.Evaluation.Project" Usage="new Microsoft.Build.Evaluation.Project (xmlReader, globalProperties, toolsVersion)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="xmlReader" Type="System.Xml.XmlReader" />
        <Parameter Name="globalProperties" Type="System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;" />
        <Parameter Name="toolsVersion" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="xmlReader">XML-Reader zum Lesen von Projekten.</param>
        <param name="globalProperties">Globale Eigenschaften für die Auswertung. Ist möglicherweise NULL, in diesem Fall werden die globalen Eigenschaften der enthaltenden Projektauflistung verwendet.</param>
        <param name="toolsVersion">Toolsversion für die Auswertung. Kann NULL sein</param>
        <summary>Wird über einen Textreader über die Projekt-XML erstellt und mit den globalen Eigenschaften der globalen Projektsammlung und der Standardversion der Tools ausgewertet, die einzeln oder beide NULL sein können.
Das Projekt wird der globalen Projektsammlung hinzugefügt, wenn es benannt wird.
Löst InvalidProjectFileException aus, wenn die Auswertung fehlschlägt.
Löst InvalidOperationException aus, wenn bereits ein äquivalentes Projekt in die Projektsammlung geladen wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Projekt wird der globalen Projekt Auflistung hinzugefügt, wenn es den vollständigen Pfad zur Quell Projektdatei erhält, in der Regel durch Speichern des Projekts.  
  
 Löst InvalidProjectFileException aus, wenn die Auswertung fehlschlägt. Löst InvalidOperationException aus, wenn in der Projekt Auflistung bereits ein entsprechendes Projekt geladen ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Project (Microsoft.Build.Construction.ProjectRootElement xml, System.Collections.Generic.IDictionary&lt;string,string&gt; globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Build.Construction.ProjectRootElement xml, class System.Collections.Generic.IDictionary`2&lt;string, string&gt; globalProperties, string toolsVersion, class Microsoft.Build.Evaluation.ProjectCollection projectCollection) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.#ctor(Microsoft.Build.Construction.ProjectRootElement,System.Collections.Generic.IDictionary{System.String,System.String},System.String,Microsoft.Build.Evaluation.ProjectCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (xml As ProjectRootElement, globalProperties As IDictionary(Of String, String), toolsVersion As String, projectCollection As ProjectCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Project(Microsoft::Build::Construction::ProjectRootElement ^ xml, System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ globalProperties, System::String ^ toolsVersion, Microsoft::Build::Evaluation::ProjectCollection ^ projectCollection);" />
      <MemberSignature Language="F#" Value="new Microsoft.Build.Evaluation.Project : Microsoft.Build.Construction.ProjectRootElement * System.Collections.Generic.IDictionary&lt;string, string&gt; * string * Microsoft.Build.Evaluation.ProjectCollection -&gt; Microsoft.Build.Evaluation.Project" Usage="new Microsoft.Build.Evaluation.Project (xml, globalProperties, toolsVersion, projectCollection)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="xml" Type="Microsoft.Build.Construction.ProjectRootElement" />
        <Parameter Name="globalProperties" Type="System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;" />
        <Parameter Name="toolsVersion" Type="System.String" />
        <Parameter Name="projectCollection" Type="Microsoft.Build.Evaluation.ProjectCollection" />
      </Parameters>
      <Docs>
        <param name="xml">Zu verwendendes ProjectRootElement</param>
        <param name="globalProperties">Globale Eigenschaften für die Auswertung. Ist möglicherweise NULL, in diesem Fall werden die globalen Eigenschaften der enthaltenden Projektauflistung verwendet.</param>
        <param name="toolsVersion">Toolsversion für die Auswertung. Kann NULL sein</param>
        <param name="projectCollection">Das <see cref="P:Microsoft.Build.Evaluation.Project.ProjectCollection" />, dem das Projekt hinzugefügt wird.</param>
        <summary>Wird über ein ProjectRootElement-Objekt erstellt und mit den angegebenen globalen Eigenschaften und dem Toolset ausgewertet, die einzeln oder beide NULL sein können.
Projekt wird der globalen Projektsammlung hinzugefügt, wenn es einen Namen hat, oder andernfalls wenn es benannt wird.
Löst InvalidProjectFileException aus, wenn die Auswertung fehlschlägt.
Löst InvalidOperationException aus, wenn bereits ein äquivalentes Projekt in die Projektsammlung geladen wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Projekt wird der angegebenen Projekt Auflistung hinzugefügt, wenn entweder diesem Projekt oder dem angegebenen Projektstamm der vollständige Pfad zur Quell Projektdatei zugewiesen wird.  
  
 Löst InvalidProjectFileException aus, wenn die Auswertung fehlschlägt. Löst InvalidOperationException aus, wenn in der Projekt Auflistung bereits ein entsprechendes Projekt geladen ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Project (System.Collections.Generic.IDictionary&lt;string,string&gt; globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.NewProjectFileOptions newProjectFileOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IDictionary`2&lt;string, string&gt; globalProperties, string toolsVersion, class Microsoft.Build.Evaluation.ProjectCollection projectCollection, valuetype Microsoft.Build.Evaluation.NewProjectFileOptions newProjectFileOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.#ctor(System.Collections.Generic.IDictionary{System.String,System.String},System.String,Microsoft.Build.Evaluation.ProjectCollection,Microsoft.Build.Evaluation.NewProjectFileOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (globalProperties As IDictionary(Of String, String), toolsVersion As String, projectCollection As ProjectCollection, newProjectFileOptions As NewProjectFileOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Project(System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ globalProperties, System::String ^ toolsVersion, Microsoft::Build::Evaluation::ProjectCollection ^ projectCollection, Microsoft::Build::Evaluation::NewProjectFileOptions newProjectFileOptions);" />
      <MemberSignature Language="F#" Value="new Microsoft.Build.Evaluation.Project : System.Collections.Generic.IDictionary&lt;string, string&gt; * string * Microsoft.Build.Evaluation.ProjectCollection * Microsoft.Build.Evaluation.NewProjectFileOptions -&gt; Microsoft.Build.Evaluation.Project" Usage="new Microsoft.Build.Evaluation.Project (globalProperties, toolsVersion, projectCollection, newProjectFileOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="globalProperties" Type="System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;" Index="0" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
        <Parameter Name="toolsVersion" Type="System.String" Index="1" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
        <Parameter Name="projectCollection" Type="Microsoft.Build.Evaluation.ProjectCollection" Index="2" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
        <Parameter Name="newProjectFileOptions" Type="Microsoft.Build.Evaluation.NewProjectFileOptions" Index="3" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
      </Parameters>
      <Docs>
        <param name="globalProperties">Globale Eigenschaften für die Auswertung. Ist möglicherweise NULL, in diesem Fall werden die globalen Eigenschaften der enthaltenden Projektauflistung verwendet.</param>
        <param name="toolsVersion">Toolsversion für die Auswertung. Kann NULL sein</param>
        <param name="projectCollection">Das <see cref="P:Microsoft.Build.Evaluation.Project.ProjectCollection" />, dem das Projekt hinzugefügt wird.</param>
        <param name="newProjectFileOptions"><see cref="T:Microsoft.Build.Evaluation.NewProjectFileOptions" />, die für das neue Projekt verwendet werden sollen.</param>
        <summary>Erstellt ein leeres Projekt, das mit der angegebenen Projektsammlung und den angegebenen globalen Eigenschaften und der vorgegebenen Toolversion ausgewertet wird, wobei beide NULL sein können.
Das Projekt wird der angegebenen Projektsammlung hinzugefügt, wenn es benannt wird.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Project (string projectFile, System.Collections.Generic.IDictionary&lt;string,string&gt; globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string projectFile, class System.Collections.Generic.IDictionary`2&lt;string, string&gt; globalProperties, string toolsVersion, class Microsoft.Build.Evaluation.ProjectCollection projectCollection) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.#ctor(System.String,System.Collections.Generic.IDictionary{System.String,System.String},System.String,Microsoft.Build.Evaluation.ProjectCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (projectFile As String, globalProperties As IDictionary(Of String, String), toolsVersion As String, projectCollection As ProjectCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Project(System::String ^ projectFile, System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ globalProperties, System::String ^ toolsVersion, Microsoft::Build::Evaluation::ProjectCollection ^ projectCollection);" />
      <MemberSignature Language="F#" Value="new Microsoft.Build.Evaluation.Project : string * System.Collections.Generic.IDictionary&lt;string, string&gt; * string * Microsoft.Build.Evaluation.ProjectCollection -&gt; Microsoft.Build.Evaluation.Project" Usage="new Microsoft.Build.Evaluation.Project (projectFile, globalProperties, toolsVersion, projectCollection)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="projectFile" Type="System.String" />
        <Parameter Name="globalProperties" Type="System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;" />
        <Parameter Name="toolsVersion" Type="System.String" />
        <Parameter Name="projectCollection" Type="Microsoft.Build.Evaluation.ProjectCollection" />
      </Parameters>
      <Docs>
        <param name="projectFile">Die Projektdatei.</param>
        <param name="globalProperties">Die globalen Eigenschaften. Ist möglicherweise NULL.</param>
        <param name="toolsVersion">Die Toolsversion. Ist möglicherweise NULL.</param>
        <param name="projectCollection">Die Sammlung, der dieses Projekt zugeordnet werden soll. Darf nicht NULL sein.</param>
        <summary>Wird über eine vorhandene Projektdatei erstellt und mit angegebenen globalen Eigenschaften und der angegebenen Toolversion ausgewertet, die einzeln oder beide NULL sein können.
Das Projekt wird der globalen Projektsammlung hinzugefügt.
Löst InvalidProjectFileException aus, wenn die Auswertung fehlschlägt.
Löst InvalidOperationException aus, wenn bereits ein äquivalentes Projekt in die Projektsammlung geladen wurde.
Kann E/A-bezogene Ausnahmen auslösen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Projekt wird der angegebenen Projekt Auflistung hinzugefügt.  
  
 Löst InvalidProjectFileException aus, wenn die Auswertung fehlschlägt. Löst InvalidOperationException aus, wenn in der Projekt Auflistung bereits ein entsprechendes Projekt geladen ist. Kann e/a-bezogene Ausnahmen auslösen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Project (System.Xml.XmlReader xmlReader, System.Collections.Generic.IDictionary&lt;string,string&gt; globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xml.XmlReader xmlReader, class System.Collections.Generic.IDictionary`2&lt;string, string&gt; globalProperties, string toolsVersion, class Microsoft.Build.Evaluation.ProjectCollection projectCollection) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.#ctor(System.Xml.XmlReader,System.Collections.Generic.IDictionary{System.String,System.String},System.String,Microsoft.Build.Evaluation.ProjectCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (xmlReader As XmlReader, globalProperties As IDictionary(Of String, String), toolsVersion As String, projectCollection As ProjectCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Project(System::Xml::XmlReader ^ xmlReader, System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ globalProperties, System::String ^ toolsVersion, Microsoft::Build::Evaluation::ProjectCollection ^ projectCollection);" />
      <MemberSignature Language="F#" Value="new Microsoft.Build.Evaluation.Project : System.Xml.XmlReader * System.Collections.Generic.IDictionary&lt;string, string&gt; * string * Microsoft.Build.Evaluation.ProjectCollection -&gt; Microsoft.Build.Evaluation.Project" Usage="new Microsoft.Build.Evaluation.Project (xmlReader, globalProperties, toolsVersion, projectCollection)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="xmlReader" Type="System.Xml.XmlReader" />
        <Parameter Name="globalProperties" Type="System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;" />
        <Parameter Name="toolsVersion" Type="System.String" />
        <Parameter Name="projectCollection" Type="Microsoft.Build.Evaluation.ProjectCollection" />
      </Parameters>
      <Docs>
        <param name="xmlReader">XML-Reader zum Lesen von Projekten.</param>
        <param name="globalProperties">Globale Eigenschaften für die Auswertung. Ist möglicherweise NULL, in diesem Fall werden die globalen Eigenschaften der enthaltenden Projektauflistung verwendet.</param>
        <param name="toolsVersion">Toolsversion für die Auswertung. Kann NULL sein</param>
        <param name="projectCollection">Die Sammlung, der dieses Projekt zugeordnet werden soll. Darf nicht NULL sein.</param>
        <summary>Wird über einen Textreader über die Projekt-XML erstellt und mit den globalen Eigenschaften der globalen Projektsammlung und der Standardversion der Tools ausgewertet, die einzeln oder beide NULL sein können.
Das Projekt wird der angegebenen Projektsammlung hinzugefügt, wenn es benannt wird.
Löst InvalidProjectFileException aus, wenn die Auswertung fehlschlägt.
Löst InvalidOperationException aus, wenn bereits ein äquivalentes Projekt in die Projektsammlung geladen wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Projekt wird der angegebenen Projekt Auflistung hinzugefügt, wenn entweder diesem Projekt oder dem angegebenen Projektstamm der vollständige Pfad zur Quell Projektdatei zugewiesen wird.  
  
 Löst InvalidProjectFileException aus, wenn die Auswertung fehlschlägt. Löst InvalidOperationException aus, wenn in der Projekt Auflistung bereits ein entsprechendes Projekt geladen ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Project (Microsoft.Build.Construction.ProjectRootElement xml, System.Collections.Generic.IDictionary&lt;string,string&gt; globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Build.Construction.ProjectRootElement xml, class System.Collections.Generic.IDictionary`2&lt;string, string&gt; globalProperties, string toolsVersion, class Microsoft.Build.Evaluation.ProjectCollection projectCollection, valuetype Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.#ctor(Microsoft.Build.Construction.ProjectRootElement,System.Collections.Generic.IDictionary{System.String,System.String},System.String,Microsoft.Build.Evaluation.ProjectCollection,Microsoft.Build.Evaluation.ProjectLoadSettings)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (xml As ProjectRootElement, globalProperties As IDictionary(Of String, String), toolsVersion As String, projectCollection As ProjectCollection, loadSettings As ProjectLoadSettings)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Project(Microsoft::Build::Construction::ProjectRootElement ^ xml, System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ globalProperties, System::String ^ toolsVersion, Microsoft::Build::Evaluation::ProjectCollection ^ projectCollection, Microsoft::Build::Evaluation::ProjectLoadSettings loadSettings);" />
      <MemberSignature Language="F#" Value="new Microsoft.Build.Evaluation.Project : Microsoft.Build.Construction.ProjectRootElement * System.Collections.Generic.IDictionary&lt;string, string&gt; * string * Microsoft.Build.Evaluation.ProjectCollection * Microsoft.Build.Evaluation.ProjectLoadSettings -&gt; Microsoft.Build.Evaluation.Project" Usage="new Microsoft.Build.Evaluation.Project (xml, globalProperties, toolsVersion, projectCollection, loadSettings)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="xml" Type="Microsoft.Build.Construction.ProjectRootElement" />
        <Parameter Name="globalProperties" Type="System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;" />
        <Parameter Name="toolsVersion" Type="System.String" />
        <Parameter Name="projectCollection" Type="Microsoft.Build.Evaluation.ProjectCollection" />
        <Parameter Name="loadSettings" Type="Microsoft.Build.Evaluation.ProjectLoadSettings" />
      </Parameters>
      <Docs>
        <param name="xml">Zu verwendendes ProjectRootElement</param>
        <param name="globalProperties">Globale Eigenschaften für die Auswertung. Ist möglicherweise NULL, in diesem Fall werden die globalen Eigenschaften der enthaltenden Projektauflistung verwendet.</param>
        <param name="toolsVersion">Toolsversion für die Auswertung. Kann NULL sein</param>
        <param name="projectCollection">Das <see cref="P:Microsoft.Build.Evaluation.Project.ProjectCollection" />, dem das Projekt hinzugefügt wird.</param>
        <param name="loadSettings">Die <see cref="T:Microsoft.Build.Evaluation.ProjectLoadSettings" />, die für die Auswertung verwendet werden.</param>
        <summary>Wird über ein ProjectRootElement-Objekt erstellt und mit den angegebenen globalen Eigenschaften und dem Toolset ausgewertet, die einzeln oder beide NULL sein können.
Projekt wird der globalen Projektsammlung hinzugefügt, wenn es einen Namen hat, oder andernfalls wenn es benannt wird.
Löst InvalidProjectFileException aus, wenn die Auswertung fehlschlägt.
Löst InvalidOperationException aus, wenn bereits ein äquivalentes Projekt in die Projektsammlung geladen wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Projekt wird der angegebenen Projekt Auflistung hinzugefügt, wenn entweder diesem Projekt oder dem angegebenen Projektstamm der vollständige Pfad zur Quell Projektdatei zugewiesen wird.  
  
 Löst InvalidProjectFileException aus, wenn die Auswertung fehlschlägt. Löst InvalidOperationException aus, wenn in der Projekt Auflistung bereits ein entsprechendes Projekt geladen ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Project (string projectFile, System.Collections.Generic.IDictionary&lt;string,string&gt; globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string projectFile, class System.Collections.Generic.IDictionary`2&lt;string, string&gt; globalProperties, string toolsVersion, class Microsoft.Build.Evaluation.ProjectCollection projectCollection, valuetype Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.#ctor(System.String,System.Collections.Generic.IDictionary{System.String,System.String},System.String,Microsoft.Build.Evaluation.ProjectCollection,Microsoft.Build.Evaluation.ProjectLoadSettings)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (projectFile As String, globalProperties As IDictionary(Of String, String), toolsVersion As String, projectCollection As ProjectCollection, loadSettings As ProjectLoadSettings)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Project(System::String ^ projectFile, System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ globalProperties, System::String ^ toolsVersion, Microsoft::Build::Evaluation::ProjectCollection ^ projectCollection, Microsoft::Build::Evaluation::ProjectLoadSettings loadSettings);" />
      <MemberSignature Language="F#" Value="new Microsoft.Build.Evaluation.Project : string * System.Collections.Generic.IDictionary&lt;string, string&gt; * string * Microsoft.Build.Evaluation.ProjectCollection * Microsoft.Build.Evaluation.ProjectLoadSettings -&gt; Microsoft.Build.Evaluation.Project" Usage="new Microsoft.Build.Evaluation.Project (projectFile, globalProperties, toolsVersion, projectCollection, loadSettings)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="projectFile" Type="System.String" />
        <Parameter Name="globalProperties" Type="System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;" />
        <Parameter Name="toolsVersion" Type="System.String" />
        <Parameter Name="projectCollection" Type="Microsoft.Build.Evaluation.ProjectCollection" />
        <Parameter Name="loadSettings" Type="Microsoft.Build.Evaluation.ProjectLoadSettings" />
      </Parameters>
      <Docs>
        <param name="projectFile">Die Projektdatei.</param>
        <param name="globalProperties">Die globalen Eigenschaften. Ist möglicherweise NULL.</param>
        <param name="toolsVersion">Die Toolsversion. Ist möglicherweise NULL.</param>
        <param name="projectCollection">Die Sammlung, der dieses Projekt zugeordnet werden soll. Darf nicht NULL sein.</param>
        <param name="loadSettings">Die Ladeeinstellungen dieses Projekts.</param>
        <summary>Wird über eine vorhandene Projektdatei erstellt und mit angegebenen globalen Eigenschaften und der angegebenen Toolversion ausgewertet, die einzeln oder beide NULL sein können.
Das Projekt wird der globalen Projektsammlung hinzugefügt.
Löst InvalidProjectFileException aus, wenn die Auswertung fehlschlägt.
Löst InvalidOperationException aus, wenn bereits ein äquivalentes Projekt in die Projektsammlung geladen wurde.
Kann E/A-bezogene Ausnahmen auslösen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Projekt wird der angegebenen Projekt Auflistung hinzugefügt.  
  
 Löst InvalidProjectFileException aus, wenn die Auswertung fehlschlägt. Löst InvalidOperationException aus, wenn in der Projekt Auflistung bereits ein entsprechendes Projekt geladen ist. Kann e/a-bezogene Ausnahmen auslösen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Project (System.Xml.XmlReader xmlReader, System.Collections.Generic.IDictionary&lt;string,string&gt; globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xml.XmlReader xmlReader, class System.Collections.Generic.IDictionary`2&lt;string, string&gt; globalProperties, string toolsVersion, class Microsoft.Build.Evaluation.ProjectCollection projectCollection, valuetype Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.#ctor(System.Xml.XmlReader,System.Collections.Generic.IDictionary{System.String,System.String},System.String,Microsoft.Build.Evaluation.ProjectCollection,Microsoft.Build.Evaluation.ProjectLoadSettings)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (xmlReader As XmlReader, globalProperties As IDictionary(Of String, String), toolsVersion As String, projectCollection As ProjectCollection, loadSettings As ProjectLoadSettings)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Project(System::Xml::XmlReader ^ xmlReader, System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ globalProperties, System::String ^ toolsVersion, Microsoft::Build::Evaluation::ProjectCollection ^ projectCollection, Microsoft::Build::Evaluation::ProjectLoadSettings loadSettings);" />
      <MemberSignature Language="F#" Value="new Microsoft.Build.Evaluation.Project : System.Xml.XmlReader * System.Collections.Generic.IDictionary&lt;string, string&gt; * string * Microsoft.Build.Evaluation.ProjectCollection * Microsoft.Build.Evaluation.ProjectLoadSettings -&gt; Microsoft.Build.Evaluation.Project" Usage="new Microsoft.Build.Evaluation.Project (xmlReader, globalProperties, toolsVersion, projectCollection, loadSettings)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="xmlReader" Type="System.Xml.XmlReader" />
        <Parameter Name="globalProperties" Type="System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;" />
        <Parameter Name="toolsVersion" Type="System.String" />
        <Parameter Name="projectCollection" Type="Microsoft.Build.Evaluation.ProjectCollection" />
        <Parameter Name="loadSettings" Type="Microsoft.Build.Evaluation.ProjectLoadSettings" />
      </Parameters>
      <Docs>
        <param name="xmlReader">XML-Reader zum Lesen von Projekten.</param>
        <param name="globalProperties">Globale Eigenschaften für die Auswertung. Ist möglicherweise NULL, in diesem Fall werden die globalen Eigenschaften der enthaltenden Projektauflistung verwendet.</param>
        <param name="toolsVersion">Toolsversion für die Auswertung. Kann NULL sein</param>
        <param name="projectCollection">Die Sammlung, der dieses Projekt zugeordnet werden soll. Darf nicht NULL sein.</param>
        <param name="loadSettings">Die <see cref="T:Microsoft.Build.Evaluation.ProjectLoadSettings" />, die für die Auswertung verwendet werden.</param>
        <summary>Wird über einen Textreader über die Projekt-XML erstellt und mit den globalen Eigenschaften der globalen Projektsammlung und der Standardversion der Tools ausgewertet, die einzeln oder beide NULL sein können.
Das Projekt wird der angegebenen Projektsammlung hinzugefügt, wenn es benannt wird.
Löst InvalidProjectFileException aus, wenn die Auswertung fehlschlägt.
Löst InvalidOperationException aus, wenn bereits ein äquivalentes Projekt in die Projektsammlung geladen wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Projekt wird der angegebenen Projekt Auflistung hinzugefügt, wenn entweder diesem Projekt oder dem angegebenen Projektstamm der vollständige Pfad zur Quell Projektdatei zugewiesen wird.  
  
 Löst InvalidProjectFileException aus, wenn die Auswertung fehlschlägt. Löst InvalidOperationException aus, wenn in der Projekt Auflistung bereits ein entsprechendes Projekt geladen ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Project (Microsoft.Build.Construction.ProjectRootElement xml, System.Collections.Generic.IDictionary&lt;string,string&gt; globalProperties, string toolsVersion, string subToolsetVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Build.Construction.ProjectRootElement xml, class System.Collections.Generic.IDictionary`2&lt;string, string&gt; globalProperties, string toolsVersion, string subToolsetVersion, class Microsoft.Build.Evaluation.ProjectCollection projectCollection, valuetype Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.#ctor(Microsoft.Build.Construction.ProjectRootElement,System.Collections.Generic.IDictionary{System.String,System.String},System.String,System.String,Microsoft.Build.Evaluation.ProjectCollection,Microsoft.Build.Evaluation.ProjectLoadSettings)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (xml As ProjectRootElement, globalProperties As IDictionary(Of String, String), toolsVersion As String, subToolsetVersion As String, projectCollection As ProjectCollection, loadSettings As ProjectLoadSettings)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Project(Microsoft::Build::Construction::ProjectRootElement ^ xml, System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ globalProperties, System::String ^ toolsVersion, System::String ^ subToolsetVersion, Microsoft::Build::Evaluation::ProjectCollection ^ projectCollection, Microsoft::Build::Evaluation::ProjectLoadSettings loadSettings);" />
      <MemberSignature Language="F#" Value="new Microsoft.Build.Evaluation.Project : Microsoft.Build.Construction.ProjectRootElement * System.Collections.Generic.IDictionary&lt;string, string&gt; * string * string * Microsoft.Build.Evaluation.ProjectCollection * Microsoft.Build.Evaluation.ProjectLoadSettings -&gt; Microsoft.Build.Evaluation.Project" Usage="new Microsoft.Build.Evaluation.Project (xml, globalProperties, toolsVersion, subToolsetVersion, projectCollection, loadSettings)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="xml" Type="Microsoft.Build.Construction.ProjectRootElement" Index="0" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="globalProperties" Type="System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;" Index="1" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="toolsVersion" Type="System.String" Index="2" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="subToolsetVersion" Type="System.String" Index="3" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="projectCollection" Type="Microsoft.Build.Evaluation.ProjectCollection" Index="4" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="loadSettings" Type="Microsoft.Build.Evaluation.ProjectLoadSettings" Index="5" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="xml">Zu verwendendes ProjectRootElement</param>
        <param name="globalProperties">Globale Eigenschaften für die Auswertung. Ist möglicherweise NULL, in diesem Fall werden die globalen Eigenschaften der enthaltenden Projektauflistung verwendet.</param>
        <param name="toolsVersion">Toolsversion für die Auswertung. Kann NULL sein</param>
        <param name="subToolsetVersion">Untertoolsetversion, mit der das Toolset explizit ausgewertet wird.  Ist möglicherweise NULL.</param>
        <param name="projectCollection">Das <see cref="P:Microsoft.Build.Evaluation.Project.ProjectCollection" />, dem das Projekt hinzugefügt wird.</param>
        <param name="loadSettings">Die <see cref="T:Microsoft.Build.Evaluation.ProjectLoadSettings" />, die für die Auswertung verwendet werden.</param>
        <summary>Wird über ein ProjectRootElement-Objekt erstellt und mit den angegebenen globalen Eigenschaften und dem Toolset ausgewertet, die einzeln oder beide NULL sein können.
Projekt wird der globalen Projektsammlung hinzugefügt, wenn es einen Namen hat, oder andernfalls wenn es benannt wird.
Löst InvalidProjectFileException aus, wenn die Auswertung fehlschlägt.
Löst InvalidOperationException aus, wenn bereits ein äquivalentes Projekt in die Projektsammlung geladen wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Projekt wird der angegebenen Projekt Auflistung hinzugefügt, wenn entweder diesem Projekt oder dem angegebenen Projektstamm der vollständige Pfad zur Quell Projektdatei zugewiesen wird.  
  
 Löst InvalidProjectFileException aus, wenn die Auswertung fehlschlägt. Löst InvalidOperationException aus, wenn in der Projekt Auflistung bereits ein entsprechendes Projekt geladen ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Project (string projectFile, System.Collections.Generic.IDictionary&lt;string,string&gt; globalProperties, string toolsVersion, string subToolsetVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string projectFile, class System.Collections.Generic.IDictionary`2&lt;string, string&gt; globalProperties, string toolsVersion, string subToolsetVersion, class Microsoft.Build.Evaluation.ProjectCollection projectCollection, valuetype Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.#ctor(System.String,System.Collections.Generic.IDictionary{System.String,System.String},System.String,System.String,Microsoft.Build.Evaluation.ProjectCollection,Microsoft.Build.Evaluation.ProjectLoadSettings)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (projectFile As String, globalProperties As IDictionary(Of String, String), toolsVersion As String, subToolsetVersion As String, projectCollection As ProjectCollection, loadSettings As ProjectLoadSettings)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Project(System::String ^ projectFile, System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ globalProperties, System::String ^ toolsVersion, System::String ^ subToolsetVersion, Microsoft::Build::Evaluation::ProjectCollection ^ projectCollection, Microsoft::Build::Evaluation::ProjectLoadSettings loadSettings);" />
      <MemberSignature Language="F#" Value="new Microsoft.Build.Evaluation.Project : string * System.Collections.Generic.IDictionary&lt;string, string&gt; * string * string * Microsoft.Build.Evaluation.ProjectCollection * Microsoft.Build.Evaluation.ProjectLoadSettings -&gt; Microsoft.Build.Evaluation.Project" Usage="new Microsoft.Build.Evaluation.Project (projectFile, globalProperties, toolsVersion, subToolsetVersion, projectCollection, loadSettings)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="projectFile" Type="System.String" Index="0" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="globalProperties" Type="System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;" Index="1" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="toolsVersion" Type="System.String" Index="2" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="subToolsetVersion" Type="System.String" Index="3" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="projectCollection" Type="Microsoft.Build.Evaluation.ProjectCollection" Index="4" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="loadSettings" Type="Microsoft.Build.Evaluation.ProjectLoadSettings" Index="5" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="projectFile">Die Projektdatei.</param>
        <param name="globalProperties">Die globalen Eigenschaften. Ist möglicherweise NULL.</param>
        <param name="toolsVersion">Die Toolsversion. Ist möglicherweise NULL.</param>
        <param name="subToolsetVersion">Untertoolsetversion, mit der das Toolset explizit ausgewertet wird.  Ist möglicherweise NULL.</param>
        <param name="projectCollection">Die Sammlung, der dieses Projekt zugeordnet werden soll. Darf nicht NULL sein.</param>
        <param name="loadSettings">Die Ladeeinstellungen dieses Projekts.</param>
        <summary>Wird über eine vorhandene Projektdatei erstellt und mit angegebenen globalen Eigenschaften und der angegebenen Toolversion ausgewertet, die einzeln oder beide NULL sein können.
Das Projekt wird der globalen Projektsammlung hinzugefügt.
Löst InvalidProjectFileException aus, wenn die Auswertung fehlschlägt.
Löst InvalidOperationException aus, wenn bereits ein äquivalentes Projekt in die Projektsammlung geladen wurde.
Kann E/A-bezogene Ausnahmen auslösen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Projekt wird der angegebenen Projekt Auflistung hinzugefügt.  
  
 Löst InvalidProjectFileException aus, wenn die Auswertung fehlschlägt. Löst InvalidOperationException aus, wenn in der Projekt Auflistung bereits ein entsprechendes Projekt geladen ist. Kann e/a-bezogene Ausnahmen auslösen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Project (System.Xml.XmlReader xmlReader, System.Collections.Generic.IDictionary&lt;string,string&gt; globalProperties, string toolsVersion, string subToolsetVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xml.XmlReader xmlReader, class System.Collections.Generic.IDictionary`2&lt;string, string&gt; globalProperties, string toolsVersion, string subToolsetVersion, class Microsoft.Build.Evaluation.ProjectCollection projectCollection, valuetype Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.#ctor(System.Xml.XmlReader,System.Collections.Generic.IDictionary{System.String,System.String},System.String,System.String,Microsoft.Build.Evaluation.ProjectCollection,Microsoft.Build.Evaluation.ProjectLoadSettings)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (xmlReader As XmlReader, globalProperties As IDictionary(Of String, String), toolsVersion As String, subToolsetVersion As String, projectCollection As ProjectCollection, loadSettings As ProjectLoadSettings)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Project(System::Xml::XmlReader ^ xmlReader, System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ globalProperties, System::String ^ toolsVersion, System::String ^ subToolsetVersion, Microsoft::Build::Evaluation::ProjectCollection ^ projectCollection, Microsoft::Build::Evaluation::ProjectLoadSettings loadSettings);" />
      <MemberSignature Language="F#" Value="new Microsoft.Build.Evaluation.Project : System.Xml.XmlReader * System.Collections.Generic.IDictionary&lt;string, string&gt; * string * string * Microsoft.Build.Evaluation.ProjectCollection * Microsoft.Build.Evaluation.ProjectLoadSettings -&gt; Microsoft.Build.Evaluation.Project" Usage="new Microsoft.Build.Evaluation.Project (xmlReader, globalProperties, toolsVersion, subToolsetVersion, projectCollection, loadSettings)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="xmlReader" Type="System.Xml.XmlReader" Index="0" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="globalProperties" Type="System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;" Index="1" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="toolsVersion" Type="System.String" Index="2" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="subToolsetVersion" Type="System.String" Index="3" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="projectCollection" Type="Microsoft.Build.Evaluation.ProjectCollection" Index="4" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="loadSettings" Type="Microsoft.Build.Evaluation.ProjectLoadSettings" Index="5" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="xmlReader">XML-Reader zum Lesen von Projekten.</param>
        <param name="globalProperties">Globale Eigenschaften für die Auswertung. Ist möglicherweise NULL, in diesem Fall werden die globalen Eigenschaften der enthaltenden Projektauflistung verwendet.</param>
        <param name="toolsVersion">Toolsversion für die Auswertung. Kann NULL sein</param>
        <param name="subToolsetVersion">Untertoolsetversion, mit der das Toolset explizit ausgewertet wird.  Ist möglicherweise NULL.</param>
        <param name="projectCollection">Die Sammlung, der dieses Projekt zugeordnet werden soll. Darf nicht NULL sein.</param>
        <param name="loadSettings">Die Ladeeinstellungen dieses Projekts.</param>
        <summary>Wird über einen Textreader über die Projekt-XML erstellt und mit den globalen Eigenschaften der globalen Projektsammlung und der Standardversion der Tools ausgewertet, die einzeln oder beide NULL sein können.
Das Projekt wird der angegebenen Projektsammlung hinzugefügt, wenn es benannt wird.
Löst InvalidProjectFileException aus, wenn die Auswertung fehlschlägt.
Löst InvalidOperationException aus, wenn bereits ein äquivalentes Projekt in die Projektsammlung geladen wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Projekt wird der angegebenen Projekt Auflistung hinzugefügt, wenn entweder diesem Projekt oder dem angegebenen Projektstamm der vollständige Pfad zur Quell Projektdatei zugewiesen wird.  
  
 Löst InvalidProjectFileException aus, wenn die Auswertung fehlschlägt. Löst InvalidOperationException aus, wenn in der Projekt Auflistung bereits ein entsprechendes Projekt geladen ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddItem">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Fügt ein Element hinzu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddItem">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;Microsoft.Build.Evaluation.ProjectItem&gt; AddItem (string itemType, string unevaluatedInclude);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IList`1&lt;class Microsoft.Build.Evaluation.ProjectItem&gt; AddItem(string itemType, string unevaluatedInclude) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.AddItem(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddItem (itemType As String, unevaluatedInclude As String) As IList(Of ProjectItem)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IList&lt;Microsoft::Build::Evaluation::ProjectItem ^&gt; ^ AddItem(System::String ^ itemType, System::String ^ unevaluatedInclude);" />
      <MemberSignature Language="F#" Value="member this.AddItem : string * string -&gt; System.Collections.Generic.IList&lt;Microsoft.Build.Evaluation.ProjectItem&gt;" Usage="project.AddItem (itemType, unevaluatedInclude)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;Microsoft.Build.Evaluation.ProjectItem&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="itemType" Type="System.String" />
        <Parameter Name="unevaluatedInclude" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="itemType">Der Elementtyp des hinzugefügten Elements.</param>
        <param name="unevaluatedInclude">Include-Attribut des hinzuzufügenden Elements.</param>
        <summary>Fügt dem Projekt ein Element ohne Metadaten hinzu.
Anschließend können beliebige Metadaten hinzugefügt werden.
Ändert die XML nicht, wenn ein Platzhalterausdruck das neue Element bereits enthält.
Wertet nach bestem Bemühen aus: wird mit allen Elementen erweitert. Elemente, die in der XML unter dem neuen Element definiert sind, können verwendet werden, auch wenn sie es in einer realen Auswertung nicht wären.
Nur dieses Element wird ausgewertet. Andere Elemente, die davon abhängen könnten, sind nicht betroffen.
Dies ist eine praktische Möglichkeit, die nicht unbedingt dazu führt, dass sich das Projekt in einem völlig in sich stimmigen Zustand befindet.</summary>
        <returns>Das hinzugefügte Element.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alle Metadaten können später hinzugefügt werden. Ändert die Projekt Quelle nicht, wenn ein Platzhalter Ausdruck bereits das neue Element enthält.  
  
 Die Auswertung erfolgt auf Grundlage der bestmöglichen Leistung. Elemente, die in der Projekt Quelle nach dem neuen Element definiert sind, können für die Auswertung verwendet werden. Nur dieses Element wird ausgewertet. Andere Elemente, die möglicherweise von dieser abhängen, sind nicht betroffen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddItem">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;Microsoft.Build.Evaluation.ProjectItem&gt; AddItem (string itemType, string unevaluatedInclude, System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;string,string&gt;&gt; metadata);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IList`1&lt;class Microsoft.Build.Evaluation.ProjectItem&gt; AddItem(string itemType, string unevaluatedInclude, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, string&gt;&gt; metadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.AddItem(System.String,System.String,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}})" />
      <MemberSignature Language="VB.NET" Value="Public Function AddItem (itemType As String, unevaluatedInclude As String, metadata As IEnumerable(Of KeyValuePair(Of String, String))) As IList(Of ProjectItem)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IList&lt;Microsoft::Build::Evaluation::ProjectItem ^&gt; ^ AddItem(System::String ^ itemType, System::String ^ unevaluatedInclude, System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::String ^&gt;&gt; ^ metadata);" />
      <MemberSignature Language="F#" Value="member this.AddItem : string * string * seq&lt;System.Collections.Generic.KeyValuePair&lt;string, string&gt;&gt; -&gt; System.Collections.Generic.IList&lt;Microsoft.Build.Evaluation.ProjectItem&gt;" Usage="project.AddItem (itemType, unevaluatedInclude, metadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;Microsoft.Build.Evaluation.ProjectItem&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="itemType" Type="System.String" />
        <Parameter Name="unevaluatedInclude" Type="System.String" />
        <Parameter Name="metadata" Type="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.String&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="itemType">Der Elementtyp des hinzugefügten Elements.</param>
        <param name="unevaluatedInclude">Include-Attribut des hinzuzufügenden Elements.</param>
        <param name="metadata">Die Metadaten des hinzugefügten Elements.</param>
        <summary>Fügt dem Projekt ein Element mit Metadaten hinzu.
Metadaten sind möglicherweise NULL und geben keine Metadaten an.
Ändert die XML nicht, wenn ein Platzhalterausdruck das neue Element bereits enthält.
Wertet nach bestem Bemühen aus: wird mit allen Elementen erweitert. Elemente, die in der XML unter dem neuen Element definiert sind, können verwendet werden, auch wenn sie es in einer realen Auswertung nicht wären.
Nur dieses Element wird ausgewertet. Andere Elemente, die davon abhängen könnten, sind nicht betroffen.
Dies ist eine praktische Möglichkeit, die nicht unbedingt dazu führt, dass sich das Projekt in einem völlig in sich stimmigen Zustand befindet.</summary>
        <returns>Das hinzugefügte Element.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Metadaten können NULL sein. Dies bedeutet, dass keine Metadaten angezeigt werden.  
  
 Die Auswertung erfolgt auf Grundlage der bestmöglichen Leistung. Elemente, die in der Projekt Quelle nach dem neuen Element definiert sind, können für die Auswertung verwendet werden. Nur dieses Element wird ausgewertet. Andere Elemente, die möglicherweise von dieser abhängen, sind nicht betroffen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddItemFast">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Fügt dem Projekt ein Element ohne Metadaten hinzu.  Ermittelt nicht, ob ein vorhandener Platzhalter bereits mit dem neuen Element übereinstimmt, außer wenn es das erste Element in einer Elementgruppe ist.  Sucht das neue Element nicht in der Nähe ähnlicher Elemente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddItemFast">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;Microsoft.Build.Evaluation.ProjectItem&gt; AddItemFast (string itemType, string unevaluatedInclude);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IList`1&lt;class Microsoft.Build.Evaluation.ProjectItem&gt; AddItemFast(string itemType, string unevaluatedInclude) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.AddItemFast(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddItemFast (itemType As String, unevaluatedInclude As String) As IList(Of ProjectItem)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IList&lt;Microsoft::Build::Evaluation::ProjectItem ^&gt; ^ AddItemFast(System::String ^ itemType, System::String ^ unevaluatedInclude);" />
      <MemberSignature Language="F#" Value="member this.AddItemFast : string * string -&gt; System.Collections.Generic.IList&lt;Microsoft.Build.Evaluation.ProjectItem&gt;" Usage="project.AddItemFast (itemType, unevaluatedInclude)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;Microsoft.Build.Evaluation.ProjectItem&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="itemType" Type="System.String" />
        <Parameter Name="unevaluatedInclude" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="itemType">Der hinzuzufügende Elementtyp.</param>
        <param name="unevaluatedInclude">Das nicht ausgewertete Include-Attribut, das dem Element hinzugefügt werden soll.</param>
        <summary>Fügt dem Projekt ein Element ohne Metadaten hinzu.
Ermittelt nicht, ob ein vorhandener Platzhalter bereits mit dem neuen Element übereinstimmt, außer wenn es das erste Element in einer Elementgruppe ist.
Sucht das neue Element nicht in der Nähe ähnlicher Elemente.
Fügt das Element an die erste Elementgruppe an, die keine Bedingung hat und entweder keine untergeordneten Elemente hat oder deren erstes untergeordnete Element ein Element desselben Typs ist.
Wertet nach bestem Bemühen aus: wird mit allen Elementen erweitert. Elemente, die in der XML unter dem neuen Element definiert sind, können verwendet werden, auch wenn sie es in einer realen Auswertung nicht wären.
Nur dieses Element wird ausgewertet. Andere Elemente, die davon abhängen könnten, sind nicht betroffen.
Dies ist eine praktische Möglichkeit, die nicht unbedingt dazu führt, dass sich das Projekt in einem völlig in sich stimmigen Zustand befindet.</summary>
        <returns>Eine Liste der hinzugefügten Projektelemente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Fügt das Element an die erste Element Gruppe an, die nicht über eine Bedingung verfügt und entweder keine untergeordneten Elemente aufweist oder deren erstes untergeordnetes Element ein Element desselben Typs ist.  
  
 Wertet aus:-erweitert mit allen Elementen. Elemente, die in der XML-Datei unterhalb des neuen Elements definiert sind, können verwendet werden, obwohl Sie in einer realen Auswertung nicht wären.  
  
 Nur dieses Element wird ausgewertet. Andere Elemente, die möglicherweise von dieser abhängen, sind nicht betroffen.  
  
 Dies ist ein Vorteil, dass es verstanden wird, dass das Projekt nicht notwendigerweise in einem vollständig selbst konsistenten Zustand belassen wird, bis eine erneute Auswertung erfolgt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddItemFast">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;Microsoft.Build.Evaluation.ProjectItem&gt; AddItemFast (string itemType, string unevaluatedInclude, System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;string,string&gt;&gt; metadata);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IList`1&lt;class Microsoft.Build.Evaluation.ProjectItem&gt; AddItemFast(string itemType, string unevaluatedInclude, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, string&gt;&gt; metadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.AddItemFast(System.String,System.String,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}})" />
      <MemberSignature Language="VB.NET" Value="Public Function AddItemFast (itemType As String, unevaluatedInclude As String, metadata As IEnumerable(Of KeyValuePair(Of String, String))) As IList(Of ProjectItem)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IList&lt;Microsoft::Build::Evaluation::ProjectItem ^&gt; ^ AddItemFast(System::String ^ itemType, System::String ^ unevaluatedInclude, System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::String ^&gt;&gt; ^ metadata);" />
      <MemberSignature Language="F#" Value="member this.AddItemFast : string * string * seq&lt;System.Collections.Generic.KeyValuePair&lt;string, string&gt;&gt; -&gt; System.Collections.Generic.IList&lt;Microsoft.Build.Evaluation.ProjectItem&gt;" Usage="project.AddItemFast (itemType, unevaluatedInclude, metadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;Microsoft.Build.Evaluation.ProjectItem&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="itemType" Type="System.String" />
        <Parameter Name="unevaluatedInclude" Type="System.String" />
        <Parameter Name="metadata" Type="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.String&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="itemType">Der hinzuzufügende Elementtyp.</param>
        <param name="unevaluatedInclude">Das nicht ausgewertete Include-Attribut, das dem Element hinzugefügt werden soll.</param>
        <param name="metadata">Die Metadaten, die hinzugefügt werden sollen.</param>
        <summary>Fügt dem Projekt ein Element mit Metadaten hinzu.
Metadaten sind möglicherweise NULL und geben keine Metadaten an.
Ermittelt nicht, ob ein vorhandener Platzhalter bereits mit dem neuen Element übereinstimmt, außer wenn es das erste Element in einer Elementgruppe ist.
Sucht das neue Element nicht in der Nähe ähnlicher Elemente.
Fügt das Element an die erste Elementgruppe an, die keine Bedingung hat und entweder keine untergeordneten Elemente hat oder deren erstes untergeordnete Element ein Element desselben Typs ist.
Wertet nach bestem Bemühen aus: wird mit allen Elementen erweitert. Elemente, die in der XML unter dem neuen Element definiert sind, können verwendet werden, auch wenn sie es in einer realen Auswertung nicht wären.
Nur dieses Element wird ausgewertet. Andere Elemente, die davon abhängen könnten, sind nicht betroffen.
Dies ist eine praktische Möglichkeit, die nicht unbedingt dazu führt, dass sich das Projekt in einem völlig in sich stimmigen Zustand befindet.</summary>
        <returns>Eine Liste der hinzugefügten Projektelemente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Fügt das Element an die erste Element Gruppe an, die nicht über eine Bedingung verfügt und entweder keine untergeordneten Elemente aufweist oder deren erstes untergeordnetes Element ein Element desselben Typs ist.  
  
 Wertet aus:-erweitert mit allen Elementen. Elemente, die in der XML-Datei unterhalb des neuen Elements definiert sind, können verwendet werden, obwohl Sie in einer realen Auswertung nicht wären.  
  
 Nur dieses Element wird ausgewertet. Andere Elemente, die möglicherweise von dieser abhängen, sind nicht betroffen.  
  
 Dies ist ein Vorteil, dass es verstanden wird, dass das Projekt nicht notwendigerweise in einem vollständig selbst konsistenten Zustand belassen wird, bis eine erneute Auswertung erfolgt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllEvaluatedItemDefinitionMetadata">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectMetadata&gt; AllEvaluatedItemDefinitionMetadata { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;class Microsoft.Build.Evaluation.ProjectMetadata&gt; AllEvaluatedItemDefinitionMetadata" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.AllEvaluatedItemDefinitionMetadata" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AllEvaluatedItemDefinitionMetadata As ICollection(Of ProjectMetadata)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::ICollection&lt;Microsoft::Build::Evaluation::ProjectMetadata ^&gt; ^ AllEvaluatedItemDefinitionMetadata { System::Collections::Generic::ICollection&lt;Microsoft::Build::Evaluation::ProjectMetadata ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AllEvaluatedItemDefinitionMetadata : System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectMetadata&gt;" Usage="Microsoft.Build.Evaluation.Project.AllEvaluatedItemDefinitionMetadata" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectMetadata&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Elementdefinitionsmetadaten, die bei der Auswertung gefunden wurden. Diese werden beim zweiten Auswertungsdurchlauf gelesen.
Im Gegensatz zu denen, die von der ItemDefinitions-Eigenschaft zurückgegeben werden, sind diese geordnet und enthalten alle Metadaten, die später von anderen mit dem gleichen Namen und Elementtyp überschrieben wurden. Enthält keine Elemente, deren Bedingungen nicht als TRUE ausgewertet wurden.
Enthält keine Metadaten zur Elementdefinition, die seit der letzten Auswertung hinzugefügt wurden.</summary>
        <value>Alle Element Definitions Metadaten, die während der Auswertung gefunden wurden. Dies schließt keine Elemente ein, deren Bedingungen nicht true ergeben haben, und keine seit der letzten Auswertung hinzugefügten Elementdefinitionsmetadaten.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Element Metadaten werden während der zweiten Evaluierungsphase gelesen. Im Unterschied zu den Metadaten, die von der itemdefinitions-Eigenschaft zurückgegeben werden, werden diese Metadaten geordnet und enthalten alle Metadaten, die anschließend mit demselben Namen und Elementtyp überschrieben werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllEvaluatedItems">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectItem&gt; AllEvaluatedItems { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;class Microsoft.Build.Evaluation.ProjectItem&gt; AllEvaluatedItems" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.AllEvaluatedItems" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AllEvaluatedItems As ICollection(Of ProjectItem)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::ICollection&lt;Microsoft::Build::Evaluation::ProjectItem ^&gt; ^ AllEvaluatedItems { System::Collections::Generic::ICollection&lt;Microsoft::Build::Evaluation::ProjectItem ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AllEvaluatedItems : System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectItem&gt;" Usage="Microsoft.Build.Evaluation.Project.AllEvaluatedItems" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectItem&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Die bei der Auswertung gefundenen Elemente. Diese werden beim dritten Auswertungsdurchlauf gelesen.
Im Gegensatz zu denen, die von der Items-Eigenschaft zurückgegeben werden, werden diese in Bezug auf alle anderen Elemente, die während der Auswertung gefunden werden, und nicht nur in Bezug auf Elemente desselben Elementtyps geordnet.
In einigen Anwendungen, wie z. B. der Sprache F#, ist diese vollständige gegenseitige Anordnung von Bedeutung, und solche Hosts können diese Eigenschaft nutzen.
Enthält keine Elemente, deren Bedingungen nicht als TRUE ausgewertet wurden.
Enthält keine Elemente, die seit der letzten Auswertung hinzugefügt wurden.</summary>
        <value>Ein Enumerator für alle Elemente, die während der Auswertung gefunden wurden. Diese werden beim dritten Auswertungsdurchlauf gelesen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Im Gegensatz zu den Elementen, die von der Items-Eigenschaft zurückgegeben werden, werden diese in Bezug auf alle anderen Elemente, die während der Auswertung gefunden werden, angeordnet, nicht nur in Bezug auf Elemente desselben Elementtyps.  
  
 Bei manchen Anwendungen ist diese gesamte gegenseitige Reihenfolge von Bedeutung, und solche Hosts können diese Eigenschaft verwenden.  
  
 Die-Enumeration enthält keine Elemente, deren Bedingungen nicht als true ausgewertet wurden, und enthält auch keine Elemente, die seit der letzten Auswertung hinzugefügt wurden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllEvaluatedProperties">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectProperty&gt; AllEvaluatedProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;class Microsoft.Build.Evaluation.ProjectProperty&gt; AllEvaluatedProperties" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.AllEvaluatedProperties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AllEvaluatedProperties As ICollection(Of ProjectProperty)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::ICollection&lt;Microsoft::Build::Evaluation::ProjectProperty ^&gt; ^ AllEvaluatedProperties { System::Collections::Generic::ICollection&lt;Microsoft::Build::Evaluation::ProjectProperty ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AllEvaluatedProperties : System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectProperty&gt;" Usage="Microsoft.Build.Evaluation.Project.AllEvaluatedProperties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectProperty&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Eigenschaften, die bei der Auswertung gefunden wurden. Diese werden beim ersten Auswertungsdurchlauf gelesen.
Im Gegensatz zu denen, die von der Properties-Eigenschaft zurückgegeben werden, sind diese geordnet und enthalten Eigenschaften, die später von anderen mit dem gleichen Namen überschrieben wurden. Enthält keine Eigenschaften, deren Bedingungen nicht als TRUE ausgewertet wurden.
Enthält keine Eigenschaften, die seit der letzten Auswertung hinzugefügt wurden.</summary>
        <value>Alle während der Auswertung gefundenen Eigenschaften. Dies schließt keine Eigenschaften ein, deren Bedingungen nicht true ergeben haben, und keine seit der letzten Auswertung hinzugefügten Eigenschaften.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaften werden während der ersten Evaluierungsphase gelesen. Anders als Eigenschaften, die von der Properties-Eigenschaft zurückgegeben werden, werden diese geordnet und enthalten alle Eigenschaften, die anschließend mit dem gleichen Namen überschrieben werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Build">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt dieses Projekt mit den Standardzielen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Build">
      <MemberSignature Language="C#" Value="public bool Build ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Build() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.Build" />
      <MemberSignature Language="VB.NET" Value="Public Function Build () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Build();" />
      <MemberSignature Language="F#" Value="member this.Build : unit -&gt; bool" Usage="project.Build " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Startet einen Build mithilfe dieses Projekts und erstellt die Standardziele.
Gibt bei Erfolg true zurück, bei einem Fehler false.
Funktioniert bei einer privat geklonten Instanz. Um für Buildzwecke virtuelle Elemente festzulegen oder abzurufen, klonen Sie eine Instanz explizit, und erstellen Sie einen Build dafür.
Ändert das Project-Objekt nicht.</summary>
        <returns><see langword="true" /> bei Erfolg, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um virtuelle Elemente für buildzwecke festzulegen oder zu erhalten, Klonen Sie explizit eine Projekt Instanz, und erstellen Sie diese. Mit dieser Methode wird das Projekt Objekt nicht geändert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Build">
      <MemberSignature Language="C#" Value="public bool Build (Microsoft.Build.Framework.ILogger logger);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Build(class Microsoft.Build.Framework.ILogger logger) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.Build(Microsoft.Build.Framework.ILogger)" />
      <MemberSignature Language="VB.NET" Value="Public Function Build (logger As ILogger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Build(Microsoft::Build::Framework::ILogger ^ logger);" />
      <MemberSignature Language="F#" Value="member this.Build : Microsoft.Build.Framework.ILogger -&gt; bool" Usage="project.Build logger" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logger" Type="Microsoft.Build.Framework.ILogger" />
      </Parameters>
      <Docs>
        <param name="logger">Die Protokollierung, die bei der Builderstellung verwendet werden soll.</param>
        <summary>Startet einen Build mit diesem Projekt, wobei die Standardziele und die angegebene Protokollierung erstellt werden.
Gibt bei Erfolg true zurück, bei einem Fehler false.
Funktioniert bei einer privat geklonten Instanz. Um für Buildzwecke virtuelle Elemente festzulegen oder abzurufen, klonen Sie eine Instanz explizit, und erstellen Sie einen Build dafür.
Ändert das Project-Objekt nicht.</summary>
        <returns><see langword="true" /> bei Erfolg, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um virtuelle Elemente für buildzwecke festzulegen oder zu erhalten, Klonen Sie explizit eine Projekt Instanz, und erstellen Sie diese. Mit dieser Methode wird das Projekt Objekt nicht geändert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Build">
      <MemberSignature Language="C#" Value="public bool Build (System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Framework.ILogger&gt; loggers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Build(class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.Build.Framework.ILogger&gt; loggers) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.Build(System.Collections.Generic.IEnumerable{Microsoft.Build.Framework.ILogger})" />
      <MemberSignature Language="VB.NET" Value="Public Function Build (loggers As IEnumerable(Of ILogger)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Build(System::Collections::Generic::IEnumerable&lt;Microsoft::Build::Framework::ILogger ^&gt; ^ loggers);" />
      <MemberSignature Language="F#" Value="member this.Build : seq&lt;Microsoft.Build.Framework.ILogger&gt; -&gt; bool" Usage="project.Build loggers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="loggers" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Framework.ILogger&gt;" />
      </Parameters>
      <Docs>
        <param name="loggers">Ein Enumerator über alle Protokollierungen, die bei der Builderstellung verwendet werden sollen.</param>
        <summary>Startet einen Build mit diesem Projekt, wobei die Standardziele und die angegebene Protokollierung erstellt werden.
Gibt bei Erfolg true zurück, bei einem Fehler false.
Funktioniert bei einer privat geklonten Instanz. Um für Buildzwecke virtuelle Elemente festzulegen oder abzurufen, klonen Sie eine Instanz explizit, und erstellen Sie einen Build dafür.
Ändert das Project-Objekt nicht.</summary>
        <returns><see langword="true" /> bei Erfolg, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um virtuelle Elemente für buildzwecke festzulegen oder zu erhalten, Klonen Sie explizit eine Projekt Instanz, und erstellen Sie diese. Mit dieser Methode wird das Projekt Objekt nicht geändert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Build">
      <MemberSignature Language="C#" Value="public bool Build (string target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Build(string target) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.Build(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Build (target As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Build(System::String ^ target);" />
      <MemberSignature Language="F#" Value="member this.Build : string -&gt; bool" Usage="project.Build target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="target">Das zu erstellende Ziel.</param>
        <summary>Startet einen Build mithilfe dieses Projekts und erstellt das angegebene Ziel.
Gibt bei Erfolg true zurück, bei einem Fehler false.
Funktioniert bei einer privat geklonten Instanz. Um für Buildzwecke virtuelle Elemente festzulegen oder abzurufen, klonen Sie eine Instanz explizit, und erstellen Sie einen Build dafür.
Ändert das Project-Objekt nicht.</summary>
        <returns><see langword="true" /> bei Erfolg, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um virtuelle Elemente für buildzwecke festzulegen oder zu erhalten, Klonen Sie explizit eine Projekt Instanz, und erstellen Sie diese. Mit dieser Methode wird das Projekt Objekt nicht geändert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Build">
      <MemberSignature Language="C#" Value="public bool Build (string[] targets);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Build(string[] targets) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.Build(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Build (targets As String()) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Build(cli::array &lt;System::String ^&gt; ^ targets);" />
      <MemberSignature Language="F#" Value="member this.Build : string[] -&gt; bool" Usage="project.Build targets" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targets" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="targets">Ein Array von Zielen, das erstellt werden soll.</param>
        <summary>Startet einen Build mithilfe dieses Projekts und erstellt die angegebenen Ziele.
Gibt bei Erfolg true zurück, bei einem Fehler false.
Funktioniert bei einer privat geklonten Instanz. Um für Buildzwecke virtuelle Elemente festzulegen oder abzurufen, klonen Sie eine Instanz explizit, und erstellen Sie einen Build dafür.
Ändert das Project-Objekt nicht.</summary>
        <returns><see langword="true" /> bei Erfolg, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um virtuelle Elemente für buildzwecke festzulegen oder zu erhalten, Klonen Sie explizit eine Projekt Instanz, und erstellen Sie diese. Mit dieser Methode wird das Projekt Objekt nicht geändert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Build">
      <MemberSignature Language="C#" Value="public bool Build (System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Framework.ILogger&gt; loggers, System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Logging.ForwardingLoggerRecord&gt; remoteLoggers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Build(class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.Build.Framework.ILogger&gt; loggers, class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.Build.Logging.ForwardingLoggerRecord&gt; remoteLoggers) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.Build(System.Collections.Generic.IEnumerable{Microsoft.Build.Framework.ILogger},System.Collections.Generic.IEnumerable{Microsoft.Build.Logging.ForwardingLoggerRecord})" />
      <MemberSignature Language="VB.NET" Value="Public Function Build (loggers As IEnumerable(Of ILogger), remoteLoggers As IEnumerable(Of ForwardingLoggerRecord)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Build(System::Collections::Generic::IEnumerable&lt;Microsoft::Build::Framework::ILogger ^&gt; ^ loggers, System::Collections::Generic::IEnumerable&lt;Microsoft::Build::Logging::ForwardingLoggerRecord ^&gt; ^ remoteLoggers);" />
      <MemberSignature Language="F#" Value="member this.Build : seq&lt;Microsoft.Build.Framework.ILogger&gt; * seq&lt;Microsoft.Build.Logging.ForwardingLoggerRecord&gt; -&gt; bool" Usage="project.Build (loggers, remoteLoggers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="loggers" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Framework.ILogger&gt;" />
        <Parameter Name="remoteLoggers" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Logging.ForwardingLoggerRecord&gt;" />
      </Parameters>
      <Docs>
        <param name="loggers">Die Protokollierungen, die bei der Builderstellung verwendet werden sollen.</param>
        <param name="remoteLoggers">Die Remoteprotokollierungen, die bei der Builderstellung verwendet werden sollen.</param>
        <summary>Startet einen Build mit diesem Projekt, wobei die Standardziele und die angegebene Protokollierung erstellt werden.
Gibt bei Erfolg true zurück, bei einem Fehler false.
Funktioniert bei einer privat geklonten Instanz. Um für Buildzwecke virtuelle Elemente festzulegen oder abzurufen, klonen Sie eine Instanz explizit, und erstellen Sie einen Build dafür.
Ändert das Project-Objekt nicht.</summary>
        <returns><see langword="true" /> bei Erfolg, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um virtuelle Elemente für buildzwecke festzulegen oder zu erhalten, Klonen Sie explizit eine Projekt Instanz, und erstellen Sie diese. Mit dieser Methode wird das Projekt Objekt nicht geändert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Build">
      <MemberSignature Language="C#" Value="public bool Build (string target, System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Framework.ILogger&gt; loggers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Build(string target, class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.Build.Framework.ILogger&gt; loggers) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.Build(System.String,System.Collections.Generic.IEnumerable{Microsoft.Build.Framework.ILogger})" />
      <MemberSignature Language="VB.NET" Value="Public Function Build (target As String, loggers As IEnumerable(Of ILogger)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Build(System::String ^ target, System::Collections::Generic::IEnumerable&lt;Microsoft::Build::Framework::ILogger ^&gt; ^ loggers);" />
      <MemberSignature Language="F#" Value="member this.Build : string * seq&lt;Microsoft.Build.Framework.ILogger&gt; -&gt; bool" Usage="project.Build (target, loggers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.String" />
        <Parameter Name="loggers" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Framework.ILogger&gt;" />
      </Parameters>
      <Docs>
        <param name="target">Das zu erstellende Ziel.</param>
        <param name="loggers">Die Protokollierungen, die bei der Builderstellung verwendet werden sollen.</param>
        <summary>Startet einen Build mithilfe dieses Projekts und erstellt das angegebene Ziel mit den angegebenen Protokollierungen.
Gibt bei Erfolg true zurück, bei einem Fehler false.
Funktioniert bei einer privat geklonten Instanz. Um für Buildzwecke virtuelle Elemente festzulegen oder abzurufen, klonen Sie eine Instanz explizit, und erstellen Sie einen Build dafür.
Ändert das Project-Objekt nicht.</summary>
        <returns><see langword="true" /> bei Erfolg, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um virtuelle Elemente für buildzwecke festzulegen oder zu erhalten, Klonen Sie explizit eine Projekt Instanz, und erstellen Sie diese. Mit dieser Methode wird das Projekt Objekt nicht geändert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Build">
      <MemberSignature Language="C#" Value="public bool Build (string[] targets, System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Framework.ILogger&gt; loggers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Build(string[] targets, class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.Build.Framework.ILogger&gt; loggers) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.Build(System.String[],System.Collections.Generic.IEnumerable{Microsoft.Build.Framework.ILogger})" />
      <MemberSignature Language="VB.NET" Value="Public Function Build (targets As String(), loggers As IEnumerable(Of ILogger)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Build(cli::array &lt;System::String ^&gt; ^ targets, System::Collections::Generic::IEnumerable&lt;Microsoft::Build::Framework::ILogger ^&gt; ^ loggers);" />
      <MemberSignature Language="F#" Value="member this.Build : string[] * seq&lt;Microsoft.Build.Framework.ILogger&gt; -&gt; bool" Usage="project.Build (targets, loggers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targets" Type="System.String[]" />
        <Parameter Name="loggers" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Framework.ILogger&gt;" />
      </Parameters>
      <Docs>
        <param name="targets">Die zu erstellenden Ziele.</param>
        <param name="loggers">Die Protokollierungen, die bei der Builderstellung verwendet werden sollen.</param>
        <summary>Startet einen Build mithilfe dieses Projekts und erstellt das angegebene Ziel mit den angegebenen Protokollierungen.
Gibt bei Erfolg true zurück, bei einem Fehler false.
Wenn der Build für dieses Projekt deaktiviert ist, erfolgt kein Build, und es wird FALSE zurückgegeben.
Funktioniert bei einer privat geklonten Instanz. Um für Buildzwecke virtuelle Elemente festzulegen oder abzurufen, klonen Sie eine Instanz explizit, und erstellen Sie einen Build dafür.
Ändert das Project-Objekt nicht.</summary>
        <returns><see langword="true" /> bei Erfolg, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um virtuelle Elemente für buildzwecke festzulegen oder zu erhalten, Klonen Sie explizit eine Projekt Instanz, und erstellen Sie diese. Mit dieser Methode wird das Projekt Objekt nicht geändert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Build">
      <MemberSignature Language="C#" Value="public bool Build (string target, System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Framework.ILogger&gt; loggers, System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Logging.ForwardingLoggerRecord&gt; remoteLoggers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Build(string target, class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.Build.Framework.ILogger&gt; loggers, class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.Build.Logging.ForwardingLoggerRecord&gt; remoteLoggers) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.Build(System.String,System.Collections.Generic.IEnumerable{Microsoft.Build.Framework.ILogger},System.Collections.Generic.IEnumerable{Microsoft.Build.Logging.ForwardingLoggerRecord})" />
      <MemberSignature Language="VB.NET" Value="Public Function Build (target As String, loggers As IEnumerable(Of ILogger), remoteLoggers As IEnumerable(Of ForwardingLoggerRecord)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Build(System::String ^ target, System::Collections::Generic::IEnumerable&lt;Microsoft::Build::Framework::ILogger ^&gt; ^ loggers, System::Collections::Generic::IEnumerable&lt;Microsoft::Build::Logging::ForwardingLoggerRecord ^&gt; ^ remoteLoggers);" />
      <MemberSignature Language="F#" Value="member this.Build : string * seq&lt;Microsoft.Build.Framework.ILogger&gt; * seq&lt;Microsoft.Build.Logging.ForwardingLoggerRecord&gt; -&gt; bool" Usage="project.Build (target, loggers, remoteLoggers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.String" />
        <Parameter Name="loggers" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Framework.ILogger&gt;" />
        <Parameter Name="remoteLoggers" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Logging.ForwardingLoggerRecord&gt;" />
      </Parameters>
      <Docs>
        <param name="target">Das zu erstellende Ziel.</param>
        <param name="loggers">Die Protokollierungen, die bei der Builderstellung verwendet werden sollen.</param>
        <param name="remoteLoggers">Die Remoteprotokollierungen, die bei der Builderstellung verwendet werden sollen.</param>
        <summary>Startet einen Build mithilfe dieses Projekts und erstellt das angegebene Ziel mit den angegebenen Protokollierungen.
Gibt bei Erfolg true zurück, bei einem Fehler false.
Funktioniert bei einer privat geklonten Instanz. Um für Buildzwecke virtuelle Elemente festzulegen oder abzurufen, klonen Sie eine Instanz explizit, und erstellen Sie einen Build dafür.
Ändert das Project-Objekt nicht.</summary>
        <returns><see langword="true" /> bei Erfolg, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um virtuelle Elemente für buildzwecke festzulegen oder zu erhalten, Klonen Sie explizit eine Projekt Instanz, und erstellen Sie diese. Mit dieser Methode wird das Projekt Objekt nicht geändert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Build">
      <MemberSignature Language="C#" Value="public bool Build (string[] targets, System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Framework.ILogger&gt; loggers, System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Logging.ForwardingLoggerRecord&gt; remoteLoggers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Build(string[] targets, class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.Build.Framework.ILogger&gt; loggers, class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.Build.Logging.ForwardingLoggerRecord&gt; remoteLoggers) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.Build(System.String[],System.Collections.Generic.IEnumerable{Microsoft.Build.Framework.ILogger},System.Collections.Generic.IEnumerable{Microsoft.Build.Logging.ForwardingLoggerRecord})" />
      <MemberSignature Language="VB.NET" Value="Public Function Build (targets As String(), loggers As IEnumerable(Of ILogger), remoteLoggers As IEnumerable(Of ForwardingLoggerRecord)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Build(cli::array &lt;System::String ^&gt; ^ targets, System::Collections::Generic::IEnumerable&lt;Microsoft::Build::Framework::ILogger ^&gt; ^ loggers, System::Collections::Generic::IEnumerable&lt;Microsoft::Build::Logging::ForwardingLoggerRecord ^&gt; ^ remoteLoggers);" />
      <MemberSignature Language="F#" Value="member this.Build : string[] * seq&lt;Microsoft.Build.Framework.ILogger&gt; * seq&lt;Microsoft.Build.Logging.ForwardingLoggerRecord&gt; -&gt; bool" Usage="project.Build (targets, loggers, remoteLoggers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targets" Type="System.String[]" />
        <Parameter Name="loggers" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Framework.ILogger&gt;" />
        <Parameter Name="remoteLoggers" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Logging.ForwardingLoggerRecord&gt;" />
      </Parameters>
      <Docs>
        <param name="targets">Die zu erstellenden Ziele.</param>
        <param name="loggers">Die Protokollierungen, die bei der Builderstellung verwendet werden sollen.</param>
        <param name="remoteLoggers">Die Remoteprotokollierungen, die bei der Builderstellung verwendet werden sollen.</param>
        <summary>Startet einen Build mithilfe dieses Projekts und erstellt das angegebene Ziel mit den angegebenen Protokollierungen.
Gibt bei Erfolg true zurück, bei einem Fehler false.
Wenn der Build für dieses Projekt deaktiviert ist, erfolgt kein Build, und es wird FALSE zurückgegeben.
Funktioniert bei einer privat geklonten Instanz. Um für Buildzwecke virtuelle Elemente festzulegen oder abzurufen, klonen Sie eine Instanz explizit, und erstellen Sie einen Build dafür.
Ändert das Project-Objekt nicht.</summary>
        <returns><see langword="true" /> bei Erfolg, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um virtuelle Elemente für buildzwecke festzulegen oder zu erhalten, Klonen Sie explizit eine Projekt Instanz, und erstellen Sie diese. Mit dieser Methode wird das Projekt Objekt nicht geändert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Build">
      <MemberSignature Language="C#" Value="public bool Build (string[] targets, System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Framework.ILogger&gt; loggers, System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Logging.ForwardingLoggerRecord&gt; remoteLoggers, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Build(string[] targets, class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.Build.Framework.ILogger&gt; loggers, class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.Build.Logging.ForwardingLoggerRecord&gt; remoteLoggers, class Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.Build(System.String[],System.Collections.Generic.IEnumerable{Microsoft.Build.Framework.ILogger},System.Collections.Generic.IEnumerable{Microsoft.Build.Logging.ForwardingLoggerRecord},Microsoft.Build.Evaluation.Context.EvaluationContext)" />
      <MemberSignature Language="VB.NET" Value="Public Function Build (targets As String(), loggers As IEnumerable(Of ILogger), remoteLoggers As IEnumerable(Of ForwardingLoggerRecord), evaluationContext As EvaluationContext) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Build(cli::array &lt;System::String ^&gt; ^ targets, System::Collections::Generic::IEnumerable&lt;Microsoft::Build::Framework::ILogger ^&gt; ^ loggers, System::Collections::Generic::IEnumerable&lt;Microsoft::Build::Logging::ForwardingLoggerRecord ^&gt; ^ remoteLoggers, Microsoft::Build::Evaluation::Context::EvaluationContext ^ evaluationContext);" />
      <MemberSignature Language="F#" Value="member this.Build : string[] * seq&lt;Microsoft.Build.Framework.ILogger&gt; * seq&lt;Microsoft.Build.Logging.ForwardingLoggerRecord&gt; * Microsoft.Build.Evaluation.Context.EvaluationContext -&gt; bool" Usage="project.Build (targets, loggers, remoteLoggers, evaluationContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targets" Type="System.String[]" Index="0" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
        <Parameter Name="loggers" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Framework.ILogger&gt;" Index="1" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
        <Parameter Name="remoteLoggers" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Logging.ForwardingLoggerRecord&gt;" Index="2" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
        <Parameter Name="evaluationContext" Type="Microsoft.Build.Evaluation.Context.EvaluationContext" Index="3" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
      </Parameters>
      <Docs>
        <param name="targets">To be added.</param>
        <param name="loggers">To be added.</param>
        <param name="remoteLoggers">To be added.</param>
        <param name="evaluationContext">Der Auswertungskontext für den Fall, dass eine Neuauswertung erforderlich ist</param>
        <summary>Siehe <see cref="M:Microsoft.Build.Evaluation.Project.Build(System.String[],System.Collections.Generic.IEnumerable{Microsoft.Build.Framework.ILogger},System.Collections.Generic.IEnumerable{Microsoft.Build.Logging.ForwardingLoggerRecord})" />.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ConditionedProperties">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IDictionary&lt;string,System.Collections.Generic.List&lt;string&gt;&gt; ConditionedProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IDictionary`2&lt;string, class System.Collections.Generic.List`1&lt;string&gt;&gt; ConditionedProperties" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.ConditionedProperties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ConditionedProperties As IDictionary(Of String, List(Of String))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IDictionary&lt;System::String ^, System::Collections::Generic::List&lt;System::String ^&gt; ^&gt; ^ ConditionedProperties { System::Collections::Generic::IDictionary&lt;System::String ^, System::Collections::Generic::List&lt;System::String ^&gt; ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ConditionedProperties : System.Collections.Generic.IDictionary&lt;string, System.Collections.Generic.List&lt;string&gt;&gt;" Usage="Microsoft.Build.Evaluation.Project.ConditionedProperties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="msbuild-15;msbuild-15-netcore;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.Collections.Generic.List&lt;System.String&gt;&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Sammlung möglicher Werte, die für die in den Bedingungen enthaltenen Eigenschaften impliziert sind, die für Eigenschaften, Eigenschaftengruppen, Importe und Instanzen von „When“ gefunden wurden.
            
Wenn z. B. die folgenden Bedingungen für Eigenschaften in einem Projekt vorhanden sind: 
Condition="'$(Configuration)|$(Platform)' == 'Debug|x86'" Condition="'$(Configuration)' == 'Release'" 
wird die Tabelle mit Folgendem aufgefüllt 
{ "Configuration", { "Debug", "Release" }} { "Platform", { "x86" }} 
Dies wird von Visual Studio verwendet, um die im Projekt definierten Konfigurationen zu bestimmen.</summary>
        <value>Eine Auflistung möglicher Eigenschaftswerte für Eigenschaften, die verwendet werden, um Bedingungen auszuwerten, die für Eigenschaften, Eigenschaften Gruppen, Importe und wann es gefunden werden. Die Auflistung erfolgt in kanonischer Form. Der Name des Eintrags ist der Name der auszuwertenden Eigenschaft, und der Wert ist eine Liste möglicher Eigenschaftswerte.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn z. b. die folgenden Bedingungen für Eigenschaften in einem Projekt vorhanden sind: Condition = "' $ (Configuration) &#124;$ (Platform) ' = = ' Debug&#124;x86 '" Condition = "' $ (Configuration) ' = = ' Release '", wird die Tabelle mit {"Configuration" aufgefüllt. {"Debug", "Release"}} {"Platform", {"x86"}} diese Sammlung wird von Visual Studio verwendet, um die Konfigurationen zu ermitteln, die im Projekt definiert sind.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateProjectInstance">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt eine Projektinstanz auf Grundlage dieses Projekts, aber vollständig davon getrennt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kann zur unabhängigen Erstellung verwendet werden. Das ursprüngliche Projekt wird ausgewertet, bevor die Instanz erstellt wird, falls erforderlich, damit das ursprüngliche Projekt als nicht geändert markiert wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateProjectInstance">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Execution.ProjectInstance CreateProjectInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Build.Execution.ProjectInstance CreateProjectInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.CreateProjectInstance" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateProjectInstance () As ProjectInstance" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Build::Execution::ProjectInstance ^ CreateProjectInstance();" />
      <MemberSignature Language="F#" Value="member this.CreateProjectInstance : unit -&gt; Microsoft.Build.Execution.ProjectInstance" Usage="project.CreateProjectInstance " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Execution.ProjectInstance</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine auf diesem Projekt basierende Instanz ohne jegliche Verbindung zurück.
Diese Instanz kann für einen unabhängigen Build verwendet werden.
Ehe die Instanz erstellt wird, wird das Projekt, falls erforderlich, neu ausgewertet, damit es nicht geändert wird.</summary>
        <returns>Die Projektinstanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kann zur unabhängigen Erstellung verwendet werden. Das ursprüngliche Projekt wird ausgewertet, bevor die Instanz erstellt wird, falls erforderlich, damit das ursprüngliche Projekt als nicht geändert markiert wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateProjectInstance">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Execution.ProjectInstance CreateProjectInstance (Microsoft.Build.Execution.ProjectInstanceSettings settings);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Build.Execution.ProjectInstance CreateProjectInstance(valuetype Microsoft.Build.Execution.ProjectInstanceSettings settings) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.CreateProjectInstance(Microsoft.Build.Execution.ProjectInstanceSettings)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateProjectInstance (settings As ProjectInstanceSettings) As ProjectInstance" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Build::Execution::ProjectInstance ^ CreateProjectInstance(Microsoft::Build::Execution::ProjectInstanceSettings settings);" />
      <MemberSignature Language="F#" Value="member this.CreateProjectInstance : Microsoft.Build.Execution.ProjectInstanceSettings -&gt; Microsoft.Build.Execution.ProjectInstance" Usage="project.CreateProjectInstance settings" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Execution.ProjectInstance</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="settings" Type="Microsoft.Build.Execution.ProjectInstanceSettings" Index="0" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="settings">Bestimmt, ob die erstellte Projektinstanz unveränderlich ist und ob sie eine Nachschlagetabelle zur Verbesserung der Leistung enthält.</param>
        <summary>Gibt eine auf diesem Projekt basierende Instanz ohne jegliche Verbindung zurück.
Diese Instanz kann für einen unabhängigen Build verwendet werden.
Ehe die Instanz erstellt wird, wird das Projekt, falls erforderlich, neu ausgewertet, damit es nicht geändert wird.
Die Instanz ist unveränderlich. Keines der Objekte, die sie bilden, kann verändert werden. Dadurch ist der gleichzeitige Zugriff durch mehrere Threads sicher.</summary>
        <returns>Die Projektinstanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kann zur unabhängigen Erstellung verwendet werden. Das ursprüngliche Projekt wird ausgewertet, bevor die Instanz erstellt wird, falls erforderlich, damit das ursprüngliche Projekt als nicht geändert markiert wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateProjectInstance">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Execution.ProjectInstance CreateProjectInstance (Microsoft.Build.Execution.ProjectInstanceSettings settings, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Build.Execution.ProjectInstance CreateProjectInstance(valuetype Microsoft.Build.Execution.ProjectInstanceSettings settings, class Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.CreateProjectInstance(Microsoft.Build.Execution.ProjectInstanceSettings,Microsoft.Build.Evaluation.Context.EvaluationContext)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateProjectInstance (settings As ProjectInstanceSettings, evaluationContext As EvaluationContext) As ProjectInstance" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Build::Execution::ProjectInstance ^ CreateProjectInstance(Microsoft::Build::Execution::ProjectInstanceSettings settings, Microsoft::Build::Evaluation::Context::EvaluationContext ^ evaluationContext);" />
      <MemberSignature Language="F#" Value="member this.CreateProjectInstance : Microsoft.Build.Execution.ProjectInstanceSettings * Microsoft.Build.Evaluation.Context.EvaluationContext -&gt; Microsoft.Build.Execution.ProjectInstance" Usage="project.CreateProjectInstance (settings, evaluationContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Execution.ProjectInstance</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="settings" Type="Microsoft.Build.Execution.ProjectInstanceSettings" Index="0" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
        <Parameter Name="evaluationContext" Type="Microsoft.Build.Evaluation.Context.EvaluationContext" Index="1" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
      </Parameters>
      <Docs>
        <param name="settings">To be added.</param>
        <param name="evaluationContext">Der Auswertungskontext für den Fall, dass eine Neuauswertung erforderlich ist</param>
        <summary>Siehe <see cref="M:Microsoft.Build.Evaluation.Project.CreateProjectInstance(Microsoft.Build.Execution.ProjectInstanceSettings)" />.</summary>
        <returns />
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DirectoryPath">
      <MemberSignature Language="C#" Value="public string DirectoryPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DirectoryPath" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.DirectoryPath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DirectoryPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DirectoryPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DirectoryPath : string" Usage="Microsoft.Build.Evaluation.Project.DirectoryPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Das Stammverzeichnis dieses Projekts.
Ist nie NULL: In-Memory-Projekte verwenden das aktuelle Verzeichnis ab dem Zeitpunkt des Ladens.</summary>
        <value>Das Stammverzeichnis für dieses Projekt. Das Stammverzeichnis ist nie NULL, Projekte im Speicher verwenden das aktuelle Verzeichnis beim Laden des Projekts.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DisableMarkDirty">
      <MemberSignature Language="C#" Value="public bool DisableMarkDirty { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisableMarkDirty" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.DisableMarkDirty" />
      <MemberSignature Language="VB.NET" Value="Public Property DisableMarkDirty As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DisableMarkDirty { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DisableMarkDirty : bool with get, set" Usage="Microsoft.Build.Evaluation.Project.DisableMarkDirty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="msbuild-16;msbuild-16-netcore">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="msbuild-16;msbuild-16-netcore">
          <AttributeName Language="C#">[set: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;set: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, ob <see cref="M:Microsoft.Build.Evaluation.Project.MarkDirty">MarkDirty()</see> vorübergehend deaktiviert ist.
Dies ermöglicht z. B. das Festlegen einer globalen Eigenschaft, ohne dass das Projekt für eine erneute Auswertung entsprechend als geändert markiert wird.</summary>
        <value><see langword="true" /> , um anzugeben, dass <see langword="MarkDirty" /> vorübergehend deaktiviert ist, andernfalls <see langword="false" /> .</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EvaluationCounter">
      <MemberSignature Language="C#" Value="public int EvaluationCounter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 EvaluationCounter" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.EvaluationCounter" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property EvaluationCounter As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int EvaluationCounter { int get(); };" />
      <MemberSignature Language="F#" Value="member this.EvaluationCounter : int" Usage="Microsoft.Build.Evaluation.Project.EvaluationCounter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Veraltet. Verwenden Sie stattdessen <see cref="P:Microsoft.Build.Evaluation.Project.LastEvaluationId" />.</summary>
        <value>Der inkrementierte Wert.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Wert sollte mit vorherigen Werten verglichen werden, um festzustellen, ob das Projekt erneut ausgewertet wurde. Es sollte nicht verwendet werden, um zu bestimmen, wie oft das Projekt erneut ausgewertet wurde, da es für eine bestimmte erneute Auswertung um mehr als eins erhöht werden kann.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExpandString">
      <MemberSignature Language="C#" Value="public string ExpandString (string unexpandedValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ExpandString(string unexpandedValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.ExpandString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExpandString (unexpandedValue As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ExpandString(System::String ^ unexpandedValue);" />
      <MemberSignature Language="F#" Value="member this.ExpandString : string -&gt; string" Usage="project.ExpandString unexpandedValue" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unexpandedValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="unexpandedValue">Die auszuwertende Zeichenfolge.</param>
        <summary>Wertet die bereitgestellte Zeichenfolge durch Erweitern von Elementen und Eigenschaften aus, als ob sie ganz am Ende der Projektdatei gefunden würde.
Dies ist für einige Hosts nützlich, für die diese Art der Auswertung nach bestem Bemühen ausreichend ist.
Erweitert keine reinen Metadatenausdrücke.</summary>
        <returns>Die ausgewertete Zeichenfolge.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann verwendet werden, wenn die bestmögliche Auswertung ausreichend ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromFile">
      <MemberSignature Language="C#" Value="public static Microsoft.Build.Evaluation.Project FromFile (string file, Microsoft.Build.Definition.ProjectOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.Build.Evaluation.Project FromFile(string file, class Microsoft.Build.Definition.ProjectOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.FromFile(System.String,Microsoft.Build.Definition.ProjectOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromFile (file As String, options As ProjectOptions) As Project" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::Build::Evaluation::Project ^ FromFile(System::String ^ file, Microsoft::Build::Definition::ProjectOptions ^ options);" />
      <MemberSignature Language="F#" Value="static member FromFile : string * Microsoft.Build.Definition.ProjectOptions -&gt; Microsoft.Build.Evaluation.Project" Usage="Microsoft.Build.Evaluation.Project.FromFile (file, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Evaluation.Project</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" Index="0" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
        <Parameter Name="options" Type="Microsoft.Build.Definition.ProjectOptions" Index="1" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
      </Parameters>
      <Docs>
        <param name="file">Die Datei, in der das Projekt ausgewertet wird.</param>
        <param name="options">Der zu verwendende <see cref="T:Microsoft.Build.Definition.ProjectOptions" />.</param>
        <summary>Erstellt ein dateibasiertes Projekt.</summary>
        <returns />
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FromProjectRootElement">
      <MemberSignature Language="C#" Value="public static Microsoft.Build.Evaluation.Project FromProjectRootElement (Microsoft.Build.Construction.ProjectRootElement rootElement, Microsoft.Build.Definition.ProjectOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.Build.Evaluation.Project FromProjectRootElement(class Microsoft.Build.Construction.ProjectRootElement rootElement, class Microsoft.Build.Definition.ProjectOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.FromProjectRootElement(Microsoft.Build.Construction.ProjectRootElement,Microsoft.Build.Definition.ProjectOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromProjectRootElement (rootElement As ProjectRootElement, options As ProjectOptions) As Project" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::Build::Evaluation::Project ^ FromProjectRootElement(Microsoft::Build::Construction::ProjectRootElement ^ rootElement, Microsoft::Build::Definition::ProjectOptions ^ options);" />
      <MemberSignature Language="F#" Value="static member FromProjectRootElement : Microsoft.Build.Construction.ProjectRootElement * Microsoft.Build.Definition.ProjectOptions -&gt; Microsoft.Build.Evaluation.Project" Usage="Microsoft.Build.Evaluation.Project.FromProjectRootElement (rootElement, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Evaluation.Project</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rootElement" Type="Microsoft.Build.Construction.ProjectRootElement" Index="0" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
        <Parameter Name="options" Type="Microsoft.Build.Definition.ProjectOptions" Index="1" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
      </Parameters>
      <Docs>
        <param name="rootElement">Das <see cref="T:Microsoft.Build.Construction.ProjectRootElement" />, in dem das Projekt ausgewertet wird.</param>
        <param name="options">Der zu verwendende <see cref="T:Microsoft.Build.Definition.ProjectOptions" />.</param>
        <summary>Erstellt ein <see cref="T:Microsoft.Build.Construction.ProjectRootElement" />-basiertes Projekt.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FromXmlReader">
      <MemberSignature Language="C#" Value="public static Microsoft.Build.Evaluation.Project FromXmlReader (System.Xml.XmlReader reader, Microsoft.Build.Definition.ProjectOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.Build.Evaluation.Project FromXmlReader(class System.Xml.XmlReader reader, class Microsoft.Build.Definition.ProjectOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.FromXmlReader(System.Xml.XmlReader,Microsoft.Build.Definition.ProjectOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromXmlReader (reader As XmlReader, options As ProjectOptions) As Project" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::Build::Evaluation::Project ^ FromXmlReader(System::Xml::XmlReader ^ reader, Microsoft::Build::Definition::ProjectOptions ^ options);" />
      <MemberSignature Language="F#" Value="static member FromXmlReader : System.Xml.XmlReader * Microsoft.Build.Definition.ProjectOptions -&gt; Microsoft.Build.Evaluation.Project" Usage="Microsoft.Build.Evaluation.Project.FromXmlReader (reader, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Evaluation.Project</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" Index="0" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
        <Parameter Name="options" Type="Microsoft.Build.Definition.ProjectOptions" Index="1" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
      </Parameters>
      <Docs>
        <param name="reader">Der <see cref="T:System.Xml.XmlReader" />, in dem das Projekt ausgewertet wird.</param>
        <param name="options">Der zu verwendende <see cref="T:Microsoft.Build.Definition.ProjectOptions" />.</param>
        <summary>Erstellt ein <see cref="T:System.Xml.XmlReader" />-basiertes Projekt.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FullPath">
      <MemberSignature Language="C#" Value="public string FullPath { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullPath" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.FullPath" />
      <MemberSignature Language="VB.NET" Value="Public Property FullPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ FullPath { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.FullPath : string with get, set" Usage="Microsoft.Build.Evaluation.Project.FullPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[set: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;set: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Der vollständige Pfad zur Datei dieses Projekts.
Kann NULL sein, wenn das Projekt nicht vom Datenträger geladen wurde.
Setter benennt das Projekt um, wenn es bereits einen Namen hat.</summary>
        <value>Der vollständige Pfad zur Projekt Quelldatei oder eine leere Zeichenfolge, wenn das Projekt nicht vom Datenträger geladen wurde.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn diese Eigenschaft für ein Projekt in einer Projekt Auflistung festgelegt wird, wird das Projekt umbenannt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAllGlobs">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;Microsoft.Build.Evaluation.GlobResult&gt; GetAllGlobs ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;class Microsoft.Build.Evaluation.GlobResult&gt; GetAllGlobs() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.GetAllGlobs" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAllGlobs () As List(Of GlobResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::List&lt;Microsoft::Build::Evaluation::GlobResult ^&gt; ^ GetAllGlobs();" />
      <MemberSignature Language="F#" Value="member this.GetAllGlobs : unit -&gt; System.Collections.Generic.List&lt;Microsoft.Build.Evaluation.GlobResult&gt;" Usage="project.GetAllGlobs " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;Microsoft.Build.Evaluation.GlobResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Findet alle Globs, die in Item-Includes enthalten sind.</summary>
        <returns>Liste mit <see cref="T:Microsoft.Build.Evaluation.GlobResult" />.</returns>
        <remarks><see cref="P:Microsoft.Build.Evaluation.GlobResult.MsBuildGlob" /> ist eine <see cref="T:Microsoft.Build.Globbing.IMSBuildGlob" /> , die alle glosb im Include-Element kombiniert und alle Fragmente im Exclude-Attribut sowie alle Fragmente in allen remove-Elementen ignoriert, die auf das Include-Element angewendet werden.
             
Benutzer können einen zusammengesetzten globmuster erstellen, der alle globs im Projekt umfasst: <code>
             var uberGlob = new CompositeGlob(project.GetAllGlobs().Select(r =&gt; r.MSBuildGlob).ToArray());
             uberGlob.IsMatch("foo.cs");
             </code></remarks>
        <example><code>
            <P>*.txt</P>
            <Bar Include="bar" /> (both outside and inside project cone)
            <Zar Include="C:\**\*.foo" /> (both outside and inside project cone)
            <Foo Include="*.a;*.b" Exclude="3.a" /><Foo Remove="2.a" /><Foo Include="**\*.b" Exclude="1.b;**\obj\*.b;**\bar\*.b" /><Foo Include="$(P)" /><Foo Include="*.a;@(Bar);3.a" /> (If Bar has globs, they will have been included when querying Bar ProjectItems for globs)
            <Foo Include="*.cs" Exclude="@(Bar)" /></code>
             
Beispiel Ergebnis: [globresult (Glob: "C: \* * \* . foo", Exclude: []), globresult (Glob: ["*. a", "*. b"], Exclude = ["3. a"], Remove = ["2. a"]), globresult (Glob: "* * \* . b", Exclude = ["1. b, * * \obj \* . b", **\bar \* . b "]), globresult (Glob:"*. txt ", Exclude = []), globresult (Glob:"*. a ", Exclude = []), globresult (Glob:"*. cs ", Exclude = [" Bar "])]</example>
      </Docs>
    </Member>
    <Member MemberName="GetAllGlobs">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;Microsoft.Build.Evaluation.GlobResult&gt; GetAllGlobs (Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;class Microsoft.Build.Evaluation.GlobResult&gt; GetAllGlobs(class Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.GetAllGlobs(Microsoft.Build.Evaluation.Context.EvaluationContext)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAllGlobs (evaluationContext As EvaluationContext) As List(Of GlobResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::List&lt;Microsoft::Build::Evaluation::GlobResult ^&gt; ^ GetAllGlobs(Microsoft::Build::Evaluation::Context::EvaluationContext ^ evaluationContext);" />
      <MemberSignature Language="F#" Value="member this.GetAllGlobs : Microsoft.Build.Evaluation.Context.EvaluationContext -&gt; System.Collections.Generic.List&lt;Microsoft.Build.Evaluation.GlobResult&gt;" Usage="project.GetAllGlobs evaluationContext" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;Microsoft.Build.Evaluation.GlobResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="evaluationContext" Type="Microsoft.Build.Evaluation.Context.EvaluationContext" Index="0" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
      </Parameters>
      <Docs>
        <param name="evaluationContext">Der Auswertungskontext für den Fall, dass eine Neuauswertung erforderlich ist.
Verwenden Sie zum Vermeiden einer Neuauswertung <see cref="F:Microsoft.Build.Evaluation.ProjectLoadSettings.RecordEvaluatedItemElements" />.</param>
        <summary>Siehe <see cref="M:Microsoft.Build.Evaluation.Project.GetAllGlobs" />.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAllGlobs">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;Microsoft.Build.Evaluation.GlobResult&gt; GetAllGlobs (string itemType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;class Microsoft.Build.Evaluation.GlobResult&gt; GetAllGlobs(string itemType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.GetAllGlobs(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAllGlobs (itemType As String) As List(Of GlobResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::List&lt;Microsoft::Build::Evaluation::GlobResult ^&gt; ^ GetAllGlobs(System::String ^ itemType);" />
      <MemberSignature Language="F#" Value="member this.GetAllGlobs : string -&gt; System.Collections.Generic.List&lt;Microsoft.Build.Evaluation.GlobResult&gt;" Usage="project.GetAllGlobs itemType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;Microsoft.Build.Evaluation.GlobResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="itemType" Type="System.String" Index="0" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
      </Parameters>
      <Docs>
        <param name="itemType">Beschränkt die Suche auf item-Elemente dieses Typs</param>
        <summary>Überladung von <see cref="M:Microsoft.Build.Evaluation.Project.GetAllGlobs" /></summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAllGlobs">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;Microsoft.Build.Evaluation.GlobResult&gt; GetAllGlobs (string itemType, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;class Microsoft.Build.Evaluation.GlobResult&gt; GetAllGlobs(string itemType, class Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.GetAllGlobs(System.String,Microsoft.Build.Evaluation.Context.EvaluationContext)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAllGlobs (itemType As String, evaluationContext As EvaluationContext) As List(Of GlobResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::List&lt;Microsoft::Build::Evaluation::GlobResult ^&gt; ^ GetAllGlobs(System::String ^ itemType, Microsoft::Build::Evaluation::Context::EvaluationContext ^ evaluationContext);" />
      <MemberSignature Language="F#" Value="member this.GetAllGlobs : string * Microsoft.Build.Evaluation.Context.EvaluationContext -&gt; System.Collections.Generic.List&lt;Microsoft.Build.Evaluation.GlobResult&gt;" Usage="project.GetAllGlobs (itemType, evaluationContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;Microsoft.Build.Evaluation.GlobResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="itemType" Type="System.String" Index="0" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
        <Parameter Name="evaluationContext" Type="Microsoft.Build.Evaluation.Context.EvaluationContext" Index="1" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
      </Parameters>
      <Docs>
        <param name="itemType">To be added.</param>
        <param name="evaluationContext">Der Auswertungskontext für den Fall, dass eine Neuauswertung erforderlich ist.
Verwenden Sie zum Vermeiden einer Neuauswertung <see cref="F:Microsoft.Build.Evaluation.ProjectLoadSettings.RecordEvaluatedItemElements" />.</param>
        <summary>Siehe <see cref="M:Microsoft.Build.Evaluation.Project.GetAllGlobs(System.String)" />.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvaluatedItemIncludeEscaped">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft den ausgewerteten, mit Escapezeichen versehenen Wert des Include-Attributs der bereitgestellten Elemente ab.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvaluatedItemIncludeEscaped">
      <MemberSignature Language="C#" Value="public static string GetEvaluatedItemIncludeEscaped (Microsoft.Build.Evaluation.ProjectItem item);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetEvaluatedItemIncludeEscaped(class Microsoft.Build.Evaluation.ProjectItem item) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.GetEvaluatedItemIncludeEscaped(Microsoft.Build.Evaluation.ProjectItem)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEvaluatedItemIncludeEscaped (item As ProjectItem) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetEvaluatedItemIncludeEscaped(Microsoft::Build::Evaluation::ProjectItem ^ item);" />
      <MemberSignature Language="F#" Value="static member GetEvaluatedItemIncludeEscaped : Microsoft.Build.Evaluation.ProjectItem -&gt; string" Usage="Microsoft.Build.Evaluation.Project.GetEvaluatedItemIncludeEscaped item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="Microsoft.Build.Evaluation.ProjectItem" />
      </Parameters>
      <Docs>
        <param name="item">Das Element, das ausgewertet und mit Escapezeichen versehen werden soll.</param>
        <summary>Gibt den ausgewerteten, mit Escapezeichen versehenen Includewert des angegebenen Elements zurück.</summary>
        <returns>Der ausgewertete, mit Escapezeichen versehene Wert des Include-Attributs der bereitgestellten Elemente.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEvaluatedItemIncludeEscaped">
      <MemberSignature Language="C#" Value="public static string GetEvaluatedItemIncludeEscaped (Microsoft.Build.Evaluation.ProjectItemDefinition item);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetEvaluatedItemIncludeEscaped(class Microsoft.Build.Evaluation.ProjectItemDefinition item) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.GetEvaluatedItemIncludeEscaped(Microsoft.Build.Evaluation.ProjectItemDefinition)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEvaluatedItemIncludeEscaped (item As ProjectItemDefinition) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetEvaluatedItemIncludeEscaped(Microsoft::Build::Evaluation::ProjectItemDefinition ^ item);" />
      <MemberSignature Language="F#" Value="static member GetEvaluatedItemIncludeEscaped : Microsoft.Build.Evaluation.ProjectItemDefinition -&gt; string" Usage="Microsoft.Build.Evaluation.Project.GetEvaluatedItemIncludeEscaped item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="Microsoft.Build.Evaluation.ProjectItemDefinition" />
      </Parameters>
      <Docs>
        <param name="item">Die Elementdefinition, die ausgewertet und mit Escapezeichen versehen werden soll.</param>
        <summary>Gibt den ausgewerteten, mit Escapezeichen versehenen Includewert der angegebenen Elementdefinition zurück.</summary>
        <returns>Der Wert des Include-Attributs.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetItemProvenance">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;Microsoft.Build.Evaluation.ProvenanceResult&gt; GetItemProvenance (Microsoft.Build.Evaluation.ProjectItem item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;class Microsoft.Build.Evaluation.ProvenanceResult&gt; GetItemProvenance(class Microsoft.Build.Evaluation.ProjectItem item) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.GetItemProvenance(Microsoft.Build.Evaluation.ProjectItem)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetItemProvenance (item As ProjectItem) As List(Of ProvenanceResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::List&lt;Microsoft::Build::Evaluation::ProvenanceResult ^&gt; ^ GetItemProvenance(Microsoft::Build::Evaluation::ProjectItem ^ item);" />
      <MemberSignature Language="F#" Value="member this.GetItemProvenance : Microsoft.Build.Evaluation.ProjectItem -&gt; System.Collections.Generic.List&lt;Microsoft.Build.Evaluation.ProvenanceResult&gt;" Usage="project.GetItemProvenance item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;Microsoft.Build.Evaluation.ProvenanceResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="Microsoft.Build.Evaluation.ProjectItem" Index="0" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
      </Parameters>
      <Docs>
        <param name="item">Das ProjectItem-Objekt, das die passende Elementspezifikation und den Elementtyp angibt, auf den die Suche beschränkt werden soll.
Die Suche ist auch auf Elemente beschränkt, die vor dem Element vorkommen, das dieses <paramref name="item" /> erzeugt hat.
Das Element, das dieses <paramref name="item" /> erzeugt hat, ist in den Ergebnissen enthalten.</param>
        <summary>Überladung von <see cref="M:Microsoft.Build.Evaluation.Project.GetItemProvenance(System.String)" /></summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetItemProvenance">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;Microsoft.Build.Evaluation.ProvenanceResult&gt; GetItemProvenance (string itemToMatch);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;class Microsoft.Build.Evaluation.ProvenanceResult&gt; GetItemProvenance(string itemToMatch) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.GetItemProvenance(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetItemProvenance (itemToMatch As String) As List(Of ProvenanceResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::List&lt;Microsoft::Build::Evaluation::ProvenanceResult ^&gt; ^ GetItemProvenance(System::String ^ itemToMatch);" />
      <MemberSignature Language="F#" Value="member this.GetItemProvenance : string -&gt; System.Collections.Generic.List&lt;Microsoft.Build.Evaluation.ProvenanceResult&gt;" Usage="project.GetItemProvenance itemToMatch" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;Microsoft.Build.Evaluation.ProvenanceResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="itemToMatch" Type="System.String" Index="0" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
      </Parameters>
      <Docs>
        <param name="itemToMatch">Die Zeichenfolge zur Durchführung des Abgleichs</param>
        <summary>Findet alle Item-Elemente im logischen Projekt mit Elementspezifikationen, die mit der angegebenen Zeichenfolge übereinstimmen: – Elemente, die die Zeichenfolge einschließen (oder ausschließen) würden – Elemente, die die Zeichenfolge aktualisieren würden (noch nicht implementiert) – Elemente, die die Zeichenfolge entfernen würden (noch nicht implementiert)</summary>
        <returns>Eine Liste mit <see cref="T:Microsoft.Build.Evaluation.ProvenanceResult" /> sortiert in der Reihenfolge der Projektauswertung.</returns>
        <remarks>Diese Methode und ihre über Ladungen sind nützlich für Clients, die alle Element Elemente überprüfen müssen, die möglicherweise auf eine bestimmte Element Instanz verweisen. Beispielsweise wird es von Visual Studio verwendet, um Projekte mit glob zu überprüfen. Bei einer Änderung des Dateisystems oder der IDE-Datei wird diese Methode von vs aufgerufen, um alle Elemente zu finden, die möglicherweise auf die erkannte Datei Änderung verweisen (z. b. "welche Element Elemente verweisen auf" Program.cs "?").
Diese Informationen werden verwendet, um zu ermitteln, welche Elemente bearbeitet werden sollten, um die Änderungen des Benutzers oder des Dateisystems widerzuspiegeln.
             
Der literalzeichenfolgenvergleich versucht, die Zeichen folgen zuerst zu Wenn die Überprüfung fehlschlägt, versucht Sie, die Zeichen folgen so abzugleichen, als ob Sie Dateien darstellen: Sie normalisiert beide Zeichen folgen als Dateien relativ zum aktuellen Projektverzeichnis. 
Getitemprovenance leidet aus einigen Quellen der ingenauigkeit:-Sie wird nach der Auswertung ausgeführt und ist daher für den Elementdaten Fluss nicht beachtet, wenn Element Verweise vorhanden sind (es werden Elemente angezeigt, die sich am Ende der Auswertung befinden). 
Diese API und ihre Rückgabe Typen sind anfällig für Änderungen.</remarks>
        <example>Der folgende Code Ausschnitt zeigt, was <c>getitemprovenance ("a. cs")</c> für verschiedene Element Elemente zurückgibt. <code><A Include="a.cs;*.cs" /> // Occurrences:2; Operation: Include; Provenance: StringLiteral | Glob
             <B Include="*.cs" Exclude="a.cs" /> // Occurrences: 1; Operation: Exclude; Provenance: StringLiteral
             <C Include="b.cs" /> // NA
             <D Include="@(A)" /> // Occurrences: 2; Operation: Include; Provenance: Inconclusive (it is an indirect occurrence from a referenced item)
             <E Include="$(P)" /> // Occurrences: 4; Operation: Include; Provenance: FromLiteral (direct reference in $P) | Glob (direct reference in $P) | Inconclusive (it is an indirect occurrence from referenced properties and items)
             <PropertyGroup><P>a.cs;*.cs;@(A)</P></PropertyGroup></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetItemProvenance">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;Microsoft.Build.Evaluation.ProvenanceResult&gt; GetItemProvenance (Microsoft.Build.Evaluation.ProjectItem item, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;class Microsoft.Build.Evaluation.ProvenanceResult&gt; GetItemProvenance(class Microsoft.Build.Evaluation.ProjectItem item, class Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.GetItemProvenance(Microsoft.Build.Evaluation.ProjectItem,Microsoft.Build.Evaluation.Context.EvaluationContext)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetItemProvenance (item As ProjectItem, evaluationContext As EvaluationContext) As List(Of ProvenanceResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::List&lt;Microsoft::Build::Evaluation::ProvenanceResult ^&gt; ^ GetItemProvenance(Microsoft::Build::Evaluation::ProjectItem ^ item, Microsoft::Build::Evaluation::Context::EvaluationContext ^ evaluationContext);" />
      <MemberSignature Language="F#" Value="member this.GetItemProvenance : Microsoft.Build.Evaluation.ProjectItem * Microsoft.Build.Evaluation.Context.EvaluationContext -&gt; System.Collections.Generic.List&lt;Microsoft.Build.Evaluation.ProvenanceResult&gt;" Usage="project.GetItemProvenance (item, evaluationContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;Microsoft.Build.Evaluation.ProvenanceResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="Microsoft.Build.Evaluation.ProjectItem" Index="0" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
        <Parameter Name="evaluationContext" Type="Microsoft.Build.Evaluation.Context.EvaluationContext" Index="1" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
      </Parameters>
      <Docs>
        <param name="item">To be added.</param>
        <param name="evaluationContext">Der Auswertungskontext für den Fall, dass eine Neuauswertung erforderlich ist.
Verwenden Sie zum Vermeiden einer Neuauswertung <see cref="F:Microsoft.Build.Evaluation.ProjectLoadSettings.RecordEvaluatedItemElements" />.</param>
        <summary>Siehe <see cref="M:Microsoft.Build.Evaluation.Project.GetItemProvenance(Microsoft.Build.Evaluation.ProjectItem)" />.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetItemProvenance">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;Microsoft.Build.Evaluation.ProvenanceResult&gt; GetItemProvenance (string itemToMatch, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;class Microsoft.Build.Evaluation.ProvenanceResult&gt; GetItemProvenance(string itemToMatch, class Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.GetItemProvenance(System.String,Microsoft.Build.Evaluation.Context.EvaluationContext)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetItemProvenance (itemToMatch As String, evaluationContext As EvaluationContext) As List(Of ProvenanceResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::List&lt;Microsoft::Build::Evaluation::ProvenanceResult ^&gt; ^ GetItemProvenance(System::String ^ itemToMatch, Microsoft::Build::Evaluation::Context::EvaluationContext ^ evaluationContext);" />
      <MemberSignature Language="F#" Value="member this.GetItemProvenance : string * Microsoft.Build.Evaluation.Context.EvaluationContext -&gt; System.Collections.Generic.List&lt;Microsoft.Build.Evaluation.ProvenanceResult&gt;" Usage="project.GetItemProvenance (itemToMatch, evaluationContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;Microsoft.Build.Evaluation.ProvenanceResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="itemToMatch" Type="System.String" Index="0" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
        <Parameter Name="evaluationContext" Type="Microsoft.Build.Evaluation.Context.EvaluationContext" Index="1" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
      </Parameters>
      <Docs>
        <param name="itemToMatch">To be added.</param>
        <param name="evaluationContext">Der Auswertungskontext für den Fall, dass eine Neuauswertung erforderlich ist.
Verwenden Sie zum Vermeiden einer Neuauswertung <see cref="F:Microsoft.Build.Evaluation.ProjectLoadSettings.RecordEvaluatedItemElements" />.</param>
        <summary>Siehe <see cref="M:Microsoft.Build.Evaluation.Project.GetItemProvenance(System.String)" />.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetItemProvenance">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;Microsoft.Build.Evaluation.ProvenanceResult&gt; GetItemProvenance (string itemToMatch, string itemType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;class Microsoft.Build.Evaluation.ProvenanceResult&gt; GetItemProvenance(string itemToMatch, string itemType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.GetItemProvenance(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetItemProvenance (itemToMatch As String, itemType As String) As List(Of ProvenanceResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::List&lt;Microsoft::Build::Evaluation::ProvenanceResult ^&gt; ^ GetItemProvenance(System::String ^ itemToMatch, System::String ^ itemType);" />
      <MemberSignature Language="F#" Value="member this.GetItemProvenance : string * string -&gt; System.Collections.Generic.List&lt;Microsoft.Build.Evaluation.ProvenanceResult&gt;" Usage="project.GetItemProvenance (itemToMatch, itemType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;Microsoft.Build.Evaluation.ProvenanceResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="itemToMatch" Type="System.String" Index="0" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
        <Parameter Name="itemType" Type="System.String" Index="1" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
      </Parameters>
      <Docs>
        <param name="itemToMatch">Die Zeichenfolge zur Durchführung des Abgleichs</param>
        <param name="itemType">Der Elementtyp, in dem die Suche eingeschränkt werden soll</param>
        <summary>Überladung von <see cref="M:Microsoft.Build.Evaluation.Project.GetItemProvenance(System.String)" /></summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetItemProvenance">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;Microsoft.Build.Evaluation.ProvenanceResult&gt; GetItemProvenance (string itemToMatch, string itemType, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;class Microsoft.Build.Evaluation.ProvenanceResult&gt; GetItemProvenance(string itemToMatch, string itemType, class Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.GetItemProvenance(System.String,System.String,Microsoft.Build.Evaluation.Context.EvaluationContext)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetItemProvenance (itemToMatch As String, itemType As String, evaluationContext As EvaluationContext) As List(Of ProvenanceResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::List&lt;Microsoft::Build::Evaluation::ProvenanceResult ^&gt; ^ GetItemProvenance(System::String ^ itemToMatch, System::String ^ itemType, Microsoft::Build::Evaluation::Context::EvaluationContext ^ evaluationContext);" />
      <MemberSignature Language="F#" Value="member this.GetItemProvenance : string * string * Microsoft.Build.Evaluation.Context.EvaluationContext -&gt; System.Collections.Generic.List&lt;Microsoft.Build.Evaluation.ProvenanceResult&gt;" Usage="project.GetItemProvenance (itemToMatch, itemType, evaluationContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;Microsoft.Build.Evaluation.ProvenanceResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="itemToMatch" Type="System.String" Index="0" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
        <Parameter Name="itemType" Type="System.String" Index="1" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
        <Parameter Name="evaluationContext" Type="Microsoft.Build.Evaluation.Context.EvaluationContext" Index="2" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
      </Parameters>
      <Docs>
        <param name="itemToMatch">To be added.</param>
        <param name="itemType">To be added.</param>
        <param name="evaluationContext">Der Auswertungskontext für den Fall, dass eine Neuauswertung erforderlich ist.
Verwenden Sie zum Vermeiden einer Neuauswertung <see cref="F:Microsoft.Build.Evaluation.ProjectLoadSettings.RecordEvaluatedItemElements" />.</param>
        <summary>Siehe <see cref="M:Microsoft.Build.Evaluation.Project.GetItemProvenance(System.String,System.String)" />.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetItems">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectItem&gt; GetItems (string itemType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.ICollection`1&lt;class Microsoft.Build.Evaluation.ProjectItem&gt; GetItems(string itemType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.GetItems(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetItems (itemType As String) As ICollection(Of ProjectItem)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::ICollection&lt;Microsoft::Build::Evaluation::ProjectItem ^&gt; ^ GetItems(System::String ^ itemType);" />
      <MemberSignature Language="F#" Value="member this.GetItems : string -&gt; System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectItem&gt;" Usage="project.GetItems itemType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectItem&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="itemType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="itemType">Der Elementtyp, der abgerufen werden soll.</param>
        <summary>Alle Elemente im Projekt mit dem angegebenen Typ.
Gibt eine leere Liste zurück, wenn keine Elemente vorhanden sind.
Mit AddItem oder RemoveItem können Elemente in diesem Projekt geändert werden.</summary>
        <returns>Alle Elemente im Projekt mit dem angegebenen Elementtyp oder eine leere Liste, wenn keine Elemente mit dem angegebenen Namen vorhanden sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit AddItem oder RemoveItem können Elemente in diesem Projekt geändert werden.  
  
 ]]></format>
        </remarks>
        <comments>Vorrats. "GetItems" gibt eine schreibgeschützte Auflistung zurück, sodass diese hier nicht erneut umschlossen werden muss.</comments>
      </Docs>
    </Member>
    <Member MemberName="GetItemsByEvaluatedInclude">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectItem&gt; GetItemsByEvaluatedInclude (string evaluatedInclude);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.ICollection`1&lt;class Microsoft.Build.Evaluation.ProjectItem&gt; GetItemsByEvaluatedInclude(string evaluatedInclude) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.GetItemsByEvaluatedInclude(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetItemsByEvaluatedInclude (evaluatedInclude As String) As ICollection(Of ProjectItem)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::ICollection&lt;Microsoft::Build::Evaluation::ProjectItem ^&gt; ^ GetItemsByEvaluatedInclude(System::String ^ evaluatedInclude);" />
      <MemberSignature Language="F#" Value="member this.GetItemsByEvaluatedInclude : string -&gt; System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectItem&gt;" Usage="project.GetItemsByEvaluatedInclude evaluatedInclude" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectItem&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="evaluatedInclude" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="evaluatedInclude">Das ausgewertete Include-Attribut.</param>
        <summary>Gibt alle Elemente zurück, die den angegebenen ausgewerteten Wert enthalten.
Zum Beispiel alle Elemente mit dem ausgewerteten Include „bar.cpp“.
Normalerweise gibt es keines oder eines, aber manchmal gibt es zwei Elemente mit dem gleichen Pfad und unterschiedlichen Elementtypen oder sogar die gleichen Elementtypen. Damit werden alle zurückgegeben.</summary>
        <returns>Alle Elemente mit dem angegebenen ausgewerteten Include-Attribut.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beispielsweise gibt diese Methode möglicherweise alle Elemente zurück, die das ausgewertete Include-Attribut "Component. cpp" aufweisen. In der Regel werden NULL oder ein Element zurückgegeben. Es können jedoch mehrere Elemente mit demselben Pfad und anderen Elementtypen oder sogar mit denselben Elementtypen vorhanden sein.  
  
 ]]></format>
        </remarks>
        <comments>Vorrats. Getitemsbyevaluatedinclude gibt bereits eine schreibgeschützte Auflistung zurück, sodass Sie Sie nicht weiter einbinden müssen.</comments>
      </Docs>
    </Member>
    <Member MemberName="GetItemsIgnoringCondition">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectItem&gt; GetItemsIgnoringCondition (string itemType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.ICollection`1&lt;class Microsoft.Build.Evaluation.ProjectItem&gt; GetItemsIgnoringCondition(string itemType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.GetItemsIgnoringCondition(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetItemsIgnoringCondition (itemType As String) As ICollection(Of ProjectItem)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::ICollection&lt;Microsoft::Build::Evaluation::ProjectItem ^&gt; ^ GetItemsIgnoringCondition(System::String ^ itemType);" />
      <MemberSignature Language="F#" Value="member this.GetItemsIgnoringCondition : string -&gt; System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectItem&gt;" Usage="project.GetItemsIgnoringCondition itemType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectItem&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="itemType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="itemType">Der Elementtyp, der abgerufen werden soll.</param>
        <summary>Alle Elemente im Projekt des angegebenen Typs, unabhängig davon, ob die Bedingungen für sie als TRUE ausgewertet wurden.
Dies ist eine schreibgeschützte Liste, mit AddItem oder RemoveItem können Elemente in diesem Projekt geändert werden.</summary>
        <returns>Alle Elemente im Projekt mit dem angegebenen Typ, unabhängig davon, ob ihr Condition-Attribut als „true“ ausgewertet wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist eine schreibgeschützte Liste. Mit AddItem oder RemoveItem können Elemente in diesem Projekt geändert werden.  
  
 ]]></format>
        </remarks>
        <comments>Itemdictionary [] gibt eine schreibgeschützte Auflistung zurück, sodass Sie nicht eingeschlossen werden muss.</comments>
      </Docs>
    </Member>
    <Member MemberName="GetLogicalProject">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Construction.ProjectElement&gt; GetLogicalProject ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.Build.Construction.ProjectElement&gt; GetLogicalProject() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.GetLogicalProject" />
      <MemberSignature Language="VB.NET" Value="Public Iterator Function GetLogicalProject () As IEnumerable(Of ProjectElement)" FrameworkAlternate="msbuild-15;msbuild-15-netcore" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;Microsoft::Build::Construction::ProjectElement ^&gt; ^ GetLogicalProject();" />
      <MemberSignature Language="F#" Value="member this.GetLogicalProject : unit -&gt; seq&lt;Microsoft.Build.Construction.ProjectElement&gt;" Usage="project.GetLogicalProject " />
      <MemberSignature Language="VB.NET" Value="Public Function GetLogicalProject () As IEnumerable(Of ProjectElement)" FrameworkAlternate="msbuild-16;msbuild-16-netcore;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="msbuild-15;msbuild-15-netcore">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.IteratorStateMachine(typeof(Microsoft.Build.Evaluation.Project/&lt;GetLogicalProject&gt;d__136))]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IteratorStateMachine(typeof(Microsoft.Build.Evaluation.Project/&lt;GetLogicalProject&gt;d__136))&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Construction.ProjectElement&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Iterator über das „logische Projekt“ zurück. Das logische Projekt wird definiert als das nicht ausgewertete Projekt, das aus der einzelnen MSBuild-Datei abgerufen wurde, die das Ergebnis des Inlinings des Texts aller Importe der ursprünglichen MSBuild-Projektmanifestdatei ist.</summary>
        <returns>Ein Enumerator über alle Elemente im „logischen Projekt“.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das logische Projekt wird als nicht ausgewertetes Projekt definiert, das aus der einzelnen MSBuild-Datei abgerufen wurde. Dies ist das Ergebnis der Einbeziehung von Inline den Text aller Importe der ursprünglichen MSBuild-Projekt Manifest-Datei.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMetadataValueEscaped">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft den Wert mit Escapezeichen des Metadatums mit dem angegebenen Namen im bereitgestellten Element ab.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMetadataValueEscaped">
      <MemberSignature Language="C#" Value="public static string GetMetadataValueEscaped (Microsoft.Build.Evaluation.ProjectMetadata metadatum);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetMetadataValueEscaped(class Microsoft.Build.Evaluation.ProjectMetadata metadatum) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.GetMetadataValueEscaped(Microsoft.Build.Evaluation.ProjectMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMetadataValueEscaped (metadatum As ProjectMetadata) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetMetadataValueEscaped(Microsoft::Build::Evaluation::ProjectMetadata ^ metadatum);" />
      <MemberSignature Language="F#" Value="static member GetMetadataValueEscaped : Microsoft.Build.Evaluation.ProjectMetadata -&gt; string" Usage="Microsoft.Build.Evaluation.Project.GetMetadataValueEscaped metadatum" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadatum" Type="Microsoft.Build.Evaluation.ProjectMetadata" />
      </Parameters>
      <Docs>
        <param name="metadatum">Das Metadatum, das mit Escapezeichen versehen werden soll.</param>
        <summary>Ruft den Wert mit Escapezeichen des bereitgestellten Metadatums ab.</summary>
        <returns>Der Wert mit Escapezeichen des bereitgestellten Metadatums.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMetadataValueEscaped">
      <MemberSignature Language="C#" Value="public static string GetMetadataValueEscaped (Microsoft.Build.Evaluation.ProjectItem item, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetMetadataValueEscaped(class Microsoft.Build.Evaluation.ProjectItem item, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.GetMetadataValueEscaped(Microsoft.Build.Evaluation.ProjectItem,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMetadataValueEscaped (item As ProjectItem, name As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetMetadataValueEscaped(Microsoft::Build::Evaluation::ProjectItem ^ item, System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member GetMetadataValueEscaped : Microsoft.Build.Evaluation.ProjectItem * string -&gt; string" Usage="Microsoft.Build.Evaluation.Project.GetMetadataValueEscaped (item, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="Microsoft.Build.Evaluation.ProjectItem" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="item">Das Element, dessen Metadaten mit Escapezeichen versehen werden sollen.</param>
        <param name="name">Der Name der Metadaten, die mit Escapezeichen versehen werden sollen.</param>
        <summary>Ruft den Wert mit Escapezeichen des Metadatums mit dem angegebenen Namen im bereitgestellten Element ab.</summary>
        <returns>Der Wert mit Escapezeichen des Metadatums mit dem angegebenen Namen im bereitgestellten Element.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMetadataValueEscaped">
      <MemberSignature Language="C#" Value="public static string GetMetadataValueEscaped (Microsoft.Build.Evaluation.ProjectItemDefinition item, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetMetadataValueEscaped(class Microsoft.Build.Evaluation.ProjectItemDefinition item, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.GetMetadataValueEscaped(Microsoft.Build.Evaluation.ProjectItemDefinition,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMetadataValueEscaped (item As ProjectItemDefinition, name As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetMetadataValueEscaped(Microsoft::Build::Evaluation::ProjectItemDefinition ^ item, System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member GetMetadataValueEscaped : Microsoft.Build.Evaluation.ProjectItemDefinition * string -&gt; string" Usage="Microsoft.Build.Evaluation.Project.GetMetadataValueEscaped (item, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="Microsoft.Build.Evaluation.ProjectItemDefinition" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="item">Die Elementdefinition, deren Metadaten mit Escapezeichen versehen werden sollen.</param>
        <param name="name">Der Name der Metadaten, die mit Escapezeichen versehen werden sollen.</param>
        <summary>Ruft den Wert mit Escapezeichen des Metadatums mit dem angegebenen Namen in der bereitgestellten Elementdefinition ab.</summary>
        <returns>Der Wert mit Escapezeichen des Metadatums mit dem angegebenen Namen in der bereitgestellten Elementdefinition.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Evaluation.ProjectProperty GetProperty (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Build.Evaluation.ProjectProperty GetProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.GetProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String) As ProjectProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Build::Evaluation::ProjectProperty ^ GetProperty(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GetProperty : string -&gt; Microsoft.Build.Evaluation.ProjectProperty" Usage="project.GetProperty name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Evaluation.ProjectProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der abzurufenden Eigenschaft.</param>
        <summary>Hiermit wird eine beliebige Eigenschaft im Element mit dem angegebenen Namen und andernfalls NULL zurückgegeben</summary>
        <returns>Jede Eigenschaft im Projekt, die den angegebenen Namen aufweist, oder <see langword="null" />, wenn keine Eigenschaft mit diesem Namen vorhanden ist.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPropertyValue">
      <MemberSignature Language="C#" Value="public string GetPropertyValue (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPropertyValue(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.GetPropertyValue(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPropertyValue (name As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPropertyValue(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GetPropertyValue : string -&gt; string" Usage="project.GetPropertyValue name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der Eigenschaft, deren Wert abgerufen wird.</param>
        <summary>Ruft den Wert einer Eigenschaft ohne Escapezeichen in diesem Projekt ab. Die Zeichenfolge ist leer, wenn keine Eigenschaft vorhanden ist.</summary>
        <returns>Der Wert der angegebenen Eigenschaft in diesem Projekt oder eine leere Zeichenfolge, wenn keine Eigenschaft mit diesem Namen existiert. Escapesequenzen werden vor dem Zurückgeben der Zeichenfolge umgewandelt.</returns>
        <remarks>Eine Eigenschaft mit einem Wert einer leeren Zeichenfolge und keiner Eigenschaft wird von dieser Methode nicht unterschieden.
Dies erleichtert die Verwendung. Um herauszufinden, ob eine Eigenschaft im Projekt überhaupt festgelegt ist, verwenden Sie GetProperty (Name).</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPropertyValueEscaped">
      <MemberSignature Language="C#" Value="public static string GetPropertyValueEscaped (Microsoft.Build.Evaluation.ProjectProperty property);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetPropertyValueEscaped(class Microsoft.Build.Evaluation.ProjectProperty property) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.GetPropertyValueEscaped(Microsoft.Build.Evaluation.ProjectProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPropertyValueEscaped (property As ProjectProperty) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetPropertyValueEscaped(Microsoft::Build::Evaluation::ProjectProperty ^ property);" />
      <MemberSignature Language="F#" Value="static member GetPropertyValueEscaped : Microsoft.Build.Evaluation.ProjectProperty -&gt; string" Usage="Microsoft.Build.Evaluation.Project.GetPropertyValueEscaped property" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="Microsoft.Build.Evaluation.ProjectProperty" />
      </Parameters>
      <Docs>
        <param name="property">Die Eigenschaft, die mit Escapezeichen versehen werden soll.</param>
        <summary>Ruft den mit Escapezeichen versehenen Wert der angegebenen Eigenschaft ab.</summary>
        <returns>Der Wert mit Escapezeichen der bereitgestellten Eigenschaft.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GlobalProperties">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IDictionary&lt;string,string&gt; GlobalProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IDictionary`2&lt;string, string&gt; GlobalProperties" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.GlobalProperties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property GlobalProperties As IDictionary(Of String, String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ GlobalProperties { System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.GlobalProperties : System.Collections.Generic.IDictionary&lt;string, string&gt;" Usage="Microsoft.Build.Evaluation.Project.GlobalProperties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="msbuild-15;msbuild-15-netcore;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Schreibgeschütztes Wörterbuch der für die Auswertung dieses Projekts verwendeten globalen Eigenschaften.</summary>
        <value>Ein Wörterbuch der für die Auswertung dieses Projekts verwendeten globalen Eigenschaften.</value>
        <remarks>Dies ist der öffentlich verfügbar gemachte Getter, der in eine schreibgeschützte, nicht schreibgeschützte IDictionary-Zeichenfolge (String) übersetzt wird &lt; &gt; .
            
Um leicht zu erkennen, wann eine Beschädigung besteht, wird das Festlegen und Entfernen von globalen Eigenschaften mit " <see cref="M:Microsoft.Build.Evaluation.Project.SetGlobalProperty(System.String,System.String)">SetGlobalProperty</see> " und " <see cref="M:Microsoft.Build.Evaluation.Project.RemoveGlobalProperty(System.String)">RemoveGlobalProperty</see>" durchgeführt.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Imports">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;Microsoft.Build.Evaluation.ResolvedImport&gt; Imports { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;valuetype Microsoft.Build.Evaluation.ResolvedImport&gt; Imports" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.Imports" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Imports As IList(Of ResolvedImport)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;Microsoft::Build::Evaluation::ResolvedImport&gt; ^ Imports { System::Collections::Generic::IList&lt;Microsoft::Build::Evaluation::ResolvedImport&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Imports : System.Collections.Generic.IList&lt;Microsoft.Build.Evaluation.ResolvedImport&gt;" Usage="Microsoft.Build.Evaluation.Project.Imports" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;Microsoft.Build.Evaluation.ResolvedImport&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Alle Dateien, die während der Auswertung als ProjectRootElements mit dem ProjectImportElement, das den Import veranlasst hat, zu diesem Projekt beigetragen haben.
Dies schließt keine Projekte ein, die nie importiert wurden, weil eine Bedingung für ein Import-Element auf FALSE festgelegt war.
Das äußere ProjectRootElement, das diesem Projekt selbst zugeordnet ist, ist nicht enthalten.</summary>
        <value>Eine Liste aller Dateien, die zur Auswertung dieses Projekts beigetragen haben.  
  
 Der Name jedes Elements ist das Import-Element, das den Import der Datei verursacht hat. Der Wert jedes Elements ist der Projektstamm des importierten Projekts. Import-Elemente, deren Condition-Attribut false ergeben hat, werden nicht eingeschlossen.</value>
        <remarks>Dies kann vom Host verwendet werden, um herauszufinden, welche Projekte möglicherweise durch eine Änderung an einer bestimmten Datei beeinträchtigt werden.
Sie kann beispielsweise verwendet werden, um die User-Datei zu suchen, und das projectrootelements-Element verwenden, um die darin enthaltenen Eigenschaften zu ändern.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ImportsIncludingDuplicates">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;Microsoft.Build.Evaluation.ResolvedImport&gt; ImportsIncludingDuplicates { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;valuetype Microsoft.Build.Evaluation.ResolvedImport&gt; ImportsIncludingDuplicates" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.ImportsIncludingDuplicates" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ImportsIncludingDuplicates As IList(Of ResolvedImport)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;Microsoft::Build::Evaluation::ResolvedImport&gt; ^ ImportsIncludingDuplicates { System::Collections::Generic::IList&lt;Microsoft::Build::Evaluation::ResolvedImport&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ImportsIncludingDuplicates : System.Collections.Generic.IList&lt;Microsoft.Build.Evaluation.ResolvedImport&gt;" Usage="Microsoft.Build.Evaluation.Project.ImportsIncludingDuplicates" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;Microsoft.Build.Evaluation.ResolvedImport&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Diese Liste enthält doppelte Importe, wenn ein Import mehrmals ausgeführt wird. Allerdings wurde nur der erste Import zur Auswertung verwendet.</summary>
        <value>Eine Liste doppelter Importe.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBuildEnabled">
      <MemberSignature Language="C#" Value="public bool IsBuildEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBuildEnabled" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.IsBuildEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property IsBuildEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBuildEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsBuildEnabled : bool with get, set" Usage="Microsoft.Build.Evaluation.Project.IsBuildEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="msbuild-16;msbuild-16-netcore">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="msbuild-16;msbuild-16-netcore">
          <AttributeName Language="C#">[set: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;set: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Damit wird gesteuert, ob die Erstellung von Zielen/Tasks für dieses Projekt aktiviert ist oder nicht.  Dies erfolgt aus Sicherheitsgründen, falls ein Host genau steuern möchte, welche Projekte er zur Ausführung von Zielen/Tasks zulässt.  Standardmäßig verwenden wir für ein neu erstelltes Projekt die Einstellung, die in der Sammlung des übergeordneten Projekts vorhanden ist.
Wenn der Build deaktiviert ist, kann die Build-Methode für diese Klasse nicht ausgeführt werden. Wenn der Host jedoch bereits eine ProjectInstance erstellt hat, kann er dafür weiterhin einen Build erstellen. (Es steht ihm frei, eine ähnliche Prüfung dort vorzunehmen, wo er dies tut.)</summary>
        <value><see langword="true" /> , wenn die Ziele und die Aufgaben dieses Projekts erstellt werden können. andernfalls <see langword="false" /> .</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kann aus Sicherheitsgründen verwendet werden. Standardmäßig hat ein neues Projekt dieselbe isbuildenabled-Einstellung wie die übergeordnete Projekt Auflistung, in der es enthalten ist. Wenn isbuildenabled den Wert false hat, schlägt die Buildmethode für dieses Projekt fehl.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDirty">
      <MemberSignature Language="C#" Value="public bool IsDirty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDirty" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.IsDirty" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDirty As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDirty { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDirty : bool" Usage="Microsoft.Build.Evaluation.Project.IsDirty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, ob dieses Projekt geändert wurde, sodass es neu ausgewertet werden muss.
Dies kann daran liegen, dass sich die zugrunde liegende XML (entweder durch dieses oder ein anderes Projekt) entweder die XML des Hauptprojekts oder eine importierte Datei geändert hat oder aber daran, dass sich das Toolset geändert hat.</summary>
        <value><see langword="true" /> , wenn dieses Projekt geändert wurde, sodass es neu ausgewertet werden muss. andernfalls <see langword="false" /> .</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Projekt wird geändert und muss neu ausgewertet werden, wenn der zugrunde liegende Projekt Quell Code, einschließlich Änderungen an importierten Dateien, geändert wird. Ein Projekt, das ebenfalls geändert wird, muss neu ausgewertet werden, wenn das Projekt Tool Änderungen ändert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ItemDefinitions">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IDictionary&lt;string,Microsoft.Build.Evaluation.ProjectItemDefinition&gt; ItemDefinitions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IDictionary`2&lt;string, class Microsoft.Build.Evaluation.ProjectItemDefinition&gt; ItemDefinitions" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.ItemDefinitions" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ItemDefinitions As IDictionary(Of String, ProjectItemDefinition)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IDictionary&lt;System::String ^, Microsoft::Build::Evaluation::ProjectItemDefinition ^&gt; ^ ItemDefinitions { System::Collections::Generic::IDictionary&lt;System::String ^, Microsoft::Build::Evaluation::ProjectItemDefinition ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ItemDefinitions : System.Collections.Generic.IDictionary&lt;string, Microsoft.Build.Evaluation.ProjectItemDefinition&gt;" Usage="Microsoft.Build.Evaluation.Project.ItemDefinitions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,Microsoft.Build.Evaluation.ProjectItemDefinition&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Schreibgeschütztes Wörterbuch der Elementdefinitionen in diesem Projekt.
Schlüsselgebunden nach Elementtyp.</summary>
        <value>Ein Wörterbuch der Element Definitionen in diesem Projekt, geordnet nach Elementtyp.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Items">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectItem&gt; Items { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;class Microsoft.Build.Evaluation.ProjectItem&gt; Items" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.Items" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Items As ICollection(Of ProjectItem)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::ICollection&lt;Microsoft::Build::Evaluation::ProjectItem ^&gt; ^ Items { System::Collections::Generic::ICollection&lt;Microsoft::Build::Evaluation::ProjectItem ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Items : System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectItem&gt;" Usage="Microsoft.Build.Evaluation.Project.Items" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectItem&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Elemente in diesem Projekt, geordnet in Gruppen von Elementtypen</summary>
        <value>Ein Enumerator über alle Elemente in diesem Projekt, geordnet in Gruppen von Elementtypen.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ItemsIgnoringCondition">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectItem&gt; ItemsIgnoringCondition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;class Microsoft.Build.Evaluation.ProjectItem&gt; ItemsIgnoringCondition" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.ItemsIgnoringCondition" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ItemsIgnoringCondition As ICollection(Of ProjectItem)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::ICollection&lt;Microsoft::Build::Evaluation::ProjectItem ^&gt; ^ ItemsIgnoringCondition { System::Collections::Generic::ICollection&lt;Microsoft::Build::Evaluation::ProjectItem ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ItemsIgnoringCondition : System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectItem&gt;" Usage="Microsoft.Build.Evaluation.Project.ItemsIgnoringCondition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="msbuild-15;msbuild-15-netcore;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectItem&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Elemente in diesem Projekt, geordnet innerhalb von Gruppen von Elementtypen, einschließlich Elementen, deren Bedingungen als FALSE ausgewertet wurden, oder die in Elementgruppen enthalten waren, die ihrerseits als FALSE ausgewertet wurden.
Dies ist nützlich für Hosts, die alle Elemente anzeigen möchten, auch wenn sie in der aktuellen Konfiguration möglicherweise nicht Teil des Builds sind.</summary>
        <value>Ein Enumerator über alle Elemente in diesem Projekt, geordnet in Gruppen von Elementtypen, einschließlich Elementen, deren Bedingungen zu "false" ausgewertet werden, oder die in Elementgruppen enthalten sind, deren Bedingung als ausgewertet wird <see langword="false" /> .</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kann verwendet werden, um alle Elemente anzuzeigen, auch wenn Sie nicht Teil des Builds in der aktuellen Konfiguration sind.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ItemTypes">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;string&gt; ItemTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;string&gt; ItemTypes" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.ItemTypes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ItemTypes As ICollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::ICollection&lt;System::String ^&gt; ^ ItemTypes { System::Collections::Generic::ICollection&lt;System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ItemTypes : System.Collections.Generic.ICollection&lt;string&gt;" Usage="Microsoft.Build.Evaluation.Project.ItemTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Elementtypen in diesem Projekt.
Dies ist eine geordnete Auflistung.</summary>
        <value>Ein Enumerator über alle Elementtypen in diesem Projekt. Dies ist eine geordnete Auflistung.</value>
        <remarks>To be added.</remarks>
        <comments>Vorrats. ItemTypes ist eine KeyCollection und benötigt daher keinen zusätzlichen schreibgeschützten Schutz.</comments>
      </Docs>
    </Member>
    <Member MemberName="LastEvaluationId">
      <MemberSignature Language="C#" Value="public int LastEvaluationId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 LastEvaluationId" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.LastEvaluationId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LastEvaluationId As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int LastEvaluationId { int get(); };" />
      <MemberSignature Language="F#" Value="member this.LastEvaluationId : int" Usage="Microsoft.Build.Evaluation.Project.LastEvaluationId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Die ID der letzten Auswertung für dieses Projekt.
Ein Projekt wird stets bei der Erstellung ausgewertet und kann anschließend mehrfach über <see cref="M:Microsoft.Build.Evaluation.Project.ReevaluateIfNecessary" /> ausgewertet werden.
            
Es ist eine willkürliche Zahl, die sich ändert, wenn dieses Projekt neu ausgewertet wird.
Hosts wissen nicht, ob eine Auswertung tatsächlich in einem Intervall stattgefunden hat. Aber sie können diesen Wert mit ihrem zuvor gespeicherten Wert vergleichen, um dies herauszufinden, und falls ja, ggf. beschließen, ihren eigenen Zustand zu aktualisieren.
Beachten Sie, dass sich der Wert möglicherweise nicht monoton vergrößert.
            
Diese Zahl <seealso cref="P:Microsoft.Build.Framework.BuildEventContext.EvaluationId" /> kann verwendet werden, um Protokollierungsereignisse bei der Auswertung wieder mit der Projektinstanz zu verbinden.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MarkDirty">
      <MemberSignature Language="C#" Value="public void MarkDirty ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MarkDirty() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.MarkDirty" />
      <MemberSignature Language="VB.NET" Value="Public Sub MarkDirty ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MarkDirty();" />
      <MemberSignature Language="F#" Value="member this.MarkDirty : unit -&gt; unit" Usage="project.MarkDirty " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wird aufgerufen, um das Projekt zwangsweise als geändert zu kennzeichnen, was eine Neuauswertung erfordert. Im Allgemeinen muss dies nicht festgelegt werden. Alle Bearbeitungen, die dieses Projekt betreffen, führen automatisch dazu, dass es geändert wird. Es gibt jedoch potenzielle Grenzfälle, in denen es notwendig ist, das Projekt direkt als geändert zu kennzeichnen. Wenn das Projekt beispielsweise einen Import abhängig von einer Datei aufweist, die auf Datenträger vorhanden ist, und die Datei zum Zeitpunkt der Auswertung noch nicht existierte, und jemand diese Datei anschließend erstellt, kann das Projekt nicht wissen, dass eine erneute Auswertung sinnvoll wäre.
In einem solchen Fall kann uns der Host helfen, indem er das Flag „Dirty“ explizit so festlegt, dass <see cref="M:Microsoft.Build.Evaluation.Project.ReevaluateIfNecessary">ReevaluateIfNecessary()</see> erkennt, dass eine Auswertung tatsächlich notwendig ist.
Markiert die zugrunde liegende Projektdatei nicht als speicherpflichtig.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es ist nur selten notwendig, diese Methode explizit aufzurufen, da alle Änderungen, die sich auf ein Projekt auswirken, es automatisch als geändert markieren.  
  
 Manchmal muss jedoch diese Methode aufgerufen werden. Ein Projekt kann beispielsweise über ein Import-Element verfügen, dessen Bedingung von einer Datei abhängt, die auf einem Datenträger vorhanden ist. Wenn diese Datei nicht zur Evaluierungszeit vorhanden ist und nach der Auswertung erstellt wird, muss das Projekt explizit als geändert markiert werden.  
  
 Die- <xref:Microsoft.Build.Evaluation.Project.ReevaluateIfNecessary%2A> Methode verwendet diese Eigenschaft, um zu bestimmen, ob eine Auswertung notwendig ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProjectCollection">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Evaluation.ProjectCollection ProjectCollection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Build.Evaluation.ProjectCollection ProjectCollection" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.ProjectCollection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProjectCollection As ProjectCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Build::Evaluation::ProjectCollection ^ ProjectCollection { Microsoft::Build::Evaluation::ProjectCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProjectCollection : Microsoft.Build.Evaluation.ProjectCollection" Usage="Microsoft.Build.Evaluation.Project.ProjectCollection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Evaluation.ProjectCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Projektsammlung ab, die dieses Projekt enthält, oder legt diese fest.
Kann nie NULL sein.
Kann nicht geändert werden.</summary>
        <value>Die Projekt Auflistung, die dieses Projekt enthält, d <see langword="null" /> . h. nie.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ProjectFileLocation">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Construction.ElementLocation ProjectFileLocation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Build.Construction.ElementLocation ProjectFileLocation" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.ProjectFileLocation" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProjectFileLocation As ElementLocation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Build::Construction::ElementLocation ^ ProjectFileLocation { Microsoft::Build::Construction::ElementLocation ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProjectFileLocation : Microsoft.Build.Construction.ElementLocation" Usage="Microsoft.Build.Evaluation.Project.ProjectFileLocation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Construction.ElementLocation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Speicherort der ursprünglichen Datei selbst, nicht ihrer Inhalte.
Wenn der Datei kein Name zugewiesen wurde, wird ein leerer Speicherort zurückgegeben.</summary>
        <value>Der Speicherort der Ursprungs Datei oder ein leerer Speicherort, wenn der Datei kein Name zugewiesen wurde.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Properties">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectProperty&gt; Properties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;class Microsoft.Build.Evaluation.ProjectProperty&gt; Properties" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.Properties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Properties As ICollection(Of ProjectProperty)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::ICollection&lt;Microsoft::Build::Evaluation::ProjectProperty ^&gt; ^ Properties { System::Collections::Generic::ICollection&lt;Microsoft::Build::Evaluation::ProjectProperty ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Properties : System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectProperty&gt;" Usage="Microsoft.Build.Evaluation.Project.Properties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectProperty&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Eigenschaften in diesem Projekt.
Da die Auswertung erfolgt ist, ist dies eine ungeordnete Sammlung.</summary>
        <value>Ein Enumerator über alle Eigenschaften in diesem Projekt. Da Eigenschaften entsprechend der Anzeige ausgewertet werden, ist dies eine ungeordnete Auflistung.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReevaluateIfNecessary">
      <MemberSignature Language="C#" Value="public void ReevaluateIfNecessary ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReevaluateIfNecessary() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.ReevaluateIfNecessary" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReevaluateIfNecessary ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReevaluateIfNecessary();" />
      <MemberSignature Language="F#" Value="member this.ReevaluateIfNecessary : unit -&gt; unit" Usage="project.ReevaluateIfNecessary " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Werten Sie das Projekt neu aus, um es in einen abfragbaren Zustand zu bringen, falls es geändert wurde.
Dies schließt alle Änderungen ein, die zuvor durch die Bearbeitung dieses Projekts an der unterstützenden XML vorgenommen wurden.
Löst InvalidProjectFileException aus, wenn die Auswertung fehlschlägt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Projekt wird nur dann erneut ausgewertet, wenn es als geändert markiert ist. Die erneute Auswertung umfasst alle Änderungen, die am Projekt Quell Code vorgenommen wurden.  
  
 Löst InvalidProjectFileException aus, wenn die Auswertung fehlschlägt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReevaluateIfNecessary">
      <MemberSignature Language="C#" Value="public void ReevaluateIfNecessary (Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReevaluateIfNecessary(class Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.ReevaluateIfNecessary(Microsoft.Build.Evaluation.Context.EvaluationContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReevaluateIfNecessary (evaluationContext As EvaluationContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReevaluateIfNecessary(Microsoft::Build::Evaluation::Context::EvaluationContext ^ evaluationContext);" />
      <MemberSignature Language="F#" Value="member this.ReevaluateIfNecessary : Microsoft.Build.Evaluation.Context.EvaluationContext -&gt; unit" Usage="project.ReevaluateIfNecessary evaluationContext" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="evaluationContext" Type="Microsoft.Build.Evaluation.Context.EvaluationContext" Index="0" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
      </Parameters>
      <Docs>
        <param name="evaluationContext">Der zu verwendende <see cref="T:Microsoft.Build.Evaluation.Context.EvaluationContext" />. Siehe <see cref="T:Microsoft.Build.Evaluation.Context.EvaluationContext" />.</param>
        <summary>Siehe <see cref="M:Microsoft.Build.Evaluation.Project.ReevaluateIfNecessary" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveGlobalProperty">
      <MemberSignature Language="C#" Value="public bool RemoveGlobalProperty (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RemoveGlobalProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.RemoveGlobalProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveGlobalProperty (name As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RemoveGlobalProperty(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.RemoveGlobalProperty : string -&gt; bool" Usage="project.RemoveGlobalProperty name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der zu entfernenden globalen Eigenschaft.</param>
        <summary>Entfernt eine globale Eigenschaft.
Falls festgelegt, wird TRUE zurückgegeben, und das Projekt wird für eine erforderliche erneute Auswertung markiert.</summary>
        <returns><see langword="true" />, wenn der Wert der globalen Eigenschaft festgelegt wurde.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveItem">
      <MemberSignature Language="C#" Value="public bool RemoveItem (Microsoft.Build.Evaluation.ProjectItem item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RemoveItem(class Microsoft.Build.Evaluation.ProjectItem item) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.RemoveItem(Microsoft.Build.Evaluation.ProjectItem)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveItem (item As ProjectItem) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RemoveItem(Microsoft::Build::Evaluation::ProjectItem ^ item);" />
      <MemberSignature Language="F#" Value="member this.RemoveItem : Microsoft.Build.Evaluation.ProjectItem -&gt; bool" Usage="project.RemoveItem item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="Microsoft.Build.Evaluation.ProjectItem" />
      </Parameters>
      <Docs>
        <param name="item">Das zu entfernende Element.</param>
        <summary>Entfernt ein Element aus dem Projekt.
Element muss diesem Projekt zugeordnet sein.
Element darf nicht aus einer importierten Datei stammen.
Gibt TRUE zurück, wenn das Element in diesem ausgewerteten Projekt enthalten war; andernfalls FALSE.
Wenn die übergeordnete Elementgruppe leer wird, wird sie der Einfachheit halber ebenfalls entfernt.
Wenn das Element von einem durch Platzhalter oder Semikolon getrennten Ausdruck stammt, erweitert es diesen Ausdruck zuerst in mehrere Elemente.
Aktualisiert das ausgewertete Projekt, wirkt sich aber bis zur erneuten Auswertung auf nichts anderes im Projekt aus. Wenn z. B. ein Element des Typs „i“ entfernt wird, wird „j“, das in „@(i)“ ausgewertet wird, bis zur erneuten Auswertung nicht geändert.
Dies ist eine praktische Möglichkeit, die nicht unbedingt dazu führt, dass sich das Projekt in einem völlig in sich stimmigen Zustand befindet.</summary>
        <returns><see langword="true" />, wenn das Element in diesem ausgewerteten Projekt vorhanden ist, andernfalls <see langword="false" />. Normalerweise gibt diese Methode true zurück, da die Methode eine Ausnahme auslöst, wenn das angeforderte Element nicht vorhanden ist. Wenn das Element nur in der ItemsIgnoringCondition-Auflistung vorhanden ist, gibt die Methode jedoch <see langword="false" /> zurück.</returns>
        <remarks>Normalerweise wird dies als "true" zurückgegeben, da das Element, das sich nicht im Projekt befindet, ausgelöst wird.
Eine Ausnahme besteht darin, ein Element zu entfernen, das nur in ItemsIgnoringCondition enthalten war.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveItems">
      <MemberSignature Language="C#" Value="public void RemoveItems (System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Evaluation.ProjectItem&gt; items);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveItems(class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.Build.Evaluation.ProjectItem&gt; items) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.RemoveItems(System.Collections.Generic.IEnumerable{Microsoft.Build.Evaluation.ProjectItem})" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveItems (items As IEnumerable(Of ProjectItem))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveItems(System::Collections::Generic::IEnumerable&lt;Microsoft::Build::Evaluation::ProjectItem ^&gt; ^ items);" />
      <MemberSignature Language="F#" Value="member this.RemoveItems : seq&lt;Microsoft.Build.Evaluation.ProjectItem&gt; -&gt; unit" Usage="project.RemoveItems items" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="items" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Evaluation.ProjectItem&gt;" />
      </Parameters>
      <Docs>
        <param name="items">Die zu entfernenden Elemente.</param>
        <summary>Entfernt alle angegebenen Elemente aus dem Projekt.
Elemente, die diesem Projekt nicht zugeordnet sind, werden übersprungen.</summary>
        <remarks>Wenn ein Element entfernt wird, kann das zugrunde liegende XML-Element erweitert werden, wodurch das nächste Element Zombie (getrennt) werden kann.
Wenn Sie diesen Fall für den Aufrufer leicht machen möchten, wird ein Element, das diesem Projekt nicht zugeordnet ist, einfach übersprungen.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveProperty">
      <MemberSignature Language="C#" Value="public bool RemoveProperty (Microsoft.Build.Evaluation.ProjectProperty property);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RemoveProperty(class Microsoft.Build.Evaluation.ProjectProperty property) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.RemoveProperty(Microsoft.Build.Evaluation.ProjectProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveProperty (property As ProjectProperty) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RemoveProperty(Microsoft::Build::Evaluation::ProjectProperty ^ property);" />
      <MemberSignature Language="F#" Value="member this.RemoveProperty : Microsoft.Build.Evaluation.ProjectProperty -&gt; bool" Usage="project.RemoveProperty property" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="Microsoft.Build.Evaluation.ProjectProperty" />
      </Parameters>
      <Docs>
        <param name="property">Die zu entfernende Eigenschaft.</param>
        <summary>Entfernt die angegebene Eigenschaft.
Die Eigenschaft muss diesem Projekt zugeordnet sein.
Eigenschaft darf nicht aus einer importierten Datei stammen.
Gibt TRUE zurück, wenn die Eigenschaft in diesem ausgewerteten Projekt enthalten war; andernfalls FALSE.
Wenn die übergeordnete Eigenschaftengruppe leer wird, wird sie der Einfachheit halber ebenfalls entfernt.
Aktualisiert das ausgewertete Projekt, wirkt sich aber bis zur erneuten Auswertung auf nichts anderes im Projekt aus. Wenn z. B. „p“ entfernt wird, wird es aus dem ausgewerteten Projekt entfernt. „q“, das in „$(p)“ ausgewertet wird, wird jedoch bis zur erneuten Auswertung nicht geändert.
Dies ist eine praktische Möglichkeit, die nicht unbedingt dazu führt, dass sich das Projekt in einem völlig in sich stimmigen Zustand befindet.</summary>
        <returns><see langword="true" />, wenn die Eigenschaft in diesem ausgewerteten Projekt vorhanden ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Eigenschaften Gruppe, die die Eigenschaft enthält, leer ist, wird Sie ebenfalls entfernt.  
  
 Das Projekt wird aktualisiert, aber bis zur erneuten Auswertung erfolgt keine weitere Auswertung. Wenn z. b. "p" entfernt wird, wird "q", das aus "$ (p)" ausgewertet wird, erst nach der erneuten Auswertung geändert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Save">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Speichert das Projekt mit der Standardzeichencodierung im Dateisystem, wenn es geändert wurde.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.Save" />
      <MemberSignature Language="VB.NET" Value="Public Sub Save ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save();" />
      <MemberSignature Language="F#" Value="member this.Save : unit -&gt; unit" Usage="project.Save " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Speichert das Projekt, falls es geändert wurde, im Dateisystem.
Verwendet die Standardcodierung.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.Save(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Save (writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::IO::TextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.Save : System.IO.TextWriter -&gt; unit" Usage="project.Save writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Der TextWriter zum Speichern des Projekts.</param>
        <summary>Speichert das Projekt im angegebenen TextWriter unabhängig davon, ob es geändert wurde.
Verwendet die Codierung von TextWriter.
Löscht das Flag „Dirty“ (geändert).</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.Save(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Save (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.Save : string -&gt; unit" Usage="project.Save path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der Pfad zum Projektquellcode.</param>
        <summary>Speichern Sie das Projekt im Dateisystem, wenn es geändert wurde oder der Pfad anders ist.
Verwendet die Standardcodierung.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.Save(System.Text.Encoding)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Save (encoding As Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="member this.Save : System.Text.Encoding -&gt; unit" Usage="project.Save encoding" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="encoding">Die zum Speichern des Projekts verwendete Zeichencodierung.</param>
        <summary>Speichert das Projekt, falls es geändert wurde, im Dateisystem.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (string path, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(string path, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.Save(System.String,System.Text.Encoding)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Save (path As String, encoding As Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::String ^ path, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="member this.Save : string * System.Text.Encoding -&gt; unit" Usage="project.Save (path, encoding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="path">Der Pfad zum Projektquellcode.</param>
        <param name="encoding">Die zum Speichern des Projekts verwendete Zeichencodierung.</param>
        <summary>Speichert das Projekt im Dateisystem, wenn es geändert wurde oder der Pfad anders ist.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveLogicalProject">
      <MemberSignature Language="C#" Value="public void SaveLogicalProject (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SaveLogicalProject(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.SaveLogicalProject(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SaveLogicalProject (writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SaveLogicalProject(System::IO::TextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.SaveLogicalProject : System.IO.TextWriter -&gt; unit" Usage="project.SaveLogicalProject writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Der Writer, der die Projektdatei speichert.</param>
        <summary>Speichert eine "logische" oder "vorverarbeitete" Projektdatei, die alle importierten Dateien so einschließt, als würden sie eine einzige Datei bilden.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetGlobalProperty">
      <MemberSignature Language="C#" Value="public bool SetGlobalProperty (string name, string escapedValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SetGlobalProperty(string name, string escapedValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.SetGlobalProperty(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function SetGlobalProperty (name As String, escapedValue As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SetGlobalProperty(System::String ^ name, System::String ^ escapedValue);" />
      <MemberSignature Language="F#" Value="member this.SetGlobalProperty : string * string -&gt; bool" Usage="project.SetGlobalProperty (name, escapedValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="escapedValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der festzulegenden globalen Eigenschaft.</param>
        <param name="escapedValue">Der neue Wert der globalen Eigenschaft.</param>
        <summary>Ändert eine globale Eigenschaft, nachdem das Projekt ausgewertet wurde.
Wenn sich der Wert ändert, muss das Projekt erneut ausgewertet werden.
Wenn sich der Wert ändert, wird TRUE zurückgegeben, andernfalls FALSE.</summary>
        <returns><see langword="true" />, wenn sich der Wert ändert, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetProperty">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Evaluation.ProjectProperty SetProperty (string name, string unevaluatedValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Build.Evaluation.ProjectProperty SetProperty(string name, string unevaluatedValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.SetProperty(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function SetProperty (name As String, unevaluatedValue As String) As ProjectProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Build::Evaluation::ProjectProperty ^ SetProperty(System::String ^ name, System::String ^ unevaluatedValue);" />
      <MemberSignature Language="F#" Value="member this.SetProperty : string * string -&gt; Microsoft.Build.Evaluation.ProjectProperty" Usage="project.SetProperty (name, unevaluatedValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Evaluation.ProjectProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="unevaluatedValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der festzulegenden Eigenschaft.</param>
        <param name="unevaluatedValue">Der neue nicht ausgewertete Wert der Eigenschaft.</param>
        <summary>Dient zum Festlegen oder Hinzufügen einer Eigenschaft mit dem angegebenen Namen und Wert.
Überschreibt den Wert aller gleichnamigen Eigenschaften, die sich bereits in der Sammlung befinden, wenn sie nicht aus einer importierten Datei stammen.
Wenn es keine solche vorhandene Eigenschaft gibt, wird folgende Heuristik verwendet: Die letzte vorhandene Eigenschaft wird mit dem angegebenen Namen aktualisiert, die keine Bedingung für sich selbst oder ihre Eigenschaftengruppe (falls vorhanden) hat und sich in dieser Projektdatei und nicht in einer importierten Datei befindet.
Andernfalls wird eine neue Eigenschaft in der ersten Eigenschaftengruppe ohne Bedingung hinzugefügt, wobei eine Eigenschaftengruppe ggf. nach der letzten vorhandenen Eigenschaftengruppe erstellt wird, andernfalls am Anfang des Projekts.
Gibt den Eigenschaftensatz zurück.
Wertet nach bestem Bemühen aus: wird mit allen Eigenschaften erweitert. Eigenschaften, die in der XML unter der neuen Eigenschaft definiert sind, können verwendet werden, auch wenn sie es in einer realen Auswertung nicht wären.
– nur diese Eigenschaft wird ausgewertet. Alle anderen Elemente, die von ihrem Wert abhängen, sind nicht betroffen.
Dies ist eine praktische Möglichkeit, die nicht unbedingt dazu führt, dass sich das Projekt in einem völlig in sich stimmigen Zustand befindet.</summary>
        <returns>Die Eigenschaft.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn keine Eigenschaft mit dem angegebenen Namen vorhanden ist, aktualisiert die letzte vorhandene Eigenschaft mit dem angegebenen Namen, der keine Bedingung für sich selbst oder die zugehörige Eigenschaften Gruppe hat, es sei denn, Sie stammt aus einer importierten Datei.  
  
 Andernfalls fügt eine neue Eigenschaft in der ersten Eigenschaften Gruppe ohne Bedingung hinzu und erstellt eine Eigenschaften Gruppe, wenn dies erforderlich ist, nach der letzten vorhandenen Eigenschaften Gruppe, sonst am Anfang des Projekts.  
  
 Die Auswertung erfolgt auf Grundlage der bestmöglichen Leistung. Eigenschaften, die in der Projekt Quelle nach der neuen Eigenschaft definiert sind, können für die Auswertung verwendet werden. Nur diese Eigenschaft wird ausgewertet. Andere Eigenschaften, die möglicherweise von dieser abhängig sind, sind nicht betroffen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SkipEvaluation">
      <MemberSignature Language="C#" Value="public bool SkipEvaluation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SkipEvaluation" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.SkipEvaluation" />
      <MemberSignature Language="VB.NET" Value="Public Property SkipEvaluation As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SkipEvaluation { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SkipEvaluation : bool with get, set" Usage="Microsoft.Build.Evaluation.Project.SkipEvaluation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="msbuild-16;msbuild-16-netcore">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="msbuild-16;msbuild-16-netcore">
          <AttributeName Language="C#">[set: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;set: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, ob ReevaluateIfNecessary vorübergehend deaktiviert ist.
Dies ist nützlich, wenn der Host Lese- und Schreibvorgänge für das Projekt erwartet und vorübergehend Richtigkeit zugunsten von Leistung geopfert werden soll.</summary>
        <value>Ein Flag, das bestimmt, ob reevaluateignecessary vorübergehend deaktiviert ist.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SubToolsetVersion">
      <MemberSignature Language="C#" Value="public string SubToolsetVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SubToolsetVersion" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.SubToolsetVersion" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SubToolsetVersion As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ SubToolsetVersion { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SubToolsetVersion : string" Usage="Microsoft.Build.Evaluation.Project.SubToolsetVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Die Version des Untertoolsets, die in Kombination mit der Toolversion verwendet wurde, um die Toolseteigenschaften für dieses Projekt zu ermitteln.</summary>
        <value>Der subtoolsetversion-Attribut Wert oder eine leere Zeichenfolge, wenn das Attribut nicht vorhanden ist.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Targets">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IDictionary&lt;string,Microsoft.Build.Execution.ProjectTargetInstance&gt; Targets { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IDictionary`2&lt;string, class Microsoft.Build.Execution.ProjectTargetInstance&gt; Targets" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.Targets" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Targets As IDictionary(Of String, ProjectTargetInstance)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IDictionary&lt;System::String ^, Microsoft::Build::Execution::ProjectTargetInstance ^&gt; ^ Targets { System::Collections::Generic::IDictionary&lt;System::String ^, Microsoft::Build::Execution::ProjectTargetInstance ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Targets : System.Collections.Generic.IDictionary&lt;string, Microsoft.Build.Execution.ProjectTargetInstance&gt;" Usage="Microsoft.Build.Evaluation.Project.Targets" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="msbuild-15;msbuild-15-netcore;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,Microsoft.Build.Execution.ProjectTargetInstance&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ziele im Projekt. Der Schlüssel für das Wörterbuch ist der Name des Ziels.
Überschriebene Ziele sind in dieser Auflistung nicht enthalten.
Die Auflistung ist schreibgeschützt.</summary>
        <value>Ein Schreib geschütztes Wörterbuch aller Ziele in diesem Projekt, sortiert nach Zielname. Überschriebene Ziele sind in dieser Auflistung nicht enthalten.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ThrowInsteadOfSplittingItemElement">
      <MemberSignature Language="C#" Value="public bool ThrowInsteadOfSplittingItemElement { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ThrowInsteadOfSplittingItemElement" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.ThrowInsteadOfSplittingItemElement" />
      <MemberSignature Language="VB.NET" Value="Public Property ThrowInsteadOfSplittingItemElement As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ThrowInsteadOfSplittingItemElement { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ThrowInsteadOfSplittingItemElement : bool with get, set" Usage="Microsoft.Build.Evaluation.Project.ThrowInsteadOfSplittingItemElement" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="msbuild-16;msbuild-16-netcore">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="msbuild-16;msbuild-16-netcore">
          <AttributeName Language="C#">[set: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;set: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bestimmte Elementvorgänge teilen das Item-Element in mehrere Elemente auf, wenn das Include Globs, Verweise auf Elemente oder Eigenschaften oder mehrere Elementwerte enthält.
            
Die Elementvorgänge, mit denen Item-Elemente erweitert werden können, sind: <see cref="M:Microsoft.Build.Evaluation.Project.RemoveItem(Microsoft.Build.Evaluation.ProjectItem)" />
             - <see cref="M:Microsoft.Build.Evaluation.Project.RemoveItems(System.Collections.Generic.IEnumerable{Microsoft.Build.Evaluation.ProjectItem})" />
             - <see cref="M:Microsoft.Build.Evaluation.Project.AddItem(System.String,System.String,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}})" />
             - <see cref="M:Microsoft.Build.Evaluation.Project.AddItemFast(System.String,System.String,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}})" />
             - <see cref="M:Microsoft.Build.Evaluation.ProjectItem.ChangeItemType(System.String)" />
             - <see cref="M:Microsoft.Build.Evaluation.ProjectItem.Rename(System.String)" />
             - <see cref="M:Microsoft.Build.Evaluation.ProjectItem.RemoveMetadata(System.String)" />
             - <see cref="M:Microsoft.Build.Evaluation.ProjectItem.SetMetadataValue(System.String,System.String)" />
             - <see cref="M:Microsoft.Build.Evaluation.ProjectItem.SetMetadataValue(System.String,System.String,System.Boolean)" />
             
Wenn diese Eigenschaft auf TRUE festgelegt ist, lösen die vorherigen Elementvorgänge eine <exception cref="T:System.InvalidOperationException" /> aus, statt das Item-Element zu erweitern.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolsVersion">
      <MemberSignature Language="C#" Value="public string ToolsVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ToolsVersion" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.ToolsVersion" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ToolsVersion As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ToolsVersion { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ToolsVersion : string" Usage="Microsoft.Build.Evaluation.Project.ToolsVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Die Toolversion, mit der dieses Projekt ausgewertet wurde (sofern vorhanden).
Nicht notwendigerweise identisch mit der Toolversion für das Project-Tag (sofern vorhanden). Die Version wurde möglicherweise extern angegeben, z. B. mit dem Schalter „/tv“.
Die tatsächliche Toolversion für das Project-Tag kann aus <see cref="P:Microsoft.Build.Evaluation.Project.Xml">Xml.ToolsVersion</see> abgerufen werden.
Kann nicht geändert werden, nachdem das Projekt erstellt wurde.</summary>
        <value>Die ToolsVersion, mit der dieses Projekt ausgewertet wurde, falls vorhanden.</value>
        <remarks>Wird von der Konstruktion festgelegt.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Xml">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Construction.ProjectRootElement Xml { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Build.Construction.ProjectRootElement Xml" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.Xml" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Xml As ProjectRootElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Build::Construction::ProjectRootElement ^ Xml { Microsoft::Build::Construction::ProjectRootElement ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Xml : Microsoft.Build.Construction.ProjectRootElement" Usage="Microsoft.Build.Evaluation.Project.Xml" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Construction.ProjectRootElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Das unterstützende XML-Projekt.
Kann nie NULL sein</summary>
        <value>Das diesem Projekt zugeordnete Stamm Projekt, das nie sein kann <see langword="null" /> .</value>
        <remarks>Hier ist kein Setter, da dies kein Sinn macht. Wenn Sie ein neues projectrootelements haben, können Sie es in ein neues Projekt auswerten.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
