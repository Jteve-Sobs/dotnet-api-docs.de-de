<Type Name="ProjectItem" FullName="Microsoft.Build.Evaluation.ProjectItem">
  <Metadata><Meta Name="ms.openlocfilehash" Value="1c8ee9efb5578e8923bbf1b876754b0a4fc5d068" /><Meta Name="ms.sourcegitcommit" Value="b53d35b4a410c949742abd4c6a989d1af5357bca" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="07/21/2020" /><Meta Name="ms.locfileid" Value="86684842" /></Metadata><TypeSignature Language="C#" Value="public class ProjectItem" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ProjectItem extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.Build.Evaluation.ProjectItem" />
  <TypeSignature Language="VB.NET" Value="Public Class ProjectItem" />
  <TypeSignature Language="C++ CLI" Value="public ref class ProjectItem" />
  <TypeSignature Language="F#" Value="type ProjectItem = class" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.Build</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>15.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName Language="C#">[System.Diagnostics.DebuggerDisplay("{ItemType}={EvaluatedInclude} [{UnevaluatedInclude}] #DirectMetadata={DirectMetadataCount}")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerDisplay("{ItemType}={EvaluatedInclude} [{UnevaluatedInclude}] #DirectMetadata={DirectMetadataCount}")&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Ein ausgewertetes Entwurfszeitelement</summary>
    <remarks>Änderungen an diesem Objekt ändern das enthaltende Projekt indirekt, da Sie die zugrunde liegende XML-Datei ändern.</remarks>
    <comment>Es ist nicht möglich, eine Copy-on-Write-Tabelle für die Metadaten zu verwenden, da ProjectMetadata-Objekte änderbar sind. Wir verwenden es jedoch für Build-Time-Elemente.</comment>
  </Docs>
  <Members>
    <Member MemberName="DirectMetadata">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Evaluation.ProjectMetadata&gt; DirectMetadata { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.Build.Evaluation.ProjectMetadata&gt; DirectMetadata" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.ProjectItem.DirectMetadata" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DirectMetadata As IEnumerable(Of ProjectMetadata)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEnumerable&lt;Microsoft::Build::Evaluation::ProjectMetadata ^&gt; ^ DirectMetadata { System::Collections::Generic::IEnumerable&lt;Microsoft::Build::Evaluation::ProjectMetadata ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DirectMetadata : seq&lt;Microsoft.Build.Evaluation.ProjectMetadata&gt;" Usage="Microsoft.Build.Evaluation.ProjectItem.DirectMetadata" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Evaluation.ProjectMetadata&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Metadaten, die direkt für das Element definiert wurden (sofern vorhanden).
Umfasst keine Metadaten aus Elementdefinitionen.
Diese Eigenschaft umfasst keine integrierten Metadaten.
Gibt niemals NULL zurück.</summary>
        <value>Ein Enumerator über alle Element Metadaten, der niemals sein kann <see langword="null" /> .</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Enthält keine Metadaten aus Element Definitionen. Enthält keine integrierten Metadaten, z. b. "FullPath".  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DirectMetadataCount">
      <MemberSignature Language="C#" Value="public int DirectMetadataCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 DirectMetadataCount" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.ProjectItem.DirectMetadataCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DirectMetadataCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int DirectMetadataCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.DirectMetadataCount : int" Usage="Microsoft.Build.Evaluation.ProjectItem.DirectMetadataCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Anzahl von direkten Metadaten für dieses Element (sofern vorhanden).
Zählt KEINE Metadaten, die von Elementdefinitionen geerbt wurden.
Integrierte Metadaten wie „FullPath“ werden nicht gezählt.</summary>
        <value>Die Anzahl der Metadaten für dieses Element.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Enthält keine Metadaten aus Element Definitionen. Enthält keine integrierten Metadaten, z. b. "FullPath".  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EvaluatedInclude">
      <MemberSignature Language="C#" Value="public string EvaluatedInclude { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string EvaluatedInclude" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.ProjectItem.EvaluatedInclude" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property EvaluatedInclude As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ EvaluatedInclude { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EvaluatedInclude : string" Usage="Microsoft.Build.Evaluation.ProjectItem.EvaluatedInclude" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den ausgewerteten Wert des Include ab (ohne Vorzeichen).</summary>
        <value>Der ausgewertete Wert des Include-Attributs.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zeichen mit Escapezeichen sind nicht vorhanden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMetadata">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Evaluation.ProjectMetadata GetMetadata (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Build.Evaluation.ProjectMetadata GetMetadata(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.ProjectItem.GetMetadata(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMetadata (name As String) As ProjectMetadata" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Build::Evaluation::ProjectMetadata ^ GetMetadata(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GetMetadata : string -&gt; Microsoft.Build.Evaluation.ProjectMetadata" Usage="projectItem.GetMetadata name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Evaluation.ProjectMetadata</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der Metadaten, deren Wert abgerufen wird.</param>
        <summary>Ruft ausgewertete Metadaten für dieses Element ab.
Umfasst möglicherweise Metadaten aus einer Elementdefinition.
Gibt keine integrierten Metadaten wie „FullPath“ zurück.
Gibt NULL zurück, wenn keine Daten gefunden werden.</summary>
        <returns>Der ausgewertete Wert der angegebenen Metadaten für dieses Element oder <see langword="null" />, wenn keine Metadaten mit dem angegebenen Namen vorhanden sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kann Metadaten aus einer Element Definition einschließen. Enthält keine integrierten Metadaten, z. b. "FullPath".  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMetadataValue">
      <MemberSignature Language="C#" Value="public string GetMetadataValue (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetMetadataValue(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.ProjectItem.GetMetadataValue(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMetadataValue (name As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetMetadataValue(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetMetadataValue : string -&gt; string&#xA;override this.GetMetadataValue : string -&gt; string" Usage="projectItem.GetMetadataValue name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der Metadaten, deren Wert abgerufen wird.</param>
        <summary>Ruft den ausgewerteten Wert von Metadaten für dieses Element ab (möglicherweise aus einer Elementdefinition). Gibt eine leere Zeichenfolge zurück, wenn die Daten nicht vorhanden sind.
Ermitteln Sie mithilfe von <see cref="M:Microsoft.Build.Evaluation.ProjectItem.HasMetadata(System.String)">HasMetadata</see>, ob ein Metadatenelement nicht vorhanden ist oder lediglich keinen Wert aufweist.
Kann verwendet werden, um auf den Wert von integrierten Metadaten wie „FullPath“ zuzugreifen.
Beim Versuch, integrierte Metadaten für einen Wert abzurufen, der kein gültiger Pfad ist, wird die Ausnahme „InvalidOperationException“ ausgelöst.</summary>
        <returns>Der ausgewertete Wert der angegebenen Metadaten für dieses Element, einschließlich Metadaten, die aus einer Elementdefinition stammen, oder eine leere Zeichenfolge, wenn keine Metadaten mit dem angegebenen Namen vorhanden sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie, um zu bestimmen, ob Metadaten vorhanden sind, ob Sie über einen Wert verfügen oder nicht <xref:Microsoft.Build.Evaluation.ProjectItem.HasMetadata%2A> .  
  
 Diese Methode kann verwendet werden, um auf den Wert integrierter Metadaten, z. b. "FullPath", zuzugreifen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasMetadata">
      <MemberSignature Language="C#" Value="public bool HasMetadata (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool HasMetadata(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.ProjectItem.HasMetadata(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function HasMetadata (name As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool HasMetadata(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.HasMetadata : string -&gt; bool" Usage="projectItem.HasMetadata name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der Metadaten, die gesucht werden sollen.</param>
        <summary>Gibt „true“ zurück, wenn ein bestimmtes Metadatenelement für dieses Element definiert ist. Anderenfalls wird „false“ zurückgegeben.
Umfasst integrierte Metadaten und Metadaten aus Elementdefinitionen.</summary>
        <returns><see langword="true" />, wenn Metadaten mit dem angegebenen Namen für dieses Element definiert sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Enthält integrierte Metadaten und Metadaten, die aus Element Definitionen stammen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsImported">
      <MemberSignature Language="C#" Value="public bool IsImported { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsImported" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.ProjectItem.IsImported" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsImported As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsImported { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsImported : bool" Usage="Microsoft.Build.Evaluation.ProjectItem.IsImported" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wenn das Element aus einer importierten Datei stammt, wird „true“ zurückgegeben.
Andernfalls wird FALSE zurückgegeben.</summary>
        <value><see langword="true" /> , wenn dieses Element aus einer importierten Datei stammt. andernfalls <see langword="false" /> .</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ItemType">
      <MemberSignature Language="C#" Value="public string ItemType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ItemType" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.ProjectItem.ItemType" />
      <MemberSignature Language="VB.NET" Value="Public Property ItemType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ItemType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ItemType : string with get, set" Usage="Microsoft.Build.Evaluation.ProjectItem.ItemType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Typ dieses Elements ab oder legt ihn fest.</summary>
        <value>Der Elementtyp.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Metadata">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectMetadata&gt; Metadata { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;class Microsoft.Build.Evaluation.ProjectMetadata&gt; Metadata" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.ProjectItem.Metadata" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Metadata As ICollection(Of ProjectMetadata)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::ICollection&lt;Microsoft::Build::Evaluation::ProjectMetadata ^&gt; ^ Metadata { System::Collections::Generic::ICollection&lt;Microsoft::Build::Evaluation::ProjectMetadata ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Metadata : System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectMetadata&gt;" Usage="Microsoft.Build.Evaluation.ProjectItem.Metadata" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectMetadata&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Metadaten des Elements, sofern vorhanden.  Umfasst Metadaten, die durch die Definition angegeben sind (sofern vorhanden).
Wenn keine Metadaten vorliegen, wird eine leere Sammlung zurückgegeben.
Umfasst keine integrierten Metadaten wie „FullPath“.
Rufen Sie die Werte von integrierten Metadaten mithilfe von <see cref="M:Microsoft.Build.Evaluation.ProjectItem.GetMetadataValue(System.String)" /> ab.
Dies ist eine schreibgeschützte Auflistung. Verwenden Sie <see cref="M:Microsoft.Build.Evaluation.ProjectItem.SetMetadataValue(System.String,System.String)" />, um die Metadaten zu ändern.</summary>
        <value>Alle Metadaten für dieses Element, einschließlich Metadaten, die aus Element Definitionen stammen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Enthält keine integrierten Metadaten, z. b. "FullPath".  
  
 Verwenden Sie und, um die Werte integrierter Metadaten hinzuzufügen, zu entfernen oder zu <xref:Microsoft.Build.Evaluation.ProjectItem.GetMetadataValue%2A> ändern <xref:Microsoft.Build.Evaluation.ProjectItem.SetMetadataValue%2A> .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MetadataCount">
      <MemberSignature Language="C#" Value="public int MetadataCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MetadataCount" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.ProjectItem.MetadataCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MetadataCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MetadataCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MetadataCount : int" Usage="Microsoft.Build.Evaluation.ProjectItem.MetadataCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Anzahl von Metadaten für dieses Element (sofern vorhanden).
Sie enthält alle Metadaten, die von Elementdefinitionen geerbt werden.
Sowohl benutzerdefinierte als auch integrierte Metadaten sind enthalten.</summary>
        <value>Die Anzahl der Metadaten für dieses Element, einschließlich aller Metadaten, die aus Element Definitionen stammen, und integrierter Metadaten.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Project">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Evaluation.Project Project { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Build.Evaluation.Project Project" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.ProjectItem.Project" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Project As Project" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Build::Evaluation::Project ^ Project { Microsoft::Build::Evaluation::Project ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Project : Microsoft.Build.Evaluation.Project" Usage="Microsoft.Build.Evaluation.ProjectItem.Project" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Evaluation.Project</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Projekt, in dem sich dieses Element befindet.
ProjectItems befinden sich immer in einem Projekt.</summary>
        <value>Das Projekt, das dieses Projekt Element enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Projekt Elemente sind immer in einem Projekt enthalten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveMetadata">
      <MemberSignature Language="C#" Value="public bool RemoveMetadata (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RemoveMetadata(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.ProjectItem.RemoveMetadata(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveMetadata (name As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RemoveMetadata(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.RemoveMetadata : string -&gt; bool" Usage="projectItem.RemoveMetadata name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der zu entfernenden Metadaten.</param>
        <summary>Entfernt alle Metadaten mit dem angegebenen Namen.
Gibt „true“ zurück, wenn die ausgewerteten Metadaten vorhanden sind. Anderenfalls wird „false“ zurückgegeben.
Wenn der Metadatenname aus den integrierten Metadaten stammt (z. B. „FullPath“), wird die Ausnahme „InvalidArgumentException“ ausgelöst.
Wenn die Metadaten aus einer Elementdefinition stammen und nicht außer Kraft gesetzt wurden, wird die Ausnahme „InvalidOperationException“ ausgelöst.</summary>
        <returns><see langword="true" />, wenn Metadaten mit dem angegebenen Namen vor dem Entfernen vorhanden sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Löst InvalidArgumentException aus, wenn der Metadatenname auf integrierte Metadaten (z. b. "FullPath") verweist.  
  
 Löst InvalidOperationException aus, wenn der Metadatenname auf Metadaten verweist, die aus einer Element Definition stammen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rename">
      <MemberSignature Language="C#" Value="public void Rename (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Rename(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.ProjectItem.Rename(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Rename (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Rename(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.Rename : string -&gt; unit" Usage="projectItem.Rename name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der neue Name des Elements.</param>
        <summary>Benennt das Element um.
Entspricht dem Festlegen des <see cref="P:Microsoft.Build.Evaluation.ProjectItem.UnevaluatedInclude" />-Werts.
Im Allgemeinen erfolgt keine Erweiterung. Dies liegt daran, dass eine Erweiterung möglicherweise mehrere Elemente zur Folge hätte. Dies wäre keine sinnvolle Semantik beim Umbenennen eines einzelnen Elements.
Wenn das Element jedoch nicht unterteilt werden muss (wodurch das zugehörige ProjectItemElement ungültig würde) und beim Erweitern des neuen Werts genau ein Element entsteht, wird das ausgewertete Include mit dem erweiterten Wert aktualisiert (nicht mit dem nicht erweiterten Wert).</summary>
        <remarks>Auch wenn der neue Wert auf 0 (null) Elemente erweitert wird, wird er nicht erweitert.
Der gängige Fall, an dem wir für die Erweiterung interessiert sind, ist das Festlegen von etwas wie "$ (sourcesroot) \foo.cs" und das Erweitern dieses Elements auf ein einzelnes Element. Wenn "@ (foo)" als neuer Name festgelegt ist und der Wert auf "blank" erweitert wird, kann dies für den Host und möglicherweise sogar nicht behandelt werden, wenn bei einer vollständigen erneuten Auswertung der Wert nicht auf "blank" erweitert wird. Aus diesem Grund sind wir vorsichtig und unterstützen nur das gängigste Szenario. Viele Hosts führen eine erneute Auswertung aus, bevor Sie trotzdem lesen.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetMetadataValue">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Evaluation.ProjectMetadata SetMetadataValue (string name, string unevaluatedValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Build.Evaluation.ProjectMetadata SetMetadataValue(string name, string unevaluatedValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.ProjectItem.SetMetadataValue(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function SetMetadataValue (name As String, unevaluatedValue As String) As ProjectMetadata" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Build::Evaluation::ProjectMetadata ^ SetMetadataValue(System::String ^ name, System::String ^ unevaluatedValue);" />
      <MemberSignature Language="F#" Value="member this.SetMetadataValue : string * string -&gt; Microsoft.Build.Evaluation.ProjectMetadata" Usage="projectItem.SetMetadataValue (name, unevaluatedValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Evaluation.ProjectMetadata</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="unevaluatedValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der hinzuzufügenden Metadaten.</param>
        <param name="unevaluatedValue">Der nicht ausgewertete Wert der hinzuzufügenden Metadaten.</param>
        <summary>Fügt Metadaten mit dem angegebenen Namen und Wert zum Element hinzu.
Aktualisiert vorhandene Metadaten, wenn sie bereits mit demselben Namen direkt für das Element definiert wurden (nicht aus einer Elementdefinition geerbte Daten).
Aktualisiert das ausgewertete Projekt, wirkt sich bis zur erneuten Auswertung jedoch auf keine weiteren Elemente des Projekts aus. Wenn z. B. ein Metadatenelement mit dem Namen „m“ für ein Element des Typs „i“ hinzugefügt wird, wirkt sich dies nicht auf „j“ aus, das von „@(j-&gt;'%(m)')“ bis zur erneuten Auswertung ausgewertet wird.
Auch wenn der nicht ausgewertete Wert „m“ auf etwas festgelegt wird, das durch die Auswertung verändert wird, wie z. B. „$(p)“, wird der ausgewertete Wert bis zur erneuten Auswertung auf das literale „$(p)“ festgelegt.
Dies ist eine praktische Möglichkeit, die nicht unbedingt dazu führt, dass sich das Projekt ohne eine erneute Auswertung in einem völlig in sich stimmigen Zustand befindet.
Gibt das neue oder vorhandene Metadatum zurück.</summary>
        <returns>Die neuen Metadaten. Gibt diese Metadaten zurück, wenn Metadaten mit dem angegebenen Namen bereits vorhanden sind.</returns>
        <remarks>Bei einem nicht ausgewerteten Wert wird vorausgesetzt, dass er bei Bedarf</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetMetadataValue">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Evaluation.ProjectMetadata SetMetadataValue (string name, string unevaluatedValue, bool propagateMetadataToSiblingItems);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Build.Evaluation.ProjectMetadata SetMetadataValue(string name, string unevaluatedValue, bool propagateMetadataToSiblingItems) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.ProjectItem.SetMetadataValue(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function SetMetadataValue (name As String, unevaluatedValue As String, propagateMetadataToSiblingItems As Boolean) As ProjectMetadata" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Build::Evaluation::ProjectMetadata ^ SetMetadataValue(System::String ^ name, System::String ^ unevaluatedValue, bool propagateMetadataToSiblingItems);" />
      <MemberSignature Language="F#" Value="member this.SetMetadataValue : string * string * bool -&gt; Microsoft.Build.Evaluation.ProjectMetadata" Usage="projectItem.SetMetadataValue (name, unevaluatedValue, propagateMetadataToSiblingItems)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Evaluation.ProjectMetadata</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
        <Parameter Name="unevaluatedValue" Type="System.String" Index="1" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
        <Parameter Name="propagateMetadataToSiblingItems" Type="System.Boolean" Index="2" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
      </Parameters>
      <Docs>
        <param name="name">Metadatenname</param>
        <param name="unevaluatedValue">Metadatenwert</param>
        <param name="propagateMetadataToSiblingItems">Wenn der Wert „true“ lautet, werden die Metadaten direkt zum <see cref="T:Microsoft.Build.Construction.ProjectItemElement" />-Element hinzugefügt (aus dem dieses <see cref="T:Microsoft.Build.Evaluation.ProjectItem" />-Element stammt). Dadurch soll erreicht werden, dass sich der Vorgang auf alle anderen gleichgeordneten Elemente auswirkt.</param>
        <summary>Überladung von <see cref="M:Microsoft.Build.Evaluation.ProjectItem.SetMetadataValue(System.String,System.String)" />. Fügt die Option hinzu, um das Element nicht aufzuteilen, die sich auf alle gleichgeordneten Elemente auswirkt.
Gleichgeordnete Elemente werden als ProjectItem-Instanzen definiert, die basierend auf demselben Element erstellt wurden.
            
Dies ist eine praktische Möglichkeit, die nicht unbedingt dazu führt, dass sich das Projekt ohne eine erneute Auswertung in einem völlig in sich stimmigen Zustand befindet</summary>
        <returns>Gibt das neue oder vorhandene Metadatum zurück.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnevaluatedInclude">
      <MemberSignature Language="C#" Value="public string UnevaluatedInclude { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UnevaluatedInclude" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.ProjectItem.UnevaluatedInclude" />
      <MemberSignature Language="VB.NET" Value="Public Property UnevaluatedInclude As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UnevaluatedInclude { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.UnevaluatedInclude : string with get, set" Usage="Microsoft.Build.Evaluation.ProjectItem.UnevaluatedInclude" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den nicht ausgewerteten Wert des Include ab oder legt ihn fest.</summary>
        <value>Der nicht ausgewertete Wert des Include-Attributs.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Xml">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Construction.ProjectItemElement Xml { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Build.Construction.ProjectItemElement Xml" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.ProjectItem.Xml" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Xml As ProjectItemElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Build::Construction::ProjectItemElement ^ Xml { Microsoft::Build::Construction::ProjectItemElement ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Xml : Microsoft.Build.Construction.ProjectItemElement" Usage="Microsoft.Build.Evaluation.ProjectItem.Xml" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Construction.ProjectItemElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>XML-Unterstützungselement.
Kann nie NULL sein.</summary>
        <value>Das Element Element, das diesem Element zugeordnet ist, das nie sein kann <see langword="null" /> .</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
