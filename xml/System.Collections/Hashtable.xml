<Type Name="Hashtable" FullName="System.Collections.Hashtable">
  <Metadata><Meta Name="ms.openlocfilehash" Value="95725a0432ff064cbad54d58488e75dd8a9b9ef9" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69333921" /></Metadata><TypeSignature Language="C#" Value="public class Hashtable : ICloneable, System.Collections.IDictionary, System.Runtime.Serialization.IDeserializationCallback, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Hashtable extends System.Object implements class System.Collections.ICollection, class System.Collections.IDictionary, class System.Collections.IEnumerable, class System.ICloneable, class System.Runtime.Serialization.IDeserializationCallback, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Hashtable" />
  <TypeSignature Language="VB.NET" Value="Public Class Hashtable&#xA;Implements ICloneable, IDeserializationCallback, IDictionary, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Hashtable : ICloneable, System::Collections::IDictionary, System::Runtime::Serialization::IDeserializationCallback, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type Hashtable = class&#xA;    interface IDictionary&#xA;    interface ISerializable&#xA;    interface IDeserializationCallback&#xA;    interface ICloneable&#xA;    interface ICollection&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Collections.NonGeneric</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IDictionary</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.IDeserializationCallback</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Hashtable/HashtableDebugView))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt eine Auflistung von Schlüssel-Wert-Paaren dar, die auf Grundlage des Hashcodes des Schlüssels geordnet sind.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks

Jedes Element ist ein Schlüssel-Wert-Paar, das <xref:System.Collections.DictionaryEntry> in einem-Objekt gespeichert ist. Ein Schlüssel kann nicht `null`sein, aber ein Wert kann sein.  

> [!IMPORTANT]
>  Es wird nicht empfohlen, die- `Hashtable` Klasse für die neue Entwicklung zu verwenden. Stattdessen wird die Verwendung der generischen <xref:System.Collections.Generic.Dictionary%602> -Klasse empfohlen. Weitere Informationen finden Sie unter [nicht generische](https://github.com/dotnet/platform-compat/blob/master/docs/DE0006.md) Auflistungen sollten nicht auf GitHub verwendet werden.
  
 Die Objekte, die von <xref:System.Collections.Hashtable> einem als Schlüssel verwendet werden, müssen die <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> -Methode ( <xref:System.Collections.IHashCodeProvider> oder die-Schnitt <xref:System.Object.Equals%2A?displayProperty=nameWithType> Stelle) und die <xref:System.Collections.IComparer> -Methode (oder die-Schnittstelle) überschreiben. Die Implementierung von Methoden und Schnittstellen muss die Groß-/Kleinschreibung auf die gleiche Weise behandeln. Andernfalls verhält sich <xref:System.Collections.Hashtable> das möglicherweise falsch. Wenn Sie z. b. <xref:System.Collections.Hashtable>ein erstellen, müssen Sie <xref:System.Collections.CaseInsensitiveHashCodeProvider> die-Klasse ( <xref:System.Collections.IHashCodeProvider> oder eine beliebige Implementierung ohne Berücksichtigung <xref:System.Collections.IComparer> der <xref:System.Collections.CaseInsensitiveComparer> Groß-/Kleinschreibung) mit der-Klasse (oder mit einer anderen Implementierung ohne Berücksichtigung der groß-  
  
 Außerdem müssen diese Methoden dieselben Ergebnisse erzielen, wenn Sie mit denselben Parametern aufgerufen werden, während der Schlüssel in <xref:System.Collections.Hashtable>vorhanden ist. Eine Alternative besteht darin, einen <xref:System.Collections.Hashtable> Konstruktor mit einem <xref:System.Collections.IEqualityComparer> -Parameter zu verwenden. Wenn die Schlüssel Gleichheit einfach Verweis Gleichheit wäre, wäre die geerbte <xref:System.Object.Equals%2A?displayProperty=nameWithType> Implementierung von <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> und ausreichend.  
  
 Schlüssel Objekte müssen unveränderlich sein, solange Sie als Schlüssel in der <xref:System.Collections.Hashtable>verwendet werden.  
  
 Wenn ein Element hinzugefügt <xref:System.Collections.Hashtable>wird, wird das Element auf Grundlage des Hashcodes des Schlüssels in einen Bucket eingefügt. Nachfolgende Suchvorgänge des Schlüssels verwenden den Hashcode des Schlüssels, um nur in einem bestimmten Bucket zu suchen. Dadurch wird die Anzahl der Schlüssel Vergleiche, die für die Suche nach einem Element erforderlich sind, erheblich reduziert.  
  
 Der Ladefaktor <xref:System.Collections.Hashtable> eines bestimmt das maximale Verhältnis von Elementen zu Bucket. Kleinere Auslastungs Faktoren verursachen schnellere durchschnittliche Suchzeiten zu den Kosten für eine höhere Arbeitsspeicher Nutzung. Der Standard Lastfaktor 1,0 bietet im Allgemeinen das beste Gleichgewicht zwischen Geschwindigkeit und Größe. Ein anderer Ladefaktor kann auch angegeben werden, wenn <xref:System.Collections.Hashtable> der erstellt wird.  
  
 Beim Hinzufügen <xref:System.Collections.Hashtable> von Elementen zu <xref:System.Collections.Hashtable>einem erhöht sich der tatsächliche Ladefaktor des. Wenn der tatsächliche Lastfaktor den angegebenen Lastfaktor erreicht, <xref:System.Collections.Hashtable> wird die Anzahl der bucketwerte in automatisch auf die kleinste Primzahl vergrößert, die größer als die doppelte Anzahl von <xref:System.Collections.Hashtable> Buchern ist.  
  
 Jedes Schlüsselobjekt in der <xref:System.Collections.Hashtable> muss eine eigene Hash Funktion bereitstellen, auf die durch Aufrufen <xref:System.Collections.Hashtable.GetHash%2A>von zugegriffen werden kann. Allerdings kann jedes Objekt <xref:System.Collections.IHashCodeProvider> , das implementiert, an <xref:System.Collections.Hashtable> einen Konstruktor übergeben werden, und diese Hash Funktion wird für alle Objekte in der Tabelle verwendet.  
  
 Die Kapazität <xref:System.Collections.Hashtable> eines ist die Anzahl der Elemente, die <xref:System.Collections.Hashtable> in der enthalten sein können. Wenn Elemente zu einem <xref:System.Collections.Hashtable>hinzugefügt werden, wird die Kapazität bei Bedarf durch erneute Zuweisung automatisch erhöht.  
  
 **Nur .NET Framework:** Bei sehr großen <xref:System.Collections.Hashtable> Objekten können Sie die maximale Kapazität auf 2 Milliarden Elemente in einem 64-Bit-System erhöhen, indem Sie `enabled` das-Attribut [`<gcAllowVeryLargeObjects>`](~/docs/framework/configure-apps/file-schema/runtime/gcallowverylargeobjects-element.md) des-Konfigurations `true` Elements in der Laufzeitumgebung auf festlegen.  
  
 Die `foreach` -Anweisung der C# -Sprache`For Each` (in Visual Basic) gibt ein Objekt des Typs der Elemente in der Auflistung zurück. Da jedes Element von <xref:System.Collections.Hashtable> ein Schlüssel-Wert-Paar ist, ist der Elementtyp nicht der Typ des Schlüssels oder der Typ des Werts. Stattdessen ist <xref:System.Collections.DictionaryEntry>der Elementtyp. Beispiel:  
  
 [!code-cpp[System.Collections.Hashtable_ClassExample#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ClassExample/cpp/remarks.cpp#01)]
 [!code-csharp[System.Collections.Hashtable_ClassExample#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ClassExample/cs/remarks.cs#01)]
 [!code-vb[System.Collections.Hashtable_ClassExample#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ClassExample/vb/remarks.vb#01)]  
  
 Bei `foreach` der-Anweisung handelt es sich um einen Wrapper um den Enumerator, der nur das Lesen von, das Schreiben in die Auflistung ermöglicht.  
  
 Da das Serialisieren und Deserialisieren eines Enumerators für <xref:System.Collections.Hashtable> einen bewirken kann, dass die Elemente neu angeordnet werden, kann die Enumeration nicht fortgesetzt werden, <xref:System.Collections.IEnumerator.Reset%2A> ohne die-Methode aufzurufende.  
  
> [!NOTE]
>  Da Schlüssel geerbt werden können und ihr Verhalten geändert wird, kann die absolute Eindeutigkeit nicht durch Vergleiche mithilfe <xref:System.Type.Equals%2A> der-Methode gewährleistet werden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie verschiedene Funktionen von <xref:System.Collections.Hashtable> erstellt, initialisiert und durchgeführt werden und wie die Schlüssel und Werte gedruckt werden.  
  
 [!code-cpp[System.Collections.Hashtable_ClassExample#00](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ClassExample/cpp/hashtable_example.cpp#00)]
 [!code-csharp[System.Collections.Hashtable_ClassExample#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ClassExample/cs/hashtable_example.cs#00)]
 [!code-vb[System.Collections.Hashtable_ClassExample#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ClassExample/vb/hashtable_example.vb#00)]
 [!code-powershell[System.Collections.Hashtable_ClassExample#00](~/samples/snippets/powershell/VS_Snippets_CLR_System/system.collections.hashtable.class/ps/hashtable.ps1#00)]  
  
 ]]></format>
    </remarks>
    <threadsafe><see cref="T:System.Collections.Hashtable" />ist Thread sicher für die Verwendung durch mehrere Lesethreads und einen einzelnen Schreib Thread. Es ist Thread sicher für die Verwendung von mehreren Threads, wenn nur einer der Threads Schreibvorgänge (Update) ausführt, die Sperr freie Lesevorgänge ermöglichen, vorausgesetzt, dass die Writer in die <see cref="T:System.Collections.Hashtable" />serialisiert werden. Zur Unterstützung mehrerer Writer müssen alle Vorgänge <see cref="T:System.Collections.Hashtable" /> auf dem durch den von der <see cref="M:System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)" /> -Methode zurückgegebenen Wrapper erfolgen, vorausgesetzt, es sind keine <see cref="T:System.Collections.Hashtable" /> Threads vorhanden, die das Objekt lesen.  
  
Das Auflisten durch eine Auflistung ist intrinsisch keine Thread sichere Prozedur. Selbst wenn eine Auflistung synchronisiert wird, besteht die Möglichkeit, dass andere Threads sie ändern. Dies führt dazu, dass der Enumerator eine Ausnahme auslöst. Um während der Enumeration Threadsicherheit zu gewährleisten, können Sie entweder die Auflistung während der gesamten Enumeration sperren oder die Ausnahmen, die aus von anderen Threads stammenden Änderungen resultieren, abfangen.</threadsafe>
    <altmember cref="T:System.Collections.IDictionary" />
    <altmember cref="T:System.Collections.IHashCodeProvider" />
    <altmember cref="M:System.Object.GetHashCode" />
    <altmember cref="M:System.Object.Equals(System.Object)" />
    <altmember cref="T:System.Collections.DictionaryEntry" />
    <altmember cref="T:System.Collections.Generic.Dictionary`2" />
    <altmember cref="T:System.Collections.IEqualityComparer" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Collections.Hashtable" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue leere Instanz der <see cref="T:System.Collections.Hashtable" />-Klasse unter Verwendung der anfänglichen Standardkapazität, des Standardlastfaktors, Hashcode-Standardanbieters und des Standardcomparers.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Kapazität einer Hash Tabelle wird verwendet, um die optimale Anzahl von Hash Tabellen-Bucket basierend auf dem Lastfaktor zu berechnen. Die Kapazität wird bei Bedarf automatisch erweitert.  
  
 Der Ladefaktor ist das maximale Verhältnis von Elementen zu Bucket. Ein geringerer Ladefaktor bedeutet einen schnelleren Such Faktor, um den Speicherverbrauch zu erhöhen.  
  
 Wenn der tatsächliche Lastfaktor den angegebenen Lastfaktor erreicht, wird die Bucketanzahl automatisch auf die kleinste Primzahl vergrößert, die größer ist als die doppelte Anzahl an bucketwerten.  
  
 Der Hashcode-Anbieter gibt Hashcodes für Schlüssel im- <xref:System.Collections.Hashtable> Objekt an. Der standardmäßige Hashcode-Anbieter ist die Schlüssel Implementierung <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>von.  
  
 Der Vergleich bestimmt, ob zwei Schlüssel gleich sind. Jeder Schlüssel in einem <xref:System.Collections.Hashtable> muss eindeutig sein. Der Standardcomparer ist die Schlüssel Implementierung von <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Dieser Konstruktor ist ein O (1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden Hash Tabellen mit unter <xref:System.Collections.Hashtable> schiedlichen Konstruktoren erstellt und die Unterschiede im Verhalten der Hash Tabellen veranschaulicht, auch wenn beide dieselben Elemente enthalten.  
  
 [!code-cpp[System.Collections.Hashtable_ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctor/CPP/hashtable_ctor.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctor/CS/hashtable_ctor.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctor/VB/hashtable_ctor.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (System.Collections.IDictionary d);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IDictionary d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (d As IDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(System::Collections::IDictionary ^ d);" />
      <MemberSignature Language="F#" Value="new System.Collections.Hashtable : System.Collections.IDictionary -&gt; System.Collections.Hashtable" Usage="new System.Collections.Hashtable d" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="d" Type="System.Collections.IDictionary" />
      </Parameters>
      <Docs>
        <param name="d">Das <see cref="T:System.Collections.IDictionary" />-Objekt, das in ein neues <see cref="T:System.Collections.Hashtable" />-Objekt kopiert werden soll.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Collections.Hashtable" />-Klasse durch Kopieren der Elemente aus dem angegebenen Wörterbuch in das neue <see cref="T:System.Collections.Hashtable" />-Objekt. Das neue <see cref="T:System.Collections.Hashtable" />-Objekt besitzt eine Anfangskapazität, die mit der Anzahl der kopierten Elemente identisch ist, und verwendet den Standardlastfaktor, den Hashcode-Standardanbieter und den Standardcomparer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die anfängliche Kapazität wird auf die Anzahl der Elemente im Quell Wörterbuch festgelegt. Die Kapazität wird basierend auf dem Ladefaktor automatisch nach Bedarf angepasst.  
  
 Der Ladefaktor ist das maximale Verhältnis von Elementen zu Bucket. Ein geringerer Ladefaktor bedeutet einen schnelleren Such Faktor, um den Speicherverbrauch zu erhöhen.  
  
 Wenn der tatsächliche Lastfaktor den angegebenen Lastfaktor erreicht, wird die Bucketanzahl automatisch auf die kleinste Primzahl vergrößert, die größer ist als die doppelte Anzahl an bucketwerten.  
  
 Der Hashcode-Anbieter gibt Hashcodes für Schlüssel im- <xref:System.Collections.Hashtable> Objekt an. Der standardmäßige Hashcode-Anbieter ist die Schlüssel Implementierung <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>von.  
  
 Der Vergleich bestimmt, ob zwei Schlüssel gleich sind. Jeder Schlüssel in einem <xref:System.Collections.Hashtable> muss eindeutig sein. Der Standardcomparer ist die Schlüssel Implementierung von <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Die Elemente der neuen <xref:System.Collections.Hashtable> werden in derselben Reihenfolge sortiert, in der der Enumerator das <xref:System.Collections.IDictionary> -Objekt durchläuft.  
  
 Dieser Konstruktor ist ein O (`n`)-Vorgang, `n` wobei die `d` Anzahl der Elemente im-Parameter ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden Hash Tabellen mit unter <xref:System.Collections.Hashtable> schiedlichen Konstruktoren erstellt und die Unterschiede im Verhalten der Hash Tabellen veranschaulicht, auch wenn beide dieselben Elemente enthalten.  
  
 [!code-cpp[System.Collections.Hashtable_ctorDictionary#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionary/CPP/hashtable_ctordictionary.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctorDictionary#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionary/CS/hashtable_ctordictionary.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctorDictionary#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionary/VB/hashtable_ctordictionary.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="d" /> ist <see langword="null" />.</exception>
        <altmember cref="T:System.Collections.IDictionary" />
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (System.Collections.IEqualityComparer equalityComparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IEqualityComparer equalityComparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (equalityComparer As IEqualityComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(System::Collections::IEqualityComparer ^ equalityComparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Hashtable : System.Collections.IEqualityComparer -&gt; System.Collections.Hashtable" Usage="new System.Collections.Hashtable equalityComparer" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="equalityComparer" Type="System.Collections.IEqualityComparer" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="equalityComparer">Das <see cref="T:System.Collections.IEqualityComparer" />-Objekt, das sowohl den Hashcodeanbieter als auch den Comparer zur Verwendung mit der <see cref="T:System.Collections.Hashtable" /> definiert.  
  
- oder - 
 <see langword="null" />, um den Hashcode-Standardanbieter und den Standardcomparer zu verwenden. Der Hashcode-Standardanbieter ist die Implementierung von <see cref="M:System.Object.GetHashCode" /> jedes Schlüssels, und der Standardcomparer ist die Implementierung von <see cref="M:System.Object.Equals(System.Object)" /> jedes Schlüssels.</param>
        <summary>Initialisiert eine neue leere Instanz der <see cref="T:System.Collections.Hashtable" />-Klasse unter Verwendung der anfänglichen Standardkapazität, des Standardlastfaktors und des angegebenen <see cref="T:System.Collections.IEqualityComparer" />-Objekts.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Kapazität einer Hash Tabelle wird verwendet, um die optimale Anzahl von Hash Tabellen-Bucket basierend auf dem Lastfaktor zu berechnen. Die Kapazität wird bei Bedarf automatisch erweitert.  
  
 Der Ladefaktor ist das maximale Verhältnis von Elementen zu Bucket. Ein geringerer Ladefaktor bedeutet einen schnelleren Such Faktor, um den Speicherverbrauch zu erhöhen.  
  
 Wenn der tatsächliche Lastfaktor den angegebenen Lastfaktor erreicht, wird die Bucketanzahl automatisch auf die kleinste Primzahl vergrößert, die größer ist als die doppelte Anzahl an bucketwerten.  
  
 Das <xref:System.Collections.IEqualityComparer> -Objekt enthält sowohl den Hash Code Anbieter als auch den Comparer. Wenn eine <xref:System.Collections.IEqualityComparer> <xref:System.Collections.Hashtable> <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> <xref:System.Object.Equals%2A?displayProperty=nameWithType> im Konstruktor verwendet wird, müssen die-Objekte, die als Schlüssel im-Objekt verwendet werden, die-Methode und die-Methode nicht überschreiben. <xref:System.Collections.Hashtable>  
  
 Der Hashcode-Anbieter gibt Hashcodes für Schlüssel in der <xref:System.Collections.Hashtable>aus. Der standardmäßige Hashcode-Anbieter ist die Schlüssel Implementierung <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>von.  
  
 Der Vergleich bestimmt, ob zwei Schlüssel gleich sind. Jeder Schlüssel in einem <xref:System.Collections.Hashtable> muss eindeutig sein. Der Standardcomparer ist die Schlüssel Implementierung von <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Ermöglicht <xref:System.Collections.IEqualityComparer> Szenarien wie Suchvorgänge mit Zeichen folgen ohne Beachtung der Groß-und Kleinschreibung.  
  
 Dieser Konstruktor ist ein O (1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden Hash Tabellen mit unter <xref:System.Collections.Hashtable> schiedlichen Konstruktoren erstellt und die Unterschiede im Verhalten der Hash Tabellen veranschaulicht, auch wenn beide dieselben Elemente enthalten.  
  
 [!code-cpp[System.Collections.Hashtable_ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctor/CPP/hashtable_ctor.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctor/CS/hashtable_ctor.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctor/VB/hashtable_ctor.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEqualityComparer" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(int capacity);" />
      <MemberSignature Language="F#" Value="new System.Collections.Hashtable : int -&gt; System.Collections.Hashtable" Usage="new System.Collections.Hashtable capacity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">Die ungefähre Anzahl von Elementen, die die <see cref="T:System.Collections.Hashtable" /> anfänglich enthalten kann.</param>
        <summary>Initialisiert eine neue leere Instanz der <see cref="T:System.Collections.Hashtable" />-Klasse unter Verwendung der angegebenen Anfangskapazität, des Standardlastfaktors, des Hashcode-Standardanbieters und des Standardcomparers.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie die anfängliche Kapazität angeben, entfällt die Notwendigkeit, beim Hinzufügen von Elementen zum <xref:System.Collections.Hashtable> Objekt eine Reihe von Ändern der Größe auszuführen. Die Kapazität wird basierend auf dem Ladefaktor automatisch nach Bedarf angepasst.  
  
 Der Ladefaktor ist das maximale Verhältnis von Elementen zu Bucket. Ein geringerer Ladefaktor bedeutet einen schnelleren Such Faktor, um den Speicherverbrauch zu erhöhen.  
  
 Wenn der tatsächliche Lastfaktor den angegebenen Lastfaktor erreicht, wird die Bucketanzahl automatisch auf die kleinste Primzahl vergrößert, die größer ist als die doppelte Anzahl an bucketwerten.  
  
 Der Hashcode-Anbieter gibt Hashcodes für Schlüssel in der <xref:System.Collections.Hashtable>aus. Der standardmäßige Hashcode-Anbieter ist die Schlüssel Implementierung <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>von.  
  
 Der Vergleich bestimmt, ob zwei Schlüssel gleich sind. Jeder Schlüssel in einem <xref:System.Collections.Hashtable> muss eindeutig sein. Der Standardcomparer ist die Schlüssel Implementierung von <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Dieser Konstruktor ist ein O (`n`)-Vorgang, `n` bei `capacity`dem gleich ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden Hash Tabellen mit unter <xref:System.Collections.Hashtable> schiedlichen Konstruktoren erstellt und die Unterschiede im Verhalten der Hash Tabellen veranschaulicht, auch wenn beide dieselben Elemente enthalten.  
  
 [!code-cpp[System.Collections.Hashtable_ctorInt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorInt/CPP/hashtable_ctorint.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctorInt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorInt/CS/hashtable_ctorint.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctorInt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorInt/VB/hashtable_ctorint.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> ist kleiner als Null.</exception>
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (System.Collections.IDictionary d, System.Collections.IEqualityComparer equalityComparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IDictionary d, class System.Collections.IEqualityComparer equalityComparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (d As IDictionary, equalityComparer As IEqualityComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(System::Collections::IDictionary ^ d, System::Collections::IEqualityComparer ^ equalityComparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Hashtable : System.Collections.IDictionary * System.Collections.IEqualityComparer -&gt; System.Collections.Hashtable" Usage="new System.Collections.Hashtable (d, equalityComparer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="d" Type="System.Collections.IDictionary" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="equalityComparer" Type="System.Collections.IEqualityComparer" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="d">Das <see cref="T:System.Collections.IDictionary" />-Objekt, das in ein neues <see cref="T:System.Collections.Hashtable" />-Objekt kopiert werden soll.</param>
        <param name="equalityComparer">Der <see cref="T:System.Collections.IEqualityComparer" />, der sowohl den Hashcodeanbieter als auch den Comparer zur Verwendung mit der <see cref="T:System.Collections.Hashtable" /> definiert.  
  
- oder - 
 <see langword="null" />, um den Hashcode-Standardanbieter und den Standardcomparer zu verwenden. Der Hashcode-Standardanbieter ist die Implementierung von <see cref="M:System.Object.GetHashCode" /> jedes Schlüssels, und der Standardcomparer ist die Implementierung von <see cref="M:System.Object.Equals(System.Object)" /> jedes Schlüssels.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Collections.Hashtable" />-Klasse durch Kopieren der Elemente aus dem angegebenen Wörterbuch in ein neues <see cref="T:System.Collections.Hashtable" />-Objekt. Das neue <see cref="T:System.Collections.Hashtable" />-Objekt besitzt eine Anfangskapazität, die mit der Anzahl der kopierten Elemente identisch ist, und verwendet den Standardlastfaktor sowie das angegebene <see cref="T:System.Collections.IEqualityComparer" />-Objekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die anfängliche Kapazität wird auf die Anzahl der Elemente im Quell Wörterbuch festgelegt. Die Kapazität wird basierend auf dem Ladefaktor automatisch nach Bedarf angepasst.  
  
 Der Ladefaktor ist das maximale Verhältnis von Elementen zu Bucket. Ein geringerer Ladefaktor bedeutet einen schnelleren Such Faktor, um den Speicherverbrauch zu erhöhen.  
  
 Wenn der tatsächliche Lastfaktor den angegebenen Lastfaktor erreicht, wird die Bucketanzahl automatisch auf die kleinste Primzahl vergrößert, die größer ist als die doppelte Anzahl an bucketwerten.  
  
 Das <xref:System.Collections.IEqualityComparer> -Objekt enthält sowohl den Hash Code Anbieter als auch den Comparer. Wenn eine <xref:System.Collections.IEqualityComparer> <xref:System.Collections.Hashtable> <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> <xref:System.Object.Equals%2A?displayProperty=nameWithType> im Konstruktor verwendet wird, müssen die-Objekte, die als Schlüssel im-Objekt verwendet werden, die-Methode und die-Methode nicht überschreiben. <xref:System.Collections.Hashtable>  
  
 Der Hashcode-Anbieter gibt Hashcodes für Schlüssel in der <xref:System.Collections.Hashtable>aus. Der standardmäßige Hashcode-Anbieter ist die Schlüssel Implementierung <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>von.  
  
 Der Vergleich bestimmt, ob zwei Schlüssel gleich sind. Jeder Schlüssel in einem <xref:System.Collections.Hashtable> muss eindeutig sein. Der Standardcomparer ist die Schlüssel Implementierung von <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Ermöglicht <xref:System.Collections.IEqualityComparer> Szenarien wie Suchvorgänge mit Zeichen folgen ohne Beachtung der Groß-und Kleinschreibung.  
  
 Die Elemente der neuen <xref:System.Collections.Hashtable> werden in derselben Reihenfolge sortiert, in der der Enumerator das <xref:System.Collections.IDictionary> -Objekt durchläuft.  
  
 Dieser Konstruktor ist ein O (`n`)-Vorgang, `n` wobei die `d` Anzahl der Elemente im-Parameter ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden Hash Tabellen mit unter <xref:System.Collections.Hashtable> schiedlichen Konstruktoren erstellt und die Unterschiede im Verhalten der Hash Tabellen veranschaulicht, auch wenn beide dieselben Elemente enthalten.  
  
 [!code-cpp[System.Collections.Hashtable_ctorDictionary#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionary/CPP/hashtable_ctordictionary.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctorDictionary#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionary/CS/hashtable_ctordictionary.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctorDictionary#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionary/VB/hashtable_ctordictionary.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="d" /> ist <see langword="null" />.</exception>
        <altmember cref="T:System.Collections.IDictionary" />
        <altmember cref="T:System.Collections.IEqualityComparer" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (System.Collections.IDictionary d, float loadFactor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IDictionary d, float32 loadFactor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (d As IDictionary, loadFactor As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(System::Collections::IDictionary ^ d, float loadFactor);" />
      <MemberSignature Language="F#" Value="new System.Collections.Hashtable : System.Collections.IDictionary * single -&gt; System.Collections.Hashtable" Usage="new System.Collections.Hashtable (d, loadFactor)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="d" Type="System.Collections.IDictionary" />
        <Parameter Name="loadFactor" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="d">Das <see cref="T:System.Collections.IDictionary" />-Objekt, das in ein neues <see cref="T:System.Collections.Hashtable" />-Objekt kopiert werden soll.</param>
        <param name="loadFactor">Eine Zahl im Bereich 0.1 bis 1.0, die mit dem Standardwert für die optimale Leistung multipliziert wird. Das Ergebnis ist das maximale Verhältnis von Elementen zu Buckets.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Collections.Hashtable" />-Klasse durch Kopieren der Elemente aus dem angegebenen Wörterbuch in das neue <see cref="T:System.Collections.Hashtable" />-Objekt. Das neue <see cref="T:System.Collections.Hashtable" />-Objekt besitzt eine Anfangskapazität, die mit der Anzahl der kopierten Elemente identisch ist, und verwendet den angegebenen Lastfaktor sowie den Hashcode-Standardanbieter und den Standardcomparer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die anfängliche Kapazität wird auf die Anzahl der Elemente im Quell Wörterbuch festgelegt. Die Kapazität wird basierend auf dem Ladefaktor automatisch nach Bedarf angepasst.  
  
 Der Ladefaktor ist das maximale Verhältnis von Elementen zu Bucket. Ein geringerer Ladefaktor bedeutet einen schnelleren Such Faktor, um den Speicherverbrauch zu erhöhen. Der Lastfaktor 1,0 ist das beste Gleichgewicht zwischen Geschwindigkeit und Größe.  
  
 Wenn der tatsächliche Lastfaktor den angegebenen Lastfaktor erreicht, wird die Bucketanzahl automatisch auf die kleinste Primzahl vergrößert, die größer ist als die doppelte Anzahl an bucketwerten.  
  
 Der Hashcode-Anbieter gibt Hashcodes für Schlüssel im- <xref:System.Collections.Hashtable> Objekt an. Der standardmäßige Hashcode-Anbieter ist die Schlüssel Implementierung <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>von.  
  
 Der Vergleich bestimmt, ob zwei Schlüssel gleich sind. Jeder Schlüssel in einem <xref:System.Collections.Hashtable> muss eindeutig sein. Der Standardcomparer ist die Schlüssel Implementierung von <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Die Elemente der neuen <xref:System.Collections.Hashtable> werden in derselben Reihenfolge sortiert, in der der Enumerator das <xref:System.Collections.IDictionary> -Objekt durchläuft.  
  
 Dieser Konstruktor ist ein O (`n`)-Vorgang, `n` wobei die `d` Anzahl der Elemente im-Parameter ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden Hash Tabellen mit unter <xref:System.Collections.Hashtable> schiedlichen Konstruktoren erstellt und die Unterschiede im Verhalten der Hash Tabellen veranschaulicht, auch wenn beide dieselben Elemente enthalten.  
  
 [!code-cpp[System.Collections.Hashtable_ctorDictionaryFloat#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionaryFloat/CPP/hashtable_ctordictionaryfloat.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctorDictionaryFloat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionaryFloat/CS/hashtable_ctordictionaryfloat.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctorDictionaryFloat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionaryFloat/VB/hashtable_ctordictionaryfloat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="d" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="loadFactor" /> ist kleiner als 0,1.  
  
- oder - 
 <paramref name="loadFactor" /> ist größer als 1,0.</exception>
        <altmember cref="T:System.Collections.IDictionary" />
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (System.Collections.IHashCodeProvider hcp, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IHashCodeProvider hcp, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (hcp As IHashCodeProvider, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(System::Collections::IHashCodeProvider ^ hcp, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Hashtable : System.Collections.IHashCodeProvider * System.Collections.IComparer -&gt; System.Collections.Hashtable" Usage="new System.Collections.Hashtable (hcp, comparer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("Please use Hashtable(IEqualityComparer) instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="hcp" Type="System.Collections.IHashCodeProvider" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="hcp">Das <see cref="T:System.Collections.IHashCodeProvider" />-Objekt, das die Hashcodes für alle Schlüssel im <see cref="T:System.Collections.Hashtable" />-Objekt bereitstellt.  
  
- oder - 
 <see langword="null" />, wenn der Hashcode-Standardanbieter verwendet werden soll. Dies ist die jeweilige <see cref="M:System.Object.GetHashCode" />-Implementierung eines Schlüssels.</param>
        <param name="comparer">Das <see cref="T:System.Collections.IComparer" />-Objekt, mit dem ermittelt wird, ob zwei Schlüssel gleich sind.  
  
- oder - 
 <see langword="null" />, wenn der Standardcomparer verwendet werden soll. Dies ist die jeweilige <see cref="M:System.Object.Equals(System.Object)" />-Implementierung eines Schlüssels.</param>
        <summary>Initialisiert eine neue leere Instanz der <see cref="T:System.Collections.Hashtable" />-Klasse unter Verwendung der anfänglichen Standardkapazität, des Standardlastfaktors, des angegebenen Hashcodeanbieters und des angegebenen Comparers.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Kapazität einer Hash Tabelle wird verwendet, um die optimale Anzahl von Hash Tabellen-Bucket basierend auf dem Lastfaktor zu berechnen. Die Kapazität wird bei Bedarf automatisch erweitert.  
  
 Der Ladefaktor ist das maximale Verhältnis von Elementen zu Bucket. Ein geringerer Ladefaktor bedeutet einen schnelleren Such Faktor, um den Speicherverbrauch zu erhöhen.  
  
 Wenn der tatsächliche Lastfaktor den angegebenen Lastfaktor erreicht, wird die Bucketanzahl automatisch auf die kleinste Primzahl vergrößert, die größer ist als die doppelte Anzahl an bucketwerten.  
  
 Der Hashcode-Anbieter gibt Hashcodes für Schlüssel im- <xref:System.Collections.Hashtable> Objekt an. Der standardmäßige Hashcode-Anbieter ist die Schlüssel Implementierung <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>von.  
  
 Der Vergleich bestimmt, ob zwei Schlüssel gleich sind. Jeder Schlüssel in einem <xref:System.Collections.Hashtable> muss eindeutig sein. Der Standardcomparer ist die Schlüssel Implementierung von <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Der benutzerdefinierte Hashcode-Anbieter und der benutzerdefinierte Vergleich ermöglichen Szenarien wie Suchvorgänge mit Zeichen folgen ohne Beachtung der Groß-und Kleinschreibung.  
  
 Dieser Konstruktor ist ein O (1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden Hash Tabellen mit unter <xref:System.Collections.Hashtable> schiedlichen Konstruktoren erstellt und die Unterschiede im Verhalten der Hash Tabellen veranschaulicht, auch wenn beide dieselben Elemente enthalten.  
  
 [!code-cpp[System.Collections.Hashtable_ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctor/CPP/hashtable_ctor.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctor/CS/hashtable_ctor.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctor/VB/hashtable_ctor.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IHashCodeProvider" />
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (int capacity, System.Collections.IEqualityComparer equalityComparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity, class System.Collections.IEqualityComparer equalityComparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer, equalityComparer As IEqualityComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(int capacity, System::Collections::IEqualityComparer ^ equalityComparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Hashtable : int * System.Collections.IEqualityComparer -&gt; System.Collections.Hashtable" Usage="new System.Collections.Hashtable (capacity, equalityComparer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="equalityComparer" Type="System.Collections.IEqualityComparer" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="capacity">Die ungefähre Anzahl von Elementen, die die <see cref="T:System.Collections.Hashtable" /> anfänglich enthalten kann.</param>
        <param name="equalityComparer">Der <see cref="T:System.Collections.IEqualityComparer" />, der sowohl den Hashcodeanbieter als auch den Comparer zur Verwendung mit der <see cref="T:System.Collections.Hashtable" /> definiert.  
  
- oder - 
 <see langword="null" />, um den Hashcode-Standardanbieter und den Standardcomparer zu verwenden. Der Hashcode-Standardanbieter ist die Implementierung von <see cref="M:System.Object.GetHashCode" /> jedes Schlüssels, und der Standardcomparer ist die Implementierung von <see cref="M:System.Object.Equals(System.Object)" /> jedes Schlüssels.</param>
        <summary>Initialisiert eine neue leere Instanz der <see cref="T:System.Collections.Hashtable" />-Klasse unter Verwendung der angegebenen Anfangskapazität und des angegebenen <see cref="T:System.Collections.IEqualityComparer" /> sowie des Standardlastfaktors.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie die anfängliche Kapazität angeben, entfällt die Notwendigkeit, beim Hinzufügen von Elementen zum <xref:System.Collections.Hashtable> Objekt eine Reihe von Ändern der Größe auszuführen. Die Kapazität wird basierend auf dem Ladefaktor automatisch nach Bedarf angepasst.  
  
 Der Ladefaktor ist das maximale Verhältnis von Elementen zu Bucket. Ein geringerer Ladefaktor bedeutet einen schnelleren Such Faktor, um den Speicherverbrauch zu erhöhen.  
  
 Wenn der tatsächliche Lastfaktor den angegebenen Lastfaktor erreicht, wird die Bucketanzahl automatisch auf die kleinste Primzahl vergrößert, die größer ist als die doppelte Anzahl an bucketwerten.  
  
 Das <xref:System.Collections.IEqualityComparer> -Objekt enthält sowohl den Hash Code Anbieter als auch den Comparer. Wenn eine <xref:System.Collections.IEqualityComparer> <xref:System.Collections.Hashtable> <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> <xref:System.Object.Equals%2A?displayProperty=nameWithType> im Konstruktor verwendet wird, müssen die-Objekte, die als Schlüssel in verwendet werden, die-Methode und die-Methode nicht überschreiben. <xref:System.Collections.Hashtable>  
  
 Der Hashcode-Anbieter gibt Hashcodes für Schlüssel in der <xref:System.Collections.Hashtable>aus. Der standardmäßige Hashcode-Anbieter ist die Schlüssel Implementierung <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>von.  
  
 Der Vergleich bestimmt, ob zwei Schlüssel gleich sind. Jeder Schlüssel in einem <xref:System.Collections.Hashtable> muss eindeutig sein. Der Standardcomparer ist die Schlüssel Implementierung von <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Ermöglicht <xref:System.Collections.IEqualityComparer> Szenarien wie Suchvorgänge mit Zeichen folgen ohne Beachtung der Groß-und Kleinschreibung.  
  
 Dieser Konstruktor ist ein O (`n`)-Vorgang, `n` wobei der `capacity` -Parameter ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden Hash Tabellen mit unter <xref:System.Collections.Hashtable> schiedlichen Konstruktoren erstellt und die Unterschiede im Verhalten der Hash Tabellen veranschaulicht, auch wenn beide dieselben Elemente enthalten.  
  
 [!code-cpp[System.Collections.Hashtable_ctorInt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorInt/CPP/hashtable_ctorint.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctorInt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorInt/CS/hashtable_ctorint.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctorInt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorInt/VB/hashtable_ctorint.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> ist kleiner als Null.</exception>
        <altmember cref="T:System.Collections.IEqualityComparer" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (int capacity, float loadFactor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity, float32 loadFactor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer, loadFactor As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(int capacity, float loadFactor);" />
      <MemberSignature Language="F#" Value="new System.Collections.Hashtable : int * single -&gt; System.Collections.Hashtable" Usage="new System.Collections.Hashtable (capacity, loadFactor)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
        <Parameter Name="loadFactor" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="capacity">Die ungefähre Anzahl von Elementen, die die <see cref="T:System.Collections.Hashtable" /> anfänglich enthalten kann.</param>
        <param name="loadFactor">Eine Zahl im Bereich 0,1 bis 1,0, die mit dem Standardwert für die optimale Leistung multipliziert wird. Das Ergebnis ist das maximale Verhältnis von Elementen zu Buckets.</param>
        <summary>Initialisiert eine neue leere Instanz der <see cref="T:System.Collections.Hashtable" />-Klasse unter Verwendung der angegebenen Anfangskapazität und des Lastfaktors sowie des Hashcode-Standardanbieter und des angegebenen Comparers.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie die anfängliche Kapazität angeben, entfällt die Notwendigkeit, beim Hinzufügen von Elementen zum <xref:System.Collections.Hashtable> Objekt eine Reihe von Ändern der Größe auszuführen. Die Kapazität wird basierend auf dem Ladefaktor automatisch nach Bedarf angepasst.  
  
 Der Ladefaktor ist das maximale Verhältnis von Elementen zu Bucket. Ein geringerer Ladefaktor bedeutet einen schnelleren Such Faktor, um den Speicherverbrauch zu erhöhen. Der Lastfaktor 1,0 ist das beste Gleichgewicht zwischen Geschwindigkeit und Größe.  
  
 Wenn der tatsächliche Lastfaktor den angegebenen Lastfaktor erreicht, wird die Bucketanzahl automatisch auf die kleinste Primzahl vergrößert, die größer ist als die doppelte Anzahl an bucketwerten.  
  
 Der Hashcode-Anbieter gibt Hashcodes für Schlüssel in der <xref:System.Collections.Hashtable>aus. Der standardmäßige Hashcode-Anbieter ist die Schlüssel Implementierung <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>von.  
  
 Der Vergleich bestimmt, ob zwei Schlüssel gleich sind. Jeder Schlüssel in einem <xref:System.Collections.Hashtable> muss eindeutig sein. Der Standardcomparer ist die Schlüssel Implementierung von <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Dieser Konstruktor ist ein O (`n`)-Vorgang, `n` wobei der `capacity` -Parameter ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden Hash Tabellen mit unter <xref:System.Collections.Hashtable> schiedlichen Konstruktoren erstellt und die Unterschiede im Verhalten der Hash Tabellen veranschaulicht, auch wenn beide dieselben Elemente enthalten.  
  
 [!code-cpp[System.Collections.Hashtable_ctorIntFloat#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorIntFloat/CPP/hashtable_ctorintfloat.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctorIntFloat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorIntFloat/CS/hashtable_ctorintfloat.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctorIntFloat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorIntFloat/VB/hashtable_ctorintfloat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> ist kleiner als Null.  
  
- oder - 
 <paramref name="loadFactor" /> ist kleiner als 0,1.  
  
- oder - 
 <paramref name="loadFactor" /> ist größer als 1,0.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="capacity" /> verursacht einen Überlauf.</exception>
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Hashtable (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Hashtable(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new System.Collections.Hashtable : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; System.Collections.Hashtable" Usage="new System.Collections.Hashtable (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="info">Ein <see cref="T:System.Runtime.Serialization.SerializationInfo" />-Objekt mit den zum Serialisieren des <see cref="T:System.Collections.Hashtable" />-Objekts erforderlichen Informationen.</param>
        <param name="context">Ein <see cref="T:System.Runtime.Serialization.StreamingContext" />-Objekt mit der Quelle und dem Ziel des entsprechenden serialisierten Streams für <see cref="T:System.Collections.Hashtable" />.</param>
        <summary>Initialisiert eine neue leere Instanz der <see cref="T:System.Collections.Hashtable" />-Klasse, die serialisierbar ist, wobei die angegebenen <see cref="T:System.Runtime.Serialization.SerializationInfo" />-Objekte und die angegebenen <see cref="T:System.Runtime.Serialization.StreamingContext" />-Objekte verwendet werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Kapazität einer Hash Tabelle wird verwendet, um die optimale Anzahl von Hash Tabellen-Bucket basierend auf dem Lastfaktor zu berechnen. Die Kapazität wird bei Bedarf automatisch erweitert.  
  
 Der Ladefaktor ist das maximale Verhältnis von Elementen zu Bucket. Ein geringerer Ladefaktor bedeutet einen schnelleren Such Faktor, um den Speicherverbrauch zu erhöhen.  
  
 Wenn der tatsächliche Lastfaktor den angegebenen Lastfaktor erreicht, wird die Bucketanzahl automatisch auf die kleinste Primzahl vergrößert, die größer ist als die doppelte Anzahl an bucketwerten.  
  
 Der Hashcode-Anbieter gibt Hashcodes für Schlüssel im- <xref:System.Collections.Hashtable> Objekt an. Der standardmäßige Hashcode-Anbieter ist die Schlüssel Implementierung <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>von.  
  
 Der Vergleich bestimmt, ob zwei Schlüssel gleich sind. Jeder Schlüssel in einem <xref:System.Collections.Hashtable> muss eindeutig sein. Der Standardcomparer ist die Schlüssel Implementierung von <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Dieser Konstruktor ist ein O (`n`)-Vorgang, `n` bei <xref:System.Collections.Hashtable.Count%2A>dem gleich ist.  
  
 Da das Serialisieren und Deserialisieren eines Enumerators für <xref:System.Collections.Hashtable> einen bewirken kann, dass die Elemente neu angeordnet werden, kann die Enumeration nicht fortgesetzt werden, <xref:System.Collections.IEnumerator.Reset%2A> ohne die-Methode aufzurufende.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="info" /> ist <see langword="null" />.</exception>
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
        <altmember cref="M:System.Collections.Hashtable.OnDeserialization(System.Object)" />
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (System.Collections.IDictionary d, System.Collections.IHashCodeProvider hcp, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IDictionary d, class System.Collections.IHashCodeProvider hcp, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (d As IDictionary, hcp As IHashCodeProvider, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(System::Collections::IDictionary ^ d, System::Collections::IHashCodeProvider ^ hcp, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Hashtable : System.Collections.IDictionary * System.Collections.IHashCodeProvider * System.Collections.IComparer -&gt; System.Collections.Hashtable" Usage="new System.Collections.Hashtable (d, hcp, comparer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("Please use Hashtable(IDictionary, IEqualityComparer) instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="d" Type="System.Collections.IDictionary" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="hcp" Type="System.Collections.IHashCodeProvider" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="d">Das <see cref="T:System.Collections.IDictionary" />-Objekt, das in ein neues <see cref="T:System.Collections.Hashtable" />-Objekt kopiert werden soll.</param>
        <param name="hcp">Das <see cref="T:System.Collections.IHashCodeProvider" />-Objekt, das die Hashcodes für alle Schlüssel in der <see cref="T:System.Collections.Hashtable" /> bereitstellt.  
  
- oder - 
 <see langword="null" />, wenn der Hashcode-Standardanbieter verwendet werden soll. Dies ist die jeweilige <see cref="M:System.Object.GetHashCode" />-Implementierung eines Schlüssels.</param>
        <param name="comparer">Das <see cref="T:System.Collections.IComparer" />-Objekt, mit dem ermittelt wird, ob zwei Schlüssel gleich sind.  
  
- oder - 
 <see langword="null" />, wenn der Standardcomparer verwendet werden soll. Dies ist die jeweilige <see cref="M:System.Object.Equals(System.Object)" />-Implementierung eines Schlüssels.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Collections.Hashtable" />-Klasse durch Kopieren der Elemente aus dem angegebenen Wörterbuch in das neue <see cref="T:System.Collections.Hashtable" />-Objekt. Das neue <see cref="T:System.Collections.Hashtable" />-Objekt besitzt eine Anfangskapazität, die mit der Anzahl der kopierten Elemente identisch ist, und verwendet den Standardlastfaktor sowie den angegebenen Hashcodeanbieter und den angegebenen Comparer. Diese API ist veraltet. Eine Alternative finden Sie unter <see cref="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die anfängliche Kapazität wird auf die Anzahl der Elemente im Quell Wörterbuch festgelegt. Die Kapazität wird basierend auf dem Ladefaktor automatisch nach Bedarf angepasst.  
  
 Der Ladefaktor ist das maximale Verhältnis von Elementen zu Bucket. Ein geringerer Ladefaktor bedeutet einen schnelleren Such Faktor, um den Speicherverbrauch zu erhöhen.  
  
 Wenn der tatsächliche Lastfaktor den angegebenen Lastfaktor erreicht, wird die Bucketanzahl automatisch auf die kleinste Primzahl vergrößert, die größer ist als die doppelte Anzahl an bucketwerten.  
  
 Der Hashcode-Anbieter gibt Hashcodes für Schlüssel im- <xref:System.Collections.Hashtable> Objekt an. Der standardmäßige Hashcode-Anbieter ist die Schlüssel Implementierung <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>von.  
  
 Der Vergleich bestimmt, ob zwei Schlüssel gleich sind. Jeder Schlüssel in einem <xref:System.Collections.Hashtable> muss eindeutig sein. Der Standardcomparer ist die Schlüssel Implementierung von <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Der benutzerdefinierte Hashcode-Anbieter und der benutzerdefinierte Vergleich ermöglichen Szenarien wie Suchvorgänge mit Zeichen folgen ohne Beachtung der Groß-und Kleinschreibung.  
  
 Die Elemente der neuen <xref:System.Collections.Hashtable> werden in derselben Reihenfolge sortiert, in der der Enumerator das <xref:System.Collections.IDictionary> -Objekt durchläuft.  
  
 Dieser Konstruktor ist ein O (`n`)-Vorgang, `n` wobei die `d` Anzahl der Elemente im-Parameter ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden Hash Tabellen mit unter <xref:System.Collections.Hashtable> schiedlichen Konstruktoren erstellt und die Unterschiede im Verhalten der Hash Tabellen veranschaulicht, auch wenn beide dieselben Elemente enthalten.  
  
 [!code-cpp[System.Collections.Hashtable_ctorDictionary#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionary/CPP/hashtable_ctordictionary.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctorDictionary#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionary/CS/hashtable_ctordictionary.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctorDictionary#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionary/VB/hashtable_ctordictionary.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="d" /> ist <see langword="null" />.</exception>
        <altmember cref="T:System.Collections.IDictionary" />
        <altmember cref="T:System.Collections.IHashCodeProvider" />
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (System.Collections.IDictionary d, float loadFactor, System.Collections.IEqualityComparer equalityComparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IDictionary d, float32 loadFactor, class System.Collections.IEqualityComparer equalityComparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (d As IDictionary, loadFactor As Single, equalityComparer As IEqualityComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(System::Collections::IDictionary ^ d, float loadFactor, System::Collections::IEqualityComparer ^ equalityComparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Hashtable : System.Collections.IDictionary * single * System.Collections.IEqualityComparer -&gt; System.Collections.Hashtable" Usage="new System.Collections.Hashtable (d, loadFactor, equalityComparer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="d" Type="System.Collections.IDictionary" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="loadFactor" Type="System.Single" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="equalityComparer" Type="System.Collections.IEqualityComparer" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="d">Das <see cref="T:System.Collections.IDictionary" />-Objekt, das in ein neues <see cref="T:System.Collections.Hashtable" />-Objekt kopiert werden soll.</param>
        <param name="loadFactor">Eine Zahl im Bereich 0.1 bis 1.0, die mit dem Standardwert für die optimale Leistung multipliziert wird. Das Ergebnis ist das maximale Verhältnis von Elementen zu Buckets.</param>
        <param name="equalityComparer">Der <see cref="T:System.Collections.IEqualityComparer" />, der sowohl den Hashcodeanbieter als auch den Comparer zur Verwendung mit der <see cref="T:System.Collections.Hashtable" /> definiert.  
  
- oder - 
 <see langword="null" />, um den Hashcode-Standardanbieter und den Standardcomparer zu verwenden. Der Hashcode-Standardanbieter ist die Implementierung von <see cref="M:System.Object.GetHashCode" /> jedes Schlüssels, und der Standardcomparer ist die Implementierung von <see cref="M:System.Object.Equals(System.Object)" /> jedes Schlüssels.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Collections.Hashtable" />-Klasse durch Kopieren der Elemente aus dem angegebenen Wörterbuch in das neue <see cref="T:System.Collections.Hashtable" />-Objekt. Das neue <see cref="T:System.Collections.Hashtable" />-Objekt besitzt eine Anfangskapazität, die mit der Anzahl der kopierten Elemente identisch ist, und verwendet den angegebenen Lastfaktor und das angegebene <see cref="T:System.Collections.IEqualityComparer" />-Objekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die anfängliche Kapazität wird auf die Anzahl der Elemente im Quell Wörterbuch festgelegt. Die Kapazität wird basierend auf dem Ladefaktor automatisch nach Bedarf angepasst.  
  
 Der Ladefaktor ist das maximale Verhältnis von Elementen zu Bucket. Ein geringerer Ladefaktor bedeutet einen schnelleren Such Faktor, um den Speicherverbrauch zu erhöhen. Der Lastfaktor 1,0 ist das beste Gleichgewicht zwischen Geschwindigkeit und Größe.  
  
 Wenn der tatsächliche Lastfaktor den angegebenen Lastfaktor erreicht, wird die Bucketanzahl automatisch auf die kleinste Primzahl vergrößert, die größer ist als die doppelte Anzahl an bucketwerten.  
  
 Das <xref:System.Collections.IEqualityComparer> -Objekt enthält sowohl den Hash Code Anbieter als auch den Comparer. Wenn eine <xref:System.Collections.IEqualityComparer> <xref:System.Collections.Hashtable> <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> <xref:System.Object.Equals%2A?displayProperty=nameWithType> im Konstruktor verwendet wird, müssen die-Objekte, die als Schlüssel im-Objekt verwendet werden, die-Methode und die-Methode nicht überschreiben. <xref:System.Collections.Hashtable>  
  
 Der Hashcode-Anbieter gibt Hashcodes für Schlüssel in der <xref:System.Collections.Hashtable>aus. Der standardmäßige Hashcode-Anbieter ist die Schlüssel Implementierung <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>von.  
  
 Der Vergleich bestimmt, ob zwei Schlüssel gleich sind. Jeder Schlüssel in einem <xref:System.Collections.Hashtable> muss eindeutig sein. Der Standardcomparer ist die Schlüssel Implementierung von <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Ermöglicht <xref:System.Collections.IEqualityComparer> Szenarien wie Suchvorgänge mit Zeichen folgen ohne Beachtung der Groß-und Kleinschreibung.  
  
 Die Elemente der neuen <xref:System.Collections.Hashtable> werden in derselben Reihenfolge sortiert, in der der Enumerator das <xref:System.Collections.IDictionary> -Objekt durchläuft.  
  
 Dieser Konstruktor ist ein O (`n`)-Vorgang, `n` wobei die `d` Anzahl der Elemente im-Parameter ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden Hash Tabellen mit unter <xref:System.Collections.Hashtable> schiedlichen Konstruktoren erstellt und die Unterschiede im Verhalten der Hash Tabellen veranschaulicht, auch wenn beide dieselben Elemente enthalten.  
  
 [!code-cpp[System.Collections.Hashtable_ctorDictionaryFloat#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionaryFloat/CPP/hashtable_ctordictionaryfloat.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctorDictionaryFloat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionaryFloat/CS/hashtable_ctordictionaryfloat.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctorDictionaryFloat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionaryFloat/VB/hashtable_ctordictionaryfloat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="d" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="loadFactor" /> ist kleiner als 0,1.  
  
- oder - 
 <paramref name="loadFactor" /> ist größer als 1,0.</exception>
        <altmember cref="T:System.Collections.IEqualityComparer" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (int capacity, System.Collections.IHashCodeProvider hcp, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity, class System.Collections.IHashCodeProvider hcp, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer, hcp As IHashCodeProvider, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(int capacity, System::Collections::IHashCodeProvider ^ hcp, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Hashtable : int * System.Collections.IHashCodeProvider * System.Collections.IComparer -&gt; System.Collections.Hashtable" Usage="new System.Collections.Hashtable (capacity, hcp, comparer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("Please use Hashtable(int, IEqualityComparer) instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="hcp" Type="System.Collections.IHashCodeProvider" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="capacity">Die ungefähre Anzahl von Elementen, die die <see cref="T:System.Collections.Hashtable" /> anfänglich enthalten kann.</param>
        <param name="hcp">Das <see cref="T:System.Collections.IHashCodeProvider" />-Objekt, das die Hashcodes für alle Schlüssel in der <see cref="T:System.Collections.Hashtable" /> bereitstellt.  
  
- oder - 
 <see langword="null" />, wenn der Hashcode-Standardanbieter verwendet werden soll. Dies ist die jeweilige <see cref="M:System.Object.GetHashCode" />-Implementierung eines Schlüssels.</param>
        <param name="comparer">Das <see cref="T:System.Collections.IComparer" />-Objekt, mit dem ermittelt wird, ob zwei Schlüssel gleich sind.  
  
- oder - 
 <see langword="null" />, wenn der Standardcomparer verwendet werden soll. Dies ist die jeweilige <see cref="M:System.Object.Equals(System.Object)" />-Implementierung eines Schlüssels.</param>
        <summary>Initialisiert eine neue leere Instanz der <see cref="T:System.Collections.Hashtable" />-Klasse unter Verwendung der angegebenen Anfangskapazität, des angegebenen Hashcodeanbieters, des angegebenen Comparers und des Standardlastfaktors.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie die anfängliche Kapazität angeben, entfällt die Notwendigkeit, beim Hinzufügen von Elementen zum <xref:System.Collections.Hashtable> Objekt eine Reihe von Ändern der Größe auszuführen. Die Kapazität wird basierend auf dem Ladefaktor automatisch nach Bedarf angepasst.  
  
 Der Ladefaktor ist das maximale Verhältnis von Elementen zu Bucket. Ein geringerer Ladefaktor bedeutet einen schnelleren Such Faktor, um den Speicherverbrauch zu erhöhen.  
  
 Wenn der tatsächliche Lastfaktor den angegebenen Lastfaktor erreicht, wird die Bucketanzahl automatisch auf die kleinste Primzahl vergrößert, die größer ist als die doppelte Anzahl an bucketwerten.  
  
 Der Hashcode-Anbieter gibt Hashcodes für Schlüssel in der <xref:System.Collections.Hashtable>aus. Der standardmäßige Hashcode-Anbieter ist die Schlüssel Implementierung <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>von.  
  
 Der Vergleich bestimmt, ob zwei Schlüssel gleich sind. Jeder Schlüssel in einem <xref:System.Collections.Hashtable> muss eindeutig sein. Der Standardcomparer ist die Schlüssel Implementierung von <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Der benutzerdefinierte Hashcode-Anbieter und der benutzerdefinierte Vergleich ermöglichen Szenarien wie Suchvorgänge mit Zeichen folgen ohne Beachtung der Groß-und Kleinschreibung.  
  
 Dieser Konstruktor ist ein O (`n`)-Vorgang, `n` wobei der `capacity` -Parameter ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden Hash Tabellen mit unter <xref:System.Collections.Hashtable> schiedlichen Konstruktoren erstellt und die Unterschiede im Verhalten der Hash Tabellen veranschaulicht, auch wenn beide dieselben Elemente enthalten.  
  
 [!code-cpp[System.Collections.Hashtable_ctorInt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorInt/CPP/hashtable_ctorint.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctorInt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorInt/CS/hashtable_ctorint.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctorInt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorInt/VB/hashtable_ctorint.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> ist kleiner als Null.</exception>
        <altmember cref="T:System.Collections.IHashCodeProvider" />
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (int capacity, float loadFactor, System.Collections.IEqualityComparer equalityComparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity, float32 loadFactor, class System.Collections.IEqualityComparer equalityComparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer, loadFactor As Single, equalityComparer As IEqualityComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(int capacity, float loadFactor, System::Collections::IEqualityComparer ^ equalityComparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Hashtable : int * single * System.Collections.IEqualityComparer -&gt; System.Collections.Hashtable" Usage="new System.Collections.Hashtable (capacity, loadFactor, equalityComparer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="loadFactor" Type="System.Single" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="equalityComparer" Type="System.Collections.IEqualityComparer" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="capacity">Die ungefähre Anzahl von Elementen, die die <see cref="T:System.Collections.Hashtable" /> anfänglich enthalten kann.</param>
        <param name="loadFactor">Eine Zahl im Bereich 0,1 bis 1,0, die mit dem Standardwert für die optimale Leistung multipliziert wird. Das Ergebnis ist das maximale Verhältnis von Elementen zu Buckets.</param>
        <param name="equalityComparer">Der <see cref="T:System.Collections.IEqualityComparer" />, der sowohl den Hashcodeanbieter als auch den Comparer zur Verwendung mit der <see cref="T:System.Collections.Hashtable" /> definiert.  
  
- oder - 
 <see langword="null" />, um den Hashcode-Standardanbieter und den Standardcomparer zu verwenden. Der Hashcode-Standardanbieter ist die Implementierung von <see cref="M:System.Object.GetHashCode" /> jedes Schlüssels, und der Standardcomparer ist die Implementierung von <see cref="M:System.Object.Equals(System.Object)" /> jedes Schlüssels.</param>
        <summary>Initialisiert eine neue leere Instanz der <see cref="T:System.Collections.Hashtable" />-Klasse unter Verwendung der angegebenen Anfangskapazität, des angegebenen Lastfaktors und des angegebenen <see cref="T:System.Collections.IEqualityComparer" />-Objekts.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie die anfängliche Kapazität angeben, entfällt die Notwendigkeit, beim Hinzufügen von Elementen zum <xref:System.Collections.Hashtable> Objekt eine Reihe von Ändern der Größe auszuführen. Die Kapazität wird basierend auf dem Ladefaktor automatisch nach Bedarf angepasst.  
  
 Der Ladefaktor ist das maximale Verhältnis von Elementen zu Bucket. Ein geringerer Ladefaktor bedeutet einen schnelleren Such Faktor, um den Speicherverbrauch zu erhöhen. Der Lastfaktor 1,0 ist das beste Gleichgewicht zwischen Geschwindigkeit und Größe.  
  
 Wenn der tatsächliche Lastfaktor den angegebenen Lastfaktor erreicht, wird die Bucketanzahl automatisch auf die kleinste Primzahl vergrößert, die größer ist als die doppelte Anzahl an bucketwerten.  
  
 Das <xref:System.Collections.IEqualityComparer> -Objekt enthält sowohl den Hash Code Anbieter als auch den Comparer. Wenn eine <xref:System.Collections.IEqualityComparer> <xref:System.Collections.Hashtable> <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> <xref:System.Object.Equals%2A?displayProperty=nameWithType> im Konstruktor verwendet wird, müssen die-Objekte, die als Schlüssel in verwendet werden, die-Methode und die-Methode nicht überschreiben. <xref:System.Collections.Hashtable>  
  
 Der Hashcode-Anbieter gibt Hashcodes für Schlüssel in der <xref:System.Collections.Hashtable>aus. Der standardmäßige Hashcode-Anbieter ist die Schlüssel Implementierung <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>von.  
  
 Der Vergleich bestimmt, ob zwei Schlüssel gleich sind. Jeder Schlüssel in einem <xref:System.Collections.Hashtable> muss eindeutig sein. Der Standardcomparer ist die Schlüssel Implementierung von <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Ermöglicht <xref:System.Collections.IEqualityComparer> Szenarien wie Suchvorgänge mit Zeichen folgen ohne Beachtung der Groß-und Kleinschreibung.  
  
 Dieser Konstruktor ist ein O (`n`)-Vorgang, `n` wobei der `capacity` -Parameter ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden Hash Tabellen mit unter <xref:System.Collections.Hashtable> schiedlichen Konstruktoren erstellt und die Unterschiede im Verhalten der Hash Tabellen veranschaulicht, auch wenn beide dieselben Elemente enthalten.  
  
 [!code-cpp[System.Collections.Hashtable_ctorIntFloat#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorIntFloat/CPP/hashtable_ctorintfloat.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctorIntFloat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorIntFloat/CS/hashtable_ctorintfloat.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctorIntFloat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorIntFloat/VB/hashtable_ctorintfloat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> ist kleiner als Null.  
  
- oder - 
 <paramref name="loadFactor" /> ist kleiner als 0,1.  
  
- oder - 
 <paramref name="loadFactor" /> ist größer als 1,0.</exception>
        <altmember cref="T:System.Collections.IEqualityComparer" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (System.Collections.IDictionary d, float loadFactor, System.Collections.IHashCodeProvider hcp, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IDictionary d, float32 loadFactor, class System.Collections.IHashCodeProvider hcp, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (d As IDictionary, loadFactor As Single, hcp As IHashCodeProvider, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(System::Collections::IDictionary ^ d, float loadFactor, System::Collections::IHashCodeProvider ^ hcp, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Hashtable : System.Collections.IDictionary * single * System.Collections.IHashCodeProvider * System.Collections.IComparer -&gt; System.Collections.Hashtable" Usage="new System.Collections.Hashtable (d, loadFactor, hcp, comparer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("Please use Hashtable(IDictionary, float, IEqualityComparer) instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="d" Type="System.Collections.IDictionary" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="loadFactor" Type="System.Single" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="hcp" Type="System.Collections.IHashCodeProvider" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="d">Das <see cref="T:System.Collections.IDictionary" />-Objekt, das in ein neues <see cref="T:System.Collections.Hashtable" />-Objekt kopiert werden soll.</param>
        <param name="loadFactor">Eine Zahl im Bereich 0.1 bis 1.0, die mit dem Standardwert für die optimale Leistung multipliziert wird. Das Ergebnis ist das maximale Verhältnis von Elementen zu Buckets.</param>
        <param name="hcp">Das <see cref="T:System.Collections.IHashCodeProvider" />-Objekt, das die Hashcodes für alle Schlüssel in der <see cref="T:System.Collections.Hashtable" /> bereitstellt.  
  
- oder - 
 <see langword="null" />, wenn der Hashcode-Standardanbieter verwendet werden soll. Dies ist die jeweilige <see cref="M:System.Object.GetHashCode" />-Implementierung eines Schlüssels.</param>
        <param name="comparer">Das <see cref="T:System.Collections.IComparer" />-Objekt, mit dem ermittelt wird, ob zwei Schlüssel gleich sind.  
  
- oder - 
 <see langword="null" />, wenn der Standardcomparer verwendet werden soll. Dies ist die jeweilige <see cref="M:System.Object.Equals(System.Object)" />-Implementierung eines Schlüssels.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Collections.Hashtable" />-Klasse durch Kopieren der Elemente aus dem angegebenen Wörterbuch in das neue <see cref="T:System.Collections.Hashtable" />-Objekt. Das neue <see cref="T:System.Collections.Hashtable" />-Objekt besitzt eine Anfangskapazität, die mit der Anzahl der kopierten Elemente identisch ist, und verwendet den angegebenen Lastfaktor, den angegebenen Hashcodeanbieter und den angegebenen Comparer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die anfängliche Kapazität wird auf die Anzahl der Elemente im Quell Wörterbuch festgelegt. Die Kapazität wird basierend auf dem Ladefaktor automatisch nach Bedarf angepasst.  
  
 Der Ladefaktor ist das maximale Verhältnis von Elementen zu Bucket. Ein geringerer Ladefaktor bedeutet einen schnelleren Such Faktor, um den Speicherverbrauch zu erhöhen. Der Lastfaktor 1,0 ist das beste Gleichgewicht zwischen Geschwindigkeit und Größe.  
  
 Wenn der tatsächliche Lastfaktor den angegebenen Lastfaktor erreicht, wird die Bucketanzahl automatisch auf die kleinste Primzahl vergrößert, die größer ist als die doppelte Anzahl an bucketwerten.  
  
 Der Hashcode-Anbieter gibt Hashcodes für Schlüssel im- <xref:System.Collections.Hashtable> Objekt an. Der standardmäßige Hashcode-Anbieter ist die Schlüssel Implementierung <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>von.  
  
 Der Vergleich bestimmt, ob zwei Schlüssel gleich sind. Jeder Schlüssel in einem <xref:System.Collections.Hashtable> muss eindeutig sein. Der Standardcomparer ist die Schlüssel Implementierung von <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Der benutzerdefinierte Hashcode-Anbieter und der benutzerdefinierte Vergleich ermöglichen Szenarien wie Suchvorgänge mit Zeichen folgen ohne Beachtung der Groß-und Kleinschreibung.  
  
 Die Elemente der neuen <xref:System.Collections.Hashtable> werden in derselben Reihenfolge sortiert, in der der Enumerator das <xref:System.Collections.IDictionary> -Objekt durchläuft.  
  
 Dieser Konstruktor ist ein O (`n`)-Vorgang, `n` wobei die `d` Anzahl der Elemente im-Parameter ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden Hash Tabellen mit unter <xref:System.Collections.Hashtable> schiedlichen Konstruktoren erstellt und die Unterschiede im Verhalten der Hash Tabellen veranschaulicht, auch wenn beide dieselben Elemente enthalten.  
  
 [!code-cpp[System.Collections.Hashtable_ctorDictionaryFloat#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionaryFloat/CPP/hashtable_ctordictionaryfloat.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctorDictionaryFloat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionaryFloat/CS/hashtable_ctordictionaryfloat.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctorDictionaryFloat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorDictionaryFloat/VB/hashtable_ctordictionaryfloat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="d" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="loadFactor" /> ist kleiner als 0,1.  
  
- oder - 
 <paramref name="loadFactor" /> ist größer als 1,0.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Hashtable (int capacity, float loadFactor, System.Collections.IHashCodeProvider hcp, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity, float32 loadFactor, class System.Collections.IHashCodeProvider hcp, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer, loadFactor As Single, hcp As IHashCodeProvider, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Hashtable(int capacity, float loadFactor, System::Collections::IHashCodeProvider ^ hcp, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Hashtable : int * single * System.Collections.IHashCodeProvider * System.Collections.IComparer -&gt; System.Collections.Hashtable" Usage="new System.Collections.Hashtable (capacity, loadFactor, hcp, comparer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("Please use Hashtable(int, float, IEqualityComparer) instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="loadFactor" Type="System.Single" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="hcp" Type="System.Collections.IHashCodeProvider" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="capacity">Die ungefähre Anzahl von Elementen, die die <see cref="T:System.Collections.Hashtable" /> anfänglich enthalten kann.</param>
        <param name="loadFactor">Eine Zahl im Bereich 0,1 bis 1,0, die mit dem Standardwert für die optimale Leistung multipliziert wird. Das Ergebnis ist das maximale Verhältnis von Elementen zu Buckets.</param>
        <param name="hcp">Das <see cref="T:System.Collections.IHashCodeProvider" />-Objekt, das die Hashcodes für alle Schlüssel in der <see cref="T:System.Collections.Hashtable" /> bereitstellt.  
  
- oder - 
 <see langword="null" />, wenn der Hashcode-Standardanbieter verwendet werden soll. Dies ist die jeweilige <see cref="M:System.Object.GetHashCode" />-Implementierung eines Schlüssels.</param>
        <param name="comparer">Das <see cref="T:System.Collections.IComparer" />-Objekt, mit dem ermittelt wird, ob zwei Schlüssel gleich sind.  
  
- oder - 
 <see langword="null" />, wenn der Standardcomparer verwendet werden soll. Dies ist die jeweilige <see cref="M:System.Object.Equals(System.Object)" />-Implementierung eines Schlüssels.</param>
        <summary>Initialisiert eine neue leere Instanz der <see cref="T:System.Collections.Hashtable" />-Klasse unter Verwendung der angegebenen Anfangskapazität, des angegebenen Lastfaktors, des angegebenen Hashcode-Anbieters und des angegebenen Comparers.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie die anfängliche Kapazität angeben, entfällt die Notwendigkeit, beim Hinzufügen von Elementen zum <xref:System.Collections.Hashtable> Objekt eine Reihe von Ändern der Größe auszuführen. Die Kapazität wird basierend auf dem Ladefaktor automatisch nach Bedarf angepasst.  
  
 Der Ladefaktor ist das maximale Verhältnis von Elementen zu Bucket. Ein geringerer Ladefaktor bedeutet einen schnelleren Such Faktor, um den Speicherverbrauch zu erhöhen. Der Lastfaktor 1,0 ist das beste Gleichgewicht zwischen Geschwindigkeit und Größe.  
  
 Wenn der tatsächliche Lastfaktor den angegebenen Lastfaktor erreicht, wird die Bucketanzahl automatisch auf die kleinste Primzahl vergrößert, die größer ist als die doppelte Anzahl an bucketwerten.  
  
 Der Hashcode-Anbieter gibt Hashcodes für Schlüssel in der <xref:System.Collections.Hashtable>aus. Der standardmäßige Hashcode-Anbieter ist die Schlüssel Implementierung <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>von.  
  
 Der Vergleich bestimmt, ob zwei Schlüssel gleich sind. Jeder Schlüssel in einem <xref:System.Collections.Hashtable> muss eindeutig sein. Der Standardcomparer ist die Schlüssel Implementierung von <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Der benutzerdefinierte Hashcode-Anbieter und der benutzerdefinierte Vergleich ermöglichen Szenarien wie Suchvorgänge mit Zeichen folgen ohne Beachtung der Groß-und Kleinschreibung.  
  
 Dieser Konstruktor ist ein O (`n`)-Vorgang, `n` wobei der `capacity` -Parameter ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden Hash Tabellen mit unter <xref:System.Collections.Hashtable> schiedlichen Konstruktoren erstellt und die Unterschiede im Verhalten der Hash Tabellen veranschaulicht, auch wenn beide dieselben Elemente enthalten.  
  
 [!code-cpp[System.Collections.Hashtable_ctorIntFloat#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorIntFloat/CPP/hashtable_ctorintfloat.cpp#1)]
 [!code-csharp[System.Collections.Hashtable_ctorIntFloat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorIntFloat/CS/hashtable_ctorintfloat.cs#1)]
 [!code-vb[System.Collections.Hashtable_ctorIntFloat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Hashtable_ctorIntFloat/VB/hashtable_ctorintfloat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> ist kleiner als Null.  
  
- oder - 
 <paramref name="loadFactor" /> ist kleiner als 0,1.  
  
- oder - 
 <paramref name="loadFactor" /> ist größer als 1,0.</exception>
        <altmember cref="T:System.Collections.IHashCodeProvider" />
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public virtual void Add (object key, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(object key, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.Add(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Add (key As Object, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Add(System::Object ^ key, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member Add : obj * obj -&gt; unit&#xA;override this.Add : obj * obj -&gt; unit" Usage="hashtable.Add (key, value)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Add(System.Object,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Der Schlüssel des hinzuzufügenden Elements.</param>
        <param name="value">Der Wert des hinzuzufügenden Elements. Der Wert kann <see langword="null" /> sein.</param>
        <summary>Fügt dem <see cref="T:System.Collections.Hashtable" /> ein Element mit dem angegebenen Schlüssel und Wert hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Schlüssel kann nicht `null`sein, aber ein Wert kann sein.  
  
 Ein Objekt, das keine Korrelation zwischen seinem Zustand und seinem Hashcodewert aufweist, sollte in der Regel nicht als Schlüssel verwendet werden. Zeichen folgen Objekte sind z. b. besser als StringBuilder-Objekte, die als Schlüssel verwendet werden können.  
  
 Sie können auch die <xref:System.Collections.Hashtable.Item%2A> zum Hinzufügen neuer Elemente durch Festlegen des Werts eines Schlüssels, die Eigenschaft ist nicht vorhanden, der <xref:System.Collections.Hashtable>, z. B. `myCollection["myNonexistentKey"] = myValue` Wenn jedoch der angegebene Schlüssel bereits in <xref:System.Collections.Hashtable>vorhanden ist, wird durch das Festlegen der <xref:System.Collections.Hashtable.Item%2A> -Eigenschaft der alte Wert überschrieben. Im Gegensatz dazu ändert <xref:System.Collections.Hashtable.Add%2A> die-Methode keine vorhandenen Elemente.  
  
 Wenn <xref:System.Collections.Hashtable.Count%2A> kleiner als die Kapazität <xref:System.Collections.Hashtable>des ist, ist diese Methode ein O (1)-Vorgang. Wenn die Kapazität für das neue Element erweitert werden muss, wird diese Methode zu einem O (`n`)-Vorgang, <xref:System.Collections.Hashtable.Count%2A>wobei `n` den Wert hat.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie der <xref:System.Collections.Hashtable>Elemente hinzugefügt werden.  
  
 [!code-cpp[Classic Hashtable.Add Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable.Add Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Hashtable.Add Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable.Add Example/CS/source.cs#1)]
 [!code-vb[Classic Hashtable.Add Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable.Add Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">In <see cref="T:System.Collections.Hashtable" /> ist bereits ein Element mit demselben Schlüssel enthalten.</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.Hashtable" /> ist schreibgeschützt.  
  
- oder - 
<see cref="T:System.Collections.Hashtable" /> hat eine feste Größe.</exception>
        <altmember cref="M:System.Collections.Hashtable.Remove(System.Object)" />
        <altmember cref="P:System.Collections.Hashtable.Item(System.Object)" />
        <altmember cref="M:System.Collections.IDictionary.Add(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public virtual void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberSignature Language="F#" Value="abstract member Clear : unit -&gt; unit&#xA;override this.Clear : unit -&gt; unit" Usage="hashtable.Clear " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Entfernt alle Elemente aus der <see cref="T:System.Collections.Hashtable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Hashtable.Count%2A>wird auf 0 (null) festgelegt, und Verweise auf andere Objekte von Elementen der Auflistung werden ebenfalls freigegeben. Die Kapazität bleibt unverändert.  
  
 Diese Methode ist ein O (`n`)-Vorgang, `n` bei <xref:System.Collections.Hashtable.Count%2A>dem gleich ist.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie Sie die Werte von <xref:System.Collections.Hashtable>löschen.  
  
 [!code-cpp[Classic Hashtable.Clear Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable.Clear Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Hashtable.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic Hashtable.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.Hashtable" /> ist schreibgeschützt.</exception>
        <altmember cref="M:System.Collections.IDictionary.Clear" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="hashtable.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt eine flache Kopie von <see cref="T:System.Collections.Hashtable" />.</summary>
        <returns>Eine flache Kopie von <see cref="T:System.Collections.Hashtable" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei einer flachen Kopie einer Auflistung werden nur die Elemente der Auflistung kopiert, unabhängig davon, ob es sich um Verweis Typen oder Werttypen handelt, die Objekte, auf die die Verweise verweisen, werden jedoch nicht kopiert. Die Verweise in der neuen Auflistung zeigen auf dieselben Objekte, auf die die Verweise in der ursprünglichen Auflistung verweisen.  
  
 Im Gegensatz dazu kopiert eine tiefe Kopie einer Auflistung die Elemente und alle Elemente, die direkt oder indirekt von den Elementen referenziert werden.  
  
 Der <xref:System.Collections.Hashtable> Klon verfügt über dieselbe Anzahl, dieselbe Kapazität, dieselbe <xref:System.Collections.IHashCodeProvider> Implementierung und dieselbe <xref:System.Collections.IComparer> Implementierung wie die ursprüngliche <xref:System.Collections.Hashtable>.  
  
 Diese Methode ist ein O (`n`)-Vorgang, `n` bei <xref:System.Collections.Hashtable.Count%2A>dem gleich ist.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Hashtable.CopyTo(System.Array,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="comparer">
      <MemberSignature Language="C#" Value="protected System.Collections.IComparer comparer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IComparer comparer" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Hashtable.comparer" />
      <MemberSignature Language="VB.NET" Value="Protected Property comparer As IComparer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::IComparer ^ comparer { System::Collections::IComparer ^ get(); void set(System::Collections::IComparer ^ value); };" />
      <MemberSignature Language="F#" Value="member this.comparer : System.Collections.IComparer with get, set" Usage="System.Collections.Hashtable.comparer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("Please use KeyComparer properties.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IComparer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den für die <see cref="T:System.Collections.IComparer" /> zu verwendenden <see cref="T:System.Collections.Hashtable" /> ab oder legt diesen fest.</summary>
        <value>Der <see cref="T:System.Collections.IComparer" />, der für die <see cref="T:System.Collections.Hashtable" /> verwendet werden soll.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die Eigenschaft wird auf einen Wert festgelegt, aber die Hashtabelle wurde mit einem <see cref="T:System.Collections.IEqualityComparer" /> erstellt.</exception>
        <altmember cref="T:System.Collections.IComparer" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public virtual bool Contains (object key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Contains (key As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(System::Object ^ key);" />
      <MemberSignature Language="F#" Value="abstract member Contains : obj -&gt; bool&#xA;override this.Contains : obj -&gt; bool" Usage="hashtable.Contains key" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Der im <see cref="T:System.Collections.Hashtable" /> zu suchende Schlüssel.</param>
        <summary>Stellt fest, ob der <see cref="T:System.Collections.Hashtable" /> einen bestimmten Schlüssel enthält.</summary>
        <returns><see langword="true" />, wenn das <see cref="T:System.Collections.Hashtable" /> ein Element mit dem angegebenen Schlüssel enthält, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Hashtable.Contains%2A> implementiert <xref:System.Collections.IDictionary.Contains%2A?displayProperty=nameWithType>. Sie verhält sich genau <xref:System.Collections.Hashtable.ContainsKey%2A>so.  
  
 Diese Methode ist ein O (1)-Vorgang.  
  
 Beginnend mit dem .NET Framework 2,0 verwendet diese Methode die- <xref:System.Object.Equals%2A> und <xref:System.IComparable.CompareTo%2A> -Methoden `item` der-Auflistung, um zu bestimmen, ob ein Element vorhanden ist. In früheren Versionen der .NET Framework wurde diese Bestimmung durch die Verwendung der <xref:System.Object.Equals%2A> -Methode und der-Methode des `item` -Parameters für die- <xref:System.IComparable.CompareTo%2A> Objekte in der-Auflistung vorgenommen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie Sie bestimmen <xref:System.Collections.Hashtable> können, ob ein bestimmtes Element enthält.  
  
 [!code-cpp[Classic Hashtable.Contains Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable.Contains Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Hashtable.Contains Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable.Contains Example/CS/source.cs#1)]
 [!code-vb[Classic Hashtable.Contains Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable.Contains Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Hashtable.ContainsKey(System.Object)" />
        <altmember cref="T:System.Collections.IDictionary" />
      </Docs>
    </Member>
    <Member MemberName="ContainsKey">
      <MemberSignature Language="C#" Value="public virtual bool ContainsKey (object key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ContainsKey(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.ContainsKey(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ContainsKey (key As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ContainsKey(System::Object ^ key);" />
      <MemberSignature Language="F#" Value="abstract member ContainsKey : obj -&gt; bool&#xA;override this.ContainsKey : obj -&gt; bool" Usage="hashtable.ContainsKey key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Der im <see cref="T:System.Collections.Hashtable" /> zu suchende Schlüssel.</param>
        <summary>Stellt fest, ob der <see cref="T:System.Collections.Hashtable" /> einen bestimmten Schlüssel enthält.</summary>
        <returns><see langword="true" />, wenn das <see cref="T:System.Collections.Hashtable" /> ein Element mit dem angegebenen Schlüssel enthält, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verhält sich genau <xref:System.Collections.Hashtable.Contains%2A>so.  
  
 Diese Methode ist ein O (1)-Vorgang.  
  
 Beginnend mit dem .NET Framework 2,0 verwendet diese Methode die- <xref:System.Object.Equals%2A> und <xref:System.IComparable.CompareTo%2A> -Methoden `item` der-Auflistung, um zu bestimmen, ob ein Element vorhanden ist. In früheren Versionen der .NET Framework wurde diese Bestimmung durch die Verwendung der <xref:System.Object.Equals%2A> -Methode und der-Methode des `item` -Parameters für die- <xref:System.IComparable.CompareTo%2A> Objekte in der-Auflistung vorgenommen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie Sie bestimmen <xref:System.Collections.Hashtable> können, ob ein bestimmtes Element enthält.  
  
 [!code-cpp[Classic Hashtable.Contains Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable.Contains Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Hashtable.Contains Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable.Contains Example/CS/source.cs#1)]
 [!code-vb[Classic Hashtable.Contains Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable.Contains Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Hashtable.Contains(System.Object)" />
        <altmember cref="M:System.Collections.Hashtable.ContainsValue(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ContainsValue">
      <MemberSignature Language="C#" Value="public virtual bool ContainsValue (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ContainsValue(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.ContainsValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ContainsValue (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ContainsValue(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member ContainsValue : obj -&gt; bool&#xA;override this.ContainsValue : obj -&gt; bool" Usage="hashtable.ContainsValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Der im <see cref="T:System.Collections.Hashtable" /> zu suchende Wert. Der Wert kann <see langword="null" /> sein.</param>
        <summary>Ermittelt, ob die <see cref="T:System.Collections.Hashtable" /> einen bestimmten Wert enthält.</summary>
        <returns><see langword="true" />, wenn die <see cref="T:System.Collections.Hashtable" /> ein Element mit dem angegebenen <paramref name="value" /> enthält, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Werte der Elemente des <xref:System.Collections.Hashtable> werden mithilfe der <xref:System.Object.Equals%2A?displayProperty=nameWithType> -Methode mit dem angegebenen Wert verglichen.  
  
 Diese Methode führt eine lineare Suche aus. Daher ist diese Methode ein O (`n`)-Vorgang, bei dem <xref:System.Collections.Hashtable.Count%2A> `n` gleich ist.  
  
 Beginnend mit dem .NET Framework 2,0 verwendet diese Methode die- <xref:System.Object.Equals%2A> und <xref:System.IComparable.CompareTo%2A> -Methoden `item` der-Auflistung, um zu bestimmen, ob ein Element vorhanden ist. In früheren Versionen der .NET Framework wurde diese Bestimmung durch die Verwendung der <xref:System.Object.Equals%2A> -Methode und der-Methode des `item` -Parameters für die- <xref:System.IComparable.CompareTo%2A> Objekte in der-Auflistung vorgenommen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie Sie bestimmen <xref:System.Collections.Hashtable> können, ob ein bestimmtes Element enthält.  
  
 [!code-cpp[Classic Hashtable.Contains Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable.Contains Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Hashtable.Contains Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable.Contains Example/CS/source.cs#1)]
 [!code-vb[Classic Hashtable.Contains Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable.Contains Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Hashtable.ContainsKey(System.Object)" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public virtual void CopyTo (Array array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.Array array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(Array ^ array, int arrayIndex);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : Array * int -&gt; unit&#xA;override this.CopyTo : Array * int -&gt; unit" Usage="hashtable.CopyTo (array, arrayIndex)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Das eindimensionale <see cref="T:System.Array" />, das das Ziel der aus <see cref="T:System.Collections.DictionaryEntry" /> kopierten <see cref="T:System.Collections.Hashtable" />-Objekte ist. Für das <see cref="T:System.Array" /> muss eine nullbasierte Indizierung verwendet werden.</param>
        <param name="arrayIndex">Der nullbasierte Index im <paramref name="array" />, bei dem der Kopiervorgang beginnt.</param>
        <summary>Kopiert die <see cref="T:System.Collections.Hashtable" />-Elemente an den angegebenen Index in einer eindimensionalen <see cref="T:System.Array" />-Instanz.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Elemente werden <xref:System.Array> in derselben Reihenfolge in den kopiert, in der der Enumerator <xref:System.Collections.Hashtable>durchläuft.  
  
 Wenn Sie nur die Schlüssel in <xref:System.Collections.Hashtable>kopieren möchten, verwenden `Hashtable.Keys.CopyTo`Sie.  
  
 Wenn Sie nur die Werte in <xref:System.Collections.Hashtable>kopieren möchten, verwenden `Hashtable.Values.CopyTo`Sie.  
  
 Diese Methode ist ein O (`n`)-Vorgang, `n` bei <xref:System.Collections.Hashtable.Count%2A>dem gleich ist.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie Sie die Liste der Schlüssel oder die Liste der Werte in <xref:System.Collections.Hashtable> einem in ein eindimensionales <xref:System.Array>kopieren.  
  
 [!code-cpp[Classic Hashtable.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Hashtable.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic Hashtable.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable.CopyTo Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="arrayIndex" /> ist kleiner als Null.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="array" /> ist mehrdimensional.  
  
- oder - 
Die Anzahl der Elemente in der Quell-<see cref="T:System.Collections.Hashtable" /> ist größer als der verfügbare Platz vom <paramref name="arrayIndex" /> bis zum Ende des Ziel-<paramref name="array" />s.</exception>
        <exception cref="T:System.InvalidCastException">Der Typ der Quell-<see cref="T:System.Collections.Hashtable" /> kann nicht automatisch in den Typ des Ziel-<paramref name="array" /> umgewandelt werden.</exception>
        <altmember cref="T:System.Array" />
        <altmember cref="T:System.Collections.DictionaryEntry" />
        <altmember cref="M:System.Collections.Hashtable.GetEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public virtual int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Hashtable.Count" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Collections.Hashtable.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anzahl der Schlüssel-Wert-Paare im <see cref="T:System.Collections.Hashtable" /> ab.</summary>
        <value>Die Anzahl der Schlüssel-Wert-Paare im <see cref="T:System.Collections.Hashtable" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EqualityComparer">
      <MemberSignature Language="C#" Value="protected System.Collections.IEqualityComparer EqualityComparer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEqualityComparer EqualityComparer" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Hashtable.EqualityComparer" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property EqualityComparer As IEqualityComparer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::IEqualityComparer ^ EqualityComparer { System::Collections::IEqualityComparer ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EqualityComparer : System.Collections.IEqualityComparer" Usage="System.Collections.Hashtable.EqualityComparer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEqualityComparer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den für die <see cref="T:System.Collections.IEqualityComparer" /> zu verwendenden <see cref="T:System.Collections.Hashtable" /> ab.</summary>
        <value>Der <see cref="T:System.Collections.IEqualityComparer" />, der für die <see cref="T:System.Collections.Hashtable" /> verwendet werden soll.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.IEqualityComparer> Enthält sowohl den Vergleich als auch den Hashcode-Anbieter. Wenn eine <xref:System.Collections.IEqualityComparer> <xref:System.Collections.Hashtable> <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> <xref:System.Object.Equals%2A?displayProperty=nameWithType> im Konstruktor verwendet wird, müssen die-Objekte, die als Schlüssel in verwendet werden, die-Methode und die-Methode nicht überschreiben. <xref:System.Collections.Hashtable>  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die Eigenschaft wird auf einen Wert festgelegt, aber die Hashtabelle wurde mit einem <see cref="T:System.Collections.IHashCodeProvider" /> und einem <see cref="T:System.Collections.IComparer" /> erstellt.</exception>
        <altmember cref="T:System.Collections.Comparer" />
        <altmember cref="T:System.Collections.IEqualityComparer" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IDictionaryEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IDictionaryEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumerator () As IDictionaryEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IDictionaryEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IDictionaryEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IDictionaryEnumerator" Usage="hashtable.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionaryEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen <see cref="T:System.Collections.IDictionaryEnumerator" /> zurück, der das <see cref="T:System.Collections.Hashtable" /> durchläuft.</summary>
        <returns>Ein <see cref="T:System.Collections.IDictionaryEnumerator" /> für das <see cref="T:System.Collections.Hashtable" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [Visual Basic, C#]  
  
 Die `foreach`-Anweisung der Programmiersprache C# (`for each` in Visual Basic) verbirgt die Komplexität der Enumeratoren.  Daher empfiehlt es sich, `foreach` zu verwenden und den Enumerator nicht direkt zu ändern.  
  
 Mit Enumeratoren können die Daten in der Auflistung zwar gelesen, jedoch nicht zum Ändern der zugrunde liegenden Auflistung verwendet werden.  
  
 Zu Beginn wird der Enumerator vor das erste Element in der Auflistung positioniert. <xref:System.Collections.IEnumerator.Reset%2A> setzt den Enumerator ebenfalls auf diese Position zurück.  An dieser Position ist <xref:System.Collections.IEnumerator.Current%2A> nicht definiert. Daher muss der Enumerator durch einen Aufruf von <xref:System.Collections.IEnumerator.MoveNext%2A> auf das erste Element der Auflistung gesetzt werden, bevor der Wert von <xref:System.Collections.IEnumerator.Current%2A> gelesen werden kann.  
  
 <xref:System.Collections.IEnumerator.Current%2A> gibt solange dasselbe Objekt zurück, bis <xref:System.Collections.IEnumerator.MoveNext%2A> oder <xref:System.Collections.IEnumerator.Reset%2A> aufgerufen wird. <xref:System.Collections.IEnumerator.MoveNext%2A> legt <xref:System.Collections.IEnumerator.Current%2A> auf das nächste Element fest.  
  
 Wenn <xref:System.Collections.IEnumerator.MoveNext%2A> das Ende der Auflistung übergibt, wird der Enumerator hinter dem letzten Element in der Auflistung platziert, und <xref:System.Collections.IEnumerator.MoveNext%2A> gibt `false` zurück. Wenn sich der Enumerator an dieser Position befindet, geben nachfolgende Aufrufe von <xref:System.Collections.IEnumerator.MoveNext%2A> auch `false` zurück. Wenn der letzte Aufruf <xref:System.Collections.IEnumerator.MoveNext%2A> zurückgegebene `false`, <xref:System.Collections.IEnumerator.Current%2A> ist nicht definiert. Um <xref:System.Collections.IEnumerator.Current%2A> wieder auf das erste Element der Auflistung festzulegen, können Sie <xref:System.Collections.IEnumerator.Reset%2A> gefolgt von <xref:System.Collections.IEnumerator.MoveNext%2A> aufrufen.  
  
 Ein Enumerator bleibt gültig, solange die Auflistung unverändert ist. Werden an der Auflistung Änderungen wie z. B. Hinzufügen, Bearbeiten oder Entfernen von Elementen vorgenommen, verliert der Enumerator unwiederbringlich seine Gültigkeit und sein Verhalten ist nicht definiert.  
  
 Der Enumerator hat keinen exklusiven Zugriff auf die Auflistung. Daher ist die Enumeration einer Auflistung systemintern keine threadsichere Prozedur.  Um während der Enumeration Threadsicherheit zu garantieren, können Sie die Auflistung während der gesamten Enumeration sperren.  Um den Lese- und Schreibzugriff auf diese Auflistung durch mehrere Threads zuzulassen, müssen Sie eine eigene Synchronisierung implementieren.  
  
 Diese Methode ist ein O (1)-Vorgang.  
  
 Da das Serialisieren und Deserialisieren eines Enumerators für <xref:System.Collections.Hashtable> einen bewirken kann, dass die Elemente neu angeordnet werden, kann die Enumeration nicht fortgesetzt werden, <xref:System.Collections.IEnumerator.Reset%2A> ohne die-Methode aufzurufende.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung von <xref:System.Collections.Hashtable.GetEnumerator%2A> und `foreach` zum Auflisten des Inhalts eines <xref:System.Collections.Hashtable>verglichen.  
  
 [!code-cpp[Classic Hashtable Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Hashtable Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable Example/CS/source2.cs#2)]
 [!code-vb[Classic Hashtable Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable Example/VB/source2.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IDictionaryEnumerator" />
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetHash">
      <MemberSignature Language="C#" Value="protected virtual int GetHash (object key);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance int32 GetHash(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.GetHash(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetHash (key As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual int GetHash(System::Object ^ key);" />
      <MemberSignature Language="F#" Value="abstract member GetHash : obj -&gt; int&#xA;override this.GetHash : obj -&gt; int" Usage="hashtable.GetHash key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Das <see cref="T:System.Object" />, für das ein Hashcode zurückgegeben werden soll.</param>
        <summary>Gibt den Hashcode für den angegebenen Schlüssel zurück.</summary>
        <returns>Der Hashcode für <paramref name="key" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Hash Tabelle mit einer bestimmten <xref:System.Collections.IHashCodeProvider> Implementierung erstellt wurde, verwendet diese Methode diesen Hashcode-Anbieter; andernfalls wird die <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> Implementierung von `key`verwendet.  
  
 Diese Methode ist ein O (1)-Vorgang.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException"><paramref name="key" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="T:System.Object" />
        <altmember cref="T:System.Collections.IHashCodeProvider" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="hashtable.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="info">Ein <see cref="T:System.Runtime.Serialization.SerializationInfo" />-Objekt mit den zum Serialisieren der <see cref="T:System.Collections.Hashtable" /> erforderlichen Informationen.</param>
        <param name="context">Ein <see cref="T:System.Runtime.Serialization.StreamingContext" />-Objekt mit der Quelle und dem Ziel des entsprechenden serialisierten Streams für <see cref="T:System.Collections.Hashtable" />.</param>
        <summary>Implementiert die <see cref="T:System.Runtime.Serialization.ISerializable" />-Schnittstelle und gibt die zum Serialisieren der <see cref="T:System.Collections.Hashtable" /> erforderlichen Daten zurück.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist ein O (`n`)-Vorgang, `n` bei <xref:System.Collections.Hashtable.Count%2A>dem gleich ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="info" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die Auflistung wurde geändert.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
        <altmember cref="M:System.Collections.Hashtable.OnDeserialization(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="hcp">
      <MemberSignature Language="C#" Value="protected System.Collections.IHashCodeProvider hcp { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IHashCodeProvider hcp" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Hashtable.hcp" />
      <MemberSignature Language="VB.NET" Value="Protected Property hcp As IHashCodeProvider" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::IHashCodeProvider ^ hcp { System::Collections::IHashCodeProvider ^ get(); void set(System::Collections::IHashCodeProvider ^ value); };" />
      <MemberSignature Language="F#" Value="member this.hcp : System.Collections.IHashCodeProvider with get, set" Usage="System.Collections.Hashtable.hcp" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("Please use EqualityComparer property.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IHashCodeProvider</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Objekt ab, das Hashcodes verteilen kann, oder legt dieses fest.</summary>
        <value>Das Objekt, das Hashcodes verteilen kann.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Abrufen des Wertes dieser Eigenschaft ist ein O(1)-Vorgang.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die Eigenschaft wird auf einen Wert festgelegt, aber die Hashtabelle wurde mit einem <see cref="T:System.Collections.IEqualityComparer" /> erstellt.</exception>
        <altmember cref="T:System.Collections.IHashCodeProvider" />
      </Docs>
    </Member>
    <Member MemberName="IsFixedSize">
      <MemberSignature Language="C#" Value="public virtual bool IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Hashtable.IsFixedSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsFixedSize As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFixedSize : bool" Usage="System.Collections.Hashtable.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das <see cref="T:System.Collections.Hashtable" /> eine feste Größe aufweist.</summary>
        <value><see langword="true" /> , wenn das <see cref="T:System.Collections.Hashtable" /> eine feste Größe aufweist, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Auflistung mit fester Größe lässt das Hinzufügen oder Entfernen von Elementen nach dem Erstellen der Auflistung nicht zu. Vorhandene Elemente können jedoch geändert werden.  
  
 Eine Auflistung mit fester Größe ist einfach eine Sammlung mit einem Wrapper, der das Hinzufügen und Entfernen von Elementen verhindert. Wenn Änderungen an der zugrunde liegenden Auflistung vorgenommen werden, einschließlich hinzufügen oder Entfernen von Elementen, reflektiert die Auflistung mit fester Größe diese Änderungen.  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public virtual bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Hashtable.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Collections.Hashtable.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das <see cref="T:System.Collections.Hashtable" /> schreibgeschützt ist.</summary>
        <value><see langword="true" />, wenn das <see cref="T:System.Collections.Hashtable" /> schreibgeschützt ist, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine schreibgeschützte Auflistung gestattet nach dem Erstellen der Auflistung weder das Hinzufügen noch das Ändern oder Entfernen von Elementen.  
  
 Eine Auflistung, die schreibgeschützt ist, ist einfach eine Sammlung mit einem Wrapper, der das Ändern der Auflistung verhindert. Wenn also Änderungen an der zugrunde liegenden Auflistung vorgenommen werden, reflektiert die schreibgeschützte Auflistung diese Änderungen.  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSynchronized">
      <MemberSignature Language="C#" Value="public virtual bool IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Hashtable.IsSynchronized" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSynchronized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSynchronized : bool" Usage="System.Collections.Hashtable.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Zugriff auf die <see cref="T:System.Collections.Hashtable" /> synchronisiert (threadsicher) ist.</summary>
        <value><see langword="true" /> , wenn der Zugriff auf das <see cref="T:System.Collections.Hashtable" /> synchronisiert (threadsicher) ist, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Collections.Hashtable> kann einen Writer und mehrere Leser gleichzeitig unterstützen. Zur Unterstützung mehrerer Writer müssen alle Vorgänge über den von der <xref:System.Collections.Hashtable.Synchronized%2A> -Methode zurückgegebenen Wrapper durchgeführt werden.  
  
 Das Auflisten durch eine Auflistung ist intrinsisch keine Thread sichere Prozedur. Selbst wenn eine Auflistung synchronisiert wird, besteht die Möglichkeit, dass andere Threads sie ändern. Dies führt dazu, dass der Enumerator eine Ausnahme auslöst. Um während der Enumeration Threadsicherheit zu gewährleisten, können Sie entweder die Auflistung während der gesamten Enumeration sperren oder die Ausnahmen, die aus von anderen Threads stammenden Änderungen resultieren, abfangen.  
  
 Im folgenden Codebeispiel wird veranschaulicht, wie die-Auflistung <xref:System.Collections.Hashtable.SyncRoot%2A> während der gesamten-Enumeration mithilfe von gesperrt wird:  
  
 [!code-cpp[Classic Hashtable.IsSynchronized Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/CPP/remarks.cpp#2)]
 [!code-csharp[Classic Hashtable.IsSynchronized Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/CS/remarks.cs#2)]
 [!code-vb[Classic Hashtable.IsSynchronized Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/VB/remarks.vb#2)]  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie eine <xref:System.Collections.Hashtable>synchronisiert wird, ob <xref:System.Collections.Hashtable> eine synchronisiert wird und wie eine Synchronisierung <xref:System.Collections.Hashtable>verwendet wird.  
  
 [!code-cpp[Classic Hashtable.IsSynchronized Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Hashtable.IsSynchronized Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/CS/source.cs#1)]
 [!code-vb[Classic Hashtable.IsSynchronized Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)" />
        <altmember cref="P:System.Collections.Hashtable.SyncRoot" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public virtual object this[object key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(object)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Hashtable.Item(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overridable Property Item(key As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ default[System::Object ^] { System::Object ^ get(System::Object ^ key); void set(System::Object ^ key, System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Item(obj) : obj with get, set" Usage="System.Collections.Hashtable.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Item(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Der Schlüssel, dessen Wert abgerufen oder festgelegt werden soll.</param>
        <summary>Ruft den Wert ab, der dem angegebenen Schlüssel zugeordnet ist, oder legt diesen fest.</summary>
        <value>Der dem angegebenen Schlüssel zugeordnete Wert. Wenn der angegebene Schlüssel nicht gefunden werden kann, wird beim Abrufen dieses Schlüssels <see langword="null" /> zurückgegeben. Beim Festlegen wird ein neues Element mit dem angegebenen Schlüssel erstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ermöglicht den Zugriff auf ein bestimmtes Element in der Auflistung mithilfe folgender Syntax: `myCollection[key]`.  
  
 Sie können auch die <xref:System.Collections.Hashtable.Item%2A> zum Hinzufügen neuer Elemente durch Festlegen des Werts eines Schlüssels, die Eigenschaft ist nicht vorhanden, der <xref:System.Collections.Hashtable>, z. B. `myCollection["myNonexistentKey"] = myValue` Wenn jedoch der angegebene Schlüssel bereits in <xref:System.Collections.Hashtable>vorhanden ist, wird durch das Festlegen der <xref:System.Collections.Hashtable.Item%2A> -Eigenschaft der alte Wert überschrieben. Im Gegensatz dazu ändert <xref:System.Collections.Hashtable.Add%2A> die-Methode keine vorhandenen Elemente.  
  
 Ein Schlüssel kann nicht `null`sein, aber ein Wert kann sein. Um zu unter `null` scheiden, ob der angegebene Schlüssel nicht gefunden wurde und `null` zurückgegeben wird, da der Wert des angegebenen Schlüssels ist `null`, verwenden Sie die <xref:System.Collections.Hashtable.Contains%2A> -Methode oder <xref:System.Collections.Hashtable.ContainsKey%2A> die-Methode, um zu bestimmen, ob der Schlüssel ist in der Liste vorhanden.  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O (1)-Vorgang. das Festlegen der-Eigenschaft ist ebenfalls ein O (1)-Vorgang.  
  
 Die C# Sprache verwendet das [`this`](~/docs/csharp/language-reference/keywords/this.md) -Schlüsselwort, um die Indexer zu definieren, <xref:System.Collections.IList.Item%2A> statt die-Eigenschaft zu implementieren. Visual Basic implementiert <xref:System.Collections.Hashtable.Item%2A> als Standardeigenschaft und stellt auf diese Weise dieselbe Indizierungsfunktionalität bereit.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Die Eigenschaft wird festgelegt, und <see cref="T:System.Collections.Hashtable" /> ist schreibgeschützt.  
  
- oder - 
Die Eigenschaft wird festgelegt, <paramref name="key" /> ist in der Auflistung nicht vorhanden, und <see cref="T:System.Collections.Hashtable" /> hat eine feste Größe.</exception>
        <altmember cref="M:System.Collections.Hashtable.Add(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="KeyEquals">
      <MemberSignature Language="C#" Value="protected virtual bool KeyEquals (object item, object key);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool KeyEquals(object item, object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.KeyEquals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function KeyEquals (item As Object, key As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool KeyEquals(System::Object ^ item, System::Object ^ key);" />
      <MemberSignature Language="F#" Value="abstract member KeyEquals : obj * obj -&gt; bool&#xA;override this.KeyEquals : obj * obj -&gt; bool" Usage="hashtable.KeyEquals (item, key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">Das <see cref="T:System.Object" />, das mit <paramref name="key" /> verglichen werden soll.</param>
        <param name="key">Der Schlüssel in der <see cref="T:System.Collections.Hashtable" />, der mit <paramref name="item" /> verglichen werden soll.</param>
        <summary>Vergleicht ein bestimmtes <see cref="T:System.Object" /> mit einem bestimmten Schlüssel in <see cref="T:System.Collections.Hashtable" />.</summary>
        <returns><see langword="true" />, wenn <paramref name="item" /> und <paramref name="key" /> gleich sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Hash <xref:System.Collections.IComparer> Tabelle mit einer bestimmten Implementierung erstellt wurde, verwendet diese Methode diesen Comparer <xref:System.Collections.IComparer.Compare%2A> , d. h.`item`( `key`,). Andernfalls wird verwendet `item.Equals(key)`.  
  
 Diese Methode ist ein O (1)-Vorgang.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="item" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="key" /> ist <see langword="null" />.</exception>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.Collections.IComparer.Compare(System.Object,System.Object)" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Keys">
      <MemberSignature Language="C#" Value="public virtual System.Collections.ICollection Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection Keys" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Hashtable.Keys" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Keys As ICollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::ICollection ^ Keys { System::Collections::ICollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Keys : System.Collections.ICollection" Usage="System.Collections.Hashtable.Keys" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Keys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine <see cref="T:System.Collections.ICollection" /> ab, die die Schlüssel im <see cref="T:System.Collections.Hashtable" /> enthält.</summary>
        <value>Eine <see cref="T:System.Collections.ICollection" />, die die Schlüssel in der <see cref="T:System.Collections.Hashtable" /> enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Reihenfolge der Schlüssel in der <xref:System.Collections.ICollection> ist nicht angegeben, aber es ist dieselbe Reihenfolge wie die zugeordneten Werte in <xref:System.Collections.ICollection> der, die <xref:System.Collections.Hashtable.Values%2A> von der-Methode zurückgegeben werden.  
  
 Der zurück <xref:System.Collections.ICollection> gegebene ist keine statische Kopie, sondern <xref:System.Collections.ICollection> verweist auf die Schlüssel im ursprünglichen <xref:System.Collections.Hashtable>. Aus diesem Grund werden Änderungen <xref:System.Collections.Hashtable> an der weiterhin im widergespiegelt. <xref:System.Collections.ICollection>  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="P:System.Collections.Hashtable.Values" />
      </Docs>
    </Member>
    <Member MemberName="OnDeserialization">
      <MemberSignature Language="C#" Value="public virtual void OnDeserialization (object sender);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void OnDeserialization(object sender) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.OnDeserialization(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub OnDeserialization (sender As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void OnDeserialization(System::Object ^ sender);" />
      <MemberSignature Language="F#" Value="abstract member OnDeserialization : obj -&gt; unit&#xA;override this.OnDeserialization : obj -&gt; unit" Usage="hashtable.OnDeserialization sender" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="sender">Die Quelle des Deserialisierungsereignisses.</param>
        <summary>Implementiert die <see cref="T:System.Runtime.Serialization.ISerializable" />-Schnittstelle und löst das Deserialisierungsereignis aus, sobald die Deserialisierung abgeschlossen ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist ein O (`n`)-Vorgang, `n` bei <xref:System.Collections.Hashtable.Count%2A>dem gleich ist.  
  
 Da das Serialisieren und Deserialisieren eines Enumerators für <xref:System.Collections.Hashtable> einen bewirken kann, dass die Elemente neu angeordnet werden, kann die Enumeration nicht fortgesetzt werden, <xref:System.Collections.IEnumerator.Reset%2A> ohne die-Methode aufzurufende.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Serialization.SerializationException">Das der aktuellen <see cref="T:System.Runtime.Serialization.SerializationInfo" /> zugeordnete <see cref="T:System.Collections.Hashtable" />-Objekt ist ungültig.</exception>
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
        <altmember cref="M:System.Collections.Hashtable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public virtual void Remove (object key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Remove(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Remove (key As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Remove(System::Object ^ key);" />
      <MemberSignature Language="F#" Value="abstract member Remove : obj -&gt; unit&#xA;override this.Remove : obj -&gt; unit" Usage="hashtable.Remove key" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Der Schlüssel des zu entfernenden Elements.</param>
        <summary>Entfernt das Element mit dem angegebenen Schlüssel aus dem <see cref="T:System.Collections.Hashtable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn das <xref:System.Collections.Hashtable> kein Element mit dem angegebenen Schlüssel enthält <xref:System.Collections.Hashtable> , bleibt unverändert. Es werden keine Ausnahmen ausgelöst.  
  
 Diese Methode ist ein O (1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie Elemente aus der <xref:System.Collections.Hashtable>entfernt werden.  
  
 [!code-cpp[Classic Hashtable.Remove Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable.Remove Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Hashtable.Remove Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable.Remove Example/CS/source.cs#1)]
 [!code-vb[Classic Hashtable.Remove Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable.Remove Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.Hashtable" /> ist schreibgeschützt.  
  
- oder - 
<see cref="T:System.Collections.Hashtable" /> hat eine feste Größe.</exception>
        <altmember cref="M:System.Collections.Hashtable.Add(System.Object,System.Object)" />
        <altmember cref="M:System.Collections.IDictionary.Remove(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Synchronized">
      <MemberSignature Language="C#" Value="public static System.Collections.Hashtable Synchronized (System.Collections.Hashtable table);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Hashtable Synchronized(class System.Collections.Hashtable table) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Synchronized (table As Hashtable) As Hashtable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Hashtable ^ Synchronized(System::Collections::Hashtable ^ table);" />
      <MemberSignature Language="F#" Value="static member Synchronized : System.Collections.Hashtable -&gt; System.Collections.Hashtable" Usage="System.Collections.Hashtable.Synchronized table" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Hashtable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Collections.Hashtable" />
      </Parameters>
      <Docs>
        <param name="table">Die <see cref="T:System.Collections.Hashtable" />, die synchronisiert werden soll.</param>
        <summary>Gibt einen synchronisierten (threadsicheren) Wrapper für die <see cref="T:System.Collections.Hashtable" /> zurück.</summary>
        <returns>Ein synchronisierter (threadsicherer) Wrapper für die <see cref="T:System.Collections.Hashtable" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Collections.Hashtable.Synchronized%2A> -Methode ist für mehrere Reader und Writer Thread sicher. Außerdem stellt der synchronisierte Wrapper sicher, dass nur ein Writer gleichzeitig geschrieben wird.  
  
 Die Enumeration einer Auflistung ist systemintern keine threadsichere Prozedur. Selbst wenn eine Auflistung synchronisiert wird, besteht die Möglichkeit, dass andere Threads sie ändern. Dies führt dazu, dass der Enumerator eine Ausnahme auslöst. Um während der Enumeration Threadsicherheit zu gewährleisten, können Sie entweder die Auflistung während der gesamten Enumeration sperren oder die Ausnahmen, die aus von anderen Threads stammenden Änderungen resultieren, abfangen.  
  
 Im folgenden Codebeispiel wird veranschaulicht, wie die-Auflistung <xref:System.Collections.Hashtable.SyncRoot%2A> während der gesamten-Enumeration mithilfe von gesperrt wird:  
  
 [!code-cpp[Classic Hashtable.IsSynchronized Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/CPP/remarks.cpp#2)]
 [!code-csharp[Classic Hashtable.IsSynchronized Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/CS/remarks.cs#2)]
 [!code-vb[Classic Hashtable.IsSynchronized Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/VB/remarks.vb#2)]  
  
 Diese Methode ist ein O (1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie eine <xref:System.Collections.Hashtable>synchronisiert wird, ob <xref:System.Collections.Hashtable> eine synchronisiert wird und wie eine Synchronisierung <xref:System.Collections.Hashtable>verwendet wird.  
  
 [!code-cpp[Classic Hashtable.IsSynchronized Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Hashtable.IsSynchronized Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/CS/source.cs#1)]
 [!code-vb[Classic Hashtable.IsSynchronized Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="table" /> ist <see langword="null" />.</exception>
        <altmember cref="P:System.Collections.Hashtable.IsSynchronized" />
        <altmember cref="P:System.Collections.Hashtable.SyncRoot" />
      </Docs>
    </Member>
    <Member MemberName="SyncRoot">
      <MemberSignature Language="C#" Value="public virtual object SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Hashtable.SyncRoot" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SyncRoot As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SyncRoot : obj" Usage="System.Collections.Hashtable.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein Objekt ab, mit dem der Zugriff auf <see cref="T:System.Collections.Hashtable" /> synchronisiert werden kann.</summary>
        <value>Ein Objekt, mit dem der Zugriff auf die <see cref="T:System.Collections.Hashtable" /> synchronisiert werden kann.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie die <xref:System.Collections.Hashtable> <xref:System.Collections.Hashtable.Synchronized%2A> -Methode, um eine synchronisierte Version von zu erstellen. Abgeleitete Klassen können jedoch <xref:System.Collections.Hashtable> mithilfe der <xref:System.Collections.Hashtable.SyncRoot%2A> -Eigenschaft eine eigene synchronisierte Version von bereitstellen. Der Synchronisierungs Code muss Vorgänge für die <xref:System.Collections.Hashtable.SyncRoot%2A> <xref:System.Collections.Hashtable>von, nicht direkt auf dem <xref:System.Collections.Hashtable> ausführen. Dies gewährleistet die einwandfreie Funktion von Auflistungen, die von anderen Objekten abgeleitet sind. Insbesondere wird die ordnungsgemäße Synchronisierung mit anderen Threads verwaltet, die das <xref:System.Collections.Hashtable> Objekt möglicherweise gleichzeitig ändern.  
  
 Das Auflisten durch eine Auflistung ist intrinsisch keine Thread sichere Prozedur. Selbst wenn eine Auflistung synchronisiert wird, besteht die Möglichkeit, dass andere Threads sie ändern. Dies führt dazu, dass der Enumerator eine Ausnahme auslöst. Um während der Enumeration Threadsicherheit zu gewährleisten, können Sie entweder die Auflistung während der gesamten Enumeration sperren oder die Ausnahmen, die aus von anderen Threads stammenden Änderungen resultieren, abfangen.  
  
 Im folgenden Codebeispiel wird veranschaulicht, wie die-Auflistung <xref:System.Collections.Hashtable.SyncRoot%2A> während der gesamten-Enumeration mithilfe von gesperrt wird:  
  
 [!code-cpp[Classic Hashtable.IsSynchronized Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/CPP/remarks.cpp#2)]
 [!code-csharp[Classic Hashtable.IsSynchronized Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/CS/remarks.cs#2)]
 [!code-vb[Classic Hashtable.IsSynchronized Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Hashtable.IsSynchronized Example/VB/remarks.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.Hashtable.IsSynchronized" />
        <altmember cref="M:System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Enumerator zurück, der eine Auflistung durchläuft.</summary>
        <returns>Ein <see cref="T:System.Collections.IEnumerator" />, der zum Durchlaufen der Auflistung verwendet werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [Visual Basic, C#]  
  
 Die `foreach`-Anweisung der Programmiersprache C# (`for each` in Visual Basic) verbirgt die Komplexität der Enumeratoren.  Daher empfiehlt es sich, `foreach` zu verwenden und den Enumerator nicht direkt zu ändern.  
  
 Mit Enumeratoren können die Daten in der Auflistung zwar gelesen, jedoch nicht zum Ändern der zugrunde liegenden Auflistung verwendet werden.  
  
 Zu Beginn wird der Enumerator vor das erste Element in der Auflistung positioniert. <xref:System.Collections.IEnumerator.Reset%2A> setzt den Enumerator ebenfalls auf diese Position zurück. An dieser Position löst der <xref:System.Collections.IEnumerator.Current%2A> Aufruf von eine Ausnahme aus. Daher muss der Enumerator durch einen Aufruf von <xref:System.Collections.IEnumerator.MoveNext%2A> auf das erste Element der Auflistung gesetzt werden, bevor der Wert von <xref:System.Collections.IEnumerator.Current%2A> gelesen werden kann.  
  
 <xref:System.Collections.IEnumerator.Current%2A> gibt solange dasselbe Objekt zurück, bis <xref:System.Collections.IEnumerator.MoveNext%2A> oder <xref:System.Collections.IEnumerator.Reset%2A> aufgerufen wird. <xref:System.Collections.IEnumerator.MoveNext%2A> legt <xref:System.Collections.IEnumerator.Current%2A> auf das nächste Element fest.  
  
 Wenn <xref:System.Collections.IEnumerator.MoveNext%2A> das Ende der Auflistung übergibt, wird der Enumerator hinter dem letzten Element in der Auflistung platziert, und <xref:System.Collections.IEnumerator.MoveNext%2A> gibt `false` zurück. Wenn sich der Enumerator an dieser Position befindet, geben nachfolgende Aufrufe von <xref:System.Collections.IEnumerator.MoveNext%2A> auch `false` zurück. Wenn der letzte Aufruf von <xref:System.Collections.IEnumerator.MoveNext%2A> zurück `false`gegeben wird <xref:System.Collections.IEnumerator.Current%2A> , löst der Aufruf von eine Ausnahme aus. Um <xref:System.Collections.IEnumerator.Current%2A> wieder auf das erste Element der Auflistung festzulegen, können Sie <xref:System.Collections.IEnumerator.Reset%2A> gefolgt von <xref:System.Collections.IEnumerator.MoveNext%2A> aufrufen.  
  
 Ein Enumerator bleibt gültig, solange die Auflistung unverändert ist. Wenn Änderungen an der Auflistung vorgenommen werden, z. b. das Hinzufügen, ändern oder Löschen von Elementen, kann der Enumerator ungültig werden, und <xref:System.Collections.IEnumerator.MoveNext%2A> der <xref:System.Collections.IEnumerator.Reset%2A> nächste Rückruf <xref:System.InvalidOperationException>von oder löst eine aus. Wenn die Auflistung zwischen <xref:System.Collections.IEnumerator.MoveNext%2A> und geändert wird, <xref:System.Collections.IEnumerator.Current%2A> gibt das- <xref:System.Collections.IEnumerator.Current%2A>Element zurück, auf das Sie festgelegt ist, auch wenn der Enumerator bereits für ungültig erklärt wurde.  
  
 Der Enumerator hat keinen exklusiven Zugriff auf die Auflistung. Daher ist die Enumeration einer Auflistung systemintern keine threadsichere Prozedur. Selbst wenn eine Auflistung synchronisiert wird, besteht die Möglichkeit, dass andere Threads sie ändern. Dies führt dazu, dass der Enumerator eine Ausnahme auslöst. Um während der Enumeration Threadsicherheit zu gewährleisten, können Sie entweder die Auflistung während der gesamten Enumeration sperren oder die Ausnahmen, die aus von anderen Threads stammenden Änderungen resultieren, abfangen.  
  
 Diese Methode ist ein O (1)-Vorgang.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="Values">
      <MemberSignature Language="C#" Value="public virtual System.Collections.ICollection Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection Values" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Hashtable.Values" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Values As ICollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::ICollection ^ Values { System::Collections::ICollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Values : System.Collections.ICollection" Usage="System.Collections.Hashtable.Values" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Values</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine <see cref="T:System.Collections.ICollection" /> ab, die die Werte im <see cref="T:System.Collections.Hashtable" /> enthält.</summary>
        <value>Eine <see cref="T:System.Collections.ICollection" />, die die Werte im <see cref="T:System.Collections.Hashtable" /> enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Reihenfolge der Werte in der <xref:System.Collections.ICollection> ist nicht angegeben, aber es ist dieselbe Reihenfolge wie die zugeordneten Schlüssel in <xref:System.Collections.ICollection> der, die <xref:System.Collections.Hashtable.Keys%2A> von der-Methode zurückgegeben wird.  
  
 Der zurück <xref:System.Collections.ICollection> gegebene ist keine statische Kopie, sondern <xref:System.Collections.ICollection> verweist auf die Werte in der ursprünglichen <xref:System.Collections.Hashtable>. Aus diesem Grund werden Änderungen <xref:System.Collections.Hashtable> an der weiterhin im widergespiegelt. <xref:System.Collections.ICollection>  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="P:System.Collections.Hashtable.Keys" />
      </Docs>
    </Member>
  </Members>
</Type>
