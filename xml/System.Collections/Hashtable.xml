<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Hashtable.xml" source-language="en-US" target-language="de-DE">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac54c6adcdcf0768c2d073d568527998677360d621e.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">4c6adcdcf0768c2d073d568527998677360d621e</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Collections.Hashtable">
          <source>Represents a collection of key/value pairs that are organized based on the hash code of the key.</source>
          <target state="translated">Stellt eine Auflistung von Schlüssel-Wert-Paaren dar, die auf Grundlage des Hashcodes des Schlüssels geordnet sind.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>Each element is a key/value pair stored in a <ph id="ph1">&lt;xref:System.Collections.DictionaryEntry&gt;</ph> object.</source>
          <target state="translated">Jedes Element ist ein Schlüssel/Wert-Paar in gespeicherten ein <ph id="ph1">&lt;xref:System.Collections.DictionaryEntry&gt;</ph> Objekt.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>A key cannot be <ph id="ph1">`null`</ph>, but a value can be.</source>
          <target state="translated">Ein Schlüssel kann nicht <ph id="ph1">`null`</ph>, aber ein Wert sein kann.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>The objects used as keys by a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> are required to override the <ph id="ph2">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> method (or the <ph id="ph3">&lt;xref:System.Collections.IHashCodeProvider&gt;</ph> interface) and the <ph id="ph4">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> method (or the <ph id="ph5">&lt;xref:System.Collections.IComparer&gt;</ph> interface).</source>
          <target state="translated">Die Objekte, die als Schlüssel durch eine <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> sind erforderlich, um das Überschreiben der <ph id="ph2">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> Methode (oder die <ph id="ph3">&lt;xref:System.Collections.IHashCodeProvider&gt;</ph> Schnittstelle) und die <ph id="ph4">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> Methode (oder die <ph id="ph5">&lt;xref:System.Collections.IComparer&gt;</ph> Schnittstelle).</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>The implementation of both methods and interfaces must handle case sensitivity the same way; otherwise, the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> might behave incorrectly.</source>
          <target state="translated">Die Implementierung von Methoden und Schnittstellen muss Groß-/Kleinschreibung die gleiche Weise behandeln. andernfalls die <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> möglicherweise nicht ordnungsgemäß verhält.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>For example, when creating a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>, you must use the <ph id="ph2">&lt;xref:System.Collections.CaseInsensitiveHashCodeProvider&gt;</ph> class (or any case-insensitive <ph id="ph3">&lt;xref:System.Collections.IHashCodeProvider&gt;</ph> implementation) with the <ph id="ph4">&lt;xref:System.Collections.CaseInsensitiveComparer&gt;</ph> class (or any case-insensitive <ph id="ph5">&lt;xref:System.Collections.IComparer&gt;</ph> implementation).</source>
          <target state="translated">Z. B. beim Erstellen einer <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>, verwenden Sie die <ph id="ph2">&lt;xref:System.Collections.CaseInsensitiveHashCodeProvider&gt;</ph> Klasse (oder alle Groß-/Kleinschreibung <ph id="ph3">&lt;xref:System.Collections.IHashCodeProvider&gt;</ph> Implementierung) mit der <ph id="ph4">&lt;xref:System.Collections.CaseInsensitiveComparer&gt;</ph> Klasse (oder alle Groß-/Kleinschreibung <ph id="ph5">&lt;xref:System.Collections.IComparer&gt;</ph> Implementierung).</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>Furthermore, these methods must produce the same results when called with the same parameters while the key exists in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
          <target state="translated">Darüber hinaus müssen diese Methoden erzeugen die gleichen Ergebnisse, wenn Sie mit denselben Parametern aufgerufen wird, während der Schlüssel vorhanden ist die <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>An alternative is to use a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> constructor with an <ph id="ph2">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> parameter.</source>
          <target state="translated">Eine Alternative ist die Verwendung einer <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> Konstruktor mit einem <ph id="ph2">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>If key equality were simply reference equality, the inherited implementation of <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> would suffice.</source>
          <target state="translated">Gleichheit der Schlüssel wäre einfach Verweisgleichheit, der geerbten Implementierung von <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> und <ph id="ph2">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> ausreichen würde.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>Key objects must be immutable as long as they are used as keys in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
          <target state="translated">Schlüsselobjekte müssen unveränderlich sein, solange sie als Schlüssel verwendet werden die <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>When an element is added to the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>, the element is placed into a bucket based on the hash code of the key.</source>
          <target state="translated">Wenn ein Element hinzugefügt wird, um die <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>, das Element befindet sich in einem Bucket, basierend auf dem Hashcode des Schlüssels.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>Subsequent lookups of the key use the hash code of the key to search in only one particular bucket, thus substantially reducing the number of key comparisons required to find an element.</source>
          <target state="translated">Nachfolgende Suchen des Schlüssels verwenden den Hashcode des Schlüssels in nur einem bestimmten Bucket gesucht werden soll, wodurch die Anzahl der Schlüssel Vergleiche erforderlich, um nach einem Element Suchen erheblich reduziert.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>The load factor of a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> determines the maximum ratio of elements to buckets.</source>
          <target state="translated">Der Ladefaktor eine <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> bestimmt das maximale Verhältnis von Elementen zu Buckets.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>Smaller load factors cause faster average lookup times at the cost of increased memory consumption.</source>
          <target state="translated">Kleinere laden Faktoren dazu führen, dass schneller Suchzeiten Speicherbedarf.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>The default load factor of 1.0 generally provides the best balance between speed and size.</source>
          <target state="translated">Der Standardlastfaktor 1,0 bietet im Allgemeinen den besten Kompromiss zwischen Geschwindigkeit und Größe.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>A different load factor can also be specified when the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> is created.</source>
          <target state="translated">Ein anderen Ladefaktor kann auch angegeben, wann die <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> wird erstellt.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>As elements are added to a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>, the actual load factor of the <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> increases.</source>
          <target state="translated">Wenn Elemente hinzugefügt werden eine <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>, den tatsächlichen Ladefaktor der <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> erhöht.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>When the actual load factor reaches the specified load factor, the number of buckets in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> is automatically increased to the smallest prime number that is larger than twice the current number of <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> buckets.</source>
          <target state="translated">Wenn der tatsächliche Lastfaktor erreicht den angegebenen Lastfaktor sowie die Anzahl der Buckets in der <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> wird automatisch auf die kleinste Primzahl, die größer ist als zweimal die aktuelle Anzahl der erhöht <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> Buckets.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>Each key object in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> must provide its own hash function, which can be accessed by calling <ph id="ph2">&lt;xref:System.Collections.Hashtable.GetHash%2A&gt;</ph>.</source>
          <target state="translated">Jedes Schlüsselobjekt in der <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> müssen eine eigene Hashfunktion, die durch den Aufruf zugegriffen werden kann bereitstellen <ph id="ph2">&lt;xref:System.Collections.Hashtable.GetHash%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>However, any object implementing <ph id="ph1">&lt;xref:System.Collections.IHashCodeProvider&gt;</ph> can be passed to a <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> constructor, and that hash function is used for all objects in the table.</source>
          <target state="translated">Allerdings alle Objekte implementieren <ph id="ph1">&lt;xref:System.Collections.IHashCodeProvider&gt;</ph> übergeben werden kann, um eine <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> Konstruktor, und Hash-Funktion für alle Objekte in der Tabelle verwendet wird.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>The capacity of a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> is the number of elements the <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> can hold.</source>
          <target state="translated">Die Kapazität einer <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> ist die Anzahl der Elemente der <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> aufnehmen kann.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>As elements are added to a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>, the capacity is automatically increased as required through reallocation.</source>
          <target state="translated">Wenn Elemente hinzugefügt werden eine <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>, die Kapazität wird automatisch erhöht, nach Bedarf über die neuzuordnung.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>For very large <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> objects, you can increase the maximum capacity to 2 billion elements on a 64-bit system by setting the <ph id="ph2">`enabled`</ph> attribute of the  configuration element to <ph id="ph3">`true`</ph> in the run-time environment.</source>
          <target state="translated">Für sehr große <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> Objekte aufweist, können Sie die maximale Kapazität auf 2 Milliarden Elemente auf einem 64-Bit-System erhöhen, indem die <ph id="ph2">`enabled`</ph> Attribut des Konfigurationselements auf <ph id="ph3">`true`</ph> in der Umgebung zur Laufzeit.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>The <ph id="ph1">`foreach`</ph> statement of the C# language (<ph id="ph2">`For Each`</ph> in Visual Basic) returns an object of the type of the elements in the collection.</source>
          <target state="translated">Die <ph id="ph1">`foreach`</ph> -Anweisung der Programmiersprache c# (<ph id="ph2">`For Each`</ph> in Visual Basic) ein Objekt des Typs der Elemente in der Auflistung zurück.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>Since each element of the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> is a key/value pair, the element type is not the type of the key or the type of the value.</source>
          <target state="translated">Da jedes Element von der <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> ist ein Schlüssel/Wert-Paar der Elementtyp ist nicht der Typ des Schlüssels oder den Typ des Werts.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>Instead, the element type is <ph id="ph1">&lt;xref:System.Collections.DictionaryEntry&gt;</ph>.</source>
          <target state="translated">Stattdessen der Elementtyp ist <ph id="ph1">&lt;xref:System.Collections.DictionaryEntry&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>For example:</source>
          <target state="translated">Zum Beispiel:</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>The <ph id="ph1">`foreach`</ph> statement is a wrapper around the enumerator, which only allows reading from, not writing to, the collection.</source>
          <target state="translated">Die <ph id="ph1">`foreach`</ph> Anweisung ist ein Wrapper um den Enumerator, der nur das Lesen aus nicht das Schreiben auf die Auflistung zulässt.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>Because serializing and deserializing an enumerator for a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> can cause the elements to become reordered, it is not possible to continue enumeration without calling the <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> method.</source>
          <target state="translated">Da das Serialisieren und Deserialisieren einen Enumerator für eine <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> kann dazu führen, dass die Elemente, die neu angeordnet werden, es ist nicht möglich, Enumeration ohne Aufruf zu fortfahren die <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>Because keys can be inherited and their behavior changed, their absolute uniqueness cannot be guaranteed by comparisons using the <ph id="ph1">&lt;xref:System.Type.Equals%2A&gt;</ph> method.</source>
          <target state="translated">Da Schlüssel geerbt werden können, und ihr Verhalten geändert, deren absolute Eindeutigkeit vom nicht sichergestellt werden Vergleiche mit der <ph id="ph1">&lt;xref:System.Type.Equals%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>The following example shows how to create, initialize and perform various functions to a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> and how to print out its keys and values.</source>
          <target state="translated">Im folgende Beispiel wird gezeigt, wie zum Erstellen, initialisieren und führen verschiedene Funktionen auf einem <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> und zum Drucken von seiner Schlüssel und Werte.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source><ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> is thread safe for use by multiple reader threads and a single writing thread.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> ist threadsicher, für die Verwendung durch mehrere Readerthreads und einen einzelnen Schreibthread threadsicher.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>It is thread safe for multi-thread use when only one of the threads perform write (update) operations, which allows for lock-free reads provided that the writers are serialized to the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated">Es ist threadsicher für Multi-Thread verwenden, wenn nur einer der Threads ausführen Schreibvorgänge (Update), die sperrenfreie Lesevorgänge gewährt, vorausgesetzt, dass der Writer serialisiert werden die <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>To support multiple writers all operations on the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> must be done through the wrapper returned by the <ph id="ph2">&lt;see cref="M:System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)" /&gt;</ph> method, provided that there are no threads reading the <ph id="ph3">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> object.</source>
          <target state="translated">Um mehrere Writer auf alle Vorgänge unterstützen die <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> muss über den Wrapper zurückgegebene erfolgen die <ph id="ph2">&lt;see cref="M:System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)" /&gt;</ph> -Methode, vorausgesetzt, es sind keine Threads, die beim Lesen der <ph id="ph3">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> Objekt.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>Enumerating through a collection is intrinsically not a thread safe procedure.</source>
          <target state="translated">Einer Auflistung ist systemintern keine threadsichere Prozedur.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</source>
          <target state="translated">Selbst wenn eine Auflistung synchronisiert wird, besteht die Möglichkeit, dass andere Threads sie ändern. Dies führt dazu, dass der Enumerator eine Ausnahme auslöst.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Hashtable">
          <source>To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</source>
          <target state="translated">Um während der Enumeration Threadsicherheit zu gewährleisten, können Sie entweder die Auflistung während der gesamten Enumeration sperren oder die Ausnahmen, die aus von anderen Threads stammenden Änderungen resultieren, abfangen.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" uid="T:System.Collections.Hashtable">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> class.</source>
          <target state="translated">Initialisiert eine neue Instanz der <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>-Klasse.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor">
          <source>Initializes a new, empty instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> class using the default initial capacity, load factor, hash code provider, and comparer.</source>
          <target state="translated">Initialisiert eine neue leere Instanz der <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>-Klasse unter Verwendung der anfänglichen Standardkapazität, des Standardlastfaktors, Hashcode-Standardanbieters und des Standardcomparers.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor">
          <source>A hash table's capacity is used to calculate the optimal number of hash table buckets based on the load factor.</source>
          <target state="translated">Eine Hashtabelle Kapazität wird verwendet, um die optimale Anzahl der hashbuckets-Tabelle basierend auf den Lastfaktor berechnen.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor">
          <source>Capacity is automatically increased as required.</source>
          <target state="translated">Kapazität wird automatisch erhöht, nach Bedarf.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor">
          <source>The load factor is the maximum ratio of elements to buckets.</source>
          <target state="translated">Der Ladefaktor ist das maximale Verhältnis von Elementen zu Buckets.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor">
          <source>A smaller load factor means faster lookup at the cost of increased memory consumption.</source>
          <target state="translated">Ein kleinerer Ladefaktor bedeutet schnellere Suchvorgänge auf Kosten erhöhter Speicherbedarf.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor">
          <source>When the actual load factor reaches the specified load factor, the number of buckets is automatically increased to the smallest prime number that is larger than twice the current number of buckets.</source>
          <target state="translated">Wenn der tatsächliche Lastfaktor den angegebenen Lastfaktor erreicht, wird die Anzahl der Buckets automatisch auf die kleinste Anzahl von Primzahlen erhöht, die größer ist als zweimal die aktuelle Anzahl der Buckets.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor">
          <source>The hash code provider dispenses hash codes for keys in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> object.</source>
          <target state="translated">Die Hashcodeanbieter Hashcodes für Schlüssel in der <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> Objekt.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor">
          <source>The default hash code provider is the key's implementation of <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Der Hashcode-Standardanbieter ist-Implementierung eines Schlüssels <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor">
          <source>The comparer determines whether two keys are equal.</source>
          <target state="translated">Der Vergleich bestimmt, ob zwei Schlüssel gleich sind.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor">
          <source>Every key in a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> must be unique.</source>
          <target state="translated">Jeder Schlüssel im einem <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> muss eindeutig sein.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor">
          <source>The default comparer is the key's implementation of <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Ist der Standardvergleich-Implementierung eines Schlüssels <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor">
          <source>This constructor is an O(1) operation.</source>
          <target state="translated">Dieser Konstruktor ist ein o(1)-Vorgang.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor">
          <source>The following code example creates hash tables using different <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.</source>
          <target state="translated">Das folgende Codebeispiel erstellt Hashtabellen mit verschiedenen <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> Konstruktoren und zeigt die Unterschiede im Verhalten von Hashtabellen, selbst wenn jeweils die gleichen Elemente enthält.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IDictionary" /&gt;</ph> object to copy to a new <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> object.</source>
          <target state="translated">Das <ph id="ph1">&lt;see cref="T:System.Collections.IDictionary" /&gt;</ph>-Objekt, das in ein neues <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>-Objekt kopiert werden soll.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> class by copying the elements from the specified dictionary to the new <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> object.</source>
          <target state="translated">Initialisiert eine neue Instanz der <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>-Klasse durch Kopieren der Elemente aus dem angegebenen Wörterbuch in das neue <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>-Objekt.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary)">
          <source>The new <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> object has an initial capacity equal to the number of elements copied, and uses the default load factor, hash code provider, and comparer.</source>
          <target state="translated">Das neue <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>-Objekt besitzt eine Anfangskapazität, die mit der Anzahl der kopierten Elemente identisch ist, und verwendet den Standardlastfaktor, den Hashcode-Standardanbieter und den Standardcomparer.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary)">
          <source>The initial capacity is set to the number of elements in the source dictionary.</source>
          <target state="translated">Die anfängliche Kapazität wird auf die Anzahl der Elemente im Quellwörterbuch festgelegt.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary)">
          <source>Capacity is automatically increased as required based on the load factor.</source>
          <target state="translated">Kapazität wird automatisch nach Bedarf erhöht werden basierend auf den Lastfaktor.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary)">
          <source>The load factor is the maximum ratio of elements to buckets.</source>
          <target state="translated">Der Ladefaktor ist das maximale Verhältnis von Elementen zu Buckets.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary)">
          <source>A smaller load factor means faster lookup at the cost of increased memory consumption.</source>
          <target state="translated">Ein kleinerer Ladefaktor bedeutet schnellere Suchvorgänge auf Kosten erhöhter Speicherbedarf.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary)">
          <source>When the actual load factor reaches the specified load factor, the number of buckets is automatically increased to the smallest prime number that is larger than twice the current number of buckets.</source>
          <target state="translated">Wenn der tatsächliche Lastfaktor den angegebenen Lastfaktor erreicht, wird die Anzahl der Buckets automatisch auf die kleinste Anzahl von Primzahlen erhöht, die größer ist als zweimal die aktuelle Anzahl der Buckets.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary)">
          <source>The hash code provider dispenses hash codes for keys in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> object.</source>
          <target state="translated">Die Hashcodeanbieter Hashcodes für Schlüssel in der <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> Objekt.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary)">
          <source>The default hash code provider is the key's implementation of <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Der Hashcode-Standardanbieter ist-Implementierung eines Schlüssels <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary)">
          <source>The comparer determines whether two keys are equal.</source>
          <target state="translated">Der Vergleich bestimmt, ob zwei Schlüssel gleich sind.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary)">
          <source>Every key in a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> must be unique.</source>
          <target state="translated">Jeder Schlüssel im einem <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> muss eindeutig sein.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary)">
          <source>The default comparer is the key's implementation of <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Ist der Standardvergleich-Implementierung eines Schlüssels <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary)">
          <source>The elements of the new <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> are sorted in the same order in which the enumerator iterates through the <ph id="ph2">&lt;xref:System.Collections.IDictionary&gt;</ph> object.</source>
          <target state="translated">Die Elemente der neuen <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> sortiert sind, in der gleichen Reihenfolge, in dem sich der Enumerator durchläuft, die <ph id="ph2">&lt;xref:System.Collections.IDictionary&gt;</ph> Objekt.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary)">
          <source>This constructor is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements in the <ph id="ph3">`d`</ph> parameter.</source>
          <target state="translated">Dieser Konstruktor ist eine O (<ph id="ph1">`n`</ph>)-Vorgang, in dem <ph id="ph2">`n`</ph> ist die Anzahl der Elemente in der <ph id="ph3">`d`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary)">
          <source>The following code example creates hash tables using different <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.</source>
          <target state="translated">Das folgende Codebeispiel erstellt Hashtabellen mit verschiedenen <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> Konstruktoren und zeigt die Unterschiede im Verhalten von Hashtabellen, selbst wenn jeweils die gleichen Elemente enthält.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary)">
          <source><ph id="ph1">&lt;paramref name="d" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="d" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IEqualityComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph> object that defines the hash code provider and the comparer to use with the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> object.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph>, der sowohl den Hashcodeanbieter als auch den Comparer zur Verwendung mit der <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> definiert.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IEqualityComparer)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IEqualityComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the default hash code provider and the default comparer.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph>, um den Hashcode-Standardanbieter und den Standardcomparer zu verwenden.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IEqualityComparer)">
          <source>The default hash code provider is each key's implementation of <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> and the default comparer is each key's implementation of <ph id="ph2">&lt;see cref="M:System.Object.Equals(System.Object)" /&gt;</ph>.</source>
          <target state="translated">Der Hashcode-Standardanbieter ist die Implementierung von <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> jedes Schlüssels, und der Standardcomparer ist die Implementierung von <ph id="ph2">&lt;see cref="M:System.Object.Equals(System.Object)" /&gt;</ph> jedes Schlüssels.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IEqualityComparer)">
          <source>Initializes a new, empty instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> class using the default initial capacity and load factor, and the specified <ph id="ph2">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph> object.</source>
          <target state="translated">Initialisiert eine neue leere Instanz der <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>-Klasse unter Verwendung der anfänglichen Standardkapazität, des Standardlastfaktors und des angegebenen <ph id="ph2">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph>-Objekts.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IEqualityComparer)">
          <source>A hash table's capacity is used to calculate the optimal number of hash table buckets based on the load factor.</source>
          <target state="translated">Eine Hashtabelle Kapazität wird verwendet, um die optimale Anzahl der hashbuckets-Tabelle basierend auf den Lastfaktor berechnen.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IEqualityComparer)">
          <source>Capacity is automatically increased as required.</source>
          <target state="translated">Kapazität wird automatisch erhöht, nach Bedarf.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IEqualityComparer)">
          <source>The load factor is the maximum ratio of elements to buckets.</source>
          <target state="translated">Der Ladefaktor ist das maximale Verhältnis von Elementen zu Buckets.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IEqualityComparer)">
          <source>A smaller load factor means faster lookup at the cost of increased memory consumption.</source>
          <target state="translated">Ein kleinerer Ladefaktor bedeutet schnellere Suchvorgänge auf Kosten erhöhter Speicherbedarf.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IEqualityComparer)">
          <source>When the actual load factor reaches the specified load factor, the number of buckets is automatically increased to the smallest prime number that is larger than twice the current number of buckets.</source>
          <target state="translated">Wenn der tatsächliche Lastfaktor den angegebenen Lastfaktor erreicht, wird die Anzahl der Buckets automatisch auf die kleinste Anzahl von Primzahlen erhöht, die größer ist als zweimal die aktuelle Anzahl der Buckets.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IEqualityComparer)">
          <source>The <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> object includes both the hash code provider and the comparer.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> -Objekt umfasst sowohl den Hashcodeanbieter als auch den Comparer.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IEqualityComparer)">
          <source>If an <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> is used in the <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> constructor, the objects used as keys in the <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph> object are not required to override the <ph id="ph4">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph5">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> methods.</source>
          <target state="translated">Wenn ein <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> werden in der <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> Konstruktor, der die Objekte, die als Schlüssel in der <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph> Objekt sind nicht erforderlich, überschreiben die <ph id="ph4">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> und <ph id="ph5">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> Methoden.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IEqualityComparer)">
          <source>The hash code provider dispenses hash codes for keys in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
          <target state="translated">Die Hashcodeanbieter Hashcodes für Schlüssel in der <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IEqualityComparer)">
          <source>The default hash code provider is the key's implementation of <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Der Hashcode-Standardanbieter ist-Implementierung eines Schlüssels <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IEqualityComparer)">
          <source>The comparer determines whether two keys are equal.</source>
          <target state="translated">Der Vergleich bestimmt, ob zwei Schlüssel gleich sind.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IEqualityComparer)">
          <source>Every key in a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> must be unique.</source>
          <target state="translated">Jeder Schlüssel im einem <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> muss eindeutig sein.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IEqualityComparer)">
          <source>The default comparer is the key's implementation of <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Ist der Standardvergleich-Implementierung eines Schlüssels <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IEqualityComparer)">
          <source>The <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> enables scenarios such as doing lookups with case-insensitive strings.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> ermöglicht Szenarien wie etwa das Durchführen von Suchvorgängen mit der Groß-/ Kleinschreibung.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IEqualityComparer)">
          <source>This constructor is an O(1) operation.</source>
          <target state="translated">Dieser Konstruktor ist ein o(1)-Vorgang.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IEqualityComparer)">
          <source>The following code example creates hash tables using different <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.</source>
          <target state="translated">Das folgende Codebeispiel erstellt Hashtabellen mit verschiedenen <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> Konstruktoren und zeigt die Unterschiede im Verhalten von Hashtabellen, selbst wenn jeweils die gleichen Elemente enthält.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32)">
          <source>The approximate number of elements that the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> object can initially contain.</source>
          <target state="translated">Die ungefähre Anzahl von Elementen, die die <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> anfänglich enthalten kann.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32)">
          <source>Initializes a new, empty instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> class using the specified initial capacity, and the default load factor, hash code provider, and comparer.</source>
          <target state="translated">Initialisiert eine neue leere Instanz der <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>-Klasse unter Verwendung der angegebenen Anfangskapazität, des Standardlastfaktors, des Hashcode-Standardanbieters und des Standardcomparers.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32)">
          <source>Specifying the initial capacity eliminates the need to perform a number of resizing operations while adding elements to the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> object.</source>
          <target state="translated">Angeben der anfänglichen Kapazität entfällt die Notwendigkeit, eine Reihe von größenänderungsvorgänge beim Hinzufügen von Elementen zum Ausführen der <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> Objekt.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32)">
          <source>Capacity is automatically increased as required based on the load factor.</source>
          <target state="translated">Kapazität wird automatisch nach Bedarf erhöht werden basierend auf den Lastfaktor.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32)">
          <source>The load factor is the maximum ratio of elements to buckets.</source>
          <target state="translated">Der Ladefaktor ist das maximale Verhältnis von Elementen zu Buckets.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32)">
          <source>A smaller load factor means faster lookup at the cost of increased memory consumption.</source>
          <target state="translated">Ein kleinerer Ladefaktor bedeutet schnellere Suchvorgänge auf Kosten erhöhter Speicherbedarf.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32)">
          <source>When the actual load factor reaches the specified load factor, the number of buckets is automatically increased to the smallest prime number that is larger than twice the current number of buckets.</source>
          <target state="translated">Wenn der tatsächliche Lastfaktor den angegebenen Lastfaktor erreicht, wird die Anzahl der Buckets automatisch auf die kleinste Anzahl von Primzahlen erhöht, die größer ist als zweimal die aktuelle Anzahl der Buckets.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32)">
          <source>The hash code provider dispenses hash codes for keys in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
          <target state="translated">Die Hashcodeanbieter Hashcodes für Schlüssel in der <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32)">
          <source>The default hash code provider is the key's implementation of <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Der Hashcode-Standardanbieter ist-Implementierung eines Schlüssels <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32)">
          <source>The comparer determines whether two keys are equal.</source>
          <target state="translated">Der Vergleich bestimmt, ob zwei Schlüssel gleich sind.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32)">
          <source>Every key in a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> must be unique.</source>
          <target state="translated">Jeder Schlüssel im einem <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> muss eindeutig sein.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32)">
          <source>The default comparer is the key's implementation of <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Ist der Standardvergleich-Implementierung eines Schlüssels <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32)">
          <source>This constructor is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`capacity`</ph>.</source>
          <target state="translated">Dieser Konstruktor ist eine O (<ph id="ph1">`n`</ph>) Vorgang, wobei <ph id="ph2">`n`</ph> ist <ph id="ph3">`capacity`</ph>.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32)">
          <source>The following code example creates hash tables using different <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.</source>
          <target state="translated">Das folgende Codebeispiel erstellt Hashtabellen mit verschiedenen <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> Konstruktoren und zeigt die Unterschiede im Verhalten von Hashtabellen, selbst wenn jeweils die gleichen Elemente enthält.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="capacity" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="capacity" /&gt;</ph> ist kleiner als Null.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IDictionary" /&gt;</ph> object to copy to a new <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> object.</source>
          <target state="translated">Das <ph id="ph1">&lt;see cref="T:System.Collections.IDictionary" /&gt;</ph>-Objekt, das in ein neues <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>-Objekt kopiert werden soll.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph> object that defines the hash code provider and the comparer to use with the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph>, der sowohl den Hashcodeanbieter als auch den Comparer zur Verwendung mit der <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> definiert.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the default hash code provider and the default comparer.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph>, um den Hashcode-Standardanbieter und den Standardcomparer zu verwenden.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)">
          <source>The default hash code provider is each key's implementation of <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> and the default comparer is each key's implementation of <ph id="ph2">&lt;see cref="M:System.Object.Equals(System.Object)" /&gt;</ph>.</source>
          <target state="translated">Der Hashcode-Standardanbieter ist die Implementierung von <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> jedes Schlüssels, und der Standardcomparer ist die Implementierung von <ph id="ph2">&lt;see cref="M:System.Object.Equals(System.Object)" /&gt;</ph> jedes Schlüssels.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> class by copying the elements from the specified dictionary to a new <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> object.</source>
          <target state="translated">Initialisiert eine neue Instanz der <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>-Klasse durch Kopieren der Elemente aus dem angegebenen Wörterbuch in ein neues <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>-Objekt.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)">
          <source>The new <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> object has an initial capacity equal to the number of elements copied, and uses the default load factor and the specified <ph id="ph2">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph> object.</source>
          <target state="translated">Das neue <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>-Objekt besitzt eine Anfangskapazität, die mit der Anzahl der kopierten Elemente identisch ist, und verwendet den Standardlastfaktor sowie das angegebene <ph id="ph2">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph>-Objekt.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)">
          <source>The initial capacity is set to the number of elements in the source dictionary.</source>
          <target state="translated">Die anfängliche Kapazität wird auf die Anzahl der Elemente im Quellwörterbuch festgelegt.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)">
          <source>Capacity is automatically increased as required based on the load factor.</source>
          <target state="translated">Kapazität wird automatisch nach Bedarf erhöht werden basierend auf den Lastfaktor.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)">
          <source>The load factor is the maximum ratio of elements to buckets.</source>
          <target state="translated">Der Ladefaktor ist das maximale Verhältnis von Elementen zu Buckets.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)">
          <source>A smaller load factor means faster lookup at the cost of increased memory consumption.</source>
          <target state="translated">Ein kleinerer Ladefaktor bedeutet schnellere Suchvorgänge auf Kosten erhöhter Speicherbedarf.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)">
          <source>When the actual load factor reaches the specified load factor, the number of buckets is automatically increased to the smallest prime number that is larger than twice the current number of buckets.</source>
          <target state="translated">Wenn der tatsächliche Lastfaktor den angegebenen Lastfaktor erreicht, wird die Anzahl der Buckets automatisch auf die kleinste Anzahl von Primzahlen erhöht, die größer ist als zweimal die aktuelle Anzahl der Buckets.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)">
          <source>The <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> object includes both the hash code provider and the comparer.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> -Objekt umfasst sowohl den Hashcodeanbieter als auch den Comparer.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)">
          <source>If an <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> is used in the <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> constructor, the objects used as keys in the <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph> object are not required to override the <ph id="ph4">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph5">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> methods.</source>
          <target state="translated">Wenn ein <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> werden in der <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> Konstruktor, der die Objekte, die als Schlüssel in der <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph> Objekt sind nicht erforderlich, überschreiben die <ph id="ph4">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> und <ph id="ph5">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> Methoden.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)">
          <source>The hash code provider dispenses hash codes for keys in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
          <target state="translated">Die Hashcodeanbieter Hashcodes für Schlüssel in der <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)">
          <source>The default hash code provider is the key's implementation of <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Der Hashcode-Standardanbieter ist-Implementierung eines Schlüssels <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)">
          <source>The comparer determines whether two keys are equal.</source>
          <target state="translated">Der Vergleich bestimmt, ob zwei Schlüssel gleich sind.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)">
          <source>Every key in a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> must be unique.</source>
          <target state="translated">Jeder Schlüssel im einem <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> muss eindeutig sein.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)">
          <source>The default comparer is the key's implementation of <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Ist der Standardvergleich-Implementierung eines Schlüssels <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)">
          <source>The <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> enables scenarios such as doing lookups with case-insensitive strings.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> ermöglicht Szenarien wie etwa das Durchführen von Suchvorgängen mit der Groß-/ Kleinschreibung.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)">
          <source>The elements of the new <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> are sorted in the same order in which the enumerator iterates through the <ph id="ph2">&lt;xref:System.Collections.IDictionary&gt;</ph> object.</source>
          <target state="translated">Die Elemente der neuen <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> sortiert sind, in der gleichen Reihenfolge, in dem sich der Enumerator durchläuft, die <ph id="ph2">&lt;xref:System.Collections.IDictionary&gt;</ph> Objekt.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)">
          <source>This constructor is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements in the <ph id="ph3">`d`</ph> parameter.</source>
          <target state="translated">Dieser Konstruktor ist eine O (<ph id="ph1">`n`</ph>)-Vorgang, in dem <ph id="ph2">`n`</ph> ist die Anzahl der Elemente in der <ph id="ph3">`d`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)">
          <source>The following code example creates hash tables using different <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.</source>
          <target state="translated">Das folgende Codebeispiel erstellt Hashtabellen mit verschiedenen <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> Konstruktoren und zeigt die Unterschiede im Verhalten von Hashtabellen, selbst wenn jeweils die gleichen Elemente enthält.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)">
          <source><ph id="ph1">&lt;paramref name="d" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="d" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IDictionary" /&gt;</ph> object to copy to a new <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> object.</source>
          <target state="translated">Das <ph id="ph1">&lt;see cref="T:System.Collections.IDictionary" /&gt;</ph>-Objekt, das in ein neues <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>-Objekt kopiert werden soll.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)">
          <source>A number in the range from 0.1 through 1.0 that is multiplied by the default value which provides the best performance.</source>
          <target state="translated">Eine Zahl im Bereich 0,1 bis 1,0, die mit dem Standardwert für die optimale Leistung multipliziert wird.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)">
          <source>The result is the maximum ratio of elements to buckets.</source>
          <target state="translated">Das Ergebnis ist das maximale Verhältnis von Elementen zu Buckets.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> class by copying the elements from the specified dictionary to the new <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> object.</source>
          <target state="translated">Initialisiert eine neue Instanz der <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>-Klasse durch Kopieren der Elemente aus dem angegebenen Wörterbuch in das neue <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>-Objekt.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)">
          <source>The new <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> object has an initial capacity equal to the number of elements copied, and uses the specified load factor, and the default hash code provider and comparer.</source>
          <target state="translated">Das neue <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>-Objekt besitzt eine Anfangskapazität, die mit der Anzahl der kopierten Elemente identisch ist, und verwendet den angegebenen Lastfaktor sowie den Hashcode-Standardanbieter und den Standardcomparer.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)">
          <source>The initial capacity is set to the number of elements in the source dictionary.</source>
          <target state="translated">Die anfängliche Kapazität wird auf die Anzahl der Elemente im Quellwörterbuch festgelegt.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)">
          <source>Capacity is automatically increased as required based on the load factor.</source>
          <target state="translated">Kapazität wird automatisch nach Bedarf erhöht werden basierend auf den Lastfaktor.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)">
          <source>The load factor is the maximum ratio of elements to buckets.</source>
          <target state="translated">Der Ladefaktor ist das maximale Verhältnis von Elementen zu Buckets.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)">
          <source>A smaller load factor means faster lookup at the cost of increased memory consumption.</source>
          <target state="translated">Ein kleinerer Ladefaktor bedeutet schnellere Suchvorgänge auf Kosten erhöhter Speicherbedarf.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)">
          <source>A load factor of 1.0 is the best balance between speed and size.</source>
          <target state="translated">Ein Ladefaktor 1.0 ist der beste Kompromiss zwischen Geschwindigkeit und Größe.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)">
          <source>When the actual load factor reaches the specified load factor, the number of buckets is automatically increased to the smallest prime number that is larger than twice the current number of buckets.</source>
          <target state="translated">Wenn der tatsächliche Lastfaktor den angegebenen Lastfaktor erreicht, wird die Anzahl der Buckets automatisch auf die kleinste Anzahl von Primzahlen erhöht, die größer ist als zweimal die aktuelle Anzahl der Buckets.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)">
          <source>The hash code provider dispenses hash codes for keys in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> object.</source>
          <target state="translated">Die Hashcodeanbieter Hashcodes für Schlüssel in der <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> Objekt.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)">
          <source>The default hash code provider is the key's implementation of <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Der Hashcode-Standardanbieter ist-Implementierung eines Schlüssels <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)">
          <source>The comparer determines whether two keys are equal.</source>
          <target state="translated">Der Vergleich bestimmt, ob zwei Schlüssel gleich sind.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)">
          <source>Every key in a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> must be unique.</source>
          <target state="translated">Jeder Schlüssel im einem <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> muss eindeutig sein.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)">
          <source>The default comparer is the key's implementation of <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Ist der Standardvergleich-Implementierung eines Schlüssels <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)">
          <source>The elements of the new <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> are sorted in the same order in which the enumerator iterates through the <ph id="ph2">&lt;xref:System.Collections.IDictionary&gt;</ph> object.</source>
          <target state="translated">Die Elemente der neuen <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> sortiert sind, in der gleichen Reihenfolge, in dem sich der Enumerator durchläuft, die <ph id="ph2">&lt;xref:System.Collections.IDictionary&gt;</ph> Objekt.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)">
          <source>This constructor is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements in the <ph id="ph3">`d`</ph> parameter.</source>
          <target state="translated">Dieser Konstruktor ist eine O (<ph id="ph1">`n`</ph>)-Vorgang, in dem <ph id="ph2">`n`</ph> ist die Anzahl der Elemente in der <ph id="ph3">`d`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)">
          <source>The following code example creates hash tables using different <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.</source>
          <target state="translated">Das folgende Codebeispiel erstellt Hashtabellen mit verschiedenen <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> Konstruktoren und zeigt die Unterschiede im Verhalten von Hashtabellen, selbst wenn jeweils die gleichen Elemente enthält.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)">
          <source><ph id="ph1">&lt;paramref name="d" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="d" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)">
          <source><ph id="ph1">&lt;paramref name="loadFactor" /&gt;</ph> is less than 0.1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="loadFactor" /&gt;</ph> ist kleiner als 0,1.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)">
          <source><ph id="ph1">&lt;paramref name="loadFactor" /&gt;</ph> is greater than 1.0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="loadFactor" /&gt;</ph> ist größer als 1,0.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IHashCodeProvider" /&gt;</ph> object that supplies the hash codes for all keys in the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> object.</source>
          <target state="translated">Das <ph id="ph1">&lt;see cref="T:System.Collections.IHashCodeProvider" /&gt;</ph>-Objekt, das die Hashcodes für alle Schlüssel in der <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> bereitstellt.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the default hash code provider, which is each key's implementation of <ph id="ph2">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph>, wenn der Hashcode-Standardanbieter verwendet werden soll. Dies ist die jeweilige <ph id="ph2">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph>-Implementierung eines Schlüssels.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> object to use to determine whether two keys are equal.</source>
          <target state="translated">Das <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph>-Objekt, mit dem ermittelt wird, ob zwei Schlüssel gleich sind.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the default comparer, which is each key's implementation of <ph id="ph2">&lt;see cref="M:System.Object.Equals(System.Object)" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph>, wenn der Standardcomparer verwendet werden soll. Dies ist die jeweilige <ph id="ph2">&lt;see cref="M:System.Object.Equals(System.Object)" /&gt;</ph>-Implementierung eines Schlüssels.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>Initializes a new, empty instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> class using the default initial capacity and load factor, and the specified hash code provider and comparer.</source>
          <target state="translated">Initialisiert eine neue leere Instanz der <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>-Klasse unter Verwendung der anfänglichen Standardkapazität, des Standardlastfaktors, des angegebenen Hashcodeanbieters und des angegebenen Comparers.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>A hash table's capacity is used to calculate the optimal number of hash table buckets based on the load factor.</source>
          <target state="translated">Eine Hashtabelle Kapazität wird verwendet, um die optimale Anzahl der hashbuckets-Tabelle basierend auf den Lastfaktor berechnen.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>Capacity is automatically increased as required.</source>
          <target state="translated">Kapazität wird automatisch erhöht, nach Bedarf.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The load factor is the maximum ratio of elements to buckets.</source>
          <target state="translated">Der Ladefaktor ist das maximale Verhältnis von Elementen zu Buckets.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>A smaller load factor means faster lookup at the cost of increased memory consumption.</source>
          <target state="translated">Ein kleinerer Ladefaktor bedeutet schnellere Suchvorgänge auf Kosten erhöhter Speicherbedarf.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>When the actual load factor reaches the specified load factor, the number of buckets is automatically increased to the smallest prime number that is larger than twice the current number of buckets.</source>
          <target state="translated">Wenn der tatsächliche Lastfaktor den angegebenen Lastfaktor erreicht, wird die Anzahl der Buckets automatisch auf die kleinste Anzahl von Primzahlen erhöht, die größer ist als zweimal die aktuelle Anzahl der Buckets.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The hash code provider dispenses hash codes for keys in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> object.</source>
          <target state="translated">Die Hashcodeanbieter Hashcodes für Schlüssel in der <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> Objekt.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The default hash code provider is the key's implementation of <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Der Hashcode-Standardanbieter ist-Implementierung eines Schlüssels <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The comparer determines whether two keys are equal.</source>
          <target state="translated">Der Vergleich bestimmt, ob zwei Schlüssel gleich sind.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>Every key in a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> must be unique.</source>
          <target state="translated">Jeder Schlüssel im einem <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> muss eindeutig sein.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The default comparer is the key's implementation of <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Ist der Standardvergleich-Implementierung eines Schlüssels <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The custom hash code provider and the custom comparer enable scenarios such as doing lookups with case-insensitive strings.</source>
          <target state="translated">Benutzerdefinierte Hashcodeanbieter und Comparer ermöglichen Szenarien wie etwa das Durchführen von Suchvorgängen mit der Groß-/ Kleinschreibung.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>This constructor is an O(1) operation.</source>
          <target state="translated">Dieser Konstruktor ist ein o(1)-Vorgang.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The following code example creates hash tables using different <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.</source>
          <target state="translated">Das folgende Codebeispiel erstellt Hashtabellen mit verschiedenen <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> Konstruktoren und zeigt die Unterschiede im Verhalten von Hashtabellen, selbst wenn jeweils die gleichen Elemente enthält.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IEqualityComparer)">
          <source>The approximate number of elements that the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> object can initially contain.</source>
          <target state="translated">Die ungefähre Anzahl von Elementen, die die <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> anfänglich enthalten kann.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IEqualityComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph> object that defines the hash code provider and the comparer to use with the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph>, der sowohl den Hashcodeanbieter als auch den Comparer zur Verwendung mit der <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> definiert.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IEqualityComparer)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IEqualityComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the default hash code provider and the default comparer.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph>, um den Hashcode-Standardanbieter und den Standardcomparer zu verwenden.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IEqualityComparer)">
          <source>The default hash code provider is each key's implementation of <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> and the default comparer is each key's implementation of <ph id="ph2">&lt;see cref="M:System.Object.Equals(System.Object)" /&gt;</ph>.</source>
          <target state="translated">Der Hashcode-Standardanbieter ist die Implementierung von <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> jedes Schlüssels, und der Standardcomparer ist die Implementierung von <ph id="ph2">&lt;see cref="M:System.Object.Equals(System.Object)" /&gt;</ph> jedes Schlüssels.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IEqualityComparer)">
          <source>Initializes a new, empty instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> class using the specified initial capacity and <ph id="ph2">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph>, and the default load factor.</source>
          <target state="translated">Initialisiert eine neue leere Instanz der <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>-Klasse unter Verwendung der angegebenen Anfangskapazität und des angegebenen <ph id="ph2">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph> sowie des Standardlastfaktors.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IEqualityComparer)">
          <source>Specifying the initial capacity eliminates the need to perform a number of resizing operations while adding elements to the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> object.</source>
          <target state="translated">Angeben der anfänglichen Kapazität entfällt die Notwendigkeit, eine Reihe von größenänderungsvorgänge beim Hinzufügen von Elementen zum Ausführen der <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> Objekt.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IEqualityComparer)">
          <source>Capacity is automatically increased as required based on the load factor.</source>
          <target state="translated">Kapazität wird automatisch nach Bedarf erhöht werden basierend auf den Lastfaktor.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IEqualityComparer)">
          <source>The load factor is the maximum ratio of elements to buckets.</source>
          <target state="translated">Der Ladefaktor ist das maximale Verhältnis von Elementen zu Buckets.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IEqualityComparer)">
          <source>A smaller load factor means faster lookup at the cost of increased memory consumption.</source>
          <target state="translated">Ein kleinerer Ladefaktor bedeutet schnellere Suchvorgänge auf Kosten erhöhter Speicherbedarf.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IEqualityComparer)">
          <source>When the actual load factor reaches the specified load factor, the number of buckets is automatically increased to the smallest prime number that is larger than twice the current number of buckets.</source>
          <target state="translated">Wenn der tatsächliche Lastfaktor den angegebenen Lastfaktor erreicht, wird die Anzahl der Buckets automatisch auf die kleinste Anzahl von Primzahlen erhöht, die größer ist als zweimal die aktuelle Anzahl der Buckets.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IEqualityComparer)">
          <source>The <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> object includes both the hash code provider and the comparer.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> -Objekt umfasst sowohl den Hashcodeanbieter als auch den Comparer.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IEqualityComparer)">
          <source>If an <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> is used in the <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> constructor, the objects used as keys in the <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph> are not required to override the <ph id="ph4">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph5">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> methods.</source>
          <target state="translated">Wenn ein <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> werden in der <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> Konstruktor, der die Objekte, die als Schlüssel in der <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph> ist nicht erforderlich, außer Kraft setzen die <ph id="ph4">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> und <ph id="ph5">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> Methoden.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IEqualityComparer)">
          <source>The hash code provider dispenses hash codes for keys in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
          <target state="translated">Die Hashcodeanbieter Hashcodes für Schlüssel in der <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IEqualityComparer)">
          <source>The default hash code provider is the key's implementation of <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Der Hashcode-Standardanbieter ist-Implementierung eines Schlüssels <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IEqualityComparer)">
          <source>The comparer determines whether two keys are equal.</source>
          <target state="translated">Der Vergleich bestimmt, ob zwei Schlüssel gleich sind.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IEqualityComparer)">
          <source>Every key in a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> must be unique.</source>
          <target state="translated">Jeder Schlüssel im einem <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> muss eindeutig sein.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IEqualityComparer)">
          <source>The default comparer is the key's implementation of <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Ist der Standardvergleich-Implementierung eines Schlüssels <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IEqualityComparer)">
          <source>The <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> enables scenarios such as doing lookups with case-insensitive strings.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> ermöglicht Szenarien wie etwa das Durchführen von Suchvorgängen mit der Groß-/ Kleinschreibung.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IEqualityComparer)">
          <source>This constructor is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">`capacity`</ph> parameter.</source>
          <target state="translated">Dieser Konstruktor ist eine O (<ph id="ph1">`n`</ph>) Vorgang, wobei <ph id="ph2">`n`</ph> ist die <ph id="ph3">`capacity`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IEqualityComparer)">
          <source>The following code example creates hash tables using different <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.</source>
          <target state="translated">Das folgende Codebeispiel erstellt Hashtabellen mit verschiedenen <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> Konstruktoren und zeigt die Unterschiede im Verhalten von Hashtabellen, selbst wenn jeweils die gleichen Elemente enthält.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IEqualityComparer)">
          <source><ph id="ph1">&lt;paramref name="capacity" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="capacity" /&gt;</ph> ist kleiner als Null.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single)">
          <source>The approximate number of elements that the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> object can initially contain.</source>
          <target state="translated">Die ungefähre Anzahl von Elementen, die die <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> anfänglich enthalten kann.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single)">
          <source>A number in the range from 0.1 through 1.0 that is multiplied by the default value which provides the best performance.</source>
          <target state="translated">Eine Zahl im Bereich 0,1 bis 1,0, die mit dem Standardwert für die optimale Leistung multipliziert wird.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single)">
          <source>The result is the maximum ratio of elements to buckets.</source>
          <target state="translated">Das Ergebnis ist das maximale Verhältnis von Elementen zu Buckets.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single)">
          <source>Initializes a new, empty instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> class using the specified initial capacity and load factor, and the default hash code provider and comparer.</source>
          <target state="translated">Initialisiert eine neue leere Instanz der <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>-Klasse unter Verwendung der angegebenen Anfangskapazität und des Lastfaktors sowie des Hashcode-Standardanbieter und des angegebenen Comparers.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single)">
          <source>Specifying the initial capacity eliminates the need to perform a number of resizing operations while adding elements to the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> object.</source>
          <target state="translated">Angeben der anfänglichen Kapazität entfällt die Notwendigkeit, eine Reihe von größenänderungsvorgänge beim Hinzufügen von Elementen zum Ausführen der <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> Objekt.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single)">
          <source>Capacity is automatically increased as required based on the load factor.</source>
          <target state="translated">Kapazität wird automatisch nach Bedarf erhöht werden basierend auf den Lastfaktor.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single)">
          <source>The load factor is the maximum ratio of elements to buckets.</source>
          <target state="translated">Der Ladefaktor ist das maximale Verhältnis von Elementen zu Buckets.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single)">
          <source>A smaller load factor means faster lookup at the cost of increased memory consumption.</source>
          <target state="translated">Ein kleinerer Ladefaktor bedeutet schnellere Suchvorgänge auf Kosten erhöhter Speicherbedarf.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single)">
          <source>A load factor of 1.0 is the best balance between speed and size.</source>
          <target state="translated">Ein Ladefaktor 1.0 ist der beste Kompromiss zwischen Geschwindigkeit und Größe.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single)">
          <source>When the actual load factor reaches the specified load factor, the number of buckets is automatically increased to the smallest prime number that is larger than twice the current number of buckets.</source>
          <target state="translated">Wenn der tatsächliche Lastfaktor den angegebenen Lastfaktor erreicht, wird die Anzahl der Buckets automatisch auf die kleinste Anzahl von Primzahlen erhöht, die größer ist als zweimal die aktuelle Anzahl der Buckets.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single)">
          <source>The hash code provider dispenses hash codes for keys in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
          <target state="translated">Die Hashcodeanbieter Hashcodes für Schlüssel in der <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single)">
          <source>The default hash code provider is the key's implementation of <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Der Hashcode-Standardanbieter ist-Implementierung eines Schlüssels <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single)">
          <source>The comparer determines whether two keys are equal.</source>
          <target state="translated">Der Vergleich bestimmt, ob zwei Schlüssel gleich sind.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single)">
          <source>Every key in a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> must be unique.</source>
          <target state="translated">Jeder Schlüssel im einem <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> muss eindeutig sein.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single)">
          <source>The default comparer is the key's implementation of <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Ist der Standardvergleich-Implementierung eines Schlüssels <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single)">
          <source>This constructor is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">`capacity`</ph> parameter.</source>
          <target state="translated">Dieser Konstruktor ist eine O (<ph id="ph1">`n`</ph>) Vorgang, wobei <ph id="ph2">`n`</ph> ist die <ph id="ph3">`capacity`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single)">
          <source>The following code example creates hash tables using different <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.</source>
          <target state="translated">Das folgende Codebeispiel erstellt Hashtabellen mit verschiedenen <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> Konstruktoren und zeigt die Unterschiede im Verhalten von Hashtabellen, selbst wenn jeweils die gleichen Elemente enthält.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single)">
          <source><ph id="ph1">&lt;paramref name="capacity" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="capacity" /&gt;</ph> ist kleiner als Null.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single)">
          <source><ph id="ph1">&lt;paramref name="loadFactor" /&gt;</ph> is less than 0.1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="loadFactor" /&gt;</ph> ist kleiner als 0,1.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single)">
          <source><ph id="ph1">&lt;paramref name="loadFactor" /&gt;</ph> is greater than 1.0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="loadFactor" /&gt;</ph> ist größer als 1,0.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single)">
          <source><ph id="ph1">&lt;paramref name="capacity" /&gt;</ph> is causing an overflow.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="capacity" /&gt;</ph> verursacht einen Überlauf.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph> object containing the information required to serialize the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> object.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph>-Objekt mit den zum Serialisieren des <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>-Objekts erforderlichen Informationen.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.StreamingContext" /&gt;</ph> object containing the source and destination of the serialized stream associated with the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.StreamingContext" /&gt;</ph>-Objekt mit der Quelle und dem Ziel des entsprechenden serialisierten Streams für <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>Initializes a new, empty instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> class that is serializable using the specified <ph id="ph2">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph> and <ph id="ph3">&lt;see cref="T:System.Runtime.Serialization.StreamingContext" /&gt;</ph> objects.</source>
          <target state="translated">Initialisiert eine neue leere Instanz der <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>-Klasse, die serialisierbar ist, wobei die angegebenen <ph id="ph2">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph>-Objekte und die angegebenen <ph id="ph3">&lt;see cref="T:System.Runtime.Serialization.StreamingContext" /&gt;</ph>-Objekte verwendet werden.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>A hash table's capacity is used to calculate the optimal number of hash table buckets based on the load factor.</source>
          <target state="translated">Eine Hashtabelle Kapazität wird verwendet, um die optimale Anzahl der hashbuckets-Tabelle basierend auf den Lastfaktor berechnen.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>Capacity is automatically increased as required.</source>
          <target state="translated">Kapazität wird automatisch erhöht, nach Bedarf.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The load factor is the maximum ratio of elements to buckets.</source>
          <target state="translated">Der Ladefaktor ist das maximale Verhältnis von Elementen zu Buckets.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>A smaller load factor means faster lookup at the cost of increased memory consumption.</source>
          <target state="translated">Ein kleinerer Ladefaktor bedeutet schnellere Suchvorgänge auf Kosten erhöhter Speicherbedarf.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>When the actual load factor reaches the specified load factor, the number of buckets is automatically increased to the smallest prime number that is larger than twice the current number of buckets.</source>
          <target state="translated">Wenn der tatsächliche Lastfaktor den angegebenen Lastfaktor erreicht, wird die Anzahl der Buckets automatisch auf die kleinste Anzahl von Primzahlen erhöht, die größer ist als zweimal die aktuelle Anzahl der Buckets.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The hash code provider dispenses hash codes for keys in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> object.</source>
          <target state="translated">Die Hashcodeanbieter Hashcodes für Schlüssel in der <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> Objekt.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The default hash code provider is the key's implementation of <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Der Hashcode-Standardanbieter ist-Implementierung eines Schlüssels <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The comparer determines whether two keys are equal.</source>
          <target state="translated">Der Vergleich bestimmt, ob zwei Schlüssel gleich sind.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>Every key in a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> must be unique.</source>
          <target state="translated">Jeder Schlüssel im einem <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> muss eindeutig sein.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The default comparer is the key's implementation of <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Ist der Standardvergleich-Implementierung eines Schlüssels <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>This constructor is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.Hashtable.Count%2A&gt;</ph>.</source>
          <target state="translated">Dieser Konstruktor ist eine O (<ph id="ph1">`n`</ph>) Vorgang, wobei <ph id="ph2">`n`</ph> ist <ph id="ph3">&lt;xref:System.Collections.Hashtable.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>Because serializing and deserializing an enumerator for a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> can cause the elements to become reordered, it is not possible to continue enumeration without calling the <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> method.</source>
          <target state="translated">Da das Serialisieren und Deserialisieren einen Enumerator für eine <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> kann dazu führen, dass die Elemente, die neu angeordnet werden, es ist nicht möglich, Enumeration ohne Aufruf zu fortfahren die <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source><ph id="ph1">&lt;paramref name="info" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="info" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IDictionary" /&gt;</ph> object to copy to a new <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> object.</source>
          <target state="translated">Das <ph id="ph1">&lt;see cref="T:System.Collections.IDictionary" /&gt;</ph>-Objekt, das in ein neues <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>-Objekt kopiert werden soll.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IHashCodeProvider" /&gt;</ph> object that supplies the hash codes for all keys in the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated">Das <ph id="ph1">&lt;see cref="T:System.Collections.IHashCodeProvider" /&gt;</ph>-Objekt, das die Hashcodes für alle Schlüssel in der <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> bereitstellt.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the default hash code provider, which is each key's implementation of <ph id="ph2">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph>, wenn der Hashcode-Standardanbieter verwendet werden soll. Dies ist die jeweilige <ph id="ph2">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph>-Implementierung eines Schlüssels.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> object to use to determine whether two keys are equal.</source>
          <target state="translated">Das <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph>-Objekt, mit dem ermittelt wird, ob zwei Schlüssel gleich sind.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the default comparer, which is each key's implementation of <ph id="ph2">&lt;see cref="M:System.Object.Equals(System.Object)" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph>, wenn der Standardcomparer verwendet werden soll. Dies ist die jeweilige <ph id="ph2">&lt;see cref="M:System.Object.Equals(System.Object)" /&gt;</ph>-Implementierung eines Schlüssels.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> class by copying the elements from the specified dictionary to the new <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> object.</source>
          <target state="translated">Initialisiert eine neue Instanz der <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>-Klasse durch Kopieren der Elemente aus dem angegebenen Wörterbuch in das neue <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>-Objekt.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The new <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> object has an initial capacity equal to the number of elements copied, and uses the default load factor, and the specified hash code provider and comparer.</source>
          <target state="translated">Das neue <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>-Objekt besitzt eine Anfangskapazität, die mit der Anzahl der kopierten Elemente identisch ist, und verwendet den Standardlastfaktor sowie den angegebenen Hashcodeanbieter und den angegebenen Comparer.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>This API is obsolete.</source>
          <target state="translated">Diese API ist veraltet.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>For an alternative, see <ph id="ph1">&lt;see cref="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)" /&gt;</ph>.</source>
          <target state="translated">Eine Alternative finden Sie unter <ph id="ph1">&lt;see cref="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The initial capacity is set to the number of elements in the source dictionary.</source>
          <target state="translated">Die anfängliche Kapazität wird auf die Anzahl der Elemente im Quellwörterbuch festgelegt.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>Capacity is automatically increased as required based on the load factor.</source>
          <target state="translated">Kapazität wird automatisch nach Bedarf erhöht werden basierend auf den Lastfaktor.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The load factor is the maximum ratio of elements to buckets.</source>
          <target state="translated">Der Ladefaktor ist das maximale Verhältnis von Elementen zu Buckets.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>A smaller load factor means faster lookup at the cost of increased memory consumption.</source>
          <target state="translated">Ein kleinerer Ladefaktor bedeutet schnellere Suchvorgänge auf Kosten erhöhter Speicherbedarf.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>When the actual load factor reaches the specified load factor, the number of buckets is automatically increased to the smallest prime number that is larger than twice the current number of buckets.</source>
          <target state="translated">Wenn der tatsächliche Lastfaktor den angegebenen Lastfaktor erreicht, wird die Anzahl der Buckets automatisch auf die kleinste Anzahl von Primzahlen erhöht, die größer ist als zweimal die aktuelle Anzahl der Buckets.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The hash code provider dispenses hash codes for keys in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> object.</source>
          <target state="translated">Die Hashcodeanbieter Hashcodes für Schlüssel in der <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> Objekt.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The default hash code provider is the key's implementation of <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Der Hashcode-Standardanbieter ist-Implementierung eines Schlüssels <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The comparer determines whether two keys are equal.</source>
          <target state="translated">Der Vergleich bestimmt, ob zwei Schlüssel gleich sind.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>Every key in a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> must be unique.</source>
          <target state="translated">Jeder Schlüssel im einem <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> muss eindeutig sein.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The default comparer is the key's implementation of <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Ist der Standardvergleich-Implementierung eines Schlüssels <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The custom hash code provider and the custom comparer enable scenarios such as doing lookups with case-insensitive strings.</source>
          <target state="translated">Benutzerdefinierte Hashcodeanbieter und Comparer ermöglichen Szenarien wie etwa das Durchführen von Suchvorgängen mit der Groß-/ Kleinschreibung.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The elements of the new <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> are sorted in the same order in which the enumerator iterates through the <ph id="ph2">&lt;xref:System.Collections.IDictionary&gt;</ph> object.</source>
          <target state="translated">Die Elemente der neuen <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> sortiert sind, in der gleichen Reihenfolge, in dem sich der Enumerator durchläuft, die <ph id="ph2">&lt;xref:System.Collections.IDictionary&gt;</ph> Objekt.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>This constructor is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements in the <ph id="ph3">`d`</ph> parameter.</source>
          <target state="translated">Dieser Konstruktor ist eine O (<ph id="ph1">`n`</ph>)-Vorgang, in dem <ph id="ph2">`n`</ph> ist die Anzahl der Elemente in der <ph id="ph3">`d`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The following code example creates hash tables using different <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.</source>
          <target state="translated">Das folgende Codebeispiel erstellt Hashtabellen mit verschiedenen <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> Konstruktoren und zeigt die Unterschiede im Verhalten von Hashtabellen, selbst wenn jeweils die gleichen Elemente enthält.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="d" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="d" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IDictionary" /&gt;</ph> object to copy to a new <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> object.</source>
          <target state="translated">Das <ph id="ph1">&lt;see cref="T:System.Collections.IDictionary" /&gt;</ph>-Objekt, das in ein neues <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>-Objekt kopiert werden soll.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)">
          <source>A number in the range from 0.1 through 1.0 that is multiplied by the default value which provides the best performance.</source>
          <target state="translated">Eine Zahl im Bereich 0,1 bis 1,0, die mit dem Standardwert für die optimale Leistung multipliziert wird.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)">
          <source>The result is the maximum ratio of elements to buckets.</source>
          <target state="translated">Das Ergebnis ist das maximale Verhältnis von Elementen zu Buckets.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph> object that defines the hash code provider and the comparer to use with the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph>, der sowohl den Hashcodeanbieter als auch den Comparer zur Verwendung mit der <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> definiert.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the default hash code provider and the default comparer.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph>, um den Hashcode-Standardanbieter und den Standardcomparer zu verwenden.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)">
          <source>The default hash code provider is each key's implementation of <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> and the default comparer is each key's implementation of <ph id="ph2">&lt;see cref="M:System.Object.Equals(System.Object)" /&gt;</ph>.</source>
          <target state="translated">Der Hashcode-Standardanbieter ist die Implementierung von <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> jedes Schlüssels, und der Standardcomparer ist die Implementierung von <ph id="ph2">&lt;see cref="M:System.Object.Equals(System.Object)" /&gt;</ph> jedes Schlüssels.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> class by copying the elements from the specified dictionary to the new <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> object.</source>
          <target state="translated">Initialisiert eine neue Instanz der <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>-Klasse durch Kopieren der Elemente aus dem angegebenen Wörterbuch in das neue <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>-Objekt.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)">
          <source>The new <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> object has an initial capacity equal to the number of elements copied, and uses the specified load factor and <ph id="ph2">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph> object.</source>
          <target state="translated">Das neue <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>-Objekt besitzt eine Anfangskapazität, die mit der Anzahl der kopierten Elemente identisch ist, und verwendet den angegebenen Lastfaktor und das angegebene <ph id="ph2">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph>-Objekt.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)">
          <source>The initial capacity is set to the number of elements in the source dictionary.</source>
          <target state="translated">Die anfängliche Kapazität wird auf die Anzahl der Elemente im Quellwörterbuch festgelegt.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)">
          <source>Capacity is automatically increased as required based on the load factor.</source>
          <target state="translated">Kapazität wird automatisch nach Bedarf erhöht werden basierend auf den Lastfaktor.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)">
          <source>The load factor is the maximum ratio of elements to buckets.</source>
          <target state="translated">Der Ladefaktor ist das maximale Verhältnis von Elementen zu Buckets.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)">
          <source>A smaller load factor means faster lookup at the cost of increased memory consumption.</source>
          <target state="translated">Ein kleinerer Ladefaktor bedeutet schnellere Suchvorgänge auf Kosten erhöhter Speicherbedarf.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)">
          <source>A load factor of 1.0 is the best balance between speed and size.</source>
          <target state="translated">Ein Ladefaktor 1.0 ist der beste Kompromiss zwischen Geschwindigkeit und Größe.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)">
          <source>When the actual load factor reaches the specified load factor, the number of buckets is automatically increased to the smallest prime number that is larger than twice the current number of buckets.</source>
          <target state="translated">Wenn der tatsächliche Lastfaktor den angegebenen Lastfaktor erreicht, wird die Anzahl der Buckets automatisch auf die kleinste Anzahl von Primzahlen erhöht, die größer ist als zweimal die aktuelle Anzahl der Buckets.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)">
          <source>The <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> object includes both the hash code provider and the comparer.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> -Objekt umfasst sowohl den Hashcodeanbieter als auch den Comparer.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)">
          <source>If an <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> is used in the <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> constructor, the objects used as keys in the <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph> object are not required to override the <ph id="ph4">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph5">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> methods.</source>
          <target state="translated">Wenn ein <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> werden in der <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> Konstruktor, der die Objekte, die als Schlüssel in der <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph> Objekt sind nicht erforderlich, überschreiben die <ph id="ph4">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> und <ph id="ph5">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> Methoden.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)">
          <source>The hash code provider dispenses hash codes for keys in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
          <target state="translated">Die Hashcodeanbieter Hashcodes für Schlüssel in der <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)">
          <source>The default hash code provider is the key's implementation of <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Der Hashcode-Standardanbieter ist-Implementierung eines Schlüssels <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)">
          <source>The comparer determines whether two keys are equal.</source>
          <target state="translated">Der Vergleich bestimmt, ob zwei Schlüssel gleich sind.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)">
          <source>Every key in a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> must be unique.</source>
          <target state="translated">Jeder Schlüssel im einem <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> muss eindeutig sein.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)">
          <source>The default comparer is the key's implementation of <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Ist der Standardvergleich-Implementierung eines Schlüssels <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)">
          <source>The <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> enables scenarios such as doing lookups with case-insensitive strings.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> ermöglicht Szenarien wie etwa das Durchführen von Suchvorgängen mit der Groß-/ Kleinschreibung.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)">
          <source>The elements of the new <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> are sorted in the same order in which the enumerator iterates through the <ph id="ph2">&lt;xref:System.Collections.IDictionary&gt;</ph> object.</source>
          <target state="translated">Die Elemente der neuen <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> sortiert sind, in der gleichen Reihenfolge, in dem sich der Enumerator durchläuft, die <ph id="ph2">&lt;xref:System.Collections.IDictionary&gt;</ph> Objekt.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)">
          <source>This constructor is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements in the <ph id="ph3">`d`</ph> parameter.</source>
          <target state="translated">Dieser Konstruktor ist eine O (<ph id="ph1">`n`</ph>)-Vorgang, in dem <ph id="ph2">`n`</ph> ist die Anzahl der Elemente in der <ph id="ph3">`d`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)">
          <source>The following code example creates hash tables using different <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.</source>
          <target state="translated">Das folgende Codebeispiel erstellt Hashtabellen mit verschiedenen <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> Konstruktoren und zeigt die Unterschiede im Verhalten von Hashtabellen, selbst wenn jeweils die gleichen Elemente enthält.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)">
          <source><ph id="ph1">&lt;paramref name="d" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="d" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)">
          <source><ph id="ph1">&lt;paramref name="loadFactor" /&gt;</ph> is less than 0.1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="loadFactor" /&gt;</ph> ist kleiner als 0,1.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)">
          <source><ph id="ph1">&lt;paramref name="loadFactor" /&gt;</ph> is greater than 1.0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="loadFactor" /&gt;</ph> ist größer als 1,0.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The approximate number of elements that the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> object can initially contain.</source>
          <target state="translated">Die ungefähre Anzahl von Elementen, die die <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> anfänglich enthalten kann.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IHashCodeProvider" /&gt;</ph> object that supplies the hash codes for all keys in the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated">Das <ph id="ph1">&lt;see cref="T:System.Collections.IHashCodeProvider" /&gt;</ph>-Objekt, das die Hashcodes für alle Schlüssel in der <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> bereitstellt.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the default hash code provider, which is each key's implementation of <ph id="ph2">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph>, wenn der Hashcode-Standardanbieter verwendet werden soll. Dies ist die jeweilige <ph id="ph2">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph>-Implementierung eines Schlüssels.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> object to use to determine whether two keys are equal.</source>
          <target state="translated">Das <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph>-Objekt, mit dem ermittelt wird, ob zwei Schlüssel gleich sind.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the default comparer, which is each key's implementation of <ph id="ph2">&lt;see cref="M:System.Object.Equals(System.Object)" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph>, wenn der Standardcomparer verwendet werden soll. Dies ist die jeweilige <ph id="ph2">&lt;see cref="M:System.Object.Equals(System.Object)" /&gt;</ph>-Implementierung eines Schlüssels.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>Initializes a new, empty instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> class using the specified initial capacity, hash code provider, comparer, and the default load factor.</source>
          <target state="translated">Initialisiert eine neue leere Instanz der <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>-Klasse unter Verwendung der angegebenen Anfangskapazität, des angegebenen Hashcodeanbieters, des angegebenen Comparers und des Standardlastfaktors.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>Specifying the initial capacity eliminates the need to perform a number of resizing operations while adding elements to the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> object.</source>
          <target state="translated">Angeben der anfänglichen Kapazität entfällt die Notwendigkeit, eine Reihe von größenänderungsvorgänge beim Hinzufügen von Elementen zum Ausführen der <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> Objekt.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>Capacity is automatically increased as required based on the load factor.</source>
          <target state="translated">Kapazität wird automatisch nach Bedarf erhöht werden basierend auf den Lastfaktor.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The load factor is the maximum ratio of elements to buckets.</source>
          <target state="translated">Der Ladefaktor ist das maximale Verhältnis von Elementen zu Buckets.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>A smaller load factor means faster lookup at the cost of increased memory consumption.</source>
          <target state="translated">Ein kleinerer Ladefaktor bedeutet schnellere Suchvorgänge auf Kosten erhöhter Speicherbedarf.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>When the actual load factor reaches the specified load factor, the number of buckets is automatically increased to the smallest prime number that is larger than twice the current number of buckets.</source>
          <target state="translated">Wenn der tatsächliche Lastfaktor den angegebenen Lastfaktor erreicht, wird die Anzahl der Buckets automatisch auf die kleinste Anzahl von Primzahlen erhöht, die größer ist als zweimal die aktuelle Anzahl der Buckets.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The hash code provider dispenses hash codes for keys in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
          <target state="translated">Die Hashcodeanbieter Hashcodes für Schlüssel in der <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The default hash code provider is the key's implementation of <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Der Hashcode-Standardanbieter ist-Implementierung eines Schlüssels <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The comparer determines whether two keys are equal.</source>
          <target state="translated">Der Vergleich bestimmt, ob zwei Schlüssel gleich sind.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>Every key in a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> must be unique.</source>
          <target state="translated">Jeder Schlüssel im einem <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> muss eindeutig sein.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The default comparer is the key's implementation of <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Ist der Standardvergleich-Implementierung eines Schlüssels <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The custom hash code provider and the custom comparer enable scenarios such as doing lookups with case-insensitive strings.</source>
          <target state="translated">Benutzerdefinierte Hashcodeanbieter und Comparer ermöglichen Szenarien wie etwa das Durchführen von Suchvorgängen mit der Groß-/ Kleinschreibung.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>This constructor is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">`capacity`</ph> parameter.</source>
          <target state="translated">Dieser Konstruktor ist eine O (<ph id="ph1">`n`</ph>) Vorgang, wobei <ph id="ph2">`n`</ph> ist die <ph id="ph3">`capacity`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The following code example creates hash tables using different <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.</source>
          <target state="translated">Das folgende Codebeispiel erstellt Hashtabellen mit verschiedenen <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> Konstruktoren und zeigt die Unterschiede im Verhalten von Hashtabellen, selbst wenn jeweils die gleichen Elemente enthält.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="capacity" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="capacity" /&gt;</ph> ist kleiner als Null.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)">
          <source>The approximate number of elements that the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> object can initially contain.</source>
          <target state="translated">Die ungefähre Anzahl von Elementen, die die <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> anfänglich enthalten kann.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)">
          <source>A number in the range from 0.1 through 1.0 that is multiplied by the default value which provides the best performance.</source>
          <target state="translated">Eine Zahl im Bereich 0,1 bis 1,0, die mit dem Standardwert für die optimale Leistung multipliziert wird.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)">
          <source>The result is the maximum ratio of elements to buckets.</source>
          <target state="translated">Das Ergebnis ist das maximale Verhältnis von Elementen zu Buckets.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph> object that defines the hash code provider and the comparer to use with the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph>, der sowohl den Hashcodeanbieter als auch den Comparer zur Verwendung mit der <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> definiert.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the default hash code provider and the default comparer.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph>, um den Hashcode-Standardanbieter und den Standardcomparer zu verwenden.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)">
          <source>The default hash code provider is each key's implementation of <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> and the default comparer is each key's implementation of <ph id="ph2">&lt;see cref="M:System.Object.Equals(System.Object)" /&gt;</ph>.</source>
          <target state="translated">Der Hashcode-Standardanbieter ist die Implementierung von <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> jedes Schlüssels, und der Standardcomparer ist die Implementierung von <ph id="ph2">&lt;see cref="M:System.Object.Equals(System.Object)" /&gt;</ph> jedes Schlüssels.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)">
          <source>Initializes a new, empty instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> class using the specified initial capacity, load factor, and <ph id="ph2">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph> object.</source>
          <target state="translated">Initialisiert eine neue leere Instanz der <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>-Klasse unter Verwendung der angegebenen Anfangskapazität, des angegebenen Lastfaktors und des angegebenen <ph id="ph2">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph>-Objekts.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)">
          <source>Specifying the initial capacity eliminates the need to perform a number of resizing operations while adding elements to the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> object.</source>
          <target state="translated">Angeben der anfänglichen Kapazität entfällt die Notwendigkeit, eine Reihe von größenänderungsvorgänge beim Hinzufügen von Elementen zum Ausführen der <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> Objekt.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)">
          <source>Capacity is automatically increased as required based on the load factor.</source>
          <target state="translated">Kapazität wird automatisch nach Bedarf erhöht werden basierend auf den Lastfaktor.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)">
          <source>The load factor is the maximum ratio of elements to buckets.</source>
          <target state="translated">Der Ladefaktor ist das maximale Verhältnis von Elementen zu Buckets.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)">
          <source>A smaller load factor means faster lookup at the cost of increased memory consumption.</source>
          <target state="translated">Ein kleinerer Ladefaktor bedeutet schnellere Suchvorgänge auf Kosten erhöhter Speicherbedarf.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)">
          <source>A load factor of 1.0 is the best balance between speed and size.</source>
          <target state="translated">Ein Ladefaktor 1.0 ist der beste Kompromiss zwischen Geschwindigkeit und Größe.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)">
          <source>When the actual load factor reaches the specified load factor, the number of buckets is automatically increased to the smallest prime number that is larger than twice the current number of buckets.</source>
          <target state="translated">Wenn der tatsächliche Lastfaktor den angegebenen Lastfaktor erreicht, wird die Anzahl der Buckets automatisch auf die kleinste Anzahl von Primzahlen erhöht, die größer ist als zweimal die aktuelle Anzahl der Buckets.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)">
          <source>The <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> object includes both the hash code provider and the comparer.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> -Objekt umfasst sowohl den Hashcodeanbieter als auch den Comparer.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)">
          <source>If an <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> is used in the <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> constructor, the objects used as keys in the <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph> are not required to override the <ph id="ph4">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph5">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> methods.</source>
          <target state="translated">Wenn ein <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> werden in der <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> Konstruktor, der die Objekte, die als Schlüssel in der <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph> ist nicht erforderlich, außer Kraft setzen die <ph id="ph4">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> und <ph id="ph5">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> Methoden.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)">
          <source>The hash code provider dispenses hash codes for keys in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
          <target state="translated">Die Hashcodeanbieter Hashcodes für Schlüssel in der <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)">
          <source>The default hash code provider is the key's implementation of <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Der Hashcode-Standardanbieter ist-Implementierung eines Schlüssels <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)">
          <source>The comparer determines whether two keys are equal.</source>
          <target state="translated">Der Vergleich bestimmt, ob zwei Schlüssel gleich sind.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)">
          <source>Every key in a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> must be unique.</source>
          <target state="translated">Jeder Schlüssel im einem <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> muss eindeutig sein.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)">
          <source>The default comparer is the key's implementation of <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Ist der Standardvergleich-Implementierung eines Schlüssels <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)">
          <source>The <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> enables scenarios such as doing lookups with case-insensitive strings.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> ermöglicht Szenarien wie etwa das Durchführen von Suchvorgängen mit der Groß-/ Kleinschreibung.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)">
          <source>This constructor is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">`capacity`</ph> parameter.</source>
          <target state="translated">Dieser Konstruktor ist eine O (<ph id="ph1">`n`</ph>) Vorgang, wobei <ph id="ph2">`n`</ph> ist die <ph id="ph3">`capacity`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)">
          <source>The following code example creates hash tables using different <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.</source>
          <target state="translated">Das folgende Codebeispiel erstellt Hashtabellen mit verschiedenen <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> Konstruktoren und zeigt die Unterschiede im Verhalten von Hashtabellen, selbst wenn jeweils die gleichen Elemente enthält.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)">
          <source><ph id="ph1">&lt;paramref name="capacity" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="capacity" /&gt;</ph> ist kleiner als Null.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)">
          <source><ph id="ph1">&lt;paramref name="loadFactor" /&gt;</ph> is less than 0.1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="loadFactor" /&gt;</ph> ist kleiner als 0,1.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)">
          <source><ph id="ph1">&lt;paramref name="loadFactor" /&gt;</ph> is greater than 1.0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="loadFactor" /&gt;</ph> ist größer als 1,0.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IDictionary" /&gt;</ph> object to copy to a new <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> object.</source>
          <target state="translated">Das <ph id="ph1">&lt;see cref="T:System.Collections.IDictionary" /&gt;</ph>-Objekt, das in ein neues <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>-Objekt kopiert werden soll.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>A number in the range from 0.1 through 1.0 that is multiplied by the default value which provides the best performance.</source>
          <target state="translated">Eine Zahl im Bereich 0,1 bis 1,0, die mit dem Standardwert für die optimale Leistung multipliziert wird.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The result is the maximum ratio of elements to buckets.</source>
          <target state="translated">Das Ergebnis ist das maximale Verhältnis von Elementen zu Buckets.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IHashCodeProvider" /&gt;</ph> object that supplies the hash codes for all keys in the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated">Das <ph id="ph1">&lt;see cref="T:System.Collections.IHashCodeProvider" /&gt;</ph>-Objekt, das die Hashcodes für alle Schlüssel in der <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> bereitstellt.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the default hash code provider, which is each key's implementation of <ph id="ph2">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph>, wenn der Hashcode-Standardanbieter verwendet werden soll. Dies ist die jeweilige <ph id="ph2">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph>-Implementierung eines Schlüssels.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> object to use to determine whether two keys are equal.</source>
          <target state="translated">Das <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph>-Objekt, mit dem ermittelt wird, ob zwei Schlüssel gleich sind.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the default comparer, which is each key's implementation of <ph id="ph2">&lt;see cref="M:System.Object.Equals(System.Object)" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph>, wenn der Standardcomparer verwendet werden soll. Dies ist die jeweilige <ph id="ph2">&lt;see cref="M:System.Object.Equals(System.Object)" /&gt;</ph>-Implementierung eines Schlüssels.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> class by copying the elements from the specified dictionary to the new <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> object.</source>
          <target state="translated">Initialisiert eine neue Instanz der <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>-Klasse durch Kopieren der Elemente aus dem angegebenen Wörterbuch in das neue <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>-Objekt.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The new <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> object has an initial capacity equal to the number of elements copied, and uses the specified load factor, hash code provider, and comparer.</source>
          <target state="translated">Das neue <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>-Objekt besitzt eine Anfangskapazität, die mit der Anzahl der kopierten Elemente identisch ist, und verwendet den angegebenen Lastfaktor, den angegebenen Hashcodeanbieter und den angegebenen Comparer.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The initial capacity is set to the number of elements in the source dictionary.</source>
          <target state="translated">Die anfängliche Kapazität wird auf die Anzahl der Elemente im Quellwörterbuch festgelegt.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>Capacity is automatically increased as required based on the load factor.</source>
          <target state="translated">Kapazität wird automatisch nach Bedarf erhöht werden basierend auf den Lastfaktor.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The load factor is the maximum ratio of elements to buckets.</source>
          <target state="translated">Der Ladefaktor ist das maximale Verhältnis von Elementen zu Buckets.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>A smaller load factor means faster lookup at the cost of increased memory consumption.</source>
          <target state="translated">Ein kleinerer Ladefaktor bedeutet schnellere Suchvorgänge auf Kosten erhöhter Speicherbedarf.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>A load factor of 1.0 is the best balance between speed and size.</source>
          <target state="translated">Ein Ladefaktor 1.0 ist der beste Kompromiss zwischen Geschwindigkeit und Größe.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>When the actual load factor reaches the specified load factor, the number of buckets is automatically increased to the smallest prime number that is larger than twice the current number of buckets.</source>
          <target state="translated">Wenn der tatsächliche Lastfaktor den angegebenen Lastfaktor erreicht, wird die Anzahl der Buckets automatisch auf die kleinste Anzahl von Primzahlen erhöht, die größer ist als zweimal die aktuelle Anzahl der Buckets.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The hash code provider dispenses hash codes for keys in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> object.</source>
          <target state="translated">Die Hashcodeanbieter Hashcodes für Schlüssel in der <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> Objekt.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The default hash code provider is the key's implementation of <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Der Hashcode-Standardanbieter ist-Implementierung eines Schlüssels <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The comparer determines whether two keys are equal.</source>
          <target state="translated">Der Vergleich bestimmt, ob zwei Schlüssel gleich sind.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>Every key in a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> must be unique.</source>
          <target state="translated">Jeder Schlüssel im einem <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> muss eindeutig sein.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The default comparer is the key's implementation of <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Ist der Standardvergleich-Implementierung eines Schlüssels <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The custom hash code provider and the custom comparer enable scenarios such as doing lookups with case-insensitive strings.</source>
          <target state="translated">Benutzerdefinierte Hashcodeanbieter und Comparer ermöglichen Szenarien wie etwa das Durchführen von Suchvorgängen mit der Groß-/ Kleinschreibung.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The elements of the new <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> are sorted in the same order in which the enumerator iterates through the <ph id="ph2">&lt;xref:System.Collections.IDictionary&gt;</ph> object.</source>
          <target state="translated">Die Elemente der neuen <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> sortiert sind, in der gleichen Reihenfolge, in dem sich der Enumerator durchläuft, die <ph id="ph2">&lt;xref:System.Collections.IDictionary&gt;</ph> Objekt.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>This constructor is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements in the <ph id="ph3">`d`</ph> parameter.</source>
          <target state="translated">Dieser Konstruktor ist eine O (<ph id="ph1">`n`</ph>)-Vorgang, in dem <ph id="ph2">`n`</ph> ist die Anzahl der Elemente in der <ph id="ph3">`d`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The following code example creates hash tables using different <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.</source>
          <target state="translated">Das folgende Codebeispiel erstellt Hashtabellen mit verschiedenen <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> Konstruktoren und zeigt die Unterschiede im Verhalten von Hashtabellen, selbst wenn jeweils die gleichen Elemente enthält.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="d" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="d" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="loadFactor" /&gt;</ph> is less than 0.1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="loadFactor" /&gt;</ph> ist kleiner als 0,1.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="loadFactor" /&gt;</ph> is greater than 1.0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="loadFactor" /&gt;</ph> ist größer als 1,0.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The approximate number of elements that the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> object can initially contain.</source>
          <target state="translated">Die ungefähre Anzahl von Elementen, die die <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> anfänglich enthalten kann.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>A number in the range from 0.1 through 1.0 that is multiplied by the default value which provides the best performance.</source>
          <target state="translated">Eine Zahl im Bereich 0,1 bis 1,0, die mit dem Standardwert für die optimale Leistung multipliziert wird.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The result is the maximum ratio of elements to buckets.</source>
          <target state="translated">Das Ergebnis ist das maximale Verhältnis von Elementen zu Buckets.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IHashCodeProvider" /&gt;</ph> object that supplies the hash codes for all keys in the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated">Das <ph id="ph1">&lt;see cref="T:System.Collections.IHashCodeProvider" /&gt;</ph>-Objekt, das die Hashcodes für alle Schlüssel in der <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> bereitstellt.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the default hash code provider, which is each key's implementation of <ph id="ph2">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph>, wenn der Hashcode-Standardanbieter verwendet werden soll. Dies ist die jeweilige <ph id="ph2">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph>-Implementierung eines Schlüssels.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> object to use to determine whether two keys are equal.</source>
          <target state="translated">Das <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph>-Objekt, mit dem ermittelt wird, ob zwei Schlüssel gleich sind.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the default comparer, which is each key's implementation of <ph id="ph2">&lt;see cref="M:System.Object.Equals(System.Object)" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph>, wenn der Standardcomparer verwendet werden soll. Dies ist die jeweilige <ph id="ph2">&lt;see cref="M:System.Object.Equals(System.Object)" /&gt;</ph>-Implementierung eines Schlüssels.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>Initializes a new, empty instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> class using the specified initial capacity, load factor, hash code provider, and comparer.</source>
          <target state="translated">Initialisiert eine neue leere Instanz der <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>-Klasse unter Verwendung der angegebenen Anfangskapazität, des angegebenen Lastfaktors, des angegebenen Hashcode-Anbieters und des angegebenen Comparers.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>Specifying the initial capacity eliminates the need to perform a number of resizing operations while adding elements to the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> object.</source>
          <target state="translated">Angeben der anfänglichen Kapazität entfällt die Notwendigkeit, eine Reihe von größenänderungsvorgänge beim Hinzufügen von Elementen zum Ausführen der <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> Objekt.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>Capacity is automatically increased as required based on the load factor.</source>
          <target state="translated">Kapazität wird automatisch nach Bedarf erhöht werden basierend auf den Lastfaktor.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The load factor is the maximum ratio of elements to buckets.</source>
          <target state="translated">Der Ladefaktor ist das maximale Verhältnis von Elementen zu Buckets.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>A smaller load factor means faster lookup at the cost of increased memory consumption.</source>
          <target state="translated">Ein kleinerer Ladefaktor bedeutet schnellere Suchvorgänge auf Kosten erhöhter Speicherbedarf.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>A load factor of 1.0 is the best balance between speed and size.</source>
          <target state="translated">Ein Ladefaktor 1.0 ist der beste Kompromiss zwischen Geschwindigkeit und Größe.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>When the actual load factor reaches the specified load factor, the number of buckets is automatically increased to the smallest prime number that is larger than twice the current number of buckets.</source>
          <target state="translated">Wenn der tatsächliche Lastfaktor den angegebenen Lastfaktor erreicht, wird die Anzahl der Buckets automatisch auf die kleinste Anzahl von Primzahlen erhöht, die größer ist als zweimal die aktuelle Anzahl der Buckets.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The hash code provider dispenses hash codes for keys in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
          <target state="translated">Die Hashcodeanbieter Hashcodes für Schlüssel in der <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The default hash code provider is the key's implementation of <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Der Hashcode-Standardanbieter ist-Implementierung eines Schlüssels <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The comparer determines whether two keys are equal.</source>
          <target state="translated">Der Vergleich bestimmt, ob zwei Schlüssel gleich sind.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>Every key in a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> must be unique.</source>
          <target state="translated">Jeder Schlüssel im einem <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> muss eindeutig sein.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The default comparer is the key's implementation of <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Ist der Standardvergleich-Implementierung eines Schlüssels <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The custom hash code provider and the custom comparer enable scenarios such as doing lookups with case-insensitive strings.</source>
          <target state="translated">Benutzerdefinierte Hashcodeanbieter und Comparer ermöglichen Szenarien wie etwa das Durchführen von Suchvorgängen mit der Groß-/ Kleinschreibung.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>This constructor is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">`capacity`</ph> parameter.</source>
          <target state="translated">Dieser Konstruktor ist eine O (<ph id="ph1">`n`</ph>) Vorgang, wobei <ph id="ph2">`n`</ph> ist die <ph id="ph3">`capacity`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>The following code example creates hash tables using different <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.</source>
          <target state="translated">Das folgende Codebeispiel erstellt Hashtabellen mit verschiedenen <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> Konstruktoren und zeigt die Unterschiede im Verhalten von Hashtabellen, selbst wenn jeweils die gleichen Elemente enthält.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="capacity" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="capacity" /&gt;</ph> ist kleiner als Null.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="loadFactor" /&gt;</ph> is less than 0.1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="loadFactor" /&gt;</ph> ist kleiner als 0,1.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="loadFactor" /&gt;</ph> is greater than 1.0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="loadFactor" /&gt;</ph> ist größer als 1,0.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.Add(System.Object,System.Object)">
          <source>The key of the element to add.</source>
          <target state="translated">Der Schlüssel des hinzuzufügenden Elements.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.Add(System.Object,System.Object)">
          <source>The value of the element to add.</source>
          <target state="translated">Der Wert des hinzuzufügenden Elements.</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.Add(System.Object,System.Object)">
          <source>The value can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Der Wert kann <ph id="ph1">&lt;see langword="null" /&gt;</ph> sein.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.Add(System.Object,System.Object)">
          <source>Adds an element with the specified key and value into the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated">Fügt dem <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> ein Element mit dem angegebenen Schlüssel und Wert hinzu.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Add(System.Object,System.Object)">
          <source>A key cannot be <ph id="ph1">`null`</ph>, but a value can be.</source>
          <target state="translated">Ein Schlüssel kann nicht <ph id="ph1">`null`</ph>, aber ein Wert sein kann.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Add(System.Object,System.Object)">
          <source>An object that has no correlation between its state and its hash code value should typically not be used as the key.</source>
          <target state="translated">Ein Objekt, das keine Korrelation zwischen seinem Zustand und seiner Hashcodewert hat, sollte in der Regel nicht als Schlüssel verwendet werden.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Add(System.Object,System.Object)">
          <source>For example, String objects are better than StringBuilder objects for use as keys.</source>
          <target state="translated">Beispielsweise sind Zeichenfolgenobjekten als Schlüssel StringBuilder-Objekte für die Verwendung besser.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Add(System.Object,System.Object)">
          <source>You can also use the <ph id="ph1">&lt;xref:System.Collections.Hashtable.Item%2A&gt;</ph> property to add new elements by setting the value of a key that does not exist in the <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph>; for example, <ph id="ph3">`myCollection["myNonexistentKey"] = myValue`</ph>.</source>
          <target state="translated">Sie können auch die <ph id="ph1">&lt;xref:System.Collections.Hashtable.Item%2A&gt;</ph> zum Hinzufügen neuer Elemente durch Festlegen des Werts eines Schlüssels, die Eigenschaft ist nicht vorhanden, der <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph>, z. B. <ph id="ph3">`myCollection["myNonexistentKey"] = myValue`</ph>.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Add(System.Object,System.Object)">
          <source>However, if the specified key already exists in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>, setting the <ph id="ph2">&lt;xref:System.Collections.Hashtable.Item%2A&gt;</ph> property overwrites the old value.</source>
          <target state="translated">Jedoch, wenn der angegebene Schlüssel bereits vorhanden ist die <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>wird durch das Festlegen der <ph id="ph2">&lt;xref:System.Collections.Hashtable.Item%2A&gt;</ph> Eigenschaft überschreibt den alten Wert.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Add(System.Object,System.Object)">
          <source>In contrast, the <ph id="ph1">&lt;xref:System.Collections.Hashtable.Add%2A&gt;</ph> method does not modify existing elements.</source>
          <target state="translated">Im Gegensatz dazu die <ph id="ph1">&lt;xref:System.Collections.Hashtable.Add%2A&gt;</ph> Methode vorhandene Elemente nicht geändert.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Add(System.Object,System.Object)">
          <source>If <ph id="ph1">&lt;xref:System.Collections.Hashtable.Count%2A&gt;</ph> is less than the capacity of the <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph>, this method is an O(1) operation.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;xref:System.Collections.Hashtable.Count%2A&gt;</ph> ist kleiner als die Kapazität der <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph>, diese Methode ist ein o(1)-Vorgang.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Add(System.Object,System.Object)">
          <source>If the capacity needs to be increased to accommodate the new element, this method becomes an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.Hashtable.Count%2A&gt;</ph>.</source>
          <target state="translated">Wenn die Kapazität für das neue Element erhöht werden muss, wird diese Methode eine O (<ph id="ph1">`n`</ph>)-Vorgang, in dem <ph id="ph2">`n`</ph> ist <ph id="ph3">&lt;xref:System.Collections.Hashtable.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Add(System.Object,System.Object)">
          <source>The following example shows how to add elements to the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
          <target state="translated">Das folgende Beispiel zeigt, wie Sie zum Hinzufügen von Elementen der <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.Add(System.Object,System.Object)">
          <source><ph id="ph1">&lt;paramref name="key" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="key" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.Add(System.Object,System.Object)">
          <source>An element with the same key already exists in the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated">In <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> ist bereits ein Element mit demselben Schlüssel enthalten.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.Add(System.Object,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> is read-only.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> ist schreibgeschützt.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.Add(System.Object,System.Object)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.Add(System.Object,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> has a fixed size.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> hat eine feste Größe.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.Clear">
          <source>Removes all elements from the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated">Entfernt alle Elemente aus der <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Clear">
          <source><ph id="ph1">&lt;xref:System.Collections.Hashtable.Count%2A&gt;</ph> is set to zero, and references to other objects from elements of the collection are also released.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.Hashtable.Count%2A&gt;</ph> ist auf 0 (null) festgelegt, und Verweise auf andere Objekte von Elementen in der Auflistung werden ebenfalls freigegeben.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Clear">
          <source>The capacity remains unchanged.</source>
          <target state="translated">Die Kapazität bleibt unverändert.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Clear">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.Hashtable.Count%2A&gt;</ph>.</source>
          <target state="translated">Diese Methode ist eine O (<ph id="ph1">`n`</ph>) Vorgang, wobei <ph id="ph2">`n`</ph> ist <ph id="ph3">&lt;xref:System.Collections.Hashtable.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Clear">
          <source>The following example shows how to clear the values of the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
          <target state="translated">Im folgende Beispiel wird gezeigt, wie zum Löschen der Werte der <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.Clear">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> is read-only.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> ist schreibgeschützt.</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.Clone">
          <source>Creates a shallow copy of the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated">Erstellt eine flache Kopie von <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.Clone">
          <source>A shallow copy of the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated">Eine flache Kopie von <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Clone">
          <source>A shallow copy of a collection copies only the elements of the collection, whether they are reference types or value types, but it does not copy the objects that the references refer to.</source>
          <target state="translated">Eine flache Kopie einer Auflistung kopiert nur die Elemente der Auflistung, ob sie Verweis- oder Werttypen sind, aber die Objekte, denen auf die verwiesen wird nicht kopiert.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Clone">
          <source>The references in the new collection point to the same objects that the references in the original collection point to.</source>
          <target state="translated">Die Verweise in der neuen Auflistung zeigen auf dieselben Objekte, denen auf die Verweise in der ursprünglichen Auflistung verweisen.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Clone">
          <source>In contrast, a deep copy of a collection copies the elements and everything directly or indirectly referenced by the elements.</source>
          <target state="translated">Im Gegensatz dazu eine tiefe Kopie einer Auflistung kopiert die Elemente aus, und alles, was durch die Elemente direkt oder indirekt verweist.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Clone">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> clone has the same count, the same capacity, the same <ph id="ph2">&lt;xref:System.Collections.IHashCodeProvider&gt;</ph> implementation, and the same <ph id="ph3">&lt;xref:System.Collections.IComparer&gt;</ph> implementation as the original <ph id="ph4">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> Klon hat dieselbe Anzahl, die gleiche Kapazität dem <ph id="ph2">&lt;xref:System.Collections.IHashCodeProvider&gt;</ph> Implementierung und die gleiche <ph id="ph3">&lt;xref:System.Collections.IComparer&gt;</ph> Implementierung wie beim ursprünglichen <ph id="ph4">&lt;xref:System.Collections.Hashtable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Clone">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.Hashtable.Count%2A&gt;</ph>.</source>
          <target state="translated">Diese Methode ist eine O (<ph id="ph1">`n`</ph>) Vorgang, wobei <ph id="ph2">`n`</ph> ist <ph id="ph3">&lt;xref:System.Collections.Hashtable.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" uid="P:System.Collections.Hashtable.comparer">
          <source>Gets or sets the <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> to use for the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated">Ruft den für die <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> zu verwendenden <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> ab oder legt diesen fest.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.comparer">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> to use for the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph>, der für die <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> verwendet werden soll.</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.comparer">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" uid="P:System.Collections.Hashtable.comparer">
          <source>The property is set to a value, but the hash table was created using an <ph id="ph1">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph>.</source>
          <target state="translated">Die Eigenschaft wird auf einen Wert festgelegt, aber die Hashtabelle wurde mit einem <ph id="ph1">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph> erstellt.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.Contains(System.Object)">
          <source>The key to locate in the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated">Der im <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> zu suchende Schlüssel.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.Contains(System.Object)">
          <source>Determines whether the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> contains a specific key.</source>
          <target state="translated">Stellt fest, ob der <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> einen bestimmten Schlüssel enthält.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.Contains(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> contains an element with the specified key; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn das <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> ein Element mit dem angegebenen Schlüssel enthält, andernfalls <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Contains(System.Object)">
          <source><ph id="ph1">&lt;xref:System.Collections.Hashtable.Contains%2A&gt;</ph> implements <ph id="ph2">&lt;xref:System.Collections.IDictionary.Contains%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.Hashtable.Contains%2A&gt;</ph> implementiert <ph id="ph2">&lt;xref:System.Collections.IDictionary.Contains%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Contains(System.Object)">
          <source>It behaves exactly as <ph id="ph1">&lt;xref:System.Collections.Hashtable.ContainsKey%2A&gt;</ph>.</source>
          <target state="translated">Sie verhält sich genau wie <ph id="ph1">&lt;xref:System.Collections.Hashtable.ContainsKey%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Contains(System.Object)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Diese Methode ist ein o(1)-Vorgang.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Contains(System.Object)">
          <source>Starting with the .NET Framework 2.0, this method uses the collection’s objects’ <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods on <ph id="ph3">`item`</ph> to determine whether item exists.</source>
          <target state="translated">Beginnend mit .NET Framework 2.0, verwendet diese Methode Objekte in der Auflistung <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> Methoden auf <ph id="ph3">`item`</ph> zu bestimmen, ob das Element vorhanden ist.</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Contains(System.Object)">
          <source>In the earlier versions of the .NET Framework, this determination was made by using the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods of the <ph id="ph3">`item`</ph> parameter on the objects in the collection.</source>
          <target state="translated">In früheren Versionen von .NET Framework-diese Entscheidung wurde versucht, mithilfe der <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> Methoden der <ph id="ph3">`item`</ph> Parameter für die Objekte in der Auflistung.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Contains(System.Object)">
          <source>The following example shows how to determine whether the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> contains a specific element.</source>
          <target state="translated">Das folgende Beispiel zeigt, wie Sie feststellen, ob die <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> ein bestimmtes Element enthält.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.Contains(System.Object)">
          <source><ph id="ph1">&lt;paramref name="key" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="key" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.ContainsKey(System.Object)">
          <source>The key to locate in the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated">Der im <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> zu suchende Schlüssel.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.ContainsKey(System.Object)">
          <source>Determines whether the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> contains a specific key.</source>
          <target state="translated">Stellt fest, ob der <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> einen bestimmten Schlüssel enthält.</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.ContainsKey(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> contains an element with the specified key; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn das <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> ein Element mit dem angegebenen Schlüssel enthält, andernfalls <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.ContainsKey(System.Object)">
          <source>This method behaves exactly as <ph id="ph1">&lt;xref:System.Collections.Hashtable.Contains%2A&gt;</ph>.</source>
          <target state="translated">Diese Methode verhält sich genauso wie <ph id="ph1">&lt;xref:System.Collections.Hashtable.Contains%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.ContainsKey(System.Object)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Diese Methode ist ein o(1)-Vorgang.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.ContainsKey(System.Object)">
          <source>Starting with the .NET Framework 2.0, this method uses the collection’s objects’ <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods on <ph id="ph3">`item`</ph> to determine whether item exists.</source>
          <target state="translated">Beginnend mit .NET Framework 2.0, verwendet diese Methode Objekte in der Auflistung <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> Methoden auf <ph id="ph3">`item`</ph> zu bestimmen, ob das Element vorhanden ist.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.ContainsKey(System.Object)">
          <source>In the earlier versions of the .NET Framework, this determination was made by using the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods of the <ph id="ph3">`item`</ph> parameter on the objects in the collection.</source>
          <target state="translated">In früheren Versionen von .NET Framework-diese Entscheidung wurde versucht, mithilfe der <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> Methoden der <ph id="ph3">`item`</ph> Parameter für die Objekte in der Auflistung.</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.ContainsKey(System.Object)">
          <source>The following example shows how to determine whether the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> contains a specific element.</source>
          <target state="translated">Das folgende Beispiel zeigt, wie Sie feststellen, ob die <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> ein bestimmtes Element enthält.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.ContainsKey(System.Object)">
          <source><ph id="ph1">&lt;paramref name="key" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="key" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.ContainsValue(System.Object)">
          <source>The value to locate in the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated">Der im <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> zu suchende Wert.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.ContainsValue(System.Object)">
          <source>The value can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Der Wert kann <ph id="ph1">&lt;see langword="null" /&gt;</ph> sein.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.ContainsValue(System.Object)">
          <source>Determines whether the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> contains a specific value.</source>
          <target state="translated">Ermittelt, ob die <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> einen bestimmten Wert enthält.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.ContainsValue(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> contains an element with the specified <ph id="ph3">&lt;paramref name="value" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn die <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> ein Element mit dem angegebenen <ph id="ph3">&lt;paramref name="value" /&gt;</ph> enthält, andernfalls <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.ContainsValue(System.Object)">
          <source>The values of the elements of the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> are compared to the specified value using the <ph id="ph2">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Die Werte der Elemente des der <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> verglichen werden, um den angegebenen Wert mit dem <ph id="ph2">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.ContainsValue(System.Object)">
          <source>This method performs a linear search; therefore, this method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.Hashtable.Count%2A&gt;</ph>.</source>
          <target state="translated">Diese Methode führt eine lineare Suche. Diese Methode ist daher eine O (<ph id="ph1">`n`</ph>)-Vorgang, in dem <ph id="ph2">`n`</ph> ist <ph id="ph3">&lt;xref:System.Collections.Hashtable.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.ContainsValue(System.Object)">
          <source>Starting with the .NET Framework 2.0, this method uses the collection’s objects’ <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods on <ph id="ph3">`item`</ph> to determine whether item exists.</source>
          <target state="translated">Beginnend mit .NET Framework 2.0, verwendet diese Methode Objekte in der Auflistung <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> Methoden auf <ph id="ph3">`item`</ph> zu bestimmen, ob das Element vorhanden ist.</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.ContainsValue(System.Object)">
          <source>In the earlier versions of the .NET Framework, this determination was made by using the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods of the <ph id="ph3">`item`</ph> parameter on the objects in the collection.</source>
          <target state="translated">In früheren Versionen von .NET Framework-diese Entscheidung wurde versucht, mithilfe der <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> Methoden der <ph id="ph3">`item`</ph> Parameter für die Objekte in der Auflistung.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.ContainsValue(System.Object)">
          <source>The following example shows how to determine whether the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> contains a specific element.</source>
          <target state="translated">Das folgende Beispiel zeigt, wie Sie feststellen, ob die <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> ein bestimmtes Element enthält.</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.CopyTo(System.Array,System.Int32)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that is the destination of the <ph id="ph2">&lt;see cref="T:System.Collections.DictionaryEntry" /&gt;</ph> objects copied from <ph id="ph3">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated">Das eindimensionale <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>, das das Ziel der aus <ph id="ph2">&lt;see cref="T:System.Collections.DictionaryEntry" /&gt;</ph> kopierten <ph id="ph3">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>-Objekte ist.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.CopyTo(System.Array,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> must have zero-based indexing.</source>
          <target state="translated">Für das <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> muss eine nullbasierte Indizierung verwendet werden.</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.CopyTo(System.Array,System.Int32)">
          <source>The zero-based index in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> at which copying begins.</source>
          <target state="translated">Der nullbasierte Index im <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>, ab dem kopiert wird.</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.CopyTo(System.Array,System.Int32)">
          <source>Copies the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> elements to a one-dimensional <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> instance at the specified index.</source>
          <target state="translated">Kopiert die <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>-Elemente an den angegebenen Index in einer eindimensionalen <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>-Instanz.</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.CopyTo(System.Array,System.Int32)">
          <source>The elements are copied to the <ph id="ph1">&lt;xref:System.Array&gt;</ph> in the same order in which the enumerator iterates through the <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
          <target state="translated">Die Elemente kopiert werden, um die <ph id="ph1">&lt;xref:System.Array&gt;</ph> in der gleichen Reihenfolge, in dem sich der Enumerator durchläuft, die <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.CopyTo(System.Array,System.Int32)">
          <source>To copy only the keys in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>, use <ph id="ph2">`Hashtable.Keys.CopyTo`</ph>.</source>
          <target state="translated">So kopieren Sie nur die Schlüssel in der <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>, verwenden Sie <ph id="ph2">`Hashtable.Keys.CopyTo`</ph>.</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.CopyTo(System.Array,System.Int32)">
          <source>To copy only the values in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>, use <ph id="ph2">`Hashtable.Values.CopyTo`</ph>.</source>
          <target state="translated">So kopieren Sie nur die Werte in der <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>, verwenden Sie <ph id="ph2">`Hashtable.Values.CopyTo`</ph>.</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.CopyTo(System.Array,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.Hashtable.Count%2A&gt;</ph>.</source>
          <target state="translated">Diese Methode ist eine O (<ph id="ph1">`n`</ph>) Vorgang, wobei <ph id="ph2">`n`</ph> ist <ph id="ph3">&lt;xref:System.Collections.Hashtable.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.CopyTo(System.Array,System.Int32)">
          <source>The following example shows how to copy the list of keys or the list of values in a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> into a one-dimensional <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Im folgende Beispiel wird gezeigt, wie So kopieren Sie die Liste der Schlüssel oder die Liste der Werte in einer <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> in einem eindimensionalen <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.CopyTo(System.Array,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.CopyTo(System.Array,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="arrayIndex" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="arrayIndex" /&gt;</ph> ist kleiner als Null.</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.CopyTo(System.Array,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> ist mehrdimensional.</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.CopyTo(System.Array,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.CopyTo(System.Array,System.Int32)">
          <source>The number of elements in the source <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> is greater than the available space from <ph id="ph2">&lt;paramref name="arrayIndex" /&gt;</ph> to the end of the destination <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">Die Anzahl der Elemente in der Quell-<ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> ist größer als der verfügbare Platz vom <ph id="ph2">&lt;paramref name="arrayIndex" /&gt;</ph> bis zum Ende des Ziel-<ph id="ph3">&lt;paramref name="array" /&gt;</ph>s.</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.CopyTo(System.Array,System.Int32)">
          <source>The type of the source <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> cannot be cast automatically to the type of the destination <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">Der Typ der Quell-<ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> kann nicht automatisch in den Typ des Ziel-<ph id="ph2">&lt;paramref name="array" /&gt;</ph> umgewandelt werden.</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" uid="P:System.Collections.Hashtable.Count">
          <source>Gets the number of key/value pairs contained in the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated">Ruft die Anzahl der Schlüssel-Wert-Paare im <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> ab.</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.Count">
          <source>The number of key/value pairs contained in the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated">Die Anzahl der Schlüssel-Wert-Paare im <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.Count">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" uid="P:System.Collections.Hashtable.EqualityComparer">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph> to use for the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated">Ruft den <ph id="ph1">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph> ab, der für die <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> verwendet werden soll.</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.EqualityComparer">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph> to use for the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph>, der für die <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> verwendet werden soll.</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.EqualityComparer">
          <source>The <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> includes both the comparer and the hash code provider.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> enthält sowohl den Hashcodeanbieter als auch des Vergleichs.</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.EqualityComparer">
          <source>If an <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> is used in the <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> constructor, the objects used as keys in the <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph> are not required to override the <ph id="ph4">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph5">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> methods.</source>
          <target state="translated">Wenn ein <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> werden in der <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> Konstruktor, der die Objekte, die als Schlüssel in der <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph> ist nicht erforderlich, außer Kraft setzen die <ph id="ph4">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> und <ph id="ph5">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> Methoden.</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.EqualityComparer">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" uid="P:System.Collections.Hashtable.EqualityComparer">
          <source>The property is set to a value, but the hash table was created using an <ph id="ph1">&lt;see cref="T:System.Collections.IHashCodeProvider" /&gt;</ph> and an <ph id="ph2">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph>.</source>
          <target state="translated">Die Eigenschaft wird auf einen Wert festgelegt, aber die Hashtabelle wurde mit einem <ph id="ph1">&lt;see cref="T:System.Collections.IHashCodeProvider" /&gt;</ph> und einem <ph id="ph2">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> erstellt.</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.GetEnumerator">
          <source>Returns an <ph id="ph1">&lt;see cref="T:System.Collections.IDictionaryEnumerator" /&gt;</ph> that iterates through the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated">Gibt einen <ph id="ph1">&lt;see cref="T:System.Collections.IDictionaryEnumerator" /&gt;</ph> zurück, der <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> durchläuft.</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.GetEnumerator">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.IDictionaryEnumerator" /&gt;</ph> for the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Collections.IDictionaryEnumerator" /&gt;</ph> für das <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.GetEnumerator">
          <source>[Visual Basic, C#]</source>
          <target state="translated">[Visual Basic, c#]</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.GetEnumerator">
          <source>The <ph id="ph1">`foreach`</ph> statement of the C# language (<ph id="ph2">`for each`</ph> in Visual Basic) hides the complexity of the enumerators.</source>
          <target state="translated">Die <ph id="ph1">`foreach`</ph>-Anweisung der Programmiersprache C# (<ph id="ph2">`for each`</ph> in Visual Basic) verbirgt die Komplexität der Enumeratoren.</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.GetEnumerator">
          <source>Therefore, using <ph id="ph1">`foreach`</ph> is recommended, instead of directly manipulating the enumerator.</source>
          <target state="translated">Daher empfiehlt es sich, <ph id="ph1">`foreach`</ph> zu verwenden und den Enumerator nicht direkt zu ändern.</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.GetEnumerator">
          <source>Enumerators can be used to read the data in the collection, but they cannot be used to modify the underlying collection.</source>
          <target state="translated">Mit Enumeratoren können die Daten in der Auflistung zwar gelesen, jedoch nicht zum Ändern der zugrunde liegenden Auflistung verwendet werden.</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.GetEnumerator">
          <source>Initially, the enumerator is positioned before the first element in the collection.</source>
          <target state="translated">Zu Beginn wird der Enumerator vor das erste Element in der Auflistung positioniert.</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.GetEnumerator">
          <source><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> also brings the enumerator back to this position.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> setzt den Enumerator ebenfalls auf diese Position zurück.</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.GetEnumerator">
          <source>At this position, <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> is undefined.</source>
          <target state="translated">An dieser Position ist <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> nicht definiert.</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.GetEnumerator">
          <source>Therefore, you must call <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> to advance the enumerator to the first element of the collection before reading the value of <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph>.</source>
          <target state="translated">Daher muss der Enumerator durch einen Aufruf von <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> auf das erste Element der Auflistung gesetzt werden, bevor der Wert von <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> gelesen werden kann.</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.GetEnumerator">
          <source><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> returns the same object until either <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> is called.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> gibt solange dasselbe Objekt zurück, bis <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> oder <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> aufgerufen wird.</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.GetEnumerator">
          <source><ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> sets <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> to the next element.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> legt <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> auf das nächste Element fest.</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.GetEnumerator">
          <source>If <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> passes the end of the collection, the enumerator is positioned after the last element in the collection and <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> returns <ph id="ph3">`false`</ph>.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> übergibt am Ende der Auflistung der Enumerator hinter dem letzten Element in der Auflistung positioniert ist und <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> gibt <ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.GetEnumerator">
          <source>When the enumerator is at this position, subsequent calls to <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> also return <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Wenn der Enumerator ist an dieser Position ist nachfolgende Aufrufe <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> auch zurückgeben <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.GetEnumerator">
          <source>If the last call to <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> returned <ph id="ph2">`false`</ph>, <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> is undefined.</source>
          <target state="translated">Wenn der letzte Aufruf <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> zurückgegebene <ph id="ph2">`false`</ph>, <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> ist nicht definiert.</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.GetEnumerator">
          <source>To set <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> to the first element of the collection again, you can call <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> followed by <ph id="ph3">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph>.</source>
          <target state="translated">Um <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> wieder auf das erste Element der Auflistung festzulegen, können Sie <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> gefolgt von <ph id="ph3">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> aufrufen.</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.GetEnumerator">
          <source>An enumerator remains valid as long as the collection remains unchanged.</source>
          <target state="translated">Ein Enumerator bleibt gültig, solange die Auflistung unverändert ist.</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.GetEnumerator">
          <source>If changes are made to the collection, such as adding, modifying, or deleting elements, the enumerator is irrecoverably invalidated and its behavior is undefined.</source>
          <target state="translated">Werden an der Auflistung Änderungen wie z. B. Hinzufügen, Bearbeiten oder Entfernen von Elementen vorgenommen, verliert der Enumerator unwiederbringlich seine Gültigkeit und sein Verhalten ist nicht definiert.</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.GetEnumerator">
          <source>The enumerator does not have exclusive access to the collection; therefore, enumerating through a collection is intrinsically not a thread safe procedure.</source>
          <target state="translated">Der Enumerator hat keinen exklusiven Zugriff auf die Auflistung. Daher ist die Enumeration einer Auflistung systemintern keine threadsichere Prozedur.</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.GetEnumerator">
          <source>To guarantee thread safety during enumeration, you can lock the collection during the entire enumeration.</source>
          <target state="translated">Um während der Enumeration Threadsicherheit zu garantieren, können Sie die Auflistung während der gesamten Enumeration sperren.</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.GetEnumerator">
          <source>To allow the collection to be accessed by multiple threads for reading and writing, you must implement your own synchronization.</source>
          <target state="translated">Um den Lese- und Schreibzugriff auf diese Auflistung durch mehrere Threads zuzulassen, müssen Sie eine eigene Synchronisierung implementieren.</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.GetEnumerator">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Diese Methode ist ein o(1)-Vorgang.</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.GetEnumerator">
          <source>Because serializing and deserializing an enumerator for a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> can cause the elements to become reordered, it is not possible to continue enumeration without calling the <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> method.</source>
          <target state="translated">Da das Serialisieren und Deserialisieren einen Enumerator für eine <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> kann dazu führen, dass die Elemente, die neu angeordnet werden, es ist nicht möglich, Enumeration ohne Aufruf zu fortfahren die <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.GetEnumerator">
          <source>The following example compares the use of <ph id="ph1">&lt;xref:System.Collections.Hashtable.GetEnumerator%2A&gt;</ph> and <ph id="ph2">`foreach`</ph> to enumerate the contents of a <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
          <target state="translated">Im folgenden Beispiel wird die Verwendung von <ph id="ph1">&lt;xref:System.Collections.Hashtable.GetEnumerator%2A&gt;</ph> und <ph id="ph2">`foreach`</ph> zum Aufzählen der Inhalt von einem <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.GetHash(System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> for which a hash code is to be returned.</source>
          <target state="translated">Das <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph>, für das ein Hashcode zurückgegeben werden soll.</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.GetHash(System.Object)">
          <source>Returns the hash code for the specified key.</source>
          <target state="translated">Gibt den Hashcode für den angegebenen Schlüssel zurück.</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.GetHash(System.Object)">
          <source>The hash code for <ph id="ph1">&lt;paramref name="key" /&gt;</ph>.</source>
          <target state="translated">Der Hashcode für <ph id="ph1">&lt;paramref name="key" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.GetHash(System.Object)">
          <source>If the hash table was created with a specific <ph id="ph1">&lt;xref:System.Collections.IHashCodeProvider&gt;</ph> implementation, this method uses that hash code provider; otherwise, it uses the <ph id="ph2">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> implementation of <ph id="ph3">`key`</ph>.</source>
          <target state="translated">Wenn die Hashtabelle, mit einem bestimmten erstellt wurde <ph id="ph1">&lt;xref:System.Collections.IHashCodeProvider&gt;</ph> Implementierung dieser Methode wird diesem Hashcode-Standardanbieter verwendet; andernfalls wird die <ph id="ph2">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> Implementierung von <ph id="ph3">`key`</ph>.</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.GetHash(System.Object)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Diese Methode ist ein o(1)-Vorgang.</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.GetHash(System.Object)">
          <source><ph id="ph1">&lt;paramref name="key" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="key" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph> object containing the information required to serialize the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph>-Objekt mit den zum Serialisieren der <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> erforderlichen Informationen.</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.StreamingContext" /&gt;</ph> object containing the source and destination of the serialized stream associated with the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.StreamingContext" /&gt;</ph>-Objekt mit der Quelle und dem Ziel des entsprechenden serialisierten Streams für <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>Implements the <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.ISerializable" /&gt;</ph> interface and returns the data needed to serialize the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated">Implementiert die <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.ISerializable" /&gt;</ph>-Schnittstelle und gibt die zum Serialisieren der <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> erforderlichen Daten zurück.</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.Hashtable.Count%2A&gt;</ph>.</source>
          <target state="translated">Diese Methode ist eine O (<ph id="ph1">`n`</ph>) Vorgang, wobei <ph id="ph2">`n`</ph> ist <ph id="ph3">&lt;xref:System.Collections.Hashtable.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source><ph id="ph1">&lt;paramref name="info" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="info" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The collection was modified.</source>
          <target state="translated">Die Auflistung wurde geändert.</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" uid="P:System.Collections.Hashtable.hcp">
          <source>Gets or sets the object that can dispense hash codes.</source>
          <target state="translated">Ruft das Objekt ab, das Hashcodes verteilen kann, oder legt dieses fest.</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.hcp">
          <source>The object that can dispense hash codes.</source>
          <target state="translated">Das Objekt, das Hashcodes verteilen kann.</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.hcp">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" uid="P:System.Collections.Hashtable.hcp">
          <source>The property is set to a value, but the hash table was created using an <ph id="ph1">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph>.</source>
          <target state="translated">Die Eigenschaft wird auf einen Wert festgelegt, aber die Hashtabelle wurde mit einem <ph id="ph1">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph> erstellt.</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" uid="P:System.Collections.Hashtable.IsFixedSize">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> has a fixed size.</source>
          <target state="translated">Ruft einen Wert ab, der angibt, ob das <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> eine feste Größe aufweist.</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.IsFixedSize">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> has a fixed size; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn das <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> eine feste Größe aufweist, andernfalls <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.IsFixedSize">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Der Standardwert ist <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.IsFixedSize">
          <source>A collection with a fixed size does not allow the addition or removal of elements after the collection is created, but it allows the modification of existing elements.</source>
          <target state="translated">Eine Auflistung mit fester Größe lässt das Hinzufügen oder Entfernen von Elementen nach dem Erstellen der Auflistung nicht zu. Vorhandene Elemente können jedoch geändert werden.</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.IsFixedSize">
          <source>A collection with a fixed size is simply a collection with a wrapper that prevents adding and removing elements; therefore, if changes are made to the underlying collection, including the addition or removal of elements, the fixed-size collection reflects those changes.</source>
          <target state="translated">Eine Auflistung mit fester Größe ist einfach eine Auflistung mit einem Wrapper, der verhindert, dass hinzufügen und Entfernen von Elementen. Deshalb spiegelt die Auflistung mit fester Größe zum Änderungen vorgenommen werden, auf die zugrunde liegende Auflistung, z. B. das Hinzufügen oder Entfernen von Elementen, die Änderungen.</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.IsFixedSize">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" uid="P:System.Collections.Hashtable.IsReadOnly">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> is read-only.</source>
          <target state="translated">Ruft einen Wert ab, der angibt, ob das <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> schreibgeschützt ist.</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.IsReadOnly">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> is read-only; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn das <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> schreibgeschützt ist, andernfalls <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.IsReadOnly">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Der Standardwert ist <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.IsReadOnly">
          <source>A collection that is read-only does not allow the addition, removal, or modification of elements after the collection is created.</source>
          <target state="translated">Eine schreibgeschützte Auflistung gestattet nach dem Erstellen der Auflistung weder das Hinzufügen noch das Ändern oder Entfernen von Elementen.</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.IsReadOnly">
          <source>A collection that is read-only is simply a collection with a wrapper that prevents modifying the collection; therefore, if changes are made to the underlying collection, the read-only collection reflects those changes.</source>
          <target state="translated">Eine Auflistung, die schreibgeschützt ist, ist eine Auflistung mit einem Wrapper, der verhindert, dass die Auflistung ändern; Wenn Änderungen an der zugrunde liegenden Auflistung vorgenommen werden, spiegelt die schreibgeschützte Auflistung daher diese Änderungen wider.</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.IsReadOnly">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" uid="P:System.Collections.Hashtable.IsSynchronized">
          <source>Gets a value indicating whether access to the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> is synchronized (thread safe).</source>
          <target state="translated">Ruft einen Wert ab, der angibt, ob der Zugriff auf die <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> synchronisiert (threadsicher) ist.</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.IsSynchronized">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if access to the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> is synchronized (thread safe); otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn der Zugriff auf das <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> synchronisiert (threadsicher) ist, andernfalls <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.IsSynchronized">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Der Standardwert ist <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.IsSynchronized">
          <source>A <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> can support one writer and multiple readers concurrently.</source>
          <target state="translated">Ein <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> gleichzeitige Unterstützung einen Writer und mehrere Reader.</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.IsSynchronized">
          <source>To support multiple writers, all operations must be done through the wrapper returned by the <ph id="ph1">&lt;xref:System.Collections.Hashtable.Synchronized%2A&gt;</ph> method.</source>
          <target state="translated">Um mehrere Writer zu unterstützen, müssen alle Vorgänge über den Wrapper zurückgegebene ausgeführt werden die <ph id="ph1">&lt;xref:System.Collections.Hashtable.Synchronized%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.IsSynchronized">
          <source>Enumerating through a collection is intrinsically not a thread safe procedure.</source>
          <target state="translated">Einer Auflistung ist systemintern keine threadsichere Prozedur.</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.IsSynchronized">
          <source>Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</source>
          <target state="translated">Selbst wenn eine Auflistung synchronisiert wird, besteht die Möglichkeit, dass andere Threads sie ändern. Dies führt dazu, dass der Enumerator eine Ausnahme auslöst.</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.IsSynchronized">
          <source>To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</source>
          <target state="translated">Um während der Enumeration Threadsicherheit zu gewährleisten, können Sie entweder die Auflistung während der gesamten Enumeration sperren oder die Ausnahmen, die aus von anderen Threads stammenden Änderungen resultieren, abfangen.</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.IsSynchronized">
          <source>The following code example shows how to lock the collection using the <ph id="ph1">&lt;xref:System.Collections.Hashtable.SyncRoot%2A&gt;</ph> during the entire enumeration:</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, das die Auflistung mit Sperren der <ph id="ph1">&lt;xref:System.Collections.Hashtable.SyncRoot%2A&gt;</ph> während der gesamten Enumeration:</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.IsSynchronized">
          <source>The following example shows how to synchronize a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>, determine if a <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> is synchronized, and use a synchronized <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
          <target state="translated">Das folgende Beispiel zeigt die Vorgehensweise beim Synchronisieren einer <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>, zu bestimmen, ob eine <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> synchronisiert ist, und verwenden Sie eine synchronisierte <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" uid="P:System.Collections.Hashtable.Item(System.Object)">
          <source>The key whose value to get or set.</source>
          <target state="translated">Der Schlüssel, dessen Wert abgerufen oder festgelegt werden soll.</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" uid="P:System.Collections.Hashtable.Item(System.Object)">
          <source>Gets or sets the value associated with the specified key.</source>
          <target state="translated">Ruft den Wert ab, der dem angegebenen Schlüssel zugeordnet ist, oder legt diesen fest.</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.Item(System.Object)">
          <source>The value associated with the specified key.</source>
          <target state="translated">Der dem angegebenen Schlüssel zugeordnete Wert.</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.Item(System.Object)">
          <source>If the specified key is not found, attempting to get it returns <ph id="ph1">&lt;see langword="null" /&gt;</ph>, and attempting to set it creates a new element using the specified key.</source>
          <target state="translated">Wenn der angegebene Schlüssel nicht gefunden werden kann, wird beim Abrufen dieses Schlüssels <ph id="ph1">&lt;see langword="null" /&gt;</ph> zurückgegeben. Beim Festlegen wird ein neues Element mit dem angegebenen Schlüssel erstellt.</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.Item(System.Object)">
          <source>This property provides the ability to access a specific element in the collection by using the following syntax: <ph id="ph1">`myCollection[key]`</ph>.</source>
          <target state="translated">Diese Eigenschaft ermöglicht den Zugriff auf ein bestimmtes Element in der Auflistung mithilfe folgender Syntax: <ph id="ph1">`myCollection[key]`</ph>.</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.Item(System.Object)">
          <source>You can also use the <ph id="ph1">&lt;xref:System.Collections.Hashtable.Item%2A&gt;</ph> property to add new elements by setting the value of a key that does not exist in the <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph>; for example, <ph id="ph3">`myCollection["myNonexistentKey"] = myValue`</ph>.</source>
          <target state="translated">Sie können auch die <ph id="ph1">&lt;xref:System.Collections.Hashtable.Item%2A&gt;</ph> zum Hinzufügen neuer Elemente durch Festlegen des Werts eines Schlüssels, die Eigenschaft ist nicht vorhanden, der <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph>, z. B. <ph id="ph3">`myCollection["myNonexistentKey"] = myValue`</ph>.</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.Item(System.Object)">
          <source>However, if the specified key already exists in the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>, setting the <ph id="ph2">&lt;xref:System.Collections.Hashtable.Item%2A&gt;</ph> property overwrites the old value.</source>
          <target state="translated">Jedoch, wenn der angegebene Schlüssel bereits vorhanden ist die <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>wird durch das Festlegen der <ph id="ph2">&lt;xref:System.Collections.Hashtable.Item%2A&gt;</ph> Eigenschaft überschreibt den alten Wert.</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.Item(System.Object)">
          <source>In contrast, the <ph id="ph1">&lt;xref:System.Collections.Hashtable.Add%2A&gt;</ph> method does not modify existing elements.</source>
          <target state="translated">Im Gegensatz dazu die <ph id="ph1">&lt;xref:System.Collections.Hashtable.Add%2A&gt;</ph> Methode vorhandene Elemente nicht geändert.</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.Item(System.Object)">
          <source>A key cannot be <ph id="ph1">`null`</ph>, but a value can be.</source>
          <target state="translated">Ein Schlüssel kann nicht <ph id="ph1">`null`</ph>, aber ein Wert sein kann.</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.Item(System.Object)">
          <source>To distinguish between <ph id="ph1">`null`</ph> that is returned because the specified key is not found and <ph id="ph2">`null`</ph> that is returned because the value of the specified key is <ph id="ph3">`null`</ph>, use the <ph id="ph4">&lt;xref:System.Collections.Hashtable.Contains%2A&gt;</ph> method or the <ph id="ph5">&lt;xref:System.Collections.Hashtable.ContainsKey%2A&gt;</ph> method to determine if the key exists in the list.</source>
          <target state="translated">Zur Unterscheidung <ph id="ph1">`null`</ph> zurückgegeben wird, weil der angegebene Schlüssel nicht gefunden wird und <ph id="ph2">`null`</ph> zurückgegeben wird, weil der Wert des angegebenen Schlüssels ist <ph id="ph3">`null`</ph>, verwenden Sie die <ph id="ph4">&lt;xref:System.Collections.Hashtable.Contains%2A&gt;</ph> Methode oder die <ph id="ph5">&lt;xref:System.Collections.Hashtable.ContainsKey%2A&gt;</ph> Methode, um festzustellen, wo der Schlüssel in der Liste vorhanden ist.</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.Item(System.Object)">
          <source>Retrieving the value of this property is an O(1) operation; setting the property is also an O(1) operation.</source>
          <target state="translated">Das Abrufen des Werts dieser Eigenschaft ist ein o(1)-Vorgang. Festlegen der Eigenschaft ist auch ein o(1)-Vorgang.</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.Item(System.Object)">
          <source>The C# language uses the  keyword to define the indexers instead of implementing the <ph id="ph1">&lt;xref:System.Collections.IList.Item%2A&gt;</ph> property.</source>
          <target state="translated">Die Programmiersprache c# verwendet das Schlüsselwort der Indexer definieren die <ph id="ph1">&lt;xref:System.Collections.IList.Item%2A&gt;</ph> Eigenschaft.</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.Item(System.Object)">
          <source>Visual Basic implements <ph id="ph1">&lt;xref:System.Collections.Hashtable.Item%2A&gt;</ph> as a default property, which provides the same indexing functionality.</source>
          <target state="translated">Visual Basic implementiert <ph id="ph1">&lt;xref:System.Collections.Hashtable.Item%2A&gt;</ph> als Standardeigenschaft und stellt auf diese Weise dieselbe Indizierungsfunktionalität bereit.</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" uid="P:System.Collections.Hashtable.Item(System.Object)">
          <source><ph id="ph1">&lt;paramref name="key" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="key" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" uid="P:System.Collections.Hashtable.Item(System.Object)">
          <source>The property is set and the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> is read-only.</source>
          <target state="translated">Die Eigenschaft wird festgelegt, und <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> ist schreibgeschützt.</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" uid="P:System.Collections.Hashtable.Item(System.Object)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" uid="P:System.Collections.Hashtable.Item(System.Object)">
          <source>The property is set, <ph id="ph1">&lt;paramref name="key" /&gt;</ph> does not exist in the collection, and the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> has a fixed size.</source>
          <target state="translated">Die Eigenschaft wird festgelegt, <ph id="ph1">&lt;paramref name="key" /&gt;</ph> ist in der Auflistung nicht vorhanden, und <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> hat eine feste Größe.</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.KeyEquals(System.Object,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> to compare with <bpt id="p1">&lt;c&gt;</bpt>key<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Das <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph>, das mit <bpt id="p1">&lt;c&gt;</bpt>key<ept id="p1">&lt;/c&gt;</ept> verglichen werden soll.</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.KeyEquals(System.Object,System.Object)">
          <source>The key in the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> to compare with <bpt id="p1">&lt;c&gt;</bpt>item<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Der Schlüssel in der <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>, der mit <bpt id="p1">&lt;c&gt;</bpt>item<ept id="p1">&lt;/c&gt;</ept> verglichen werden soll.</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.KeyEquals(System.Object,System.Object)">
          <source>Compares a specific <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> with a specific key in the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated">Vergleicht ein bestimmtes <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> mit einem bestimmten Schlüssel in <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.KeyEquals(System.Object,System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="item" /&gt;</ph> and <ph id="ph3">&lt;paramref name="key" /&gt;</ph> are equal; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn <ph id="ph2">&lt;paramref name="item" /&gt;</ph> und <ph id="ph3">&lt;paramref name="key" /&gt;</ph> gleich sind, andernfalls <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.KeyEquals(System.Object,System.Object)">
          <source>If the hash table was created with a specific <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementation, this method uses that comparer; that is, <ph id="ph2">&lt;xref:System.Collections.IComparer.Compare%2A&gt;</ph> (<ph id="ph3">`item`</ph>, <ph id="ph4">`key`</ph>).</source>
          <target state="translated">Wenn die Hashtabelle, mit einem bestimmten erstellt wurde <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> Implementierung, die diese Methode verwendet dieses Vergleichs; die, <ph id="ph2">&lt;xref:System.Collections.IComparer.Compare%2A&gt;</ph> (<ph id="ph3">`item`</ph>, <ph id="ph4">`key`</ph>).</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.KeyEquals(System.Object,System.Object)">
          <source>Otherwise, it uses <ph id="ph1">`item.Equals(key)`</ph>.</source>
          <target state="translated">Andernfalls verwendet es <ph id="ph1">`item.Equals(key)`</ph>.</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.KeyEquals(System.Object,System.Object)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Diese Methode ist ein o(1)-Vorgang.</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.KeyEquals(System.Object,System.Object)">
          <source><ph id="ph1">&lt;paramref name="item" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="item" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.KeyEquals(System.Object,System.Object)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.KeyEquals(System.Object,System.Object)">
          <source><ph id="ph1">&lt;paramref name="key" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="key" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" uid="P:System.Collections.Hashtable.Keys">
          <source>Gets an <ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph> containing the keys in the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated">Ruft eine <ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph> ab, die die Schlüssel in der <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> enthält.</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.Keys">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph> containing the keys in the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated">Eine <ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph>, die die Schlüssel in der <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> enthält.</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.Keys">
          <source>The order of the keys in the <ph id="ph1">&lt;xref:System.Collections.ICollection&gt;</ph> is unspecified, but it is the same order as the associated values in the <ph id="ph2">&lt;xref:System.Collections.ICollection&gt;</ph> returned by the <ph id="ph3">&lt;xref:System.Collections.Hashtable.Values%2A&gt;</ph> method.</source>
          <target state="translated">Die Reihenfolge der Schlüssel in der <ph id="ph1">&lt;xref:System.Collections.ICollection&gt;</ph> ist nicht vorgegeben, den zugehörigen Werten in der Reihenfolge ist jedoch die <ph id="ph2">&lt;xref:System.Collections.ICollection&gt;</ph> zurückgegebenes die <ph id="ph3">&lt;xref:System.Collections.Hashtable.Values%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.Keys">
          <source>The returned <ph id="ph1">&lt;xref:System.Collections.ICollection&gt;</ph> is not a static copy; instead, the <ph id="ph2">&lt;xref:System.Collections.ICollection&gt;</ph> refers back to the keys in the original <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
          <target state="translated">Das zurückgegebene <ph id="ph1">&lt;xref:System.Collections.ICollection&gt;</ph> ist keine statische Kopie; stattdessen die <ph id="ph2">&lt;xref:System.Collections.ICollection&gt;</ph> verweist auf die Schlüssel in der ursprünglichen <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.Keys">
          <source>Therefore, changes to the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> continue to be reflected in the <ph id="ph2">&lt;xref:System.Collections.ICollection&gt;</ph>.</source>
          <target state="translated">Daher ändert sich in der <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> im berücksichtigt werden weiterhin die <ph id="ph2">&lt;xref:System.Collections.ICollection&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.Keys">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.OnDeserialization(System.Object)">
          <source>The source of the deserialization event.</source>
          <target state="translated">Die Quelle des Deserialisierungsereignisses.</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.OnDeserialization(System.Object)">
          <source>Implements the <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.ISerializable" /&gt;</ph> interface and raises the deserialization event when the deserialization is complete.</source>
          <target state="translated">Implementiert die <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.ISerializable" /&gt;</ph>-Schnittstelle und löst das Deserialisierungsereignis aus, sobald die Deserialisierung abgeschlossen ist.</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.OnDeserialization(System.Object)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.Hashtable.Count%2A&gt;</ph>.</source>
          <target state="translated">Diese Methode ist eine O (<ph id="ph1">`n`</ph>) Vorgang, wobei <ph id="ph2">`n`</ph> ist <ph id="ph3">&lt;xref:System.Collections.Hashtable.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.OnDeserialization(System.Object)">
          <source>Because serializing and deserializing an enumerator for a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> can cause the elements to become reordered, it is not possible to continue enumeration without calling the <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> method.</source>
          <target state="translated">Da das Serialisieren und Deserialisieren einen Enumerator für eine <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> kann dazu führen, dass die Elemente, die neu angeordnet werden, es ist nicht möglich, Enumeration ohne Aufruf zu fortfahren die <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.OnDeserialization(System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph> object associated with the current <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> is invalid.</source>
          <target state="translated">Das der aktuellen <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph> zugeordnete <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>-Objekt ist ungültig.</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.Remove(System.Object)">
          <source>The key of the element to remove.</source>
          <target state="translated">Der Schlüssel des zu entfernenden Elements.</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.Remove(System.Object)">
          <source>Removes the element with the specified key from the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated">Entfernt das Element mit dem angegebenen Schlüssel aus dem <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Remove(System.Object)">
          <source>If the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> does not contain an element with the specified key, the <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> remains unchanged.</source>
          <target state="translated">Wenn die <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> enthält ein Element mit dem angegebenen Schlüssel keine der <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> bleibt unverändert.</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Remove(System.Object)">
          <source>No exception is thrown.</source>
          <target state="translated">Es werden keine Ausnahmen ausgelöst.</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Remove(System.Object)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Diese Methode ist ein o(1)-Vorgang.</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Remove(System.Object)">
          <source>The following example shows how to remove elements from the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
          <target state="translated">Das folgende Beispiel zeigt die Vorgehensweise beim Entfernen von Elementen aus der <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.Remove(System.Object)">
          <source><ph id="ph1">&lt;paramref name="key" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="key" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.Remove(System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> is read-only.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> ist schreibgeschützt.</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.Remove(System.Object)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.Remove(System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> has a fixed size.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> hat eine feste Größe.</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> to synchronize.</source>
          <target state="translated">Die <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>, die synchronisiert werden soll.</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)">
          <source>Returns a synchronized (thread-safe) wrapper for the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated">Gibt einen synchronisierten (threadsicheren) Wrapper für die <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> zurück.</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)">
          <source>A synchronized (thread-safe) wrapper for the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated">Ein synchronisierter (threadsicherer) Wrapper für die <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Hashtable.Synchronized%2A&gt;</ph> method is thread safe for multiple readers and writers.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Collections.Hashtable.Synchronized%2A&gt;</ph> Methode ist threadsicher, die für mehrere Reader und Writer.</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)">
          <source>Furthermore, the synchronized wrapper ensures that there is only one writer writing at a time.</source>
          <target state="translated">Darüber hinaus die synchronisierte Wrapper wird sichergestellt, dass es nur einen Writer, die zu einem Zeitpunkt schreiben.</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)">
          <source>Enumerating through a collection is intrinsically not a thread-safe procedure.</source>
          <target state="translated">Die Enumeration einer Auflistung ist systemintern keine threadsichere Prozedur.</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)">
          <source>Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</source>
          <target state="translated">Selbst wenn eine Auflistung synchronisiert wird, besteht die Möglichkeit, dass andere Threads sie ändern. Dies führt dazu, dass der Enumerator eine Ausnahme auslöst.</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)">
          <source>To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</source>
          <target state="translated">Um während der Enumeration Threadsicherheit zu gewährleisten, können Sie entweder die Auflistung während der gesamten Enumeration sperren oder die Ausnahmen, die aus von anderen Threads stammenden Änderungen resultieren, abfangen.</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)">
          <source>The following code example shows how to lock the collection using the <ph id="ph1">&lt;xref:System.Collections.Hashtable.SyncRoot%2A&gt;</ph> during the entire enumeration:</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, das die Auflistung mit Sperren der <ph id="ph1">&lt;xref:System.Collections.Hashtable.SyncRoot%2A&gt;</ph> während der gesamten Enumeration:</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Diese Methode ist ein o(1)-Vorgang.</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)">
          <source>The following example shows how to synchronize a <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>, determine if a <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> is synchronized, and use a synchronized <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
          <target state="translated">Das folgende Beispiel zeigt die Vorgehensweise beim Synchronisieren einer <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>, zu bestimmen, ob eine <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> synchronisiert ist, und verwenden Sie eine synchronisierte <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)">
          <source><ph id="ph1">&lt;paramref name="table" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="table" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" uid="P:System.Collections.Hashtable.SyncRoot">
          <source>Gets an object that can be used to synchronize access to the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated">Ruft ein Objekt ab, mit dem der Zugriff auf <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> synchronisiert werden kann.</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.SyncRoot">
          <source>An object that can be used to synchronize access to the <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated">Ein Objekt, mit dem der Zugriff auf die <ph id="ph1">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> synchronisiert werden kann.</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.SyncRoot">
          <source>To create a synchronized version of the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Collections.Hashtable.Synchronized%2A&gt;</ph> method.</source>
          <target state="translated">Eine synchronisierte Version der Erstellung der <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>, verwenden Sie die <ph id="ph2">&lt;xref:System.Collections.Hashtable.Synchronized%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.SyncRoot">
          <source>However, derived classes can provide their own synchronized version of the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> using the <ph id="ph2">&lt;xref:System.Collections.Hashtable.SyncRoot%2A&gt;</ph> property.</source>
          <target state="translated">Abgeleitete Klassen können jedoch eigene synchronisierte Version der Bereitstellen der <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> mithilfe der <ph id="ph2">&lt;xref:System.Collections.Hashtable.SyncRoot%2A&gt;</ph> Eigenschaft.</target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.SyncRoot">
          <source>The synchronizing code must perform operations on the <ph id="ph1">&lt;xref:System.Collections.Hashtable.SyncRoot%2A&gt;</ph> of the <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph>, not directly on the <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph> .</source>
          <target state="translated">Die Synchronisierungscode dürfen Vorgänge auf die <ph id="ph1">&lt;xref:System.Collections.Hashtable.SyncRoot%2A&gt;</ph> von der <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph>, nicht direkt auf die <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph> .</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.SyncRoot">
          <source>This ensures proper operation of collections that are derived from other objects.</source>
          <target state="translated">Dies gewährleistet die einwandfreie Funktion von Auflistungen, die von anderen Objekten abgeleitet sind.</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.SyncRoot">
          <source>Specifically, it maintains proper synchronization with other threads that might be simultaneously modifying the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> object.</source>
          <target state="translated">Es Auflistungsinstanz ordnungsgemäße Synchronisierung mit anderen Threads, die gleichzeitig eventuell die <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> Objekt.</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.SyncRoot">
          <source>Enumerating through a collection is intrinsically not a thread safe procedure.</source>
          <target state="translated">Einer Auflistung ist systemintern keine threadsichere Prozedur.</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.SyncRoot">
          <source>Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</source>
          <target state="translated">Selbst wenn eine Auflistung synchronisiert wird, besteht die Möglichkeit, dass andere Threads sie ändern. Dies führt dazu, dass der Enumerator eine Ausnahme auslöst.</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.SyncRoot">
          <source>To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</source>
          <target state="translated">Um während der Enumeration Threadsicherheit zu gewährleisten, können Sie entweder die Auflistung während der gesamten Enumeration sperren oder die Ausnahmen, die aus von anderen Threads stammenden Änderungen resultieren, abfangen.</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.SyncRoot">
          <source>The following code example shows how to lock the collection using the <ph id="ph1">&lt;xref:System.Collections.Hashtable.SyncRoot%2A&gt;</ph> during the entire enumeration:</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, das die Auflistung mit Sperren der <ph id="ph1">&lt;xref:System.Collections.Hashtable.SyncRoot%2A&gt;</ph> während der gesamten Enumeration:</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator">
          <source>Returns an enumerator that iterates through a collection.</source>
          <target state="translated">Gibt einen Enumerator zurück, der eine Auflistung durchläuft.</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" uid="M:System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.IEnumerator" /&gt;</ph> that can be used to iterate through the collection.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Collections.IEnumerator" /&gt;</ph>, der zum Durchlaufen der Auflistung verwendet werden kann.</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator">
          <source>[Visual Basic, C#]</source>
          <target state="translated">[Visual Basic, c#]</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator">
          <source>The <ph id="ph1">`foreach`</ph> statement of the C# language (<ph id="ph2">`for each`</ph> in Visual Basic) hides the complexity of the enumerators.</source>
          <target state="translated">Die <ph id="ph1">`foreach`</ph>-Anweisung der Programmiersprache C# (<ph id="ph2">`for each`</ph> in Visual Basic) verbirgt die Komplexität der Enumeratoren.</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator">
          <source>Therefore, using <ph id="ph1">`foreach`</ph> is recommended, instead of directly manipulating the enumerator.</source>
          <target state="translated">Daher empfiehlt es sich, <ph id="ph1">`foreach`</ph> zu verwenden und den Enumerator nicht direkt zu ändern.</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator">
          <source>Enumerators can be used to read the data in the collection, but they cannot be used to modify the underlying collection.</source>
          <target state="translated">Mit Enumeratoren können die Daten in der Auflistung zwar gelesen, jedoch nicht zum Ändern der zugrunde liegenden Auflistung verwendet werden.</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator">
          <source>Initially, the enumerator is positioned before the first element in the collection.</source>
          <target state="translated">Zu Beginn wird der Enumerator vor das erste Element in der Auflistung positioniert.</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator">
          <source><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> also brings the enumerator back to this position.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> setzt den Enumerator ebenfalls auf diese Position zurück.</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator">
          <source>At this position, calling <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> throws an exception.</source>
          <target state="translated">An dieser position Aufrufen <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> löst eine Ausnahme aus.</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator">
          <source>Therefore, you must call <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> to advance the enumerator to the first element of the collection before reading the value of <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph>.</source>
          <target state="translated">Daher muss der Enumerator durch einen Aufruf von <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> auf das erste Element der Auflistung gesetzt werden, bevor der Wert von <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> gelesen werden kann.</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator">
          <source><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> returns the same object until either <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> is called.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> gibt solange dasselbe Objekt zurück, bis <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> oder <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> aufgerufen wird.</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator">
          <source><ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> sets <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> to the next element.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> legt <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> auf das nächste Element fest.</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator">
          <source>If <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> passes the end of the collection, the enumerator is positioned after the last element in the collection and <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> returns <ph id="ph3">`false`</ph>.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> übergibt am Ende der Auflistung der Enumerator hinter dem letzten Element in der Auflistung positioniert ist und <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> gibt <ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator">
          <source>When the enumerator is at this position, subsequent calls to <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> also return <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Wenn der Enumerator ist an dieser Position ist nachfolgende Aufrufe <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> auch zurückgeben <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator">
          <source>If the last call to <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> returned <ph id="ph2">`false`</ph>, calling <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> throws an exception.</source>
          <target state="translated">Wenn der letzte Aufruf <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> zurückgegebene <ph id="ph2">`false`</ph>Aufrufen <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> löst eine Ausnahme aus.</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator">
          <source>To set <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> to the first element of the collection again, you can call <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> followed by <ph id="ph3">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph>.</source>
          <target state="translated">Um <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> wieder auf das erste Element der Auflistung festzulegen, können Sie <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> gefolgt von <ph id="ph3">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> aufrufen.</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator">
          <source>An enumerator remains valid as long as the collection remains unchanged.</source>
          <target state="translated">Ein Enumerator bleibt gültig, solange die Auflistung unverändert ist.</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator">
          <source>If changes are made to the collection, such as adding, modifying, or deleting elements, the enumerator can be invalidated and the next call to <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> throws an <ph id="ph3">&lt;xref:System.InvalidOperationException&gt;</ph>.</source>
          <target state="translated">Wenn die Änderungen werden auf die Auflistung, z. B. das Hinzufügen, ändern oder Löschen von Elementen, kann der Enumerator ungültig werden und der nächste Aufruf von <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> löst eine <ph id="ph3">&lt;xref:System.InvalidOperationException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator">
          <source>If the collection is modified between <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> returns the element that it is set to, even if the enumerator is already invalidated.</source>
          <target state="translated">Wenn die Auflistung, zwischen geändert wird <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> gibt das Element, das auf festgelegt, wird, auch wenn der Enumerator bereits ungültig ist.</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator">
          <source>The enumerator does not have exclusive access to the collection; therefore, enumerating through a collection is intrinsically not a thread safe procedure.</source>
          <target state="translated">Der Enumerator hat keinen exklusiven Zugriff auf die Auflistung. Daher ist die Enumeration einer Auflistung systemintern keine threadsichere Prozedur.</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator">
          <source>Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</source>
          <target state="translated">Selbst wenn eine Auflistung synchronisiert wird, besteht die Möglichkeit, dass andere Threads sie ändern. Dies führt dazu, dass der Enumerator eine Ausnahme auslöst.</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator">
          <source>To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</source>
          <target state="translated">Um während der Enumeration Threadsicherheit zu gewährleisten, können Sie entweder die Auflistung während der gesamten Enumeration sperren oder die Ausnahmen, die aus von anderen Threads stammenden Änderungen resultieren, abfangen.</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Diese Methode ist ein o(1)-Vorgang.</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" uid="P:System.Collections.Hashtable.Values">
          <source>Gets an <ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph> containing the values in the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated">Ruft eine <ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph> ab, die die Werte im <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> enthält.</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.Values">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph> containing the values in the <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>.</source>
          <target state="translated">Eine <ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph>, die die Werte im <ph id="ph2">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> enthält.</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.Values">
          <source>The order of the values in the <ph id="ph1">&lt;xref:System.Collections.ICollection&gt;</ph> is unspecified, but it is the same order as the associated keys in the <ph id="ph2">&lt;xref:System.Collections.ICollection&gt;</ph> returned by the <ph id="ph3">&lt;xref:System.Collections.Hashtable.Keys%2A&gt;</ph> method.</source>
          <target state="translated">Die Reihenfolge der Werte in der <ph id="ph1">&lt;xref:System.Collections.ICollection&gt;</ph> ist nicht vorgegeben, aber die zugehörigen Schlüssel in der Reihenfolge der <ph id="ph2">&lt;xref:System.Collections.ICollection&gt;</ph> zurückgegebenes die <ph id="ph3">&lt;xref:System.Collections.Hashtable.Keys%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.Values">
          <source>The returned <ph id="ph1">&lt;xref:System.Collections.ICollection&gt;</ph> is not a static copy; instead, the <ph id="ph2">&lt;xref:System.Collections.ICollection&gt;</ph> refers back to the values in the original <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
          <target state="translated">Das zurückgegebene <ph id="ph1">&lt;xref:System.Collections.ICollection&gt;</ph> ist keine statische Kopie; stattdessen die <ph id="ph2">&lt;xref:System.Collections.ICollection&gt;</ph> verweist auf die Werte in der ursprünglichen <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.Values">
          <source>Therefore, changes to the <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> continue to be reflected in the <ph id="ph2">&lt;xref:System.Collections.ICollection&gt;</ph>.</source>
          <target state="translated">Daher ändert sich in der <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> im berücksichtigt werden weiterhin die <ph id="ph2">&lt;xref:System.Collections.ICollection&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Hashtable.Values">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>