<Type Name="Stack" FullName="System.Collections.Stack">
  <Metadata><Meta Name="ms.openlocfilehash" Value="127b23e75cd19e787bb8388b59a631f38c696646" /><Meta Name="ms.sourcegitcommit" Value="7b48428cbeb3a3c0221a3a096013b2659d01348c" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="08/04/2019" /><Meta Name="ms.locfileid" Value="68776147" /></Metadata><TypeSignature Language="C#" Value="public class Stack : ICloneable, System.Collections.ICollection" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Stack extends System.Object implements class System.Collections.ICollection, class System.Collections.IEnumerable, class System.ICloneable" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Stack" />
  <TypeSignature Language="VB.NET" Value="Public Class Stack&#xA;Implements ICloneable, ICollection" />
  <TypeSignature Language="C++ CLI" Value="public ref class Stack : ICloneable, System::Collections::ICollection" />
  <TypeSignature Language="F#" Value="type Stack = class&#xA;    interface ICollection&#xA;    interface ICloneable&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Collections.NonGeneric</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Stack/StackDebugView))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="7aef2-101">Stellt eine einfache, nicht generische LIFO (Last-In-First-Out)-Auflistung von Objekten dar.</span><span class="sxs-lookup"><span data-stu-id="7aef2-101">Represents a simple last-in-first-out (LIFO) non-generic collection of objects.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<span data-ttu-id="7aef2-102">Die Kapazität <xref:System.Collections.Stack> eines ist die Anzahl der Elemente, die <xref:System.Collections.Stack> in der enthalten sein können.</span><span class="sxs-lookup"><span data-stu-id="7aef2-102">The capacity of a <xref:System.Collections.Stack> is the number of elements the <xref:System.Collections.Stack> can hold.</span></span> <span data-ttu-id="7aef2-103">Wenn Elemente zu einem <xref:System.Collections.Stack>hinzugefügt werden, wird die Kapazität bei Bedarf durch erneute Zuweisung automatisch erhöht.</span><span class="sxs-lookup"><span data-stu-id="7aef2-103">As elements are added to a <xref:System.Collections.Stack>, the capacity is automatically increased as required through reallocation.</span></span>  

> [!IMPORTANT]
> <span data-ttu-id="7aef2-104">Es wird nicht empfohlen, die- `Stack` Klasse für die neue Entwicklung zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="7aef2-104">We don't recommend that you use the `Stack` class for new development.</span></span> <span data-ttu-id="7aef2-105">Stattdessen wird die Verwendung der generischen <xref:System.Collections.Generic.Stack%601?displayProperty=nameWithType> -Klasse empfohlen.</span><span class="sxs-lookup"><span data-stu-id="7aef2-105">Instead, we recommend that you use the generic <xref:System.Collections.Generic.Stack%601?displayProperty=nameWithType> class.</span></span> <span data-ttu-id="7aef2-106">Weitere Informationen finden Sie unter [nicht generische](https://github.com/dotnet/platform-compat/blob/master/docs/DE0006.md) Auflistungen sollten nicht auf GitHub verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="7aef2-106">For more information, see [Non-generic collections shouldn't be used](https://github.com/dotnet/platform-compat/blob/master/docs/DE0006.md) on GitHub.</span></span>

<span data-ttu-id="7aef2-107">Wenn <xref:System.Collections.Stack.Count%2A> kleiner als die Kapazität des Stapels ist, <xref:System.Collections.Stack.Push%2A> ist ein O (1)-Vorgang.</span><span class="sxs-lookup"><span data-stu-id="7aef2-107">If <xref:System.Collections.Stack.Count%2A> is less than the capacity of the stack, <xref:System.Collections.Stack.Push%2A> is an O(1) operation.</span></span> <span data-ttu-id="7aef2-108">Wenn die Kapazität für das neue Element erweitert werden muss <xref:System.Collections.Stack.Push%2A> , wird ein O (`n`)-Vorgang, bei dem `n` gleich <xref:System.Collections.Stack.Count%2A>ist.</span><span class="sxs-lookup"><span data-stu-id="7aef2-108">If the capacity needs to be increased to accommodate the new element, <xref:System.Collections.Stack.Push%2A> becomes an O(`n`) operation, where `n` is <xref:System.Collections.Stack.Count%2A>.</span></span> <span data-ttu-id="7aef2-109"><xref:System.Collections.Stack.Pop%2A>ist ein O (1)-Vorgang.</span><span class="sxs-lookup"><span data-stu-id="7aef2-109"><xref:System.Collections.Stack.Pop%2A> is an O(1) operation.</span></span>  
  
 <span data-ttu-id="7aef2-110"><xref:System.Collections.Stack>akzeptiert `null` als gültigen-Wert und lässt doppelte Elemente zu.</span><span class="sxs-lookup"><span data-stu-id="7aef2-110"><xref:System.Collections.Stack> accepts `null` as a valid value and allows duplicate elements.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7aef2-111">Im folgenden Beispiel wird gezeigt, wie Sie einem Stapel Werte erstellen und Werte hinzufügen und wie die zugehörigen Werte angezeigt werden.</span><span class="sxs-lookup"><span data-stu-id="7aef2-111">The following example shows how to create and add values to a Stack and how to display its values.</span></span>  
  
 [!code-cpp[Classic Stack Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Stack Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Stack Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Stack Example/CS/source.cs#1)]
 [!code-vb[Classic Stack Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Stack Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="7aef2-112">Öffentliche statische (<see langword="Shared" /> in Visual Basic) Member dieses Typs sind Thread sicher.</span><span class="sxs-lookup"><span data-stu-id="7aef2-112">Public static (<see langword="Shared" /> in Visual Basic) members of this type are thread safe.</span></span> <span data-ttu-id="7aef2-113">Bei Instanzmembern ist die Threadsicherheit nicht gewährleistet.</span><span class="sxs-lookup"><span data-stu-id="7aef2-113">Any instance members are not guaranteed to be thread safe.</span></span>  
  
<span data-ttu-id="7aef2-114">Um die Thread Sicherheit von <see cref="T:System.Collections.Stack" />zu gewährleisten, müssen alle Vorgänge über den von der <see cref="M:System.Collections.Stack.Synchronized(System.Collections.Stack)" /> -Methode zurückgegebenen Wrapper durchgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="7aef2-114">To guarantee the thread safety of the <see cref="T:System.Collections.Stack" />, all operations must be done through the wrapper returned by the <see cref="M:System.Collections.Stack.Synchronized(System.Collections.Stack)" /> method.</span></span>  
  
<span data-ttu-id="7aef2-115">Die Enumeration einer Auflistung ist systemintern keine threadsichere Prozedur.</span><span class="sxs-lookup"><span data-stu-id="7aef2-115">Enumerating through a collection is intrinsically not a thread-safe procedure.</span></span> <span data-ttu-id="7aef2-116">Selbst wenn eine Auflistung synchronisiert wird, besteht die Möglichkeit, dass andere Threads sie ändern. Dies führt dazu, dass der Enumerator eine Ausnahme auslöst.</span><span class="sxs-lookup"><span data-stu-id="7aef2-116">Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</span></span> <span data-ttu-id="7aef2-117">Um während der Enumeration Threadsicherheit zu gewährleisten, können Sie entweder die Auflistung während der gesamten Enumeration sperren oder die Ausnahmen, die aus von anderen Threads stammenden Änderungen resultieren, abfangen.</span><span class="sxs-lookup"><span data-stu-id="7aef2-117">To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</span></span></threadsafe>
    <altmember cref="T:System.Collections.Generic.Stack`1" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7aef2-118">Initialisiert eine neue Instanz der <see cref="T:System.Collections.Stack" />-Klasse.</span><span class="sxs-lookup"><span data-stu-id="7aef2-118">Initializes a new instance of the <see cref="T:System.Collections.Stack" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Stack ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Stack.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Stack();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="7aef2-119">Initialisiert eine neue, leere Instanz der <see cref="T:System.Collections.Stack" />-Klasse, die die Standardanfangskapazität aufweist.</span><span class="sxs-lookup"><span data-stu-id="7aef2-119">Initializes a new instance of the <see cref="T:System.Collections.Stack" /> class that is empty and has the default initial capacity.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7aef2-120">Die Kapazität eines <xref:System.Collections.Stack> ist die Anzahl der Elemente, die der <xref:System.Collections.Stack> enthalten kann.</span><span class="sxs-lookup"><span data-stu-id="7aef2-120">The capacity of a <xref:System.Collections.Stack> is the number of elements that the <xref:System.Collections.Stack> can hold.</span></span> <span data-ttu-id="7aef2-121">Wenn Elemente zu einem <xref:System.Collections.Stack>hinzugefügt werden, wird die Kapazität bei Bedarf automatisch erhöht, indem das interne Array neu zugewiesen wird.</span><span class="sxs-lookup"><span data-stu-id="7aef2-121">As elements are added to a <xref:System.Collections.Stack>, the capacity is automatically increased as required by reallocating the internal array.</span></span>  
  
 <span data-ttu-id="7aef2-122">Wenn die Größe der Auflistung geschätzt werden kann, entfällt beim Angeben der anfänglichen Kapazität das Ausführen einer Reihe von Größenänderung beim Hinzufügen von Elementen zum <xref:System.Collections.Stack>.</span><span class="sxs-lookup"><span data-stu-id="7aef2-122">If the size of the collection can be estimated, specifying the initial capacity eliminates the need to perform a number of resizing operations while adding elements to the <xref:System.Collections.Stack>.</span></span>  
  
 <span data-ttu-id="7aef2-123">Dieser Konstruktor ist ein O (1)-Vorgang.</span><span class="sxs-lookup"><span data-stu-id="7aef2-123">This constructor is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Stack (System.Collections.ICollection col);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.ICollection col) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Stack.#ctor(System.Collections.ICollection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (col As ICollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Stack(System::Collections::ICollection ^ col);" />
      <MemberSignature Language="F#" Value="new System.Collections.Stack : System.Collections.ICollection -&gt; System.Collections.Stack" Usage="new System.Collections.Stack col" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="col" Type="System.Collections.ICollection" />
      </Parameters>
      <Docs>
        <param name="col"><span data-ttu-id="7aef2-124">Die <see cref="T:System.Collections.ICollection" />, aus der Elemente kopiert werden sollen.</span><span class="sxs-lookup"><span data-stu-id="7aef2-124">The <see cref="T:System.Collections.ICollection" /> to copy elements from.</span></span></param>
        <summary><span data-ttu-id="7aef2-125">Initialisiert eine neue Instanz der <see cref="T:System.Collections.Stack" />-Klasse, die aus der angegebenen Auflistung kopierte Elemente enthält und deren anfängliche Kapazität der Anzahl der kopierten Elemente entspricht.</span><span class="sxs-lookup"><span data-stu-id="7aef2-125">Initializes a new instance of the <see cref="T:System.Collections.Stack" /> class that contains elements copied from the specified collection and has the same initial capacity as the number of elements copied.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7aef2-126">Die Kapazität eines <xref:System.Collections.Stack> ist die Anzahl der Elemente, die der <xref:System.Collections.Stack> enthalten kann.</span><span class="sxs-lookup"><span data-stu-id="7aef2-126">The capacity of a <xref:System.Collections.Stack> is the number of elements that the <xref:System.Collections.Stack> can hold.</span></span> <span data-ttu-id="7aef2-127">Wenn Elemente zu einem <xref:System.Collections.Stack>hinzugefügt werden, wird die Kapazität bei Bedarf automatisch erhöht, indem das interne Array neu zugewiesen wird.</span><span class="sxs-lookup"><span data-stu-id="7aef2-127">As elements are added to a <xref:System.Collections.Stack>, the capacity is automatically increased as required by reallocating the internal array.</span></span>  
  
 <span data-ttu-id="7aef2-128">Wenn die Größe der Auflistung geschätzt werden kann, entfällt beim Angeben der anfänglichen Kapazität das Ausführen einer Reihe von Größenänderung beim Hinzufügen von Elementen zum <xref:System.Collections.Stack>.</span><span class="sxs-lookup"><span data-stu-id="7aef2-128">If the size of the collection can be estimated, specifying the initial capacity eliminates the need to perform a number of resizing operations while adding elements to the <xref:System.Collections.Stack>.</span></span>  
  
 <span data-ttu-id="7aef2-129">Die-Elemente werden <xref:System.Collections.Stack> in derselben Reihenfolge, in der Sie <xref:System.Collections.IEnumerator> vom <xref:System.Collections.ICollection>gelesen werden, in die kopiert.</span><span class="sxs-lookup"><span data-stu-id="7aef2-129">The elements are copied onto the <xref:System.Collections.Stack> in the same order they are read by the <xref:System.Collections.IEnumerator> of the <xref:System.Collections.ICollection>.</span></span>  
  
 <span data-ttu-id="7aef2-130">Dieser Konstruktor ist ein O (`n`)-Vorgang, `n` wobei die Anzahl der Elemente in `col`ist.</span><span class="sxs-lookup"><span data-stu-id="7aef2-130">This constructor is an O(`n`) operation, where `n` is the number of elements in `col`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7aef2-131"><paramref name="col" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="7aef2-131"><paramref name="col" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Stack (int initialCapacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCapacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Stack.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCapacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Stack(int initialCapacity);" />
      <MemberSignature Language="F#" Value="new System.Collections.Stack : int -&gt; System.Collections.Stack" Usage="new System.Collections.Stack initialCapacity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCapacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="initialCapacity"><span data-ttu-id="7aef2-132">Die anfängliche Anzahl von Elementen, die das <see cref="T:System.Collections.Stack" /> enthalten kann.</span><span class="sxs-lookup"><span data-stu-id="7aef2-132">The initial number of elements that the <see cref="T:System.Collections.Stack" /> can contain.</span></span></param>
        <summary><span data-ttu-id="7aef2-133">Initialisiert eine neue, leere Instanz der <see cref="T:System.Collections.Stack" />-Klasse, die über die angegebene anfängliche Kapazität, mindestens aber über die anfängliche Standardkapazität verfügt.</span><span class="sxs-lookup"><span data-stu-id="7aef2-133">Initializes a new instance of the <see cref="T:System.Collections.Stack" /> class that is empty and has the specified initial capacity or the default initial capacity, whichever is greater.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7aef2-134">Die Kapazität eines <xref:System.Collections.Stack> ist die Anzahl der Elemente, die der <xref:System.Collections.Stack> enthalten kann.</span><span class="sxs-lookup"><span data-stu-id="7aef2-134">The capacity of a <xref:System.Collections.Stack> is the number of elements that the <xref:System.Collections.Stack> can hold.</span></span> <span data-ttu-id="7aef2-135">Wenn Elemente zu einem <xref:System.Collections.Stack>hinzugefügt werden, wird die Kapazität bei Bedarf automatisch erhöht, indem das interne Array neu zugewiesen wird.</span><span class="sxs-lookup"><span data-stu-id="7aef2-135">As elements are added to a <xref:System.Collections.Stack>, the capacity is automatically increased as required by reallocating the internal array.</span></span>  
  
 <span data-ttu-id="7aef2-136">Wenn die Größe der Auflistung geschätzt werden kann, entfällt beim Angeben der anfänglichen Kapazität das Ausführen einer Reihe von Größenänderung beim Hinzufügen von Elementen zum <xref:System.Collections.Stack>.</span><span class="sxs-lookup"><span data-stu-id="7aef2-136">If the size of the collection can be estimated, specifying the initial capacity eliminates the need to perform a number of resizing operations while adding elements to the <xref:System.Collections.Stack>.</span></span>  
  
 <span data-ttu-id="7aef2-137">Dieser Konstruktor ist ein O (`n`)-Vorgang, `n` bei `initialCapacity`dem gleich ist.</span><span class="sxs-lookup"><span data-stu-id="7aef2-137">This constructor is an O(`n`) operation, where `n` is `initialCapacity`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="7aef2-138"><paramref name="initialCapacity" /> ist kleiner als Null.</span><span class="sxs-lookup"><span data-stu-id="7aef2-138"><paramref name="initialCapacity" /> is less than zero.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public virtual void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Stack.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberSignature Language="F#" Value="abstract member Clear : unit -&gt; unit&#xA;override this.Clear : unit -&gt; unit" Usage="stack.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="7aef2-139">Entfernt alle Objekte aus dem <see cref="T:System.Collections.Stack" />.</span><span class="sxs-lookup"><span data-stu-id="7aef2-139">Removes all objects from the <see cref="T:System.Collections.Stack" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7aef2-140"><xref:System.Collections.Stack.Count%2A>wird auf 0 (null) festgelegt, und Verweise auf andere Objekte von Elementen der Auflistung werden ebenfalls freigegeben.</span><span class="sxs-lookup"><span data-stu-id="7aef2-140"><xref:System.Collections.Stack.Count%2A> is set to zero, and references to other objects from elements of the collection are also released.</span></span>  
  
 <span data-ttu-id="7aef2-141">Diese Methode ist ein O (`n`)-Vorgang, `n` bei <xref:System.Collections.Stack.Count%2A>dem gleich ist.</span><span class="sxs-lookup"><span data-stu-id="7aef2-141">This method is an O(`n`) operation, where `n` is <xref:System.Collections.Stack.Count%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7aef2-142">Im folgenden Beispiel wird gezeigt, wie Sie die Werte von <xref:System.Collections.Stack>löschen.</span><span class="sxs-lookup"><span data-stu-id="7aef2-142">The following example shows how to clear the values of the <xref:System.Collections.Stack>.</span></span>  
  
 [!code-cpp[Classic Stack.Clear Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Stack.Clear Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Stack.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Stack.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic Stack.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Stack.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Stack.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="stack.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="7aef2-143">Erstellt eine flache Kopie von <see cref="T:System.Collections.Stack" />.</span><span class="sxs-lookup"><span data-stu-id="7aef2-143">Creates a shallow copy of the <see cref="T:System.Collections.Stack" />.</span></span></summary>
        <returns><span data-ttu-id="7aef2-144">Eine flache Kopie von <see cref="T:System.Collections.Stack" />.</span><span class="sxs-lookup"><span data-stu-id="7aef2-144">A shallow copy of the <see cref="T:System.Collections.Stack" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7aef2-145">Bei einer flachen Kopie einer Auflistung werden nur die Elemente der Auflistung kopiert, unabhängig davon, ob es sich um Verweis Typen oder Werttypen handelt, die Objekte, auf die die Verweise verweisen, werden jedoch nicht kopiert.</span><span class="sxs-lookup"><span data-stu-id="7aef2-145">A shallow copy of a collection copies only the elements of the collection, whether they are reference types or value types, but it does not copy the objects that the references refer to.</span></span> <span data-ttu-id="7aef2-146">Die Verweise in der neuen Auflistung zeigen auf dieselben Objekte, auf die die Verweise in der ursprünglichen Auflistung verweisen.</span><span class="sxs-lookup"><span data-stu-id="7aef2-146">The references in the new collection point to the same objects that the references in the original collection point to.</span></span>  
  
 <span data-ttu-id="7aef2-147">Im Gegensatz dazu kopiert eine tiefe Kopie einer Auflistung die Elemente und alle Elemente, die direkt oder indirekt von den Elementen referenziert werden.</span><span class="sxs-lookup"><span data-stu-id="7aef2-147">In contrast, a deep copy of a collection copies the elements and everything directly or indirectly referenced by the elements.</span></span>  
  
 <span data-ttu-id="7aef2-148">Diese Methode ist ein O (`n`)-Vorgang, `n` bei <xref:System.Collections.Stack.Count%2A>dem gleich ist.</span><span class="sxs-lookup"><span data-stu-id="7aef2-148">This method is an O(`n`) operation, where `n` is <xref:System.Collections.Stack.Count%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public virtual bool Contains (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Stack.Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Contains (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="abstract member Contains : obj -&gt; bool&#xA;override this.Contains : obj -&gt; bool" Usage="stack.Contains obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="7aef2-149">Das im <see cref="T:System.Collections.Stack" /> zu suchende Objekt.</span><span class="sxs-lookup"><span data-stu-id="7aef2-149">The object to locate in the <see cref="T:System.Collections.Stack" />.</span></span> <span data-ttu-id="7aef2-150">Der Wert kann <see langword="null" /> sein.</span><span class="sxs-lookup"><span data-stu-id="7aef2-150">The value can be <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="7aef2-151">Bestimmt, ob sich ein Element in <see cref="T:System.Collections.Stack" /> befindet.</span><span class="sxs-lookup"><span data-stu-id="7aef2-151">Determines whether an element is in the <see cref="T:System.Collections.Stack" />.</span></span></summary>
        <returns><span data-ttu-id="7aef2-152"><see langword="true" />, wenn das <paramref name="obj" /> in der <see cref="T:System.Collections.Stack" /> gefunden wird, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="7aef2-152"><see langword="true" />, if <paramref name="obj" /> is found in the <see cref="T:System.Collections.Stack" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7aef2-153">Diese Methode bestimmt Gleichheit durch Aufrufen der <xref:System.Object.Equals%2A?displayProperty=nameWithType> -Methode.</span><span class="sxs-lookup"><span data-stu-id="7aef2-153">This method determines equality by calling the <xref:System.Object.Equals%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="7aef2-154">Diese Methode führt eine lineare Suche aus. Daher ist diese Methode ein O (`n`)-Vorgang, bei dem <xref:System.Collections.Stack.Count%2A> `n` gleich ist.</span><span class="sxs-lookup"><span data-stu-id="7aef2-154">This method performs a linear search; therefore, this method is an O(`n`) operation, where `n` is <xref:System.Collections.Stack.Count%2A>.</span></span>  
  
 <span data-ttu-id="7aef2-155">Beginnend mit dem .NET Framework 2,0, testet diese Methode auf Gleichheit, indem das `obj` -Argument an <xref:System.Object.Equals%2A> die-Methode der einzelnen Objekte in der Auflistung übergeben wird.</span><span class="sxs-lookup"><span data-stu-id="7aef2-155">Starting with the .NET Framework 2.0, this method tests for equality by passing the `obj` argument to the <xref:System.Object.Equals%2A> method of individual objects in the collection.</span></span> <span data-ttu-id="7aef2-156">In früheren Versionen der .NET Framework wurde diese Bestimmung mithilfe der Übergabe der einzelnen Elemente in der Auflistung an die <xref:System.Object.Equals%2A> -Methode `obj` des-Arguments vorgenommen.</span><span class="sxs-lookup"><span data-stu-id="7aef2-156">In the earlier versions of the .NET Framework, this determination was made by using passing the individual items in the collection to the <xref:System.Object.Equals%2A> method of the `obj` argument.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations.md"><span data-ttu-id="7aef2-157">Durchführen kulturunabhängiger Zeichenfolgenoperationen</span><span class="sxs-lookup"><span data-stu-id="7aef2-157">Performing Culture-Insensitive String Operations</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public virtual void CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Stack.CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(Array ^ array, int index);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : Array * int -&gt; unit&#xA;override this.CopyTo : Array * int -&gt; unit" Usage="stack.CopyTo (array, index)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="7aef2-158">Das eindimensionale <see cref="T:System.Array" />, das das Ziel der aus der <see cref="T:System.Collections.Stack" /> kopierten Elemente ist.</span><span class="sxs-lookup"><span data-stu-id="7aef2-158">The one-dimensional <see cref="T:System.Array" /> that is the destination of the elements copied from <see cref="T:System.Collections.Stack" />.</span></span> <span data-ttu-id="7aef2-159">Für das <see cref="T:System.Array" /> muss eine nullbasierte Indizierung verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="7aef2-159">The <see cref="T:System.Array" /> must have zero-based indexing.</span></span></param>
        <param name="index"><span data-ttu-id="7aef2-160">Der nullbasierte Index im <paramref name="array" />, bei dem der Kopiervorgang beginnt.</span><span class="sxs-lookup"><span data-stu-id="7aef2-160">The zero-based index in <paramref name="array" /> at which copying begins.</span></span></param>
        <summary><span data-ttu-id="7aef2-161">Kopiert <see cref="T:System.Collections.Stack" /> in ein vorhandenes eindimensionales <see cref="T:System.Array" />, beginnend beim angegebenen Arrayindex.</span><span class="sxs-lookup"><span data-stu-id="7aef2-161">Copies the <see cref="T:System.Collections.Stack" /> to an existing one-dimensional <see cref="T:System.Array" />, starting at the specified array index.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7aef2-162">Die Elemente werden auf das Array in der LIFO-Reihenfolge (Last-in-First-Out) kopiert, ähnlich der Reihenfolge der Elemente, die durch eine Abfolge <xref:System.Collections.Stack.Pop%2A>von Aufrufen an zurückgegeben werden.</span><span class="sxs-lookup"><span data-stu-id="7aef2-162">The elements are copied onto the array in last-in-first-out (LIFO) order, similar to the order of the elements returned by a succession of calls to <xref:System.Collections.Stack.Pop%2A>.</span></span>  
  
 <span data-ttu-id="7aef2-163">Diese Methode ist ein O (`n`)-Vorgang, `n` bei <xref:System.Collections.Stack.Count%2A>dem gleich ist.</span><span class="sxs-lookup"><span data-stu-id="7aef2-163">This method is an O(`n`) operation, where `n` is <xref:System.Collections.Stack.Count%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7aef2-164">Im folgenden Beispiel wird gezeigt, wie ein <xref:System.Collections.Stack> in ein eindimensionales Array kopiert wird.</span><span class="sxs-lookup"><span data-stu-id="7aef2-164">The following example shows how to copy a <xref:System.Collections.Stack> into a one-dimensional array.</span></span>  
  
 [!code-cpp[Classic Stack.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Stack.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Stack.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Stack.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic Stack.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Stack.CopyTo Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7aef2-165"><paramref name="array" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="7aef2-165"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="7aef2-166"><paramref name="index" /> ist kleiner als Null.</span><span class="sxs-lookup"><span data-stu-id="7aef2-166"><paramref name="index" /> is less than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7aef2-167"><paramref name="array" /> ist mehrdimensional.</span><span class="sxs-lookup"><span data-stu-id="7aef2-167"><paramref name="array" /> is multidimensional.</span></span>  
  
<span data-ttu-id="7aef2-168">- oder -</span><span class="sxs-lookup"><span data-stu-id="7aef2-168">-or-</span></span> 
<span data-ttu-id="7aef2-169">Die Anzahl der Elemente in der Quell-<see cref="T:System.Collections.Stack" /> ist größer als der verfügbare Platz vom <paramref name="index" /> bis zum Ende des Ziel-<paramref name="array" />s.</span><span class="sxs-lookup"><span data-stu-id="7aef2-169">The number of elements in the source <see cref="T:System.Collections.Stack" /> is greater than the available space from <paramref name="index" /> to the end of the destination <paramref name="array" />.</span></span></exception>
        <exception cref="T:System.InvalidCastException"><span data-ttu-id="7aef2-170">Der Typ der Quell-<see cref="T:System.Collections.Stack" /> kann nicht automatisch in den Typ des Ziel-<paramref name="array" /> umgewandelt werden.</span><span class="sxs-lookup"><span data-stu-id="7aef2-170">The type of the source <see cref="T:System.Collections.Stack" /> cannot be cast automatically to the type of the destination <paramref name="array" />.</span></span></exception>
        <altmember cref="M:System.Collections.Stack.ToArray" />
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public virtual int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Stack.Count" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Collections.Stack.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="7aef2-171">Ruft die Anzahl der Elemente ab, die in <see cref="T:System.Collections.Stack" /> enthalten sind.</span><span class="sxs-lookup"><span data-stu-id="7aef2-171">Gets the number of elements contained in the <see cref="T:System.Collections.Stack" />.</span></span></summary>
        <value><span data-ttu-id="7aef2-172">Die Anzahl der Elemente, die in <see cref="T:System.Collections.Stack" /> enthalten sind.</span><span class="sxs-lookup"><span data-stu-id="7aef2-172">The number of elements contained in the <see cref="T:System.Collections.Stack" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7aef2-173">Die Kapazität ist die Anzahl der Elemente, die <xref:System.Collections.Stack> von der gespeichert werden können.</span><span class="sxs-lookup"><span data-stu-id="7aef2-173">The capacity is the number of elements that the <xref:System.Collections.Stack> can store.</span></span> <span data-ttu-id="7aef2-174"><xref:System.Collections.Stack.Count%2A>die Anzahl der Elemente, die tatsächlich in der <xref:System.Collections.Stack>sind.</span><span class="sxs-lookup"><span data-stu-id="7aef2-174"><xref:System.Collections.Stack.Count%2A> is the number of elements that are actually in the <xref:System.Collections.Stack>.</span></span>  
  
 <span data-ttu-id="7aef2-175">Die Kapazität ist immer größer oder gleich <xref:System.Collections.Stack.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="7aef2-175">The capacity is always greater than or equal to <xref:System.Collections.Stack.Count%2A>.</span></span> <span data-ttu-id="7aef2-176">Wenn <xref:System.Collections.Stack.Count%2A> die Kapazität beim Hinzufügen von Elementen überschreitet, wird die Kapazität automatisch erhöht, indem das interne Array neu zugewiesen wird, bevor die alten Elemente kopiert und die neuen Elemente hinzugefügt werden.</span><span class="sxs-lookup"><span data-stu-id="7aef2-176">If <xref:System.Collections.Stack.Count%2A> exceeds the capacity while adding elements, the capacity is automatically increased by reallocating the internal array before copying the old elements and adding the new elements.</span></span>  
  
 <span data-ttu-id="7aef2-177">Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.</span><span class="sxs-lookup"><span data-stu-id="7aef2-177">Retrieving the value of this property is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Stack.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="stack.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="7aef2-178">Gibt einen <see cref="T:System.Collections.IEnumerator" /> für das <see cref="T:System.Collections.Stack" /> zurück.</span><span class="sxs-lookup"><span data-stu-id="7aef2-178">Returns an <see cref="T:System.Collections.IEnumerator" /> for the <see cref="T:System.Collections.Stack" />.</span></span></summary>
        <returns><span data-ttu-id="7aef2-179">Ein <see cref="T:System.Collections.IEnumerator" /> für das <see cref="T:System.Collections.Stack" />.</span><span class="sxs-lookup"><span data-stu-id="7aef2-179">An <see cref="T:System.Collections.IEnumerator" /> for the <see cref="T:System.Collections.Stack" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7aef2-180">[Visual Basic, C#]</span><span class="sxs-lookup"><span data-stu-id="7aef2-180">[Visual Basic, C#]</span></span>  
  
 <span data-ttu-id="7aef2-181">Die `foreach`-Anweisung der Programmiersprache C# (`for each` in Visual Basic) verbirgt die Komplexität der Enumeratoren.</span><span class="sxs-lookup"><span data-stu-id="7aef2-181">The `foreach` statement of the C# language (`for each` in Visual Basic) hides the complexity of the enumerators.</span></span>  <span data-ttu-id="7aef2-182">Daher empfiehlt es sich, `foreach` zu verwenden und den Enumerator nicht direkt zu ändern.</span><span class="sxs-lookup"><span data-stu-id="7aef2-182">Therefore, using `foreach` is recommended, instead of directly manipulating the enumerator.</span></span>  
  
 <span data-ttu-id="7aef2-183">Mit Enumeratoren können die Daten in der Auflistung zwar gelesen, jedoch nicht zum Ändern der zugrunde liegenden Auflistung verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="7aef2-183">Enumerators can be used to read the data in the collection, but they cannot be used to modify the underlying collection.</span></span>  
  
 <span data-ttu-id="7aef2-184">Zu Beginn wird der Enumerator vor das erste Element in der Auflistung positioniert.</span><span class="sxs-lookup"><span data-stu-id="7aef2-184">Initially, the enumerator is positioned before the first element in the collection.</span></span> <span data-ttu-id="7aef2-185"><xref:System.Collections.IEnumerator.Reset%2A> setzt den Enumerator ebenfalls auf diese Position zurück.</span><span class="sxs-lookup"><span data-stu-id="7aef2-185"><xref:System.Collections.IEnumerator.Reset%2A> also brings the enumerator back to this position.</span></span>  <span data-ttu-id="7aef2-186">An dieser Position ist <xref:System.Collections.IEnumerator.Current%2A> nicht definiert.</span><span class="sxs-lookup"><span data-stu-id="7aef2-186">At this position, <xref:System.Collections.IEnumerator.Current%2A> is undefined.</span></span> <span data-ttu-id="7aef2-187">Daher muss der Enumerator durch einen Aufruf von <xref:System.Collections.IEnumerator.MoveNext%2A> auf das erste Element der Auflistung gesetzt werden, bevor der Wert von <xref:System.Collections.IEnumerator.Current%2A> gelesen werden kann.</span><span class="sxs-lookup"><span data-stu-id="7aef2-187">Therefore, you must call <xref:System.Collections.IEnumerator.MoveNext%2A> to advance the enumerator to the first element of the collection before reading the value of <xref:System.Collections.IEnumerator.Current%2A>.</span></span>  
  
 <span data-ttu-id="7aef2-188"><xref:System.Collections.IEnumerator.Current%2A> gibt solange dasselbe Objekt zurück, bis <xref:System.Collections.IEnumerator.MoveNext%2A> oder <xref:System.Collections.IEnumerator.Reset%2A> aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="7aef2-188"><xref:System.Collections.IEnumerator.Current%2A> returns the same object until either <xref:System.Collections.IEnumerator.MoveNext%2A> or <xref:System.Collections.IEnumerator.Reset%2A> is called.</span></span> <span data-ttu-id="7aef2-189"><xref:System.Collections.IEnumerator.MoveNext%2A> legt <xref:System.Collections.IEnumerator.Current%2A> auf das nächste Element fest.</span><span class="sxs-lookup"><span data-stu-id="7aef2-189"><xref:System.Collections.IEnumerator.MoveNext%2A> sets <xref:System.Collections.IEnumerator.Current%2A> to the next element.</span></span>  
  
 <span data-ttu-id="7aef2-190">Wenn <xref:System.Collections.IEnumerator.MoveNext%2A> das Ende der Auflistung übergibt, wird der Enumerator hinter dem letzten Element in der Auflistung platziert, und <xref:System.Collections.IEnumerator.MoveNext%2A> gibt `false` zurück.</span><span class="sxs-lookup"><span data-stu-id="7aef2-190">If <xref:System.Collections.IEnumerator.MoveNext%2A> passes the end of the collection, the enumerator is positioned after the last element in the collection and <xref:System.Collections.IEnumerator.MoveNext%2A> returns `false`.</span></span> <span data-ttu-id="7aef2-191">Wenn sich der Enumerator an dieser Position befindet, geben nachfolgende Aufrufe von <xref:System.Collections.IEnumerator.MoveNext%2A> auch `false` zurück.</span><span class="sxs-lookup"><span data-stu-id="7aef2-191">When the enumerator is at this position, subsequent calls to <xref:System.Collections.IEnumerator.MoveNext%2A> also return `false`.</span></span> <span data-ttu-id="7aef2-192">Wenn der letzte Aufruf <xref:System.Collections.IEnumerator.MoveNext%2A> zurückgegebene `false`, <xref:System.Collections.IEnumerator.Current%2A> ist nicht definiert.</span><span class="sxs-lookup"><span data-stu-id="7aef2-192">If the last call to <xref:System.Collections.IEnumerator.MoveNext%2A> returned `false`, <xref:System.Collections.IEnumerator.Current%2A> is undefined.</span></span> <span data-ttu-id="7aef2-193">Um <xref:System.Collections.IEnumerator.Current%2A> wieder auf das erste Element der Auflistung festzulegen, können Sie <xref:System.Collections.IEnumerator.Reset%2A> gefolgt von <xref:System.Collections.IEnumerator.MoveNext%2A> aufrufen.</span><span class="sxs-lookup"><span data-stu-id="7aef2-193">To set <xref:System.Collections.IEnumerator.Current%2A> to the first element of the collection again, you can call <xref:System.Collections.IEnumerator.Reset%2A> followed by <xref:System.Collections.IEnumerator.MoveNext%2A>.</span></span>  
  
 <span data-ttu-id="7aef2-194">Ein Enumerator bleibt gültig, solange die Auflistung unverändert ist.</span><span class="sxs-lookup"><span data-stu-id="7aef2-194">An enumerator remains valid as long as the collection remains unchanged.</span></span> <span data-ttu-id="7aef2-195">Werden an der Auflistung Änderungen wie z. B. Hinzufügen, Bearbeiten oder Entfernen von Elementen vorgenommen, verliert der Enumerator unwiederbringlich seine Gültigkeit und sein Verhalten ist nicht definiert.</span><span class="sxs-lookup"><span data-stu-id="7aef2-195">If changes are made to the collection, such as adding, modifying, or deleting elements, the enumerator is irrecoverably invalidated and its behavior is undefined.</span></span>  
  
 <span data-ttu-id="7aef2-196">Der Enumerator hat keinen exklusiven Zugriff auf die Auflistung; daher ist die Enumeration einer Auflistung systembedingt kein threadsicheres Verfahren.</span><span class="sxs-lookup"><span data-stu-id="7aef2-196">The enumerator does not have exclusive access to the collection; therefore, enumerating through a collection is intrinsically not a thread-safe procedure.</span></span>  <span data-ttu-id="7aef2-197">Um während der Enumeration Threadsicherheit zu garantieren, können Sie die Auflistung während der gesamten Enumeration sperren.</span><span class="sxs-lookup"><span data-stu-id="7aef2-197">To guarantee thread safety during enumeration, you can lock the collection during the entire enumeration.</span></span>  <span data-ttu-id="7aef2-198">Um den Lese- und Schreibzugriff auf diese Auflistung durch mehrere Threads zuzulassen, müssen Sie eine eigene Synchronisierung implementieren.</span><span class="sxs-lookup"><span data-stu-id="7aef2-198">To allow the collection to be accessed by multiple threads for reading and writing, you must implement your own synchronization.</span></span>  
  
 <span data-ttu-id="7aef2-199">Diese Methode ist ein O (1)-Vorgang.</span><span class="sxs-lookup"><span data-stu-id="7aef2-199">This method is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="IsSynchronized">
      <MemberSignature Language="C#" Value="public virtual bool IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Stack.IsSynchronized" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSynchronized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSynchronized : bool" Usage="System.Collections.Stack.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="7aef2-200">Ruft einen Wert ab, der angibt, ob der Zugriff auf die <see cref="T:System.Collections.Stack" /> synchronisiert (threadsicher) ist.</span><span class="sxs-lookup"><span data-stu-id="7aef2-200">Gets a value indicating whether access to the <see cref="T:System.Collections.Stack" /> is synchronized (thread safe).</span></span></summary>
        <value><span data-ttu-id="7aef2-201"><see langword="true" />, wenn der Zugriff auf die <see cref="T:System.Collections.Stack" /> synchronisiert (threadsicher) ist, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="7aef2-201"><see langword="true" />, if access to the <see cref="T:System.Collections.Stack" /> is synchronized (thread safe); otherwise, <see langword="false" />.</span></span> <span data-ttu-id="7aef2-202">Die Standardeinstellung ist <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="7aef2-202">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7aef2-203">Um die Thread Sicherheit von <xref:System.Collections.Stack>zu gewährleisten, müssen alle Vorgänge über den von der <xref:System.Collections.Stack.Synchronized%2A> -Methode zurückgegebenen Wrapper durchgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="7aef2-203">To guarantee the thread safety of the <xref:System.Collections.Stack>, all operations must be done through the wrapper returned by the <xref:System.Collections.Stack.Synchronized%2A> method.</span></span>  
  
 <span data-ttu-id="7aef2-204">Die Enumeration einer Auflistung ist systemintern keine threadsichere Prozedur.</span><span class="sxs-lookup"><span data-stu-id="7aef2-204">Enumerating through a collection is intrinsically not a thread-safe procedure.</span></span> <span data-ttu-id="7aef2-205">Selbst wenn eine Auflistung synchronisiert wird, besteht die Möglichkeit, dass andere Threads sie ändern. Dies führt dazu, dass der Enumerator eine Ausnahme auslöst.</span><span class="sxs-lookup"><span data-stu-id="7aef2-205">Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</span></span> <span data-ttu-id="7aef2-206">Um während der Enumeration Threadsicherheit zu gewährleisten, können Sie entweder die Auflistung während der gesamten Enumeration sperren oder die Ausnahmen, die aus von anderen Threads stammenden Änderungen resultieren, abfangen.</span><span class="sxs-lookup"><span data-stu-id="7aef2-206">To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</span></span>  
  
 <span data-ttu-id="7aef2-207">Im folgenden Codebeispiel wird veranschaulicht, wie die-Auflistung <xref:System.Collections.Stack.SyncRoot%2A> während der gesamten-Enumeration mithilfe von gesperrt wird.</span><span class="sxs-lookup"><span data-stu-id="7aef2-207">The following code example shows how to lock the collection using the <xref:System.Collections.Stack.SyncRoot%2A> during the entire enumeration.</span></span>  
  
 [!code-cpp[Classic Stack.IsSynchronized Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Stack.IsSynchronized Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Stack.IsSynchronized Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Stack.IsSynchronized Example/CS/source2.cs#2)]
 [!code-vb[Classic Stack.IsSynchronized Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Stack.IsSynchronized Example/VB/source2.vb#2)]  
  
 <span data-ttu-id="7aef2-208">Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.</span><span class="sxs-lookup"><span data-stu-id="7aef2-208">Retrieving the value of this property is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7aef2-209">Im folgenden Beispiel wird gezeigt, wie eine <xref:System.Collections.Stack>synchronisiert wird, ob <xref:System.Collections.Stack> eine synchronisiert wird und wie eine Synchronisierung <xref:System.Collections.Stack>verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="7aef2-209">The following example shows how to synchronize a <xref:System.Collections.Stack>, determine if a <xref:System.Collections.Stack> is synchronized, and use a synchronized <xref:System.Collections.Stack>.</span></span>  
  
 [!code-cpp[Classic Stack.IsSynchronized Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Stack.IsSynchronized Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Stack.IsSynchronized Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Stack.IsSynchronized Example/CS/source.cs#1)]
 [!code-vb[Classic Stack.IsSynchronized Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Stack.IsSynchronized Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public virtual object Peek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Peek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Stack.Peek" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Peek () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Peek();" />
      <MemberSignature Language="F#" Value="abstract member Peek : unit -&gt; obj&#xA;override this.Peek : unit -&gt; obj" Usage="stack.Peek " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="7aef2-210">Gibt das oberste Objekt von <see cref="T:System.Collections.Stack" /> zurück, ohne es zu entfernen.</span><span class="sxs-lookup"><span data-stu-id="7aef2-210">Returns the object at the top of the <see cref="T:System.Collections.Stack" /> without removing it.</span></span></summary>
        <returns><span data-ttu-id="7aef2-211">Das oberste <see cref="T:System.Object" /> von <see cref="T:System.Collections.Stack" />.</span><span class="sxs-lookup"><span data-stu-id="7aef2-211">The <see cref="T:System.Object" /> at the top of the <see cref="T:System.Collections.Stack" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7aef2-212">Diese Methode ähnelt der <xref:System.Collections.Stack.Pop%2A>-Methode, aber <xref:System.Collections.Stack.Peek%2A> ändert die <xref:System.Collections.Stack> nicht.</span><span class="sxs-lookup"><span data-stu-id="7aef2-212">This method is similar to the <xref:System.Collections.Stack.Pop%2A> method, but <xref:System.Collections.Stack.Peek%2A> does not modify the <xref:System.Collections.Stack>.</span></span>  
  
 <span data-ttu-id="7aef2-213">`null`kann bei Bedarf als Platz <xref:System.Collections.Stack> Halter auf den verschoben werden.</span><span class="sxs-lookup"><span data-stu-id="7aef2-213">`null` can be pushed onto the <xref:System.Collections.Stack> as a placeholder, if needed.</span></span> <span data-ttu-id="7aef2-214">Um zwischen einem NULL-Wert und dem Ende des Stapels zu unterscheiden <xref:System.Collections.Stack.Count%2A> , überprüfen Sie <xref:System.InvalidOperationException>die-Eigenschaft, oder fangen <xref:System.Collections.Stack> Sie den ab, der ausgelöst wird, wenn der leer ist.</span><span class="sxs-lookup"><span data-stu-id="7aef2-214">To distinguish between a null value and the end of the stack, check the <xref:System.Collections.Stack.Count%2A> property or catch the <xref:System.InvalidOperationException>, which is thrown when the <xref:System.Collections.Stack> is empty.</span></span>  
  
 <span data-ttu-id="7aef2-215">Diese Methode ist ein O (1)-Vorgang.</span><span class="sxs-lookup"><span data-stu-id="7aef2-215">This method is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7aef2-216">Im folgenden Beispiel <xref:System.Collections.Stack>wird gezeigt, wie Sie Elemente hinzufügen, Elemente aus der <xref:System.Collections.Stack>entfernen oder das Element <xref:System.Collections.Stack>am Anfang der anzeigen.</span><span class="sxs-lookup"><span data-stu-id="7aef2-216">The following example shows how to add elements to the <xref:System.Collections.Stack>, remove elements from the <xref:System.Collections.Stack>, or view the element at the top of the <xref:System.Collections.Stack>.</span></span>  
  
 [!code-cpp[Classic Stack.Peek Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Stack.Peek Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Stack.Peek Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Stack.Peek Example/CS/source.cs#1)]
 [!code-vb[Classic Stack.Peek Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Stack.Peek Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7aef2-217">Die <see cref="T:System.Collections.Stack" /> ist leer.</span><span class="sxs-lookup"><span data-stu-id="7aef2-217">The <see cref="T:System.Collections.Stack" /> is empty.</span></span></exception>
        <altmember cref="M:System.Collections.Stack.Pop" />
        <altmember cref="M:System.Collections.Stack.Push(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Pop">
      <MemberSignature Language="C#" Value="public virtual object Pop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Pop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Stack.Pop" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Pop () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Pop();" />
      <MemberSignature Language="F#" Value="abstract member Pop : unit -&gt; obj&#xA;override this.Pop : unit -&gt; obj" Usage="stack.Pop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="7aef2-218">Entfernt das oberste Objekt aus <see cref="T:System.Collections.Stack" /> und gibt es zurück.</span><span class="sxs-lookup"><span data-stu-id="7aef2-218">Removes and returns the object at the top of the <see cref="T:System.Collections.Stack" />.</span></span></summary>
        <returns><span data-ttu-id="7aef2-219">Das <see cref="T:System.Object" />, das vom Anfang des <see cref="T:System.Collections.Stack" /> entfernt wurde.</span><span class="sxs-lookup"><span data-stu-id="7aef2-219">The <see cref="T:System.Object" /> removed from the top of the <see cref="T:System.Collections.Stack" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7aef2-220">Diese Methode ähnelt der <xref:System.Collections.Stack.Peek%2A>-Methode, aber <xref:System.Collections.Stack.Peek%2A> ändert die <xref:System.Collections.Stack> nicht.</span><span class="sxs-lookup"><span data-stu-id="7aef2-220">This method is similar to the <xref:System.Collections.Stack.Peek%2A> method, but <xref:System.Collections.Stack.Peek%2A> does not modify the <xref:System.Collections.Stack>.</span></span>  
  
 <span data-ttu-id="7aef2-221">`null`kann bei Bedarf als Platz <xref:System.Collections.Stack> Halter auf den verschoben werden.</span><span class="sxs-lookup"><span data-stu-id="7aef2-221">`null` can be pushed onto the <xref:System.Collections.Stack> as a placeholder, if needed.</span></span> <span data-ttu-id="7aef2-222">Um zwischen einem NULL-Wert und dem Ende des Stapels zu unterscheiden <xref:System.Collections.Stack.Count%2A> , überprüfen Sie <xref:System.InvalidOperationException>die-Eigenschaft, oder fangen <xref:System.Collections.Stack> Sie den ab, der ausgelöst wird, wenn der leer ist.</span><span class="sxs-lookup"><span data-stu-id="7aef2-222">To distinguish between a null value and the end of the stack, check the <xref:System.Collections.Stack.Count%2A> property or catch the <xref:System.InvalidOperationException>, which is thrown when the <xref:System.Collections.Stack> is empty.</span></span>  
  
 <span data-ttu-id="7aef2-223">Diese Methode ist ein O (1)-Vorgang.</span><span class="sxs-lookup"><span data-stu-id="7aef2-223">This method is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7aef2-224">Im folgenden Beispiel <xref:System.Collections.Stack>wird gezeigt, wie Sie Elemente hinzufügen, Elemente aus der <xref:System.Collections.Stack>entfernen oder das Element <xref:System.Collections.Stack>am Anfang der anzeigen.</span><span class="sxs-lookup"><span data-stu-id="7aef2-224">The following example shows how to add elements to the <xref:System.Collections.Stack>, remove elements from the <xref:System.Collections.Stack>, or view the element at the top of the <xref:System.Collections.Stack>.</span></span>  
  
 [!code-cpp[Classic Stack.Peek Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Stack.Peek Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Stack.Peek Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Stack.Peek Example/CS/source.cs#1)]
 [!code-vb[Classic Stack.Peek Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Stack.Peek Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7aef2-225">Die <see cref="T:System.Collections.Stack" /> ist leer.</span><span class="sxs-lookup"><span data-stu-id="7aef2-225">The <see cref="T:System.Collections.Stack" /> is empty.</span></span></exception>
        <altmember cref="M:System.Collections.Stack.Peek" />
        <altmember cref="M:System.Collections.Stack.Push(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Push">
      <MemberSignature Language="C#" Value="public virtual void Push (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Push(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Stack.Push(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Push (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Push(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="abstract member Push : obj -&gt; unit&#xA;override this.Push : obj -&gt; unit" Usage="stack.Push obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="7aef2-226">Das <see cref="T:System.Object" />, das auf dem <see cref="T:System.Collections.Stack" /> abgelegt werden soll.</span><span class="sxs-lookup"><span data-stu-id="7aef2-226">The <see cref="T:System.Object" /> to push onto the <see cref="T:System.Collections.Stack" />.</span></span> <span data-ttu-id="7aef2-227">Der Wert kann <see langword="null" /> sein.</span><span class="sxs-lookup"><span data-stu-id="7aef2-227">The value can be <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="7aef2-228">Fügt ein Objekt am Anfang von <see cref="T:System.Collections.Stack" /> ein.</span><span class="sxs-lookup"><span data-stu-id="7aef2-228">Inserts an object at the top of the <see cref="T:System.Collections.Stack" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7aef2-229">Wenn <xref:System.Collections.Stack.Count%2A> die Kapazität bereits entspricht, <xref:System.Collections.Stack> wird die Kapazität des erhöht, indem das interne Array automatisch neu zugewiesen wird. die vorhandenen Elemente werden dann in das neue Array kopiert, bevor das neue Element hinzugefügt wird.</span><span class="sxs-lookup"><span data-stu-id="7aef2-229">If <xref:System.Collections.Stack.Count%2A> already equals the capacity, the capacity of the <xref:System.Collections.Stack> is increased by automatically reallocating the internal array, and the existing elements are copied to the new array before the new element is added.</span></span>  
  
 <span data-ttu-id="7aef2-230">`null`kann bei Bedarf als Platz <xref:System.Collections.Stack> Halter auf den verschoben werden.</span><span class="sxs-lookup"><span data-stu-id="7aef2-230">`null` can be pushed onto the <xref:System.Collections.Stack> as a placeholder, if needed.</span></span> <span data-ttu-id="7aef2-231">Es belegt einen Slot im Stapel und wird wie ein beliebiges Objekt behandelt.</span><span class="sxs-lookup"><span data-stu-id="7aef2-231">It occupies a slot in the stack and is treated like any object.</span></span>  
  
 <span data-ttu-id="7aef2-232">Wenn <xref:System.Collections.Stack.Count%2A> kleiner als die Kapazität des Stapels ist, <xref:System.Collections.Stack.Push%2A> ist ein O (1)-Vorgang.</span><span class="sxs-lookup"><span data-stu-id="7aef2-232">If <xref:System.Collections.Stack.Count%2A> is less than the capacity of the stack, <xref:System.Collections.Stack.Push%2A> is an O(1) operation.</span></span> <span data-ttu-id="7aef2-233">Wenn die Kapazität für das neue Element erweitert werden muss <xref:System.Collections.Stack.Push%2A> , wird ein O (`n`)-Vorgang, bei dem `n` gleich <xref:System.Collections.Stack.Count%2A>ist.</span><span class="sxs-lookup"><span data-stu-id="7aef2-233">If the capacity needs to be increased to accommodate the new element, <xref:System.Collections.Stack.Push%2A> becomes an O(`n`) operation, where `n` is <xref:System.Collections.Stack.Count%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7aef2-234">Im folgenden Beispiel <xref:System.Collections.Stack>wird gezeigt, wie Sie Elemente hinzufügen, Elemente aus der <xref:System.Collections.Stack>entfernen oder das Element <xref:System.Collections.Stack>am Anfang der anzeigen.</span><span class="sxs-lookup"><span data-stu-id="7aef2-234">The following example shows how to add elements to the <xref:System.Collections.Stack>, remove elements from the <xref:System.Collections.Stack>, or view the element at the top of the <xref:System.Collections.Stack>.</span></span>  
  
 [!code-cpp[Classic Stack.Peek Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Stack.Peek Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Stack.Peek Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Stack.Peek Example/CS/source.cs#1)]
 [!code-vb[Classic Stack.Peek Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Stack.Peek Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Stack.Peek" />
        <altmember cref="M:System.Collections.Stack.Pop" />
      </Docs>
    </Member>
    <Member MemberName="Synchronized">
      <MemberSignature Language="C#" Value="public static System.Collections.Stack Synchronized (System.Collections.Stack stack);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Stack Synchronized(class System.Collections.Stack stack) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Stack.Synchronized(System.Collections.Stack)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Stack ^ Synchronized(System::Collections::Stack ^ stack);" />
      <MemberSignature Language="F#" Value="static member Synchronized : System.Collections.Stack -&gt; System.Collections.Stack" Usage="System.Collections.Stack.Synchronized stack" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Stack</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stack" Type="System.Collections.Stack" />
      </Parameters>
      <Docs>
        <param name="stack"><span data-ttu-id="7aef2-235">Die <see cref="T:System.Collections.Stack" />, die synchronisiert werden soll.</span><span class="sxs-lookup"><span data-stu-id="7aef2-235">The <see cref="T:System.Collections.Stack" /> to synchronize.</span></span></param>
        <summary><span data-ttu-id="7aef2-236">Gibt einen synchronisierten (threadsicheren) Wrapper für <see cref="T:System.Collections.Stack" /> zurück.</span><span class="sxs-lookup"><span data-stu-id="7aef2-236">Returns a synchronized (thread safe) wrapper for the <see cref="T:System.Collections.Stack" />.</span></span></summary>
        <returns><span data-ttu-id="7aef2-237">Ein synchronisierter Wrapper um <see cref="T:System.Collections.Stack" />.</span><span class="sxs-lookup"><span data-stu-id="7aef2-237">A synchronized wrapper around the <see cref="T:System.Collections.Stack" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7aef2-238">Um die Thread Sicherheit von <xref:System.Collections.Stack>zu gewährleisten, müssen alle Vorgänge über diesen Wrapper ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="7aef2-238">To guarantee the thread safety of the <xref:System.Collections.Stack>, all operations must be done through this wrapper.</span></span>  
  
 <span data-ttu-id="7aef2-239">Die Enumeration einer Auflistung ist systemintern keine threadsichere Prozedur.</span><span class="sxs-lookup"><span data-stu-id="7aef2-239">Enumerating through a collection is intrinsically not a thread-safe procedure.</span></span> <span data-ttu-id="7aef2-240">Selbst wenn eine Auflistung synchronisiert wird, besteht die Möglichkeit, dass andere Threads sie ändern. Dies führt dazu, dass der Enumerator eine Ausnahme auslöst.</span><span class="sxs-lookup"><span data-stu-id="7aef2-240">Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</span></span> <span data-ttu-id="7aef2-241">Um während der Enumeration Threadsicherheit zu gewährleisten, können Sie entweder die Auflistung während der gesamten Enumeration sperren oder die Ausnahmen, die aus von anderen Threads stammenden Änderungen resultieren, abfangen.</span><span class="sxs-lookup"><span data-stu-id="7aef2-241">To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</span></span>  
  
 <span data-ttu-id="7aef2-242">Im folgenden Codebeispiel wird veranschaulicht, wie die-Auflistung <xref:System.Collections.Stack.SyncRoot%2A> während der gesamten-Enumeration mithilfe von gesperrt wird.</span><span class="sxs-lookup"><span data-stu-id="7aef2-242">The following code example shows how to lock the collection using the <xref:System.Collections.Stack.SyncRoot%2A> during the entire enumeration.</span></span>  
  
 [!code-cpp[Classic Stack.IsSynchronized Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Stack.IsSynchronized Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Stack.IsSynchronized Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Stack.IsSynchronized Example/CS/source2.cs#2)]
 [!code-vb[Classic Stack.IsSynchronized Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Stack.IsSynchronized Example/VB/source2.vb#2)]  
  
 <span data-ttu-id="7aef2-243">Diese Methode ist ein O (1)-Vorgang.</span><span class="sxs-lookup"><span data-stu-id="7aef2-243">This method is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7aef2-244">Im folgenden Beispiel wird gezeigt, wie eine <xref:System.Collections.Stack>synchronisiert wird, ob <xref:System.Collections.Stack> eine synchronisiert wird und wie eine Synchronisierung <xref:System.Collections.Stack>verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="7aef2-244">The following example shows how to synchronize a <xref:System.Collections.Stack>, determine if a <xref:System.Collections.Stack> is synchronized, and use a synchronized <xref:System.Collections.Stack>.</span></span>  
  
 [!code-cpp[Classic Stack.IsSynchronized Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Stack.IsSynchronized Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Stack.IsSynchronized Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Stack.IsSynchronized Example/CS/source.cs#1)]
 [!code-vb[Classic Stack.IsSynchronized Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Stack.IsSynchronized Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7aef2-245"><paramref name="stack" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="7aef2-245"><paramref name="stack" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SyncRoot">
      <MemberSignature Language="C#" Value="public virtual object SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Stack.SyncRoot" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SyncRoot As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SyncRoot : obj" Usage="System.Collections.Stack.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="7aef2-246">Ruft ein Objekt ab, mit dem der Zugriff auf <see cref="T:System.Collections.Stack" /> synchronisiert werden kann.</span><span class="sxs-lookup"><span data-stu-id="7aef2-246">Gets an object that can be used to synchronize access to the <see cref="T:System.Collections.Stack" />.</span></span></summary>
        <value><span data-ttu-id="7aef2-247">Ein <see cref="T:System.Object" />, mit dem der Zugriff auf das <see cref="T:System.Collections.Stack" /> synchronisiert werden kann.</span><span class="sxs-lookup"><span data-stu-id="7aef2-247">An <see cref="T:System.Object" /> that can be used to synchronize access to the <see cref="T:System.Collections.Stack" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7aef2-248">Verwenden Sie die <xref:System.Collections.Stack> <xref:System.Collections.Stack.Synchronized%2A> -Methode, um eine synchronisierte Version von zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="7aef2-248">To create a synchronized version of the <xref:System.Collections.Stack>, use the <xref:System.Collections.Stack.Synchronized%2A> method.</span></span> <span data-ttu-id="7aef2-249">Abgeleitete Klassen können jedoch <xref:System.Collections.Stack> mithilfe der <xref:System.Collections.Stack.SyncRoot%2A> -Eigenschaft eine eigene synchronisierte Version von bereitstellen.</span><span class="sxs-lookup"><span data-stu-id="7aef2-249">However, derived classes can provide their own synchronized version of the <xref:System.Collections.Stack> using the <xref:System.Collections.Stack.SyncRoot%2A> property.</span></span> <span data-ttu-id="7aef2-250">Der Synchronisierungs Code muss Vorgänge für die <xref:System.Collections.Stack.SyncRoot%2A> <xref:System.Collections.Stack>von, nicht direkt auf dem <xref:System.Collections.Stack>ausführen.</span><span class="sxs-lookup"><span data-stu-id="7aef2-250">The synchronizing code must perform operations on the <xref:System.Collections.Stack.SyncRoot%2A> of the <xref:System.Collections.Stack>, not directly on the <xref:System.Collections.Stack>.</span></span> <span data-ttu-id="7aef2-251">Dies gewährleistet die einwandfreie Funktion von Auflistungen, die von anderen Objekten abgeleitet sind.</span><span class="sxs-lookup"><span data-stu-id="7aef2-251">This ensures proper operation of collections that are derived from other objects.</span></span> <span data-ttu-id="7aef2-252">Insbesondere wird die ordnungsgemäße Synchronisierung mit anderen Threads verwaltet, die das <xref:System.Collections.Stack> Objekt möglicherweise gleichzeitig ändern.</span><span class="sxs-lookup"><span data-stu-id="7aef2-252">Specifically, it maintains proper synchronization with other threads that might be simultaneously modifying the <xref:System.Collections.Stack> object.</span></span>  
  
 <span data-ttu-id="7aef2-253">Die Enumeration einer Auflistung ist systemintern keine threadsichere Prozedur.</span><span class="sxs-lookup"><span data-stu-id="7aef2-253">Enumerating through a collection is intrinsically not a thread-safe procedure.</span></span> <span data-ttu-id="7aef2-254">Selbst wenn eine Auflistung synchronisiert wird, besteht die Möglichkeit, dass andere Threads sie ändern. Dies führt dazu, dass der Enumerator eine Ausnahme auslöst.</span><span class="sxs-lookup"><span data-stu-id="7aef2-254">Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</span></span> <span data-ttu-id="7aef2-255">Um während der Enumeration Threadsicherheit zu gewährleisten, können Sie entweder die Auflistung während der gesamten Enumeration sperren oder die Ausnahmen, die aus von anderen Threads stammenden Änderungen resultieren, abfangen.</span><span class="sxs-lookup"><span data-stu-id="7aef2-255">To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</span></span>  
  
 <span data-ttu-id="7aef2-256">Im folgenden Codebeispiel wird veranschaulicht, wie die-Auflistung <xref:System.Collections.Stack.SyncRoot%2A> während der gesamten-Enumeration mithilfe von gesperrt wird.</span><span class="sxs-lookup"><span data-stu-id="7aef2-256">The following code example shows how to lock the collection using the <xref:System.Collections.Stack.SyncRoot%2A> during the entire enumeration.</span></span>  
  
 [!code-cpp[Classic Stack.IsSynchronized Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Stack.IsSynchronized Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Stack.IsSynchronized Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Stack.IsSynchronized Example/CS/source2.cs#2)]
 [!code-vb[Classic Stack.IsSynchronized Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Stack.IsSynchronized Example/VB/source2.vb#2)]  
  
 <span data-ttu-id="7aef2-257">Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.</span><span class="sxs-lookup"><span data-stu-id="7aef2-257">Retrieving the value of this property is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToArray">
      <MemberSignature Language="C#" Value="public virtual object[] ToArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object[] ToArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Stack.ToArray" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ToArray () As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Object ^&gt; ^ ToArray();" />
      <MemberSignature Language="F#" Value="abstract member ToArray : unit -&gt; obj[]&#xA;override this.ToArray : unit -&gt; obj[]" Usage="stack.ToArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="7aef2-258">Kopiert <see cref="T:System.Collections.Stack" /> in ein neues Array.</span><span class="sxs-lookup"><span data-stu-id="7aef2-258">Copies the <see cref="T:System.Collections.Stack" /> to a new array.</span></span></summary>
        <returns><span data-ttu-id="7aef2-259">Ein neues Array, das Kopien der Elemente aus <see cref="T:System.Collections.Stack" /> enthält.</span><span class="sxs-lookup"><span data-stu-id="7aef2-259">A new array containing copies of the elements of the <see cref="T:System.Collections.Stack" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7aef2-260">Die Elemente werden auf das Array in der LIFO-Reihenfolge (Last-in-First-Out) kopiert, ähnlich der Reihenfolge der Elemente, die durch eine Abfolge <xref:System.Collections.Stack.Pop%2A>von Aufrufen an zurückgegeben werden.</span><span class="sxs-lookup"><span data-stu-id="7aef2-260">The elements are copied onto the array in last-in-first-out (LIFO) order, similar to the order of the elements returned by a succession of calls to <xref:System.Collections.Stack.Pop%2A>.</span></span>  
  
 <span data-ttu-id="7aef2-261">Diese Methode ist ein O (`n`)-Vorgang, `n` bei <xref:System.Collections.Stack.Count%2A>dem gleich ist.</span><span class="sxs-lookup"><span data-stu-id="7aef2-261">This method is an O(`n`) operation, where `n` is <xref:System.Collections.Stack.Count%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7aef2-262">Im folgenden Beispiel wird gezeigt, wie ein <xref:System.Collections.Stack> in ein eindimensionales Array kopiert wird.</span><span class="sxs-lookup"><span data-stu-id="7aef2-262">The following example shows how to copy a <xref:System.Collections.Stack> into a one-dimensional array.</span></span>  
  
 [!code-cpp[Classic Stack.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Stack.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Stack.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Stack.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic Stack.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Stack.CopyTo Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Stack.CopyTo(System.Array,System.Int32)" />
        <altmember cref="M:System.Collections.Stack.Pop" />
      </Docs>
    </Member>
  </Members>
</Type>
