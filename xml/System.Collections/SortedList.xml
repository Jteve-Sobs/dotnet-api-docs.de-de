<Type Name="SortedList" FullName="System.Collections.SortedList">
  <Metadata><Meta Name="ms.openlocfilehash" Value="23e5d8d5e03c1249285d4642fc657c83c0e4e4ab" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69333538" /></Metadata><TypeSignature Language="C#" Value="public class SortedList : ICloneable, System.Collections.IDictionary" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit SortedList extends System.Object implements class System.Collections.ICollection, class System.Collections.IDictionary, class System.Collections.IEnumerable, class System.ICloneable" />
  <TypeSignature Language="DocId" Value="T:System.Collections.SortedList" />
  <TypeSignature Language="VB.NET" Value="Public Class SortedList&#xA;Implements ICloneable, IDictionary" />
  <TypeSignature Language="C++ CLI" Value="public ref class SortedList : ICloneable, System::Collections::IDictionary" />
  <TypeSignature Language="F#" Value="type SortedList = class&#xA;    interface IDictionary&#xA;    interface ICloneable&#xA;    interface ICollection&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Collections.NonGeneric</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IDictionary</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.SortedList/SortedListDebugView))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt eine Auflistung von Schlüssel-Wert-Paaren dar, die nach Schlüsseln sortiert sind und auf die sowohl über Schlüssel als auch über Indizes zugegriffen werden kann.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  

Auf <xref:System.Collections.SortedList> ein-Element kann über seinen Schlüssel zugegriffen werden, z. b <xref:System.Collections.IDictionary> . ein Element in einer beliebigen Implementierung oder durch seinen Index, <xref:System.Collections.IList> wie ein Element in jeder Implementierung.  

> [!IMPORTANT]
> Es wird nicht empfohlen, die- `SortedList` Klasse für die neue Entwicklung zu verwenden. Stattdessen wird die Verwendung der generischen <xref:System.Collections.Generic.SortedList%602?displayProperty=nameWithType> -Klasse empfohlen. Weitere Informationen finden Sie unter [nicht generische](https://github.com/dotnet/platform-compat/blob/master/docs/DE0006.md) Auflistungen sollten nicht auf GitHub verwendet werden.

 Ein <xref:System.Collections.SortedList> -Objekt verwaltet intern zwei Arrays, um die Elemente der Liste zu speichern, d. h. ein Array für die Schlüssel und ein anderes Array für die zugeordneten Werte. Jedes Element ist ein Schlüssel-Wert-Paar, auf das als <xref:System.Collections.DictionaryEntry> -Objekt zugegriffen werden kann. Ein Schlüssel kann nicht `null`sein, aber ein Wert kann sein.  
  
 Die Kapazität eines <xref:System.Collections.SortedList> -Objekts ist die Anzahl der Elemente, <xref:System.Collections.SortedList> die in der enthalten sein können. Wenn Elemente zu einem <xref:System.Collections.SortedList>hinzugefügt werden, wird die Kapazität bei Bedarf durch erneute Zuweisung automatisch erhöht. Die Kapazität kann verringert werden, indem <xref:System.Collections.SortedList.TrimToSize%2A> Sie aufrufen oder indem <xref:System.Collections.SortedList.Capacity%2A> Sie die-Eigenschaft explizit festlegen.  
  
 **Nur .NET Framework:** Bei sehr großen <xref:System.Collections.SortedList> Objekten können Sie die maximale Kapazität auf 2 Milliarden Elemente in einem 64-Bit-System erhöhen, indem Sie `enabled` das-Attribut [`<gcAllowVeryLargeObjects>`](~/docs/framework/configure-apps/file-schema/runtime/gcallowverylargeobjects-element.md) des-Konfigurations `true` Elements in der Laufzeitumgebung auf festlegen.  
  
 Die Elemente eines <xref:System.Collections.SortedList> -Objekts werden nach den Schlüsseln sortiert, entweder entsprechend einer bestimmten <xref:System.Collections.IComparer> -Implementierung, die <xref:System.Collections.SortedList> beim Erstellen von angegeben wird, <xref:System.IComparable> oder gemäß der Implementierung, die von den Schlüsseln selbst bereitgestellt wird. In beiden Fällen lässt ein <xref:System.Collections.SortedList> keine doppelten Schlüssel zu.  
  
 Die Index Sequenz basiert auf der Sortierreihenfolge. Wenn ein Element hinzugefügt wird, wird es <xref:System.Collections.SortedList> in der richtigen Sortierreihenfolge eingefügt, und die Indizierung wird entsprechend angepasst. Wenn ein Element entfernt wird, wird die Indizierung ebenfalls entsprechend angepasst. Daher kann sich der Index eines bestimmten Schlüssel-Wert-Paars ändern, wenn Elemente dem <xref:System.Collections.SortedList> Objekt hinzugefügt oder daraus entfernt werden.  
  
 Vorgänge für ein <xref:System.Collections.SortedList> -Objekt sind aufgrund der Sortierung tendenziell langsamer als <xref:System.Collections.Hashtable> Vorgänge für ein-Objekt. <xref:System.Collections.SortedList> Bietet jedoch mehr Flexibilität, da der Zugriff auf die Werte entweder über die zugeordneten Schlüssel oder über die Indizes ermöglicht wird.  
  
 Auf Elemente in dieser Auflistung kann mit einem ganzzahligen Index zugegriffen werden.  Indizes in dieser Sammlung sind NULL basiert.  
  
 Die `foreach` -Anweisung der C# -Sprache`for each` (in Visual Basic) gibt ein Objekt des Typs der Elemente in der Auflistung zurück. Da jedes Element des <xref:System.Collections.SortedList> Objekts ein Schlüssel-Wert-Paar ist, ist der Elementtyp nicht der Typ des Schlüssels oder der Typ des Werts. Stattdessen ist <xref:System.Collections.DictionaryEntry>der Elementtyp. Beispiel:  
  
 [!code-cpp[Classic SortedList Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList Example/CPP/remarks.cpp#2)]
 [!code-csharp[Classic SortedList Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList Example/CS/remarks.cs#2)]
 [!code-vb[Classic SortedList Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList Example/VB/remarks.vb#2)]  
  
 Bei `foreach` der-Anweisung handelt es sich um einen Wrapper um den Enumerator, der nur das Lesen von und das Schreiben in die Auflistung ermöglicht.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie ein <xref:System.Collections.SortedList> -Objekt erstellt und initialisiert wird und wie seine Schlüssel und Werte gedruckt werden.  
  
 [!code-cpp[Classic SortedList Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Öffentliche statische (<see langword="Shared" /> in Visual Basic) Member dieses Typs sind Thread sicher. Bei Instanzmembern ist die Threadsicherheit nicht gewährleistet.  
  
Ein <see cref="T:System.Collections.SortedList" /> -Objekt kann mehrere Leser gleichzeitig unterstützen, solange die Auflistung nicht geändert wird. Um die Thread Sicherheit von <see cref="T:System.Collections.SortedList" />zu gewährleisten, müssen alle Vorgänge über den von der <see cref="M:System.Collections.SortedList.Synchronized(System.Collections.SortedList)" /> -Methode zurückgegebenen Wrapper durchgeführt werden.  
  
Die Enumeration einer Auflistung ist systemintern keine threadsichere Prozedur. Selbst wenn eine Auflistung synchronisiert wird, besteht die Möglichkeit, dass andere Threads sie ändern. Dies führt dazu, dass der Enumerator eine Ausnahme auslöst. Um während der Enumeration Threadsicherheit zu gewährleisten, können Sie entweder die Auflistung während der gesamten Enumeration sperren oder die Ausnahmen, die aus von anderen Threads stammenden Änderungen resultieren, abfangen.</threadsafe>
    <altmember cref="T:System.IComparable" />
    <altmember cref="T:System.Collections.IComparer" />
    <altmember cref="T:System.Collections.IDictionary" />
    <altmember cref="T:System.Collections.Hashtable" />
    <altmember cref="T:System.Collections.Generic.SortedList`2" />
    <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Auflistungen</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Collections.SortedList" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedList ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SortedList();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue, leere Instanz der <see cref="T:System.Collections.SortedList" />-Klasse, die über die anfängliche Standardkapazität verfügt und entsprechend der <see cref="T:System.IComparable" />-Schnittstelle sortiert wird, die von jedem zum <see cref="T:System.Collections.SortedList" />-Objekt hinzugefügten Schlüssel implementiert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeder Schlüssel muss die <xref:System.IComparable> -Schnittstelle implementieren, damit Vergleiche mit jedem anderen Schlüssel <xref:System.Collections.SortedList> im-Objekt möglich sind. Die Elemente werden nach der <xref:System.IComparable> -Implementierung der einzelnen Schlüssel sortiert, die dem <xref:System.Collections.SortedList>hinzugefügt werden.  
  
 Die Kapazität eines <xref:System.Collections.SortedList> -Objekts ist die Anzahl der Elemente, die <xref:System.Collections.SortedList> der enthalten kann. Wenn Elemente zu einem <xref:System.Collections.SortedList>hinzugefügt werden, wird die Kapazität bei Bedarf automatisch erhöht, indem das interne Array neu zugewiesen wird.  
  
 Wenn die Größe der Auflistung geschätzt werden kann, entfällt beim Angeben der anfänglichen Kapazität das Ausführen einer Reihe von Größenänderung beim Hinzufügen von Elementen zum <xref:System.Collections.SortedList> Objekt.  
  
 Dieser Konstruktor ist ein O (1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden Auflistungen <xref:System.Collections.SortedList> mithilfe verschiedener Konstruktoren erstellt und die Unterschiede im Verhalten der Auflistungen veranschaulicht.  
  
 [!code-cpp[System.Collections.SortedList_ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.SortedList_ctor/CPP/sortedlist_ctor.cpp#1)]
 [!code-csharp[System.Collections.SortedList_ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.SortedList_ctor/CS/sortedlist_ctor.cs#1)]
 [!code-vb[System.Collections.SortedList_ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.SortedList_ctor/VB/sortedlist_ctor.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IComparable" />
        <altmember cref="P:System.Collections.SortedList.Capacity" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Auflistungen</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedList (System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.#ctor(System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SortedList(System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.SortedList : System.Collections.IComparer -&gt; System.Collections.SortedList" Usage="new System.Collections.SortedList comparer" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="comparer">Die <see cref="T:System.Collections.IComparer" />-Implementierung, die beim Vergleich von Schlüsseln verwendet wird.  
  
- oder - 
 <see langword="null" />, wenn die <see cref="T:System.IComparable" />-Implementierung des jeweiligen Schlüssels verwendet werden soll.</param>
        <summary>Initialisiert eine neue, leere Instanz der <see cref="T:System.Collections.SortedList" />-Klasse, die über die anfängliche Standardkapazität verfügt und entsprechend der angegebenen <see cref="T:System.Collections.IComparer" />-Schnittstelle sortiert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Elemente werden nach der angegebenen <xref:System.Collections.IComparer> Implementierung sortiert. Wenn der `comparer` -Parameter `null`ist, <xref:System.IComparable> wird die Implementierung der einzelnen Schlüssel verwendet. Daher muss jeder Schlüssel die <xref:System.IComparable> -Schnittstelle implementieren, damit Vergleiche mit jedem anderen Schlüssel im <xref:System.Collections.SortedList> -Objekt möglich sind.  
  
 Die Kapazität eines <xref:System.Collections.SortedList> -Objekts ist die Anzahl der Elemente, die <xref:System.Collections.SortedList> der enthalten kann. Wenn Elemente zu einem <xref:System.Collections.SortedList>hinzugefügt werden, wird die Kapazität bei Bedarf automatisch erhöht, indem das interne Array neu zugewiesen wird.  
  
 Wenn die Größe der Auflistung geschätzt werden kann, entfällt beim Angeben der anfänglichen Kapazität das Ausführen einer Reihe von Größenänderung beim Hinzufügen von Elementen zum <xref:System.Collections.SortedList> Objekt.  
  
 Dieser Konstruktor ist ein O (1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden Auflistungen <xref:System.Collections.SortedList> mithilfe verschiedener Konstruktoren erstellt und die Unterschiede im Verhalten der Auflistungen veranschaulicht.  
  
 [!code-cpp[System.Collections.SortedList_ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.SortedList_ctor/CPP/sortedlist_ctor.cpp#1)]
 [!code-csharp[System.Collections.SortedList_ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.SortedList_ctor/CS/sortedlist_ctor.cs#1)]
 [!code-vb[System.Collections.SortedList_ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.SortedList_ctor/VB/sortedlist_ctor.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="P:System.Collections.SortedList.Capacity" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Auflistungen</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedList (System.Collections.IDictionary d);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IDictionary d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.#ctor(System.Collections.IDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (d As IDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SortedList(System::Collections::IDictionary ^ d);" />
      <MemberSignature Language="F#" Value="new System.Collections.SortedList : System.Collections.IDictionary -&gt; System.Collections.SortedList" Usage="new System.Collections.SortedList d" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="d" Type="System.Collections.IDictionary" />
      </Parameters>
      <Docs>
        <param name="d">Die <see cref="T:System.Collections.IDictionary" />-Implementierung, die in ein neues <see cref="T:System.Collections.SortedList" />-Objekt kopiert werden soll.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Collections.SortedList" />-Klasse mit Elementen, die aus dem angegebenen Wörterbuch kopiert werden. Die anfängliche Kapazität entspricht der Anzahl der kopierten Elemente, und die Sortierung erfolgt entsprechend der <see cref="T:System.IComparable" />-Schnittstelle, die von den einzelnen Schlüsseln implementiert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeder Schlüssel muss die <xref:System.IComparable> -Schnittstelle implementieren, damit Vergleiche mit jedem anderen Schlüssel <xref:System.Collections.SortedList> im-Objekt möglich sind. Die Elemente werden nach der <xref:System.IComparable> -Implementierung der einzelnen Schlüssel sortiert, die dem <xref:System.Collections.SortedList>hinzugefügt werden.  
  
 Ein <xref:System.Collections.Hashtable> -Objekt ist ein Beispiel für <xref:System.Collections.IDictionary> eine-Implementierung, die an diesen Konstruktor übergeben werden kann. Das neue <xref:System.Collections.SortedList> -Objekt enthält eine Kopie der Schlüssel und Werte, die in <xref:System.Collections.Hashtable>der gespeichert sind.  
  
 Die Kapazität eines <xref:System.Collections.SortedList> -Objekts ist die Anzahl der Elemente, die <xref:System.Collections.SortedList> der enthalten kann. Wenn Elemente zu einem <xref:System.Collections.SortedList>hinzugefügt werden, wird die Kapazität bei Bedarf automatisch erhöht, indem das interne Array neu zugewiesen wird.  
  
 Wenn die Größe der Auflistung geschätzt werden kann, entfällt beim Angeben der anfänglichen Kapazität das Ausführen einer Reihe von Größenänderung beim Hinzufügen von Elementen zum <xref:System.Collections.SortedList> Objekt.  
  
 Dieser Konstruktor ist ein O (`n`)-Vorgang, `n` wobei die Anzahl der Elemente in `d`ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden Auflistungen <xref:System.Collections.SortedList> mithilfe verschiedener Konstruktoren erstellt und die Unterschiede im Verhalten der Auflistungen veranschaulicht.  
  
 [!code-cpp[System.Collections.SortedList_ctorDictionary#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.SortedList_ctorDictionary/CPP/sortedlist_ctordictionary.cpp#1)]
 [!code-csharp[System.Collections.SortedList_ctorDictionary#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.SortedList_ctorDictionary/CS/sortedlist_ctordictionary.cs#1)]
 [!code-vb[System.Collections.SortedList_ctorDictionary#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.SortedList_ctorDictionary/VB/sortedlist_ctordictionary.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="d" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidCastException">Mindestens ein Element in <paramref name="d" /> implementiert die <see cref="T:System.IComparable" />-Schnittstelle nicht.</exception>
        <altmember cref="T:System.Collections.IDictionary" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="T:System.Collections.Hashtable" />
        <altmember cref="P:System.Collections.SortedList.Capacity" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Auflistungen</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedList (int initialCapacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCapacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCapacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SortedList(int initialCapacity);" />
      <MemberSignature Language="F#" Value="new System.Collections.SortedList : int -&gt; System.Collections.SortedList" Usage="new System.Collections.SortedList initialCapacity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCapacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="initialCapacity">Die anfängliche Anzahl an Elementen, die das <see cref="T:System.Collections.SortedList" />-Objekt enthalten kann.</param>
        <summary>Initialisiert eine neue, leere Instanz der <see cref="T:System.Collections.SortedList" />-Klasse, die über die angegebene anfängliche Standardkapazität verfügt und entsprechend der <see cref="T:System.IComparable" />-Schnittstelle sortiert wird, die von jedem zum <see cref="T:System.Collections.SortedList" />-Objekt hinzugefügten Schlüssel implementiert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeder Schlüssel muss die <xref:System.IComparable> -Schnittstelle implementieren, damit Vergleiche mit jedem anderen Schlüssel <xref:System.Collections.SortedList> im-Objekt möglich sind. Die Elemente werden nach der <xref:System.IComparable> -Implementierung der einzelnen Schlüssel sortiert, die dem <xref:System.Collections.SortedList>hinzugefügt werden.  
  
 Die Kapazität eines <xref:System.Collections.SortedList> -Objekts ist die Anzahl der Elemente, die <xref:System.Collections.SortedList> der enthalten kann. Wenn Elemente zu einem <xref:System.Collections.SortedList>hinzugefügt werden, wird die Kapazität bei Bedarf automatisch erhöht, indem das interne Array neu zugewiesen wird.  
  
 Wenn die Größe der Auflistung geschätzt werden kann, entfällt beim Angeben der anfänglichen Kapazität das Ausführen einer Reihe von Größenänderung beim Hinzufügen von Elementen zum <xref:System.Collections.SortedList> Objekt.  
  
 Dieser Konstruktor ist ein O (`n`)-Vorgang, `n` bei `initialCapacity`dem gleich ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden Auflistungen <xref:System.Collections.SortedList> mithilfe verschiedener Konstruktoren erstellt und die Unterschiede im Verhalten der Auflistungen veranschaulicht.  
  
 [!code-cpp[System.Collections.SortedList_ctorInt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.SortedList_ctorInt/CPP/sortedlist_ctorint.cpp#1)]
 [!code-csharp[System.Collections.SortedList_ctorInt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.SortedList_ctorInt/CS/sortedlist_ctorint.cs#1)]
 [!code-vb[System.Collections.SortedList_ctorInt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.SortedList_ctorInt/VB/sortedlist_ctorint.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="initialCapacity" /> ist kleiner als Null.</exception>
        <exception cref="T:System.OutOfMemoryException">Es ist nicht genügend Arbeitsspeicher verfügbar, um ein <see cref="T:System.Collections.SortedList" />-Objekt mit der angegebenen <paramref name="initialCapacity" /> zu erstellen.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="P:System.Collections.SortedList.Capacity" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Auflistungen</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedList (System.Collections.IComparer comparer, int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IComparer comparer, int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.#ctor(System.Collections.IComparer,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (comparer As IComparer, capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SortedList(System::Collections::IComparer ^ comparer, int capacity);" />
      <MemberSignature Language="F#" Value="new System.Collections.SortedList : System.Collections.IComparer * int -&gt; System.Collections.SortedList" Usage="new System.Collections.SortedList (comparer, capacity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="comparer">Die <see cref="T:System.Collections.IComparer" />-Implementierung, die beim Vergleich von Schlüsseln verwendet wird.  
  
- oder - 
 <see langword="null" />, wenn die <see cref="T:System.IComparable" />-Implementierung des jeweiligen Schlüssels verwendet werden soll.</param>
        <param name="capacity">Die anfängliche Anzahl an Elementen, die das <see cref="T:System.Collections.SortedList" />-Objekt enthalten kann.</param>
        <summary>Initialisiert eine neue, leere Instanz der <see cref="T:System.Collections.SortedList" />-Klasse, die über die angegebene anfängliche Kapazität verfügt und entsprechend der angegebenen <see cref="T:System.Collections.IComparer" />-Schnittstelle sortiert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Elemente werden nach der angegebenen <xref:System.Collections.IComparer> Implementierung sortiert. Wenn der `comparer` -Parameter `null`ist, <xref:System.IComparable> wird die Implementierung der einzelnen Schlüssel verwendet. Daher muss jeder Schlüssel die <xref:System.IComparable> -Schnittstelle implementieren, damit Vergleiche mit jedem anderen Schlüssel im <xref:System.Collections.SortedList> -Objekt möglich sind.  
  
 Die Kapazität eines <xref:System.Collections.SortedList> -Objekts ist die Anzahl der Elemente, die <xref:System.Collections.SortedList> der enthalten kann. Wenn Elemente zu einem <xref:System.Collections.SortedList>hinzugefügt werden, wird die Kapazität bei Bedarf automatisch erhöht, indem das interne Array neu zugewiesen wird.  
  
 Wenn die Größe der Auflistung geschätzt werden kann, entfällt beim Angeben der anfänglichen Kapazität das Ausführen einer Reihe von Größenänderung beim Hinzufügen von Elementen zum <xref:System.Collections.SortedList> Objekt.  
  
 Dieser Konstruktor ist ein O (`n`)-Vorgang, `n` bei `capacity`dem gleich ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden Auflistungen <xref:System.Collections.SortedList> mithilfe verschiedener Konstruktoren erstellt und die Unterschiede im Verhalten der Auflistungen veranschaulicht.  
  
 [!code-cpp[System.Collections.SortedList_ctorInt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.SortedList_ctorInt/CPP/sortedlist_ctorint.cpp#1)]
 [!code-csharp[System.Collections.SortedList_ctorInt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.SortedList_ctorInt/CS/sortedlist_ctorint.cs#1)]
 [!code-vb[System.Collections.SortedList_ctorInt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.SortedList_ctorInt/VB/sortedlist_ctorint.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> ist kleiner als Null.</exception>
        <exception cref="T:System.OutOfMemoryException">Es ist nicht genügend Arbeitsspeicher verfügbar, um ein <see cref="T:System.Collections.SortedList" />-Objekt mit der angegebenen <paramref name="capacity" /> zu erstellen.</exception>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="P:System.Collections.SortedList.Capacity" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Auflistungen</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedList (System.Collections.IDictionary d, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IDictionary d, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.#ctor(System.Collections.IDictionary,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (d As IDictionary, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SortedList(System::Collections::IDictionary ^ d, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.SortedList : System.Collections.IDictionary * System.Collections.IComparer -&gt; System.Collections.SortedList" Usage="new System.Collections.SortedList (d, comparer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="d" Type="System.Collections.IDictionary" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="d">Die <see cref="T:System.Collections.IDictionary" />-Implementierung, die in ein neues <see cref="T:System.Collections.SortedList" />-Objekt kopiert werden soll.</param>
        <param name="comparer">Die <see cref="T:System.Collections.IComparer" />-Implementierung, die beim Vergleich von Schlüsseln verwendet wird.  
  
- oder - 
 <see langword="null" />, wenn die <see cref="T:System.IComparable" />-Implementierung des jeweiligen Schlüssels verwendet werden soll.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Collections.SortedList" />-Klasse, die aus dem angegebenen Wörterbuch kopierte Elemente enthält. Die anfängliche Kapazität entspricht der Anzahl der kopierten Elemente, und die Sortierung erfolgt nach der angegebenen <see cref="T:System.Collections.IComparer" />-Schnittstelle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Elemente werden nach der angegebenen <xref:System.Collections.IComparer> Implementierung sortiert. Wenn der `comparer` -Parameter `null`ist, <xref:System.IComparable> wird die Implementierung der einzelnen Schlüssel verwendet. Daher muss jeder Schlüssel die <xref:System.IComparable> -Schnittstelle implementieren, damit Vergleiche mit jedem anderen Schlüssel im <xref:System.Collections.SortedList> -Objekt möglich sind.  
  
 Ein <xref:System.Collections.Hashtable> -Objekt ist ein Beispiel für <xref:System.Collections.IDictionary> eine-Implementierung, die an diesen Konstruktor übergeben werden kann. Das neue <xref:System.Collections.SortedList> -Objekt enthält eine Kopie der Schlüssel und Werte, die in <xref:System.Collections.Hashtable>der gespeichert sind.  
  
 Die Kapazität eines <xref:System.Collections.SortedList> -Objekts ist die Anzahl der Elemente, die <xref:System.Collections.SortedList> der enthalten kann. Wenn Elemente zu einem <xref:System.Collections.SortedList>hinzugefügt werden, wird die Kapazität bei Bedarf automatisch erhöht, indem das interne Array neu zugewiesen wird.  
  
 Wenn die Größe der Auflistung geschätzt werden kann, entfällt beim Angeben der anfänglichen Kapazität das Ausführen einer Reihe von Größenänderung beim Hinzufügen von Elementen zum <xref:System.Collections.SortedList> Objekt.  
  
 Dieser Konstruktor ist ein O (`n`)-Vorgang, `n` wobei die Anzahl der Elemente in `d`ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden Auflistungen <xref:System.Collections.SortedList> mithilfe verschiedener Konstruktoren erstellt und die Unterschiede im Verhalten der Auflistungen veranschaulicht.  
  
 [!code-cpp[System.Collections.SortedList_ctorDictionary#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.SortedList_ctorDictionary/CPP/sortedlist_ctordictionary.cpp#1)]
 [!code-csharp[System.Collections.SortedList_ctorDictionary#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.SortedList_ctorDictionary/CS/sortedlist_ctordictionary.cs#1)]
 [!code-vb[System.Collections.SortedList_ctorDictionary#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.SortedList_ctorDictionary/VB/sortedlist_ctordictionary.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="d" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="comparer" /> ist <see langword="null" />, und mindestens ein Element in <paramref name="d" /> implementiert die <see cref="T:System.IComparable" />-Schnittstelle nicht.</exception>
        <altmember cref="T:System.Collections.IDictionary" />
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="T:System.Collections.Hashtable" />
        <altmember cref="P:System.Collections.SortedList.Capacity" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Auflistungen</related>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public virtual void Add (object key, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(object key, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.Add(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Add (key As Object, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Add(System::Object ^ key, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member Add : obj * obj -&gt; unit&#xA;override this.Add : obj * obj -&gt; unit" Usage="sortedList.Add (key, value)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Add(System.Object,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Der Schlüssel des hinzuzufügenden Elements.</param>
        <param name="value">Der Wert des hinzuzufügenden Elements. Der Wert kann <see langword="null" /> sein.</param>
        <summary>Fügt einem <see cref="T:System.Collections.SortedList" />-Objekt ein Element mit dem angegebenen Schlüssel und Wert hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Einfügemarke wird basierend auf dem ausgewählten Vergleich festgelegt, entweder explizit oder standardmäßig <xref:System.Collections.SortedList> , wenn das Objekt erstellt wurde.  
  
 Wenn <xref:System.Collections.SortedList.Count%2A> bereits entspricht <xref:System.Collections.SortedList.Capacity%2A> ,wirddieKapazitätdes-ObjektsdurchautomatischesNeuzuordnendesinternenArrayserhöht,unddievorhandenenElementewerdenindasneueArraykopiert,bevordasneueElementhinzugefügtwird.<xref:System.Collections.SortedList>  
  
 Sie können auch die <xref:System.Collections.SortedList.Item%2A> -Eigenschaft verwenden, um neue Elemente hinzuzufügen, indem Sie den Wert eines Schlüssels festlegen, der <xref:System.Collections.SortedList> im- `myCollection["myNonexistentKey"] = myValue`Objekt nicht vorhanden ist (z. b.). Wenn jedoch der angegebene Schlüssel bereits in <xref:System.Collections.SortedList>vorhanden ist, wird durch das Festlegen der <xref:System.Collections.SortedList.Item%2A> -Eigenschaft der alte Wert überschrieben. Im Gegensatz dazu ändert <xref:System.Collections.SortedList.Add%2A> die-Methode keine vorhandenen Elemente.  
  
 Die Elemente eines <xref:System.Collections.SortedList> -Objekts werden nach den Schlüsseln sortiert, entweder entsprechend einer bestimmten <xref:System.Collections.IComparer> -Implementierung, die <xref:System.Collections.SortedList> beim Erstellen von angegeben wird, <xref:System.IComparable> oder gemäß der Implementierung, die von den Schlüsseln selbst bereitgestellt wird.  
  
 Ein Schlüssel kann nicht `null`sein, aber ein Wert kann sein.  
  
 Bei dieser Methode handelt es sich`n`um einen O ()-Vorgang für unsortierte Daten, wobei `n` den Wert hat. <xref:System.Collections.SortedList.Count%2A> Es handelt sich um einen O `n`(Log)-Vorgang, wenn das neue Element am Ende der Liste hinzugefügt wird. Wenn das Einfügen eine Größenänderung bewirkt, ist der Vorgang O`n`().  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie Elemente zu einem <xref:System.Collections.SortedList> -Objekt hinzugefügt werden.  
  
 [!code-cpp[Classic SortedList.Add Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.Add Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.Add Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.Add Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.Add Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.Add Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Ein Element mit dem angegebenen <paramref name="key" /> ist bereits im <see cref="T:System.Collections.SortedList" />-Objekt vorhanden.  
  
- oder - 
<see cref="T:System.Collections.SortedList" /> ist auf die Verwendung der <see cref="T:System.IComparable" />-Schnittstelle festgelegt, und <paramref name="key" /> implementiert die <see cref="T:System.IComparable" />-Schnittstelle nicht.</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.SortedList" /> ist schreibgeschützt.  
  
- oder - 
<see cref="T:System.Collections.SortedList" /> hat eine feste Größe.</exception>
        <exception cref="T:System.OutOfMemoryException">Es ist nicht genügend Arbeitsspeicher verfügbar, um das Element zu <see cref="T:System.Collections.SortedList" /> hinzuzufügen.</exception>
        <exception cref="T:System.InvalidOperationException">Der Vergleich löst eine Ausnahme aus.</exception>
        <altmember cref="P:System.Collections.SortedList.Item(System.Object)" />
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="P:System.Collections.SortedList.Capacity" />
      </Docs>
    </Member>
    <Member MemberName="Capacity">
      <MemberSignature Language="C#" Value="public virtual int Capacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Capacity" />
      <MemberSignature Language="DocId" Value="P:System.Collections.SortedList.Capacity" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Capacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Capacity { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Capacity : int with get, set" Usage="System.Collections.SortedList.Capacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Kapazität eines <see cref="T:System.Collections.SortedList" />-Objekts ab oder legt diese fest.</summary>
        <value>Die Anzahl von Elementen, die das <see cref="T:System.Collections.SortedList" />-Objekt enthalten kann.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.SortedList.Capacity%2A>die Anzahl der Elemente, die vom <xref:System.Collections.SortedList> Objekt gespeichert werden können. <xref:System.Collections.SortedList.Count%2A>die Anzahl der Elemente, die tatsächlich in der <xref:System.Collections.SortedList>sind.  
  
 <xref:System.Collections.SortedList.Capacity%2A>ist immer größer als oder gleich <xref:System.Collections.SortedList.Count%2A>. Wenn <xref:System.Collections.SortedList.Count%2A> beim <xref:System.Collections.SortedList.Capacity%2A> Hinzufügen von Elementen überschreitet, wird die Kapazität automatisch erhöht, indem das interne Array neu zugewiesen wird, bevor die alten Elemente kopiert und die neuen Elemente hinzugefügt werden.  
  
 Die Kapazität kann verringert werden, indem <xref:System.Collections.SortedList.TrimToSize%2A> Sie aufrufen oder indem <xref:System.Collections.SortedList.Capacity%2A> Sie die-Eigenschaft explizit festlegen. Wenn der Wert von <xref:System.Collections.SortedList.Capacity%2A> explizit festgelegt wird, wird das interne Array ebenfalls neu zugeordnet, um der angegebenen Kapazität Rechnung zu tragen.  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O (1)-Vorgang. das Festlegen der-Eigenschaft ist ein`n`O ()- `n` Vorgang, wobei die neue Kapazität ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der zugewiesene Wert ist kleiner als die derzeitige Anzahl der Elemente im <see cref="T:System.Collections.SortedList" />-Objekt.</exception>
        <exception cref="T:System.OutOfMemoryException">Im System ist nicht genügend Arbeitsspeicher verfügbar.</exception>
        <altmember cref="M:System.Collections.SortedList.TrimToSize" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public virtual void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberSignature Language="F#" Value="abstract member Clear : unit -&gt; unit&#xA;override this.Clear : unit -&gt; unit" Usage="sortedList.Clear " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Entfernt alle Elemente aus einem <see cref="T:System.Collections.SortedList" />-Objekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.SortedList.Count%2A>wird auf NULL festgelegt, und Verweise auf andere Objekte von Elementen der Auflistung werden ebenfalls freigegeben.  
  
 <xref:System.Collections.SortedList.Capacity%2A>bleibt unverändert. Wenn Sie die Kapazität des <xref:System.Collections.SortedList> -Objekts zurücksetzen möchten, können Sie die <xref:System.Collections.SortedList.Capacity%2A> -Eigenschaft direkt aufzurufen <xref:System.Collections.SortedList.TrimToSize%2A> oder festlegen. Durch Kürzen eines <xref:System.Collections.SortedList> leeren wird die Kapazität von aufdieStandardkapazitätfestgelegt.<xref:System.Collections.SortedList>  
  
 Diese Methode ist ein O (`n`)-Vorgang, `n` bei <xref:System.Collections.SortedList.Count%2A>dem gleich ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie die nicht verwendeten Teile eines <xref:System.Collections.SortedList> -Objekts beschnitten werden und wie die Werte <xref:System.Collections.SortedList>der gelöscht werden.  
  
 [!code-cpp[Classic SortedList.Clear Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.Clear Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Das <see cref="T:System.Collections.SortedList" />-Objekt ist schreibgeschützt.  
  
- oder - 
<see cref="T:System.Collections.SortedList" /> hat eine feste Größe.</exception>
        <altmember cref="M:System.Collections.SortedList.TrimToSize" />
        <altmember cref="P:System.Collections.SortedList.Capacity" />
        <altmember cref="P:System.Collections.SortedList.Count" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="sortedList.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt eine flache Kopie eines <see cref="T:System.Collections.SortedList" />-Objekts.</summary>
        <returns>Eine flache Kopie des <see cref="T:System.Collections.SortedList" />-Objekts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei einer flachen Kopie einer Auflistung werden nur die Elemente der Auflistung kopiert, unabhängig davon, ob es sich um Verweis Typen oder Werttypen handelt, die Objekte, auf die die Verweise verweisen, werden jedoch nicht kopiert. Die Verweise in der neuen Auflistung zeigen auf dieselben Objekte, auf die die Verweise in der ursprünglichen Auflistung verweisen.  
  
 Im Gegensatz dazu kopiert eine tiefe Kopie einer Auflistung die Elemente und alle Elemente, die direkt oder indirekt von den Elementen referenziert werden.  
  
 Diese Methode ist ein O (`n`)-Vorgang, `n` bei <xref:System.Collections.SortedList.Count%2A>dem gleich ist.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.SortedList.CopyTo(System.Array,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public virtual bool Contains (object key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Contains (key As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(System::Object ^ key);" />
      <MemberSignature Language="F#" Value="abstract member Contains : obj -&gt; bool&#xA;override this.Contains : obj -&gt; bool" Usage="sortedList.Contains key" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Der im <see cref="T:System.Collections.SortedList" />-Objekt zu suchende Schlüssel.</param>
        <summary>Ermittelt, ob ein <see cref="T:System.Collections.SortedList" />-Objekt einen bestimmten Schlüssel enthält.</summary>
        <returns><see langword="true" />, wenn das <see cref="T:System.Collections.SortedList" />-Objekt ein Element mit dem angegebenen <paramref name="key" /> enthält, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Elemente eines <xref:System.Collections.SortedList> -Objekts werden nach den Schlüsseln sortiert, entweder entsprechend einer bestimmten <xref:System.Collections.IComparer> -Implementierung, die <xref:System.Collections.SortedList> beim Erstellen von angegeben wird, <xref:System.IComparable> oder gemäß der Implementierung, die von den Schlüsseln selbst bereitgestellt wird.  
  
 <xref:System.Collections.SortedList.Contains%2A> implementiert <xref:System.Collections.IDictionary.Contains%2A?displayProperty=nameWithType>. Sie verhält sich genau <xref:System.Collections.SortedList.ContainsKey%2A>so.  
  
 Diese Methode verwendet einen binären Suchalgorithmus. Daher handelt es sich bei dieser Methode um einen `n`O (Log) `n` - <xref:System.Collections.SortedList.Count%2A>Vorgang, bei dem gleich ist.  
  
 Beginnend mit dem .NET Framework 2,0 verwendet diese Methode die- <xref:System.Object.Equals%2A> und <xref:System.IComparable.CompareTo%2A> -Methoden `item` der-Auflistung, um zu bestimmen, ob ein Element vorhanden ist. In früheren Versionen der .NET Framework wurde diese Bestimmung durch die Verwendung der <xref:System.Object.Equals%2A> -Methode und der-Methode des `item` -Parameters für die- <xref:System.IComparable.CompareTo%2A> Objekte in der-Auflistung vorgenommen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie bestimmt wird <xref:System.Collections.SortedList> , ob ein-Objekt ein bestimmtes Element enthält.  
  
 [!code-cpp[Classic SortedList.Contains Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.Contains Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.Contains Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.Contains Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.Contains Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.Contains Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der Vergleich löst eine Ausnahme aus.</exception>
        <altmember cref="M:System.Collections.SortedList.ContainsKey(System.Object)" />
        <altmember cref="M:System.Collections.SortedList.IndexOfKey(System.Object)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Auflistungen</related>
      </Docs>
    </Member>
    <Member MemberName="ContainsKey">
      <MemberSignature Language="C#" Value="public virtual bool ContainsKey (object key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ContainsKey(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.ContainsKey(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ContainsKey (key As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ContainsKey(System::Object ^ key);" />
      <MemberSignature Language="F#" Value="abstract member ContainsKey : obj -&gt; bool&#xA;override this.ContainsKey : obj -&gt; bool" Usage="sortedList.ContainsKey key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Der im <see cref="T:System.Collections.SortedList" />-Objekt zu suchende Schlüssel.</param>
        <summary>Ermittelt, ob ein <see cref="T:System.Collections.SortedList" />-Objekt einen bestimmten Schlüssel enthält.</summary>
        <returns><see langword="true" />, wenn das <see cref="T:System.Collections.SortedList" />-Objekt ein Element mit dem angegebenen <paramref name="key" /> enthält, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Elemente eines <xref:System.Collections.SortedList> -Objekts werden nach den Schlüsseln sortiert, entweder entsprechend einer bestimmten <xref:System.Collections.IComparer> -Implementierung, die <xref:System.Collections.SortedList> beim Erstellen von angegeben wird, <xref:System.IComparable> oder gemäß der Implementierung, die von den Schlüsseln selbst bereitgestellt wird.  
  
 Diese Methode verhält sich genau wie <xref:System.Collections.SortedList.Contains%2A> die-Methode.  
  
 Diese Methode verwendet einen binären Suchalgorithmus. Daher handelt es sich bei dieser Methode um einen `n`O (Log) `n` - <xref:System.Collections.SortedList.Count%2A>Vorgang, bei dem gleich ist.  
  
 Beginnend mit dem .NET Framework 2,0 verwendet diese Methode die- <xref:System.Object.Equals%2A> und <xref:System.IComparable.CompareTo%2A> -Methoden `item` der-Auflistung, um zu bestimmen, ob ein Element vorhanden ist. In früheren Versionen der .NET Framework wurde diese Bestimmung durch die Verwendung der <xref:System.Object.Equals%2A> -Methode und der-Methode des `item` -Parameters für die- <xref:System.IComparable.CompareTo%2A> Objekte in der-Auflistung vorgenommen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie bestimmt wird <xref:System.Collections.SortedList> , ob ein-Objekt ein bestimmtes Element enthält.  
  
 [!code-cpp[Classic SortedList.Contains Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.Contains Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.Contains Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.Contains Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.Contains Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.Contains Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der Vergleich löst eine Ausnahme aus.</exception>
        <altmember cref="M:System.Collections.SortedList.Contains(System.Object)" />
        <altmember cref="M:System.Collections.SortedList.ContainsValue(System.Object)" />
        <altmember cref="M:System.Collections.SortedList.IndexOfKey(System.Object)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Auflistungen</related>
      </Docs>
    </Member>
    <Member MemberName="ContainsValue">
      <MemberSignature Language="C#" Value="public virtual bool ContainsValue (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ContainsValue(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.ContainsValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ContainsValue (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ContainsValue(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member ContainsValue : obj -&gt; bool&#xA;override this.ContainsValue : obj -&gt; bool" Usage="sortedList.ContainsValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Der im <see cref="T:System.Collections.SortedList" />-Objekt zu suchende Wert. Der Wert kann <see langword="null" /> sein.</param>
        <summary>Ermittelt, ob ein <see cref="T:System.Collections.SortedList" />-Objekt einen bestimmten Wert enthält.</summary>
        <returns><see langword="true" />, wenn das <see cref="T:System.Collections.SortedList" />-Objekt ein Element mit dem angegebenen <paramref name="value" /> enthält, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Werte der Elemente des <xref:System.Collections.SortedList> -Objekts werden mithilfe der <xref:System.Object.Equals%2A> -Methode mit dem angegebenen Wert verglichen.  
  
 Diese Methode führt eine lineare Suche aus. Daher ist die durchschnittliche Ausführungszeit proportional zu <xref:System.Collections.SortedList.Count%2A>. Das heißt, diese Methode ist ein O (`n`)-Vorgang, `n` bei <xref:System.Collections.SortedList.Count%2A>dem gleich ist.  
  
 Beginnend mit dem .NET Framework 2,0 verwendet diese Methode die- <xref:System.Object.Equals%2A> und <xref:System.IComparable.CompareTo%2A> -Methoden `item` der-Auflistung, um zu bestimmen, ob ein Element vorhanden ist. In früheren Versionen der .NET Framework wurde diese Bestimmung durch die Verwendung der <xref:System.Object.Equals%2A> -Methode und der-Methode des `item` -Parameters für die- <xref:System.IComparable.CompareTo%2A> Objekte in der-Auflistung vorgenommen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie bestimmt wird <xref:System.Collections.SortedList> , ob ein-Objekt ein bestimmtes Element enthält.  
  
 [!code-cpp[Classic SortedList.Contains Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.Contains Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.Contains Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.Contains Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.Contains Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.Contains Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.SortedList.ContainsKey(System.Object)" />
        <altmember cref="M:System.Collections.SortedList.IndexOfValue(System.Object)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Auflistungen</related>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public virtual void CopyTo (Array array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.Array array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(Array ^ array, int arrayIndex);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : Array * int -&gt; unit&#xA;override this.CopyTo : Array * int -&gt; unit" Usage="sortedList.CopyTo (array, arrayIndex)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Das eindimensionale <see cref="T:System.Array" />-Objekt, das das Ziel der aus <see cref="T:System.Collections.DictionaryEntry" /> kopierten <see cref="T:System.Collections.SortedList" />-Objekte darstellt. Für das <see cref="T:System.Array" /> muss eine nullbasierte Indizierung verwendet werden.</param>
        <param name="arrayIndex">Der nullbasierte Index im <paramref name="array" />, bei dem der Kopiervorgang beginnt.</param>
        <summary>Kopiert <see cref="T:System.Collections.SortedList" />-Elemente in ein eindimensionales <see cref="T:System.Array" />-Objekt, beginnend mit dem angegebenen Index im Array.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Schlüssel-Wert-Paare werden in derselben <xref:System.Array> Reihenfolge in das-Objekt kopiert, in der der Enumerator das <xref:System.Collections.SortedList> -Objekt durchläuft.  
  
 Wenn Sie nur die Schlüssel in <xref:System.Collections.SortedList>kopieren möchten, verwenden `SortedList.Keys.CopyTo`Sie.  
  
 Wenn Sie nur die Werte in <xref:System.Collections.SortedList>kopieren möchten, verwenden `SortedList.Values.CopyTo`Sie.  
  
 Diese Methode ist ein O (`n`)-Vorgang, `n` bei <xref:System.Collections.SortedList.Count%2A>dem gleich ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie die Werte in einem <xref:System.Collections.SortedList> -Objekt in ein eindimensionales <xref:System.Array> -Objekt kopiert werden.  
  
 [!code-cpp[Classic SortedList.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.CopyTo Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="arrayIndex" /> ist kleiner als Null.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="array" /> ist mehrdimensional.  
  
- oder - 
Die Anzahl der aus dem <see cref="T:System.Collections.SortedList" />-Quellobjekt zu kopierenden Elemente ist größer als der verfügbare Platz von <paramref name="arrayIndex" /> bis zum Ende des Ziel-<paramref name="array" />.</exception>
        <exception cref="T:System.InvalidCastException">Der Typ der Quell-<see cref="T:System.Collections.SortedList" /> kann nicht automatisch in den Typ des Ziel-<paramref name="array" /> umgewandelt werden.</exception>
        <altmember cref="T:System.Array" />
        <altmember cref="T:System.Collections.DictionaryEntry" />
        <altmember cref="M:System.Collections.SortedList.GetEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public virtual int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.SortedList.Count" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Collections.SortedList.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anzahl der Elemente ab, die in einem <see cref="T:System.Collections.SortedList" />-Objekt enthalten sind.</summary>
        <value>Die Anzahl der Elemente, die im <see cref="T:System.Collections.SortedList" />-Objekt enthalten sind.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jedes Element ist ein Schlüssel-Wert-Paar, auf das als <xref:System.Collections.DictionaryEntry> -Objekt zugegriffen werden kann.  
  
 <xref:System.Collections.SortedList.Capacity%2A>die Anzahl der Elemente, die vom <xref:System.Collections.SortedList> Objekt gespeichert werden können. <xref:System.Collections.SortedList.Count%2A>die Anzahl der Elemente, die tatsächlich in der <xref:System.Collections.SortedList>sind.  
  
 <xref:System.Collections.SortedList.Capacity%2A>ist immer größer als oder gleich <xref:System.Collections.SortedList.Count%2A>. Wenn <xref:System.Collections.SortedList.Count%2A> beim <xref:System.Collections.SortedList.Capacity%2A> Hinzufügen von Elementen überschreitet, wird die Kapazität automatisch erhöht, indem das interne Array neu zugewiesen wird, bevor die alten Elemente kopiert und die neuen Elemente hinzugefügt werden.  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.SortedList.Capacity" />
      </Docs>
    </Member>
    <Member MemberName="GetByIndex">
      <MemberSignature Language="C#" Value="public virtual object GetByIndex (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetByIndex(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.GetByIndex(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByIndex (index As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetByIndex(int index);" />
      <MemberSignature Language="F#" Value="abstract member GetByIndex : int -&gt; obj&#xA;override this.GetByIndex : int -&gt; obj" Usage="sortedList.GetByIndex index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Der nullbasierte Index des abzurufenden Werts.</param>
        <summary>Ruft den Wert am angegebenen Index in einem <see cref="T:System.Collections.SortedList" />-Objekt ab.</summary>
        <returns>Der Wert am angegebenen Index im <see cref="T:System.Collections.SortedList" />-Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Index Sequenz basiert auf der Sortierreihenfolge. Wenn ein Element hinzugefügt wird, wird es <xref:System.Collections.SortedList> in der richtigen Sortierreihenfolge eingefügt, und die Indizierung wird entsprechend angepasst. Wenn ein Element entfernt wird, wird die Indizierung ebenfalls entsprechend angepasst. Daher kann sich der Index eines bestimmten Schlüssel-Wert-Paars ändern, wenn Elemente dem <xref:System.Collections.SortedList> Objekt hinzugefügt oder daraus entfernt werden.  
  
 Diese Methode ist ein O (1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie Sie einen oder alle Schlüssel oder Werte in einem <xref:System.Collections.SortedList> -Objekt erhalten.  
  
 [!code-cpp[Classic SortedList.GetByIndex Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.GetByIndex Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.GetByIndex Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> liegt außerhalb des Bereichs der gültigen Indizes für das <see cref="T:System.Collections.SortedList" />-Objekt.</exception>
        <altmember cref="M:System.Collections.SortedList.IndexOfKey(System.Object)" />
        <altmember cref="M:System.Collections.SortedList.IndexOfValue(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IDictionaryEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IDictionaryEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumerator () As IDictionaryEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IDictionaryEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IDictionaryEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IDictionaryEnumerator" Usage="sortedList.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionaryEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt ein <see cref="T:System.Collections.IDictionaryEnumerator" />-Objekt zurück, das ein <see cref="T:System.Collections.SortedList" />-Objekt durchläuft.</summary>
        <returns>Ein <see cref="T:System.Collections.IDictionaryEnumerator" />-Objekt für das <see cref="T:System.Collections.SortedList" />-Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `foreach`-Anweisung der Programmiersprache C# (`for each` in Visual Basic) verbirgt die Komplexität der Enumeratoren.  Daher empfiehlt es sich, `foreach` zu verwenden und den Enumerator nicht direkt zu ändern.  
  
 Mit Enumeratoren können die Daten in der Auflistung zwar gelesen, jedoch nicht zum Ändern der zugrunde liegenden Auflistung verwendet werden.  
  
 Zu Beginn wird der Enumerator vor das erste Element in der Auflistung positioniert. <xref:System.Collections.IEnumerator.Reset%2A> setzt den Enumerator ebenfalls auf diese Position zurück.  An dieser Position ist <xref:System.Collections.IEnumerator.Current%2A> nicht definiert. Daher muss der Enumerator durch einen Aufruf von <xref:System.Collections.IEnumerator.MoveNext%2A> auf das erste Element der Auflistung gesetzt werden, bevor der Wert von <xref:System.Collections.IEnumerator.Current%2A> gelesen werden kann.  
  
 <xref:System.Collections.IEnumerator.Current%2A> gibt solange dasselbe Objekt zurück, bis <xref:System.Collections.IEnumerator.MoveNext%2A> oder <xref:System.Collections.IEnumerator.Reset%2A> aufgerufen wird. <xref:System.Collections.IEnumerator.MoveNext%2A> legt <xref:System.Collections.IEnumerator.Current%2A> auf das nächste Element fest.  
  
 Wenn <xref:System.Collections.IEnumerator.MoveNext%2A> das Ende der Auflistung übergibt, wird der Enumerator hinter dem letzten Element in der Auflistung platziert, und <xref:System.Collections.IEnumerator.MoveNext%2A> gibt `false` zurück. Wenn sich der Enumerator an dieser Position befindet, geben nachfolgende Aufrufe von <xref:System.Collections.IEnumerator.MoveNext%2A> auch `false` zurück. Wenn der letzte Aufruf <xref:System.Collections.IEnumerator.MoveNext%2A> zurückgegebene `false`, <xref:System.Collections.IEnumerator.Current%2A> ist nicht definiert. Um <xref:System.Collections.IEnumerator.Current%2A> wieder auf das erste Element der Auflistung festzulegen, können Sie <xref:System.Collections.IEnumerator.Reset%2A> gefolgt von <xref:System.Collections.IEnumerator.MoveNext%2A> aufrufen.  
  
 Ein Enumerator bleibt gültig, solange die Auflistung unverändert ist. Werden an der Auflistung Änderungen wie z. B. Hinzufügen, Bearbeiten oder Entfernen von Elementen vorgenommen, verliert der Enumerator unwiederbringlich seine Gültigkeit und sein Verhalten ist nicht definiert.  
  
 Der Enumerator hat keinen exklusiven Zugriff auf die Auflistung; daher ist die Enumeration einer Auflistung systembedingt kein threadsicheres Verfahren.  Um während der Enumeration Threadsicherheit zu garantieren, können Sie die Auflistung während der gesamten Enumeration sperren.  Um den Lese- und Schreibzugriff auf diese Auflistung durch mehrere Threads zuzulassen, müssen Sie eine eigene Synchronisierung implementieren.  
  
 Diese Methode ist ein O (1)-Vorgang.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IDictionaryEnumerator" />
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetKey">
      <MemberSignature Language="C#" Value="public virtual object GetKey (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetKey(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.GetKey(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetKey (index As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetKey(int index);" />
      <MemberSignature Language="F#" Value="abstract member GetKey : int -&gt; obj&#xA;override this.GetKey : int -&gt; obj" Usage="sortedList.GetKey index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Der nullbasierte Index des abzurufenden Schlüssels.</param>
        <summary>Ruft den Schlüssel am angegebenen Index in einem <see cref="T:System.Collections.SortedList" />-Objekt ab.</summary>
        <returns>Der Schlüssel am angegebenen Index im <see cref="T:System.Collections.SortedList" />-Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Index Sequenz basiert auf der Sortierreihenfolge. Wenn ein Element hinzugefügt wird, wird es <xref:System.Collections.SortedList> in der richtigen Sortierreihenfolge eingefügt, und die Indizierung wird entsprechend angepasst. Wenn ein Element entfernt wird, wird die Indizierung ebenfalls entsprechend angepasst. Daher kann sich der Index eines bestimmten Schlüssel-Wert-Paars ändern, wenn Elemente dem <xref:System.Collections.SortedList> Objekt hinzugefügt oder daraus entfernt werden.  
  
 Diese Methode ist ein O (1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie Sie einen oder alle Schlüssel oder Werte in einem <xref:System.Collections.SortedList> -Objekt erhalten.  
  
 [!code-cpp[Classic SortedList.GetByIndex Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.GetByIndex Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.GetByIndex Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> liegt außerhalb des Bereichs der gültigen Indizes für das <see cref="T:System.Collections.SortedList" />-Objekt.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetKeyList">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IList GetKeyList ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IList GetKeyList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.GetKeyList" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetKeyList () As IList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IList ^ GetKeyList();" />
      <MemberSignature Language="F#" Value="abstract member GetKeyList : unit -&gt; System.Collections.IList&#xA;override this.GetKeyList : unit -&gt; System.Collections.IList" Usage="sortedList.GetKeyList " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft die Schlüssel in einem <see cref="T:System.Collections.SortedList" />-Objekt ab.</summary>
        <returns>Ein <see cref="T:System.Collections.IList" />-Objekt, das die Schlüssel im <see cref="T:System.Collections.SortedList" />-Objekt enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das zurück <xref:System.Collections.IList> gegebene-Objekt ist eine schreibgeschützte Ansicht der Schlüssel <xref:System.Collections.SortedList> des-Objekts. An den zugrunde liegenden <xref:System.Collections.SortedList> vorgenommene Änderungen werden sofort <xref:System.Collections.IList>in widergespiegelt.  
  
 Die Elemente der zurückgegebenen <xref:System.Collections.IList> werden in der Reihenfolge sortiert, in der sich die <xref:System.Collections.SortedList>Schlüssel von befinden.  
  
 Diese Methode ähnelt der <xref:System.Collections.SortedList.Keys%2A> -Eigenschaft, gibt jedoch ein <xref:System.Collections.IList> -Objekt anstelle <xref:System.Collections.ICollection> eines-Objekts zurück.  
  
 Diese Methode ist ein O (1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie Sie einen oder alle Schlüssel oder Werte in einem <xref:System.Collections.SortedList> -Objekt erhalten.  
  
 [!code-cpp[Classic SortedList.GetByIndex Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.GetByIndex Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.GetByIndex Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="M:System.Collections.SortedList.GetValueList" />
        <altmember cref="P:System.Collections.SortedList.Keys" />
      </Docs>
    </Member>
    <Member MemberName="GetValueList">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IList GetValueList ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IList GetValueList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.GetValueList" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetValueList () As IList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IList ^ GetValueList();" />
      <MemberSignature Language="F#" Value="abstract member GetValueList : unit -&gt; System.Collections.IList&#xA;override this.GetValueList : unit -&gt; System.Collections.IList" Usage="sortedList.GetValueList " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft die Werte in einem <see cref="T:System.Collections.SortedList" />-Objekt ab.</summary>
        <returns>Ein <see cref="T:System.Collections.IList" />-Objekt, das die Werte des <see cref="T:System.Collections.SortedList" />-Objekts enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das zurück <xref:System.Collections.IList> gegebene-Objekt ist eine schreibgeschützte Ansicht der Werte <xref:System.Collections.SortedList> des-Objekts. An den zugrunde liegenden <xref:System.Collections.SortedList> vorgenommene Änderungen werden sofort <xref:System.Collections.IList>in widergespiegelt.  
  
 Die Elemente der zurückgegebenen <xref:System.Collections.IList> werden in der Reihenfolge sortiert, in der sich die <xref:System.Collections.SortedList>Werte von befinden.  
  
 Diese Methode ähnelt der <xref:System.Collections.SortedList.Values%2A> -Eigenschaft, gibt jedoch ein <xref:System.Collections.IList> -Objekt anstelle <xref:System.Collections.ICollection> eines-Objekts zurück.  
  
 Diese Methode ist ein O (1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie Sie einen oder alle Schlüssel oder Werte in einem <xref:System.Collections.SortedList> -Objekt erhalten.  
  
 [!code-cpp[Classic SortedList.GetByIndex Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.GetByIndex Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.GetByIndex Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.GetByIndex Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="M:System.Collections.SortedList.GetKeyList" />
        <altmember cref="P:System.Collections.SortedList.Values" />
      </Docs>
    </Member>
    <Member MemberName="IndexOfKey">
      <MemberSignature Language="C#" Value="public virtual int IndexOfKey (object key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOfKey(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.IndexOfKey(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IndexOfKey (key As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int IndexOfKey(System::Object ^ key);" />
      <MemberSignature Language="F#" Value="abstract member IndexOfKey : obj -&gt; int&#xA;override this.IndexOfKey : obj -&gt; int" Usage="sortedList.IndexOfKey key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Der im <see cref="T:System.Collections.SortedList" />-Objekt zu suchende Schlüssel.</param>
        <summary>Gibt den nullbasierten Index des angegebenen Schlüssels in einem <see cref="T:System.Collections.SortedList" />-Objekt zurück.</summary>
        <returns>Der nullbasierte Index des <paramref name="key" />-Parameters, wenn <paramref name="key" /> im <see cref="T:System.Collections.SortedList" />-Objekt gefunden wurde, andernfalls -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Elemente eines <xref:System.Collections.SortedList> -Objekts werden nach den Schlüsseln sortiert, entweder entsprechend einer bestimmten <xref:System.Collections.IComparer> -Implementierung, die <xref:System.Collections.SortedList> beim Erstellen von angegeben wird, oder <xref:System.IComparable> gemäß der Implementierung, die von den Schlüsseln selbst bereitgestellt wird.  
  
 Die Index Sequenz basiert auf der Sortierreihenfolge. Wenn ein Element hinzugefügt wird, wird es <xref:System.Collections.SortedList> in der richtigen Sortierreihenfolge eingefügt, und die Indizierung wird entsprechend angepasst. Wenn ein Element entfernt wird, wird die Indizierung ebenfalls entsprechend angepasst. Daher kann sich der Index eines bestimmten Schlüssel-Wert-Paars ändern, wenn Elemente hinzugefügt oder aus dem <xref:System.Collections.SortedList>entfernt werden.  
  
 Diese Methode verwendet einen binären Suchalgorithmus. Daher handelt es sich bei dieser Methode um einen `n`O (Log) `n` - <xref:System.Collections.SortedList.Count%2A>Vorgang, bei dem gleich ist.  
  
 Beginnend mit dem .NET Framework 2,0 verwendet diese Methode die- <xref:System.Object.Equals%2A> und <xref:System.IComparable.CompareTo%2A> -Methoden `item` der-Auflistung, um zu bestimmen, ob ein Element vorhanden ist. In früheren Versionen der .NET Framework wurde diese Bestimmung durch die Verwendung der <xref:System.Object.Equals%2A> -Methode und der-Methode des `item` -Parameters für die- <xref:System.IComparable.CompareTo%2A> Objekte in der-Auflistung vorgenommen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie der Index eines Schlüssels oder eines Werts in einem <xref:System.Collections.SortedList> -Objekt bestimmt wird.  
  
 [!code-cpp[Classic SortedList.IndexOfKey Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.IndexOfKey Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.IndexOfKey Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.IndexOfKey Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.IndexOfKey Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.IndexOfKey Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der Vergleich löst eine Ausnahme aus.</exception>
        <altmember cref="M:System.Collections.SortedList.ContainsKey(System.Object)" />
        <altmember cref="M:System.Collections.SortedList.IndexOfValue(System.Object)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Auflistungen</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOfValue">
      <MemberSignature Language="C#" Value="public virtual int IndexOfValue (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOfValue(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.IndexOfValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IndexOfValue (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int IndexOfValue(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member IndexOfValue : obj -&gt; int&#xA;override this.IndexOfValue : obj -&gt; int" Usage="sortedList.IndexOfValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Der im <see cref="T:System.Collections.SortedList" />-Objekt zu suchende Wert. Der Wert kann <see langword="null" /> sein.</param>
        <summary>Gibt den nullbasierten Index des ersten Vorkommens des angegebenen Werts in einem <see cref="T:System.Collections.SortedList" />-Objekt zurück.</summary>
        <returns>Der nullbasierte Index des ersten Vorkommens des <paramref name="value" />-Parameters in der Auflistung, sofern <paramref name="value" /> im <see cref="T:System.Collections.SortedList" />-Objekt gefunden wurde, andernfalls -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Index Sequenz basiert auf der Sortierreihenfolge. Wenn ein Element hinzugefügt wird, wird es <xref:System.Collections.SortedList> in der richtigen Sortierreihenfolge eingefügt, und die Indizierung wird entsprechend angepasst. Wenn ein Element entfernt wird, wird die Indizierung ebenfalls entsprechend angepasst. Daher kann sich der Index eines bestimmten Schlüssel-Wert-Paars ändern, wenn Elemente dem <xref:System.Collections.SortedList> Objekt hinzugefügt oder daraus entfernt werden.  
  
 Die Werte der Elemente des <xref:System.Collections.SortedList> werden mithilfe der <xref:System.Object.Equals%2A> -Methode mit dem angegebenen Wert verglichen.  
  
 Diese Methode verwendet eine lineare Suche. Daher ist diese Methode ein O (`n`)-Vorgang, bei dem <xref:System.Collections.SortedList.Count%2A> `n` gleich ist.  
  
 Beginnend mit dem .NET Framework 2,0 verwendet diese Methode die- <xref:System.Object.Equals%2A> und <xref:System.IComparable.CompareTo%2A> -Methoden `item` der-Auflistung, um zu bestimmen, ob ein Element vorhanden ist. In früheren Versionen der .NET Framework wurde diese Bestimmung durch die Verwendung der <xref:System.Object.Equals%2A> -Methode und der-Methode des `item` -Parameters für die- <xref:System.IComparable.CompareTo%2A> Objekte in der-Auflistung vorgenommen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie der Index eines Schlüssels oder eines Werts in einem <xref:System.Collections.SortedList> -Objekt bestimmt wird.  
  
 [!code-cpp[Classic SortedList.IndexOfKey Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.IndexOfKey Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.IndexOfKey Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.IndexOfKey Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.IndexOfKey Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.IndexOfKey Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.SortedList.ContainsValue(System.Object)" />
        <altmember cref="M:System.Collections.SortedList.IndexOfKey(System.Object)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Auflistungen</related>
      </Docs>
    </Member>
    <Member MemberName="IsFixedSize">
      <MemberSignature Language="C#" Value="public virtual bool IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Collections.SortedList.IsFixedSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsFixedSize As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFixedSize : bool" Usage="System.Collections.SortedList.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob ein <see cref="T:System.Collections.SortedList" />-Objekt eine feste Größe hat.</summary>
        <value><see langword="true" />, wenn das <see cref="T:System.Collections.SortedList" />-Objekt eine feste Größe hat, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Auflistung mit fester Größe lässt das Hinzufügen oder Entfernen von Elementen nach dem Erstellen der Auflistung nicht zu, lässt jedoch das Ändern vorhandener Elemente zu.  
  
 Eine Auflistung mit fester Größe ist einfach eine Sammlung mit einem Wrapper, der das Hinzufügen und Entfernen von Elementen verhindert. Wenn Änderungen an der zugrunde liegenden Auflistung vorgenommen werden, einschließlich hinzufügen oder Entfernen von Elementen, reflektiert die Auflistung mit fester Größe diese Änderungen.  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public virtual bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.SortedList.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Collections.SortedList.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob ein <see cref="T:System.Collections.SortedList" />-Objekt schreibgeschützt ist.</summary>
        <value><see langword="true" />, wenn das <see cref="T:System.Collections.SortedList" />-Objekt schreibgeschützt ist, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine schreibgeschützte Auflistung gestattet nach dem Erstellen der Auflistung weder das Hinzufügen noch das Ändern oder Entfernen von Elementen.  
  
 Eine Auflistung, die schreibgeschützt ist, ist einfach eine Sammlung mit einem Wrapper, der das Ändern der Auflistung verhindert. Wenn also Änderungen an der zugrunde liegenden Auflistung vorgenommen werden, reflektiert die schreibgeschützte Auflistung diese Änderungen.  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSynchronized">
      <MemberSignature Language="C#" Value="public virtual bool IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.SortedList.IsSynchronized" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSynchronized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSynchronized : bool" Usage="System.Collections.SortedList.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Zugriff auf ein <see cref="T:System.Collections.SortedList" />-Objekt synchronisiert (threadsicher) ist.</summary>
        <value><see langword="true" />, wenn der Zugriff auf das <see cref="T:System.Collections.SortedList" />-Objekt synchronisiert (threadsicher) ist, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um die Thread Sicherheit <xref:System.Collections.SortedList> eines-Objekts zu gewährleisten, müssen alle Vorgänge über den von der <xref:System.Collections.SortedList.Synchronized%2A> -Methode zurückgegebenen Wrapper durchgeführt werden.  
  
 Die Enumeration einer Auflistung ist systemintern keine threadsichere Prozedur. Selbst wenn eine Auflistung synchronisiert wird, besteht die Möglichkeit, dass andere Threads sie ändern. Dies führt dazu, dass der Enumerator eine Ausnahme auslöst. Um während der Enumeration Threadsicherheit zu gewährleisten, können Sie entweder die Auflistung während der gesamten Enumeration sperren oder die Ausnahmen, die aus von anderen Threads stammenden Änderungen resultieren, abfangen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie eine Auflistung mithilfe der <xref:System.Collections.SortedList.SyncRoot%2A> -Eigenschaft während der gesamten-Enumeration gesperrt wird.  
  
 [!code-cpp[Classic SortedList.IsSynchronized Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic SortedList.IsSynchronized Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/CS/source2.cs#2)]
 [!code-vb[Classic SortedList.IsSynchronized Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/VB/source2.vb#2)]  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
 Im folgenden Codebeispiel wird veranschaulicht, wie Sie <xref:System.Collections.SortedList> ein-Objekt synchronisieren, <xref:System.Collections.SortedList> bestimmen, ob eine synchronisiert ist, <xref:System.Collections.SortedList>und einen synchronisierten verwenden.  
  
 [!code-cpp[Classic SortedList.IsSynchronized Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.IsSynchronized Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.IsSynchronized Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.SortedList.SyncRoot" />
        <altmember cref="M:System.Collections.SortedList.Synchronized(System.Collections.SortedList)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public virtual object this[object key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(object)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.SortedList.Item(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overridable Property Item(key As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ default[System::Object ^] { System::Object ^ get(System::Object ^ key); void set(System::Object ^ key, System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Item(obj) : obj with get, set" Usage="System.Collections.SortedList.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Item(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Der Schlüssel, der dem abzurufenden oder festzulegenden Wert zugeordnet ist.</param>
        <summary>Ruft den Wert ab, der einem bestimmten Schlüssel in einem <see cref="T:System.Collections.SortedList" />-Objekt zugeordnet ist, oder legt diesen fest.</summary>
        <value>Wenn <paramref name="key" /> gefunden wird, der dem <paramref name="key" />-Parameter zugeordnete Wert im <see cref="T:System.Collections.SortedList" />-Objekt, andernfalls <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können die <xref:System.Collections.SortedList.Item%2A> -Eigenschaft verwenden, um auf ein bestimmtes Element in einer Auflistung zuzugreifen, indem Sie `myCollection[key]`die folgende Syntax angeben:.  
  
 Sie können diese Eigenschaft auch verwenden, um neue Elemente hinzuzufügen, indem Sie den Wert eines Schlüssels festlegen, der im <xref:System.Collections.SortedList> Objekt nicht vorhanden ist ( `myCollection["myNonexistentKey"] = myValue)`z. b.). Wenn jedoch der angegebene Schlüssel bereits in <xref:System.Collections.SortedList>vorhanden ist, wird durch das Festlegen der <xref:System.Collections.SortedList.Item%2A> -Eigenschaft der alte Wert überschrieben. Im Gegensatz dazu ändert <xref:System.Collections.SortedList.Add%2A> die-Methode keine vorhandenen Elemente.  
  
 Ein Schlüssel kann nicht `null`sein, aber ein Wert kann sein. Um zu unter `null` scheiden, ob der angegebene Schlüssel nicht gefunden wurde und `null` zurückgegeben wird, da der Wert des angegebenen Schlüssels ist `null`, verwenden Sie die <xref:System.Collections.SortedList.Contains%2A> -Methode oder <xref:System.Collections.SortedList.ContainsKey%2A> die-Methode, um zu bestimmen, ob der Schlüssel ist in der Liste vorhanden.  
  
 Die Elemente einer <xref:System.Collections.SortedList> werden nach den Schlüsseln sortiert, entweder entsprechend einer bestimmten <xref:System.Collections.IComparer> -Implementierung, die <xref:System.Collections.SortedList> beim Erstellen von angegeben wird, oder <xref:System.IComparable> entsprechend der Implementierung, die von den Schlüsseln selbst bereitgestellt wird.  
  
 Die C# Sprache verwendet das [`this`](~/docs/csharp/language-reference/keywords/this.md) -Schlüsselwort, um die Indexer zu definieren, <xref:System.Collections.SortedList.Keys%2A> statt die-Eigenschaft zu implementieren. Visual Basic implementiert <xref:System.Collections.SortedList.Item%2A> als Standardeigenschaft und stellt auf diese Weise dieselbe Indizierungsfunktionalität bereit.  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O (log `n`)-Vorgang, bei dem <xref:System.Collections.SortedList.Count%2A> `n` gleich ist. Das Festlegen der-Eigenschaft ist ein O `n`(Log)-Vorgang, wenn der Schlüssel <xref:System.Collections.SortedList>bereits in der vorhanden ist. Wenn der Schlüssel nicht in der Liste enthalten ist, ist das Festlegen der Eigenschaft ein`n`O ()-Vorgang für unsortierte Daten oder O `n`(Log), wenn das neue Element am Ende der Liste hinzugefügt wird. Wenn das Einfügen eine Größenänderung bewirkt, ist der Vorgang O`n`().  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Die Eigenschaft wird festgelegt, und das <see cref="T:System.Collections.SortedList" />-Objekt ist schreibgeschützt.  
  
- oder - 
Die Eigenschaft wird festgelegt, <paramref name="key" /> ist in der Auflistung nicht vorhanden, und der <see cref="T:System.Collections.SortedList" /> hat eine feste Größe.</exception>
        <exception cref="T:System.OutOfMemoryException">Es ist nicht genügend Arbeitsspeicher verfügbar, um das Element zu <see cref="T:System.Collections.SortedList" /> hinzuzufügen.</exception>
        <exception cref="T:System.InvalidOperationException">Der Vergleich löst eine Ausnahme aus.</exception>
        <altmember cref="M:System.Collections.SortedList.Add(System.Object,System.Object)" />
        <altmember cref="M:System.Collections.SortedList.Contains(System.Object)" />
        <altmember cref="M:System.Collections.SortedList.ContainsKey(System.Object)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Auflistungen</related>
      </Docs>
    </Member>
    <Member MemberName="Keys">
      <MemberSignature Language="C#" Value="public virtual System.Collections.ICollection Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection Keys" />
      <MemberSignature Language="DocId" Value="P:System.Collections.SortedList.Keys" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Keys As ICollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::ICollection ^ Keys { System::Collections::ICollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Keys : System.Collections.ICollection" Usage="System.Collections.SortedList.Keys" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Keys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Schlüssel in einem <see cref="T:System.Collections.SortedList" />-Objekt ab.</summary>
        <value>Ein <see cref="T:System.Collections.ICollection" />-Objekt, das die Schlüssel im <see cref="T:System.Collections.SortedList" />-Objekt enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das <xref:System.Collections.ICollection> -Objekt ist eine schreibgeschützte Ansicht der Schlüssel <xref:System.Collections.SortedList> des-Objekts. An den zugrunde liegenden <xref:System.Collections.SortedList> vorgenommene Änderungen werden sofort <xref:System.Collections.ICollection>in widergespiegelt.  
  
 Die Elemente <xref:System.Collections.ICollection> der werden in der Reihenfolge sortiert, in der sich die Schlüssel <xref:System.Collections.SortedList>von befinden.  
  
 Diese Eigenschaft ähnelt der <xref:System.Collections.SortedList.GetKeyList%2A> -Methode, gibt jedoch ein <xref:System.Collections.ICollection> -Objekt anstelle <xref:System.Collections.IList> eines-Objekts zurück.  
  
 Diese Methode ist ein O (1)-Vorgang.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="P:System.Collections.SortedList.Values" />
        <altmember cref="M:System.Collections.SortedList.GetKeyList" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Auflistungen</related>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public virtual void Remove (object key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Remove(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Remove (key As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Remove(System::Object ^ key);" />
      <MemberSignature Language="F#" Value="abstract member Remove : obj -&gt; unit&#xA;override this.Remove : obj -&gt; unit" Usage="sortedList.Remove key" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Der Schlüssel des zu entfernenden Elements.</param>
        <summary>Entfernt das Element mit dem angegebenen Schlüssel aus einem <see cref="T:System.Collections.SortedList" />-Objekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn das <xref:System.Collections.SortedList>-Objekt kein Element mit dem angegebenen Schlüssel enthält, bleibt das <xref:System.Collections.SortedList> unverändert. Es werden keine Ausnahmen ausgelöst.  
  
 In Auflistungen mit zusammenhängenden Elementen, beispielsweise Listen, wird die nach dem Entfernen eines Elements entstandene Lücke durch Verschieben aller nachfolgenden Elemente gefüllt. Wenn die Auflistung indiziert ist, werden auch die Indizes der verschobenen Elemente aktualisiert. Dies gilt nicht für Auflistungen, in denen die Elemente konzeptionell in Buckets gruppiert sind, beispielsweise Hashtabellen.  
  
 Diese Methode ist ein O (`n`)-Vorgang, `n` bei <xref:System.Collections.SortedList.Count%2A>dem gleich ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie Elemente aus einem <xref:System.Collections.SortedList> -Objekt entfernt werden.  
  
 [!code-cpp[Classic SortedList.RemoveAt Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.RemoveAt Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.RemoveAt Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.RemoveAt Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.RemoveAt Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.RemoveAt Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Das <see cref="T:System.Collections.SortedList" />-Objekt ist schreibgeschützt.  
  
- oder - 
<see cref="T:System.Collections.SortedList" /> hat eine feste Größe.</exception>
        <altmember cref="M:System.Collections.SortedList.RemoveAt(System.Int32)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Auflistungen</related>
      </Docs>
    </Member>
    <Member MemberName="RemoveAt">
      <MemberSignature Language="C#" Value="public virtual void RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.RemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RemoveAt (index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RemoveAt(int index);" />
      <MemberSignature Language="F#" Value="abstract member RemoveAt : int -&gt; unit&#xA;override this.RemoveAt : int -&gt; unit" Usage="sortedList.RemoveAt index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Der nullbasierte Index des zu entfernenden Elements.</param>
        <summary>Entfernt das Element am angegebenen Index aus einem <see cref="T:System.Collections.SortedList" />-Objekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Index Sequenz basiert auf der Sortierreihenfolge. Wenn ein Element hinzugefügt wird, wird es <xref:System.Collections.SortedList> in der richtigen Sortierreihenfolge eingefügt, und die Indizierung wird entsprechend angepasst. Wenn ein Element entfernt wird, wird die Indizierung ebenfalls entsprechend angepasst. Daher kann sich der Index eines bestimmten Schlüssel-Wert-Paars ändern, wenn Elemente dem <xref:System.Collections.SortedList> Objekt hinzugefügt oder daraus entfernt werden.  
  
 In Auflistungen mit zusammenhängenden Elementen, beispielsweise Listen, wird die nach dem Entfernen eines Elements entstandene Lücke durch Verschieben aller nachfolgenden Elemente gefüllt. Wenn die Auflistung indiziert ist, werden auch die Indizes der verschobenen Elemente aktualisiert. Dies gilt nicht für Auflistungen, in denen die Elemente konzeptionell in Buckets gruppiert sind, beispielsweise Hashtabellen.  
  
 Diese Methode ist ein O (`n`)-Vorgang, `n` bei <xref:System.Collections.SortedList.Count%2A>dem gleich ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie Elemente aus einem <xref:System.Collections.SortedList> -Objekt entfernt werden.  
  
 [!code-cpp[Classic SortedList.RemoveAt Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.RemoveAt Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.RemoveAt Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.RemoveAt Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.RemoveAt Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.RemoveAt Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> liegt außerhalb des Bereichs der gültigen Indizes für das <see cref="T:System.Collections.SortedList" />-Objekt.</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.SortedList" /> ist schreibgeschützt.  
  
- oder - 
<see cref="T:System.Collections.SortedList" /> hat eine feste Größe.</exception>
        <altmember cref="M:System.Collections.SortedList.Remove(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="SetByIndex">
      <MemberSignature Language="C#" Value="public virtual void SetByIndex (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetByIndex(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.SetByIndex(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetByIndex (index As Integer, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetByIndex(int index, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member SetByIndex : int * obj -&gt; unit&#xA;override this.SetByIndex : int * obj -&gt; unit" Usage="sortedList.SetByIndex (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">Der nullbasierte Index, an dem <paramref name="value" /> gespeichert werden soll.</param>
        <param name="value">Das <see cref="T:System.Object" />, das im <see cref="T:System.Collections.SortedList" />-Objekt gespeichert werden soll. Der Wert kann <see langword="null" /> sein.</param>
        <summary>Ersetzt den Wert an einem bestimmten Index in einem <see cref="T:System.Collections.SortedList" />-Objekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Index Sequenz basiert auf der Sortierreihenfolge. Wenn ein Element hinzugefügt wird, wird es <xref:System.Collections.SortedList> in der richtigen Sortierreihenfolge eingefügt, und die Indizierung wird entsprechend angepasst. Wenn ein Element entfernt wird, wird die Indizierung ebenfalls entsprechend angepasst. Daher kann sich der Index eines bestimmten Schlüssel-Wert-Paars ändern, wenn Elemente dem <xref:System.Collections.SortedList> Objekt hinzugefügt oder daraus entfernt werden.  
  
 Diese Methode ist ein O (1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie der Wert eines vorhandenen Elements in einem <xref:System.Collections.SortedList> -Objekt ersetzt wird.  
  
 [!code-cpp[Classic SortedList.SetByIndex Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.SetByIndex Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.SetByIndex Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.SetByIndex Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.SetByIndex Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.SetByIndex Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> liegt außerhalb des Bereichs der gültigen Indizes für das <see cref="T:System.Collections.SortedList" />-Objekt.</exception>
        <altmember cref="M:System.Collections.SortedList.IndexOfKey(System.Object)" />
        <altmember cref="M:System.Collections.SortedList.IndexOfValue(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Synchronized">
      <MemberSignature Language="C#" Value="public static System.Collections.SortedList Synchronized (System.Collections.SortedList list);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.SortedList Synchronized(class System.Collections.SortedList list) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.Synchronized(System.Collections.SortedList)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Synchronized (list As SortedList) As SortedList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::SortedList ^ Synchronized(System::Collections::SortedList ^ list);" />
      <MemberSignature Language="F#" Value="static member Synchronized : System.Collections.SortedList -&gt; System.Collections.SortedList" Usage="System.Collections.SortedList.Synchronized list" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.SortedList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="list" Type="System.Collections.SortedList" />
      </Parameters>
      <Docs>
        <param name="list">Das <see cref="T:System.Collections.SortedList" />-Objekt, das synchronisiert werden soll.</param>
        <summary>Gibt einen synchronisierten (threadsicheren) Wrapper für ein <see cref="T:System.Collections.SortedList" />-Objekt zurück.</summary>
        <returns>Ein synchronisierter (threadsicherer) Wrapper das <see cref="T:System.Collections.SortedList" />-Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um die Thread Sicherheit <xref:System.Collections.SortedList> eines-Objekts zu gewährleisten, müssen alle Vorgänge nur über diesen Wrapper ausgeführt werden.  
  
 Die Enumeration einer Auflistung ist systemintern keine threadsichere Prozedur. Selbst wenn eine Auflistung synchronisiert wird, besteht die Möglichkeit, dass andere Threads sie ändern. Dies führt dazu, dass der Enumerator eine Ausnahme auslöst. Um während der Enumeration Threadsicherheit zu gewährleisten, können Sie entweder die Auflistung während der gesamten Enumeration sperren oder die Ausnahmen, die aus von anderen Threads stammenden Änderungen resultieren, abfangen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie die-Auflistung mit <xref:System.Collections.SortedList.SyncRoot%2A> der-Eigenschaft während der gesamten-Enumeration gesperrt wird.  
  
 [!code-cpp[Classic SortedList.IsSynchronized Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic SortedList.IsSynchronized Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/CS/source2.cs#2)]
 [!code-vb[Classic SortedList.IsSynchronized Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/VB/source2.vb#2)]  
  
 Diese Methode ist ein O (1)-Vorgang.  
  
 Im folgenden Codebeispiel wird veranschaulicht, wie Sie <xref:System.Collections.SortedList> ein-Objekt synchronisieren, <xref:System.Collections.SortedList> bestimmen, ob eine synchronisiert ist, <xref:System.Collections.SortedList>und einen synchronisierten verwenden.  
  
 [!code-cpp[Classic SortedList.IsSynchronized Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.IsSynchronized Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.IsSynchronized Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="list" /> ist <see langword="null" />.</exception>
        <altmember cref="P:System.Collections.SortedList.IsSynchronized" />
        <altmember cref="P:System.Collections.SortedList.SyncRoot" />
      </Docs>
    </Member>
    <Member MemberName="SyncRoot">
      <MemberSignature Language="C#" Value="public virtual object SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.SortedList.SyncRoot" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SyncRoot As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SyncRoot : obj" Usage="System.Collections.SortedList.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein Objekt ab, mit dem der Zugriff auf ein <see cref="T:System.Collections.SortedList" />-Objekt synchronisiert werden kann.</summary>
        <value>Ein Objekt, mit dem der Zugriff auf das <see cref="T:System.Collections.SortedList" />-Objekt synchronisiert werden kann.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie die <xref:System.Collections.SortedList.Synchronized%2A> -Methode, um <xref:System.Collections.SortedList> eine synchronisierte Version des-Objekts zu erstellen. Abgeleitete Klassen können jedoch <xref:System.Collections.SortedList> mithilfe der <xref:System.Collections.SortedList.SyncRoot%2A> -Eigenschaft eine eigene synchronisierte Version von bereitstellen. Der Synchronisierungs Code muss Vorgänge für die <xref:System.Collections.SortedList.SyncRoot%2A> <xref:System.Collections.SortedList>von, nicht direkt auf dem <xref:System.Collections.SortedList>ausführen. Dies gewährleistet die einwandfreie Funktion von Auflistungen, die von anderen Objekten abgeleitet sind. Insbesondere wird die ordnungsgemäße Synchronisierung mit anderen Threads verwaltet, die das <xref:System.Collections.SortedList> Objekt möglicherweise gleichzeitig ändern.  
  
 Die Enumeration einer Auflistung ist systemintern keine threadsichere Prozedur. Selbst wenn eine Auflistung synchronisiert wird, besteht die Möglichkeit, dass andere Threads sie ändern. Dies führt dazu, dass der Enumerator eine Ausnahme auslöst. Um während der Enumeration Threadsicherheit zu gewährleisten, können Sie entweder die Auflistung während der gesamten Enumeration sperren oder die Ausnahmen, die aus von anderen Threads stammenden Änderungen resultieren, abfangen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie die-Auflistung mit <xref:System.Collections.SortedList.SyncRoot%2A> der-Eigenschaft während der gesamten-Enumeration gesperrt wird.  
  
 [!code-cpp[Classic SortedList.IsSynchronized Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic SortedList.IsSynchronized Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/CS/source2.cs#2)]
 [!code-vb[Classic SortedList.IsSynchronized Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.IsSynchronized Example/VB/source2.vb#2)]  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.SortedList.IsSynchronized" />
        <altmember cref="M:System.Collections.SortedList.Synchronized(System.Collections.SortedList)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen <see cref="T:System.Collections.IEnumerator" /> zurück, der <see cref="T:System.Collections.SortedList" /> durchläuft.</summary>
        <returns>Ein <see cref="T:System.Collections.IEnumerator" /> für das <see cref="T:System.Collections.SortedList" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [Visual Basic, C#]  
  
 Die `foreach`-Anweisung der Programmiersprache C# (`for each` in Visual Basic) verbirgt die Komplexität der Enumeratoren.  Daher empfiehlt es sich, `foreach` zu verwenden und den Enumerator nicht direkt zu ändern.  
  
 Mit Enumeratoren können die Daten in der Auflistung zwar gelesen, jedoch nicht zum Ändern der zugrunde liegenden Auflistung verwendet werden.  
  
 Zu Beginn wird der Enumerator vor das erste Element in der Auflistung positioniert. <xref:System.Collections.IEnumerator.Reset%2A> setzt den Enumerator ebenfalls auf diese Position zurück. An dieser Position löst der <xref:System.Collections.IEnumerator.Current%2A> Aufruf von eine Ausnahme aus. Daher muss der Enumerator durch einen Aufruf von <xref:System.Collections.IEnumerator.MoveNext%2A> auf das erste Element der Auflistung gesetzt werden, bevor der Wert von <xref:System.Collections.IEnumerator.Current%2A> gelesen werden kann.  
  
 <xref:System.Collections.IEnumerator.Current%2A> gibt solange dasselbe Objekt zurück, bis <xref:System.Collections.IEnumerator.MoveNext%2A> oder <xref:System.Collections.IEnumerator.Reset%2A> aufgerufen wird. <xref:System.Collections.IEnumerator.MoveNext%2A> legt <xref:System.Collections.IEnumerator.Current%2A> auf das nächste Element fest.  
  
 Wenn <xref:System.Collections.IEnumerator.MoveNext%2A> das Ende der Auflistung übergibt, wird der Enumerator hinter dem letzten Element in der Auflistung platziert, und <xref:System.Collections.IEnumerator.MoveNext%2A> gibt `false` zurück. Wenn sich der Enumerator an dieser Position befindet, geben nachfolgende Aufrufe von <xref:System.Collections.IEnumerator.MoveNext%2A> auch `false` zurück. Wenn der letzte Aufruf von <xref:System.Collections.IEnumerator.MoveNext%2A> zurück `false`gegeben wird <xref:System.Collections.IEnumerator.Current%2A> , löst der Aufruf von eine Ausnahme aus. Um <xref:System.Collections.IEnumerator.Current%2A> wieder auf das erste Element der Auflistung festzulegen, können Sie <xref:System.Collections.IEnumerator.Reset%2A> gefolgt von <xref:System.Collections.IEnumerator.MoveNext%2A> aufrufen.  
  
 Ein Enumerator bleibt gültig, solange die Auflistung unverändert ist. Wenn an der Auflistung Änderungen vorgenommen werden, z. b. das Hinzufügen, ändern oder Löschen von Elementen, wird der Enumerator unwiederbringlich ungültig, <xref:System.Collections.IEnumerator.MoveNext%2A> und <xref:System.Collections.IEnumerator.Reset%2A> der nächste <xref:System.InvalidOperationException>Rückruf von oder löst eine aus. Wenn die Auflistung zwischen <xref:System.Collections.IEnumerator.MoveNext%2A> und geändert wird, <xref:System.Collections.IEnumerator.Current%2A> gibt das- <xref:System.Collections.IEnumerator.Current%2A>Element zurück, auf das Sie festgelegt ist, auch wenn der Enumerator bereits für ungültig erklärt wurde.  
  
 Der Enumerator hat keinen exklusiven Zugriff auf die Auflistung; daher ist die Enumeration einer Auflistung systembedingt kein threadsicheres Verfahren. Selbst wenn eine Auflistung synchronisiert wird, besteht die Möglichkeit, dass andere Threads sie ändern. Dies führt dazu, dass der Enumerator eine Ausnahme auslöst. Um während der Enumeration Threadsicherheit zu gewährleisten, können Sie entweder die Auflistung während der gesamten Enumeration sperren oder die Ausnahmen, die aus von anderen Threads stammenden Änderungen resultieren, abfangen.  
  
 Diese Methode ist ein O (1)-Vorgang.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IDictionaryEnumerator" />
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="TrimToSize">
      <MemberSignature Language="C#" Value="public virtual void TrimToSize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void TrimToSize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.SortedList.TrimToSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub TrimToSize ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void TrimToSize();" />
      <MemberSignature Language="F#" Value="abstract member TrimToSize : unit -&gt; unit&#xA;override this.TrimToSize : unit -&gt; unit" Usage="sortedList.TrimToSize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Legt die Kapazität auf die tatsächliche Anzahl der in einem <see cref="T:System.Collections.SortedList" />-Objekt enthaltenen Elemente fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann verwendet werden, um den Arbeitsspeicher Aufwand einer Sammlung zu minimieren, wenn der Auflistung keine neuen Elemente hinzugefügt werden.  
  
 Um ein <xref:System.Collections.SortedList> -Objekt auf seinen ursprünglichen Zustand zurückzusetzen, <xref:System.Collections.SortedList.Clear%2A> rufen Sie die <xref:System.Collections.SortedList.TrimToSize%2A>-Methode auf, bevor Sie aufrufen. Durch Kürzen eines <xref:System.Collections.SortedList> leeren wird die Kapazität von aufdieStandardkapazitätfestgelegt.<xref:System.Collections.SortedList>  
  
 Diese Methode ist ein O (`n`)-Vorgang, `n` bei <xref:System.Collections.SortedList.Count%2A>dem gleich ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie die nicht verwendeten Teile eines <xref:System.Collections.SortedList> -Objekts beschnitten werden und wie die Werte gelöscht werden.  
  
 [!code-cpp[Classic SortedList.Clear Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic SortedList.Clear Example/CPP/source.cpp#1)]
 [!code-csharp[Classic SortedList.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SortedList.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic SortedList.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SortedList.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Das <see cref="T:System.Collections.SortedList" />-Objekt ist schreibgeschützt.  
  
- oder - 
<see cref="T:System.Collections.SortedList" /> hat eine feste Größe.</exception>
        <altmember cref="M:System.Collections.SortedList.Clear" />
        <altmember cref="P:System.Collections.SortedList.Capacity" />
        <altmember cref="P:System.Collections.SortedList.Count" />
      </Docs>
    </Member>
    <Member MemberName="Values">
      <MemberSignature Language="C#" Value="public virtual System.Collections.ICollection Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection Values" />
      <MemberSignature Language="DocId" Value="P:System.Collections.SortedList.Values" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Values As ICollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::ICollection ^ Values { System::Collections::ICollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Values : System.Collections.ICollection" Usage="System.Collections.SortedList.Values" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Values</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Werte in einem <see cref="T:System.Collections.SortedList" />-Objekt ab.</summary>
        <value>Ein <see cref="T:System.Collections.ICollection" />-Objekt, das die Werte des <see cref="T:System.Collections.SortedList" />-Objekts enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das <xref:System.Collections.ICollection> -Objekt ist eine schreibgeschützte Ansicht der Werte <xref:System.Collections.SortedList> des-Objekts. An den zugrunde liegenden <xref:System.Collections.SortedList> vorgenommene Änderungen werden sofort <xref:System.Collections.ICollection>in widergespiegelt.  
  
 Die Elemente <xref:System.Collections.ICollection> der werden in der Reihenfolge sortiert, in der sich die Werte <xref:System.Collections.SortedList>von befinden.  
  
 Diese Eigenschaft ähnelt der <xref:System.Collections.SortedList.GetValueList%2A> -Methode, gibt jedoch ein <xref:System.Collections.ICollection> -Objekt anstelle <xref:System.Collections.IList> eines-Objekts zurück.  
  
 Diese Methode ist ein O (1)-Vorgang.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="P:System.Collections.SortedList.Keys" />
        <altmember cref="M:System.Collections.SortedList.GetValueList" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Auflistungen</related>
      </Docs>
    </Member>
  </Members>
</Type>
