<Type Name="INormalizeForIsolatedStorage" FullName="System.IO.IsolatedStorage.INormalizeForIsolatedStorage">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="318f83d32bcaea61fe7f94f0d9bc4ac10d11bc4f" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30414944" />
  </Metadata>
  <TypeSignature Language="C#" Value="public interface INormalizeForIsolatedStorage" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract INormalizeForIsolatedStorage" />
  <TypeSignature Language="DocId" Value="T:System.IO.IsolatedStorage.INormalizeForIsolatedStorage" />
  <TypeSignature Language="VB.NET" Value="Public Interface INormalizeForIsolatedStorage" />
  <TypeSignature Language="C++ CLI" Value="public interface class INormalizeForIsolatedStorage" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Aktiviert den Vergleich zwischen einem isolierten Speicher und einem Beweis einer Anwendungsdomäne und einer Assembly.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Isolierte Speicherung Indizien und Spuren zu einer Assembly, damit es identifiziert und ihn mit einem eindeutigen Dateinamen Speicherort angeben. Wenn eine Assembly einen Speicher anfordert, wird seine Beweis (wie durch den Host, die sie geladen dargestellt) verarbeitet und im Vergleich mit dem Beweis verwendet, um die vorhandenen Speicher zu erstellen. Dies bestimmt, ob Sie einen neuen Speicher erstellen müssen, oder wenn eine für die betreffende Assembly bereits vorhanden ist. Aufgrund der Vergleichsmethode, die verwendet wird können Teile von Beweisen, die funktionell gleichwertig sind nicht in einem Vergleich "true" ergeben, wenn die serialisierten Formen nicht identisch sind. Beim Implementieren benutzerdefinierter Beweise, erwägen Sie, ob dies der Fall für die Beweisklasse ist, und wenn dies der Fall ist, implementieren Sie <xref:System.IO.IsolatedStorage.INormalizeForIsolatedStorage>. Nach Spuren, die diese Schnittstelle implementiert, die <xref:System.IO.IsolatedStorage.INormalizeForIsolatedStorage.Normalize%2A> Methode wird aufgerufen, und Vergleiche werden basierend auf der normalisierten Kopie des Objekts, das von dieser Methode zurückgegeben.  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>Implementieren Sie diese Schnittstelle, wenn Sie benutzerdefinierten Beweis implementieren und zu bestimmen, ob bereits ein Speicher benötigen. Serialisierte Objekte sollten nicht für Vergleiche in einigen Fällen, beispielsweise von Groß-/Kleinschreibung beachtet Zeichenfolgen verwendet werden. Beispielsweise www.MSN.com WWW.msn.com entspricht, und gibt zurück, eine <see langword="true" /> bei einem Vergleich. Zum Erstellen einer <see cref="T:System.IO.IsolatedStorage.INormalizeForIsolatedStorage" /> -Objekt müssen Sie zum Implementieren der <see cref="M:System.IO.IsolatedStorage.INormalizeForIsolatedStorage.Normalize" /> Methode.</para>
    </block>
    <block subset="none" type="usage">
      <para>Rufen Sie die Methoden dieser Schnittstelle die Instanz zu normalisieren, bevor Speicher Vergleiche zwischen einer Assembly Beweis und den derzeit vorhandenen isoliert werden.</para>
    </block>
  </Docs>
  <Members>
    <Member MemberName="Normalize">
      <MemberSignature Language="C#" Value="public object Normalize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Normalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.INormalizeForIsolatedStorage.Normalize" />
      <MemberSignature Language="VB.NET" Value="Public Function Normalize () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Normalize();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine normalisierte Kopie des Objekts zurück, für das es aufgerufen wurde, wenn es in einer abgeleiteten Klasse überschrieben wird.</summary>
        <returns>Ein normalisiertes Objekt, das die Instanz darstellt, für die diese Methode aufgerufen wurde. Die Instanz kann eine Zeichenfolge, ein Stream oder ein beliebiges serialisierbares Objekt sein.</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie diese Methode überschreiben, und das zurückgegebene Objekt ein Stream ist, wird davon ausgegangen, dass serialisiert werden und wird direkt an die serialisierte Form des Beweises zum Erstellen von vorhandenen Speicher verglichen. Wenn das zurückgegebene Objekt eine Zeichenfolge ist, wird es als den Namen des einem isolierten Speicher und im Vergleich zu den Namen der vorhandenen Speicher.</para>
        </block>
        <block subset="none" type="usage">
          <para>Sie rufen diese Methode in der Regel auf, wenn Sie aus dem isolierten Speicher abgeleitete Klasse schreiben, und Sie müssen Sie überprüfen, um festzustellen, ob der isolierte Speicher für die aktuelle Assembly ist bereits vorhanden.</para>
        </block>
      </Docs>
    </Member>
  </Members>
</Type>