<Type Name="IsolatedStorageFileStream" FullName="System.IO.IsolatedStorage.IsolatedStorageFileStream">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="9de43a34ac56793b4be3d2c25e97f029aab52c93" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37654455" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class IsolatedStorageFileStream : System.IO.FileStream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit IsolatedStorageFileStream extends System.IO.FileStream" />
  <TypeSignature Language="DocId" Value="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" />
  <TypeSignature Language="VB.NET" Value="Public Class IsolatedStorageFileStream&#xA;Inherits FileStream" />
  <TypeSignature Language="C++ CLI" Value="public ref class IsolatedStorageFileStream : System::IO::FileStream" />
  <TypeSignature Language="F#" Value="type IsolatedStorageFileStream = class&#xA;    inherit FileStream" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.FileStream</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Macht eine Datei im isolierten Speicher verfügbar.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Klasse zum Lesen, schreiben und erstellen Sie die Dateien im isolierten Speicher.  
  
 Da diese Klasse erweitert <xref:System.IO.FileStream>, können Sie eine Instanz von <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> in den meisten Fällen, in denen eine <xref:System.IO.FileStream> andernfalls verwendet werden kann, z. B. zum Erstellen einer <xref:System.IO.StreamReader> oder <xref:System.IO.StreamWriter>.  
  
 Dieser Typ implementiert die <xref:System.IDisposable> Schnittstelle. Wenn Sie mit dem Typ haben, sollten Sie es entweder direkt oder indirekt freigeben. Damit des Typs direkt freigegeben werden, rufen Sie die <xref:System.IDisposable.Dispose%2A> -Methode in einer `try` / `catch` Block. Um sie indirekt löschen, verwenden Sie ein Sprachkonstrukt wie `using` (in c#) oder `Using` (in Visual Basic). Weitere Informationen finden Sie im Abschnitt "mithilfe von ein-Objekt, das implementiert" IDisposable "" in der <xref:System.IDisposable> schnittstellenthema.  
  
> [!IMPORTANT]
>  Isolierte Speicherung ist nicht für [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]-Apps verfügbar. Verwenden Sie stattdessen die zum Speichern von lokalen Daten und Dateien in der `Windows.Storage`-API enthaltenen Anwendungsdatenklassen in den [!INCLUDE[wrt](~/includes/wrt-md.md)]-Namespaces. Weitere Informationen finden Sie im Windows Developer Center unter [Anwendungsdaten](http://go.microsoft.com/fwlink/?LinkId=229175) .  
  
   
  
## Examples  
 Die folgende Konsolenanwendung zeigt, wie Sie verwenden können <xref:System.IO.IsolatedStorage.IsolatedStorageFile> und <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> Daten in eine Datei im isolierten Speicher geschrieben. Der Benutzer wird aufgefordert, sich anzumelden. Wenn der Benutzer einen neuen Benutzer ist, werden eine Nachrichten-URL und eine Sport-URL als persönliche Einstellungen in einem isolierten Speicher aufgezeichnet. Wenn der Benutzer einen Benutzer zurückgeben, werden die aktuellen benutzereinstellungen angezeigt. Die Codebeispiele in diesem Namespace verwendet, werden im Rahmen dieser beispielanwendung angezeigt. Sie können die [Storeadm.exe (Isolated Storage-Tool)](~/docs/framework/tools/storeadm-exe-isolated-storage-tool.md) Hilfsprogramm zum Auflisten und entfernen die Dateien der isolierten Speicherung, die mit dieser Konsolenanwendung erstellt werden.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#1)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#1)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" />-Klasse. Ein <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> kann nur von einem seiner Konstruktoren geöffnet werden.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IsolatedStorageFileStream (string path, System.IO.FileMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IsolatedStorageFileStream(System::String ^ path, System::IO::FileMode mode);" />
      <MemberSignature Language="F#" Value="new System.IO.IsolatedStorage.IsolatedStorageFileStream : string * System.IO.FileMode -&gt; System.IO.IsolatedStorage.IsolatedStorageFileStream" Usage="new System.IO.IsolatedStorage.IsolatedStorageFileStream (path, mode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="path">Der relative Pfad der Datei innerhalb des isolierten Speichers.</param>
        <param name="mode">Einer der <see cref="T:System.IO.FileMode" />-Werte.</param>
        <summary>Initialisiert eine neue Instanz eines <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" />-Objekts, das im angegebenen <paramref name="mode" /> Zugriff auf die mit <paramref name="path" /> bezeichnete Datei ermöglicht.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Von der aktuell ausgeführten Assembly-Identität und der Anwendungsdomäne, in der er ausgeführt wird, bezieht sich der isolierte Speicher, der verwendet wird. Dieser Speicher wird nur für die Lebensdauer des geöffnet bleiben die <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> Objekt. An einem anderen isolierten Speicherbereichs oder erlaubt den Speicher geöffnet bleiben (also mehrere <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> Objekte daraus geöffnet werden können), verwenden Sie die Form des Konstruktors, die akzeptiert eine <xref:System.IO.IsolatedStorage.IsolatedStorageFile> Objekt.  
  
 Die `mode` Parameter gibt an, ob eine neue Datei erstellt werden soll, eine vorhandene verwendet und So weiter.  
  
> [!CAUTION]
>  Wenn Sie kompilieren Sie eine Gruppe von Zeichen mit einer bestimmten kulturellen Einstellung und die gleichen Zeichen mit der eine andere kultureinstellung abrufen, werden die Zeichen können nicht interpretiert werden und können dazu führen, dass eine Ausnahme ausgelöst werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das Format von <paramref name="path" /> ist ungültig.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Das Verzeichnis in <paramref name="path" /> ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Es wurde keine Datei gefunden, und <paramref name="mode" /> ist auf <see cref="F:System.IO.FileMode.Open" /> festgelegt.</exception>
        <permission cref="T:System.Security.Permissions.IsolatedStorageFilePermission">für den Zugriff von isoliertem Speicher</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IsolatedStorageFileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IsolatedStorageFileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="new System.IO.IsolatedStorage.IsolatedStorageFileStream : string * System.IO.FileMode * System.IO.FileAccess -&gt; System.IO.IsolatedStorage.IsolatedStorageFileStream" Usage="new System.IO.IsolatedStorage.IsolatedStorageFileStream (path, mode, access)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path">Der relative Pfad der Datei innerhalb des isolierten Speichers.</param>
        <param name="mode">Einer der <see cref="T:System.IO.FileMode" />-Werte.</param>
        <param name="access">Eine bitweise Kombination der <see cref="T:System.IO.FileAccess" />-Werte.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" />-Klasse, die im angegebenen <paramref name="mode" /> mit der Art des angeforderten <paramref name="access" /> einen Zugriff auf die mit <paramref name="path" /> bezeichnete Datei ermöglicht.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Von der aktuell ausgeführten Assembly-Identität und der Anwendungsdomäne, in der er ausgeführt wird, bezieht sich der isolierte Speicher, der verwendet wird. Dieser Speicher wird nur für die Lebensdauer des geöffnet bleiben die <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> Objekt. An einem anderen isolierten Speicherbereichs oder erlaubt den Speicher geöffnet bleiben (also mehrere <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> Objekte daraus geöffnet werden können), verwenden Sie die Form des Konstruktors, die akzeptiert eine <xref:System.IO.IsolatedStorage.IsolatedStorageFile> Objekt.  
  
 Die `mode` Parameter gibt an, ob eine neue Datei erstellt werden soll, oder eine vorhandene verwendet. Die `access` Parameter enthält, schreibgeschützt, Lese-/Schreibzugriff, und nur-schreiben.  
  
> [!CAUTION]
>  Wenn Sie kompilieren Sie eine Gruppe von Zeichen mit einer bestimmten kulturellen Einstellung und die gleichen Zeichen mit der eine andere kultureinstellung abrufen, werden die Zeichen können nicht interpretiert werden, und können dazu führen, dass eine Ausnahme ausgelöst werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das Format von <paramref name="path" /> ist ungültig.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Es wurde keine Datei gefunden, und <paramref name="mode" /> ist auf <see cref="F:System.IO.FileMode.Open" /> festgelegt.</exception>
        <permission cref="T:System.Security.Permissions.IsolatedStorageFilePermission">für den Zugriff von isoliertem Speicher</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IsolatedStorageFileStream (string path, System.IO.FileMode mode, System.IO.IsolatedStorage.IsolatedStorageFile isf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, class System.IO.IsolatedStorage.IsolatedStorageFile isf) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.IsolatedStorage.IsolatedStorageFile)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, isf As IsolatedStorageFile)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IsolatedStorageFileStream(System::String ^ path, System::IO::FileMode mode, System::IO::IsolatedStorage::IsolatedStorageFile ^ isf);" />
      <MemberSignature Language="F#" Value="new System.IO.IsolatedStorage.IsolatedStorageFileStream : string * System.IO.FileMode * System.IO.IsolatedStorage.IsolatedStorageFile -&gt; System.IO.IsolatedStorage.IsolatedStorageFileStream" Usage="new System.IO.IsolatedStorage.IsolatedStorageFileStream (path, mode, isf)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="isf" Type="System.IO.IsolatedStorage.IsolatedStorageFile" />
      </Parameters>
      <Docs>
        <param name="path">Der relative Pfad der Datei innerhalb des isolierten Speichers.</param>
        <param name="mode">Einer der <see cref="T:System.IO.FileMode" />-Werte.</param>
        <param name="isf">Die <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFile" />, in der der <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> geöffnet werden soll.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" />-Klasse, die im angegebenen <paramref name="mode" /> und im Kontext der durch <paramref name="isf" /> angegebenen <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFile" />-Klasse Zugriff auf die durch <paramref name="path" /> bezeichnete Datei ermöglicht.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `mode` Parameter gibt an, ob eine neue Datei erstellt werden soll, eine vorhandene verwendet und So weiter.  
  
> [!CAUTION]
>  Wenn Sie kompilieren Sie eine Gruppe von Zeichen mit einer bestimmten kulturellen Einstellung und die gleichen Zeichen mit der eine andere kultureinstellung abrufen, werden die Zeichen können nicht interpretiert werden, und können dazu führen, dass eine Ausnahme ausgelöst werden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung dieses Konstruktors veranschaulicht. Den vollständigen Kontext dieses Beispiels, finden Sie unter den <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> Übersicht.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#11)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#11)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das Format von <paramref name="path" /> ist ungültig.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Es wurde keine Datei gefunden, und <paramref name="mode" /> ist auf <see cref="F:System.IO.FileMode.Open" /> festgelegt.</exception>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">
          <paramref name="isf" /> hat kein Kontingent.</exception>
        <permission cref="T:System.Security.Permissions.IsolatedStorageFilePermission">für den Zugriff von isoliertem Speicher</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IsolatedStorageFileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IsolatedStorageFileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share);" />
      <MemberSignature Language="F#" Value="new System.IO.IsolatedStorage.IsolatedStorageFileStream : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare -&gt; System.IO.IsolatedStorage.IsolatedStorageFileStream" Usage="new System.IO.IsolatedStorage.IsolatedStorageFileStream (path, mode, access, share)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
      </Parameters>
      <Docs>
        <param name="path">Der relative Pfad der Datei innerhalb des isolierten Speichers.</param>
        <param name="mode">Einer der <see cref="T:System.IO.FileMode" />-Werte.</param>
        <param name="access">Eine bitweise Kombination der <see cref="T:System.IO.FileAccess" />-Werte.</param>
        <param name="share">Eine bitweise Kombination der <see cref="T:System.IO.FileShare" />-Werte.</param>
        <summary>Initialisiert eine neue Instanz einer <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" />-Klasse, die im angegebenen <paramref name="mode" /> mit dem angegebenen Datei-<paramref name="access" /> und unter Verwendung des durch <paramref name="share" /> angegebenen Dateifreigabemodus Zugriff auf die durch <paramref name="path" /> angegebene Datei ermöglicht.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Von der aktuell ausgeführten Assembly-Identität und der Anwendungsdomäne, in der er ausgeführt wird, bezieht sich der isolierte Speicher, der verwendet wird. Dieser Speicher wird nur für die Lebensdauer des geöffnet bleiben die <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> Objekt. An einem anderen isolierten Speicherbereichs oder erlaubt den Speicher geöffnet bleiben (also mehrere <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> Objekte daraus geöffnet werden können), verwenden Sie die Form des Konstruktors, die akzeptiert eine <xref:System.IO.IsolatedStorage.IsolatedStorageFile> Objekt.  
  
> [!CAUTION]
>  Wenn Sie kompilieren Sie eine Gruppe von Zeichen mit einer bestimmten kulturellen Einstellung und die gleichen Zeichen mit der eine andere kultureinstellung abrufen, werden die Zeichen können nicht interpretiert werden und können dazu führen, dass eine Ausnahme ausgelöst werden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung dieses Konstruktors veranschaulicht. Den vollständigen Kontext dieses Beispiels, finden Sie unter den <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> Übersicht.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#15)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#15)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das Format von <paramref name="path" /> ist ungültig.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Es wurde keine Datei gefunden, und <paramref name="mode" /> ist auf <see cref="F:System.IO.FileMode.Open" /> festgelegt.</exception>
        <permission cref="T:System.Security.Permissions.IsolatedStorageFilePermission">für den Zugriff von isoliertem Speicher</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IsolatedStorageFileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.IsolatedStorage.IsolatedStorageFile isf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, class System.IO.IsolatedStorage.IsolatedStorageFile isf) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.IsolatedStorage.IsolatedStorageFile)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, isf As IsolatedStorageFile)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IsolatedStorageFileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::IsolatedStorage::IsolatedStorageFile ^ isf);" />
      <MemberSignature Language="F#" Value="new System.IO.IsolatedStorage.IsolatedStorageFileStream : string * System.IO.FileMode * System.IO.FileAccess * System.IO.IsolatedStorage.IsolatedStorageFile -&gt; System.IO.IsolatedStorage.IsolatedStorageFileStream" Usage="new System.IO.IsolatedStorage.IsolatedStorageFileStream (path, mode, access, isf)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="isf" Type="System.IO.IsolatedStorage.IsolatedStorageFile" />
      </Parameters>
      <Docs>
        <param name="path">Der relative Pfad der Datei innerhalb des isolierten Speichers.</param>
        <param name="mode">Einer der <see cref="T:System.IO.FileMode" />-Werte.</param>
        <param name="access">Eine bitweise Kombination der <see cref="T:System.IO.FileAccess" />-Werte.</param>
        <param name="isf">Die <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFile" />, in der der <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> geöffnet werden soll.</param>
        <summary>Initialisiert eine neue Instanz einer <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" />-Klasse, die im angegebenen <paramref name="mode" /> im durch <paramref name="isf" /> angegebenen Kontext von <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFile" /> den angegebenen Datei-<paramref name="access" /> auf die durch <paramref name="path" /> definierte Datei ermöglicht.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `mode` Parameter gibt an, ob eine neue Datei erstellt werden soll, oder eine vorhandene verwendet. Die `access` Parameter enthält, schreibgeschützt, Lese-/Schreibzugriff, und nur-schreiben.  
  
> [!CAUTION]
>  Wenn Sie kompilieren Sie eine Gruppe von Zeichen mit einer bestimmten kulturellen Einstellung und die gleichen Zeichen mit der eine andere kultureinstellung abrufen, werden die Zeichen können nicht interpretiert werden, und können dazu führen, dass eine Ausnahme ausgelöst werden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung dieses Konstruktors veranschaulicht. Den vollständigen Kontext dieses Beispiels, finden Sie unter den <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> Übersicht.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#10)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#10)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das Format von <paramref name="path" /> ist ungültig.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Der isolierte Speicher wird geschlossen.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Es wurde keine Datei gefunden, und <paramref name="mode" /> ist auf <see cref="F:System.IO.FileMode.Open" /> festgelegt.</exception>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">
          <paramref name="isf" /> hat kein Kontingent.</exception>
        <permission cref="T:System.Security.Permissions.IsolatedStorageFilePermission">für den Zugriff von isoliertem Speicher</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IsolatedStorageFileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare, bufferSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IsolatedStorageFileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, int bufferSize);" />
      <MemberSignature Language="F#" Value="new System.IO.IsolatedStorage.IsolatedStorageFileStream : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare * int -&gt; System.IO.IsolatedStorage.IsolatedStorageFileStream" Usage="new System.IO.IsolatedStorage.IsolatedStorageFileStream (path, mode, access, share, bufferSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="path">Der relative Pfad der Datei innerhalb des isolierten Speichers.</param>
        <param name="mode">Einer der <see cref="T:System.IO.FileMode" />-Werte.</param>
        <param name="access">Eine bitweise Kombination der <see cref="T:System.IO.FileAccess" />-Werte.</param>
        <param name="share">Eine bitweise Kombination der <see cref="T:System.IO.FileShare" />-Werte.</param>
        <param name="bufferSize">Die <see cref="T:System.IO.FileStream" />-Puffergröße.</param>
        <summary>Initialisiert eine neue Instanz einer <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" />-Klasse, die im angegebenen <paramref name="mode" /> mit dem angegebenen Datei-<paramref name="access" /> und unter Verwendung des durch <paramref name="share" /> angegebenen Dateifreigabemodus Zugriff auf die durch <paramref name="path" /> angegebene Datei ermöglicht, wobei <paramref name="buffersize" /> angegeben wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Von der aktuell ausgeführten Assembly-Identität und der Anwendungsdomäne, in der er ausgeführt wird, bezieht sich der isolierte Speicher, der verwendet wird. Dieser Speicher wird nur für die Lebensdauer des geöffnet bleiben die <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> Objekt. An einem anderen isolierten Speicherbereichs oder erlaubt den Speicher geöffnet bleiben (also mehrere <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> Objekte daraus geöffnet werden können), verwenden Sie die Form des Konstruktors, die akzeptiert eine <xref:System.IO.IsolatedStorage.IsolatedStorageFile> Objekt.  
  
 Die `mode` Parameter gibt an, ob eine neue Datei erstellt werden soll, oder eine vorhandene verwendet. Die `access` Parameter enthält, schreibgeschützt, Lese-/Schreibzugriff, und nur-schreiben.  
  
> [!CAUTION]
>  Wenn Sie kompilieren Sie eine Gruppe von Zeichen mit einer bestimmten kulturellen Einstellung und die gleichen Zeichen mit der eine andere kultureinstellung abrufen, werden die Zeichen können nicht interpretiert werden, und können dazu führen, dass eine Ausnahme ausgelöst werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das Format von <paramref name="path" /> ist ungültig.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Es wurde keine Datei gefunden, und <paramref name="mode" /> ist auf <see cref="F:System.IO.FileMode.Open" /> festgelegt.</exception>
        <permission cref="T:System.Security.Permissions.IsolatedStorageFilePermission">für den Zugriff von isoliertem Speicher</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IsolatedStorageFileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, System.IO.IsolatedStorage.IsolatedStorageFile isf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, class System.IO.IsolatedStorage.IsolatedStorageFile isf) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.IO.IsolatedStorage.IsolatedStorageFile)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare, isf As IsolatedStorageFile)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IsolatedStorageFileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, System::IO::IsolatedStorage::IsolatedStorageFile ^ isf);" />
      <MemberSignature Language="F#" Value="new System.IO.IsolatedStorage.IsolatedStorageFileStream : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare * System.IO.IsolatedStorage.IsolatedStorageFile -&gt; System.IO.IsolatedStorage.IsolatedStorageFileStream" Usage="new System.IO.IsolatedStorage.IsolatedStorageFileStream (path, mode, access, share, isf)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="isf" Type="System.IO.IsolatedStorage.IsolatedStorageFile" />
      </Parameters>
      <Docs>
        <param name="path">Der relative Pfad der Datei innerhalb des isolierten Speichers.</param>
        <param name="mode">Einer der <see cref="T:System.IO.FileMode" />-Werte.</param>
        <param name="access">Eine bitweise Kombination der <see cref="T:System.IO.FileAccess" />-Werte.</param>
        <param name="share">Eine bitweise Kombination der <see cref="T:System.IO.FileShare" />-Werte.</param>
        <param name="isf">Die <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFile" />, in der der <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> geöffnet werden soll.</param>
        <summary>Initialisiert eine neue Instanz einer <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" />-Klasse, die im angegebenen <paramref name="mode" /> im durch <paramref name="isf" /> angegebenen Kontext des <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFile" /> des durch <paramref name="share" /> angegebenen Dateifreigabemodus den angegebenen Datei-<paramref name="access" /> auf die durch <paramref name="path" /> definierte Datei ermöglicht.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `mode` Parameter gibt an, ob eine neue Datei erstellt werden soll, oder eine vorhandene verwendet. Die `access` Parameter enthält, schreibgeschützt, Lese-/Schreibzugriff, und nur-schreiben.  
  
> [!CAUTION]
>  Wenn Sie kompilieren Sie eine Gruppe von Zeichen mit einer bestimmten kulturellen Einstellung und die gleichen Zeichen mit der eine andere kultureinstellung abrufen, werden die Zeichen können nicht interpretiert werden, und können dazu führen, dass eine Ausnahme ausgelöst werden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung dieses Konstruktors veranschaulicht. Den vollständigen Kontext dieses Beispiels, finden Sie unter den <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> Übersicht.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#11)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#11)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das Format von <paramref name="path" /> ist ungültig.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Es wurde keine Datei gefunden, und <paramref name="mode" /> ist auf <see cref="F:System.IO.FileMode.Open" /> festgelegt.</exception>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">
          <paramref name="isf" /> hat kein Kontingent.</exception>
        <permission cref="T:System.Security.Permissions.IsolatedStorageFilePermission">für den Zugriff von isoliertem Speicher</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IsolatedStorageFileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, System.IO.IsolatedStorage.IsolatedStorageFile isf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize, class System.IO.IsolatedStorage.IsolatedStorageFile isf) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.IsolatedStorage.IsolatedStorageFile)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare, bufferSize As Integer, isf As IsolatedStorageFile)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IsolatedStorageFileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, int bufferSize, System::IO::IsolatedStorage::IsolatedStorageFile ^ isf);" />
      <MemberSignature Language="F#" Value="new System.IO.IsolatedStorage.IsolatedStorageFileStream : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare * int * System.IO.IsolatedStorage.IsolatedStorageFile -&gt; System.IO.IsolatedStorage.IsolatedStorageFileStream" Usage="new System.IO.IsolatedStorage.IsolatedStorageFileStream (path, mode, access, share, bufferSize, isf)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="isf" Type="System.IO.IsolatedStorage.IsolatedStorageFile" />
      </Parameters>
      <Docs>
        <param name="path">Der relative Pfad der Datei innerhalb des isolierten Speichers.</param>
        <param name="mode">Einer der <see cref="T:System.IO.FileMode" />-Werte.</param>
        <param name="access">Eine bitweise Kombination der <see cref="T:System.IO.FileAccess" />-Werte.</param>
        <param name="share">Eine bitweise Kombination der <see cref="T:System.IO.FileShare" />-Werte.</param>
        <param name="bufferSize">Die <see cref="T:System.IO.FileStream" />-Puffergröße.</param>
        <param name="isf">Die <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFile" />, in der der <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> geöffnet werden soll.</param>
        <summary>Initialisiert eine neue Instanz einer <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" />-Klasse, die im angegebenen <paramref name="mode" /> mit dem angegebenen Datei-<paramref name="access" /> und unter Verwendung des durch <paramref name="share" /> angegebenen Dateifreigabemodus Zugriff auf die durch <paramref name="path" /> angegebene Datei ermöglicht, wobei <paramref name="buffersize" /> angegeben wird. Dies erfolgt im Kontext von <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFile" />, angegeben durch <paramref name="isf" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `mode` Parameter gibt an, ob eine neue Datei erstellt werden soll, oder eine vorhandene verwendet. Die `access` Parameter enthält, schreibgeschützt, Lese-/Schreibzugriff, und nur-schreiben.  
  
> [!CAUTION]
>  Wenn Sie kompilieren Sie eine Gruppe von Zeichen mit einer bestimmten kulturellen Einstellung und die gleichen Zeichen mit der eine andere kultureinstellung abrufen, werden die Zeichen können nicht interpretiert werden, und können dazu führen, dass eine Ausnahme ausgelöst werden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung dieses Konstruktors veranschaulicht. Den vollständigen Kontext dieses Beispiels, finden Sie unter den <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> Übersicht.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#12)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#12)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das Format von <paramref name="path" /> ist ungültig.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Es wurde keine Datei gefunden, und <paramref name="mode" /> ist auf <see cref="F:System.IO.FileMode.Open" /> festgelegt.</exception>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">
          <paramref name="isf" /> hat kein Kontingent.</exception>
        <permission cref="T:System.Security.Permissions.IsolatedStorageFilePermission">für den Zugriff von isoliertem Speicher</permission>
      </Docs>
    </Member>
    <Member MemberName="BeginRead">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] buffer, int offset, int numBytes, AsyncCallback userCallback, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] buffer, int32 offset, int32 numBytes, class System.AsyncCallback userCallback, object stateObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginRead (buffer As Byte(), offset As Integer, numBytes As Integer, userCallback As AsyncCallback, stateObject As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginRead(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int numBytes, AsyncCallback ^ userCallback, System::Object ^ stateObject);" />
      <MemberSignature Language="F#" Value="override this.BeginRead : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="isolatedStorageFileStream.BeginRead (buffer, offset, numBytes, userCallback, stateObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="numBytes" Type="System.Int32" />
        <Parameter Name="userCallback" Type="System.AsyncCallback" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">Der Puffer, in den Daten gelesen werden sollen.</param>
        <param name="offset">Der Byteoffset in <c>buffer</c>, ab dem gelesen werden soll.</param>
        <param name="numBytes">Die maximale Anzahl der zu lesenden Bytes.</param>
        <param name="userCallback">Die Methode, die aufgerufen wird, wenn der asynchrone Lesevorgang abgeschlossen ist. Dieser Parameter ist optional.</param>
        <param name="stateObject">Der Status des asynchronen Lesevorgangs.</param>
        <summary>Beginnt einen asynchronen Lesevorgang.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />-Objekt, das den asynchronen Lesevorgang darstellt, der möglicherweise noch aussteht. Dieses <see cref="T:System.IAsyncResult" /> muss an die <see cref="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.EndRead(System.IAsyncResult)" />-Methode dieses Streams übergeben werden, um die Anzahl der gelesenen Bytes zu bestimmen. Sie können dafür den gleichen Code wie für den Aufruf von <see cref="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> verwenden oder einen Rückruf an <see cref="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> übergeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim Ausgeben der asynchronen Lese- oder Schreibvorgang nicht, wenn der e/a-Vorgang abgeschlossen ist, wird die aktuelle Position im Stream aktualisiert.  
  
 Rufen Sie <xref:System.IO.Stream.EndRead%2A> dabei <xref:System.IAsyncResult> zu ermitteln, wie viele Bytes gelesen wurden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Es wurde ein asynchroner Lesevorgang nach Erreichen des Dateiendes versucht.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginWrite">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] buffer, int offset, int numBytes, AsyncCallback userCallback, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] buffer, int32 offset, int32 numBytes, class System.AsyncCallback userCallback, object stateObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginWrite (buffer As Byte(), offset As Integer, numBytes As Integer, userCallback As AsyncCallback, stateObject As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginWrite(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int numBytes, AsyncCallback ^ userCallback, System::Object ^ stateObject);" />
      <MemberSignature Language="F#" Value="override this.BeginWrite : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="isolatedStorageFileStream.BeginWrite (buffer, offset, numBytes, userCallback, stateObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="numBytes" Type="System.Int32" />
        <Parameter Name="userCallback" Type="System.AsyncCallback" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">Der Puffer, in den Daten geschrieben werden sollen.</param>
        <param name="offset">Der Byteoffset in <c>buffer</c>, ab dem geschrieben werden soll.</param>
        <param name="numBytes">Die maximale Anzahl der zu schreibenden Bytes.</param>
        <param name="userCallback">Die Methode, die aufgerufen wird, wenn der asynchrone Schreibvorgang abgeschlossen ist. Dieser Parameter ist optional.</param>
        <param name="stateObject">Der Status des asynchronen Schreibvorgangs.</param>
        <summary>Beginnt einen asynchronen Schreibvorgang.</summary>
        <returns>Eine <see cref="T:System.IAsyncResult" />-Schnittstelle, die den asynchronen Schreibvorgang darstellt, der möglicherweise noch aussteht. Dieses <see cref="T:System.IAsyncResult" /> muss an die <see cref="M:System.IO.Stream.EndWrite(System.IAsyncResult)" />-Methode des Streams übergeben werden, um sicherzustellen, dass der Schreibvorgang abgeschlossen ist und die Ressourcen entsprechend freigegeben werden. Sie können dafür den gleichen Code wie für den Aufruf von <see cref="M:System.IO.Stream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> verwenden oder einen Rückruf an <see cref="M:System.IO.Stream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> übergeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn eine <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> -Objekt schreibbar ist, den Schreibvorgang am Ende des Streams erweitert den Stream.  
  
 Beim Ausgeben der asynchronen Lese- oder Schreibvorgang nicht, wenn der e/a-Vorgang abgeschlossen ist, wird die aktuelle Position im Stream aktualisiert.  
  
 Rufen Sie <xref:System.IO.Stream.EndWrite%2A> mit der <xref:System.IAsyncResult> -Objekt, das diese Methode zurückgegeben wird, um herauszufinden, wie viele Bytes geschrieben wurden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Es wurde ein asynchroner Schreibvorgang nach Erreichen des Dateiendes versucht.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.IO.IsolatedStorage.IsolatedStorageFileStream.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanRead { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRead : bool" Usage="System.IO.IsolatedStorage.IsolatedStorageFileStream.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen booleschen Wert ab, der angibt, ob die Datei gelesen werden kann.</summary>
        <value>
          <see langword="true" />, wenn ein <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" />-Objekt gelesen werden kann, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Eigenschaft, um zu bestimmen, ob die <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> Objekt gelesen werden kann.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie Sie verwenden können die <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.CanRead%2A> Eigenschaft eine Überprüfung, um festzustellen, ob ein Stream kann, vor dem Aufruf gelesen werden der <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Read%2A> oder <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginRead%2A> Methoden. Den vollständigen Kontext dieses Beispiels, finden Sie unter den <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> Übersicht.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#11)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#11)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.IO.IsolatedStorage.IsolatedStorageFileStream.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanSeek { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanSeek : bool" Usage="System.IO.IsolatedStorage.IsolatedStorageFileStream.CanSeek" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen booleschen Wert ab, der angibt, ob Suchvorgänge unterstützt werden.</summary>
        <value>
          <see langword="true" />, wenn ein <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" />-Objekt Suchvorgänge unterstützt, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Eigenschaft, um zu bestimmen, ob die <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> -Objekt Suchvorgänge unterstützt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.IO.IsolatedStorage.IsolatedStorageFileStream.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWrite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWrite : bool" Usage="System.IO.IsolatedStorage.IsolatedStorageFileStream.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen booleschen Wert ab, der angibt, ob in die Datei geschrieben werden kann.</summary>
        <value>
          <see langword="true" />, wenn ein <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" />-Objekt geschrieben werden kann, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Eigenschaft, um zu bestimmen, ob die <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> -Objekt geschrieben werden können.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie Sie verwenden können die <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.CanWrite%2A> Eigenschaft eine Überprüfung, um festzustellen, ob ein Stream kann, vor dem Aufruf gelesen werden der <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Write%2A> oder <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginWrite%2A> Methoden. Den vollständigen Kontext dieses Beispiels, finden Sie unter den <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> Übersicht.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#13)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#13)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public override void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Close();" />
      <MemberSignature Language="F#" Value="override this.Close : unit -&gt; unit" Usage="isolatedStorageFileStream.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="isolatedStorageFileStream.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben. <see langword="false" />, wenn ausschließlich nicht verwaltete Ressourcen freigegeben werden sollen.</param>
        <summary>Gibt die von <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> verwendeten nicht verwalteten Ressourcen und optional die verwalteten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird aufgerufen, von der öffentlichen <xref:System.IDisposable.Dispose%2A> Methode und die <xref:System.Object.Finalize%2A> Methode. <xref:System.IDisposable.Dispose%2A> Ruft die geschützte <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Dispose%2A> -Methode mit dem `disposing` Parameter auf "true" festgelegt ist. <xref:System.Object.Finalize%2A> Ruft <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Dispose%2A> mit `disposing` auf "false" festgelegt.  
  
 Wenn die `disposing` Parameter true ist, gibt diese Methode alle Ressourcen frei, die für verwaltete Objekte, die dieses <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> Verweise. Diese Methode ruft die <xref:System.IDisposable.Dispose%2A>-Methode aller Objekte auf, auf die verwiesen wird.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.IDisposable.Dispose" /> kann von anderen Objekten mehrmals aufgerufen werden. Beim Überschreiben von <see cref="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Dispose(System.Boolean)" /> müssen Sie darauf achten, nicht auf Objekte zu verweisen, die durch einen früheren Aufruf von <see cref="M:System.IDisposable.Dispose" /> freigegeben wurden. Weitere Informationen zur Implementierung <see cref="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Dispose(System.Boolean)" />, finden Sie unter [Implementieren einer Dispose-Method](~/docs/standard/garbage-collection/implementing-dispose.md).  Weitere Informationen zu <see cref="M:System.IDisposable.Dispose" /> und <see cref="M:System.Object.Finalize" />, finden Sie unter [einrichten nicht verwalteten Resources](~/docs/standard/garbage-collection/unmanaged.md) bereinigen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EndRead">
      <MemberSignature Language="C#" Value="public override int EndRead (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 EndRead(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.EndRead(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndRead (asyncResult As IAsyncResult) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int EndRead(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndRead : IAsyncResult -&gt; int" Usage="isolatedStorageFileStream.EndRead asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Die ausstehende asynchrone Anforderung.</param>
        <summary>Beendet eine ausstehende asynchrone Leseanforderung.</summary>
        <returns>Die Anzahl der aus dem Stream gelesenen Bytes. Diese Anzahl kann zwischen 0 (null) und der Anzahl der angeforderten Bytes liegen. Streams geben nur am Ende des Streams 0 (null) zurück. Andernfalls blockieren diese, bis mindestens ein Byte verfügbar ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.EndRead%2A> muss genau einmal aufgerufen werden, für jede <xref:System.IAsyncResult> -Sitzungsobjekts <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginRead%2A>, und das Aufrufen <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.EndRead%2A> ist die einzige Möglichkeit zu wissen, wie viele Bytes gelesen wurden die <xref:System.IO.Stream>. <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.EndRead%2A> blockiert, bis der e/a-Vorgang abgeschlossen ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndWrite">
      <MemberSignature Language="C#" Value="public override void EndWrite (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EndWrite(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.EndWrite(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub EndWrite (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void EndWrite(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndWrite : IAsyncResult -&gt; unit" Usage="isolatedStorageFileStream.EndWrite asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Die ausstehende, zu beendende asynchrone E/A-Anforderung.</param>
        <summary>Beendet einen asynchronen Schreibvorgang.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.EndWrite%2A> muss genau einmal aufgerufen werden, für jede <xref:System.IAsyncResult> aus <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginWrite%2A>.  
  
 <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.EndWrite%2A> blockiert, bis der e/a-Vorgang abgeschlossen ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="asyncResult" />-Parameter ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Flush">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Löscht die Puffer für diesen Datenstrom und veranlasst die Ausgabe aller gepufferten Daten in die Datei.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush();" />
      <MemberSignature Language="F#" Value="override this.Flush : unit -&gt; unit" Usage="isolatedStorageFileStream.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Löscht die Puffer für diesen Datenstrom und veranlasst die Ausgabe aller gepufferten Daten in die Datei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Da ein Puffer verwendet werden kann, entweder lesen oder schreiben, aber nicht beides gleichzeitig <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Flush%2A> erfüllt zwei Funktionen. Klicken Sie zuerst alle zuvor in den Puffer geschriebenen Daten in die Datei kopiert werden, und der Puffer wird gelöscht. Zweitens If <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.CanSeek%2A> ist `true` Daten wurde zuvor in den Puffer zum Lesen aus der Datei kopiert, und die aktuelle Position in der Datei wird durch die Anzahl der gelesenen Bytes im Puffer verringert. Der Puffer wird dann gelöscht.  
  
 Verwenden der <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Flush%28System.Boolean%29> -methodenüberladung, wenn Sie möchten sicherstellen, dass alle Zwischendateipuffer Daten gepuffert wird geschrieben. auf dem Datenträger.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Flush(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush (bool flushToDisk);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush(bool flushToDisk) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Flush(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush (flushToDisk As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush(bool flushToDisk);" />
      <MemberSignature Language="F#" Value="override this.Flush : bool -&gt; unit" Usage="isolatedStorageFileStream.Flush flushToDisk" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="flushToDisk" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="flushToDisk">
          <see langword="true" />, um alle Zwischendateipuffer zu leeren, andernfalls <see langword="false" />.</param>
        <summary>Löscht die Puffer für diesen Datenstrom, veranlasst die Ausgabe aller gepufferten Daten in die Datei und löscht zudem alle Zwischendateipuffer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, wenn Sie möchten, um sicherzustellen, dass alle Daten im Zwischendateipuffer gepuffert geschrieben wird. auf dem Datenträger.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Flush" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public override IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.IO.IsolatedStorage.IsolatedStorageFileStream.Handle" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property IntPtr Handle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint" Usage="System.IO.IsolatedStorage.IsolatedStorageFileStream.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use SafeFileHandle - once available")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Dateihandle für die Datei ab, die vom aktuellen <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" />-Objekt gekapselt wird. Der Zugriff auf diese Eigenschaft ist für ein <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" />-Objekt nicht zulässig und löst eine <see cref="T:System.IO.IsolatedStorage.IsolatedStorageException" />-Ausnahme aus.</summary>
        <value>Das Dateihandle für die Datei, die vom aktuellen <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" />-Objekt gekapselt wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen finden Sie unter <xref:System.IO.FileStream.Handle%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, die <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Handle%2A> Eigenschaft.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#4)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#4)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">Die <see cref="P:System.IO.IsolatedStorage.IsolatedStorageFileStream.Handle" />-Eigenschaft generiert immer diese Ausnahme.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff auf nicht verwalteten Code. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="IsAsync">
      <MemberSignature Language="C#" Value="public override bool IsAsync { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAsync" />
      <MemberSignature Language="DocId" Value="P:System.IO.IsolatedStorage.IsolatedStorageFileStream.IsAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsAsync As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsAsync { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAsync : bool" Usage="System.IO.IsolatedStorage.IsolatedStorageFileStream.IsAsync" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen booleschen Wert ab, der angibt, ob das <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" />-Objekt asynchron oder synchron geöffnet wurde.</summary>
        <value>
          <see langword="true" />, wenn das <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" />-Objekt den asynchronen Zugriff unterstützt, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Asynchrone <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> Objekte können nicht erstellt werden, im Gegensatz zum <xref:System.IO.FileStream>. Allerdings die <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginWrite%2A>, <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginRead%2A>, <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.EndWrite%2A>, und <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.EndRead%2A> Methoden werden unterstützt, auf synchrone Instanzen mit Leistungseinbußen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie Sie verwenden können die <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.IsAsync%2A> Eigenschaft, um zu überprüfen, ob ein <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> ist synchron. Den vollständigen Kontext dieses Beispiels, finden Sie unter den <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> Übersicht.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#7)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#7)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.FileStream" />
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.IO.IsolatedStorage.IsolatedStorageFileStream.Length" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Length { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int64" Usage="System.IO.IsolatedStorage.IsolatedStorageFileStream.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Länge des <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" />-Objekts ab.</summary>
        <value>Die Länge des <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" />-Objekts in Bytes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Length%2A> Gibt die Anzahl der Bytes, die derzeit in der Datei. Es wird durch isolierte Speicherung Kontingent nicht beeinflusst.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, die <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Length%2A> Eigenschaft.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#14)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#14)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public override void Lock (long position, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Lock(int64 position, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Lock(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Lock (position As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Lock(long position, long length);" />
      <MemberSignature Language="F#" Value="override this.Lock : int64 * int64 -&gt; unit" Usage="isolatedStorageFileStream.Lock (position, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="position">Die Anfangsposition des zu sperrenden Bereichs. Der Wert dieses Parameters muss größer oder gleich 0 (Null) sein.</param>
        <param name="length">Die Anzahl der zu sperrenden Bytes.</param>
        <summary>Verhindert, dass andere Prozesse im Stream lesen oder schreiben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Erhalten durch Sperren eines Bereichs eines Dateidatenstroms der Threads von der Sperren exklusiven Zugriff auf dieses Bereichs des Dateidatenstroms.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="position" /> oder <paramref name="length" /> ist ein negativer Wert.</exception>
        <exception cref="T:System.ObjectDisposedException">Die Datei ist geschlossen.</exception>
        <exception cref="T:System.IO.IOException">Der Prozess kann nicht auf die Datei zugreifen, da sie teilweise von einem anderen Prozess gesperrt ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.IO.IsolatedStorage.IsolatedStorageFileStream.Position" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Position { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.Position : int64 with get, set" Usage="System.IO.IsolatedStorage.IsolatedStorageFileStream.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die aktuelle Position des aktuellen <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" />-Objekts ab oder legt diese fest.</summary>
        <value>Die aktuelle Position dieses <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" />-Objekts.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn diese Eigenschaft funktioniert, wenn die <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.CanSeek%2A> Eigenschaft `true`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Position%2A> Eigenschaft, um Daten in eine Datei zu schreiben.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#14)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#14)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Position kann nicht auf eine negative Zahl festgelegt werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Read : byte[] * int * int -&gt; int" Usage="isolatedStorageFileStream.Read (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Der zu lesende Puffer.</param>
        <param name="offset">Der Offset im Puffer, ab dem geschrieben werden soll.</param>
        <param name="count">Die maximale Anzahl der zu lesenden Bytes.</param>
        <summary>Kopiert Bytes aus dem aktuellen gepufferten <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" />-Objekt in ein Array.</summary>
        <returns>Die Anzahl der insgesamt in den <paramref name="buffer" /> gelesenen Bytes. Dies kann weniger als die Anzahl der angeforderten Bytes sein, wenn diese Anzahl an Bytes derzeit nicht verfügbar ist, oder 0 (null), wenn das Streamende erreicht ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `buffer` Parameter kann eine Instanz von werden die <xref:System.Buffer> -Klasse, oder ein Array von einem der folgenden Typen: <xref:System.Byte>, <xref:System.SByte>, <xref:System.Char>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.Int64>, <xref:System.UInt16>, <xref:System.UInt32> , <xref:System.UInt64>, <xref:System.Single>, oder <xref:System.Double>. Die `offset` -Parameter gibt den Offset des Bytes im Puffer, ab dem geschrieben (Index im Puffer) werden soll und die `count` Parameter gibt die maximale Anzahl von Bytes, die aus diesem Stream gelesen werden. Der zurückgegebene Wert ist die tatsächliche Anzahl der gelesenen Bytes oder 0 (null), wenn das Ende des Streams erreicht ist. Wenn der Lesevorgang erfolgreich ist, ist die aktuelle Position im Stream um die Anzahl der gelesenen Bytes erweitert. Wenn eine Ausnahme auftritt, wird die aktuelle Position des Streams unverändert.  
  
 Die <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Read%2A> Methode behandelt das `buffer` Parameter als einen Block von Bytes, unabhängig von seinem tatsächlichen Typ. Ebenso die `offset` und `count` Parameter werden immer in Bytes angegeben. Für `buffer` Parameter als Bytearrays, das bedeutet, dass der Elementgröße in Bytes, die einen korrekten Wert für ein Elementindex multipliziert werden muss `offset` oder `count`.  
  
 Die <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Read%2A> Methode gibt 0 (null) zurück, nur dann, wenn das Ende des Streams erreicht ist. In allen anderen Fällen <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Read%2A> immer mindestens ein Byte aus dem Stream liest, vor der Rückgabe. Wenn keine Daten verfügbar sind die <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> Objekt bei einem Aufruf von <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Read%2A>, die Methode blockiert, bis mindestens ein Byte an Daten zurückgegeben werden kann.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public override int ReadByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadByte() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.ReadByte" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadByte () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadByte();" />
      <MemberSignature Language="F#" Value="override this.ReadByte : unit -&gt; int" Usage="isolatedStorageFileStream.ReadByte " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest ein einzelnes Byte aus dem <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" />-Objekt im isolierten Speicher.</summary>
        <returns>Der aus der Datei im isolierten Speicher gelesene Wert in Form einer 8-Bit-Ganzzahl ohne Vorzeichen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.ReadByte%2A> Methode kann verwendet werden, zum Lesen von Daten aus einer <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> Objekt. Den vollständigen Kontext dieses Beispiels, finden Sie unter den <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> Übersicht.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#14)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#14)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SafeFileHandle">
      <MemberSignature Language="C#" Value="public override Microsoft.Win32.SafeHandles.SafeFileHandle SafeFileHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeFileHandle SafeFileHandle" />
      <MemberSignature Language="DocId" Value="P:System.IO.IsolatedStorage.IsolatedStorageFileStream.SafeFileHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property SafeFileHandle As SafeFileHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Microsoft::Win32::SafeHandles::SafeFileHandle ^ SafeFileHandle { Microsoft::Win32::SafeHandles::SafeFileHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SafeFileHandle : Microsoft.Win32.SafeHandles.SafeFileHandle" Usage="System.IO.IsolatedStorage.IsolatedStorageFileStream.SafeFileHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeFileHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein <see cref="T:Microsoft.Win32.SafeHandles.SafeFileHandle" />-Objekt ab, das das Dateihandle des Betriebssystems für die Datei darstellt, die vom aktuellen <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" />-Objekt gekapselt wird.</summary>
        <value>Ein <see cref="T:Microsoft.Win32.SafeHandles.SafeFileHandle" />-Objekt, das das Dateihandle des Betriebssystems für die Datei darstellt, die das aktuelle <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" />-Objekt kapselt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.SafeFileHandle%2A> Eigenschaft wird nicht unterstützt und generiert immer eine <xref:System.IO.IsolatedStorage.IsolatedStorageException> Ausnahme.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">Die <see cref="P:System.IO.IsolatedStorage.IsolatedStorageFileStream.SafeFileHandle" />-Eigenschaft generiert immer diese Ausnahme.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff auf nicht verwalteten Code. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Seek (offset As Long, origin As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long Seek(long offset, System::IO::SeekOrigin origin);" />
      <MemberSignature Language="F#" Value="override this.Seek : int64 * System.IO.SeekOrigin -&gt; int64" Usage="isolatedStorageFileStream.Seek (offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">Die neue Position des <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" />-Objekts.</param>
        <param name="origin">Einer der <see cref="T:System.IO.SeekOrigin" />-Werte.</param>
        <summary>Legt die aktuelle Position dieses <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" />-Objekts auf den angegebenen Wert fest.</summary>
        <returns>Die neue Position im <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" />-Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Einige <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> Objekte zu unterstützen, über die Länge des Streams hinaus zu positionieren, während andere in diesem Fall eine Ausnahme auslösen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der <paramref name="origin" /> muss einer der <see cref="T:System.IO.SeekOrigin" />-Werte sein.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void SetLength(long value);" />
      <MemberSignature Language="F#" Value="override this.SetLength : int64 -&gt; unit" Usage="isolatedStorageFileStream.SetLength value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Die neue Länge des <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" />-Objekts.</param>
        <summary>Legt die Länge dieses <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" />-Objekts auf den angegebenen <paramref name="value" /> fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn das angegebene `value` ist kleiner als die aktuelle Länge der <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> Objekt ist, wird der Datenstrom ist abgeschnitten. Wenn das angegebene `value` ist größer als die aktuelle Länge des Datenstroms der, der Stream erweitert wird. Wenn der Stream erweitert wird, sind die Inhalte des Streams, der zwischen den alten und die neue Länge nicht definiert. Um diese Methode verwenden, ein <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> Objekt muss Schreib- und Suchvorgänge unterstützen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="value" /> ist eine negative Zahl.</exception>
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public override void Unlock (long position, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Unlock(int64 position, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Unlock(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Unlock (position As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Unlock(long position, long length);" />
      <MemberSignature Language="F#" Value="override this.Unlock : int64 * int64 -&gt; unit" Usage="isolatedStorageFileStream.Unlock (position, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="position">Die Anfangsposition des zu entsperrenden Bereichs. Der Wert dieses Parameters muss größer oder gleich 0 (Null) sein.</param>
        <param name="length">Die Anzahl der zu entsperrenden Bytes.</param>
        <summary>Ermöglicht anderen Prozessen den Zugriff auf die gesamte Datei oder einen Teil der Datei, die zuvor gesperrt war.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="position" /> oder <paramref name="length" /> ist ein negativer Wert.</exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (buffer As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Write : byte[] * int * int -&gt; unit" Usage="isolatedStorageFileStream.Write (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Der zu schreibende Puffer.</param>
        <param name="offset">Der Byteoffset im Puffer, ab dem begonnen wird.</param>
        <param name="count">Die maximale Anzahl der zu schreibenden Bytes.</param>
        <summary>Schreibt einen Block von Bytes mit den aus einem Bytearray gelesenen Daten in das <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" />-Objekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `offset` -Parameter gibt den Offset des Bytes in den `buffer` gelesen werden soll, und die `count` -Parameter gibt die Anzahl der Bytes, die in diese geschrieben werden <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> Objekt. Wenn der Schreibvorgang erfolgreich ist, die aktuelle position der <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> Objekt durch die Anzahl der geschriebenen Bytes erweitert wird. Wenn eine Ausnahme auftritt, die aktuelle Position der <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> Objekt bleibt unverändert.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">Der versuchte Schreibvorgang überschreitet das Kontingent für das <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" />-Objekt.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public override void WriteByte (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteByte(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.WriteByte(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteByte (value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteByte(System::Byte value);" />
      <MemberSignature Language="F#" Value="override this.WriteByte : byte -&gt; unit" Usage="isolatedStorageFileStream.WriteByte value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">Der in die Datei im isolierten Speicher zu schreibende Bytewert.</param>
        <summary>Schreibt ein einzelnes Byte in das <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" />-Objekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.WriteByte%2A> Methode kann verwendet werden, zum Lesen von Daten aus einer <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> Objekt. Den vollständigen Kontext dieses Beispiels, finden Sie unter den <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> Übersicht.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#14)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#14)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">Der versuchte Schreibvorgang überschreitet das Kontingent für das <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" />-Objekt.</exception>
      </Docs>
    </Member>
  </Members>
</Type>