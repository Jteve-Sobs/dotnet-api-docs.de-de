<Type Name="AsnDecoder" FullName="System.Formats.Asn1.AsnDecoder">
  <Metadata><Meta Name="ms.openlocfilehash" Value="92bfd0f34fc05db3c55c18117f96dc0d07057b4a" /><Meta Name="ms.sourcegitcommit" Value="2f78d0752398ee2d15afbf06143cb62a01dc6d71" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="08/14/2020" /><Meta Name="ms.locfileid" Value="88242661" /></Metadata><TypeSignature Language="C#" Value="public static class AsnDecoder" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit AsnDecoder extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Formats.Asn1.AsnDecoder" />
  <TypeSignature Language="VB.NET" Value="Public Class AsnDecoder" />
  <TypeSignature Language="C++ CLI" Value="public ref class AsnDecoder abstract sealed" />
  <TypeSignature Language="F#" Value="type AsnDecoder = class" />
  <AssemblyInfo>
    <AssemblyName>System.Formats.Asn1</AssemblyName>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Stellt zustandslose Methoden zum Decodieren von BER-, CER- oder DER-codierten ASN.1-Daten bereit.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="ReadBitString">
      <MemberSignature Language="C#" Value="public static byte[]? ReadBitString (ReadOnlySpan&lt;byte&gt; source, System.Formats.Asn1.AsnEncodingRules ruleSet, out int unusedBitCount, out int bytesConsumed, System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] ReadBitString(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, valuetype System.Formats.Asn1.AsnEncodingRules ruleSet, [out] int32&amp; unusedBitCount, [out] int32&amp; bytesConsumed, valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnDecoder.ReadBitString(System.ReadOnlySpan{System.Byte},System.Formats.Asn1.AsnEncodingRules,System.Int32@,System.Int32@,System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadBitString (source As ReadOnlySpan(Of Byte), ruleSet As AsnEncodingRules, ByRef unusedBitCount As Integer, ByRef bytesConsumed As Integer, Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As Byte()" />
      <MemberSignature Language="F#" Value="static member ReadBitString : ReadOnlySpan&lt;byte&gt; * System.Formats.Asn1.AsnEncodingRules * int * int * Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; byte[]" Usage="System.Formats.Asn1.AsnDecoder.ReadBitString (source, ruleSet, unusedBitCount, bytesConsumed, expectedTag)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="ruleSet" Type="System.Formats.Asn1.AsnEncodingRules" />
        <Parameter Name="unusedBitCount" Type="System.Int32" RefType="out" />
        <Parameter Name="bytesConsumed" Type="System.Int32" RefType="out" />
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="source">Der Puffer, der codierte Daten enthält.</param>
        <param name="ruleSet">Die Codierungseinschränkungen, die beim Interpretieren der Daten verwendet werden sollen.</param>
        <param name="unusedBitCount">Bei Erfolg wird die Anzahl der Bits im letzten Byte empfangen, die vom Writer als „nicht verwendet“ gemeldet wurden.
Dieser Parameter wird nicht initialisiert behandelt.</param>
        <param name="bytesConsumed">Die Rückgabe dieser Methode ist die Gesamtzahl der Bytes für den codierten Wert.
Dieser Parameter wird nicht initialisiert behandelt.</param>
        <param name="expectedTag">Das Tag, das vor dem Lesen überprüft werden soll, oder <see langword="null" /> für das Standardtag (Universell 3).</param>
        <summary>Liest einen Bitzeichenfolgenwert aus <paramref name="source" /> mit einem angegebenen Tag gemäß den angegebenen Codierungsregeln und gibt den Inhalt in einem neuen Array zurück.</summary>
        <returns>Ein Array, das den Inhalt des Bitzeichenfolgenwerts enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Die am wenigsten signifikanten Bits im letzten Byte, die vom Wert als "nicht verwendet" gemeldet werden `unusedBitCount` , werden als nicht festgelegte Bits in den Rückgabewert kopiert, unabhängig von deren Wert in der codierten Darstellung.

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="ruleSet" /> ist nicht definiert.</exception>
        <exception cref="T:System.Formats.Asn1.AsnContentException">Der nächste Wert weist nicht das richtige Tag auf.
Oder die Längencodierung ist gemäß den aktuellen Codierungsregeln ungültig.
Oder der Inhalt ist gemäß den aktuellen Codierungsregeln ungültig.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> ist <see cref="F:System.Formats.Asn1.TagClass.Universal" />, aber <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> ist für die Methode nicht richtig.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadBoolean">
      <MemberSignature Language="C#" Value="public static bool ReadBoolean (ReadOnlySpan&lt;byte&gt; source, System.Formats.Asn1.AsnEncodingRules ruleSet, out int bytesConsumed, System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ReadBoolean(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, valuetype System.Formats.Asn1.AsnEncodingRules ruleSet, [out] int32&amp; bytesConsumed, valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnDecoder.ReadBoolean(System.ReadOnlySpan{System.Byte},System.Formats.Asn1.AsnEncodingRules,System.Int32@,System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadBoolean (source As ReadOnlySpan(Of Byte), ruleSet As AsnEncodingRules, ByRef bytesConsumed As Integer, Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As Boolean" />
      <MemberSignature Language="F#" Value="static member ReadBoolean : ReadOnlySpan&lt;byte&gt; * System.Formats.Asn1.AsnEncodingRules * int * Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; bool" Usage="System.Formats.Asn1.AsnDecoder.ReadBoolean (source, ruleSet, bytesConsumed, expectedTag)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="ruleSet" Type="System.Formats.Asn1.AsnEncodingRules" />
        <Parameter Name="bytesConsumed" Type="System.Int32" RefType="out" />
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="source">Der Puffer, der codierte Daten enthält.</param>
        <param name="ruleSet">Die Codierungseinschränkungen, die beim Interpretieren der Daten verwendet werden sollen.</param>
        <param name="bytesConsumed">Die Rückgabe dieser Methode ist die Gesamtzahl der Bytes für den codierten Wert.
Dieser Parameter wird nicht initialisiert behandelt.</param>
        <param name="expectedTag">Das Tag, das vor dem Lesen überprüft werden soll, oder <see langword="null" /> für das Standardtag (Universell 1).</param>
        <summary>Liest einen booleschen Wert aus <paramref name="source" /> mit einem angegebenen Tag gemäß den angegebenen Codierungsregeln.</summary>
        <returns>Der decodierte Wert.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="ruleSet" /> ist nicht definiert.</exception>
        <exception cref="T:System.Formats.Asn1.AsnContentException">Der nächste Wert weist nicht das richtige Tag auf.
Oder die Längencodierung ist gemäß den aktuellen Codierungsregeln ungültig.
Oder der Inhalt ist gemäß den aktuellen Codierungsregeln ungültig.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> ist <see cref="F:System.Formats.Asn1.TagClass.Universal" />, aber <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> ist für die Methode nicht richtig.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadCharacterString">
      <MemberSignature Language="C#" Value="public static string? ReadCharacterString (ReadOnlySpan&lt;byte&gt; source, System.Formats.Asn1.AsnEncodingRules ruleSet, System.Formats.Asn1.UniversalTagNumber encodingType, out int bytesConsumed, System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ReadCharacterString(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, valuetype System.Formats.Asn1.AsnEncodingRules ruleSet, valuetype System.Formats.Asn1.UniversalTagNumber encodingType, [out] int32&amp; bytesConsumed, valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnDecoder.ReadCharacterString(System.ReadOnlySpan{System.Byte},System.Formats.Asn1.AsnEncodingRules,System.Formats.Asn1.UniversalTagNumber,System.Int32@,System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadCharacterString (source As ReadOnlySpan(Of Byte), ruleSet As AsnEncodingRules, encodingType As UniversalTagNumber, ByRef bytesConsumed As Integer, Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As String" />
      <MemberSignature Language="F#" Value="static member ReadCharacterString : ReadOnlySpan&lt;byte&gt; * System.Formats.Asn1.AsnEncodingRules * System.Formats.Asn1.UniversalTagNumber * int * Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; string" Usage="System.Formats.Asn1.AsnDecoder.ReadCharacterString (source, ruleSet, encodingType, bytesConsumed, expectedTag)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="ruleSet" Type="System.Formats.Asn1.AsnEncodingRules" />
        <Parameter Name="encodingType" Type="System.Formats.Asn1.UniversalTagNumber" />
        <Parameter Name="bytesConsumed" Type="System.Int32" RefType="out" />
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="source">Der Puffer, der codierte Daten enthält.</param>
        <param name="ruleSet">Die Codierungseinschränkungen, die beim Interpretieren der Daten verwendet werden sollen.</param>
        <param name="encodingType">Einer der Enumerationswerte, der den zu verarbeitenden Werttyp darstellt.</param>
        <param name="bytesConsumed">Die Rückgabe dieser Methode ist die Gesamtzahl der Bytes für den codierten Wert.
Dieser Parameter wird nicht initialisiert behandelt.</param>
        <param name="expectedTag">Das Tag, das vor dem Lesen überprüft werden soll, oder <see langword="null" /> für das universelle Tag, das für den angeforderten Codierungstyp geeignet ist.</param>
        <summary>Liest den nächsten Wert als Zeichenfolge mit dem angegebenen Tag und Codierungstyp und gibt die decodierte Zeichenfolge zurück.</summary>
        <returns>Der decodierte Wert.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="ruleSet" /> ist nicht definiert.
Oder <paramref name="encodingType" /> ist kein bekannter Zeichenfolgentyp.</exception>
        <exception cref="T:System.Formats.Asn1.AsnContentException">Der nächste Wert weist nicht das richtige Tag auf.
Oder die Längencodierung ist gemäß den aktuellen Codierungsregeln ungültig.
Oder der Inhalt ist gemäß den aktuellen Codierungsregeln ungültig.
Oder die Zeichenfolge konnte nicht erfolgreich decodiert werden.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> ist <see cref="F:System.Formats.Asn1.TagClass.Universal" />, aber <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> ist nicht identisch mit <paramref name="encodingType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadEncodedValue">
      <MemberSignature Language="C#" Value="public static System.Formats.Asn1.Asn1Tag ReadEncodedValue (ReadOnlySpan&lt;byte&gt; source, System.Formats.Asn1.AsnEncodingRules ruleSet, out int contentOffset, out int contentLength, out int bytesConsumed);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Formats.Asn1.Asn1Tag ReadEncodedValue(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, valuetype System.Formats.Asn1.AsnEncodingRules ruleSet, [out] int32&amp; contentOffset, [out] int32&amp; contentLength, [out] int32&amp; bytesConsumed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnDecoder.ReadEncodedValue(System.ReadOnlySpan{System.Byte},System.Formats.Asn1.AsnEncodingRules,System.Int32@,System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadEncodedValue (source As ReadOnlySpan(Of Byte), ruleSet As AsnEncodingRules, ByRef contentOffset As Integer, ByRef contentLength As Integer, ByRef bytesConsumed As Integer) As Asn1Tag" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Formats::Asn1::Asn1Tag ReadEncodedValue(ReadOnlySpan&lt;System::Byte&gt; source, System::Formats::Asn1::AsnEncodingRules ruleSet, [Runtime::InteropServices::Out] int % contentOffset, [Runtime::InteropServices::Out] int % contentLength, [Runtime::InteropServices::Out] int % bytesConsumed);" />
      <MemberSignature Language="F#" Value="static member ReadEncodedValue : ReadOnlySpan&lt;byte&gt; * System.Formats.Asn1.AsnEncodingRules * int * int * int -&gt; System.Formats.Asn1.Asn1Tag" Usage="System.Formats.Asn1.AsnDecoder.ReadEncodedValue (source, ruleSet, contentOffset, contentLength, bytesConsumed)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Formats.Asn1.Asn1Tag</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="ruleSet" Type="System.Formats.Asn1.AsnEncodingRules" />
        <Parameter Name="contentOffset" Type="System.Int32" RefType="out" />
        <Parameter Name="contentLength" Type="System.Int32" RefType="out" />
        <Parameter Name="bytesConsumed" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="source">Der Puffer, der codierte Daten enthält.</param>
        <param name="ruleSet">Die Codierungseinschränkungen, die beim Interpretieren der Daten verwendet werden sollen.</param>
        <param name="contentOffset">Die Rückgabe dieser Methode ist der Offset der Inhaltsnutzlast relativ zum Anfang von <paramref name="source" />.
Dieser Parameter wird nicht initialisiert behandelt.</param>
        <param name="contentLength">Die Rückgabe dieser Methode ist die Anzahl der Bytes in der Inhaltsnutzlast (die 0 sein kann).
Dieser Parameter wird nicht initialisiert behandelt.</param>
        <param name="bytesConsumed">Die Rückgabe dieser Methode ist die Gesamtzahl der Bytes für den codierten Wert.
Dieser Parameter wird nicht initialisiert behandelt.</param>
        <summary>Sucht den Inhaltsbereich für den codierten Wert am Anfang des <paramref name="source" />-Puffers unter Verwendung der angegebenen Codierungsregeln.</summary>
        <returns>Das Tag, das den Inhalt identifiziert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

 Diese Methode führt sehr wenig Validierung der Inhalte aus.
Wenn der codierte Wert eine bestimmte Länge verwendet, wird der Inhalt überhaupt nicht geprüft.
Wenn der codierte Wert eine unbestimmte Länge verwendet, wird der Inhalt nur nach Bedarf überprüft, um den Speicherort der relevanten Markierung für das Ende des Inhalts zu ermitteln.
              

 Wenn der codierte Wert eine unbestimmte Länge verwendet, ist der `bytesConsumed` Wert größer als die Summe von `contentOffset` und `contentLength` , um die Markierung für das Ende des Inhalts zu berücksichtigen.
              



          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="ruleSet" /> ist nicht definiert.</exception>
        <exception cref="T:System.Formats.Asn1.AsnContentException"><paramref name="source" /> stellt keinen Wert dar, der gemäß den angegebenen Codierungsregeln codiert ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadEnumeratedBytes">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;byte&gt; ReadEnumeratedBytes (ReadOnlySpan&lt;byte&gt; source, System.Formats.Asn1.AsnEncodingRules ruleSet, out int bytesConsumed, System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; ReadEnumeratedBytes(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, valuetype System.Formats.Asn1.AsnEncodingRules ruleSet, [out] int32&amp; bytesConsumed, valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnDecoder.ReadEnumeratedBytes(System.ReadOnlySpan{System.Byte},System.Formats.Asn1.AsnEncodingRules,System.Int32@,System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadEnumeratedBytes (source As ReadOnlySpan(Of Byte), ruleSet As AsnEncodingRules, ByRef bytesConsumed As Integer, Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As ReadOnlySpan(Of Byte)" />
      <MemberSignature Language="F#" Value="static member ReadEnumeratedBytes : ReadOnlySpan&lt;byte&gt; * System.Formats.Asn1.AsnEncodingRules * int * Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; ReadOnlySpan&lt;byte&gt;" Usage="System.Formats.Asn1.AsnDecoder.ReadEnumeratedBytes (source, ruleSet, bytesConsumed, expectedTag)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Byte&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="ruleSet" Type="System.Formats.Asn1.AsnEncodingRules" />
        <Parameter Name="bytesConsumed" Type="System.Int32" RefType="out" />
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="source">Der Puffer, der codierte Daten enthält.</param>
        <param name="ruleSet">Die Codierungseinschränkungen, die beim Interpretieren der Daten verwendet werden sollen.</param>
        <param name="bytesConsumed">Die Rückgabe dieser Methode ist die Gesamtzahl der Bytes für den codierten Wert.
Dieser Parameter wird nicht initialisiert behandelt.</param>
        <param name="expectedTag">Das Tag, das vor dem Lesen überprüft werden soll, oder <see langword="null" /> für das Standardtag (Universell 10).</param>
        <summary>Liest einen Enumerationswert aus <paramref name="source" /> mit einem angegebenen Tag gemäß den angegebenen Codierungsregeln und gibt den Inhalt als Segment des Puffers zurück.</summary>
        <returns>Das Segment des Puffers, das die Bytes des Enumerationswerts enthält, im big-endian-Format mit Vorzeichen.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="ruleSet" /> ist nicht definiert.</exception>
        <exception cref="T:System.Formats.Asn1.AsnContentException">Der nächste Wert weist nicht das richtige Tag auf.
Oder die Längencodierung ist gemäß den aktuellen Codierungsregeln ungültig.
Oder der Inhalt ist gemäß den aktuellen Codierungsregeln ungültig.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> ist <see cref="F:System.Formats.Asn1.TagClass.Universal" />, aber <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> ist für die Methode nicht richtig.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadEnumeratedValue">
      <MemberSignature Language="C#" Value="public static Enum ReadEnumeratedValue (ReadOnlySpan&lt;byte&gt;? source, System.Formats.Asn1.AsnEncodingRules ruleSet, Type enumType, out int bytesConsumed, System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Enum ReadEnumeratedValue(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, valuetype System.Formats.Asn1.AsnEncodingRules ruleSet, class System.Type enumType, [out] int32&amp; bytesConsumed, valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnDecoder.ReadEnumeratedValue(System.ReadOnlySpan{System.Byte},System.Formats.Asn1.AsnEncodingRules,System.Type,System.Int32@,System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadEnumeratedValue (source As ReadOnlySpan(Of Byte), ruleSet As AsnEncodingRules, enumType As Type, ByRef bytesConsumed As Integer, Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As Enum" />
      <MemberSignature Language="F#" Value="static member ReadEnumeratedValue : ReadOnlySpan&lt;byte&gt; * System.Formats.Asn1.AsnEncodingRules * Type * int * Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; Enum" Usage="System.Formats.Asn1.AsnDecoder.ReadEnumeratedValue (source, ruleSet, enumType, bytesConsumed, expectedTag)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Enum</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="ruleSet" Type="System.Formats.Asn1.AsnEncodingRules" />
        <Parameter Name="enumType" Type="System.Type" />
        <Parameter Name="bytesConsumed" Type="System.Int32" RefType="out" />
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="source">Der Puffer, der codierte Daten enthält.</param>
        <param name="ruleSet">Die Codierungseinschränkungen, die beim Interpretieren der Daten verwendet werden sollen.</param>
        <param name="enumType">Typobjekt, das den Zieltyp darstellt.</param>
        <param name="bytesConsumed">Die Rückgabe dieser Methode ist die Gesamtzahl der Bytes für den codierten Wert.
Dieser Parameter wird nicht initialisiert behandelt.</param>
        <param name="expectedTag">Das Tag, das vor dem Lesen überprüft werden soll, oder <see langword="null" /> für das Standardtag (Universell 10).</param>
        <summary>Liest einen Enumerationswert aus <paramref name="source" /> mit einem angegebenen Tag gemäß den angegebenen Codierungsregeln und konvertiert diesen wird in die von <paramref name="enumType" /> angegebene Nicht-[<see cref="T:System.FlagsAttribute" />]-Enumeration.</summary>
        <returns>Der in einen <paramref name="enumType" /> konvertierte Enumerationswert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Diese Methode überprüft nicht, ob der Rückgabewert in definiert ist `enumType` .

          ]]></format>
        </remarks>
        <exception cref="T:System.Formats.Asn1.AsnContentException">Der nächste Wert weist nicht das richtige Tag auf.
Oder die Längencodierung ist gemäß den aktuellen Codierungsregeln ungültig.
Oder der Inhalt ist gemäß den aktuellen Codierungsregeln ungültig.
Oder der codierte Wert ist zu groß für einen <paramref name="enumType" />-Wert.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="enumType" /> ist kein Enumerationstyp.
Oder <paramref name="enumType" /> wurde mit <see cref="T:System.FlagsAttribute" /> deklariert.
Oder <paramref name="enumType" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> ist <see cref="F:System.Formats.Asn1.TagClass.Universal" />, aber <paramref name="enumType" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> ist für die Methode nicht richtig.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="enumType" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadEnumeratedValue&lt;TEnum&gt;">
      <MemberSignature Language="C#" Value="public static TEnum? ReadEnumeratedValue&lt;TEnum&gt; (ReadOnlySpan&lt;byte&gt; source, System.Formats.Asn1.AsnEncodingRules ruleSet, out int bytesConsumed, System.Formats.Asn1.Asn1Tag? expectedTag = default) where TEnum : Enum;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TEnum ReadEnumeratedValue&lt;(class System.Enum) TEnum&gt;(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, valuetype System.Formats.Asn1.AsnEncodingRules ruleSet, [out] int32&amp; bytesConsumed, valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnDecoder.ReadEnumeratedValue``1(System.ReadOnlySpan{System.Byte},System.Formats.Asn1.AsnEncodingRules,System.Int32@,System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadEnumeratedValue(Of TEnum As Enum) (source As ReadOnlySpan(Of Byte), ruleSet As AsnEncodingRules, ByRef bytesConsumed As Integer, Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As TEnum" />
      <MemberSignature Language="F#" Value="static member ReadEnumeratedValue : ReadOnlySpan&lt;byte&gt; * System.Formats.Asn1.AsnEncodingRules * int * Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; 'Enum (requires 'Enum :&gt; Enum)" Usage="System.Formats.Asn1.AsnDecoder.ReadEnumeratedValue (source, ruleSet, bytesConsumed, expectedTag)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TEnum</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEnum">
          <Constraints>
            <BaseTypeName>System.Enum</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="ruleSet" Type="System.Formats.Asn1.AsnEncodingRules" />
        <Parameter Name="bytesConsumed" Type="System.Int32" RefType="out" />
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TEnum">Ziel-Aufzählungs Typen</typeparam>
        <param name="source">Der Puffer, der codierte Daten enthält.</param>
        <param name="ruleSet">Die Codierungseinschränkungen, die beim Interpretieren der Daten verwendet werden sollen.</param>
        <param name="bytesConsumed">Die Rückgabe dieser Methode ist die Gesamtzahl der Bytes für den codierten Wert.
Dieser Parameter wird nicht initialisiert behandelt.</param>
        <param name="expectedTag">Das Tag, das vor dem Lesen überprüft werden soll, oder <see langword="null" /> für das Standardtag (Universell 10).</param>
        <summary>Liest einen Enumerationswert aus <paramref name="source" /> mit einem angegebenen Tag gemäß den angegebenen Codierungsregeln und konvertiert diesen in die von <typeparamref name="TEnum" /> angegebene nicht-[<see cref="T:System.FlagsAttribute" />]-Enumeration.</summary>
        <returns>Der in ein <typeparamref name="TEnum" />-Element konvertierte Enumerationswert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Diese Methode überprüft nicht, ob der Rückgabewert in <typeparamref Name = "TEnum> definiert ist.

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="ruleSet" /> ist nicht definiert.</exception>
        <exception cref="T:System.Formats.Asn1.AsnContentException">Der nächste Wert weist nicht das richtige Tag auf.
Oder die Längencodierung ist gemäß den aktuellen Codierungsregeln ungültig.
Oder der Inhalt ist gemäß den aktuellen Codierungsregeln ungültig.
Oder der codierte Wert ist zu groß für einen <typeparamref name="TEnum" />-Wert.</exception>
        <exception cref="T:System.ArgumentException"><typeparamref name="TEnum" /> ist kein Enumerationstyp.
Oder <typeparamref name="TEnum" /> wurde mit <see cref="T:System.FlagsAttribute" /> deklariert.
Oder <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> ist <see cref="F:System.Formats.Asn1.TagClass.Universal" />, aber <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> ist für die Methode nicht richtig.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadGeneralizedTime">
      <MemberSignature Language="C#" Value="public static DateTimeOffset ReadGeneralizedTime (ReadOnlySpan&lt;byte&gt; source, System.Formats.Asn1.AsnEncodingRules ruleSet, out int bytesConsumed, System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTimeOffset ReadGeneralizedTime(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, valuetype System.Formats.Asn1.AsnEncodingRules ruleSet, [out] int32&amp; bytesConsumed, valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnDecoder.ReadGeneralizedTime(System.ReadOnlySpan{System.Byte},System.Formats.Asn1.AsnEncodingRules,System.Int32@,System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadGeneralizedTime (source As ReadOnlySpan(Of Byte), ruleSet As AsnEncodingRules, ByRef bytesConsumed As Integer, Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As DateTimeOffset" />
      <MemberSignature Language="F#" Value="static member ReadGeneralizedTime : ReadOnlySpan&lt;byte&gt; * System.Formats.Asn1.AsnEncodingRules * int * Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; DateTimeOffset" Usage="System.Formats.Asn1.AsnDecoder.ReadGeneralizedTime (source, ruleSet, bytesConsumed, expectedTag)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTimeOffset</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="ruleSet" Type="System.Formats.Asn1.AsnEncodingRules" />
        <Parameter Name="bytesConsumed" Type="System.Int32" RefType="out" />
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="source">Der Puffer, der codierte Daten enthält.</param>
        <param name="ruleSet">Die Codierungseinschränkungen, die beim Interpretieren der Daten verwendet werden sollen.</param>
        <param name="bytesConsumed">Die Rückgabe dieser Methode ist die Gesamtzahl der Bytes für den codierten Wert.
Dieser Parameter wird nicht initialisiert behandelt.</param>
        <param name="expectedTag">Das Tag, das vor dem Lesen überprüft werden soll, oder <see langword="null" /> für das Standardtag (Universell 24).</param>
        <summary>Liest einen GeneralizedTime-Wert aus <paramref name="source" /> mit einem angegebenen Tag gemäß den angegebenen Codierungsregeln.</summary>
        <returns>Der decodierte Wert.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="ruleSet" /> ist nicht definiert.</exception>
        <exception cref="T:System.Formats.Asn1.AsnContentException">Der nächste Wert weist nicht das richtige Tag auf.
Oder die Längencodierung ist gemäß den aktuellen Codierungsregeln ungültig.
Oder der Inhalt ist gemäß den aktuellen Codierungsregeln ungültig.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> ist <see cref="F:System.Formats.Asn1.TagClass.Universal" />, aber <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> ist für die Methode nicht richtig.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadInteger">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger ReadInteger (ReadOnlySpan&lt;byte&gt; source, System.Formats.Asn1.AsnEncodingRules ruleSet, out int bytesConsumed, System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger ReadInteger(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, valuetype System.Formats.Asn1.AsnEncodingRules ruleSet, [out] int32&amp; bytesConsumed, valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnDecoder.ReadInteger(System.ReadOnlySpan{System.Byte},System.Formats.Asn1.AsnEncodingRules,System.Int32@,System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadInteger (source As ReadOnlySpan(Of Byte), ruleSet As AsnEncodingRules, ByRef bytesConsumed As Integer, Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As BigInteger" />
      <MemberSignature Language="F#" Value="static member ReadInteger : ReadOnlySpan&lt;byte&gt; * System.Formats.Asn1.AsnEncodingRules * int * Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; System.Numerics.BigInteger" Usage="System.Formats.Asn1.AsnDecoder.ReadInteger (source, ruleSet, bytesConsumed, expectedTag)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="ruleSet" Type="System.Formats.Asn1.AsnEncodingRules" />
        <Parameter Name="bytesConsumed" Type="System.Int32" RefType="out" />
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="source">Der Puffer, der codierte Daten enthält.</param>
        <param name="ruleSet">Die Codierungseinschränkungen, die beim Interpretieren der Daten verwendet werden sollen.</param>
        <param name="bytesConsumed">Die Rückgabe dieser Methode ist die Gesamtzahl der Bytes für den codierten Wert.
Dieser Parameter wird nicht initialisiert behandelt.</param>
        <param name="expectedTag">Das Tag, das vor dem Lesen überprüft werden soll, oder <see langword="null" /> für das Standardtag (Universell 2).</param>
        <summary>Liest einen Integerwert aus <paramref name="source" /> mit einem angegebenen Tag gemäß den angegebenen Codierungsregeln.</summary>
        <returns>Der decodierte numerische Wert.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="ruleSet" /> ist nicht definiert.</exception>
        <exception cref="T:System.Formats.Asn1.AsnContentException">Der nächste Wert weist nicht das richtige Tag auf.
Oder die Längencodierung ist gemäß den aktuellen Codierungsregeln ungültig.
Oder der Inhalt ist gemäß den aktuellen Codierungsregeln ungültig.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> ist <see cref="F:System.Formats.Asn1.TagClass.Universal" />, aber <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> ist für die Methode nicht richtig.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadIntegerBytes">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;byte&gt; ReadIntegerBytes (ReadOnlySpan&lt;byte&gt; source, System.Formats.Asn1.AsnEncodingRules ruleSet, out int bytesConsumed, System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; ReadIntegerBytes(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, valuetype System.Formats.Asn1.AsnEncodingRules ruleSet, [out] int32&amp; bytesConsumed, valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnDecoder.ReadIntegerBytes(System.ReadOnlySpan{System.Byte},System.Formats.Asn1.AsnEncodingRules,System.Int32@,System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadIntegerBytes (source As ReadOnlySpan(Of Byte), ruleSet As AsnEncodingRules, ByRef bytesConsumed As Integer, Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As ReadOnlySpan(Of Byte)" />
      <MemberSignature Language="F#" Value="static member ReadIntegerBytes : ReadOnlySpan&lt;byte&gt; * System.Formats.Asn1.AsnEncodingRules * int * Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; ReadOnlySpan&lt;byte&gt;" Usage="System.Formats.Asn1.AsnDecoder.ReadIntegerBytes (source, ruleSet, bytesConsumed, expectedTag)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Byte&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="ruleSet" Type="System.Formats.Asn1.AsnEncodingRules" />
        <Parameter Name="bytesConsumed" Type="System.Int32" RefType="out" />
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="source">Der Puffer, der codierte Daten enthält.</param>
        <param name="ruleSet">Die Codierungseinschränkungen, die beim Interpretieren der Daten verwendet werden sollen.</param>
        <param name="bytesConsumed">Die Rückgabe dieser Methode ist die Gesamtzahl der Bytes für den codierten Wert.
Dieser Parameter wird nicht initialisiert behandelt.</param>
        <param name="expectedTag">Das Tag, das vor dem Lesen überprüft werden soll, oder <see langword="null" /> für das Standardtag (Universell 2).</param>
        <summary>Liest einen Integerwert aus <paramref name="source" /> mit einem angegebenen Tag gemäß den angegebenen Codierungsregeln und gibt den Inhalt als Segment des Puffers zurück.</summary>
        <returns>Das Segment des Puffers, das die Bytes des Integerwerts in einem big-endian-Format mit Vorzeichen enthält.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="ruleSet" /> ist nicht definiert.</exception>
        <exception cref="T:System.Formats.Asn1.AsnContentException">Der nächste Wert weist nicht das richtige Tag auf.
Oder die Längencodierung ist gemäß den aktuellen Codierungsregeln ungültig.
Oder der Inhalt ist gemäß den aktuellen Codierungsregeln ungültig.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> ist <see cref="F:System.Formats.Asn1.TagClass.Universal" />, aber <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> ist für die Methode nicht richtig.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadNamedBitList">
      <MemberSignature Language="C#" Value="public static System.Collections.BitArray? ReadNamedBitList (ReadOnlySpan&lt;byte&gt; source, System.Formats.Asn1.AsnEncodingRules ruleSet, out int bytesConsumed, System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.BitArray ReadNamedBitList(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, valuetype System.Formats.Asn1.AsnEncodingRules ruleSet, [out] int32&amp; bytesConsumed, valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnDecoder.ReadNamedBitList(System.ReadOnlySpan{System.Byte},System.Formats.Asn1.AsnEncodingRules,System.Int32@,System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadNamedBitList (source As ReadOnlySpan(Of Byte), ruleSet As AsnEncodingRules, ByRef bytesConsumed As Integer, Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As BitArray" />
      <MemberSignature Language="F#" Value="static member ReadNamedBitList : ReadOnlySpan&lt;byte&gt; * System.Formats.Asn1.AsnEncodingRules * int * Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; System.Collections.BitArray" Usage="System.Formats.Asn1.AsnDecoder.ReadNamedBitList (source, ruleSet, bytesConsumed, expectedTag)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.BitArray</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="ruleSet" Type="System.Formats.Asn1.AsnEncodingRules" />
        <Parameter Name="bytesConsumed" Type="System.Int32" RefType="out" />
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="source">Der Puffer, der codierte Daten enthält.</param>
        <param name="ruleSet">Die Codierungseinschränkungen, die beim Interpretieren der Daten verwendet werden sollen.</param>
        <param name="bytesConsumed">Die Rückgabe dieser Methode ist die Gesamtzahl der Bytes für den codierten Wert.
Dieser Parameter wird nicht initialisiert behandelt.</param>
        <param name="expectedTag">Das Tag, das vor dem Lesen überprüft werden soll, oder <see langword="null" /> für das Standardtag (Universell 3).</param>
        <summary>Liest eine NamedBitList aus <paramref name="source" /> mit einem angegebenen Tag gemäß den angegebenen Codierungsregeln.</summary>
        <returns>Die Bits aus dem codierten Wert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Die von dieser Methode ausgeführte bitausrichtung besteht darin, das signifikanteste Bit im ersten Byte des Werts als Bit 0 zu interpretieren, wobei Bits den Wert bis zum geringsten Wert des ersten Bytes überschreitet, wobei das wichtigste Bit des zweiten Bytes usw. angezeigt wird.
Dies bedeutet, dass die in einer ASN. 1-namedbitlist-Konstruktion verwendete Zahl der Index im Rückgabewert ist.

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="ruleSet" /> ist nicht definiert.</exception>
        <exception cref="T:System.Formats.Asn1.AsnContentException">Der nächste Wert weist nicht das richtige Tag auf.
Oder die Längencodierung ist gemäß den aktuellen Codierungsregeln ungültig.
Oder der Inhalt ist gemäß den aktuellen Codierungsregeln ungültig.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> ist <see cref="F:System.Formats.Asn1.TagClass.Universal" />, aber <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> ist für die Methode nicht richtig.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadNamedBitListValue">
      <MemberSignature Language="C#" Value="public static Enum ReadNamedBitListValue (ReadOnlySpan&lt;byte&gt;? source, System.Formats.Asn1.AsnEncodingRules ruleSet, Type flagsEnumType, out int bytesConsumed, System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Enum ReadNamedBitListValue(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, valuetype System.Formats.Asn1.AsnEncodingRules ruleSet, class System.Type flagsEnumType, [out] int32&amp; bytesConsumed, valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnDecoder.ReadNamedBitListValue(System.ReadOnlySpan{System.Byte},System.Formats.Asn1.AsnEncodingRules,System.Type,System.Int32@,System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadNamedBitListValue (source As ReadOnlySpan(Of Byte), ruleSet As AsnEncodingRules, flagsEnumType As Type, ByRef bytesConsumed As Integer, Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As Enum" />
      <MemberSignature Language="F#" Value="static member ReadNamedBitListValue : ReadOnlySpan&lt;byte&gt; * System.Formats.Asn1.AsnEncodingRules * Type * int * Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; Enum" Usage="System.Formats.Asn1.AsnDecoder.ReadNamedBitListValue (source, ruleSet, flagsEnumType, bytesConsumed, expectedTag)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Enum</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="ruleSet" Type="System.Formats.Asn1.AsnEncodingRules" />
        <Parameter Name="flagsEnumType" Type="System.Type" />
        <Parameter Name="bytesConsumed" Type="System.Int32" RefType="out" />
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="source">Der Puffer, der codierte Daten enthält.</param>
        <param name="ruleSet">Die Codierungseinschränkungen, die beim Interpretieren der Daten verwendet werden sollen.</param>
        <param name="flagsEnumType">Typobjekt, das den Zieltyp darstellt.</param>
        <param name="bytesConsumed">Die Rückgabe dieser Methode ist die Gesamtzahl der Bytes für den codierten Wert.
Dieser Parameter wird nicht initialisiert behandelt.</param>
        <param name="expectedTag">Das Tag, das vor dem Lesen überprüft werden soll, oder <see langword="null" /> für das Standardtag (Universell 3).</param>
        <summary>Liest eine NamedBitList aus <paramref name="source" /> mit einem angegebenen Tag gemäß den angegebenen Codierungsregeln und konvertiert diesen in die durch <paramref name="flagsEnumType" /> angegebene [<see cref="T:System.FlagsAttribute" />]-Enumeration.</summary>
        <returns>Der in einen <paramref name="flagsEnumType" /> konvertierte NamedBitList-Wert.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="ruleSet" /> ist nicht definiert.</exception>
        <exception cref="T:System.Formats.Asn1.AsnContentException">Der nächste Wert weist nicht das richtige Tag auf.
Oder die Längencodierung ist gemäß den aktuellen Codierungsregeln ungültig.
Oder der Inhalt ist gemäß den aktuellen Codierungsregeln ungültig.
Oder der codierte Wert ist zu groß für einen <paramref name="flagsEnumType" />-Wert.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="flagsEnumType" /> ist kein Enumerationstyp.
Oder <paramref name="flagsEnumType" /> wurde nicht mit <see cref="T:System.FlagsAttribute" />deklariert oder <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> ist <see cref="F:System.Formats.Asn1.TagClass.Universal" />, aber <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> ist für die Methode nicht richtig.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="flagsEnumType" /> ist gleich <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadNamedBitListValue&lt;TFlagsEnum&gt;">
      <MemberSignature Language="C#" Value="public static TFlagsEnum? ReadNamedBitListValue&lt;TFlagsEnum&gt; (ReadOnlySpan&lt;byte&gt; source, System.Formats.Asn1.AsnEncodingRules ruleSet, out int bytesConsumed, System.Formats.Asn1.Asn1Tag? expectedTag = default) where TFlagsEnum : Enum;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TFlagsEnum ReadNamedBitListValue&lt;(class System.Enum) TFlagsEnum&gt;(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, valuetype System.Formats.Asn1.AsnEncodingRules ruleSet, [out] int32&amp; bytesConsumed, valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnDecoder.ReadNamedBitListValue``1(System.ReadOnlySpan{System.Byte},System.Formats.Asn1.AsnEncodingRules,System.Int32@,System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadNamedBitListValue(Of TFlagsEnum As Enum) (source As ReadOnlySpan(Of Byte), ruleSet As AsnEncodingRules, ByRef bytesConsumed As Integer, Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As TFlagsEnum" />
      <MemberSignature Language="F#" Value="static member ReadNamedBitListValue : ReadOnlySpan&lt;byte&gt; * System.Formats.Asn1.AsnEncodingRules * int * Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; 'FlagsEnum (requires 'FlagsEnum :&gt; Enum)" Usage="System.Formats.Asn1.AsnDecoder.ReadNamedBitListValue (source, ruleSet, bytesConsumed, expectedTag)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TFlagsEnum</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TFlagsEnum">
          <Constraints>
            <BaseTypeName>System.Enum</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="ruleSet" Type="System.Formats.Asn1.AsnEncodingRules" />
        <Parameter Name="bytesConsumed" Type="System.Int32" RefType="out" />
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TFlagsEnum">Ziel-Aufzählungs Typen</typeparam>
        <param name="source">Der Puffer, der codierte Daten enthält.</param>
        <param name="ruleSet">Die Codierungseinschränkungen, die beim Interpretieren der Daten verwendet werden sollen.</param>
        <param name="bytesConsumed">Die Rückgabe dieser Methode ist die Gesamtzahl der Bytes für den codierten Wert.
Dieser Parameter wird nicht initialisiert behandelt.</param>
        <param name="expectedTag">Das Tag, das vor dem Lesen überprüft werden soll, oder <see langword="null" /> für das Standardtag (Universell 3).</param>
        <summary>Liest eine NamedBitList aus <paramref name="source" /> mit einem angegebenen Tag gemäß den angegebenen Codierungsregeln und konvertiert diesen in die durch <typeparamref name="TFlagsEnum" /> angegebene [<see cref="T:System.FlagsAttribute" />]-Enumeration.</summary>
        <returns>Der in ein <typeparamref name="TFlagsEnum" />-Element konvertierte NamedBitList-Wert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Die von dieser Methode ausgeführte bitausrichtung besteht darin, das signifikanteste Bit im ersten Byte des Werts als das unwichtigste Bit in <typeparamref Name = "tflagsenum> zu interpretieren, wobei Bits den Wert bis zum geringsten signifikanten Bit des ersten Bytes überschreitet, mit dem signifikantesten Bit des zweiten Bytes usw. Unter diesem Schema können die folgende ASN. 1-Typdeklaration und die c#-Enumeration verwendet werden: <code> KeyUsage ::= BIT STRING { digitalSignature   (0), nonRepudiation     (1), keyEncipherment    (2), dataEncipherment   (3), keyAgreement       (4), keyCertSign        (5), cRLSign            (6), encipherOnly       (7), decipherOnly       (8) } </code><code> [Flags] enum KeyUsage { None              = 0, DigitalSignature  = 1 &lt;&lt; (0), NonRepudiation    = 1 &lt;&lt; (1), KeyEncipherment   = 1 &lt;&lt; (2), DataEncipherment  = 1 &lt;&lt; (3), KeyAgreement      = 1 &lt;&lt; (4), KeyCertSign       = 1 &lt;&lt; (5), CrlSign           = 1 &lt;&lt; (6), EncipherOnly      = 1 &lt;&lt; (7), DecipherOnly      = 1 &lt;&lt; (8), } </code> 
Beachten Sie, dass im Beispiel hier die KeyUsage-namedbitlist aus <a href="https://tools.ietf.org/html/rfc3280#section-4.2.1.3">RFC 3280 (4.2.1.3)</a>verwendet wird, die example-Enumeration jedoch Werte verwendet, die sich von System. Security. Cryptography. X509Certificates. X509KeyUsageFlags unterscheiden.

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="ruleSet" /> ist nicht definiert.</exception>
        <exception cref="T:System.Formats.Asn1.AsnContentException">Der nächste Wert weist nicht das richtige Tag auf.
Oder die Längencodierung ist gemäß den aktuellen Codierungsregeln ungültig.
Oder der Inhalt ist gemäß den aktuellen Codierungsregeln ungültig.
Oder der codierte Wert ist zu groß für einen <typeparamref name="TFlagsEnum" />-Wert.</exception>
        <exception cref="T:System.ArgumentException"><typeparamref name="TFlagsEnum" /> ist kein Enumerationstyp.
Oder <typeparamref name="TFlagsEnum" /> wurde nicht mit <see cref="T:System.FlagsAttribute" /> deklariert oder <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> ist <see cref="F:System.Formats.Asn1.TagClass.Universal" />, aber <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> ist für die Methode nicht richtig.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadNull">
      <MemberSignature Language="C#" Value="public static void ReadNull (ReadOnlySpan&lt;byte&gt; source, System.Formats.Asn1.AsnEncodingRules ruleSet, out int bytesConsumed, System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ReadNull(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, valuetype System.Formats.Asn1.AsnEncodingRules ruleSet, [out] int32&amp; bytesConsumed, valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnDecoder.ReadNull(System.ReadOnlySpan{System.Byte},System.Formats.Asn1.AsnEncodingRules,System.Int32@,System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ReadNull (source As ReadOnlySpan(Of Byte), ruleSet As AsnEncodingRules, ByRef bytesConsumed As Integer, Optional expectedTag As Nullable(Of Asn1Tag) = Nothing)" />
      <MemberSignature Language="F#" Value="static member ReadNull : ReadOnlySpan&lt;byte&gt; * System.Formats.Asn1.AsnEncodingRules * int * Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; unit" Usage="System.Formats.Asn1.AsnDecoder.ReadNull (source, ruleSet, bytesConsumed, expectedTag)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="ruleSet" Type="System.Formats.Asn1.AsnEncodingRules" />
        <Parameter Name="bytesConsumed" Type="System.Int32" RefType="out" />
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="source">Der Puffer, der codierte Daten enthält.</param>
        <param name="ruleSet">Die Codierungseinschränkungen, die beim Interpretieren der Daten verwendet werden sollen.</param>
        <param name="bytesConsumed">Die Rückgabe dieser Methode ist die Gesamtzahl der Bytes für den codierten Wert.
Dieser Parameter wird nicht initialisiert behandelt.</param>
        <param name="expectedTag">Das Tag, das vor dem Lesen überprüft werden soll, oder <see langword="null" /> für das Standardtag (Universell 5).</param>
        <summary>Liest einen <see langword="null" />-Wert aus <paramref name="source" /> mit einem angegebenen Tag gemäß den angegebenen Codierungsregeln.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="ruleSet" /> ist nicht definiert.</exception>
        <exception cref="T:System.Formats.Asn1.AsnContentException">Der nächste Wert weist nicht das richtige Tag auf.
Oder die Längencodierung ist gemäß den aktuellen Codierungsregeln ungültig.
Oder der Inhalt ist gemäß den aktuellen Codierungsregeln ungültig.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> ist <see cref="F:System.Formats.Asn1.TagClass.Universal" />, aber <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> ist für die Methode nicht richtig.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadObjectIdentifier">
      <MemberSignature Language="C#" Value="public static string? ReadObjectIdentifier (ReadOnlySpan&lt;byte&gt; source, System.Formats.Asn1.AsnEncodingRules ruleSet, out int bytesConsumed, System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ReadObjectIdentifier(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, valuetype System.Formats.Asn1.AsnEncodingRules ruleSet, [out] int32&amp; bytesConsumed, valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnDecoder.ReadObjectIdentifier(System.ReadOnlySpan{System.Byte},System.Formats.Asn1.AsnEncodingRules,System.Int32@,System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadObjectIdentifier (source As ReadOnlySpan(Of Byte), ruleSet As AsnEncodingRules, ByRef bytesConsumed As Integer, Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As String" />
      <MemberSignature Language="F#" Value="static member ReadObjectIdentifier : ReadOnlySpan&lt;byte&gt; * System.Formats.Asn1.AsnEncodingRules * int * Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; string" Usage="System.Formats.Asn1.AsnDecoder.ReadObjectIdentifier (source, ruleSet, bytesConsumed, expectedTag)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="ruleSet" Type="System.Formats.Asn1.AsnEncodingRules" />
        <Parameter Name="bytesConsumed" Type="System.Int32" RefType="out" />
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="source">Der Puffer, der codierte Daten enthält.</param>
        <param name="ruleSet">Die Codierungseinschränkungen, die beim Interpretieren der Daten verwendet werden sollen.</param>
        <param name="bytesConsumed">Die Rückgabe dieser Methode ist die Gesamtzahl der Bytes für den codierten Wert.
Dieser Parameter wird nicht initialisiert behandelt.</param>
        <param name="expectedTag">Das Tag, das vor dem Lesen überprüft werden soll, oder <see langword="null" /> für das Standardtag (Universell 6).</param>
        <summary>Liest einen Objektbezeichnerwert aus <paramref name="source" /> mit einem angegebenen Tag gemäß den angegebenen Codierungsregeln.</summary>
        <returns>Der decodierte Objektbezeichner in punktierter Dezimalschreibweise.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="ruleSet" /> ist nicht definiert.</exception>
        <exception cref="T:System.Formats.Asn1.AsnContentException">Der nächste Wert weist nicht das richtige Tag auf.
Oder die Längencodierung ist gemäß den aktuellen Codierungsregeln ungültig.
Oder der Inhalt ist gemäß den aktuellen Codierungsregeln ungültig.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> ist <see cref="F:System.Formats.Asn1.TagClass.Universal" />, aber <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> ist für die Methode nicht richtig.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadOctetString">
      <MemberSignature Language="C#" Value="public static byte[]? ReadOctetString (ReadOnlySpan&lt;byte&gt; source, System.Formats.Asn1.AsnEncodingRules ruleSet, out int bytesConsumed, System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] ReadOctetString(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, valuetype System.Formats.Asn1.AsnEncodingRules ruleSet, [out] int32&amp; bytesConsumed, valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnDecoder.ReadOctetString(System.ReadOnlySpan{System.Byte},System.Formats.Asn1.AsnEncodingRules,System.Int32@,System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadOctetString (source As ReadOnlySpan(Of Byte), ruleSet As AsnEncodingRules, ByRef bytesConsumed As Integer, Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As Byte()" />
      <MemberSignature Language="F#" Value="static member ReadOctetString : ReadOnlySpan&lt;byte&gt; * System.Formats.Asn1.AsnEncodingRules * int * Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; byte[]" Usage="System.Formats.Asn1.AsnDecoder.ReadOctetString (source, ruleSet, bytesConsumed, expectedTag)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="ruleSet" Type="System.Formats.Asn1.AsnEncodingRules" />
        <Parameter Name="bytesConsumed" Type="System.Int32" RefType="out" />
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="source">Der Puffer, der codierte Daten enthält.</param>
        <param name="ruleSet">Die Codierungseinschränkungen, die beim Interpretieren der Daten verwendet werden sollen.</param>
        <param name="bytesConsumed">Die Rückgabe dieser Methode ist die Gesamtzahl der Bytes für den codierten Wert.
Dieser Parameter wird nicht initialisiert behandelt.</param>
        <param name="expectedTag">Das Tag, das vor dem Lesen überprüft werden soll, oder <see langword="null" /> für das Standardtag (Universell 4).</param>
        <summary>Liest einen Oktett-Zeichenfolgenwert aus <paramref name="source" /> mit einem angegebenen Tag gemäß den angegebenen Codierungsregeln und gibt den Inhalt in einem neuen Array zurück.</summary>
        <returns>Ein Array, das den Inhalt des Oktett-Zeichenfolgenwerts enthält.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="ruleSet" /> ist nicht definiert.</exception>
        <exception cref="T:System.Formats.Asn1.AsnContentException">Der nächste Wert weist nicht das richtige Tag auf.
Oder die Längencodierung ist gemäß den aktuellen Codierungsregeln ungültig.
Oder der Inhalt ist gemäß den aktuellen Codierungsregeln ungültig.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> ist <see cref="F:System.Formats.Asn1.TagClass.Universal" />, aber <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> ist für die Methode nicht richtig.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadSequence">
      <MemberSignature Language="C#" Value="public static void ReadSequence (ReadOnlySpan&lt;byte&gt; source, System.Formats.Asn1.AsnEncodingRules ruleSet, out int contentOffset, out int contentLength, out int bytesConsumed, System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ReadSequence(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, valuetype System.Formats.Asn1.AsnEncodingRules ruleSet, [out] int32&amp; contentOffset, [out] int32&amp; contentLength, [out] int32&amp; bytesConsumed, valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnDecoder.ReadSequence(System.ReadOnlySpan{System.Byte},System.Formats.Asn1.AsnEncodingRules,System.Int32@,System.Int32@,System.Int32@,System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ReadSequence (source As ReadOnlySpan(Of Byte), ruleSet As AsnEncodingRules, ByRef contentOffset As Integer, ByRef contentLength As Integer, ByRef bytesConsumed As Integer, Optional expectedTag As Nullable(Of Asn1Tag) = Nothing)" />
      <MemberSignature Language="F#" Value="static member ReadSequence : ReadOnlySpan&lt;byte&gt; * System.Formats.Asn1.AsnEncodingRules * int * int * int * Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; unit" Usage="System.Formats.Asn1.AsnDecoder.ReadSequence (source, ruleSet, contentOffset, contentLength, bytesConsumed, expectedTag)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="ruleSet" Type="System.Formats.Asn1.AsnEncodingRules" />
        <Parameter Name="contentOffset" Type="System.Int32" RefType="out" />
        <Parameter Name="contentLength" Type="System.Int32" RefType="out" />
        <Parameter Name="bytesConsumed" Type="System.Int32" RefType="out" />
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="source">Der Puffer, der codierte Daten enthält.</param>
        <param name="ruleSet">Die Codierungseinschränkungen, die beim Interpretieren der Daten verwendet werden sollen.</param>
        <param name="contentOffset">Die Rückgabe dieser Methode ist der Offset der Inhaltsnutzlast relativ zum Anfang von <paramref name="source" />.
Dieser Parameter wird nicht initialisiert behandelt.</param>
        <param name="contentLength">Die Rückgabe dieser Methode ist die Anzahl der Bytes in der Inhaltsnutzlast (die 0 sein kann).
Dieser Parameter wird nicht initialisiert behandelt.</param>
        <param name="bytesConsumed">Die Rückgabe dieser Methode ist die Gesamtzahl der Bytes für den codierten Wert.
Dieser Parameter wird nicht initialisiert behandelt.</param>
        <param name="expectedTag">Das Tag, das vor dem Lesen überprüft werden soll, oder <see langword="null" /> für das Standardtag (Universell 16).</param>
        <summary>Liest einen Sequence- oder Sequence-Of-Wert aus <paramref name="source" /> mit einem angegebenen Tag gemäß den angegebenen Codierungsregeln.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Der eingefügte Inhalt wird nicht von dieser Methode ausgewertet, mit Ausnahme der minimalen Verarbeitung, um den Speicherort eines endinhalts Markers zu ermitteln.
Daher kann der Inhalt Daten enthalten, die unter den aktuellen Codierungsregeln nicht gültig sind.

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="ruleSet" /> ist nicht definiert.</exception>
        <exception cref="T:System.Formats.Asn1.AsnContentException">Der nächste Wert weist nicht das richtige Tag auf.
Oder die Längencodierung ist gemäß den aktuellen Codierungsregeln ungültig.
Oder der Inhalt ist gemäß den aktuellen Codierungsregeln ungültig.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> ist <see cref="F:System.Formats.Asn1.TagClass.Universal" />, aber <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> ist für die Methode nicht richtig.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadSetOf">
      <MemberSignature Language="C#" Value="public static void ReadSetOf (ReadOnlySpan&lt;byte&gt; source, System.Formats.Asn1.AsnEncodingRules ruleSet, out int contentOffset, out int contentLength, out int bytesConsumed, bool skipSortOrderValidation = false, System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ReadSetOf(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, valuetype System.Formats.Asn1.AsnEncodingRules ruleSet, [out] int32&amp; contentOffset, [out] int32&amp; contentLength, [out] int32&amp; bytesConsumed, bool skipSortOrderValidation, valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnDecoder.ReadSetOf(System.ReadOnlySpan{System.Byte},System.Formats.Asn1.AsnEncodingRules,System.Int32@,System.Int32@,System.Int32@,System.Boolean,System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ReadSetOf (source As ReadOnlySpan(Of Byte), ruleSet As AsnEncodingRules, ByRef contentOffset As Integer, ByRef contentLength As Integer, ByRef bytesConsumed As Integer, Optional skipSortOrderValidation As Boolean = false, Optional expectedTag As Nullable(Of Asn1Tag) = Nothing)" />
      <MemberSignature Language="F#" Value="static member ReadSetOf : ReadOnlySpan&lt;byte&gt; * System.Formats.Asn1.AsnEncodingRules * int * int * int * bool * Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; unit" Usage="System.Formats.Asn1.AsnDecoder.ReadSetOf (source, ruleSet, contentOffset, contentLength, bytesConsumed, skipSortOrderValidation, expectedTag)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="ruleSet" Type="System.Formats.Asn1.AsnEncodingRules" />
        <Parameter Name="contentOffset" Type="System.Int32" RefType="out" />
        <Parameter Name="contentLength" Type="System.Int32" RefType="out" />
        <Parameter Name="bytesConsumed" Type="System.Int32" RefType="out" />
        <Parameter Name="skipSortOrderValidation" Type="System.Boolean" />
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="source">Der Puffer, der codierte Daten enthält.</param>
        <param name="ruleSet">Die Codierungseinschränkungen, die beim Interpretieren der Daten verwendet werden sollen.</param>
        <param name="contentOffset">Die Rückgabe dieser Methode ist der Offset der Inhaltsnutzlast relativ zum Anfang von <paramref name="source" />.
Dieser Parameter wird nicht initialisiert behandelt.</param>
        <param name="contentLength">Die Rückgabe dieser Methode ist die Anzahl der Bytes in der Inhaltsnutzlast (die 0 sein kann).
Dieser Parameter wird nicht initialisiert behandelt.</param>
        <param name="bytesConsumed">Die Rückgabe dieser Methode ist die Gesamtzahl der Bytes für den codierten Wert.
Dieser Parameter wird nicht initialisiert behandelt.</param>
        <param name="skipSortOrderValidation"><see langword="true" />, um die Daten immer in der Reihenfolge zu akzeptieren, in der sie vorliegen, <see langword="false" />, um zu bestätigen, dass die Daten ordnungsgemäß sortiert sind, wenn die Codierungsregeln besagen, dass Sortierung erforderlich war (CER und DER).</param>
        <param name="expectedTag">Das Tag, das vor dem Lesen überprüft werden soll, oder <see langword="null" /> für das Standardtag (Universell 17).</param>
        <summary>Liest einen Set-Of-Wert aus <paramref name="source" /> mit einem angegebenen Tag gemäß den angegebenen Codierungsregeln.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Der Inhalt wird nicht von dieser Methode ausgewertet, mit Ausnahme der minimalen Verarbeitung, um den Speicherort eines Zeichens für das Ende des Inhalts oder die Überprüfung der Inhalts Sortierreihenfolge zu bestimmen.
Daher kann der Inhalt Daten enthalten, die unter den aktuellen Codierungsregeln nicht gültig sind.

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="ruleSet" /> ist nicht definiert.</exception>
        <exception cref="T:System.Formats.Asn1.AsnContentException">Der nächste Wert weist nicht das richtige Tag auf.
Oder die Längencodierung ist gemäß den aktuellen Codierungsregeln ungültig.
Oder der Inhalt ist gemäß den aktuellen Codierungsregeln ungültig.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> ist <see cref="F:System.Formats.Asn1.TagClass.Universal" />, aber <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> ist für die Methode nicht richtig.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadUtcTime">
      <MemberSignature Language="C#" Value="public static DateTimeOffset ReadUtcTime (ReadOnlySpan&lt;byte&gt; source, System.Formats.Asn1.AsnEncodingRules ruleSet, out int bytesConsumed, int twoDigitYearMax = 2049, System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTimeOffset ReadUtcTime(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, valuetype System.Formats.Asn1.AsnEncodingRules ruleSet, [out] int32&amp; bytesConsumed, int32 twoDigitYearMax, valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnDecoder.ReadUtcTime(System.ReadOnlySpan{System.Byte},System.Formats.Asn1.AsnEncodingRules,System.Int32@,System.Int32,System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadUtcTime (source As ReadOnlySpan(Of Byte), ruleSet As AsnEncodingRules, ByRef bytesConsumed As Integer, Optional twoDigitYearMax As Integer = 2049, Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As DateTimeOffset" />
      <MemberSignature Language="F#" Value="static member ReadUtcTime : ReadOnlySpan&lt;byte&gt; * System.Formats.Asn1.AsnEncodingRules * int * int * Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; DateTimeOffset" Usage="System.Formats.Asn1.AsnDecoder.ReadUtcTime (source, ruleSet, bytesConsumed, twoDigitYearMax, expectedTag)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTimeOffset</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="ruleSet" Type="System.Formats.Asn1.AsnEncodingRules" />
        <Parameter Name="bytesConsumed" Type="System.Int32" RefType="out" />
        <Parameter Name="twoDigitYearMax" Type="System.Int32" />
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="source">Der Puffer, der codierte Daten enthält.</param>
        <param name="ruleSet">Die Codierungseinschränkungen, die beim Interpretieren der Daten verwendet werden sollen.</param>
        <param name="bytesConsumed">Die Rückgabe dieser Methode ist die Gesamtzahl der Bytes für den codierten Wert.
Dieser Parameter wird nicht initialisiert behandelt.</param>
        <param name="twoDigitYearMax">Das größte Jahr, das mit diesem Wert dargestellt werden soll.
Der Standardwert (2049) stellt den Bereich 1950 bis 2049 für X.509-Zertifikate dar.</param>
        <param name="expectedTag">Das Tag, das vor dem Lesen überprüft werden soll, oder <see langword="null" /> für das Standardtag (Universell 24).</param>
        <summary>Liest einen UtcTime-Wert aus <paramref name="source" /> mit einem angegebenen Tag gemäß den angegebenen Codierungsregeln.</summary>
        <returns>Der decodierte Wert.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="ruleSet" /> ist nicht definiert.
Oder <paramref name="twoDigitYearMax" /> liegt nicht im Bereich [99, 9999].</exception>
        <exception cref="T:System.Formats.Asn1.AsnContentException">Der nächste Wert weist nicht das richtige Tag auf.
Oder die Längencodierung ist gemäß den aktuellen Codierungsregeln ungültig.
Oder der Inhalt ist gemäß den aktuellen Codierungsregeln ungültig.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> ist <see cref="F:System.Formats.Asn1.TagClass.Universal" />, aber <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> ist für die Methode nicht richtig.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryReadBitString">
      <MemberSignature Language="C#" Value="public static bool TryReadBitString (ReadOnlySpan&lt;byte&gt; source, Span&lt;byte&gt; destination, System.Formats.Asn1.AsnEncodingRules ruleSet, out int unusedBitCount, out int bytesConsumed, out int bytesWritten, System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReadBitString(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, valuetype System.Span`1&lt;unsigned int8&gt; destination, valuetype System.Formats.Asn1.AsnEncodingRules ruleSet, [out] int32&amp; unusedBitCount, [out] int32&amp; bytesConsumed, [out] int32&amp; bytesWritten, valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnDecoder.TryReadBitString(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Formats.Asn1.AsnEncodingRules,System.Int32@,System.Int32@,System.Int32@,System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryReadBitString (source As ReadOnlySpan(Of Byte), destination As Span(Of Byte), ruleSet As AsnEncodingRules, ByRef unusedBitCount As Integer, ByRef bytesConsumed As Integer, ByRef bytesWritten As Integer, Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As Boolean" />
      <MemberSignature Language="F#" Value="static member TryReadBitString : ReadOnlySpan&lt;byte&gt; * Span&lt;byte&gt; * System.Formats.Asn1.AsnEncodingRules * int * int * int * Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; bool" Usage="System.Formats.Asn1.AsnDecoder.TryReadBitString (source, destination, ruleSet, unusedBitCount, bytesConsumed, bytesWritten, expectedTag)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="ruleSet" Type="System.Formats.Asn1.AsnEncodingRules" />
        <Parameter Name="unusedBitCount" Type="System.Int32" RefType="out" />
        <Parameter Name="bytesConsumed" Type="System.Int32" RefType="out" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" />
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="source">Der Puffer, der codierte Daten enthält.</param>
        <param name="destination">Der Puffer, in den geschrieben werden soll.</param>
        <param name="ruleSet">Die Codierungseinschränkungen, die beim Interpretieren der Daten verwendet werden sollen.</param>
        <param name="unusedBitCount">Bei Erfolg wird die Anzahl der Bits im letzten Byte empfangen, die vom Writer als „nicht verwendet“ gemeldet wurden.
Dieser Parameter wird nicht initialisiert behandelt.</param>
        <param name="bytesConsumed">Die Rückgabe dieser Methode ist die Gesamtzahl der Bytes für den codierten Wert.
Dieser Parameter wird nicht initialisiert behandelt.</param>
        <param name="bytesWritten">Die Rückgabe dieser Methode ist die Gesamtzahl der in <paramref name="destination" /> geschriebenen Bytes.
Dieser Parameter wird nicht initialisiert behandelt.</param>
        <param name="expectedTag">Das Tag, das vor dem Lesen überprüft werden soll, oder <see langword="null" /> für das Standardtag (Universell 3).</param>
        <summary>Versucht, einen Bit-Zeichenfolgenwert aus <paramref name="source" /> mit einem angegebenen Tag gemäß den angegebenen Codierungsregeln in <paramref name="destination" /> zu kopieren.</summary>
        <returns><see langword="true" />, wenn <paramref name="destination" /> groß genug ist, um den Wert der Bitzeichenfolge zu empfangen, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Die am wenigsten signifikanten Bits im letzten Byte, die vom-Wert als "nicht verwendet" gemeldet werden `unusedBitCount` , werden `destination` als nicht festgelegte Bits kopiert, unabhängig von deren Wert in der codierten Darstellung.

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="ruleSet" /> ist nicht definiert.</exception>
        <exception cref="T:System.Formats.Asn1.AsnContentException">Der nächste Wert weist nicht das richtige Tag auf.
Oder die Längencodierung ist gemäß den aktuellen Codierungsregeln ungültig.
Oder der Inhalt ist gemäß den aktuellen Codierungsregeln ungültig.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> ist <see cref="F:System.Formats.Asn1.TagClass.Universal" />, aber <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> ist für die Methode nicht richtig.
Oder <paramref name="destination" /> überschneidet sich mit <paramref name="source" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryReadCharacterString">
      <MemberSignature Language="C#" Value="public static bool TryReadCharacterString (ReadOnlySpan&lt;byte&gt; source, Span&lt;char&gt; destination, System.Formats.Asn1.AsnEncodingRules ruleSet, System.Formats.Asn1.UniversalTagNumber encodingType, out int bytesConsumed, out int charsWritten, System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReadCharacterString(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, valuetype System.Span`1&lt;char&gt; destination, valuetype System.Formats.Asn1.AsnEncodingRules ruleSet, valuetype System.Formats.Asn1.UniversalTagNumber encodingType, [out] int32&amp; bytesConsumed, [out] int32&amp; charsWritten, valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnDecoder.TryReadCharacterString(System.ReadOnlySpan{System.Byte},System.Span{System.Char},System.Formats.Asn1.AsnEncodingRules,System.Formats.Asn1.UniversalTagNumber,System.Int32@,System.Int32@,System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryReadCharacterString (source As ReadOnlySpan(Of Byte), destination As Span(Of Char), ruleSet As AsnEncodingRules, encodingType As UniversalTagNumber, ByRef bytesConsumed As Integer, ByRef charsWritten As Integer, Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As Boolean" />
      <MemberSignature Language="F#" Value="static member TryReadCharacterString : ReadOnlySpan&lt;byte&gt; * Span&lt;char&gt; * System.Formats.Asn1.AsnEncodingRules * System.Formats.Asn1.UniversalTagNumber * int * int * Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; bool" Usage="System.Formats.Asn1.AsnDecoder.TryReadCharacterString (source, destination, ruleSet, encodingType, bytesConsumed, charsWritten, expectedTag)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="ruleSet" Type="System.Formats.Asn1.AsnEncodingRules" />
        <Parameter Name="encodingType" Type="System.Formats.Asn1.UniversalTagNumber" />
        <Parameter Name="bytesConsumed" Type="System.Int32" RefType="out" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" />
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="source">Der Puffer, der codierte Daten enthält.</param>
        <param name="destination">Der Puffer, in den geschrieben werden soll.</param>
        <param name="ruleSet">Die Codierungseinschränkungen, die beim Interpretieren der Daten verwendet werden sollen.</param>
        <param name="encodingType">Einer der Enumerationswerte, der den zu verarbeitenden Werttyp darstellt.</param>
        <param name="bytesConsumed">Die Rückgabe dieser Methode ist die Gesamtzahl der Bytes für den codierten Wert.
Dieser Parameter wird nicht initialisiert behandelt.</param>
        <param name="charsWritten">Die Rückgabe dieser Methode ist die Anzahl der in <paramref name="destination" /> geschriebenen Zeichen.
Dieser Parameter wird nicht initialisiert behandelt.</param>
        <param name="expectedTag">Das Tag, das vor dem Lesen überprüft werden soll, oder <see langword="null" /> für das universelle Tag, das für den angeforderten Codierungstyp geeignet ist.</param>
        <summary>Liest einen Zeichenfolgenwert aus <paramref name="source" /> mit einem angegebenen Tag gemäß den angegebenen Codierungsregeln und kopiert die decodierte Zeichenfolge in einen bereitgestellten Zielpuffer.</summary>
        <returns><see langword="true" /> und bewegt den Reader vorwärts, wenn <paramref name="destination" /> eine ausreichende Länge zum Empfangen des Werts hatte, andernfalls, <see langword="false" /> und der Reader wird nicht vorwärtsbewegt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="ruleSet" /> ist nicht definiert.
Oder <paramref name="encodingType" /> ist kein bekannter Zeichenfolgentyp.</exception>
        <exception cref="T:System.Formats.Asn1.AsnContentException">Der nächste Wert weist nicht das richtige Tag auf.
Oder die Längencodierung ist gemäß den aktuellen Codierungsregeln ungültig.
Oder der Inhalt ist gemäß den aktuellen Codierungsregeln ungültig.
Oder die Zeichenfolge konnte nicht erfolgreich decodiert werden.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> ist <see cref="F:System.Formats.Asn1.TagClass.Universal" />, aber <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> ist nicht identisch mit <paramref name="encodingType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryReadCharacterStringBytes">
      <MemberSignature Language="C#" Value="public static bool TryReadCharacterStringBytes (ReadOnlySpan&lt;byte&gt; source, Span&lt;byte&gt; destination, System.Formats.Asn1.AsnEncodingRules ruleSet, System.Formats.Asn1.Asn1Tag expectedTag, out int bytesConsumed, out int bytesWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReadCharacterStringBytes(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, valuetype System.Span`1&lt;unsigned int8&gt; destination, valuetype System.Formats.Asn1.AsnEncodingRules ruleSet, valuetype System.Formats.Asn1.Asn1Tag expectedTag, [out] int32&amp; bytesConsumed, [out] int32&amp; bytesWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnDecoder.TryReadCharacterStringBytes(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Formats.Asn1.AsnEncodingRules,System.Formats.Asn1.Asn1Tag,System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryReadCharacterStringBytes (source As ReadOnlySpan(Of Byte), destination As Span(Of Byte), ruleSet As AsnEncodingRules, expectedTag As Asn1Tag, ByRef bytesConsumed As Integer, ByRef bytesWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryReadCharacterStringBytes(ReadOnlySpan&lt;System::Byte&gt; source, Span&lt;System::Byte&gt; destination, System::Formats::Asn1::AsnEncodingRules ruleSet, System::Formats::Asn1::Asn1Tag expectedTag, [Runtime::InteropServices::Out] int % bytesConsumed, [Runtime::InteropServices::Out] int % bytesWritten);" />
      <MemberSignature Language="F#" Value="static member TryReadCharacterStringBytes : ReadOnlySpan&lt;byte&gt; * Span&lt;byte&gt; * System.Formats.Asn1.AsnEncodingRules * System.Formats.Asn1.Asn1Tag * int * int -&gt; bool" Usage="System.Formats.Asn1.AsnDecoder.TryReadCharacterStringBytes (source, destination, ruleSet, expectedTag, bytesConsumed, bytesWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="ruleSet" Type="System.Formats.Asn1.AsnEncodingRules" />
        <Parameter Name="expectedTag" Type="System.Formats.Asn1.Asn1Tag" />
        <Parameter Name="bytesConsumed" Type="System.Int32" RefType="out" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="source">Der Puffer, der codierte Daten enthält.</param>
        <param name="destination">Der Puffer, in den geschrieben werden soll.</param>
        <param name="ruleSet">Die Codierungseinschränkungen, die beim Interpretieren der Daten verwendet werden sollen.</param>
        <param name="expectedTag">Das Tag, das vor dem Lesen überprüft werden soll.</param>
        <param name="bytesConsumed">Die Rückgabe dieser Methode ist die Gesamtzahl der Bytes für den codierten Wert.
Dieser Parameter wird nicht initialisiert behandelt.</param>
        <param name="bytesWritten">Bei Erfolg wird die Anzahl der in <paramref name="destination" /> geschriebenen Bytes empfangen.</param>
        <summary>Versucht, einen Zeichenfolgenwert aus <paramref name="source" /> mit einem angegebenen Tag gemäß den angegebenen Codierungsregeln zu lesen, wobei die nicht verarbeiteten Bytes in den bereitgestellten Zielpuffer kopiert werden.</summary>
        <returns><see langword="true" />, wenn <paramref name="destination" /> groß genug ist, um den Wert der nicht verarbeiteten Zeichenfolge zu empfangen, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Diese Methode bestimmt nicht, ob in der Zeichenfolge nur von der Codierung definierte Zeichen verwendet wurden.

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="ruleSet" /> ist nicht definiert.</exception>
        <exception cref="T:System.Formats.Asn1.AsnContentException">Der nächste Wert weist nicht das richtige Tag auf.
Oder die Längencodierung ist gemäß den aktuellen Codierungsregeln ungültig.
Oder der Inhalt ist gemäß den aktuellen Codierungsregeln ungültig.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> ist <see cref="F:System.Formats.Asn1.TagClass.Universal" />, aber <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> ist kein Zeichenfolgen-Tagtyp.
Oder <paramref name="destination" /> überschneidet sich mit <paramref name="source" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryReadEncodedValue">
      <MemberSignature Language="C#" Value="public static bool TryReadEncodedValue (ReadOnlySpan&lt;byte&gt; source, System.Formats.Asn1.AsnEncodingRules ruleSet, out System.Formats.Asn1.Asn1Tag tag, out int contentOffset, out int contentLength, out int bytesConsumed);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReadEncodedValue(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, valuetype System.Formats.Asn1.AsnEncodingRules ruleSet, [out] valuetype System.Formats.Asn1.Asn1Tag&amp; tag, [out] int32&amp; contentOffset, [out] int32&amp; contentLength, [out] int32&amp; bytesConsumed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnDecoder.TryReadEncodedValue(System.ReadOnlySpan{System.Byte},System.Formats.Asn1.AsnEncodingRules,System.Formats.Asn1.Asn1Tag@,System.Int32@,System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryReadEncodedValue (source As ReadOnlySpan(Of Byte), ruleSet As AsnEncodingRules, ByRef tag As Asn1Tag, ByRef contentOffset As Integer, ByRef contentLength As Integer, ByRef bytesConsumed As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryReadEncodedValue(ReadOnlySpan&lt;System::Byte&gt; source, System::Formats::Asn1::AsnEncodingRules ruleSet, [Runtime::InteropServices::Out] System::Formats::Asn1::Asn1Tag % tag, [Runtime::InteropServices::Out] int % contentOffset, [Runtime::InteropServices::Out] int % contentLength, [Runtime::InteropServices::Out] int % bytesConsumed);" />
      <MemberSignature Language="F#" Value="static member TryReadEncodedValue : ReadOnlySpan&lt;byte&gt; * System.Formats.Asn1.AsnEncodingRules * Asn1Tag * int * int * int -&gt; bool" Usage="System.Formats.Asn1.AsnDecoder.TryReadEncodedValue (source, ruleSet, tag, contentOffset, contentLength, bytesConsumed)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="ruleSet" Type="System.Formats.Asn1.AsnEncodingRules" />
        <Parameter Name="tag" Type="System.Formats.Asn1.Asn1Tag" RefType="out" />
        <Parameter Name="contentOffset" Type="System.Int32" RefType="out" />
        <Parameter Name="contentLength" Type="System.Int32" RefType="out" />
        <Parameter Name="bytesConsumed" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="source">Der Puffer, der codierte Daten enthält.</param>
        <param name="ruleSet">Die Codierungseinschränkungen, die beim Interpretieren der Daten verwendet werden sollen.</param>
        <param name="tag">Die Rückgabe dieser Methode ist das Tag, das den Inhalt identifiziert.
Dieser Parameter wird nicht initialisiert behandelt.</param>
        <param name="contentOffset">Die Rückgabe dieser Methode ist der Offset der Inhaltsnutzlast relativ zum Anfang von <paramref name="source" />.
Dieser Parameter wird nicht initialisiert behandelt.</param>
        <param name="contentLength">Die Rückgabe dieser Methode ist die Anzahl der Bytes in der Inhaltsnutzlast (die 0 sein kann).
Dieser Parameter wird nicht initialisiert behandelt.</param>
        <param name="bytesConsumed">Die Rückgabe dieser Methode ist die Gesamtzahl der Bytes für den codierten Wert.
Dieser Parameter wird nicht initialisiert behandelt.</param>
        <summary>Versucht, den Inhaltsbereich für den codierten Wert am Anfang des <paramref name="source" />-Puffers mithilfe der angegebenen Codierungsregeln zu ermitteln.</summary>
        <returns><see langword="true" />, wenn <paramref name="source" /> eine gültige strukturelle Codierung für die angegebenen Codierungsregeln darstellt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

 Diese Methode führt sehr wenig Validierung der Inhalte aus.
Wenn der codierte Wert eine bestimmte Länge verwendet, wird der Inhalt überhaupt nicht geprüft.
Wenn der codierte Wert eine unbestimmte Länge verwendet, wird der Inhalt nur nach Bedarf überprüft, um den Speicherort der relevanten Markierung für das Ende des Inhalts zu ermitteln.
              

 Wenn der codierte Wert eine unbestimmte Länge verwendet, ist der `bytesConsumed` Wert größer als die Summe von `contentOffset` und `contentLength` , um die Markierung für das Ende des Inhalts zu berücksichtigen.
              



          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="ruleSet" /> ist nicht definiert.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryReadInt32">
      <MemberSignature Language="C#" Value="public static bool TryReadInt32 (ReadOnlySpan&lt;byte&gt; source, System.Formats.Asn1.AsnEncodingRules ruleSet, out int value, out int bytesConsumed, System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReadInt32(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, valuetype System.Formats.Asn1.AsnEncodingRules ruleSet, [out] int32&amp; value, [out] int32&amp; bytesConsumed, valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnDecoder.TryReadInt32(System.ReadOnlySpan{System.Byte},System.Formats.Asn1.AsnEncodingRules,System.Int32@,System.Int32@,System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryReadInt32 (source As ReadOnlySpan(Of Byte), ruleSet As AsnEncodingRules, ByRef value As Integer, ByRef bytesConsumed As Integer, Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As Boolean" />
      <MemberSignature Language="F#" Value="static member TryReadInt32 : ReadOnlySpan&lt;byte&gt; * System.Formats.Asn1.AsnEncodingRules * int * int * Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; bool" Usage="System.Formats.Asn1.AsnDecoder.TryReadInt32 (source, ruleSet, value, bytesConsumed, expectedTag)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="ruleSet" Type="System.Formats.Asn1.AsnEncodingRules" />
        <Parameter Name="value" Type="System.Int32" RefType="out" />
        <Parameter Name="bytesConsumed" Type="System.Int32" RefType="out" />
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="source">Der Puffer, der codierte Daten enthält.</param>
        <param name="ruleSet">Die Codierungseinschränkungen, die beim Interpretieren der Daten verwendet werden sollen.</param>
        <param name="value">Empfängt bei Erfolg den interpretierten numerischen Wert.
Dieser Parameter wird nicht initialisiert behandelt.</param>
        <param name="bytesConsumed">Die Rückgabe dieser Methode ist die Gesamtzahl der Bytes für den codierten Wert.
Dieser Parameter wird nicht initialisiert behandelt.</param>
        <param name="expectedTag">Das Tag, das vor dem Lesen überprüft werden soll, oder <see langword="null" /> für das Standardtag (Universell 2).</param>
        <summary>Versucht, einen Integerwert aus <paramref name="source" /> mit einem angegebenen Tag gemäß den angegebenen Codierungsregeln als 32-Bit-Wert mit Vorzeichen zu lesen.</summary>
        <returns><see langword="true" />, wenn der Integerwert zwischen <see cref="F:System.Int32.MinValue" /> und <see cref="F:System.Int32.MaxValue" /> (einschließlich) liegt, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="ruleSet" /> ist nicht definiert.</exception>
        <exception cref="T:System.Formats.Asn1.AsnContentException">Der nächste Wert weist nicht das richtige Tag auf.
Oder die Längencodierung ist gemäß den aktuellen Codierungsregeln ungültig.
Oder der Inhalt ist gemäß den aktuellen Codierungsregeln ungültig.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> ist <see cref="F:System.Formats.Asn1.TagClass.Universal" />, aber <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> ist für die Methode nicht richtig.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryReadInt64">
      <MemberSignature Language="C#" Value="public static bool TryReadInt64 (ReadOnlySpan&lt;byte&gt; source, System.Formats.Asn1.AsnEncodingRules ruleSet, out long value, out int bytesConsumed, System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReadInt64(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, valuetype System.Formats.Asn1.AsnEncodingRules ruleSet, [out] int64&amp; value, [out] int32&amp; bytesConsumed, valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnDecoder.TryReadInt64(System.ReadOnlySpan{System.Byte},System.Formats.Asn1.AsnEncodingRules,System.Int64@,System.Int32@,System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryReadInt64 (source As ReadOnlySpan(Of Byte), ruleSet As AsnEncodingRules, ByRef value As Long, ByRef bytesConsumed As Integer, Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As Boolean" />
      <MemberSignature Language="F#" Value="static member TryReadInt64 : ReadOnlySpan&lt;byte&gt; * System.Formats.Asn1.AsnEncodingRules * int64 * int * Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; bool" Usage="System.Formats.Asn1.AsnDecoder.TryReadInt64 (source, ruleSet, value, bytesConsumed, expectedTag)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="ruleSet" Type="System.Formats.Asn1.AsnEncodingRules" />
        <Parameter Name="value" Type="System.Int64" RefType="out" />
        <Parameter Name="bytesConsumed" Type="System.Int32" RefType="out" />
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="source">Der Puffer, der codierte Daten enthält.</param>
        <param name="ruleSet">Die Codierungseinschränkungen, die beim Interpretieren der Daten verwendet werden sollen.</param>
        <param name="value">Empfängt bei Erfolg den interpretierten numerischen Wert.
Dieser Parameter wird nicht initialisiert behandelt.</param>
        <param name="bytesConsumed">Die Rückgabe dieser Methode ist die Gesamtzahl der Bytes für den codierten Wert.
Dieser Parameter wird nicht initialisiert behandelt.</param>
        <param name="expectedTag">Das Tag, das vor dem Lesen überprüft werden soll, oder <see langword="null" /> für das Standardtag (Universell 2).</param>
        <summary>Versucht, einen Integerwert aus <paramref name="source" /> mit einem angegebenen Tag gemäß den angegebenen Codierungsregeln als 64-Bit-Wert mit Vorzeichen zu lesen.</summary>
        <returns><see langword="true" />, wenn der Integerwert zwischen <see cref="F:System.Int64.MinValue" /> und <see cref="F:System.Int64.MaxValue" /> (einschließlich) liegt, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="ruleSet" /> ist nicht definiert.</exception>
        <exception cref="T:System.Formats.Asn1.AsnContentException">Der nächste Wert weist nicht das richtige Tag auf.
Oder die Längencodierung ist gemäß den aktuellen Codierungsregeln ungültig.
Oder der Inhalt ist gemäß den aktuellen Codierungsregeln ungültig.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> ist <see cref="F:System.Formats.Asn1.TagClass.Universal" />, aber <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> ist für die Methode nicht richtig.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryReadOctetString">
      <MemberSignature Language="C#" Value="public static bool TryReadOctetString (ReadOnlySpan&lt;byte&gt; source, Span&lt;byte&gt; destination, System.Formats.Asn1.AsnEncodingRules ruleSet, out int bytesConsumed, out int bytesWritten, System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReadOctetString(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, valuetype System.Span`1&lt;unsigned int8&gt; destination, valuetype System.Formats.Asn1.AsnEncodingRules ruleSet, [out] int32&amp; bytesConsumed, [out] int32&amp; bytesWritten, valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnDecoder.TryReadOctetString(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Formats.Asn1.AsnEncodingRules,System.Int32@,System.Int32@,System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryReadOctetString (source As ReadOnlySpan(Of Byte), destination As Span(Of Byte), ruleSet As AsnEncodingRules, ByRef bytesConsumed As Integer, ByRef bytesWritten As Integer, Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As Boolean" />
      <MemberSignature Language="F#" Value="static member TryReadOctetString : ReadOnlySpan&lt;byte&gt; * Span&lt;byte&gt; * System.Formats.Asn1.AsnEncodingRules * int * int * Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; bool" Usage="System.Formats.Asn1.AsnDecoder.TryReadOctetString (source, destination, ruleSet, bytesConsumed, bytesWritten, expectedTag)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="ruleSet" Type="System.Formats.Asn1.AsnEncodingRules" />
        <Parameter Name="bytesConsumed" Type="System.Int32" RefType="out" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" />
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="source">Der Puffer, der codierte Daten enthält.</param>
        <param name="destination">Der Puffer, in den geschrieben werden soll.</param>
        <param name="ruleSet">Die Codierungseinschränkungen, die beim Interpretieren der Daten verwendet werden sollen.</param>
        <param name="bytesConsumed">Die Rückgabe dieser Methode ist die Gesamtzahl der Bytes für den codierten Wert.
Dieser Parameter wird nicht initialisiert behandelt.</param>
        <param name="bytesWritten">Die Rückgabe dieser Methode ist die Gesamtzahl der in <paramref name="destination" /> geschriebenen Bytes.
Dieser Parameter wird nicht initialisiert behandelt.</param>
        <param name="expectedTag">Das Tag, das vor dem Lesen überprüft werden soll, oder <see langword="null" /> für das Standardtag (Universell 4).</param>
        <summary>Versucht, einen Oktett-Zeichenfolgenwert aus <paramref name="source" /> mit einem angegebenen Tag gemäß den angegebenen Codierungsregeln zu lesen, wobei der Wert in den bereitgestellten Zielpuffer kopiert wird.</summary>
        <returns><see langword="true" />, wenn <paramref name="destination" /> groß genug ist, um den Wert der Oktettzeichenfolge zu empfangen, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="ruleSet" /> ist nicht definiert.</exception>
        <exception cref="T:System.Formats.Asn1.AsnContentException">Der nächste Wert weist nicht das richtige Tag auf.
Oder die Längencodierung ist gemäß den aktuellen Codierungsregeln ungültig.
Oder der Inhalt ist gemäß den aktuellen Codierungsregeln ungültig.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> ist <see cref="F:System.Formats.Asn1.TagClass.Universal" />, aber <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> ist für die Methode nicht richtig.
Oder <paramref name="destination" /> überschneidet sich mit <paramref name="source" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryReadPrimitiveBitString">
      <MemberSignature Language="C#" Value="public static bool TryReadPrimitiveBitString (ReadOnlySpan&lt;byte&gt; source, System.Formats.Asn1.AsnEncodingRules ruleSet, out int unusedBitCount, out ReadOnlySpan&lt;byte&gt; value, out int bytesConsumed, System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReadPrimitiveBitString(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, valuetype System.Formats.Asn1.AsnEncodingRules ruleSet, [out] int32&amp; unusedBitCount, [out] valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt;&amp; value, [out] int32&amp; bytesConsumed, valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnDecoder.TryReadPrimitiveBitString(System.ReadOnlySpan{System.Byte},System.Formats.Asn1.AsnEncodingRules,System.Int32@,System.ReadOnlySpan{System.Byte}@,System.Int32@,System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryReadPrimitiveBitString (source As ReadOnlySpan(Of Byte), ruleSet As AsnEncodingRules, ByRef unusedBitCount As Integer, ByRef value As ReadOnlySpan(Of Byte), ByRef bytesConsumed As Integer, Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As Boolean" />
      <MemberSignature Language="F#" Value="static member TryReadPrimitiveBitString : ReadOnlySpan&lt;byte&gt; * System.Formats.Asn1.AsnEncodingRules * int * ReadOnlySpan * int * Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; bool" Usage="System.Formats.Asn1.AsnDecoder.TryReadPrimitiveBitString (source, ruleSet, unusedBitCount, value, bytesConsumed, expectedTag)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="ruleSet" Type="System.Formats.Asn1.AsnEncodingRules" />
        <Parameter Name="unusedBitCount" Type="System.Int32" RefType="out" />
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Byte&gt;" RefType="out" />
        <Parameter Name="bytesConsumed" Type="System.Int32" RefType="out" />
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="source">Der Puffer, der codierte Daten enthält.</param>
        <param name="ruleSet">Die Codierungseinschränkungen, die beim Interpretieren der Daten verwendet werden sollen.</param>
        <param name="unusedBitCount">Bei Erfolg wird die Anzahl der Bits im letzten Byte empfangen, die vom Writer als „nicht verwendet“ gemeldet wurden.
Dieser Parameter wird nicht initialisiert behandelt.</param>
        <param name="value">Empfängt bei Erfolg ein Segment des Eingabepuffers, das dem Wert der Bitzeichenfolge entspricht.
Dieser Parameter wird nicht initialisiert behandelt.</param>
        <param name="bytesConsumed">Die Rückgabe dieser Methode ist die Gesamtzahl der Bytes für den codierten Wert.
Dieser Parameter wird nicht initialisiert behandelt.</param>
        <param name="expectedTag">Das Tag, das vor dem Lesen überprüft werden soll, oder <see langword="null" /> für das Standardtag (Universell 3).</param>
        <summary>Versucht, einen Bit-Zeichenfolgenwert aus <paramref name="source" /> mit einem angegebenen Tag gemäß den angegebenen Codierungsregeln abzurufen, wenn der Wert in einer einzelnen (primitiven) Codierung enthalten ist.</summary>
        <returns><see langword="true" />, wenn der Bit-Zeichenfolgenwert eine primitive Codierung aufweist und alle als nicht verwendet gemeldeten Bits auf 0 festgelegt sind, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="ruleSet" /> ist nicht definiert.</exception>
        <exception cref="T:System.Formats.Asn1.AsnContentException">Der nächste Wert weist nicht das richtige Tag auf.
Oder die Längencodierung ist gemäß den aktuellen Codierungsregeln ungültig.
Oder der Inhalt ist gemäß den aktuellen Codierungsregeln ungültig.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> ist <see cref="F:System.Formats.Asn1.TagClass.Universal" />, aber <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> ist für die Methode nicht richtig.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryReadPrimitiveCharacterStringBytes">
      <MemberSignature Language="C#" Value="public static bool TryReadPrimitiveCharacterStringBytes (ReadOnlySpan&lt;byte&gt; source, System.Formats.Asn1.AsnEncodingRules ruleSet, System.Formats.Asn1.Asn1Tag expectedTag, out ReadOnlySpan&lt;byte&gt; value, out int bytesConsumed);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReadPrimitiveCharacterStringBytes(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, valuetype System.Formats.Asn1.AsnEncodingRules ruleSet, valuetype System.Formats.Asn1.Asn1Tag expectedTag, [out] valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt;&amp; value, [out] int32&amp; bytesConsumed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnDecoder.TryReadPrimitiveCharacterStringBytes(System.ReadOnlySpan{System.Byte},System.Formats.Asn1.AsnEncodingRules,System.Formats.Asn1.Asn1Tag,System.ReadOnlySpan{System.Byte}@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryReadPrimitiveCharacterStringBytes (source As ReadOnlySpan(Of Byte), ruleSet As AsnEncodingRules, expectedTag As Asn1Tag, ByRef value As ReadOnlySpan(Of Byte), ByRef bytesConsumed As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryReadPrimitiveCharacterStringBytes(ReadOnlySpan&lt;System::Byte&gt; source, System::Formats::Asn1::AsnEncodingRules ruleSet, System::Formats::Asn1::Asn1Tag expectedTag, [Runtime::InteropServices::Out] ReadOnlySpan&lt;System::Byte&gt; % value, [Runtime::InteropServices::Out] int % bytesConsumed);" />
      <MemberSignature Language="F#" Value="static member TryReadPrimitiveCharacterStringBytes : ReadOnlySpan&lt;byte&gt; * System.Formats.Asn1.AsnEncodingRules * System.Formats.Asn1.Asn1Tag * ReadOnlySpan * int -&gt; bool" Usage="System.Formats.Asn1.AsnDecoder.TryReadPrimitiveCharacterStringBytes (source, ruleSet, expectedTag, value, bytesConsumed)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="ruleSet" Type="System.Formats.Asn1.AsnEncodingRules" />
        <Parameter Name="expectedTag" Type="System.Formats.Asn1.Asn1Tag" />
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Byte&gt;" RefType="out" />
        <Parameter Name="bytesConsumed" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="source">Der Puffer, der codierte Daten enthält.</param>
        <param name="ruleSet">Die Codierungseinschränkungen, die beim Interpretieren der Daten verwendet werden sollen.</param>
        <param name="expectedTag">Das Tag, das vor dem Lesen überprüft werden soll.</param>
        <param name="value">Empfängt bei Erfolg ein Segment des Eingabepuffers, das dem Wert der Bitzeichenfolge entspricht.
Dieser Parameter wird nicht initialisiert behandelt.</param>
        <param name="bytesConsumed">Die Rückgabe dieser Methode ist die Gesamtzahl der Bytes für den codierten Wert.
Dieser Parameter wird nicht initialisiert behandelt.</param>
        <summary>Versucht, einen nicht verarbeiteten Zeichenfolgenwert aus <paramref name="source" /> mit einem angegebenen Tag gemäß den angegebenen Codierungsregeln abzurufen, wenn der Wert in einer einzelnen (primitiven) Codierung enthalten ist.</summary>
        <returns><see langword="true" />, wenn der Zeichenfolgenwert eine primitive Codierung aufweist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Diese Methode bestimmt nicht, ob in der Zeichenfolge nur von der Codierung definierte Zeichen verwendet wurden.

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="ruleSet" /> ist nicht definiert.</exception>
        <exception cref="T:System.Formats.Asn1.AsnContentException">Der nächste Wert weist nicht das richtige Tag auf.
Oder die Längencodierung ist gemäß den aktuellen Codierungsregeln ungültig.
Oder der Inhalt ist gemäß den aktuellen Codierungsregeln ungültig.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> ist <see cref="F:System.Formats.Asn1.TagClass.Universal" />, aber <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> ist kein Zeichenfolgen-Tagtyp.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryReadPrimitiveOctetString">
      <MemberSignature Language="C#" Value="public static bool TryReadPrimitiveOctetString (ReadOnlySpan&lt;byte&gt; source, System.Formats.Asn1.AsnEncodingRules ruleSet, out ReadOnlySpan&lt;byte&gt; value, out int bytesConsumed, System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReadPrimitiveOctetString(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, valuetype System.Formats.Asn1.AsnEncodingRules ruleSet, [out] valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt;&amp; value, [out] int32&amp; bytesConsumed, valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnDecoder.TryReadPrimitiveOctetString(System.ReadOnlySpan{System.Byte},System.Formats.Asn1.AsnEncodingRules,System.ReadOnlySpan{System.Byte}@,System.Int32@,System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryReadPrimitiveOctetString (source As ReadOnlySpan(Of Byte), ruleSet As AsnEncodingRules, ByRef value As ReadOnlySpan(Of Byte), ByRef bytesConsumed As Integer, Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As Boolean" />
      <MemberSignature Language="F#" Value="static member TryReadPrimitiveOctetString : ReadOnlySpan&lt;byte&gt; * System.Formats.Asn1.AsnEncodingRules * ReadOnlySpan * int * Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; bool" Usage="System.Formats.Asn1.AsnDecoder.TryReadPrimitiveOctetString (source, ruleSet, value, bytesConsumed, expectedTag)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="ruleSet" Type="System.Formats.Asn1.AsnEncodingRules" />
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Byte&gt;" RefType="out" />
        <Parameter Name="bytesConsumed" Type="System.Int32" RefType="out" />
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="source">Der Puffer, der codierte Daten enthält.</param>
        <param name="ruleSet">Die Codierungseinschränkungen, die beim Interpretieren der Daten verwendet werden sollen.</param>
        <param name="value">Empfängt bei Erfolg ein Segment des Eingabepuffers, das dem Wert der Oktettzeichenfolge entspricht.
Dieser Parameter wird nicht initialisiert behandelt.</param>
        <param name="bytesConsumed">Die Rückgabe dieser Methode ist die Gesamtzahl der Bytes für den codierten Wert.
Dieser Parameter wird nicht initialisiert behandelt.</param>
        <param name="expectedTag">Das Tag, das vor dem Lesen überprüft werden soll, oder <see langword="null" /> für das Standardtag (Universell 4).</param>
        <summary>Versucht, einen Oktett-Zeichenfolgenwert aus <paramref name="source" /> mit einem angegebenen Tag gemäß den angegebenen Codierungsregeln abzurufen, wenn der Wert in einer einzelnen (primitiven) Codierung enthalten ist.</summary>
        <returns><see langword="true" />, wenn der Oktett-Zeichenfolgenwert eine primitive Codierung aufweist, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="ruleSet" /> ist nicht definiert.</exception>
        <exception cref="T:System.Formats.Asn1.AsnContentException">Der nächste Wert weist nicht das richtige Tag auf.
Oder die Längencodierung ist gemäß den aktuellen Codierungsregeln ungültig.
Oder der Inhalt ist gemäß den aktuellen Codierungsregeln ungültig.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> ist <see cref="F:System.Formats.Asn1.TagClass.Universal" />, aber <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> ist für die Methode nicht richtig.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryReadUInt32">
      <MemberSignature Language="C#" Value="public static bool TryReadUInt32 (ReadOnlySpan&lt;byte&gt; source, System.Formats.Asn1.AsnEncodingRules ruleSet, out uint value, out int bytesConsumed, System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReadUInt32(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, valuetype System.Formats.Asn1.AsnEncodingRules ruleSet, [out] unsigned int32&amp; value, [out] int32&amp; bytesConsumed, valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnDecoder.TryReadUInt32(System.ReadOnlySpan{System.Byte},System.Formats.Asn1.AsnEncodingRules,System.UInt32@,System.Int32@,System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryReadUInt32 (source As ReadOnlySpan(Of Byte), ruleSet As AsnEncodingRules, ByRef value As UInteger, ByRef bytesConsumed As Integer, Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As Boolean" />
      <MemberSignature Language="F#" Value="static member TryReadUInt32 : ReadOnlySpan&lt;byte&gt; * System.Formats.Asn1.AsnEncodingRules * uint32 * int * Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; bool" Usage="System.Formats.Asn1.AsnDecoder.TryReadUInt32 (source, ruleSet, value, bytesConsumed, expectedTag)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="ruleSet" Type="System.Formats.Asn1.AsnEncodingRules" />
        <Parameter Name="value" Type="System.UInt32" RefType="out" />
        <Parameter Name="bytesConsumed" Type="System.Int32" RefType="out" />
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="source">Der Puffer, der codierte Daten enthält.</param>
        <param name="ruleSet">Die Codierungseinschränkungen, die beim Interpretieren der Daten verwendet werden sollen.</param>
        <param name="value">Empfängt bei Erfolg den interpretierten numerischen Wert.
Dieser Parameter wird nicht initialisiert behandelt.</param>
        <param name="bytesConsumed">Die Rückgabe dieser Methode ist die Gesamtzahl der Bytes für den codierten Wert.
Dieser Parameter wird nicht initialisiert behandelt.</param>
        <param name="expectedTag">Das Tag, das vor dem Lesen überprüft werden soll, oder <see langword="null" /> für das Standardtag (Universell 2).</param>
        <summary>Versucht, einen Integerwert aus <paramref name="source" /> mit einem angegebenen Tag gemäß den angegebenen Codierungsregeln als 32-Bit-Wert ohne Vorzeichen zu lesen.</summary>
        <returns><see langword="true" />, wenn der Integerwert zwischen <see cref="F:System.UInt32.MinValue" /> und <see cref="F:System.UInt32.MaxValue" /> (einschließlich) liegt, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="ruleSet" /> ist nicht definiert.</exception>
        <exception cref="T:System.Formats.Asn1.AsnContentException">Der nächste Wert weist nicht das richtige Tag auf.
Oder die Längencodierung ist gemäß den aktuellen Codierungsregeln ungültig.
Oder der Inhalt ist gemäß den aktuellen Codierungsregeln ungültig.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> ist <see cref="F:System.Formats.Asn1.TagClass.Universal" />, aber <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> ist für die Methode nicht richtig.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryReadUInt64">
      <MemberSignature Language="C#" Value="public static bool TryReadUInt64 (ReadOnlySpan&lt;byte&gt; source, System.Formats.Asn1.AsnEncodingRules ruleSet, out ulong value, out int bytesConsumed, System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReadUInt64(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, valuetype System.Formats.Asn1.AsnEncodingRules ruleSet, [out] unsigned int64&amp; value, [out] int32&amp; bytesConsumed, valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnDecoder.TryReadUInt64(System.ReadOnlySpan{System.Byte},System.Formats.Asn1.AsnEncodingRules,System.UInt64@,System.Int32@,System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryReadUInt64 (source As ReadOnlySpan(Of Byte), ruleSet As AsnEncodingRules, ByRef value As ULong, ByRef bytesConsumed As Integer, Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As Boolean" />
      <MemberSignature Language="F#" Value="static member TryReadUInt64 : ReadOnlySpan&lt;byte&gt; * System.Formats.Asn1.AsnEncodingRules * uint64 * int * Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; bool" Usage="System.Formats.Asn1.AsnDecoder.TryReadUInt64 (source, ruleSet, value, bytesConsumed, expectedTag)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="ruleSet" Type="System.Formats.Asn1.AsnEncodingRules" />
        <Parameter Name="value" Type="System.UInt64" RefType="out" />
        <Parameter Name="bytesConsumed" Type="System.Int32" RefType="out" />
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="source">Der Puffer, der codierte Daten enthält.</param>
        <param name="ruleSet">Die Codierungseinschränkungen, die beim Interpretieren der Daten verwendet werden sollen.</param>
        <param name="value">Empfängt bei Erfolg den interpretierten numerischen Wert.
Dieser Parameter wird nicht initialisiert behandelt.</param>
        <param name="bytesConsumed">Die Rückgabe dieser Methode ist die Gesamtzahl der Bytes für den codierten Wert.
Dieser Parameter wird nicht initialisiert behandelt.</param>
        <param name="expectedTag">Das Tag, das vor dem Lesen überprüft werden soll, oder <see langword="null" /> für das Standardtag (Universell 2).</param>
        <summary>Versucht, einen Integerwert aus <paramref name="source" /> mit einem angegebenen Tag gemäß den angegebenen Codierungsregeln als 64-Bit-Wert ohne Vorzeichen zu lesen.</summary>
        <returns><see langword="true" />, wenn der Integerwert zwischen <see cref="F:System.UInt64.MinValue" /> und <see cref="F:System.UInt64.MaxValue" /> (einschließlich) liegt, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="ruleSet" /> ist nicht definiert.</exception>
        <exception cref="T:System.Formats.Asn1.AsnContentException">Der nächste Wert weist nicht das richtige Tag auf.
Oder die Längencodierung ist gemäß den aktuellen Codierungsregeln ungültig.
Oder der Inhalt ist gemäß den aktuellen Codierungsregeln ungültig.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> ist <see cref="F:System.Formats.Asn1.TagClass.Universal" />, aber <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> ist für die Methode nicht richtig.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
