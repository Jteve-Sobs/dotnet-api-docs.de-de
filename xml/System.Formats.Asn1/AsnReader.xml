<Type Name="AsnReader" FullName="System.Formats.Asn1.AsnReader">
  <Metadata><Meta Name="ms.openlocfilehash" Value="788ea251768408281f0c4bcd8dfb6be8a05d50d3" /><Meta Name="ms.sourcegitcommit" Value="2f78d0752398ee2d15afbf06143cb62a01dc6d71" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="08/14/2020" /><Meta Name="ms.locfileid" Value="88242609" /></Metadata><TypeSignature Language="C#" Value="public class AsnReader" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit AsnReader extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Formats.Asn1.AsnReader" />
  <TypeSignature Language="VB.NET" Value="Public Class AsnReader" />
  <TypeSignature Language="C++ CLI" Value="public ref class AsnReader" />
  <TypeSignature Language="F#" Value="type AsnReader = class" />
  <AssemblyInfo>
    <AssemblyName>System.Formats.Asn1</AssemblyName>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Ein zustandsbehafteter Vorwärtsreader für BER-, CER- oder DER-codierte ASN.1-Daten.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AsnReader (ReadOnlyMemory&lt;byte&gt; data, System.Formats.Asn1.AsnEncodingRules ruleSet, System.Formats.Asn1.AsnReaderOptions options = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.ReadOnlyMemory`1&lt;unsigned int8&gt; data, valuetype System.Formats.Asn1.AsnEncodingRules ruleSet, valuetype System.Formats.Asn1.AsnReaderOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnReader.#ctor(System.ReadOnlyMemory{System.Byte},System.Formats.Asn1.AsnEncodingRules,System.Formats.Asn1.AsnReaderOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (data As ReadOnlyMemory(Of Byte), ruleSet As AsnEncodingRules, Optional options As AsnReaderOptions = Nothing)" />
      <MemberSignature Language="F#" Value="new System.Formats.Asn1.AsnReader : ReadOnlyMemory&lt;byte&gt; * System.Formats.Asn1.AsnEncodingRules * System.Formats.Asn1.AsnReaderOptions -&gt; System.Formats.Asn1.AsnReader" Usage="new System.Formats.Asn1.AsnReader (data, ruleSet, options)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="data" Type="System.ReadOnlyMemory&lt;System.Byte&gt;" />
        <Parameter Name="ruleSet" Type="System.Formats.Asn1.AsnEncodingRules" />
        <Parameter Name="options" Type="System.Formats.Asn1.AsnReaderOptions" />
      </Parameters>
      <Docs>
        <param name="data">Die zu lesenden Daten.</param>
        <param name="ruleSet">Die Codierungseinschränkungen für den Reader.</param>
        <param name="options">Zusätzliche Optionen für den Reader.</param>
        <summary>Erstellen Sie ein <see cref="T:System.Formats.Asn1.AsnReader" />-Element für <paramref name="data" /> mit einem angegebenen Regelsatz.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Dieser Konstruktor wertet nicht `data` aus Gründen der Richtigkeit aus. alle Richtigkeit der Überprüfungen werden als Teil der Element Methoden durchgeführt.
Dieser Konstruktor wird nicht kopiert `data` . Der Aufrufer ist dafür verantwortlich, sicherzustellen, dass die Werte nicht geändert werden, bis der Reader abgeschlossen ist.

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="ruleSet" /> ist nicht definiert.</exception>
      </Docs>
    </Member>
    <Member MemberName="HasData">
      <MemberSignature Language="C#" Value="public bool HasData { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasData" />
      <MemberSignature Language="DocId" Value="P:System.Formats.Asn1.AsnReader.HasData" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasData As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasData { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasData : bool" Usage="System.Formats.Asn1.AsnReader.HasData" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Angabe dazu ab, ob der Reader über verbleibende Daten zur Verarbeitung verfügt.</summary>
        <value><see langword="true" /> , wenn weitere Daten für den Reader zur Verarbeitung verfügbar sind. andernfalls <see langword="false" /> .</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PeekContentBytes">
      <MemberSignature Language="C#" Value="public ReadOnlyMemory&lt;byte&gt; PeekContentBytes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.ReadOnlyMemory`1&lt;unsigned int8&gt; PeekContentBytes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnReader.PeekContentBytes" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekContentBytes () As ReadOnlyMemory(Of Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReadOnlyMemory&lt;System::Byte&gt; PeekContentBytes();" />
      <MemberSignature Language="F#" Value="member this.PeekContentBytes : unit -&gt; ReadOnlyMemory&lt;byte&gt;" Usage="asnReader.PeekContentBytes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlyMemory&lt;System.Byte&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft eine <see cref="T:System.ReadOnlyMemory`1" />-Ansicht der Inhaltsoktette (Bytes) des nächsten codierten Werts ab, ohne dass der Reader fortfährt.</summary>
        <returns>Die Bytes der Inhaltsoktette des nächsten codierten Werts.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Formats.Asn1.AsnContentException">Der Reader wird an einem Punkt positioniert, an dem das Tag oder die Länge gemäß den aktuellen Codierungsregeln ungültig ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="PeekEncodedValue">
      <MemberSignature Language="C#" Value="public ReadOnlyMemory&lt;byte&gt; PeekEncodedValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.ReadOnlyMemory`1&lt;unsigned int8&gt; PeekEncodedValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnReader.PeekEncodedValue" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekEncodedValue () As ReadOnlyMemory(Of Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReadOnlyMemory&lt;System::Byte&gt; PeekEncodedValue();" />
      <MemberSignature Language="F#" Value="member this.PeekEncodedValue : unit -&gt; ReadOnlyMemory&lt;byte&gt;" Usage="asnReader.PeekEncodedValue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlyMemory&lt;System.Byte&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft eine <see cref="T:System.ReadOnlyMemory`1" />-Ansicht des nächsten codierten Werts ab, ohne dass der Reader fortfährt. Bei Codierungen mit unbegrenzter Länge umfasst dies den Marker für das Ende des Inhalts.</summary>
        <returns>Die Bytes des nächsten codierten Werts.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Formats.Asn1.AsnContentException">Der Reader wird an einem Punkt positioniert, an dem das Tag oder die Länge gemäß den aktuellen Codierungsregeln ungültig ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="PeekTag">
      <MemberSignature Language="C#" Value="public System.Formats.Asn1.Asn1Tag PeekTag ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Formats.Asn1.Asn1Tag PeekTag() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnReader.PeekTag" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekTag () As Asn1Tag" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Formats::Asn1::Asn1Tag PeekTag();" />
      <MemberSignature Language="F#" Value="member this.PeekTag : unit -&gt; System.Formats.Asn1.Asn1Tag" Usage="asnReader.PeekTag " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Formats.Asn1.Asn1Tag</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest das codierte Tag an der nächsten Datenposition, ohne dass der Reader vorwärtsbewegt wird.</summary>
        <returns>Der decodierte Tagwert.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Formats.Asn1.AsnContentException">An der aktuellen Position des Readers konnte ein Tag nicht decodiert werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadBitString">
      <MemberSignature Language="C#" Value="public byte[] ReadBitString (out int unusedBitCount, System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] ReadBitString([out] int32&amp; unusedBitCount, valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnReader.ReadBitString(System.Int32@,System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadBitString (ByRef unusedBitCount As Integer, Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As Byte()" />
      <MemberSignature Language="F#" Value="member this.ReadBitString : int * Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; byte[]" Usage="asnReader.ReadBitString (unusedBitCount, expectedTag)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unusedBitCount" Type="System.Int32" RefType="out" />
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="unusedBitCount">Bei erfolgreichem Vorgang wird die Anzahl von Bits im letzten Byte empfangen, die vom Writer als „nicht verwendet“ gemeldet wurden.</param>
        <param name="expectedTag">Das Tag, das vor dem Lesen überprüft werden soll, oder <see langword="null" /> für das Standardtag (Universal 1).</param>
        <summary>Liest den nächsten Wert als BIT STRING mit einem angegebenen Tag und gibt den Wert in einem Bytearray zurück.</summary>
        <returns>Eine Kopie des Werts in einem neu zugeordneten Array mit präziser Größe.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Formats.Asn1.AsnContentException">Der nächste Wert verfügt nicht über das korrekte Tag.
Oder die Längencodierung ist gemäß den aktuellen Codierungsregeln ungültig.
Oder der Inhalt ist gemäß den aktuellen Codierungsregeln ungültig.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> ist <see cref="F:System.Formats.Asn1.TagClass.Universal" />, aber <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> ist für die Methode nicht korrekt.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadBoolean">
      <MemberSignature Language="C#" Value="public bool ReadBoolean (System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReadBoolean(valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnReader.ReadBoolean(System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadBoolean (Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As Boolean" />
      <MemberSignature Language="F#" Value="member this.ReadBoolean : Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; bool" Usage="asnReader.ReadBoolean expectedTag" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="expectedTag">Das Tag, das vor dem Lesen überprüft werden soll, oder <see langword="null" /> für das Standardtag (Universal 1).</param>
        <summary>Liest den nächsten Wert als booleschen Wert mit einem angegebenen Tag.</summary>
        <returns>Der decodierte Wert.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Formats.Asn1.AsnContentException">Der nächste Wert verfügt nicht über das korrekte Tag.
Oder die Längencodierung ist gemäß den aktuellen Codierungsregeln ungültig.
Oder der Inhalt ist gemäß den aktuellen Codierungsregeln ungültig.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> ist <see cref="F:System.Formats.Asn1.TagClass.Universal" />, aber <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> ist für die Methode nicht korrekt.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadCharacterString">
      <MemberSignature Language="C#" Value="public string ReadCharacterString (System.Formats.Asn1.UniversalTagNumber encodingType, System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ReadCharacterString(valuetype System.Formats.Asn1.UniversalTagNumber encodingType, valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnReader.ReadCharacterString(System.Formats.Asn1.UniversalTagNumber,System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadCharacterString (encodingType As UniversalTagNumber, Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As String" />
      <MemberSignature Language="F#" Value="member this.ReadCharacterString : System.Formats.Asn1.UniversalTagNumber * Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; string" Usage="asnReader.ReadCharacterString (encodingType, expectedTag)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="encodingType" Type="System.Formats.Asn1.UniversalTagNumber" />
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="encodingType">Einer der Enumerationswerte, der den zu verarbeitenden Werttyp darstellt.</param>
        <param name="expectedTag">Das Tag, das vor dem Lesen überprüft werden soll, oder <see langword="null" /> für das universelle Tag, das für den angeforderten Codierungstyp geeignet ist.</param>
        <summary>Liest den nächsten Wert als Zeichenfolge mit dem angegebenen Tag und Codierungstyp und gibt den decodierten Wert als Zeichenfolge zurück.</summary>
        <returns>Der decodierte Wert.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="encodingType" /> ist kein bekannter Zeichenfolgentyp.</exception>
        <exception cref="T:System.Formats.Asn1.AsnContentException">Der nächste Wert verfügt nicht über das korrekte Tag.
Oder die Längencodierung ist gemäß den aktuellen Codierungsregeln ungültig.
Oder der Inhalt ist gemäß den aktuellen Codierungsregeln ungültig.
Oder die Zeichenfolge konnte nicht erfolgreich decodiert werden.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> ist <see cref="F:System.Formats.Asn1.TagClass.Universal" />, aber <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> ist nicht identisch mit <paramref name="encodingType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadEncodedValue">
      <MemberSignature Language="C#" Value="public ReadOnlyMemory&lt;byte&gt; ReadEncodedValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.ReadOnlyMemory`1&lt;unsigned int8&gt; ReadEncodedValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnReader.ReadEncodedValue" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadEncodedValue () As ReadOnlyMemory(Of Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReadOnlyMemory&lt;System::Byte&gt; ReadEncodedValue();" />
      <MemberSignature Language="F#" Value="member this.ReadEncodedValue : unit -&gt; ReadOnlyMemory&lt;byte&gt;" Usage="asnReader.ReadEncodedValue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlyMemory&lt;System.Byte&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft eine <see cref="T:System.ReadOnlyMemory`1" />-Ansicht des nächsten codierten Werts ab, und der Reader wird bis zu einer Position nach diesem Wert vorwärtsbewegt. Bei einer Codierung mit unbegrenzter Länge umfasst dies den Marker für das Ende des Inhalts.</summary>
        <returns>Eine <see cref="T:System.ReadOnlyMemory`1" />-Ansicht des nächsten codierten Werts.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadEnumeratedBytes">
      <MemberSignature Language="C#" Value="public ReadOnlyMemory&lt;byte&gt; ReadEnumeratedBytes (System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.ReadOnlyMemory`1&lt;unsigned int8&gt; ReadEnumeratedBytes(valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnReader.ReadEnumeratedBytes(System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadEnumeratedBytes (Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As ReadOnlyMemory(Of Byte)" />
      <MemberSignature Language="F#" Value="member this.ReadEnumeratedBytes : Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; ReadOnlyMemory&lt;byte&gt;" Usage="asnReader.ReadEnumeratedBytes expectedTag" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlyMemory&lt;System.Byte&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="expectedTag">Das Tag, das vor dem Lesen überprüft werden soll, oder <see langword="null" /> für das Standardtag (Universal 10).</param>
        <summary>Liest den nächsten Wert als Enumerationswert mit einem angegebenen Tag und gibt die Inhalte als <see cref="T:System.ReadOnlyMemory`1" /> für die ursprünglichen Daten zurück.</summary>
        <returns>Die Bytes des Enumerationswerts, im big-endian-Format mit Vorzeichen.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Formats.Asn1.AsnContentException">Der nächste Wert verfügt nicht über das korrekte Tag.
Oder die Längencodierung ist gemäß den aktuellen Codierungsregeln ungültig.
Oder der Inhalt ist gemäß den aktuellen Codierungsregeln ungültig.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> ist <see cref="F:System.Formats.Asn1.TagClass.Universal" />, aber <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> ist für die Methode nicht korrekt.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadEnumeratedValue">
      <MemberSignature Language="C#" Value="public Enum ReadEnumeratedValue (Type enumType, System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Enum ReadEnumeratedValue(class System.Type enumType, valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnReader.ReadEnumeratedValue(System.Type,System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadEnumeratedValue (enumType As Type, Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As Enum" />
      <MemberSignature Language="F#" Value="member this.ReadEnumeratedValue : Type * Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; Enum" Usage="asnReader.ReadEnumeratedValue (enumType, expectedTag)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Enum</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="enumType">Typobjekt, das den Zieltyp darstellt.</param>
        <param name="expectedTag">Das Tag, das vor dem Lesen überprüft werden soll, oder <see langword="null" /> für das Standardtag (Universal 10).</param>
        <summary>Liest den nächsten Wert als Enumerationswert mit einem angegebenen Tag und konvertiert ihn in den Nicht-[<see cref="T:System.FlagsAttribute" />]-Enumerationswert, der von <paramref name="enumType" /> angegeben ist.</summary>
        <returns>Der in ein <paramref name="enumType" />-Element konvertierte Enumerationswert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Diese Methode überprüft nicht, ob der Rückgabewert in definiert ist `enumType` .

          ]]></format>
        </remarks>
        <exception cref="T:System.Formats.Asn1.AsnContentException">Der nächste Wert verfügt nicht über das korrekte Tag.
Oder die Längencodierung ist gemäß den aktuellen Codierungsregeln ungültig.
Oder der Inhalt ist gemäß den aktuellen Codierungsregeln ungültig.
Oder der codierte Wert ist zu groß für einen <paramref name="enumType" />-Wert.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="enumType" /> ist kein Enumerationstyp.
Oder <paramref name="enumType" /> wurde mit <see cref="T:System.FlagsAttribute" /> deklariert.
Oder <paramref name="enumType" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> ist <see cref="F:System.Formats.Asn1.TagClass.Universal" />, aber <paramref name="enumType" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> ist für die Methode nicht korrekt.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="enumType" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadEnumeratedValue&lt;TEnum&gt;">
      <MemberSignature Language="C#" Value="public TEnum ReadEnumeratedValue&lt;TEnum&gt; (System.Formats.Asn1.Asn1Tag? expectedTag = default) where TEnum : Enum;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !!TEnum ReadEnumeratedValue&lt;(class System.Enum) TEnum&gt;(valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnReader.ReadEnumeratedValue``1(System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadEnumeratedValue(Of TEnum As Enum) (Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As TEnum" />
      <MemberSignature Language="F#" Value="member this.ReadEnumeratedValue : Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; 'Enum (requires 'Enum :&gt; Enum)" Usage="asnReader.ReadEnumeratedValue expectedTag" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TEnum</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEnum">
          <Constraints>
            <BaseTypeName>System.Enum</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TEnum">Ziel-Aufzählungs Typen</typeparam>
        <param name="expectedTag">Das Tag, das vor dem Lesen überprüft werden soll, oder <see langword="null" /> für das Standardtag (Universal 10).</param>
        <summary>Liest den nächsten Wert als Enumerationswert mit einem angegebenen Tag und konvertiert ihn in den Nicht-[<see cref="T:System.FlagsAttribute" />]-Enumerationswert, der von <typeparamref name="TEnum" /> angegeben ist.</summary>
        <returns>Der in ein <typeparamref name="TEnum" />-Element konvertierte Enumerationswert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Diese Methode überprüft nicht, ob der Rückgabewert in <typeparamref Name = "TEnum> definiert ist.

          ]]></format>
        </remarks>
        <exception cref="T:System.Formats.Asn1.AsnContentException">Der nächste Wert verfügt nicht über das korrekte Tag.
Oder die Längencodierung ist gemäß den aktuellen Codierungsregeln ungültig.
Oder der Inhalt ist gemäß den aktuellen Codierungsregeln ungültig.
Oder der codierte Wert ist zu groß für einen <typeparamref name="TEnum" />-Wert.</exception>
        <exception cref="T:System.ArgumentException"><typeparamref name="TEnum" /> ist kein Enumerationstyp.
Oder <typeparamref name="TEnum" /> wurde mit <see cref="T:System.FlagsAttribute" /> deklariert.
Oder <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> ist <see cref="F:System.Formats.Asn1.TagClass.Universal" />, aber <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> ist für die Methode nicht korrekt.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadGeneralizedTime">
      <MemberSignature Language="C#" Value="public DateTimeOffset ReadGeneralizedTime (System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.DateTimeOffset ReadGeneralizedTime(valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnReader.ReadGeneralizedTime(System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadGeneralizedTime (Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As DateTimeOffset" />
      <MemberSignature Language="F#" Value="member this.ReadGeneralizedTime : Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; DateTimeOffset" Usage="asnReader.ReadGeneralizedTime expectedTag" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTimeOffset</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="expectedTag">Das Tag, das vor dem Lesen überprüft werden soll, oder <see langword="null" /> für das Standardtag (Universal 24).</param>
        <summary>Liest den nächsten Wert als GeneralizedTime-Wert mit einem angegebenen Tag.</summary>
        <returns>Der decodierte Wert.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Formats.Asn1.AsnContentException">Der nächste Wert verfügt nicht über das korrekte Tag.
Oder die Längencodierung ist gemäß den aktuellen Codierungsregeln ungültig.
Oder der Inhalt ist gemäß den aktuellen Codierungsregeln ungültig.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> ist <see cref="F:System.Formats.Asn1.TagClass.Universal" />, aber <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> ist für die Methode nicht korrekt.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadInteger">
      <MemberSignature Language="C#" Value="public System.Numerics.BigInteger ReadInteger (System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Numerics.BigInteger ReadInteger(valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnReader.ReadInteger(System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadInteger (Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As BigInteger" />
      <MemberSignature Language="F#" Value="member this.ReadInteger : Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; System.Numerics.BigInteger" Usage="asnReader.ReadInteger expectedTag" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="expectedTag">Das Tag, das vor dem Lesen überprüft werden soll, oder <see langword="null" /> für das Standardtag (Universal 2).</param>
        <summary>Liest den nächsten Wert als Ganzzahl mit einem angegebenen Tag.</summary>
        <returns>Der decodierte Wert.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Formats.Asn1.AsnContentException">Der nächste Wert verfügt nicht über das korrekte Tag.
Oder die Längencodierung ist gemäß den aktuellen Codierungsregeln ungültig.
Oder der Inhalt ist gemäß den aktuellen Codierungsregeln ungültig.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> ist <see cref="F:System.Formats.Asn1.TagClass.Universal" />, aber <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> ist für die Methode nicht korrekt.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadIntegerBytes">
      <MemberSignature Language="C#" Value="public ReadOnlyMemory&lt;byte&gt; ReadIntegerBytes (System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.ReadOnlyMemory`1&lt;unsigned int8&gt; ReadIntegerBytes(valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnReader.ReadIntegerBytes(System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadIntegerBytes (Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As ReadOnlyMemory(Of Byte)" />
      <MemberSignature Language="F#" Value="member this.ReadIntegerBytes : Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; ReadOnlyMemory&lt;byte&gt;" Usage="asnReader.ReadIntegerBytes expectedTag" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlyMemory&lt;System.Byte&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="expectedTag">Das Tag, das vor dem Lesen überprüft werden soll, oder <see langword="null" /> für das Standardtag (Universal 2).</param>
        <summary>Liest den nächsten Wert als Ganzzahl mit einem angegebenen Tag und gibt die Inhalte als <see cref="T:System.ReadOnlyMemory`1" /> für die ursprünglichen Daten zurück.</summary>
        <returns>Die Bytes des Ganzzahlwerts, im big-endian-Format mit Vorzeichen.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Formats.Asn1.AsnContentException">Der nächste Wert verfügt nicht über das korrekte Tag.
Oder die Längencodierung ist gemäß den aktuellen Codierungsregeln ungültig.
Oder der Inhalt ist gemäß den aktuellen Codierungsregeln ungültig.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> ist <see cref="F:System.Formats.Asn1.TagClass.Universal" />, aber <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> ist für die Methode nicht korrekt.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadNamedBitList">
      <MemberSignature Language="C#" Value="public System.Collections.BitArray ReadNamedBitList (System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.BitArray ReadNamedBitList(valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnReader.ReadNamedBitList(System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadNamedBitList (Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As BitArray" />
      <MemberSignature Language="F#" Value="member this.ReadNamedBitList : Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; System.Collections.BitArray" Usage="asnReader.ReadNamedBitList expectedTag" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.BitArray</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="expectedTag">Das Tag, das vor dem Lesen überprüft werden soll.</param>
        <summary>Liest den nächsten Wert als NamedBitList mit einem angegebenen Tag.</summary>
        <returns>Die Bits aus dem codierten Wert.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Formats.Asn1.AsnContentException">Der nächste Wert verfügt nicht über das korrekte Tag.
Oder die Längencodierung ist gemäß den aktuellen Codierungsregeln ungültig.
Oder der Inhalt ist gemäß den aktuellen Codierungsregeln ungültig.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> ist <see cref="F:System.Formats.Asn1.TagClass.Universal" />, aber <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> ist für die Methode nicht korrekt.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadNamedBitListValue">
      <MemberSignature Language="C#" Value="public Enum ReadNamedBitListValue (Type flagsEnumType, System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Enum ReadNamedBitListValue(class System.Type flagsEnumType, valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnReader.ReadNamedBitListValue(System.Type,System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadNamedBitListValue (flagsEnumType As Type, Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As Enum" />
      <MemberSignature Language="F#" Value="member this.ReadNamedBitListValue : Type * Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; Enum" Usage="asnReader.ReadNamedBitListValue (flagsEnumType, expectedTag)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Enum</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="flagsEnumType" Type="System.Type" />
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="flagsEnumType">Typobjekt, das den Zieltyp darstellt.</param>
        <param name="expectedTag">Das Tag, das vor dem Lesen überprüft werden soll.</param>
        <summary>Liest den nächsten Wert als NamedBitList mit einem angegebenen Tag und konvertiert ihn in den [<see cref="T:System.FlagsAttribute" />]-Enumerationswert, der von <paramref name="flagsEnumType" /> angegeben ist.</summary>
        <returns>Der in ein <paramref name="flagsEnumType" />-Element konvertierte NamedBitList-Wert.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Formats.Asn1.AsnContentException">Der nächste Wert verfügt nicht über das korrekte Tag.
Oder die Längencodierung ist gemäß den aktuellen Codierungsregeln ungültig.
Oder der Inhalt ist gemäß den aktuellen Codierungsregeln ungültig.
Oder der codierte Wert ist zu groß für einen <paramref name="flagsEnumType" />-Wert.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="flagsEnumType" /> ist kein Enumerationstyp.
Oder <paramref name="flagsEnumType" /> wurde nicht mit <see cref="T:System.FlagsAttribute" /> deklariert oder <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> ist <see cref="F:System.Formats.Asn1.TagClass.Universal" />, aber <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> ist für die Methode nicht korrekt.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="flagsEnumType" /> ist gleich <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadNamedBitListValue&lt;TFlagsEnum&gt;">
      <MemberSignature Language="C#" Value="public TFlagsEnum ReadNamedBitListValue&lt;TFlagsEnum&gt; (System.Formats.Asn1.Asn1Tag? expectedTag = default) where TFlagsEnum : Enum;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !!TFlagsEnum ReadNamedBitListValue&lt;(class System.Enum) TFlagsEnum&gt;(valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnReader.ReadNamedBitListValue``1(System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadNamedBitListValue(Of TFlagsEnum As Enum) (Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As TFlagsEnum" />
      <MemberSignature Language="F#" Value="member this.ReadNamedBitListValue : Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; 'FlagsEnum (requires 'FlagsEnum :&gt; Enum)" Usage="asnReader.ReadNamedBitListValue expectedTag" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TFlagsEnum</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TFlagsEnum">
          <Constraints>
            <BaseTypeName>System.Enum</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TFlagsEnum">Ziel-Aufzählungs Typen</typeparam>
        <param name="expectedTag">Das Tag, das vor dem Lesen überprüft werden soll.</param>
        <summary>Liest den nächsten Wert als NamedBitList mit einem angegebenen Tag und konvertiert ihn in den [<see cref="T:System.FlagsAttribute" />]-Enumerationswert, der von <typeparamref name="TFlagsEnum" /> angegeben ist.</summary>
        <returns>Der in ein <typeparamref name="TFlagsEnum" />-Element konvertierte NamedBitList-Wert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Die von dieser Methode ausgeführte bitausrichtung besteht darin, das signifikanteste Bit im ersten Byte des Werts als das unwichtigste Bit in <typeparamref Name = "tflagsenum> zu interpretieren, wobei Bits den Wert bis zum geringsten signifikanten Bit des ersten Bytes überschreitet, mit dem signifikantesten Bit des zweiten Bytes usw. Unter diesem Schema können die folgende ASN. 1-Typdeklaration und die c#-Enumeration verwendet werden: <code> KeyUsage ::= BIT STRING { digitalSignature   (0), nonRepudiation     (1), keyEncipherment    (2), dataEncipherment   (3), keyAgreement       (4), keyCertSign        (5), cRLSign            (6), encipherOnly       (7), decipherOnly       (8) } </code><code> [Flags] enum KeyUsage { None              = 0, DigitalSignature  = 1 &lt;&lt; (0), NonRepudiation    = 1 &lt;&lt; (1), KeyEncipherment   = 1 &lt;&lt; (2), DataEncipherment  = 1 &lt;&lt; (3), KeyAgreement      = 1 &lt;&lt; (4), KeyCertSign       = 1 &lt;&lt; (5), CrlSign           = 1 &lt;&lt; (6), EncipherOnly      = 1 &lt;&lt; (7), DecipherOnly      = 1 &lt;&lt; (8), } </code> 
Beachten Sie, dass im Beispiel hier die KeyUsage-namedbitlist aus <a href="https://tools.ietf.org/html/rfc3280#section-4.2.1.3">RFC 3280 (4.2.1.3)</a>verwendet wird, die example-Enumeration jedoch Werte verwendet, die sich von System. Security. Cryptography. X509Certificates. X509KeyUsageFlags unterscheiden.

          ]]></format>
        </remarks>
        <exception cref="T:System.Formats.Asn1.AsnContentException">Der nächste Wert verfügt nicht über das korrekte Tag.
Oder die Längencodierung ist gemäß den aktuellen Codierungsregeln ungültig.
Oder der Inhalt ist gemäß den aktuellen Codierungsregeln ungültig.
Oder der codierte Wert ist zu groß für einen <typeparamref name="TFlagsEnum" />-Wert.</exception>
        <exception cref="T:System.ArgumentException"><typeparamref name="TFlagsEnum" /> ist kein Enumerationstyp.
Oder <typeparamref name="TFlagsEnum" /> wurde nicht mit <see cref="T:System.FlagsAttribute" /> deklariert oder <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> ist <see cref="F:System.Formats.Asn1.TagClass.Universal" />, aber <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> ist für die Methode nicht korrekt.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadNull">
      <MemberSignature Language="C#" Value="public void ReadNull (System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadNull(valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnReader.ReadNull(System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadNull (Optional expectedTag As Nullable(Of Asn1Tag) = Nothing)" />
      <MemberSignature Language="F#" Value="member this.ReadNull : Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; unit" Usage="asnReader.ReadNull expectedTag" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="expectedTag">Das Tag, das vor dem Lesen überprüft werden soll, oder <see langword="null" /> für das Standardtag (Universal 5).</param>
        <summary>Liest den nächsten Wert als NULL mit einem angegebenen Tag.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Formats.Asn1.AsnContentException">Der nächste Wert verfügt nicht über das korrekte Tag.
Oder die Längencodierung ist gemäß den aktuellen Codierungsregeln ungültig.
Oder der Inhalt ist gemäß den aktuellen Codierungsregeln ungültig.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> ist <see cref="F:System.Formats.Asn1.TagClass.Universal" />, aber <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> ist für die Methode nicht korrekt.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadObjectIdentifier">
      <MemberSignature Language="C#" Value="public string ReadObjectIdentifier (System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ReadObjectIdentifier(valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnReader.ReadObjectIdentifier(System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadObjectIdentifier (Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As String" />
      <MemberSignature Language="F#" Value="member this.ReadObjectIdentifier : Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; string" Usage="asnReader.ReadObjectIdentifier expectedTag" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="expectedTag">Das Tag, das vor dem Lesen überprüft werden soll, oder <see langword="null" /> für das Standardtag (Universal 6).</param>
        <summary>Liest den nächsten Wert als OBJECT IDENTIFIER mit einem angegebenen Tag und gibt den Wert in einer Zeichenfolge im Dezimalpunktformat zurück.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Formats.Asn1.AsnContentException">Der nächste Wert verfügt nicht über das korrekte Tag.
Oder die Längencodierung ist gemäß den aktuellen Codierungsregeln ungültig.
Oder der Inhalt ist gemäß den aktuellen Codierungsregeln ungültig.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> ist <see cref="F:System.Formats.Asn1.TagClass.Universal" />, aber <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> ist für die Methode nicht korrekt.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadOctetString">
      <MemberSignature Language="C#" Value="public byte[] ReadOctetString (System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] ReadOctetString(valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnReader.ReadOctetString(System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadOctetString (Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As Byte()" />
      <MemberSignature Language="F#" Value="member this.ReadOctetString : Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; byte[]" Usage="asnReader.ReadOctetString expectedTag" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="expectedTag">Das Tag, das vor dem Lesen überprüft werden soll, oder <see langword="null" /> für das Standardtag (Universal 4).</param>
        <summary>Liest den nächsten Wert als OCTET STRING mit dem UNIVERSAL 4-Tag und gibt den Wert in einem Bytearray zurück.</summary>
        <returns>Eine Kopie des Werts in einem neu zugeordneten Array mit präziser Größe.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Formats.Asn1.AsnContentException">Der nächste Wert verfügt nicht über das korrekte Tag.
Oder die Längencodierung ist gemäß den aktuellen Codierungsregeln ungültig.
Oder der Inhalt ist gemäß den aktuellen Codierungsregeln ungültig.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> ist <see cref="F:System.Formats.Asn1.TagClass.Universal" />, aber <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> ist für die Methode nicht korrekt.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadSequence">
      <MemberSignature Language="C#" Value="public System.Formats.Asn1.AsnReader ReadSequence (System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Formats.Asn1.AsnReader ReadSequence(valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnReader.ReadSequence(System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadSequence (Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As AsnReader" />
      <MemberSignature Language="F#" Value="member this.ReadSequence : Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; System.Formats.Asn1.AsnReader" Usage="asnReader.ReadSequence expectedTag" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Formats.Asn1.AsnReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="expectedTag">Das Tag, das vor dem Lesen überprüft werden soll, oder <see langword="null" /> für das Standardtag (Universal 16).</param>
        <summary>Liest den nächsten Wert als SEQUENCE oder SEQUENCE-OF mit dem angegebenen Tag und gibt das Ergebnis als neuen Reader zurück, der beim ersten Wert in der Sequenz positioniert ist (oder mit <see cref="P:System.Formats.Asn1.AsnReader.HasData" />  ==  <see langword="false" /> ).</summary>
        <returns>Ein neuer Reader, der beim ersten Wert in der Sequenz positioniert ist (oder mit <see cref="P:System.Formats.Asn1.AsnReader.HasData" /> == <see langword="false" />).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

der Inhalt wird nicht von dieser Methode ausgewertet und kann Daten enthalten, die unter den aktuellen Codierungsregeln nicht gültig sind.

          ]]></format>
        </remarks>
        <exception cref="T:System.Formats.Asn1.AsnContentException">Der nächste Wert verfügt nicht über das korrekte Tag.
Oder die Längencodierung ist gemäß den aktuellen Codierungsregeln ungültig.
Oder der Inhalt ist gemäß den aktuellen Codierungsregeln ungültig.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> ist <see cref="F:System.Formats.Asn1.TagClass.Universal" />, aber <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> ist für die Methode nicht korrekt.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadSetOf">
      <MemberSignature Language="C#" Value="public System.Formats.Asn1.AsnReader ReadSetOf (System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Formats.Asn1.AsnReader ReadSetOf(valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnReader.ReadSetOf(System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadSetOf (Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As AsnReader" />
      <MemberSignature Language="F#" Value="member this.ReadSetOf : Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; System.Formats.Asn1.AsnReader" Usage="asnReader.ReadSetOf expectedTag" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Formats.Asn1.AsnReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="expectedTag">Das Tag, das vor dem Lesen überprüft werden soll, oder <see langword="null" /> für das Standardtag (Universal 17).</param>
        <summary>Liest den nächsten Wert als SET-OF mit dem angegebenen Tag und gibt das Ergebnis als neuen Reader zurück, der beim ersten Wert im SET-OF-Element positioniert ist (oder mit <see cref="P:System.Formats.Asn1.AsnReader.HasData" /> == <see langword="false" />). Dabei wird der <see cref="P:System.Formats.Asn1.AsnReaderOptions.SkipSetSortOrderVerification" />-Wert des Konstruktors verwendet (Standardwert <see langword="false" />).</summary>
        <returns>Ein neuer Reader, der beim ersten Wert im SET-OF-Element positioniert ist (oder mit <see cref="P:System.Formats.Asn1.AsnReader.HasData" /> == <see langword="false" />).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

der Inhalt wird nicht von dieser Methode ausgewertet (abgesehen von der Sortierreihenfolge, wenn erforderlich) und kann Daten enthalten, die unter den aktuellen Codierungsregeln nicht gültig sind.

          ]]></format>
        </remarks>
        <exception cref="T:System.Formats.Asn1.AsnContentException">Der nächste Wert verfügt nicht über das korrekte Tag.
Oder die Längencodierung ist gemäß den aktuellen Codierungsregeln ungültig.
Oder der Inhalt ist gemäß den aktuellen Codierungsregeln ungültig.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> ist <see cref="F:System.Formats.Asn1.TagClass.Universal" />, aber <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> ist für die Methode nicht korrekt.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadSetOf">
      <MemberSignature Language="C#" Value="public System.Formats.Asn1.AsnReader ReadSetOf (bool skipSortOrderValidation, System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Formats.Asn1.AsnReader ReadSetOf(bool skipSortOrderValidation, valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnReader.ReadSetOf(System.Boolean,System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadSetOf (skipSortOrderValidation As Boolean, Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As AsnReader" />
      <MemberSignature Language="F#" Value="member this.ReadSetOf : bool * Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; System.Formats.Asn1.AsnReader" Usage="asnReader.ReadSetOf (skipSortOrderValidation, expectedTag)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Formats.Asn1.AsnReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="skipSortOrderValidation" Type="System.Boolean" />
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="skipSortOrderValidation"><see langword="true" />, um die Daten immer in der Reihenfolge zu akzeptieren, in der sie vorliegen, <see langword="false" />, um zu bestätigen, dass die Daten ordnungsgemäß sortiert sind, wenn die Codierungsregeln besagen, dass eine Sortierung erforderlich war (CER und DER).</param>
        <param name="expectedTag">Das Tag, das vor dem Lesen überprüft werden soll, oder <see langword="null" /> für das Standardtag (Universal 17).</param>
        <summary>Liest den nächsten Wert als SET-OF mit dem angegebenen Tag und gibt das Ergebnis als neuen Reader zurück, der beim ersten Wert im SET-OF-Element positioniert ist (oder mit <see cref="P:System.Formats.Asn1.AsnReader.HasData" /> == <see langword="false" />).</summary>
        <returns>Ein neuer Reader, der beim ersten Wert im SET-OF-Element positioniert ist (oder mit <see cref="P:System.Formats.Asn1.AsnReader.HasData" /> == <see langword="false" />).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

der Inhalt wird nicht von dieser Methode ausgewertet (abgesehen von der Sortierreihenfolge, wenn erforderlich) und kann Daten enthalten, die unter den aktuellen Codierungsregeln nicht gültig sind.

          ]]></format>
        </remarks>
        <exception cref="T:System.Formats.Asn1.AsnContentException">Der nächste Wert verfügt nicht über das korrekte Tag.
Oder die Längencodierung ist gemäß den aktuellen Codierungsregeln ungültig.
Oder der Inhalt ist gemäß den aktuellen Codierungsregeln ungültig.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> ist <see cref="F:System.Formats.Asn1.TagClass.Universal" />, aber <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> ist für die Methode nicht korrekt.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadUtcTime">
      <MemberSignature Language="C#" Value="public DateTimeOffset ReadUtcTime (System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.DateTimeOffset ReadUtcTime(valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnReader.ReadUtcTime(System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadUtcTime (Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As DateTimeOffset" />
      <MemberSignature Language="F#" Value="member this.ReadUtcTime : Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; DateTimeOffset" Usage="asnReader.ReadUtcTime expectedTag" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTimeOffset</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="expectedTag">Das Tag, das vor dem Lesen überprüft werden soll, oder <see langword="null" /> für das Standardtag (Universal 23).</param>
        <summary>Liest den nächsten Wert als UTCTime mit einem angegebenen Tag unter Verwendung des <see cref="P:System.Formats.Asn1.AsnReaderOptions.UtcTimeTwoDigitYearMax" />-Werts aus den Optionen, die an den Konstruktor übergeben werden (Standardwert 2049).</summary>
        <returns>Der decodierte Wert.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Formats.Asn1.AsnContentException">Der nächste Wert verfügt nicht über das korrekte Tag.
Oder die Längencodierung ist gemäß den aktuellen Codierungsregeln ungültig.
Oder der Inhalt ist gemäß den aktuellen Codierungsregeln ungültig.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> ist <see cref="F:System.Formats.Asn1.TagClass.Universal" />, aber <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> ist für die Methode nicht korrekt.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadUtcTime">
      <MemberSignature Language="C#" Value="public DateTimeOffset ReadUtcTime (int twoDigitYearMax, System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.DateTimeOffset ReadUtcTime(int32 twoDigitYearMax, valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnReader.ReadUtcTime(System.Int32,System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadUtcTime (twoDigitYearMax As Integer, Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As DateTimeOffset" />
      <MemberSignature Language="F#" Value="member this.ReadUtcTime : int * Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; DateTimeOffset" Usage="asnReader.ReadUtcTime (twoDigitYearMax, expectedTag)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTimeOffset</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="twoDigitYearMax" Type="System.Int32" />
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="twoDigitYearMax">Das größte Jahr, das mit diesem Wert dargestellt werden soll.</param>
        <param name="expectedTag">Das Tag, das vor dem Lesen überprüft werden soll, oder <see langword="null" /> für das Standardtag (Universal 23).</param>
        <summary>Liest den nächsten Wert als UTCTime mit einem angegebenen Tag.</summary>
        <returns>Der decodierte Wert.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Formats.Asn1.AsnContentException">Der nächste Wert verfügt nicht über das korrekte Tag.
Oder die Längencodierung ist gemäß den aktuellen Codierungsregeln ungültig.
Oder der Inhalt ist gemäß den aktuellen Codierungsregeln ungültig.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> ist <see cref="F:System.Formats.Asn1.TagClass.Universal" />, aber <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> ist für die Methode nicht korrekt.</exception>
      </Docs>
    </Member>
    <Member MemberName="RuleSet">
      <MemberSignature Language="C#" Value="public System.Formats.Asn1.AsnEncodingRules RuleSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Formats.Asn1.AsnEncodingRules RuleSet" />
      <MemberSignature Language="DocId" Value="P:System.Formats.Asn1.AsnReader.RuleSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RuleSet As AsnEncodingRules" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Formats::Asn1::AsnEncodingRules RuleSet { System::Formats::Asn1::AsnEncodingRules get(); };" />
      <MemberSignature Language="F#" Value="member this.RuleSet : System.Formats.Asn1.AsnEncodingRules" Usage="System.Formats.Asn1.AsnReader.RuleSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Formats.Asn1.AsnEncodingRules</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Codierungsregeln ab, die von diesem Reader verwendet werden.</summary>
        <value>Die von diesem Reader verwendeten Codierungsregeln.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ThrowIfNotEmpty">
      <MemberSignature Language="C#" Value="public void ThrowIfNotEmpty ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ThrowIfNotEmpty() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnReader.ThrowIfNotEmpty" />
      <MemberSignature Language="VB.NET" Value="Public Sub ThrowIfNotEmpty ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ThrowIfNotEmpty();" />
      <MemberSignature Language="F#" Value="member this.ThrowIfNotEmpty : unit -&gt; unit" Usage="asnReader.ThrowIfNotEmpty " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Löst einen standardisierten <see cref="T:System.Formats.Asn1.AsnContentException" /> aus, wenn der Reader über verbleibende Daten verfügt. Wenn <see cref="P:System.Formats.Asn1.AsnReader.HasData" /> <see langword="false" /> zurückgibt, wird keine Funktion ausgeführt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Diese Methode bietet ein standardisiertes Ziel und eine standardisierte Ausnahme zum Lesen einer "geschlossenen" Struktur, z. b. der für einen explizit markierten Wert.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReadBitString">
      <MemberSignature Language="C#" Value="public bool TryReadBitString (Span&lt;byte&gt; destination, out int unusedBitCount, out int bytesWritten, System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryReadBitString(valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; unusedBitCount, [out] int32&amp; bytesWritten, valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnReader.TryReadBitString(System.Span{System.Byte},System.Int32@,System.Int32@,System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Function TryReadBitString (destination As Span(Of Byte), ByRef unusedBitCount As Integer, ByRef bytesWritten As Integer, Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryReadBitString : Span&lt;byte&gt; * int * int * Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; bool" Usage="asnReader.TryReadBitString (destination, unusedBitCount, bytesWritten, expectedTag)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="unusedBitCount" Type="System.Int32" RefType="out" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" />
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="destination">Der Puffer, in den geschrieben werden soll.</param>
        <param name="unusedBitCount">Bei erfolgreichem Vorgang wird die Anzahl von Bits im letzten Byte empfangen, die vom Writer als „nicht verwendet“ gemeldet wurden.</param>
        <param name="bytesWritten">Empfängt bei Erfolg die Anzahl von Bytes, die in <paramref name="destination" /> geschrieben werden.</param>
        <param name="expectedTag">Das Tag, das vor dem Lesen überprüft werden soll, oder <see langword="null" /> für das Standardtag (Universal 1).</param>
        <summary>Liest den nächsten Wert als BIT STRING mit einem angegebenen Tag und kopiert den Wert in einen angegebenen Zielpuffer.</summary>
        <returns><see langword="true" /> und bewegt den Reader vorwärts, wenn <paramref name="destination" /> eine ausreichende Länge zum Empfangen des Werts hatte, andernfalls <see langword="false" />, und der Reader wird nicht vorwärtsbewegt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Formats.Asn1.AsnContentException">Der nächste Wert verfügt nicht über das korrekte Tag.
Oder die Längencodierung ist gemäß den aktuellen Codierungsregeln ungültig.
Oder der Inhalt ist gemäß den aktuellen Codierungsregeln ungültig.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> ist <see cref="F:System.Formats.Asn1.TagClass.Universal" />, aber <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> ist für die Methode nicht korrekt.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryReadCharacterString">
      <MemberSignature Language="C#" Value="public bool TryReadCharacterString (Span&lt;char&gt; destination, System.Formats.Asn1.UniversalTagNumber encodingType, out int charsWritten, System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryReadCharacterString(valuetype System.Span`1&lt;char&gt; destination, valuetype System.Formats.Asn1.UniversalTagNumber encodingType, [out] int32&amp; charsWritten, valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnReader.TryReadCharacterString(System.Span{System.Char},System.Formats.Asn1.UniversalTagNumber,System.Int32@,System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Function TryReadCharacterString (destination As Span(Of Char), encodingType As UniversalTagNumber, ByRef charsWritten As Integer, Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryReadCharacterString : Span&lt;char&gt; * System.Formats.Asn1.UniversalTagNumber * int * Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; bool" Usage="asnReader.TryReadCharacterString (destination, encodingType, charsWritten, expectedTag)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="encodingType" Type="System.Formats.Asn1.UniversalTagNumber" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" />
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="destination">Der Puffer, in den geschrieben werden soll.</param>
        <param name="encodingType">Einer der Enumerationswerte, der den zu verarbeitenden Werttyp darstellt.</param>
        <param name="charsWritten">Empfängt bei Erfolg die Anzahl von Zeichen, die in <paramref name="destination" /> geschrieben wurden.</param>
        <param name="expectedTag">Das Tag, das vor dem Lesen überprüft werden soll, oder <see langword="null" /> für das universelle Tag, das für den angeforderten Codierungstyp geeignet ist.</param>
        <summary>Liest den nächsten Wert als Zeichenfolge mit dem angegebenen Tag und Codierungstyp und kopiert den decodierten Wert in einen angegebenen Zielpuffer.</summary>
        <returns><see langword="true" /> und bewegt den Reader vorwärts, wenn <paramref name="destination" /> eine ausreichende Länge zum Empfangen des Werts hatte, andernfalls <see langword="false" />, und der Reader wird nicht vorwärtsbewegt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="encodingType" /> ist kein bekannter Zeichenfolgentyp.</exception>
        <exception cref="T:System.Formats.Asn1.AsnContentException">Der nächste Wert verfügt nicht über das korrekte Tag.
Oder die Längencodierung ist gemäß den aktuellen Codierungsregeln ungültig.
Oder der Inhalt ist gemäß den aktuellen Codierungsregeln ungültig.
Oder die Zeichenfolge konnte nicht erfolgreich decodiert werden.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> ist <see cref="F:System.Formats.Asn1.TagClass.Universal" />, aber <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> ist nicht identisch mit <paramref name="encodingType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryReadCharacterStringBytes">
      <MemberSignature Language="C#" Value="public bool TryReadCharacterStringBytes (Span&lt;byte&gt; destination, System.Formats.Asn1.Asn1Tag expectedTag, out int bytesWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryReadCharacterStringBytes(valuetype System.Span`1&lt;unsigned int8&gt; destination, valuetype System.Formats.Asn1.Asn1Tag expectedTag, [out] int32&amp; bytesWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnReader.TryReadCharacterStringBytes(System.Span{System.Byte},System.Formats.Asn1.Asn1Tag,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryReadCharacterStringBytes (destination As Span(Of Byte), expectedTag As Asn1Tag, ByRef bytesWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryReadCharacterStringBytes(Span&lt;System::Byte&gt; destination, System::Formats::Asn1::Asn1Tag expectedTag, [Runtime::InteropServices::Out] int % bytesWritten);" />
      <MemberSignature Language="F#" Value="member this.TryReadCharacterStringBytes : Span&lt;byte&gt; * System.Formats.Asn1.Asn1Tag * int -&gt; bool" Usage="asnReader.TryReadCharacterStringBytes (destination, expectedTag, bytesWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="expectedTag" Type="System.Formats.Asn1.Asn1Tag" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="destination">Der Puffer, in den geschrieben werden soll.</param>
        <param name="expectedTag">Das Tag, das vor dem Lesen überprüft werden soll.</param>
        <param name="bytesWritten">Empfängt bei Erfolg die Anzahl von Bytes, die in <paramref name="destination" /> geschrieben werden.</param>
        <summary>Liest den nächsten Wert als Zeichenfolge mit dem angegebenen Tag und kopiert die nicht verarbeiteten Bytes in einen angegebenen Zielpuffer.</summary>
        <returns><see langword="true" /> und bewegt den Reader vorwärts, wenn <paramref name="destination" /> eine ausreichende Länge zum Empfangen des Werts hatte, andernfalls <see langword="false" />, und der Reader wird nicht vorwärtsbewegt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Diese Methode bestimmt nicht, ob in der Zeichenfolge nur von der Codierung definierte Zeichen verwendet wurden.

          ]]></format>
        </remarks>
        <exception cref="T:System.Formats.Asn1.AsnContentException">Der nächste Wert verfügt nicht über das korrekte Tag.
Oder die Längencodierung ist gemäß den aktuellen Codierungsregeln ungültig.
Oder der Inhalt ist gemäß den aktuellen Codierungsregeln ungültig.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> ist <see cref="F:System.Formats.Asn1.TagClass.Universal" />, aber <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> ist kein Zeichenfolgen-Tagtyp.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryReadInt32">
      <MemberSignature Language="C#" Value="public bool TryReadInt32 (out int value, System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryReadInt32([out] int32&amp; value, valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnReader.TryReadInt32(System.Int32@,System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Function TryReadInt32 (ByRef value As Integer, Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryReadInt32 : int * Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; bool" Usage="asnReader.TryReadInt32 (value, expectedTag)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" RefType="out" />
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="value">Empfängt bei erfolgreichem Vorgang den decodierten Wert.</param>
        <param name="expectedTag">Das Tag, das vor dem Lesen überprüft werden soll, oder <see langword="null" /> für das Standardtag (Universal 2).</param>
        <summary>Versucht, den nächsten Wert als Ganzzahl mit einem angegebenen Tag zu lesen (32-Bit-Wert mit Vorzeichen).</summary>
        <returns><see langword="false" /> und bewegt den Reader nicht vorwärts, wenn der Wert nicht zwischen <see cref="F:System.Int32.MinValue" /> und <see cref="F:System.Int32.MaxValue" /> liegt. Anderenfalls wird <see langword="true" /> zurückgegeben, und der Reader wird vorwärtsbewegt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Formats.Asn1.AsnContentException">Der nächste Wert verfügt nicht über das korrekte Tag.
Oder die Längencodierung ist gemäß den aktuellen Codierungsregeln ungültig.
Oder der Inhalt ist gemäß den aktuellen Codierungsregeln ungültig.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> ist <see cref="F:System.Formats.Asn1.TagClass.Universal" />, aber <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> ist für die Methode nicht korrekt.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryReadInt64">
      <MemberSignature Language="C#" Value="public bool TryReadInt64 (out long value, System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryReadInt64([out] int64&amp; value, valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnReader.TryReadInt64(System.Int64@,System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Function TryReadInt64 (ByRef value As Long, Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryReadInt64 : int64 * Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; bool" Usage="asnReader.TryReadInt64 (value, expectedTag)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" RefType="out" />
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="value">Empfängt bei erfolgreichem Vorgang den decodierten Wert.</param>
        <param name="expectedTag">Das Tag, das vor dem Lesen überprüft werden soll, oder <see langword="null" /> für das Standardtag (Universal 2).</param>
        <summary>Versucht, den nächsten Wert als Ganzzahl mit einem angegebenen Tag zu lesen (64-Bit-Wert mit Vorzeichen).</summary>
        <returns><see langword="false" /> und bewegt den Reader nicht vorwärts, wenn der Wert nicht zwischen <see cref="F:System.Int64.MinValue" /> und <see cref="F:System.Int64.MaxValue" /> liegt. Anderenfalls wird <see langword="true" /> zurückgegeben, und der Reader wird vorwärtsbewegt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Formats.Asn1.AsnContentException">Der nächste Wert verfügt nicht über das korrekte Tag.
Oder die Längencodierung ist gemäß den aktuellen Codierungsregeln ungültig.
Oder der Inhalt ist gemäß den aktuellen Codierungsregeln ungültig.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> ist <see cref="F:System.Formats.Asn1.TagClass.Universal" />, aber <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> ist für die Methode nicht korrekt.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryReadOctetString">
      <MemberSignature Language="C#" Value="public bool TryReadOctetString (Span&lt;byte&gt; destination, out int bytesWritten, System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryReadOctetString(valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten, valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnReader.TryReadOctetString(System.Span{System.Byte},System.Int32@,System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Function TryReadOctetString (destination As Span(Of Byte), ByRef bytesWritten As Integer, Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryReadOctetString : Span&lt;byte&gt; * int * Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; bool" Usage="asnReader.TryReadOctetString (destination, bytesWritten, expectedTag)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" />
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="destination">Der Puffer, in den geschrieben werden soll.</param>
        <param name="bytesWritten">Empfängt bei Erfolg die Anzahl von Bytes, die in <paramref name="destination" /> geschrieben werden.</param>
        <param name="expectedTag">Das Tag, das vor dem Lesen überprüft werden soll, oder <see langword="null" /> für das Standardtag (Universal 4).</param>
        <summary>Liest den nächsten Wert als OCTET STRING mit einem angegebenen Tag und kopiert den Wert in einen angegebenen Zielpuffer.</summary>
        <returns><see langword="true" /> und bewegt den Reader vorwärts, wenn <paramref name="destination" /> eine ausreichende Länge zum Empfangen des Werts hatte, andernfalls <see langword="false" />, und der Reader wird nicht vorwärtsbewegt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Formats.Asn1.AsnContentException">Der nächste Wert verfügt nicht über das korrekte Tag.
Oder die Längencodierung ist gemäß den aktuellen Codierungsregeln ungültig.
Oder der Inhalt ist gemäß den aktuellen Codierungsregeln ungültig.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> ist <see cref="F:System.Formats.Asn1.TagClass.Universal" />, aber <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> ist für die Methode nicht korrekt.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryReadPrimitiveBitString">
      <MemberSignature Language="C#" Value="public bool TryReadPrimitiveBitString (out int unusedBitCount, out ReadOnlyMemory&lt;byte&gt; value, System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryReadPrimitiveBitString([out] int32&amp; unusedBitCount, [out] valuetype System.ReadOnlyMemory`1&lt;unsigned int8&gt;&amp; value, valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnReader.TryReadPrimitiveBitString(System.Int32@,System.ReadOnlyMemory{System.Byte}@,System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Function TryReadPrimitiveBitString (ByRef unusedBitCount As Integer, ByRef value As ReadOnlyMemory(Of Byte), Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryReadPrimitiveBitString : int * ReadOnlyMemory * Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; bool" Usage="asnReader.TryReadPrimitiveBitString (unusedBitCount, value, expectedTag)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unusedBitCount" Type="System.Int32" RefType="out" />
        <Parameter Name="value" Type="System.ReadOnlyMemory&lt;System.Byte&gt;" RefType="out" />
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="unusedBitCount">Bei erfolgreichem Vorgang wird die Anzahl von Bits im letzten Byte empfangen, die vom Writer als „nicht verwendet“ gemeldet wurden.</param>
        <param name="value">Bei erfolgreichem Vorgang wird ein <see cref="T:System.ReadOnlyMemory`1" />-Element für die ursprünglichen Daten empfangen, das dem Wert von BIT STRING entspricht.</param>
        <param name="expectedTag">Das Tag, das vor dem Lesen überprüft werden soll, oder <see langword="null" /> für das Standardtag (Universal 1).</param>
        <summary>Liest den nächsten Wert als BIT STRING mit einem angegebenen Tag und gibt die Inhalte als <see cref="T:System.ReadOnlyMemory`1" /> für die ursprünglichen Daten zurück.</summary>
        <returns><see langword="true" /> und bewegt den Reader vorwärts, wenn der BIT STRING-Wert eine primitive Codierung aufwies. <see langword="false" /> und bewegt den Reader nicht vorwärts, wenn der Wert eine konstruierte Codierung aufwies.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Formats.Asn1.AsnContentException">Der nächste Wert verfügt nicht über das korrekte Tag.
Oder die Längencodierung ist gemäß den aktuellen Codierungsregeln ungültig.
Oder der Inhalt ist gemäß den aktuellen Codierungsregeln ungültig.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> ist <see cref="F:System.Formats.Asn1.TagClass.Universal" />, aber <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> ist für die Methode nicht korrekt.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryReadPrimitiveCharacterStringBytes">
      <MemberSignature Language="C#" Value="public bool TryReadPrimitiveCharacterStringBytes (System.Formats.Asn1.Asn1Tag expectedTag, out ReadOnlyMemory&lt;byte&gt; contents);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryReadPrimitiveCharacterStringBytes(valuetype System.Formats.Asn1.Asn1Tag expectedTag, [out] valuetype System.ReadOnlyMemory`1&lt;unsigned int8&gt;&amp; contents) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnReader.TryReadPrimitiveCharacterStringBytes(System.Formats.Asn1.Asn1Tag,System.ReadOnlyMemory{System.Byte}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryReadPrimitiveCharacterStringBytes (expectedTag As Asn1Tag, ByRef contents As ReadOnlyMemory(Of Byte)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryReadPrimitiveCharacterStringBytes(System::Formats::Asn1::Asn1Tag expectedTag, [Runtime::InteropServices::Out] ReadOnlyMemory&lt;System::Byte&gt; % contents);" />
      <MemberSignature Language="F#" Value="member this.TryReadPrimitiveCharacterStringBytes : System.Formats.Asn1.Asn1Tag * ReadOnlyMemory -&gt; bool" Usage="asnReader.TryReadPrimitiveCharacterStringBytes (expectedTag, contents)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expectedTag" Type="System.Formats.Asn1.Asn1Tag" />
        <Parameter Name="contents" Type="System.ReadOnlyMemory&lt;System.Byte&gt;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="expectedTag">Das Tag, das vor dem Lesen überprüft werden soll.</param>
        <param name="contents">Bei erfolgreichem Vorgang wird ein <see cref="T:System.ReadOnlyMemory`1" />-Element für die ursprünglichen Daten empfangen, das dem Wert der Zeichenfolge entspricht.</param>
        <summary>Liest den nächsten Wert als Zeichen mit einem angegebenen Tag und gibt die Inhalte als nicht verarbeitetes <see cref="T:System.ReadOnlyMemory`1" />-Element für die ursprünglichen Daten zurück.</summary>
        <returns><see langword="true" /> und bewegt den Reader vorwärts, wenn der Zeichenfolgenwert eine primitive Codierung aufwies. <see langword="false" /> und bewegt den Reader nicht vorwärts, wenn der Wert eine konstruierte Codierung aufwies.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Diese Methode bestimmt nicht, ob in der Zeichenfolge nur von der Codierung definierte Zeichen verwendet wurden.

          ]]></format>
        </remarks>
        <exception cref="T:System.Formats.Asn1.AsnContentException">Der nächste Wert verfügt nicht über das korrekte Tag.
Oder die Längencodierung ist gemäß den aktuellen Codierungsregeln ungültig.
Oder der Inhalt ist gemäß den aktuellen Codierungsregeln ungültig.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> ist <see cref="F:System.Formats.Asn1.TagClass.Universal" />, aber <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> ist kein Zeichenfolgen-Tagtyp.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryReadPrimitiveOctetString">
      <MemberSignature Language="C#" Value="public bool TryReadPrimitiveOctetString (out ReadOnlyMemory&lt;byte&gt; contents, System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryReadPrimitiveOctetString([out] valuetype System.ReadOnlyMemory`1&lt;unsigned int8&gt;&amp; contents, valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnReader.TryReadPrimitiveOctetString(System.ReadOnlyMemory{System.Byte}@,System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Function TryReadPrimitiveOctetString (ByRef contents As ReadOnlyMemory(Of Byte), Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryReadPrimitiveOctetString : ReadOnlyMemory * Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; bool" Usage="asnReader.TryReadPrimitiveOctetString (contents, expectedTag)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="contents" Type="System.ReadOnlyMemory&lt;System.Byte&gt;" RefType="out" />
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="contents">Bei erfolgreichem Vorgang wird ein <see cref="T:System.ReadOnlyMemory`1" />-Element für die ursprünglichen Daten empfangen, das dem Wert von OCTET STRING entspricht.</param>
        <param name="expectedTag">Das Tag, das vor dem Lesen überprüft werden soll.</param>
        <summary>Versucht, den nächsten Wert als OCTET STRING mit einem angegebenen Tag zu lesen, und gibt die Inhalte als <see cref="T:System.ReadOnlyMemory`1" />-Element für die ursprünglichen Daten zurück.</summary>
        <returns><see langword="true" /> und bewegt den Reader vorwärts, wenn der OCTET STRING-Wert eine primitive Codierung aufwies. <see langword="false" /> und bewegt den Reader nicht vorwärts, wenn der Wert eine konstruierte Codierung aufwies.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Formats.Asn1.AsnContentException">Der nächste Wert verfügt nicht über das korrekte Tag.
Oder die Längencodierung ist gemäß den aktuellen Codierungsregeln ungültig.
Oder der Inhalt ist gemäß den aktuellen Codierungsregeln ungültig.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> ist <see cref="F:System.Formats.Asn1.TagClass.Universal" />, aber <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> ist für die Methode nicht korrekt.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryReadUInt32">
      <MemberSignature Language="C#" Value="public bool TryReadUInt32 (out uint value, System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryReadUInt32([out] unsigned int32&amp; value, valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnReader.TryReadUInt32(System.UInt32@,System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Function TryReadUInt32 (ByRef value As UInteger, Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryReadUInt32 : uint32 * Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; bool" Usage="asnReader.TryReadUInt32 (value, expectedTag)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" RefType="out" />
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="value">Empfängt bei erfolgreichem Vorgang den decodierten Wert.</param>
        <param name="expectedTag">Das Tag, das vor dem Lesen überprüft werden soll, oder <see langword="null" /> für das Standardtag (Universal 2).</param>
        <summary>Versucht, den nächsten Wert als Ganzzahl mit einem angegebenen Tag zu lesen (als 32-Bit-Wert ohne Vorzeichen).</summary>
        <returns><see langword="false" /> und bewegt den Reader nicht vorwärts, wenn der Wert nicht zwischen <see cref="F:System.UInt32.MinValue" /> und <see cref="F:System.UInt32.MaxValue" /> liegt. Anderenfalls wird <see langword="true" /> zurückgegeben, und der Reader wird vorwärtsbewegt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Formats.Asn1.AsnContentException">Der nächste Wert verfügt nicht über das korrekte Tag.
Oder die Längencodierung ist gemäß den aktuellen Codierungsregeln ungültig.
Oder der Inhalt ist gemäß den aktuellen Codierungsregeln ungültig.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> ist <see cref="F:System.Formats.Asn1.TagClass.Universal" />, aber <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> ist für die Methode nicht korrekt.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryReadUInt64">
      <MemberSignature Language="C#" Value="public bool TryReadUInt64 (out ulong value, System.Formats.Asn1.Asn1Tag? expectedTag = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryReadUInt64([out] unsigned int64&amp; value, valuetype System.Nullable`1&lt;valuetype System.Formats.Asn1.Asn1Tag&gt; expectedTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Formats.Asn1.AsnReader.TryReadUInt64(System.UInt64@,System.Nullable{System.Formats.Asn1.Asn1Tag})" />
      <MemberSignature Language="VB.NET" Value="Public Function TryReadUInt64 (ByRef value As ULong, Optional expectedTag As Nullable(Of Asn1Tag) = Nothing) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryReadUInt64 : uint64 * Nullable&lt;System.Formats.Asn1.Asn1Tag&gt; -&gt; bool" Usage="asnReader.TryReadUInt64 (value, expectedTag)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Formats.Asn1</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" RefType="out" />
        <Parameter Name="expectedTag" Type="System.Nullable&lt;System.Formats.Asn1.Asn1Tag&gt;" />
      </Parameters>
      <Docs>
        <param name="value">Empfängt bei erfolgreichem Vorgang den decodierten Wert.</param>
        <param name="expectedTag">Das Tag, das vor dem Lesen überprüft werden soll, oder <see langword="null" /> für das Standardtag (Universal 2).</param>
        <summary>Versucht, den nächsten Wert als Ganzzahl mit einem angegebenen Tag zu lesen (als 64-Bit-Wert ohne Vorzeichen).</summary>
        <returns><see langword="false" /> und bewegt den Reader nicht vorwärts, wenn der Wert nicht zwischen <see cref="F:System.UInt64.MinValue" /> und <see cref="F:System.UInt64.MaxValue" /> liegt. Anderenfalls wird <see langword="true" /> zurückgegeben, und der Reader wird vorwärtsbewegt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Formats.Asn1.AsnContentException">Der nächste Wert verfügt nicht über das korrekte Tag.
Oder die Längencodierung ist gemäß den aktuellen Codierungsregeln ungültig.
Oder der Inhalt ist gemäß den aktuellen Codierungsregeln ungültig.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagClass" /> ist <see cref="F:System.Formats.Asn1.TagClass.Universal" />, aber <paramref name="expectedTag" />.<see cref="P:System.Formats.Asn1.Asn1Tag.TagValue" /> ist für die Methode nicht korrekt.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
