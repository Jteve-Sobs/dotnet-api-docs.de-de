<Type Name="PersonalizationProvider" FullName="System.Web.UI.WebControls.WebParts.PersonalizationProvider">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="87e3ce07403879dd120bd456e456cdf4379dc99c" />
    <Meta Name="ms.sourcegitcommit" Value="16d2d159872fd213cae4b8f371d7ae9c8b027c89" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="11/17/2018" />
    <Meta Name="ms.locfileid" Value="51880660" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class PersonalizationProvider : System.Configuration.Provider.ProviderBase" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit PersonalizationProvider extends System.Configuration.Provider.ProviderBase" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.WebControls.WebParts.PersonalizationProvider" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class PersonalizationProvider&#xA;Inherits ProviderBase" />
  <TypeSignature Language="C++ CLI" Value="public ref class PersonalizationProvider abstract : System::Configuration::Provider::ProviderBase" />
  <TypeSignature Language="F#" Value="type PersonalizationProvider = class&#xA;    inherit ProviderBase" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Configuration.Provider.ProviderBase</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Implementiert die Basisfunktionalität für einen Personalisierungsanbieter.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist die abstrakte Basisklasse, die die erforderliche Funktionalität eines Personalisierungsanbieters definiert. Ein Personalisierungsanbieter lädt und speichert Personalisierungsdaten für eine <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization> Instanz.  
  
 Die Basisklasse der Klasse definiert das Standardverhalten für eine Reihe von Methoden. nur die Methoden, die speziell mit den zugrunde liegenden Datenspeicher arbeiten, werden als abstrakt markiert werden. Dies ermöglicht Entwicklern das Schreiben eines benutzerdefinierten Anbieters, um einen bestimmten Datenspeicher, interagieren, ohne ein, die Standardfunktionen erneut zu implementieren die <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization> Klasse.  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>Es sind ableitungen von <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationProvider" /> , und geben Sie Implementierungen für nur die abstrakten Methoden, die in dieser Klasse definiert. Die abstrakten Methoden geht es insbesondere beim Speichern und Laden von Daten in einem physischen Datenspeicher und Verwaltung von Datenspeichern. Ein benutzerdefinierter Anbieter muss zum Bearbeiten von Personalisierungsinformationen, die in einer Weise, mit dem unterschieden <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared" /> Daten aus <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.User" /> Daten. Darüber hinaus muss ein Anbieter Personalisierungsdaten per Seite oder Anwendung segmentieren.  
  
Implementierungen von <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationProvider" /> sind eng gekoppelt an Implementierungen von <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationState" /> da einige Methoden der Personalisierung Anbieter Instanzen zurückgeben <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationState" />-abgeleiteten Klassen. Zum Vereinfachen der Entwicklung von benutzerdefinierten Anbietern, die <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationProvider" /> Basisklasse enthält eine Standardimplementierung von die Personalisierung Logik und die Serialisierung/Deserialisierung-Logik, die direkt von verwendet wird, die <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" /> Klasse. Erstellen einen benutzerdefinierten Anbieter ausschließlich zum Zweck der Arbeit mit einem anderen Datenspeicher erfordert daher nur die Implementierung der folgenden abstrakten Methoden: 
-   <see cref="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.GetCountOfState(System.Web.UI.WebControls.WebParts.PersonalizationScope,System.Web.UI.WebControls.WebParts.PersonalizationStateQuery)" /> – Diese Methode muss die Anzahl der Zeilen der Personalisierungsdaten, die in der Datenbank für den angegebenen Abfrageparametern zählen können.  
  
-   <see cref="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.LoadPersonalizationBlobs(System.Web.UI.WebControls.WebParts.WebPartManager,System.String,System.String,System.Byte[]@,System.Byte[]@)" /> -Angegebenen Pfad und der Benutzer, diese Methode lädt zwei binary large Objects (BLOBs) aus der Datenbank: ein BLOB für gemeinsam genutzte Daten und eine für Benutzerdaten. Wenn Sie angeben, den Benutzernamen und ein Pfad, Sie müssen nicht die <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> Steuerelement auf die Seiteninformationen zugreifen, die die Benutzerinformationen von der Name bzw. Pfad bereitstellen können.  
  
-   <see cref="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ResetPersonalizationBlob(System.Web.UI.WebControls.WebParts.WebPartManager,System.String,System.String)" /> -Wenn der Pfad und den Benutzer angegeben ist, löscht diese Methode die entsprechende Zeile in der Datenbank. Wenn Sie angeben, den Benutzernamen und ein Pfad, Sie müssen nicht die <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> Steuerelement auf die Seiteninformationen zugreifen, die die Benutzerinformationen von der Name bzw. Pfad bereitstellen können.  
  
-   <see cref="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.SavePersonalizationBlob(System.Web.UI.WebControls.WebParts.WebPartManager,System.String,System.String,System.Byte[])" /> -Wenn der Pfad und den Benutzer-Name, speichert diese Methode das angegebene BLOB mit der Datenbank an. Wenn Sie angeben, den Benutzernamen und ein Pfad, Sie müssen nicht die <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> Steuerelement auf die Seiteninformationen zugreifen, die die Benutzerinformationen von der Name bzw. Pfad bereitstellen können.  
  
In allen der folgenden Methoden Wenn nur ein Pfad angegeben ist, bedeutet dies, dass der freigegebene Personalisierungsdaten für die Seite bei bearbeiteten. Wenn sowohl einen Pfad und einen Benutzernamen an eine Methode übergeben werden, sollte dann die Benutzerdaten für die Personalisierung für die Seite bearbeitet werden. Im Fall von <see cref="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.LoadPersonalizationBlobs(System.Web.UI.WebControls.WebParts.WebPartManager,System.String,System.String,System.Byte[]@,System.Byte[]@)" />, die freigegebenen Daten für den angegebenen Pfad müssen immer geladen werden und optional die Benutzerdaten für die Personalisierung für den Pfad auch geladen werden sollten der Benutzername ist nicht <see langword="null" />.  
  
Alle anderen abstrakten Methoden sind nur für administrative Anwendungen vorgesehen und werden nicht von der Webparts-Infrastruktur zur Laufzeit verwendet. Ein Beispiel für die Implementierung eines Personalisierungsanbieters, finden Sie unter den <see cref="T:System.Web.UI.WebControls.WebParts.SqlPersonalizationProvider" /> Klasse.</para>
    </block>
    <altmember cref="T:System.Web.UI.WebControls.WebParts.SqlPersonalizationProvider" />
    <related type="Article" href="https://msdn.microsoft.com/library/ab78a66e-9feb-4391-b3c3-8c07555e2308">ASP.NET Webparts-Seiten</related>
    <related type="Article" href="https://msdn.microsoft.com/library/7dc34f74-52aa-4082-b98d-2bcf9e07e320">Übersicht über Webserver Webparts-Personalisierung</related>
    <related type="Article" href="https://msdn.microsoft.com/library/a88d2bd5-4932-4ec1-b176-7d7da45f85d9">Exemplarische Vorgehensweise: Implementieren von Webparts-Personalisierung mit einem Benutzersteuerelement</related>
    <related type="Article" href="https://msdn.microsoft.com/library/7885563f-7bbe-45a0-b5e2-c6bf1bc2deaa">Webparts-Personalisierung</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected PersonalizationProvider ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; PersonalizationProvider();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationProvider" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Da es sich um einen Konstruktor für eine abstrakte Klasse handelt, müssen Sie überschreiben diese Methode, um eine Instanz einer Klasse zu erstellen, die von dieser Klasse erbt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationName">
      <MemberSignature Language="C#" Value="public abstract string ApplicationName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ApplicationName" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ApplicationName" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Property ApplicationName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ ApplicationName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationName : string with get, set" Usage="System.Web.UI.WebControls.WebParts.PersonalizationProvider.ApplicationName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namen der für den Anbieter konfigurierten Anwendung ab bzw. legt ihn fest, wenn der Name in einer abgeleiteten Klasse überschrieben wird.</summary>
        <value>Die für den Personalisierungsanbieter konfigurierte Anwendung.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein Anwendungsname nicht, in der Konfiguration mithilfe angegeben ist der [Providers-Element für Personalization für WebParts ((ASP.NET Einstellungsschema)](https://msdn.microsoft.com/library/51363b49-eafa-4b9c-b9d0-80086b385195) Attribut den Wert des der <xref:System.Web.Hosting.HostingEnvironment.ApplicationVirtualPath%2A> Eigenschaft wird verwendet.  
  
> [!CAUTION]
>  Da für alle Anforderungen verarbeitet, indem Sie eine einzelne Standardinstanz Personalisierung-Anbieter verwendet wird ein <xref:System.Web.HttpApplication> -Objekt können mehrere Anforderungen gleichzeitig ausgeführt wird, jede beim Festlegen der <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ApplicationName%2A> -Eigenschaftswert. Die <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ApplicationName%2A> -Eigenschaft ist für mehrere Schreibvorgänge nicht threadsicher und Ändern der <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ApplicationName%2A> Eigenschaftswert kann zu unerwartetem Verhalten für mehrere Benutzer einer Anwendung führen. Es wird empfohlen, dass Sie keinen Code ermöglicht Benutzern das Festlegen der <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ApplicationName%2A> Eigenschaft erforderlich. Festlegen der <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ApplicationName%2A> Eigenschaft ist möglicherweise erforderlich, z. B. in einer administrativen Anwendung, die Personalisierungsdaten für mehrere Anwendungen verwaltet.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateSupportedUserCapabilities">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.IList CreateSupportedUserCapabilities ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.IList CreateSupportedUserCapabilities() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.CreateSupportedUserCapabilities" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateSupportedUserCapabilities () As IList" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::IList ^ CreateSupportedUserCapabilities();" />
      <MemberSignature Language="F#" Value="abstract member CreateSupportedUserCapabilities : unit -&gt; System.Collections.IList&#xA;override this.CreateSupportedUserCapabilities : unit -&gt; System.Collections.IList" Usage="personalizationProvider.CreateSupportedUserCapabilities " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine Liste von <see cref="T:System.Web.UI.WebControls.WebParts.WebPartUserCapability" />-Objekten zurück, die die vom Webparts-Steuerelementsatz verwendeten bekannten Funktionen darstellen.</summary>
        <returns>Eine <see cref="T:System.Collections.IList" />, die die vom Webparts-Steuerelementsatz verwendeten bekannten Funktionen darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Derzeit gibt diese Methode eine Liste mit zwei Funktionen: <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.EnterSharedScopeUserCapability> und <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ModifyStateUserCapability>. Hierbei handelt es sich um die Standardfunktionen, die in definiert werden, können die [Authorization-Element für Personalization für WebParts ((ASP.NET Einstellungsschema)](https://msdn.microsoft.com/library/d190d4ff-1445-4ee1-88eb-9737c7aa1434) Element innerhalb der [Personalization-Element für WebParts (ASP.NET Schema für Laufzeiteinstellungen)](https://msdn.microsoft.com/library/3d77da55-73ce-46ce-97cf-7d2abcaada09) Element der [WebParts-Element ((ASP.NET Einstellungsschema)](https://msdn.microsoft.com/library/90af5acc-5a80-4b39-bba7-74afd06b167c) Konfigurationsabschnitt. Wenn Sie eine benutzerdefinierte Personalisierungsinfrastruktur implementieren möchten, können Sie diese Methode überschreiben, und definieren Ihren eigenen Satz von Autorisierung bezogene Benutzeroptionen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DetermineInitialScope">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.PersonalizationScope DetermineInitialScope (System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, System.Web.UI.WebControls.WebParts.PersonalizationState loadedState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Web.UI.WebControls.WebParts.PersonalizationScope DetermineInitialScope(class System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, class System.Web.UI.WebControls.WebParts.PersonalizationState loadedState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.DetermineInitialScope(System.Web.UI.WebControls.WebParts.WebPartManager,System.Web.UI.WebControls.WebParts.PersonalizationState)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::PersonalizationScope DetermineInitialScope(System::Web::UI::WebControls::WebParts::WebPartManager ^ webPartManager, System::Web::UI::WebControls::WebParts::PersonalizationState ^ loadedState);" />
      <MemberSignature Language="F#" Value="abstract member DetermineInitialScope : System.Web.UI.WebControls.WebParts.WebPartManager * System.Web.UI.WebControls.WebParts.PersonalizationState -&gt; System.Web.UI.WebControls.WebParts.PersonalizationScope&#xA;override this.DetermineInitialScope : System.Web.UI.WebControls.WebParts.WebPartManager * System.Web.UI.WebControls.WebParts.PersonalizationState -&gt; System.Web.UI.WebControls.WebParts.PersonalizationScope" Usage="personalizationProvider.DetermineInitialScope (webPartManager, loadedState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.PersonalizationScope</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartManager" Type="System.Web.UI.WebControls.WebParts.WebPartManager" />
        <Parameter Name="loadedState" Type="System.Web.UI.WebControls.WebParts.PersonalizationState" />
      </Parameters>
      <Docs>
        <param name="webPartManager">Der <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />, der die Personalisierungsinformationen verwaltet.</param>
        <param name="loadedState">Die Personalisierungszustandsinformationen.</param>
        <summary>Bestimmt, ob der ursprüngliche Personalisierungsbereich der <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared" />-Bereich oder der <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.User" />-Bereich sein soll.</summary>
        <returns>Ein <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationScope" />, der angibt, ob der aktuelle Personalisierungsbereich <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.User" /> oder <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared" /> ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode bestimmt, ob der aktuelle Bereich <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> oder <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>, wenn ein Verweis auf eine <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Kontrolle und die Personalisierung der Zustandsinformationen, die vom bereits weiter oben in den Lebenszyklus der Personalisierung geladen wurde. Diese Informationen werden verwendet, indem eine <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization> Instanz für nachfolgende Personalisierung-bezogene Aufgaben.  
  
 Die folgenden Regeln werden verwendet, um zu bestimmen, Personalisierungsbereich:  
  
-   Bereich wird als ursprünglich <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>.  
  
-   Wenn die aktuell ausgeführte Benutzerkonto nicht authentifiziert ist, ist der Gültigkeitsbereich auf festgelegt <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>.  
  
-   Wenn die aktuell ausgeführte Benutzerkonto authentifiziert wurde, wird eine zusätzliche Verarbeitung in der Rangfolge:  
  
    -   Wenn die Seite im postback-Modus befindet, enthält die Seitenanforderung Bereichsinformationen aus einer vorherigen Darstellung der Seite. Wenn diese Bereichsinformationen angibt, dass <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> Bereich wurde verwendet, und klicken Sie dann der Bereich ergibt <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>.  
  
    -   Hätte die aktuell ausgeführte Seite Steuerelement, von einer anderen Seite übertragen (z. B., wenn die Übertragung der Steuerung aufgrund von Aufrufen aufgetreten ist die <xref:System.Web.HttpServerUtility.Transfer%2A> Methode; Beachten Sie, dass diese bestimmten Prüfung nicht für seitenübergreifendes Senden auftritt), und wenn die zuvor Ausführen von Seite hatte eine <xref:System.Web.UI.WebControls.WebParts.WebPartManager> -Instanz, auf den Wert der Bereich festgelegt ist die `Personalization.Scope` Eigenschaft aus dem vorherigen <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Instanz.  
  
    -   Wenn die zuvor angegebenen Kriterien nicht erfüllt, und klicken Sie dann der Bereich den Wert des ergibt der <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.InitialScope%2A> -Eigenschaft für die aktuelle <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Steuerelement.  
  
 Nachdem die auswertungen früheren vorgenommen wurden, und ergibt der Bereich <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> beschränken, die folgende Vorgänge ausgeführt:  
  
-   Wenn die aktuell ausgeführte Benutzerkonto verfügt die <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.EnterSharedScopeUserCapability> -Funktion der Bereich bleibt festgelegt, um <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>.  
  
-   Wenn der aktuell ausgeführten Benutzerkontos keinen der <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.EnterSharedScopeUserCapability> -Funktion, und klicken Sie dann auf den Bereich auf zurückgesetzt <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>.  
  
-   Wenn das Ergebnis der alle vorherigen Bereich Bewertungen <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>, dieses Ergebnis wird als ausgeblendetes Feld auf der derzeit ausgeführte Seite gespeichert. Dies ist der Mechanismus, bei dem die Bereich Auswertung bei nachfolgenden Postbacks der von eine Seite wiedergegeben werden können.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPartManager" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die dem <paramref name="webPartManager" /> zugeordnete Seite ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DetermineUserCapabilities">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IDictionary DetermineUserCapabilities (System.Web.UI.WebControls.WebParts.WebPartManager webPartManager);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IDictionary DetermineUserCapabilities(class System.Web.UI.WebControls.WebParts.WebPartManager webPartManager) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.DetermineUserCapabilities(System.Web.UI.WebControls.WebParts.WebPartManager)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IDictionary ^ DetermineUserCapabilities(System::Web::UI::WebControls::WebParts::WebPartManager ^ webPartManager);" />
      <MemberSignature Language="F#" Value="abstract member DetermineUserCapabilities : System.Web.UI.WebControls.WebParts.WebPartManager -&gt; System.Collections.IDictionary&#xA;override this.DetermineUserCapabilities : System.Web.UI.WebControls.WebParts.WebPartManager -&gt; System.Collections.IDictionary" Usage="personalizationProvider.DetermineUserCapabilities webPartManager" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartManager" Type="System.Web.UI.WebControls.WebParts.WebPartManager" />
      </Parameters>
      <Docs>
        <param name="webPartManager">Der <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />, der die Personalisierungsinformationen verwaltet.</param>
        <summary>Gibt ein Wörterbuch mit <see cref="T:System.Web.UI.WebControls.WebParts.WebPartUserCapability" />-Instanzen zurück, die die personalisierungsbezogenen Funktionen des aktuell ausgeführten Benutzerkontos darstellen.</summary>
        <returns>Ein <see cref="T:System.Collections.IDictionary" />, das 0 oder mehr <see cref="T:System.Web.UI.WebControls.WebParts.WebPartUserCapability" />-Instanzen enthält, wenn das Benutzerkonto authentifiziert wird, oder <see langword="null" /> ist, wenn das aktuell ausgeführte Benutzerkonto nicht authentifiziert wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standardimplementierung dieser Methode nutzt die Informationen in den [Authorization-Element für Personalization für WebParts ((ASP.NET Einstellungsschema)](https://msdn.microsoft.com/library/d190d4ff-1445-4ee1-88eb-9737c7aa1434) Element innerhalb der [Personalization-Element für WebParts ((ASP.NET Einstellungsschema)](https://msdn.microsoft.com/library/3d77da55-73ce-46ce-97cf-7d2abcaada09) Element der [WebParts-Element ((ASP.NET Einstellungsschema)](https://msdn.microsoft.com/library/90af5acc-5a80-4b39-bba7-74afd06b167c) Konfigurationsabschnitt in der Datei "Machine.config" oder "Web.config", um zu bestimmen, einen Benutzer die Funktionen autorisiert.  
  
 Die Funktionen im Wörterbuch werden Mitglieder der der <xref:System.Collections.IList> zurückgegebenes Objekt der <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.CreateSupportedUserCapabilities%2A> Methode, die zurzeit die <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.EnterSharedScopeUserCapability> Funktion und die <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ModifyStateUserCapability> Funktion.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die dem <paramref name="webPartManager" /> zugeordnete Seite ist <see langword="null" />.  
  
\- oder – 
Die der Seite zugeordnete Anforderung ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPartManager" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FindState">
      <MemberSignature Language="C#" Value="public abstract System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection FindState (System.Web.UI.WebControls.WebParts.PersonalizationScope scope, System.Web.UI.WebControls.WebParts.PersonalizationStateQuery query, int pageIndex, int pageSize, out int totalRecords);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection FindState(valuetype System.Web.UI.WebControls.WebParts.PersonalizationScope scope, class System.Web.UI.WebControls.WebParts.PersonalizationStateQuery query, int32 pageIndex, int32 pageSize, [out] int32&amp; totalRecords) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.FindState(System.Web.UI.WebControls.WebParts.PersonalizationScope,System.Web.UI.WebControls.WebParts.PersonalizationStateQuery,System.Int32,System.Int32,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function FindState (scope As PersonalizationScope, query As PersonalizationStateQuery, pageIndex As Integer, pageSize As Integer, ByRef totalRecords As Integer) As PersonalizationStateInfoCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Web::UI::WebControls::WebParts::PersonalizationStateInfoCollection ^ FindState(System::Web::UI::WebControls::WebParts::PersonalizationScope scope, System::Web::UI::WebControls::WebParts::PersonalizationStateQuery ^ query, int pageIndex, int pageSize, [Runtime::InteropServices::Out] int % totalRecords);" />
      <MemberSignature Language="F#" Value="abstract member FindState : System.Web.UI.WebControls.WebParts.PersonalizationScope * System.Web.UI.WebControls.WebParts.PersonalizationStateQuery * int * int *  -&gt; System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection" Usage="personalizationProvider.FindState (scope, query, pageIndex, pageSize, totalRecords)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scope" Type="System.Web.UI.WebControls.WebParts.PersonalizationScope" />
        <Parameter Name="query" Type="System.Web.UI.WebControls.WebParts.PersonalizationStateQuery" />
        <Parameter Name="pageIndex" Type="System.Int32" />
        <Parameter Name="pageSize" Type="System.Int32" />
        <Parameter Name="totalRecords" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="scope">Ein <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationScope" /> mit den Personalisierungsinformationen, die abgefragt werden sollen. Dieser Wert darf nicht <see langword="null" /> sein.</param>
        <param name="query">Eine <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery" />, die eine Abfrage enthält. Dieser Wert kann <see langword="null" /> sein.</param>
        <param name="pageIndex">Die Position, an der die Abfrage gestartet wird.</param>
        <param name="pageSize">Die Anzahl der zurückzugebenden Datensätze.</param>
        <param name="totalRecords">Die Gesamtzahl der verfügbaren Datensätze.</param>
        <summary>Wenn in einer abgeleiteten Klasse überschrieben, wird basierend auf dem angegebenen Bereich und den angegebenen Parametern eine Auflistung mit 0 oder mehr von <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo" /> abgeleiteten Objekten zurückgegeben.</summary>
        <returns>Eine <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection" /> mit 0 oder mehr von <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo" /> abgeleiteten Objekten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist die abstrakte Definition einer Verwaltungsmethode zum Abfragen von Personalisierungsdaten. Abgeleitete Implementierungen sollten die unten beschriebene Logik folgen.  
  
 Ist der Satz der zurückgegebenen Elemente durch beschränkt die `pageIndex` und `pageSize` Parameter, in denen `pageSize` legt die Anzahl der zurückzugebenden Datensätze und `pageIndex` legt sie fest welche Datensätze zurückgegeben. Z. B. eine `pageIndex` 0 und einem `pageSize` von 25 würden die ersten 25 Vorkommen zurück, während eine `pageIndex` 1 und ein `pageSize` von 25 Vorkommen 26 bis 50 zurück. Wenn Sie alle verfügbaren Datensätze abrufen möchten, legen Sie `pageIndex` auf 0 und `pageSize` zu <xref:System.Int32.MaxValue>.  
  
 Die <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo>-abgeleiteten Objekte in alphabetischer Reihenfolge zurückgegeben werden, und durch eine Kombination von sortiert ihre <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo.Path%2A> und <xref:System.Web.UI.WebControls.WebParts.UserPersonalizationStateInfo.Username%2A> Standardwerte für die Eigenschaft, in aufsteigender Reihenfolge.  
  
 Diese Methode übergibt Platzhalterzeichen für die Abfrage an den zugrunde liegenden Datenspeicher. Unterstützung für Platzhalterzeichen ist derzeit an der Behandlung von Zeichen wie z. B. ein Sternchen (*), ein Prozentzeichen (%) oder einem Unterstrich (_) in jeder Anbieter abhängig.  
  
 In der Regel SQL-kompatiblen Datenspeichern, führen Sie eine Platzhaltersuche in einem partiellen Pfad mit dem Platzhalterzeichen, die angezeigt werden, am Anfang, Ende oder die Mitte des Texts der Suchzeichenfolge in die <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A> Eigenschaft. Um beispielsweise alle Pfade zu finden, die mit "~/vdir", beginnen die <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A> Eigenschaft auf "~/vdir%" fest.  
  
 Ebenso möglicherweise eine Platzhaltersuche auf einen Teil eines Benutzernamens das Platzhalterzeichen zu einem beliebigen Zeitpunkt in der Textzeichenfolge, die von der <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A> Eigenschaft. Um beispielsweise alle Benutzernamen, die beginnen mit "John", suchen die <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A> Parameter sieht "John %".  
  
 Die folgende Abfrage Einschränkungen gelten:  
  
-   Wenn nur `scope` angegeben ist, und `query` ist `null` oder alle Eigenschaften auf `query` zurückgeben `null` oder Standardwerte, und klicken Sie dann alle Datensätze, die mit dem angegebenen `scope` Parameter zurückgegeben werden.  
  
-   Wenn die <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A> Eigenschaft ist nicht `null`, die zurückgegebenen Datensätze werden auch basierend auf Pfade gefiltert, die entsprechen den <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A> Wert.  
  
-   Wenn die <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A> Eigenschaft ist nicht `null`, die zurückgegebenen Datensätze werden auch gefilterte basierend auf dem Namen, die entsprechen der <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A> -Eigenschaftswert.  
  
-   Wenn die <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UserInactiveSinceDate%2A> Eigenschaft ist nicht gleich <xref:System.DateTime.MaxValue>, und klicken Sie dann die zurückgegebenen Datensätze auch gefiltert werden, um nur die inaktiven Benutzern zugeordnet Datensätze zurückzugeben. Der Vergleich enthält Datensätze, in denen die <xref:System.Web.UI.WebControls.WebParts.UserPersonalizationStateInfo.LastActivityDate%2A> -Eigenschaft ist kleiner als oder gleich der <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UserInactiveSinceDate%2A> Eigenschaft.  
  
 Beachten Sie, dass diese Methode nicht Kombinationen von Abfrageparametern überprüft. Code kann z. B. einen Satz von benutzerspezifische Zustand Datensätze, die einen bestimmten Benutzernamen im freigegebenen Bereich zugeordneten anfordern. Da Benutzernamen nicht freigegebene Informationen zugeordnet sind, wird die zurückgegebene Auflistung leer sein.  
  
 Parameterkombinationen, bei denen eine nicht leere Auflistung zurückgeben enthalten:  
  
-   <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> Bereich, in Kombination mit der <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A> Eigenschaft.  
  
-   <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User> Bereich, in Kombination mit den Werten für einige oder alle der <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A>, <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A>, und <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UserInactiveSinceDate%2A> Eigenschaften.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCountOfState">
      <MemberSignature Language="C#" Value="public abstract int GetCountOfState (System.Web.UI.WebControls.WebParts.PersonalizationScope scope, System.Web.UI.WebControls.WebParts.PersonalizationStateQuery query);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCountOfState(valuetype System.Web.UI.WebControls.WebParts.PersonalizationScope scope, class System.Web.UI.WebControls.WebParts.PersonalizationStateQuery query) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.GetCountOfState(System.Web.UI.WebControls.WebParts.PersonalizationScope,System.Web.UI.WebControls.WebParts.PersonalizationStateQuery)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetCountOfState (scope As PersonalizationScope, query As PersonalizationStateQuery) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetCountOfState(System::Web::UI::WebControls::WebParts::PersonalizationScope scope, System::Web::UI::WebControls::WebParts::PersonalizationStateQuery ^ query);" />
      <MemberSignature Language="F#" Value="abstract member GetCountOfState : System.Web.UI.WebControls.WebParts.PersonalizationScope * System.Web.UI.WebControls.WebParts.PersonalizationStateQuery -&gt; int" Usage="personalizationProvider.GetCountOfState (scope, query)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scope" Type="System.Web.UI.WebControls.WebParts.PersonalizationScope" />
        <Parameter Name="query" Type="System.Web.UI.WebControls.WebParts.PersonalizationStateQuery" />
      </Parameters>
      <Docs>
        <param name="scope">Ein <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationScope" /> der Personalisierungsinformationen, die abgefragt werden sollen. Dieser Wert darf nicht <see langword="null" /> sein.</param>
        <param name="query">Eine <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery" />, die eine Abfrage enthält. Dieser Wert kann <see langword="null" /> sein.</param>
        <summary>Wenn in einer abgeleiteten Klasse überschrieben, wird die Anzahl der Zeilen im zugrunde liegenden Datenspeicher zurückgegeben, die innerhalb des angegebenen Bereichs vorhanden sind.</summary>
        <returns>Die Anzahl der Zeilen im zugrunde liegenden Datenspeicher, die für den angegebenen <paramref name="scope" />-Parameter vorhanden sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist die abstrakte Definition einer Verwaltungsmethode für das Abrufen von Anzahlen von Personalisierungsdaten. Abgeleitete Implementierungen sollten die unten beschriebene Logik folgen.  
  
 Diese Methode übergibt Platzhalterzeichen für die Abfrage an den zugrunde liegenden Datenspeicher. Unterstützung für Platzhalterzeichen ist derzeit an der Behandlung von Zeichen wie z. B. ein Sternchen (*), ein Prozentzeichen (%) oder einem Unterstrich (_) in jeder Anbieter abhängig.  
  
 In der Regel SQL-kompatiblen Datenspeichern, führen Sie eine Platzhaltersuche in einem partiellen Pfad mit dem Platzhalterzeichen, die angezeigt werden, am Anfang, Ende oder die Mitte des Texts der Suchzeichenfolge in die <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A> Eigenschaft. Um beispielsweise alle Pfade zu finden, die mit "~/vdir", beginnen die <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A> Eigenschaft auf "~/vdir%" fest.  
  
 Ebenso möglicherweise eine Platzhaltersuche auf einen Teil eines Benutzernamens das Platzhalterzeichen zu einem beliebigen Zeitpunkt in der Textzeichenfolge, die von der <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A> Eigenschaft. Um beispielsweise alle Benutzernamen, die beginnen mit "John", suchen die <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A> Parameter sieht "John %".  
  
 Die folgende Abfrage Einschränkungen gelten:  
  
-   Wenn nur `scope` angegeben ist, und `query` ist `null` oder alle Eigenschaften auf `query` zurückgeben `null` oder Standardwerte, und klicken Sie dann alle Datensätze, die mit dem angegebenen `scope` Parameter werden gezählt.  
  
-   Wenn die <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A> Eigenschaft ist nicht `null`, die gezählten Datensätze sind auch gefilterte basierend auf Pfade, die <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A> Wert.  
  
-   Wenn die <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A> Eigenschaft ist nicht `null`, die gezählten Datensätze werden auch gefilterte basierend auf dem Namen, die entsprechen den <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A> -Eigenschaftswert.  
  
-   Wenn die <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UserInactiveSinceDate%2A> Eigenschaft ist nicht gleich <xref:System.DateTime.MaxValue>, die gezählten Datensätze ebenfalls gefiltert, um nur die inaktiven Benutzern zugeordnet Datensätze zurückzugeben. Der Vergleich enthält Datensätze, in denen die <xref:System.Web.UI.WebControls.WebParts.UserPersonalizationStateInfo.LastActivityDate%2A> -Eigenschaft ist kleiner als oder gleich der <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UserInactiveSinceDate%2A> Eigenschaft.  
  
 Beachten Sie, dass diese Methode nicht Kombinationen von Abfrageparametern überprüft. Code kann z. B. Anzahl der Datensätze zum clientbereitstellungsstatus Personalisierung mit einem bestimmten Benutzernamen im freigegebenen Bereich verknüpften anfordern. Da Benutzernamen nicht freigegebene Informationen zugeordnet sind, wäre die zurückgegebene Anzahl 0 (null).  
  
 Folgende Parameterkombinationen, bei denen eine Anzahl nicht 0 (null) zurück:  
  
-   <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> Bereich, in Kombination mit der <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A> Eigenschaft.  
  
-   <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User> Bereich, in Kombination mit den Werten für einige oder alle der <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A>, <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A>, und <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UserInactiveSinceDate%2A> Eigenschaften.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadPersonalizationBlobs">
      <MemberSignature Language="C#" Value="protected abstract void LoadPersonalizationBlobs (System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, string path, string userName, ref byte[] sharedDataBlob, ref byte[] userDataBlob);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void LoadPersonalizationBlobs(class System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, string path, string userName, unsigned int8[]&amp; sharedDataBlob, unsigned int8[]&amp; userDataBlob) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.LoadPersonalizationBlobs(System.Web.UI.WebControls.WebParts.WebPartManager,System.String,System.String,System.Byte[]@,System.Byte[]@)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void LoadPersonalizationBlobs(System::Web::UI::WebControls::WebParts::WebPartManager ^ webPartManager, System::String ^ path, System::String ^ userName, cli::array &lt;System::Byte&gt; ^ % sharedDataBlob, cli::array &lt;System::Byte&gt; ^ % userDataBlob);" />
      <MemberSignature Language="F#" Value="abstract member LoadPersonalizationBlobs : System.Web.UI.WebControls.WebParts.WebPartManager * string * string *  *  -&gt; unit" Usage="personalizationProvider.LoadPersonalizationBlobs (webPartManager, path, userName, sharedDataBlob, userDataBlob)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartManager" Type="System.Web.UI.WebControls.WebParts.WebPartManager" />
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="sharedDataBlob" Type="System.Byte[]" RefType="ref" />
        <Parameter Name="userDataBlob" Type="System.Byte[]" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="webPartManager">Der <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />, der die Personalisierungsdaten verwaltet.</param>
        <param name="path">Der Pfad für Personalisierungsinformationen, der als Abrufschlüssel verwendet werden soll.</param>
        <param name="userName">Der Benutzername für Personalisierungsinformationen, der als Abrufschlüssel verwendet werden soll.</param>
        <param name="sharedDataBlob">Die zurückgegebenen Daten für den <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared" />-Bereich.</param>
        <param name="userDataBlob">Die zurückgegebenen Daten für den <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.User" />-Bereich.</param>
        <summary>Wenn in einer abgeleiteten Klasse überschrieben, werden Personalisierungsrohdaten aus dem zugrunde liegenden Datenspeicher geladen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Abgeleitete Klassen <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider> und diese Methode implementieren, sollten die `webPartManager`, `path`, und `username` Parameter als Abrufschlüssel. Unabhängig davon, wie die Daten sind gespeichert in den Datenspeicher (einigen Datenspeichern möglicherweise eine Art von intelligenten Speicher ausführen), die Personalisierung, die Daten zurückgegeben werden müssen, wie eine gepackte Gruppe von Bytes in zwei Arrays. Die zurückgegebenen Daten müssen die folgenden Regeln entsprechen:  
  
-   Die Daten für die <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> Bereich muss immer zurückgegeben werden, der `sharedDataBlob` Parameter.  
  
-   Abhängig von den Schlüsselwerten <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User> Daten werden zurückgegeben, der `userDataBlob` Parameter. Nicht`null` Wert für die `userName` Parameter gibt an, dass <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User> Daten auch abgerufen werden soll.  
  
 Einen Personalisierungsanbieter, die von abgeleitet <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider> und implementiert diese Methode kann optimieren, Interaktionen mit dem Datenspeicher alle Personalisierungsdaten in einer Schleife, im Gegensatz zum Abrufen von <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> und <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User> Daten in zwei Trennen Sie die Anzahl der Roundtrips.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadPersonalizationState">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.PersonalizationState LoadPersonalizationState (System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, bool ignoreCurrentUser);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.PersonalizationState LoadPersonalizationState(class System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, bool ignoreCurrentUser) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.LoadPersonalizationState(System.Web.UI.WebControls.WebParts.WebPartManager,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::PersonalizationState ^ LoadPersonalizationState(System::Web::UI::WebControls::WebParts::WebPartManager ^ webPartManager, bool ignoreCurrentUser);" />
      <MemberSignature Language="F#" Value="abstract member LoadPersonalizationState : System.Web.UI.WebControls.WebParts.WebPartManager * bool -&gt; System.Web.UI.WebControls.WebParts.PersonalizationState&#xA;override this.LoadPersonalizationState : System.Web.UI.WebControls.WebParts.WebPartManager * bool -&gt; System.Web.UI.WebControls.WebParts.PersonalizationState" Usage="personalizationProvider.LoadPersonalizationState (webPartManager, ignoreCurrentUser)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.PersonalizationState</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartManager" Type="System.Web.UI.WebControls.WebParts.WebPartManager" />
        <Parameter Name="ignoreCurrentUser" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="webPartManager">Der <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />, der die Personalisierungsdaten verwaltet.</param>
        <param name="ignoreCurrentUser">Ein <see cref="T:System.Boolean" />, der angibt, ob der Benutzername an den Personalisierungsanbieter übergeben werden soll.</param>
        <summary>Lädt die Rohdaten aus dem zugrunde liegenden Datenspeicher und konvertiert diese Daten in ein <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationState" />-Objekt.</summary>
        <returns>Ein <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationState" />, der Personalisierungsdaten enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist der Haupteinstiegspunkt, ein, die die <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization> Klasse Personalisierungsdaten geladen. Die Standardimplementierung lädt die Rohdaten aus dem zugrunde liegenden Datenspeicher (Funktionalität ist in der abgeleiteten Anbieter implementiert) und konvertiert dann die Rohdaten in eine <xref:System.Web.UI.WebControls.WebParts.PersonalizationState> Instanz.  
  
 Wenn die `ignoreCurrentUser` Parameter `true`, kein Benutzername wird zum Übergeben der <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.LoadPersonalizationBlobs%2A> Methode. Ein Personalisierungsanbieter können dies ggf. so auslegen, nur ein Personalisierungszustand mit einem <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> Bereich aus dem zugrunde liegenden Datenspeicher abgerufen werden soll.  
  
 Wenn die <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.Load%2A> Methode ausgeführt wird, ruft es die <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.LoadPersonalizationState%2A> -Methode, und es gibt drei Arten von Deserialisierungsfehler, die auftreten können, wie der Zustand geladen wird. Wenn dieser Fehler auftreten, keine Ausnahme ausgelöst wird und die Fehlerereignisse werden stattdessen durch das Überwachen der Sicherheitsintegrität Feature protokolliert (Informationen zur Integrität überwachen und Zugriff auf die Protokolle, die erstellt werden, finden Sie unter [ASP.NET Health Monitoring Overview ](https://msdn.microsoft.com/library/e003f224-70fe-4cd8-a71a-2dc81e2d7e4c)). Die folgenden drei Szenarien Ursache Deserialisierung Fehlerereignisse in das Protokoll geschrieben werden:  
  
-   Einen fehlgeschlagenen Versuch, einen Eigenschaftentyp zu deserialisieren, eine Zeichenfolge verwendet <xref:System.ComponentModel.TypeConverter>.  
  
-   Einem fehlgeschlagenen Versuch, auf den Typ einer Eigenschaft zu deserialisieren, der binäre Serialisierung verwendet werden soll.  
  
-   Geben Sie ein fehlerhaftem Versuch, eine Eigenschaft zu deserialisieren, da eine Instanz des Typs kann nicht erstellt werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPartManager" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die dem <paramref name="webPartManager" /> zugeordnete Seite ist <see langword="null" />.  
  
\- oder – 
Die der Seite zugeordnete Anforderung ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResetPersonalizationBlob">
      <MemberSignature Language="C#" Value="protected abstract void ResetPersonalizationBlob (System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, string path, string userName);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ResetPersonalizationBlob(class System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, string path, string userName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ResetPersonalizationBlob(System.Web.UI.WebControls.WebParts.WebPartManager,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void ResetPersonalizationBlob(System::Web::UI::WebControls::WebParts::WebPartManager ^ webPartManager, System::String ^ path, System::String ^ userName);" />
      <MemberSignature Language="F#" Value="abstract member ResetPersonalizationBlob : System.Web.UI.WebControls.WebParts.WebPartManager * string * string -&gt; unit" Usage="personalizationProvider.ResetPersonalizationBlob (webPartManager, path, userName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartManager" Type="System.Web.UI.WebControls.WebParts.WebPartManager" />
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="userName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="webPartManager">Der <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />, der die Personalisierungsdaten verwaltet.</param>
        <param name="path">Der Pfad für Personalisierungsinformationen, der als Datenspeicherschlüssel verwendet werden soll.</param>
        <param name="userName">Der Benutzername für Personalisierungsinformationen, der als Datenspeicherschlüssel verwendet werden soll.</param>
        <summary>Wenn in einer abgeleiteten Klasse überschrieben, werden Personalisierungsrohdaten aus dem zugrunde liegenden Datenspeicher gelöscht.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Abgeleitete Klassen <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider> und diese Methode implementieren, sollten die `webPartManager`, `path`, und `userName` Parameter als Speicherschlüssel. Abgeleitete Implementierungen müssen den Datenspeicher ändern, so, dass Personalisierungsdaten für den angegebenen Speicherschlüssel effektiv gelöscht werden. Es ist Aufgabe der abgeleiteten Implementierungen, wie sie physisch dies zu erreichen.  
  
 Der abgeleitete Personalisierungsanbieter muss Personalisierungsdaten auf ein auf Seitenbasis unterscheiden können. Darüber hinaus für eine bestimmte Seite Status, der Personalisierungsanbieter muss in der Lage unterscheiden <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> und <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User> Daten beschränken. Wenn es sich bei einer nicht -`null` Benutzername angegeben wird, und klicken Sie dann die Reset-Vorgang gilt für die <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User> Bereich festzulegen; andernfalls der Reset-Vorgang gilt für die <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> Bereich.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetPersonalizationState">
      <MemberSignature Language="C#" Value="public virtual void ResetPersonalizationState (System.Web.UI.WebControls.WebParts.WebPartManager webPartManager);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetPersonalizationState(class System.Web.UI.WebControls.WebParts.WebPartManager webPartManager) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ResetPersonalizationState(System.Web.UI.WebControls.WebParts.WebPartManager)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ResetPersonalizationState(System::Web::UI::WebControls::WebParts::WebPartManager ^ webPartManager);" />
      <MemberSignature Language="F#" Value="abstract member ResetPersonalizationState : System.Web.UI.WebControls.WebParts.WebPartManager -&gt; unit&#xA;override this.ResetPersonalizationState : System.Web.UI.WebControls.WebParts.WebPartManager -&gt; unit" Usage="personalizationProvider.ResetPersonalizationState webPartManager" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartManager" Type="System.Web.UI.WebControls.WebParts.WebPartManager" />
      </Parameters>
      <Docs>
        <param name="webPartManager">Der <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />, der die Personalisierungsdaten verwaltet.</param>
        <summary>Setzt Personalisierungsdaten auf den zugrunde liegenden Datenspeicher zurück.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist der Haupteinstiegspunkt, ein, die die <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization> Klasse, Personalisierungsdaten zurückzusetzen. Die Standardimplementierung verwendet die <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Steuerelement, um zu bestimmen, die Pfad und den Namen für die Daten zurückgesetzt werden sollen. Klicken Sie dann die Standardimplementierung Ruft die <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ResetPersonalizationBlob%2A> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPartManager" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der <paramref name="webPartManager" /> ist nicht einer Seite zugeordnet.  
  
\- oder – 
Die Seite ist nicht einer laufenden <see cref="T:System.Web.HttpRequest" /> zugeordnet.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResetState">
      <MemberSignature Language="C#" Value="public abstract int ResetState (System.Web.UI.WebControls.WebParts.PersonalizationScope scope, string[] paths, string[] usernames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ResetState(valuetype System.Web.UI.WebControls.WebParts.PersonalizationScope scope, string[] paths, string[] usernames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ResetState(System.Web.UI.WebControls.WebParts.PersonalizationScope,System.String[],System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function ResetState (scope As PersonalizationScope, paths As String(), usernames As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int ResetState(System::Web::UI::WebControls::WebParts::PersonalizationScope scope, cli::array &lt;System::String ^&gt; ^ paths, cli::array &lt;System::String ^&gt; ^ usernames);" />
      <MemberSignature Language="F#" Value="abstract member ResetState : System.Web.UI.WebControls.WebParts.PersonalizationScope * string[] * string[] -&gt; int" Usage="personalizationProvider.ResetState (scope, paths, usernames)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scope" Type="System.Web.UI.WebControls.WebParts.PersonalizationScope" />
        <Parameter Name="paths" Type="System.String[]" />
        <Parameter Name="usernames" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="scope">Ein <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationScope" /> der Personalisierungsinformationen, die zurückgesetzt werden sollen. Dieser Wert darf nicht <see langword="null" /> sein.</param>
        <param name="paths">Die Pfade für Personalisierungsinformationen, die gelöscht werden sollen.</param>
        <param name="usernames">Die Benutzernamen für Personalisierungsinformationen, die gelöscht werden sollen.</param>
        <summary>Wenn in einer abgeleiteten Klasse überschrieben, wird der Personalisierungszustand aus dem zugrunde liegenden Datenspeicher basierend auf den festgelegten Parametern gelöscht.</summary>
        <returns>Die Anzahl der gelöschten Zeilen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist die abstrakte Definition einer Verwaltungsmethode für das Löschen von Personalisierungsdaten. Abgeleitete Implementierungen sollten die unten beschriebene Logik folgen.  
  
 Keine Zeichen suchen mit Platzhaltern werden von dieser Methode unterstützt. Wenn der Personalisierungsanbieter Daten aus einer transaktionsfähigen Datenspeicher verfügbar macht, sollten diese Methode die Operationen als einer einzelnen atomaren Transaktion ausführen.  
  
 Nur die folgenden Kombinationen von Parameter sind zulässig:  
  
-   Die `scope` Parameter festgelegt wird, und alle anderen Parameter werden festgelegt, um `null`. Diese Kombination löscht alle Webparts-Personalisierungsdaten, die vom angegebenen Personalisierungsbereich zugeordneten `scope`.  
  
-   Die `scope` -Parameter festgelegt ist, und die `paths` Parameter enthält mindestens einen Wert. Diese Kombination löscht alle Webparts-Personalisierungsdaten für den angegebenen Pfad oder die Pfade in den Personalisierungsbereich erkennbar `scope`.  
  
-   Der `scope` Parametersatz zu <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>, wird die `paths` Parameter festgelegt ist, und enthält nur ein Wert, und die `usernames` Parameter enthält mindestens einen Wert. Diese Kombination löscht alle Benutzerpersonalisierungsdaten Webparts für den angegebenen Pfad, der den oder die Benutzer, die in enthaltenen zugeordnet ist `usernames`.  
  
-   Die `scope` Parametersatz zu <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>, `paths` Parameter auf festgelegt ist `null`, und die `usernames` Parameter enthält mindestens einen Wert. Diese Kombination löscht alle benutzerspezifische Personalisierung, Webparts-Daten, für alle Pfade, zugeordnete den oder die Benutzer, die in enthaltenen `usernames`.  
  
 Eine beliebige andere Kombination von Parameterwerten ist ungültig und löst eine <xref:System.ArgumentException> Ausnahme. Insbesondere werden die folgenden zwei Kombinationen sind nicht zulässig:  
  
-   Die `usernames` Parameter kann nicht bereitgestellt werden, wenn `scope` nastaven NA hodnotu <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>.  
  
-   Die `paths` Parameter darf nicht mehr als einen Eintrag enthalten bei der `usernames` -Parameter ist kein `null`.  
  
 Alle `paths` und `usernames` Parameterwerte, die in den entsprechenden Arrays enthalten sind, müssen die folgenden Gültigkeitsprüfungsregeln erfüllen. Wenn alle Validierungsregeln für jedes Mitglied die Parameterarrays Fehlschlagen einer <xref:System.ArgumentException> Ausnahme ausgelöst. Die Validierungsregeln werden:  
  
-   `null` Werte sind nicht zulässig.  
  
-   Eine leere Zeichenfolge ("") ist nicht zulässig. Vor der Durchführung einer leere Zeichenfolge Überprüfung sollten Parameter gekürzt werden.  
  
-   Die `usernames` Parameter darf keine Kommas (,) enthalten.  
  
-   Die Länge der `paths` Parameter darf nicht länger als 256 Zeichen für eine SQL­Datenbank sein.  
  
-   Die Länge der `usernames` Parameter darf nicht länger als 256 Zeichen für eine SQL­Datenbank sein.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetUserState">
      <MemberSignature Language="C#" Value="public abstract int ResetUserState (string path, DateTime userInactiveSinceDate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ResetUserState(string path, valuetype System.DateTime userInactiveSinceDate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ResetUserState(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function ResetUserState (path As String, userInactiveSinceDate As DateTime) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int ResetUserState(System::String ^ path, DateTime userInactiveSinceDate);" />
      <MemberSignature Language="F#" Value="abstract member ResetUserState : string * DateTime -&gt; int" Usage="personalizationProvider.ResetUserState (path, userInactiveSinceDate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="userInactiveSinceDate" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Der Pfad der zu löschenden Personalisierungsdaten. Dieser Wert kann <see langword="null" /> sein. Er darf jedoch keine leere Zeichenfolge ("") sein.</param>
        <param name="userInactiveSinceDate">Das Datum der letzten Änderung der Personalierungsdaten durch einen Websitebenutzer.</param>
        <summary>Wenn in einer abgeleiteten Klasse überschrieben, werden Webparts-Personalisierungsdaten im zugrunde liegenden Datenspeicher basierend auf den festgelegten Parametern gelöscht.</summary>
        <returns>Die Anzahl der aus dem zugrunde liegenden Datenspeicher gelöschten Zeilen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist die abstrakte Definition einer Verwaltungsmethode für das Löschen von Personalisierungsdaten. Beachten Sie, dass diese Methode nur Personalisierungsdaten für Benutzer und nicht auf freigegebene Daten auswirkt.  
  
 Abgeleitete Implementierungen sollten die unten beschriebene Logik ausführen:  
  
-   Die `path` Parameter darf keine Platzhalterzeichen enthalten.  
  
-   Wenn der Anbieter die Daten aus einer transaktionsfähigen Datenspeicher verfügbar macht, sollte diese Methode der Vorgänge in einer einzelnen atomaren Transaktion durchführen.  
  
-   Wenn die `path` -Parameter ist ungleich`null`, und klicken Sie dann nur benutzerspezifische Personalisierung Datensätze zugeordnet `path` gelöscht werden.  
  
-   Benutzerspezifische Personalisierung Datensätzen bezieht sich auf Benutzer, die seit dem angegebenen Datum als inaktiv betrachtet werden die `userInactiveSinceDate` Parameter gelöscht werden. Insbesondere zeichnet Where <xref:System.Web.UI.WebControls.WebParts.UserPersonalizationStateInfo.LastActivityDate%2A> ist kleiner als oder gleich <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UserInactiveSinceDate%2A> werden gelöscht.  
  
-   Wenn beide Parameter angegeben sind, werden Datensätze, die beide Einschränkungen entsprechen gelöscht.  
  
-   Die `path` -Parameters auch `null`.  
  
-   Die `path` Parameter darf keine leere Zeichenfolge sein. Es sollte entfernt werden, vor der Durchführung dieser Überprüfung.  
  
-   Die <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UserInactiveSinceDate%2A>-Eigenschaft darf nicht `null` sein.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SavePersonalizationBlob">
      <MemberSignature Language="C#" Value="protected abstract void SavePersonalizationBlob (System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, string path, string userName, byte[] dataBlob);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void SavePersonalizationBlob(class System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, string path, string userName, unsigned int8[] dataBlob) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.SavePersonalizationBlob(System.Web.UI.WebControls.WebParts.WebPartManager,System.String,System.String,System.Byte[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void SavePersonalizationBlob(System::Web::UI::WebControls::WebParts::WebPartManager ^ webPartManager, System::String ^ path, System::String ^ userName, cli::array &lt;System::Byte&gt; ^ dataBlob);" />
      <MemberSignature Language="F#" Value="abstract member SavePersonalizationBlob : System.Web.UI.WebControls.WebParts.WebPartManager * string * string * byte[] -&gt; unit" Usage="personalizationProvider.SavePersonalizationBlob (webPartManager, path, userName, dataBlob)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartManager" Type="System.Web.UI.WebControls.WebParts.WebPartManager" />
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="dataBlob" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="webPartManager">Der <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />, der die Personalisierungsdaten verwaltet.</param>
        <param name="path">Der Pfad für Personalisierungsinformationen, der als Datenspeicherschlüssel verwendet werden soll.</param>
        <param name="userName">Der Benutzername für Personalisierungsinformationen, der als Schlüssel verwendet werden soll.</param>
        <param name="dataBlob">Das Bytearray der zu speichernden Daten.</param>
        <summary>Wenn in einer abgeleiteten Klasse überschrieben, werden Personalisierungsrohdaten im zugrunde liegenden Datenspeicher gespeichert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist die abstrakte Definition der Methode zum Speichern von unformatierte Personalisierungsdaten im zugrunde liegenden Datenspeicher verwendet.  
  
 Abgeleitete Implementierungen verwenden, sollten die `webPartManager`, `path`, und `userName` Parameter als Speicherschlüssel. Der abgeleitete Personalisierungsanbieter muss Personalisierungsdaten auf ein auf Seitenbasis unterscheiden können. Darüber hinaus für eine bestimmte Seite Status des Anbieters muss in der Lage unterscheiden <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> und <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User> Bereich. Eine nicht-`null` Benutzername angegeben ist, und klicken Sie dann die `dataBlob` -Parameter wird <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User> -Bereich, andernfalls die `dataBlob` Parameter wird davon ausgegangen, dass im <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> Bereich.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SavePersonalizationState">
      <MemberSignature Language="C#" Value="public virtual void SavePersonalizationState (System.Web.UI.WebControls.WebParts.PersonalizationState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SavePersonalizationState(class System.Web.UI.WebControls.WebParts.PersonalizationState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.SavePersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationState)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SavePersonalizationState (state As PersonalizationState)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SavePersonalizationState(System::Web::UI::WebControls::WebParts::PersonalizationState ^ state);" />
      <MemberSignature Language="F#" Value="abstract member SavePersonalizationState : System.Web.UI.WebControls.WebParts.PersonalizationState -&gt; unit&#xA;override this.SavePersonalizationState : System.Web.UI.WebControls.WebParts.PersonalizationState -&gt; unit" Usage="personalizationProvider.SavePersonalizationState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Web.UI.WebControls.WebParts.PersonalizationState" />
      </Parameters>
      <Docs>
        <param name="state">Ein <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationState" />, der Personalisierungsdaten enthält, die gespeichert werden sollen.</param>
        <summary>Speichert Personalisierungsdaten in einen Datenspeicher.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist der Haupteinstiegspunkt, ein, die die <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization> Klasse zum Speichern von Personalisierungsdaten.  
  
 Die Standardimplementierung dieser Methode verwendet die Methoden für die interne Implementierung von <xref:System.Web.UI.WebControls.WebParts.PersonalizationState> Personalisierungsdaten in ein Bytearray zu packen. Wenn die Ergebnisse dieser Überlastung erstellen Sie ein leeres Byte array (da keine Personalisierungsdaten Eigenschaftenextraktion geführt hat), die Standardimplementierung Ruft die <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ResetPersonalizationBlob%2A> Methode. Andernfalls die Standardimplementierung Ruft die <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.SavePersonalizationBlob%2A> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="state" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der Typ des gespeicherten <paramref name="state" />-Objekts ist nicht identisch mit dem Typ des von der <see cref="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.LoadPersonalizationState(System.Web.UI.WebControls.WebParts.WebPartManager,System.Boolean)" />-Methode zurückgegebenen <paramref name="state" />-Objekts.</exception>
      </Docs>
    </Member>
  </Members>
</Type>