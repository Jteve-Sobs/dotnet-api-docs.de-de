<Type Name="PersonalizationProvider" FullName="System.Web.UI.WebControls.WebParts.PersonalizationProvider">
  <Metadata><Meta Name="ms.openlocfilehash" Value="d603d7964d57083f954418f6535bd9d25b1a0e8b" /><Meta Name="ms.sourcegitcommit" Value="1b924db57b3a1cf768d98c21f9b988d6966a0f2b" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="03/06/2020" /><Meta Name="ms.locfileid" Value="78765322" /></Metadata><TypeSignature Language="C#" Value="public abstract class PersonalizationProvider : System.Configuration.Provider.ProviderBase" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit PersonalizationProvider extends System.Configuration.Provider.ProviderBase" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.WebControls.WebParts.PersonalizationProvider" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class PersonalizationProvider&#xA;Inherits ProviderBase" />
  <TypeSignature Language="C++ CLI" Value="public ref class PersonalizationProvider abstract : System::Configuration::Provider::ProviderBase" />
  <TypeSignature Language="F#" Value="type PersonalizationProvider = class&#xA;    inherit ProviderBase" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Configuration.Provider.ProviderBase</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Implementiert die Basisfunktionalität für einen Personalisierungsanbieter.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist die abstrakte Basisklasse, die die erforderliche Funktionalität eines Personalisierungs Anbieters definiert. Ein Personalisierungs Anbieter lädt und speichert Personalisierungs Daten im Auftrag einer <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization>-Instanz.  
  
 Die-Basisklasse definiert das Standardverhalten für eine Reihe von Methoden. nur die Methoden, die speziell mit dem zugrunde liegenden Datenspeicher behandelt werden, sind als abstrakt gekennzeichnet. Dies ermöglicht es einem Entwickler, einen benutzerdefinierten Anbieter für die Interaktion mit einem bestimmten Datenspeicher zu schreiben, ohne dass die von der <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization>-Klasse verwendete Standardfunktionalität neu implementiert werden muss.  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides"><para>Sie können von <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationProvider" /> ableiten und Implementierungen nur für die in dieser Klasse definierten abstrakten Methoden bereitstellen. Die abstrakten Methoden befassen sich insbesondere mit dem Speichern und Laden von Daten in einen physischen Datenspeicher und mit der Datenspeicher Verwaltung. Ein benutzerdefinierter Anbieter muss in der Lage sein, Personalisierungs Informationen auf eine Weise zu manipulieren, die <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared" /> Daten von <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.User" /> Daten unterscheidet. Darüber hinaus muss ein Anbieter Personalisierungs Daten sowohl nach Seite als auch nach Anwendung segmentieren.  
  
Implementierungen von <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationProvider" /> sind eng an Implementierungen von <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationState" /> gekoppelt, da einige Personalisierungs Anbieter Methoden Instanzen von <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationState" />abgeleiteter Klassen zurückgeben. Um die Entwicklung von benutzerdefinierten Anbietern zu vereinfachen, enthält die <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationProvider" /> Basisklasse eine Standard Implementierung der Logik-und Serialisierungs-/Deserialisierungslogik, die direkt von der <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" />-Klasse verwendet wird. Daher erfordert das Erstellen eines benutzerdefinierten Anbieters ausschließlich zum Zweck der Arbeit mit einem anderen Datenspeicher nur die Implementierung der folgenden abstrakten Methoden: 
-   <see cref="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.GetCountOfState(System.Web.UI.WebControls.WebParts.PersonalizationScope,System.Web.UI.WebControls.WebParts.PersonalizationStateQuery)" />: Diese Methode muss in der Lage sein, die Anzahl der Zeilen der Personalisierungs Daten in der Datenbank für die angegebenen Abfrage Parameter zu zählen.  
  
-   <see cref="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.LoadPersonalizationBlobs(System.Web.UI.WebControls.WebParts.WebPartManager,System.String,System.String,System.Byte[]@,System.Byte[]@)" /> mit dem Pfad und dem Benutzernamen, lädt diese Methode zwei BLOBs (Binary Large Objects) aus der Datenbank: ein BLOB für freigegebene Daten und eine für Benutzerdaten. Wenn Sie den Benutzernamen und den Pfad angeben, benötigen Sie das <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />-Steuerelement nicht für den Zugriff auf die Seiten Informationen, die die Benutzernamen-/Pfadinformationen bereitstellen können.  
  
-   <see cref="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ResetPersonalizationBlob(System.Web.UI.WebControls.WebParts.WebPartManager,System.String,System.String)" /> mit dem Pfad und dem Benutzernamen, löscht diese Methode die entsprechende Zeile in der Datenbank. Wenn Sie den Benutzernamen und den Pfad angeben, benötigen Sie das <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />-Steuerelement nicht für den Zugriff auf die Seiten Informationen, die die Benutzernamen-/Pfadinformationen bereitstellen können.  
  
-   <see cref="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.SavePersonalizationBlob(System.Web.UI.WebControls.WebParts.WebPartManager,System.String,System.String,System.Byte[])" /> unter Angabe des Pfads und des Benutzernamens speichert diese Methode das angegebene BLOB in der Datenbank. Wenn Sie den Benutzernamen und den Pfad angeben, benötigen Sie das <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />-Steuerelement nicht für den Zugriff auf die Seiten Informationen, die die Benutzernamen-/Pfadinformationen bereitstellen können.  
  
Wenn bei all diesen Methoden nur ein Pfad bereitgestellt wird, gibt dies an, dass die freigegebenen Personalisierungs Daten für die Seite verarbeitet werden. Wenn sowohl ein Pfad als auch ein Benutzername an eine Methode weitergegeben werden, sollten die Benutzer Personalisierungs Daten für die Seite verarbeitet werden. Im Fall von <see cref="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.LoadPersonalizationBlobs(System.Web.UI.WebControls.WebParts.WebPartManager,System.String,System.String,System.Byte[]@,System.Byte[]@)" />sollten die freigegebenen Daten für den angegebenen Pfad immer geladen werden, und optional sollten auch die Benutzer Personalisierungs Daten für den Pfad geladen werden, wenn der Benutzername nicht <see langword="null" />ist.  
  
Alle anderen abstrakten Methoden sind nur für die Verwendung in administrativen Anwendungen vorgesehen und werden nicht von der Webparts-Infrastruktur zur Laufzeit verwendet. Ein Beispiel für eine Implementierung eines Personalisierungs Anbieters finden Sie in der <see cref="T:System.Web.UI.WebControls.WebParts.SqlPersonalizationProvider" />-Klasse.</para></block>
    <altmember cref="T:System.Web.UI.WebControls.WebParts.SqlPersonalizationProvider" />
    <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Webparts-Steuerelemente</related>
    <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/z36h8be9(v=vs.100)">Übersicht über die Webparts Personalisierung</related>
    <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/784d8z92(v=vs.100)">Exemplarische Vorgehensweise: Implementieren der Webparts Personalisierung mit einem Benutzer Steuerelement</related>
    <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/ms178182(v=vs.100)">Webparts Personalisierung</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected PersonalizationProvider ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; PersonalizationProvider();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der Klasse <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationProvider" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Da es sich hierbei um einen Konstruktor für eine abstrakte Klasse handelt, müssen Sie diese Methode überschreiben, um eine Instanz einer Klasse zu erstellen, die von dieser Klasse erbt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationName">
      <MemberSignature Language="C#" Value="public abstract string ApplicationName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ApplicationName" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ApplicationName" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Property ApplicationName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ ApplicationName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationName : string with get, set" Usage="System.Web.UI.WebControls.WebParts.PersonalizationProvider.ApplicationName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namen der für den Anbieter konfigurierten Anwendung ab bzw. legt ihn fest, wenn der Name in einer abgeleiteten Klasse überschrieben wird.</summary>
        <value>Die für den Personalisierungsanbieter konfigurierte Anwendung.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn in der Konfigurationsdatei kein Anwendungsname mit dem [providers-Element für die Personalisierung für das Webparts-Attribut (ASP.NET Settings Schema)](https://msdn.microsoft.com/library/51363b49-eafa-4b9c-b9d0-80086b385195) angegeben wird, wird der Wert der <xref:System.Web.Hosting.HostingEnvironment.ApplicationVirtualPath%2A>-Eigenschaft verwendet.  
  
> [!CAUTION]
>  Da eine einzelne standardmäßige Personalisierungs Anbieter Instanz für alle Anforderungen verwendet wird, die von einem <xref:System.Web.HttpApplication> Objekt bereitgestellt werden, können mehrere Anforderungen gleichzeitig ausgeführt werden, von denen jedes versucht, den <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ApplicationName%2A>-Eigenschafts Wert festzulegen. Die <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ApplicationName%2A>-Eigenschaft ist für mehrere Schreibvorgänge nicht Thread sicher, und das Ändern des <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ApplicationName%2A>-Eigenschafts Werts kann zu unerwartetem Verhalten bei mehreren Benutzern einer Anwendung führen. Es wird empfohlen, Code zu vermeiden, der es Benutzern ermöglicht, die <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ApplicationName%2A> Eigenschaft festzulegen, sofern dies nicht erforderlich ist Das Festlegen der <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ApplicationName%2A> Eigenschaft ist möglicherweise erforderlich, z. b. in einer administrativen Anwendung, die Personalisierungs Daten für mehrere Anwendungen verwaltet.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateSupportedUserCapabilities">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.IList CreateSupportedUserCapabilities ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.IList CreateSupportedUserCapabilities() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.CreateSupportedUserCapabilities" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateSupportedUserCapabilities () As IList" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::IList ^ CreateSupportedUserCapabilities();" />
      <MemberSignature Language="F#" Value="abstract member CreateSupportedUserCapabilities : unit -&gt; System.Collections.IList&#xA;override this.CreateSupportedUserCapabilities : unit -&gt; System.Collections.IList" Usage="personalizationProvider.CreateSupportedUserCapabilities " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine Liste von <see cref="T:System.Web.UI.WebControls.WebParts.WebPartUserCapability" />-Objekten zurück, die die vom Webparts-Steuerelementsatz verwendeten bekannten Funktionen darstellen.</summary>
        <returns>Eine <see cref="T:System.Collections.IList" />, die die vom Webparts-Steuerelementsatz verwendeten bekannten Funktionen darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Derzeit gibt diese Methode eine Liste zurück, die zwei Funktionen enthält: <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.EnterSharedScopeUserCapability> und <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ModifyStateUserCapability>. Dabei handelt es sich um die Standardfunktionen, die im Element Authorization für das Element "Authorization" für das Webparts-Element ( [ASP.NET Settings Schema](https://msdn.microsoft.com/library/d190d4ff-1445-4ee1-88eb-9737c7aa1434) ) im Element " [Personalisierungs Element für Webparts (ASP.NET Settings](https://msdn.microsoft.com/library/3d77da55-73ce-46ce-97cf-7d2abcaada09) Schema)" des [Webparts-Element (ASP.NET Settings Schema)](https://msdn.microsoft.com/library/90af5acc-5a80-4b39-bba7-74afd06b167c) -Konfigurations Abschnitts definiert werden können. Wenn Sie sich dafür entscheiden, eine benutzerdefinierte Personalisierungs Infrastruktur zu implementieren, können Sie diese Methode überschreiben und einen eigenen Satz Autorisierungs bezogener Benutzer Funktionen definieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DetermineInitialScope">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.PersonalizationScope DetermineInitialScope (System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, System.Web.UI.WebControls.WebParts.PersonalizationState loadedState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Web.UI.WebControls.WebParts.PersonalizationScope DetermineInitialScope(class System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, class System.Web.UI.WebControls.WebParts.PersonalizationState loadedState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.DetermineInitialScope(System.Web.UI.WebControls.WebParts.WebPartManager,System.Web.UI.WebControls.WebParts.PersonalizationState)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DetermineInitialScope (webPartManager As WebPartManager, loadedState As PersonalizationState) As PersonalizationScope" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::PersonalizationScope DetermineInitialScope(System::Web::UI::WebControls::WebParts::WebPartManager ^ webPartManager, System::Web::UI::WebControls::WebParts::PersonalizationState ^ loadedState);" />
      <MemberSignature Language="F#" Value="abstract member DetermineInitialScope : System.Web.UI.WebControls.WebParts.WebPartManager * System.Web.UI.WebControls.WebParts.PersonalizationState -&gt; System.Web.UI.WebControls.WebParts.PersonalizationScope&#xA;override this.DetermineInitialScope : System.Web.UI.WebControls.WebParts.WebPartManager * System.Web.UI.WebControls.WebParts.PersonalizationState -&gt; System.Web.UI.WebControls.WebParts.PersonalizationScope" Usage="personalizationProvider.DetermineInitialScope (webPartManager, loadedState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.PersonalizationScope</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartManager" Type="System.Web.UI.WebControls.WebParts.WebPartManager" />
        <Parameter Name="loadedState" Type="System.Web.UI.WebControls.WebParts.PersonalizationState" />
      </Parameters>
      <Docs>
        <param name="webPartManager">Der <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />, der die Personalisierungsinformationen verwaltet.</param>
        <param name="loadedState">Die Personalisierungszustandsinformationen.</param>
        <summary>Bestimmt, ob der ursprüngliche Personalisierungsbereich der <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared" />-Bereich oder der <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.User" />-Bereich sein soll.</summary>
        <returns>Ein <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationScope" />, der angibt, ob der aktuelle Personalisierungsbereich <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.User" /> oder <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared" /> ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode bestimmt, ob der aktuelle Bereich <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> oder <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>werden soll, wenn ein Verweis auf ein <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Steuerelement und die Personalisierungs Zustandsinformationen vorhanden sind, die bereits zuvor im Personalisierungs Lebenszyklus geladen wurden. Diese Informationen werden von einer <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization> Instanz für nachfolgende Personalisierungs Aufgaben verwendet.  
  
 Die folgenden Regeln werden verwendet, um den Personalisierungs Bereich zu bestimmen:  
  
-   Es wird davon ausgegangen, dass der Bereich zunächst <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>wird.  
  
-   Wenn das aktuell ausgeführte Benutzerkonto nicht authentifiziert ist, wird der Gültigkeitsbereich auf <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>festgelegt.  
  
-   Wenn das aktuell ausgeführte Benutzerkonto authentifiziert wird, erfolgt die weitere Verarbeitung in der Rangfolge der Rangfolge:  
  
    -   Wenn sich die Seite im Post Back Modus befindet, enthält die Seiten Anforderung Bereichs Informationen von einem vorherigen Rendering der Seite. Wenn diese Bereichs Informationen darauf hindeuten, dass <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> Bereich verwendet wurde, wird der Gültigkeitsbereich als <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>ausgewertet.  
  
    -   Wenn für die aktuell ausgeführte Seite die Steuerung von einer anderen Seite übernommen wurde (z. b., wenn die Übertragung der Steuerung aufgrund des <xref:System.Web.UI.WebControls.WebParts.WebPartManager> `Personalization.Scope` Aufrufs der <xref:System.Web.HttpServerUtility.Transfer%2A>-Methode aufgetreten ist; beachten Sie, dass diese spezielle Überprüfung nicht für die Seiten übergreifende Bereitstellung erfolgt) und wenn die zuvor ausgeführte Seite über eine <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Instanz verfügt.  
  
    -   Wenn die vorherigen Kriterien nicht erfüllt sind, wird der Gültigkeitsbereich als Wert der <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.InitialScope%2A>-Eigenschaft für das aktuelle <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Steuerelement ausgewertet.  
  
 Nachdem die vorherigen Auswertungen vorgenommen wurden und der Gültigkeitsbereich als <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> Bereich ausgewertet wird, erfolgt die folgende Verarbeitung:  
  
-   Wenn das aktuell ausgeführte Benutzerkonto über die <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.EnterSharedScopeUserCapability> Funktion verfügt, bleibt der Bereich auf <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>festgelegt.  
  
-   Wenn das aktuell ausgeführte Benutzerkonto nicht über die <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.EnterSharedScopeUserCapability> Funktion verfügt, wird der Bereich auf <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>zurückgesetzt.  
  
-   Wenn das Ergebnis aller vorherigen Bereichs Auswertungen <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>ist, wird dieses Ergebnis als ausgeblendetes Feld auf der aktuell ausgeführten Seite gespeichert. Dies ist der Mechanismus, bei dem eine Seite die Bereichs Auswertung bei nachfolgenden Postbacks wiedergeben kann.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPartManager" /> ist <see langword="null" /></exception>
        <exception cref="T:System.ArgumentException">Die dem <paramref name="webPartManager" /> zugeordnete Seite ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DetermineUserCapabilities">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IDictionary DetermineUserCapabilities (System.Web.UI.WebControls.WebParts.WebPartManager webPartManager);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IDictionary DetermineUserCapabilities(class System.Web.UI.WebControls.WebParts.WebPartManager webPartManager) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.DetermineUserCapabilities(System.Web.UI.WebControls.WebParts.WebPartManager)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DetermineUserCapabilities (webPartManager As WebPartManager) As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IDictionary ^ DetermineUserCapabilities(System::Web::UI::WebControls::WebParts::WebPartManager ^ webPartManager);" />
      <MemberSignature Language="F#" Value="abstract member DetermineUserCapabilities : System.Web.UI.WebControls.WebParts.WebPartManager -&gt; System.Collections.IDictionary&#xA;override this.DetermineUserCapabilities : System.Web.UI.WebControls.WebParts.WebPartManager -&gt; System.Collections.IDictionary" Usage="personalizationProvider.DetermineUserCapabilities webPartManager" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartManager" Type="System.Web.UI.WebControls.WebParts.WebPartManager" />
      </Parameters>
      <Docs>
        <param name="webPartManager">Der <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />, der die Personalisierungsinformationen verwaltet.</param>
        <summary>Gibt ein Wörterbuch mit <see cref="T:System.Web.UI.WebControls.WebParts.WebPartUserCapability" />-Instanzen zurück, die die personalisierungsbezogenen Funktionen des aktuell ausgeführten Benutzerkontos darstellen.</summary>
        <returns>Ein <see cref="T:System.Collections.IDictionary" />, das 0 oder mehr <see cref="T:System.Web.UI.WebControls.WebParts.WebPartUserCapability" />-Instanzen enthält, wenn das Benutzerkonto authentifiziert wird, oder <see langword="null" /> ist, wenn das aktuell ausgeführte Benutzerkonto nicht authentifiziert wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standard Implementierung dieser Methode verwendet die Informationen im Authorization- [Element für das Personalisierungs für Webparts (ASP.NET Settings Schema)](https://msdn.microsoft.com/library/d190d4ff-1445-4ee1-88eb-9737c7aa1434) -Element innerhalb des Elements " [Personalisierungs Element für Webparts" (ASP.NET Settings Schema)](https://msdn.microsoft.com/library/3d77da55-73ce-46ce-97cf-7d2abcaada09) des [Webparts-Element (ASP.NET Settings Schema)](https://msdn.microsoft.com/library/90af5acc-5a80-4b39-bba7-74afd06b167c) -Konfigurations Abschnitts in der Datei "Machine. config" oder "Web. config", um die autorisierten Funktionen eines Benutzers zu bestimmen.  
  
 Die Funktionen im Wörterbuch sind Member des <xref:System.Collections.IList> Objekts, das von der <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.CreateSupportedUserCapabilities%2A>-Methode zurückgegeben wird, die derzeit die <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.EnterSharedScopeUserCapability>-Funktion und die <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ModifyStateUserCapability> Funktion enthält.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die dem <paramref name="webPartManager" /> zugeordnete Seite ist <see langword="null" />.  
  
Oder 
Die der Seite zugeordnete Anforderung ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPartManager" /> ist <see langword="null" /></exception>
      </Docs>
    </Member>
    <Member MemberName="FindState">
      <MemberSignature Language="C#" Value="public abstract System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection FindState (System.Web.UI.WebControls.WebParts.PersonalizationScope scope, System.Web.UI.WebControls.WebParts.PersonalizationStateQuery query, int pageIndex, int pageSize, out int totalRecords);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection FindState(valuetype System.Web.UI.WebControls.WebParts.PersonalizationScope scope, class System.Web.UI.WebControls.WebParts.PersonalizationStateQuery query, int32 pageIndex, int32 pageSize, [out] int32&amp; totalRecords) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.FindState(System.Web.UI.WebControls.WebParts.PersonalizationScope,System.Web.UI.WebControls.WebParts.PersonalizationStateQuery,System.Int32,System.Int32,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function FindState (scope As PersonalizationScope, query As PersonalizationStateQuery, pageIndex As Integer, pageSize As Integer, ByRef totalRecords As Integer) As PersonalizationStateInfoCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Web::UI::WebControls::WebParts::PersonalizationStateInfoCollection ^ FindState(System::Web::UI::WebControls::WebParts::PersonalizationScope scope, System::Web::UI::WebControls::WebParts::PersonalizationStateQuery ^ query, int pageIndex, int pageSize, [Runtime::InteropServices::Out] int % totalRecords);" />
      <MemberSignature Language="F#" Value="abstract member FindState : System.Web.UI.WebControls.WebParts.PersonalizationScope * System.Web.UI.WebControls.WebParts.PersonalizationStateQuery * int * int * int -&gt; System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection" Usage="personalizationProvider.FindState (scope, query, pageIndex, pageSize, totalRecords)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scope" Type="System.Web.UI.WebControls.WebParts.PersonalizationScope" />
        <Parameter Name="query" Type="System.Web.UI.WebControls.WebParts.PersonalizationStateQuery" />
        <Parameter Name="pageIndex" Type="System.Int32" />
        <Parameter Name="pageSize" Type="System.Int32" />
        <Parameter Name="totalRecords" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="scope">Ein <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationScope" /> mit den Personalisierungsinformationen, die abgefragt werden sollen. Dieser Wert darf nicht <see langword="null" /> sein.</param>
        <param name="query">Eine <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery" />, die eine Abfrage enthält. Dieser Wert kann <see langword="null" /> sein.</param>
        <param name="pageIndex">Die Position, an der die Abfrage gestartet wird.</param>
        <param name="pageSize">Die Anzahl der zurückzugebenden Datensätze.</param>
        <param name="totalRecords">Die Gesamtzahl der verfügbaren Datensätze.</param>
        <summary>Wenn in einer abgeleiteten Klasse überschrieben, wird basierend auf dem angegebenen Bereich und den angegebenen Parametern eine Auflistung mit 0 oder mehr von <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo" /> abgeleiteten Objekten zurückgegeben.</summary>
        <returns>Eine <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection" /> mit 0 oder mehr von <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo" /> abgeleiteten Objekten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei dieser Methode handelt es sich um die abstrakte Definition einer administrativen Methode zum Abfragen von Personalisierungs Daten. Abgeleitete Implementierungen sollten der unten beschriebenen Logik folgen.  
  
 Die Menge der zurückgegebenen Elemente wird durch die Parameter `pageIndex` und `pageSize` eingeschränkt, wobei `pageSize` die Anzahl der zurück zugebende Datensätze festlegt und `pageIndex` festlegt, welche Datensätze zurückgegeben werden sollen. Beispielsweise werden bei einer `pageIndex` von 0 und einer `pageSize` von 25 die ersten 25 vorkommen zurückgegeben, während eine `pageIndex` von 1 und eine `pageSize` von 25 vorkommen 26-50 zurückgeben würde. Wenn Sie alle verfügbaren Datensätze abrufen möchten, legen Sie `pageIndex` auf 0 fest, und `pageSize` auf <xref:System.Int32.MaxValue>.  
  
 Die <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo>von abgeleiteten Objekten werden in alphabetischer Reihenfolge zurückgegeben und nach einer Kombination ihrer <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo.Path%2A>-und <xref:System.Web.UI.WebControls.WebParts.UserPersonalizationStateInfo.Username%2A> Eigenschaftswerte sortiert, beide in aufsteigender Reihenfolge.  
  
 Diese Methode übergibt die Abfrage Platzhalter Zeichen an den zugrunde liegenden Datenspeicher. Die Unterstützung für Platzhalter Zeichen ist zurzeit davon abhängig, wie die einzelnen Anbieter Zeichen, wie z. b. ein Sternchen (*), ein Prozentzeichen (%) oder einen Unterstrich (_) behandeln.  
  
 Normalerweise können Sie für SQL-kompatible Datenspeicher eine Platzhalter Suche in einem partiellen Pfad ausführen, wobei das Platzhalter Zeichen am Anfang, am Ende oder in der Mitte des Text der Such Zeichenfolge in der <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A>-Eigenschaft angezeigt wird. Wenn Sie z. b. alle Pfade suchen möchten, die mit "\~/vdir" beginnen, wird die Eigenschaft <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A> auf "\~/vdir%" festgelegt.  
  
 Ebenso kann für eine Platzhalter Suche bei einem partiellen Benutzernamen das Platzhalter Zeichen an einem beliebigen Punkt in der Text Zeichenfolge der <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A>-Eigenschaft angezeigt werden. Um beispielsweise alle Benutzernamen zu suchen, die mit "John" beginnen, würde der <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A>-Parameter wie folgt lauten: "John%".  
  
 Die folgenden Abfrage Einschränkungen gelten:  
  
-   Wenn nur `scope` bereitgestellt wird, und `query` `null` oder alle Eigenschaften auf `query` entweder `null` oder Standardwerte zurückgeben, werden alle Datensätze zurückgegeben, die mit dem angegebenen `scope` Parameter übereinstimmen.  
  
-   Wenn die <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A>-Eigenschaft nicht `null`ist, werden die zurückgegebenen Datensätze auch auf der Grundlage von Pfaden gefiltert, die dem <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A>-Wert entsprechen.  
  
-   Wenn die <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A>-Eigenschaft nicht `null`ist, werden die zurückgegebenen Datensätze auch auf der Grundlage von Benutzernamen gefiltert, die dem <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A>-Eigenschafts Wert entsprechen.  
  
-   Wenn die <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UserInactiveSinceDate%2A>-Eigenschaft nicht gleich <xref:System.DateTime.MaxValue>ist, werden die zurückgegebenen Datensätze ebenfalls so gefiltert, dass nur die Datensätze zurückgegeben werden, die inaktiven Benutzern zugeordnet sind. Der Vergleich umfasst Datensätze, bei denen die <xref:System.Web.UI.WebControls.WebParts.UserPersonalizationStateInfo.LastActivityDate%2A>-Eigenschaft kleiner oder gleich der <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UserInactiveSinceDate%2A>-Eigenschaft ist.  
  
 Beachten Sie, dass diese Methode keine Kombinationen von Abfrage Parametern überprüft. Beispielsweise kann Code einen Satz von Personalisierungs Zustandsdaten Sätzen anfordern, die einem bestimmten Benutzernamen im freigegebenen Bereich zugeordnet sind. Da Benutzernamen nicht mit freigegebenen Informationen verknüpft sind, ist die zurückgegebene Auflistung leer.  
  
 Parameter Kombinationen, die die Möglichkeit haben, eine nicht leere Auflistung zurückzugeben, umfassen Folgendes:  
  
-   <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> Bereich in Kombination mit der <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A>-Eigenschaft.  
  
-   <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User> Bereich in Kombination mit den Werten für die Eigenschaften <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A>, <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A>und <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UserInactiveSinceDate%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCountOfState">
      <MemberSignature Language="C#" Value="public abstract int GetCountOfState (System.Web.UI.WebControls.WebParts.PersonalizationScope scope, System.Web.UI.WebControls.WebParts.PersonalizationStateQuery query);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCountOfState(valuetype System.Web.UI.WebControls.WebParts.PersonalizationScope scope, class System.Web.UI.WebControls.WebParts.PersonalizationStateQuery query) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.GetCountOfState(System.Web.UI.WebControls.WebParts.PersonalizationScope,System.Web.UI.WebControls.WebParts.PersonalizationStateQuery)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetCountOfState (scope As PersonalizationScope, query As PersonalizationStateQuery) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetCountOfState(System::Web::UI::WebControls::WebParts::PersonalizationScope scope, System::Web::UI::WebControls::WebParts::PersonalizationStateQuery ^ query);" />
      <MemberSignature Language="F#" Value="abstract member GetCountOfState : System.Web.UI.WebControls.WebParts.PersonalizationScope * System.Web.UI.WebControls.WebParts.PersonalizationStateQuery -&gt; int" Usage="personalizationProvider.GetCountOfState (scope, query)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scope" Type="System.Web.UI.WebControls.WebParts.PersonalizationScope" />
        <Parameter Name="query" Type="System.Web.UI.WebControls.WebParts.PersonalizationStateQuery" />
      </Parameters>
      <Docs>
        <param name="scope">Ein <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationScope" /> der Personalisierungsinformationen, die abgefragt werden sollen. Dieser Wert darf nicht <see langword="null" /> sein.</param>
        <param name="query">Eine <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery" />, die eine Abfrage enthält. Dieser Wert kann <see langword="null" /> sein.</param>
        <summary>Wenn in einer abgeleiteten Klasse überschrieben, wird die Anzahl der Zeilen im zugrunde liegenden Datenspeicher zurückgegeben, die innerhalb des angegebenen Bereichs vorhanden sind.</summary>
        <returns>Die Anzahl der Zeilen im zugrunde liegenden Datenspeicher, die für den angegebenen <paramref name="scope" />-Parameter vorhanden sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist die abstrakte Definition einer administrativen Methode zum Abrufen der Anzahl von Personalisierungs Daten. Abgeleitete Implementierungen sollten der unten beschriebenen Logik folgen.  
  
 Diese Methode übergibt die Abfrage Platzhalter Zeichen an den zugrunde liegenden Datenspeicher. Die Unterstützung für Platzhalter Zeichen ist zurzeit davon abhängig, wie die einzelnen Anbieter Zeichen, wie z. b. ein Sternchen (*), ein Prozentzeichen (%) oder einen Unterstrich (_) behandeln.  
  
 Normalerweise können Sie für SQL-kompatible Datenspeicher eine Platzhalter Suche in einem partiellen Pfad ausführen, wobei das Platzhalter Zeichen am Anfang, am Ende oder in der Mitte des Text der Such Zeichenfolge in der <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A>-Eigenschaft angezeigt wird. Wenn Sie z. b. alle Pfade suchen möchten, die mit "\~/vdir" beginnen, wird die Eigenschaft <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A> auf "\~/vdir%" festgelegt.  
  
 Ebenso kann für eine Platzhalter Suche bei einem partiellen Benutzernamen das Platzhalter Zeichen an einem beliebigen Punkt in der Text Zeichenfolge der <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A>-Eigenschaft angezeigt werden. Um beispielsweise alle Benutzernamen zu suchen, die mit "John" beginnen, würde der <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A>-Parameter wie folgt lauten: "John%".  
  
 Die folgenden Abfrage Einschränkungen gelten:  
  
-   Wenn nur `scope` bereitgestellt wird, und `query` `null` ist oder alle Eigenschaften auf `query` entweder `null` oder Standardwerte zurückgeben, werden alle Datensätze gezählt, die dem angegebenen `scope` Parameter entsprechen.  
  
-   Wenn die <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A>-Eigenschaft nicht `null`ist, werden die gezählten Datensätze auch auf der Grundlage von Pfaden gefiltert, die dem <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A> Wert entsprechen.  
  
-   Wenn die <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A>-Eigenschaft nicht `null`ist, werden die gezählten Datensätze auch auf der Grundlage von Benutzernamen gefiltert, die dem <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A>-Eigenschafts Wert entsprechen.  
  
-   Wenn die <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UserInactiveSinceDate%2A>-Eigenschaft nicht gleich <xref:System.DateTime.MaxValue>ist, werden die gezählten Datensätze ebenfalls so gefiltert, dass nur die Datensätze zurückgegeben werden, die inaktiven Benutzern zugeordnet sind. Der Vergleich umfasst Datensätze, bei denen die <xref:System.Web.UI.WebControls.WebParts.UserPersonalizationStateInfo.LastActivityDate%2A>-Eigenschaft kleiner oder gleich der <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UserInactiveSinceDate%2A>-Eigenschaft ist.  
  
 Beachten Sie, dass diese Methode keine Kombinationen von Abfrage Parametern überprüft. Beispielsweise kann Code eine Anzahl von Personalisierungs Zustandsdaten Sätzen anfordern, die einem bestimmten Benutzernamen im freigegebenen Bereich zugeordnet sind. Da Benutzernamen nicht mit freigegebenen Informationen verknüpft sind, ist die zurückgegebene Anzahl 0 (null).  
  
 Parameter Kombinationen, die eine Anzahl ungleich NULL zurückgeben können, sind:  
  
-   <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> Bereich in Kombination mit der <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A>-Eigenschaft.  
  
-   <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User> Bereich in Kombination mit den Werten für die Eigenschaften <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A>, <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A>und <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UserInactiveSinceDate%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadPersonalizationBlobs">
      <MemberSignature Language="C#" Value="protected abstract void LoadPersonalizationBlobs (System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, string path, string userName, ref byte[] sharedDataBlob, ref byte[] userDataBlob);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void LoadPersonalizationBlobs(class System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, string path, string userName, unsigned int8[]&amp; sharedDataBlob, unsigned int8[]&amp; userDataBlob) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.LoadPersonalizationBlobs(System.Web.UI.WebControls.WebParts.WebPartManager,System.String,System.String,System.Byte[]@,System.Byte[]@)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub LoadPersonalizationBlobs (webPartManager As WebPartManager, path As String, userName As String, ByRef sharedDataBlob As Byte(), ByRef userDataBlob As Byte())" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void LoadPersonalizationBlobs(System::Web::UI::WebControls::WebParts::WebPartManager ^ webPartManager, System::String ^ path, System::String ^ userName, cli::array &lt;System::Byte&gt; ^ % sharedDataBlob, cli::array &lt;System::Byte&gt; ^ % userDataBlob);" />
      <MemberSignature Language="F#" Value="abstract member LoadPersonalizationBlobs : System.Web.UI.WebControls.WebParts.WebPartManager * string * string * Byte[] * Byte[] -&gt; unit" Usage="personalizationProvider.LoadPersonalizationBlobs (webPartManager, path, userName, sharedDataBlob, userDataBlob)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartManager" Type="System.Web.UI.WebControls.WebParts.WebPartManager" />
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="sharedDataBlob" Type="System.Byte[]" RefType="ref" />
        <Parameter Name="userDataBlob" Type="System.Byte[]" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="webPartManager">Der <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />, der die Personalisierungsdaten verwaltet.</param>
        <param name="path">Der Pfad für Personalisierungsinformationen, der als Abrufschlüssel verwendet werden soll.</param>
        <param name="userName">Der Benutzername für Personalisierungsinformationen, der als Abrufschlüssel verwendet werden soll.</param>
        <param name="sharedDataBlob">Die zurückgegebenen Daten für den <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared" />-Bereich.</param>
        <param name="userDataBlob">Die zurückgegebenen Daten für den <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.User" />-Bereich.</param>
        <summary>Wenn in einer abgeleiteten Klasse überschrieben, werden Personalisierungsrohdaten aus dem zugrunde liegenden Datenspeicher geladen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klassen, die von <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider> abgeleitet werden und diese Methode implementieren, sollten die Parameter `webPartManager`, `path`und `username` als Abruf Schlüssel verwenden. Unabhängig davon, wie die Daten im Datenspeicher gespeichert werden (einige Datenspeicher können einen intelligenten Speicher aufweisen), müssen die Personalisierungs Daten als gepackte Byte Satz in zwei Arrays zurückgegeben werden. Die zurückgegebenen Daten müssen den folgenden Regeln entsprechen:  
  
-   Die Daten für den <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> Bereich müssen immer im `sharedDataBlob`-Parameter zurückgegeben werden.  
  
-   Abhängig von den Schlüsselwerten werden <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User> Daten im `userDataBlob`-Parameter zurückgegeben. Ein nicht`null` Wert für den `userName`-Parameter gibt an, dass <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User> Daten ebenfalls abgerufen werden sollen.  
  
 Ein Personalisierungs Anbieter, der von <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider> abgeleitet ist und diese Methode implementiert, kann die Interaktion mit seinem Datenspeicher optimieren, indem alle Personalisierungs Daten in einem Roundtrip abgerufen werden, anstatt <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> und <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User> Daten in zwei separaten Roundtrips abzurufen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadPersonalizationState">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.PersonalizationState LoadPersonalizationState (System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, bool ignoreCurrentUser);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.PersonalizationState LoadPersonalizationState(class System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, bool ignoreCurrentUser) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.LoadPersonalizationState(System.Web.UI.WebControls.WebParts.WebPartManager,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function LoadPersonalizationState (webPartManager As WebPartManager, ignoreCurrentUser As Boolean) As PersonalizationState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::PersonalizationState ^ LoadPersonalizationState(System::Web::UI::WebControls::WebParts::WebPartManager ^ webPartManager, bool ignoreCurrentUser);" />
      <MemberSignature Language="F#" Value="abstract member LoadPersonalizationState : System.Web.UI.WebControls.WebParts.WebPartManager * bool -&gt; System.Web.UI.WebControls.WebParts.PersonalizationState&#xA;override this.LoadPersonalizationState : System.Web.UI.WebControls.WebParts.WebPartManager * bool -&gt; System.Web.UI.WebControls.WebParts.PersonalizationState" Usage="personalizationProvider.LoadPersonalizationState (webPartManager, ignoreCurrentUser)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.PersonalizationState</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartManager" Type="System.Web.UI.WebControls.WebParts.WebPartManager" />
        <Parameter Name="ignoreCurrentUser" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="webPartManager">Der <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />, der die Personalisierungsdaten verwaltet.</param>
        <param name="ignoreCurrentUser">Ein <see cref="T:System.Boolean" />, der angibt, ob der Benutzername an den Personalisierungsanbieter übergeben werden soll.</param>
        <summary>Lädt die Rohdaten aus dem zugrunde liegenden Datenspeicher und konvertiert diese Daten in ein <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationState" />-Objekt.</summary>
        <returns>Ein <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationState" />, der Personalisierungsdaten enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist der Haupteinstiegspunkt, der von der <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization>-Klasse verwendet wird, um Personalisierungs Daten zu laden. Die Standard Implementierung lädt die Rohdaten aus dem zugrunde liegenden Datenspeicher (Funktionalität wird in abgeleiteten Anbietern implementiert) und konvertiert dann die Rohdaten in eine <xref:System.Web.UI.WebControls.WebParts.PersonalizationState> Instanz.  
  
 Wenn der `ignoreCurrentUser`-Parameter `true`ist, wird kein Benutzername an die <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.LoadPersonalizationBlobs%2A>-Methode übergeben. Ein Personalisierungs Anbieter kann dies so interpretieren, dass nur der Personalisierungs Zustand mit einem <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> Bereich aus dem zugrunde liegenden Datenspeicher abgerufen werden soll.  
  
 Wenn die <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.Load%2A>-Methode ausgeführt wird, ruft Sie die <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.LoadPersonalizationState%2A>-Methode auf, und es gibt drei Typen von Deserialisierungsfehlern, die auftreten können, wenn der Zustand geladen wird. Wenn diese spezifischen Fehler auftreten, wird keine Ausnahme ausgelöst, und die Fehlerereignisse werden stattdessen von der System Überwachungsfunktion protokolliert (Informationen zur Integritäts Überwachung und zum Zugriff auf die von ihr erstellten Protokolle finden Sie unter [ASP.NET Health Monitoring Overview](https://msdn.microsoft.com/library/e003f224-70fe-4cd8-a71a-2dc81e2d7e4c)). Die folgenden drei Szenarien bewirken, dass Deserialisierungsfehlerereignisse in das Protokoll geschrieben werden:  
  
-   Ein fehlerhafter Versuch, einen Eigenschaftentyp zu deserialisieren, der eine Zeichenfolge <xref:System.ComponentModel.TypeConverter>verwendet.  
  
-   Der Versuch, einen Eigenschaftentyp zu deserialisieren, der binäre Serialisierung verwendet, ist fehlgeschlagen.  
  
-   Der Versuch, einen Eigenschaftentyp zu deserialisieren, ist fehlgeschlagen, da keine Instanz des Typs erstellt werden kann.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der Jointyp (<paramref name="webPartManager" />) lautet <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die dem <paramref name="webPartManager" /> zugeordnete Seite ist <see langword="null" />.  
  
Oder 
Die der Seite zugeordnete Anforderung ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResetPersonalizationBlob">
      <MemberSignature Language="C#" Value="protected abstract void ResetPersonalizationBlob (System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, string path, string userName);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ResetPersonalizationBlob(class System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, string path, string userName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ResetPersonalizationBlob(System.Web.UI.WebControls.WebParts.WebPartManager,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub ResetPersonalizationBlob (webPartManager As WebPartManager, path As String, userName As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void ResetPersonalizationBlob(System::Web::UI::WebControls::WebParts::WebPartManager ^ webPartManager, System::String ^ path, System::String ^ userName);" />
      <MemberSignature Language="F#" Value="abstract member ResetPersonalizationBlob : System.Web.UI.WebControls.WebParts.WebPartManager * string * string -&gt; unit" Usage="personalizationProvider.ResetPersonalizationBlob (webPartManager, path, userName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartManager" Type="System.Web.UI.WebControls.WebParts.WebPartManager" />
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="userName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="webPartManager">Der <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />, der die Personalisierungsdaten verwaltet.</param>
        <param name="path">Der Pfad für Personalisierungsinformationen, der als Datenspeicherschlüssel verwendet werden soll.</param>
        <param name="userName">Der Benutzername für Personalisierungsinformationen, der als Datenspeicherschlüssel verwendet werden soll.</param>
        <summary>Wenn in einer abgeleiteten Klasse überschrieben, werden Personalisierungsrohdaten aus dem zugrunde liegenden Datenspeicher gelöscht.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klassen, die von <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider> abgeleitet sind und diese Methode implementieren, sollten die Parameter `webPartManager`, `path`und `userName` als Speicher Schlüssel verwenden. Abgeleitete Implementierungen müssen den Datenspeicher so ändern, dass Personalisierungs Daten für bereitgestellte Speicher Schlüssel effektiv gelöscht werden. Es liegt an den abgeleiteten Implementierungen, wie Sie dies physisch erreichen.  
  
 Der abgeleitete Personalisierungs Anbieter muss in der Lage sein, Personalisierungs Daten auf Seitenbasis zu unterscheiden. Darüber hinaus muss der Personalisierungs Anbieter in der Lage sein, zwischen <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> und <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User> Bereichs Daten zu unterscheiden, um den Status einer bestimmten Seite zu ermitteln. Wenn ein nicht`null` Benutzername angegeben wird, gilt der Zurücksetzungs Vorgang für den <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User> Bereich. Andernfalls gilt der Zurücksetzungs Vorgang für den <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> Bereich.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetPersonalizationState">
      <MemberSignature Language="C#" Value="public virtual void ResetPersonalizationState (System.Web.UI.WebControls.WebParts.WebPartManager webPartManager);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetPersonalizationState(class System.Web.UI.WebControls.WebParts.WebPartManager webPartManager) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ResetPersonalizationState(System.Web.UI.WebControls.WebParts.WebPartManager)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ResetPersonalizationState (webPartManager As WebPartManager)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ResetPersonalizationState(System::Web::UI::WebControls::WebParts::WebPartManager ^ webPartManager);" />
      <MemberSignature Language="F#" Value="abstract member ResetPersonalizationState : System.Web.UI.WebControls.WebParts.WebPartManager -&gt; unit&#xA;override this.ResetPersonalizationState : System.Web.UI.WebControls.WebParts.WebPartManager -&gt; unit" Usage="personalizationProvider.ResetPersonalizationState webPartManager" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartManager" Type="System.Web.UI.WebControls.WebParts.WebPartManager" />
      </Parameters>
      <Docs>
        <param name="webPartManager">Der <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />, der die Personalisierungsdaten verwaltet.</param>
        <summary>Setzt Personalisierungsdaten auf den zugrunde liegenden Datenspeicher zurück.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist der Haupteinstiegspunkt, der von der <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization>-Klasse verwendet wird, um Personalisierungs Daten zurückzusetzen. Die Standard Implementierung verwendet das <xref:System.Web.UI.WebControls.WebParts.WebPartManager>-Steuerelement, um den Pfad und den Benutzernamen für die zurück zusetzenden Daten zu bestimmen. Die Standard Implementierung ruft dann die <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ResetPersonalizationBlob%2A>-Methode auf.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPartManager" /> ist <see langword="null" /></exception>
        <exception cref="T:System.ArgumentException">Der <paramref name="webPartManager" /> ist nicht einer Seite zugeordnet.  
  
Oder 
Die Seite ist nicht einer laufenden <see cref="T:System.Web.HttpRequest" /> zugeordnet.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResetState">
      <MemberSignature Language="C#" Value="public abstract int ResetState (System.Web.UI.WebControls.WebParts.PersonalizationScope scope, string[] paths, string[] usernames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ResetState(valuetype System.Web.UI.WebControls.WebParts.PersonalizationScope scope, string[] paths, string[] usernames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ResetState(System.Web.UI.WebControls.WebParts.PersonalizationScope,System.String[],System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function ResetState (scope As PersonalizationScope, paths As String(), usernames As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int ResetState(System::Web::UI::WebControls::WebParts::PersonalizationScope scope, cli::array &lt;System::String ^&gt; ^ paths, cli::array &lt;System::String ^&gt; ^ usernames);" />
      <MemberSignature Language="F#" Value="abstract member ResetState : System.Web.UI.WebControls.WebParts.PersonalizationScope * string[] * string[] -&gt; int" Usage="personalizationProvider.ResetState (scope, paths, usernames)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scope" Type="System.Web.UI.WebControls.WebParts.PersonalizationScope" />
        <Parameter Name="paths" Type="System.String[]" />
        <Parameter Name="usernames" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="scope">Ein <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationScope" /> der Personalisierungsinformationen, die zurückgesetzt werden sollen. Dieser Wert darf nicht <see langword="null" /> sein.</param>
        <param name="paths">Die Pfade für Personalisierungsinformationen, die gelöscht werden sollen.</param>
        <param name="usernames">Die Benutzernamen für Personalisierungsinformationen, die gelöscht werden sollen.</param>
        <summary>Wenn in einer abgeleiteten Klasse überschrieben, wird der Personalisierungszustand aus dem zugrunde liegenden Datenspeicher basierend auf den festgelegten Parametern gelöscht.</summary>
        <returns>Die Anzahl der gelöschten Zeilen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist die abstrakte Definition einer administrativen Methode zum Löschen von Personalisierungs Daten. Abgeleitete Implementierungen sollten der unten beschriebenen Logik folgen.  
  
 Von dieser Methode werden keine Platzhalter für Platzhalter Zeichen unterstützt. Wenn der Personalisierungs Anbieter Daten aus einem Transaktions abhängigen Datenspeicher verfügbar macht, sollte diese Methode die Vorgänge als einzelne atomarische Transaktion ausführen.  
  
 Nur die folgenden Kombinationen von Parametern sind zulässig:  
  
-   Der `scope`-Parameter ist festgelegt, und alle anderen Parameter werden auf `null`festgelegt. Diese Kombination löscht alle Webparts Personalisierungs Daten, die dem Personalisierungs Bereich zugeordnet sind, der durch `scope`angegeben wird.  
  
-   Der `scope`-Parameter ist festgelegt, und der `paths`-Parameter enthält mindestens einen Wert. Diese Kombination löscht alle Webparts Personalisierungs Daten für den angegebenen Pfad oder die Pfade im Personalisierungs Bereich, der durch `scope`angegeben wird.  
  
-   Der `scope`-Parameter ist auf <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>festgelegt, der `paths`-Parameter wird festgelegt und enthält nur einen Wert, und der `usernames`-Parameter enthält mindestens einen Wert. Diese Kombination löscht alle Benutzer Personalisierungs Webparts Daten für den angegebenen Pfad, der dem Benutzer zugeordnet ist, der in `usernames`enthalten ist.  
  
-   Der `scope`-Parameter ist auf <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>festgelegt, der `paths`-Parameter ist auf `null`festgelegt, und der `usernames`-Parameter enthält mindestens einen Wert. Durch diese Kombination werden alle Benutzer bezogenen Personalisierungs Webparts Daten über alle Pfade hinweg gelöscht, die mit dem Benutzer oder den Benutzern in `usernames`verknüpft sind.  
  
 Eine beliebige andere Kombination von Parameterwerten ist ungültig und löst eine <xref:System.ArgumentException> Ausnahme aus. Insbesondere sind die folgenden beiden Kombinationen nicht zulässig:  
  
-   Der `usernames`-Parameter kann nicht angegeben werden, wenn `scope` auf <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>festgelegt ist.  
  
-   Der `paths`-Parameter darf nicht mehr als einen Eintrag enthalten, wenn der `usernames` Parameter nicht `null`ist.  
  
 Alle `paths`-und `usernames` Parameterwerte, die in den entsprechenden Arrays enthalten sind, müssen die folgenden Validierungsregeln erfüllen. Wenn bei einem beliebigen Member der Parameter Arrays Validierungsregeln fehlschlagen, wird eine <xref:System.ArgumentException> Ausnahme ausgelöst. Die Validierungsregeln lauten wie folgt:  
  
-   `null` Werte sind nicht zulässig.  
  
-   Eine leere Zeichenfolge ("") ist nicht zulässig. Parameter sollten vor der Durchführung einer leeren Zeichen folgen Überprüfung gekürzt werden.  
  
-   Der `usernames`-Parameter darf keine Kommas (,) enthalten.  
  
-   Die Länge des `paths`-Parameters darf für eine SQL-Datenbank nicht mehr als 256 Zeichen umfassen.  
  
-   Die Länge des `usernames`-Parameters darf für eine SQL-Datenbank nicht mehr als 256 Zeichen umfassen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetUserState">
      <MemberSignature Language="C#" Value="public abstract int ResetUserState (string path, DateTime userInactiveSinceDate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ResetUserState(string path, valuetype System.DateTime userInactiveSinceDate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ResetUserState(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function ResetUserState (path As String, userInactiveSinceDate As DateTime) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int ResetUserState(System::String ^ path, DateTime userInactiveSinceDate);" />
      <MemberSignature Language="F#" Value="abstract member ResetUserState : string * DateTime -&gt; int" Usage="personalizationProvider.ResetUserState (path, userInactiveSinceDate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="userInactiveSinceDate" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Der Pfad der zu löschenden Personalisierungsdaten. Dieser Wert kann <see langword="null" /> sein. Er darf jedoch keine leere Zeichenfolge ("") sein.</param>
        <param name="userInactiveSinceDate">Das Datum der letzten Änderung der Personalierungsdaten durch einen Websitebenutzer.</param>
        <summary>Wenn in einer abgeleiteten Klasse überschrieben, werden Webparts-Personalisierungsdaten im zugrunde liegenden Datenspeicher basierend auf den festgelegten Parametern gelöscht.</summary>
        <returns>Die Anzahl der aus dem zugrunde liegenden Datenspeicher gelöschten Zeilen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist die abstrakte Definition einer administrativen Methode zum Löschen von Personalisierungs Daten. Beachten Sie, dass sich diese Methode nur auf Benutzer Personalisierungs Daten und nicht auf freigegebene Daten auswirkt.  
  
 Abgeleitete Implementierungen sollten der unten beschriebenen Logik folgen:  
  
-   Der `path`-Parameter darf keine Platzhalter Zeichen enthalten.  
  
-   Wenn der Anbieter Daten aus einem Transaktions abhängigen Datenspeicher verfügbar macht, sollte diese Methode die Vorgänge in einer einzelnen atomarischen Transaktion ausführen.  
  
-   Wenn der `path`-Parameter nicht`null`ist, werden nur benutzerspezifische Personalisierungs Datensätze, die `path` zugeordnet sind, gelöscht.  
  
-   Nur benutzerspezifische Personalisierungs Datensätze, die Benutzer zugeordnet sind, die als inaktiv eingestuft werden, da das im `userInactiveSinceDate` Parameter festgestellte Datum gelöscht wird. Insbesondere werden Datensätze gelöscht, bei denen <xref:System.Web.UI.WebControls.WebParts.UserPersonalizationStateInfo.LastActivityDate%2A> kleiner oder gleich <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UserInactiveSinceDate%2A> gelöscht werden.  
  
-   Wenn beide Parameter angegeben werden, werden Datensätze, die mit beiden Einschränkungen identisch sind, gelöscht.  
  
-   Der `path`-Parameter kann `null`werden.  
  
-   Der `path`-Parameter darf keine leere Zeichenfolge sein. Er sollte vor der Durchführung dieser Überprüfung gekürzt werden.  
  
-   Die <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UserInactiveSinceDate%2A>-Eigenschaft darf nicht `null` sein.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SavePersonalizationBlob">
      <MemberSignature Language="C#" Value="protected abstract void SavePersonalizationBlob (System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, string path, string userName, byte[] dataBlob);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void SavePersonalizationBlob(class System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, string path, string userName, unsigned int8[] dataBlob) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.SavePersonalizationBlob(System.Web.UI.WebControls.WebParts.WebPartManager,System.String,System.String,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub SavePersonalizationBlob (webPartManager As WebPartManager, path As String, userName As String, dataBlob As Byte())" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void SavePersonalizationBlob(System::Web::UI::WebControls::WebParts::WebPartManager ^ webPartManager, System::String ^ path, System::String ^ userName, cli::array &lt;System::Byte&gt; ^ dataBlob);" />
      <MemberSignature Language="F#" Value="abstract member SavePersonalizationBlob : System.Web.UI.WebControls.WebParts.WebPartManager * string * string * byte[] -&gt; unit" Usage="personalizationProvider.SavePersonalizationBlob (webPartManager, path, userName, dataBlob)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartManager" Type="System.Web.UI.WebControls.WebParts.WebPartManager" />
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="dataBlob" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="webPartManager">Der <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />, der die Personalisierungsdaten verwaltet.</param>
        <param name="path">Der Pfad für Personalisierungsinformationen, der als Datenspeicherschlüssel verwendet werden soll.</param>
        <param name="userName">Der Benutzername für Personalisierungsinformationen, der als Schlüssel verwendet werden soll.</param>
        <param name="dataBlob">Das Bytearray der zu speichernden Daten.</param>
        <summary>Wenn in einer abgeleiteten Klasse überschrieben, werden Personalisierungsrohdaten im zugrunde liegenden Datenspeicher gespeichert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist die abstrakte Definition der Methode, die zum Speichern von unformatierten Personalisierungs Daten im zugrunde liegenden Datenspeicher verwendet wird.  
  
 Abgeleitete Implementierungen sollten die Parameter `webPartManager`, `path`und `userName` als Speicher Schlüssel verwenden. Der abgeleitete Personalisierungs Anbieter muss in der Lage sein, Personalisierungs Daten auf Seitenbasis zu unterscheiden. Außerdem muss der Anbieter für den Status einer bestimmten Seite zwischen <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> und <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User> Bereich unterscheiden können. Wenn ein nicht`null` Benutzername angegeben wird, befindet sich der `dataBlob` Parameter in <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User> Gültigkeitsbereich. Andernfalls wird davon ausgegangen, dass sich der `dataBlob` Parameter in <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> Gültigkeitsbereich befindet.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SavePersonalizationState">
      <MemberSignature Language="C#" Value="public virtual void SavePersonalizationState (System.Web.UI.WebControls.WebParts.PersonalizationState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SavePersonalizationState(class System.Web.UI.WebControls.WebParts.PersonalizationState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.SavePersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationState)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SavePersonalizationState (state As PersonalizationState)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SavePersonalizationState(System::Web::UI::WebControls::WebParts::PersonalizationState ^ state);" />
      <MemberSignature Language="F#" Value="abstract member SavePersonalizationState : System.Web.UI.WebControls.WebParts.PersonalizationState -&gt; unit&#xA;override this.SavePersonalizationState : System.Web.UI.WebControls.WebParts.PersonalizationState -&gt; unit" Usage="personalizationProvider.SavePersonalizationState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Web.UI.WebControls.WebParts.PersonalizationState" />
      </Parameters>
      <Docs>
        <param name="state">Ein <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationState" />, der Personalisierungsdaten enthält, die gespeichert werden sollen.</param>
        <summary>Speichert Personalisierungsdaten in einen Datenspeicher.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist der Haupteinstiegspunkt, der von der <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization>-Klasse verwendet wird, um Personalisierungs Daten zu speichern.  
  
 Die Standard Implementierung dieser Methode verwendet die Methoden einer internen Implementierung von <xref:System.Web.UI.WebControls.WebParts.PersonalizationState>, um Personalisierungs Daten in ein Bytearray zu packen. Wenn die Ergebnisse dieser Verpackung ein leeres Bytearray erstellen (da die Eigenschaftsextrahierung zu keinen Personalisierungs Daten geführt hat), ruft die Standard Implementierung die <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ResetPersonalizationBlob%2A>-Methode auf. Andernfalls wird die <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.SavePersonalizationBlob%2A>-Methode von der Standard Implementierung aufgerufen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="state" /> ist <see langword="null" /></exception>
        <exception cref="T:System.ArgumentException">Der Typ des gespeicherten <paramref name="state" />-Objekts ist nicht identisch mit dem Typ des von der <paramref name="state" />-Methode zurückgegebenen <see cref="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.LoadPersonalizationState(System.Web.UI.WebControls.WebParts.WebPartManager,System.Boolean)" />-Objekts.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
