<Type Name="WebPartManager" FullName="System.Web.UI.WebControls.WebParts.WebPartManager">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="39878b0a58d88077e3f60f42a8b9f566fd421748" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30601304" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class WebPartManager : System.Web.UI.Control, System.Web.UI.INamingContainer, System.Web.UI.WebControls.WebParts.IPersonalizable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit WebPartManager extends System.Web.UI.Control implements class System.Web.UI.INamingContainer, class System.Web.UI.WebControls.WebParts.IPersonalizable" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.WebControls.WebParts.WebPartManager" />
  <TypeSignature Language="VB.NET" Value="Public Class WebPartManager&#xA;Inherits Control&#xA;Implements INamingContainer, IPersonalizable" />
  <TypeSignature Language="C++ CLI" Value="public ref class WebPartManager : System::Web::UI::Control, System::Web::UI::INamingContainer, System::Web::UI::WebControls::WebParts::IPersonalizable" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Web.UI.Control</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Web.UI.INamingContainer</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.WebControls.WebParts.IPersonalizable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("System.Web.UI.Design.WebControls.WebParts.WebPartManagerDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.NonVisualControl</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.ParseChildren(true)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.PersistChildren(false)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.ViewStateModeById</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Dient als zentrale Klasse des Webparts-Steuerelementsatzes und verwaltet alle Webparts-Steuerelemente, -Funktionen und -Ereignisse, die auf einer Webseite auftreten.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Steuerelement fungiert als Hub oder Mittelpunkt einer Webparts-Anwendung. Es muss ein – und nur ein--<xref:System.Web.UI.WebControls.WebParts.WebPartManager> Steuerelementinstanz auf jeder Seite, die Webparts-Steuerelemente verwendet. Wie bei den meisten Aspekte des Webparts-Anwendungen, die <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Steuerelement funktioniert nur mit authentifizierten Benutzern. Darüber hinaus funktioniert seine Funktionalität nahezu vollständig mit Serversteuerelemente, die sich auf Zonen Webparts, die befinden von erben die <xref:System.Web.UI.WebControls.WebParts.WebZone> Klasse. Serversteuerelemente, die sich auf einer Seite außerhalb dieser Zonen befinden können sehr wenig Webparts-Funktionen oder die Interaktion mit der <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Steuerelement.  
  
 Als Hub für Webparts-Funktionen auf einer Seite die <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Steuerelement führt die Arten von Aufgaben, die in der folgenden Tabelle beschrieben.  
  
|"Aufgabenkategorie"|Was bewirkt, dass das Steuerelement|  
|-------------------|---------------------------|  
|Nachverfolgen von Webparts-Steuerelemente|Hält den Überblick über die viele verschiedenen Arten von Steuerelementen auf einer Seite, die Webparts-Funktionen, einschließlich bereitstellen <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelemente, Verbindungen und Zonen.|  
|Hinzufügen und Entfernen von Webparts-Steuerelemente|Bietet Methoden zum Hinzufügen, löschen und Schließen von <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelemente auf einer Seite.|  
|Verwalten von Verbindungen|Verbindungen zwischen Steuerelementen erstellt und überwacht die Verbindungen als auch die Prozesse des hinzufügen und entfernen sie.|  
|Personalisieren von Steuerelementen und Seiten|Ermöglicht es Benutzern, die Steuerelemente auf einer Seite an andere Speicherorte verschoben, und startet die Ansichten, in denen Benutzer die Darstellung, Eigenschaften und Verhalten von Steuerelementen bearbeiten können. Benutzerspezifische personalisierungseinstellungen auf den einzelnen Seiten verwaltet werden.|  
|Umschalten zwischen verschiedenen Seitenansichten|Wechselt zwischen verschiedenen spezieller Ansichten von der Seite, damit Benutzer bestimmte Aufgaben wie das Ändern des Seitenlayouts oder Bearbeiten von Steuerelementen ausführen können.|  
|Auslösen von Ereignissen für Webparts-Lebenszyklus|Definiert, löst Sie aus und ermöglicht Entwicklern, behandeln Lebenszyklusereignisse des Webparts-Steuerelemente, z. B. wenn Steuerelemente, verschoben, in der verbundenen oder gelöschten hinzugefügt werden.|  
|Importieren und Exportieren von Steuerelementen|Exportiert die XML-Streams, die den Status der Eigenschaften des enthalten <xref:System.Web.UI.WebControls.WebParts.WebPart> steuert und ermöglicht Benutzern das Importieren der Dateien zum Personalisieren von komplexe Steuerelemente in anderen Seiten oder Websites.|  
  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager> -Klasse verfügt über eine große Gruppe von Eigenschaften. Konsistent mit der <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Rolle, der durch das Nachverfolgen von anderen Steuerelementen, gibt es eine Reihe von Eigenschaften, die Auflistungen von Webparts-Steuerelemente oder andere spezielle Webparts-Objekte zu verweisen. Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Connections%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Controls%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A>, und <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Zones%2A> Eigenschaften sind alle Auflistungen von verwendet die <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Steuerelement für die Überwachung und andere Aufgaben zur Verwaltung.  
  
 Eine andere Gruppe von Eigenschaften enthält, anpassbare Warnungen, die in bestimmten Szenarien gelten, die in einer Webparts-Anwendung auftreten. Dazu gehören die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A>, und die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportSensitiveDataWarning%2A> Eigenschaften.  
  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Klasse überschreibt einige Basis geerbten Eigenschaften, die von vielen Webserversteuerelementen verwendet werden. Dazu gehören die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EnableTheming%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SkinID%2A>, und <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Visible%2A> Eigenschaften.  
  
 Zum Schluss wird eine Gruppe von Eigenschaften für den Zugriff auf den aktuellen Zustand der Anwendung nützlich. Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> Eigenschaft gibt an, der aktuelle Anzeigemodus, die in eine Seite befindet. Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript%2A> Eigenschaft angibt, ob ein Steuerelement rendern Skriptdatei auf Clientseite in Situationen relevant ist, in denen Benutzer möglicherweise Browsern mit unterschiedlichen Funktionen oder Skripts deaktiviert haben. Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Internals%2A> Eigenschaft ist nützlich zum Verweisen auf eine Hilfsklasse, die Aufrufe an eine Reihe von Methoden für wichtige Webparts enthält, die für die Erweiterbarkeit verwendet werden. Durch das Ausblenden der Aufrufe dieser Methoden in einer separaten Klasse (die <xref:System.Web.UI.WebControls.WebParts.WebPartManagerInternals> Klasse), wird die <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Klasse-API vereinfacht. Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> Eigenschaft ermöglicht den Zugriff auf die personalisierungsobjekte, die Benutzer personalisierungseinstellungen speichern und diese Daten in dauerhaften Speicher beibehalten. Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A> Eigenschaft gibt an, welche <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelement auf einer Seite durch den Benutzer oder die Anwendung derzeit ausgewählt ist. Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A> Eigenschaft gibt an, ob benutzerdefinierte Personalisierungsdaten für eine <xref:System.Web.UI.WebControls.WebParts.WebPart> -Steuerelements geändert hat.  
  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager> -Steuerelement enthält fünf integrierte Anzeigemodi oder Sichten einer Webseite. Entwickler können dieses Feature erweitern und Erstellen von benutzerdefinierten Anzeigemodi Ausdehnung Typen wie z. B. die <xref:System.Web.UI.WebControls.WebParts.WebZone> Klasse oder die <xref:System.Web.UI.WebControls.WebParts.ToolZone> Klasse. Benutzer können in die verschiedenen Anzeigemodi eine Seite wechseln, vorausgesetzt, dass die richtige Art von Steuerelementen, die einen bestimmten Anzeigemodus entsprechen auf einer Seite vorhanden sind.  
  
> [!NOTE]
>  Es ist möglich, diese Funktion zu erweitern, sodass Benutzer in einem benutzerdefinierten Anzeigemodus wechseln können, ohne eine entsprechende Zone auf der Seite. Allerdings ist das Standardverhalten, dass Anzeigemodi Zonen entsprechen.  
  
 Die standardmäßige Anzeigemodi werden dargestellt durch öffentliche Felder in der <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Klasse. In der folgenden Tabelle werden die Felder und die Anzeigemodi, denen sie referenzieren zusammengefasst. Der aktuelle Anzeigemodus einer Seite wie zuvor erwähnt, ist immer auf die verwiesen wird der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> -Eigenschaft und der Satz der Anzeigemodi, ist für eine bestimmte Seite, erhält die Art der Zonen, die auf der Seite vorhanden sind, möglich, ist Bestandteil der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> Eigenschaft.  
  
|Feld|Anzeigen von Details Modus|  
|-----------|--------------------------|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>|Die Ansicht, normaler Benutzer einer Webseite. Die Standardeinstellung und die am häufigsten verwendeten Anzeigemodus.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode>|Die Ansicht, in der Benutzer neu anordnen oder Löschen von Steuerelementen zum Ändern des Seitenlayouts werden können.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode>|Die Ansicht, in der eine Bearbeitung Benutzeroberfläche (UI) angezeigt wird. Benutzer können bearbeiten, die Darstellung, Eigenschaften und Verhalten der Steuerelemente, die in den normalen Durchsuchenmodus angezeigt werden.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode>|Die Ansicht, in der ein Katalog Benutzeroberfläche angezeigt wird. Benutzer können Steuerelemente aus Katalogen der verfügbaren Steuerelemente auf einer Seite hinzufügen.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>|Die Ansicht, in der eine Verbindung UI sichtbar wird. Benutzer können eine Verbindung herstellen, verwalten oder trennt die Verbindungen zwischen Steuerelementen.|  
  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Steuerelement enthält auch eine Anzahl von Ereignissen, die in den Lebenszyklus von Webparts-Seiten und Steuerelemente wichtig sind. Diese Ereignisse bieten präzise programmgesteuerte Kontrolle über das Verhalten des Webparts-Steuerelemente. Die meisten Methoden betreffen direkt <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelemente (oder andere Server- oder Benutzersteuerelemente, die in platziert werden <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> Zonen so, dass sie als Verhalten können <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelemente). Allerdings gelten einige Ereignisse in den Zustand der Seite oder Verbindungen auf der Seite ein. In der folgenden Tabelle sind die verfügbaren Ereignisse und deren Verwendungszweck zusammengefasst.  
  
> [!NOTE]
>  In allen Fällen in der folgenden Tabelle das Wort "Control" bezieht sich auf eine <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelement oder ein beliebiges Serversteuerelement, das in einer Zone und wird mit umbrochen ein <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> Objekt zur Laufzeit.  
  
|event|Beschreibung |  
|-----------|-----------------|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>|Tritt unmittelbar vor einem Steuerelement hinzugefügt wird, auf eine Seite, um sicherzustellen, dass sie autorisiert sind.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated>|Tritt auf, nachdem alle Verbindungen auf einer Seite aktiviert wurden.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating>|Tritt unmittelbar vor den Prozess des Aktivierens alle Verbindungen auf einer Seite.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanged>|Tritt auf, nachdem der aktuelle Anzeigemodus einer Seite geändert wurde.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanging>|Tritt auf, unmittelbar bevor Anzeigemodus für eine Seite zu ändern.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged>|Tritt auf, nachdem die Auswahl eines Steuerelements wurde abgebrochen.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging>|Tritt auf, unmittelbar bevor der Aufheben der Auswahl eines Steuerelements.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded>|Tritt auf, nachdem ein Steuerelement zu einer Zone hinzugefügt wurde.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding>|Tritt unmittelbar vor der Prozess des Hinzufügens eines Steuerelements zu einer Zone.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed>|Tritt auf, nachdem ein Steuerelement (aus einer Seite entfernt) geschlossen wurde.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>|Tritt auf, unmittelbar bevor ein Steuerelement geschlossen.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted>|Tritt auf, nachdem eine Instanz eines dynamischen Steuerelements (eine, die programmgesteuert erstellt oder aus einem Katalog hinzugefügt wurde) dauerhaft gelöscht wurde.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting>|Tritt auf, unmittelbar bevor das Löschen einer dynamischen Steuerelemente.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved>|Tritt auf, nachdem ein Steuerelement innerhalb einer Zone oder in eine andere Zone verschoben wurde.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving>|Tritt unmittelbar vor der Migration eines Steuerelements.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected>|Tritt auf, nachdem zwei Steuerelemente, die ausgewählt werden, für die Teilnahme in eine Verbindung die Verbindung hergestellt haben.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting>|Tritt auf, unmittelbar bevor Herstellen einer Verbindung zwischen zwei Steuerelementen.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected>|Tritt auf, nachdem zwei verbundene Steuerelemente getrennt wurden.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>|Tritt auf, unmittelbar bevor von zwei Steuerelementen getrennt wird.|  
  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Steuerelement verfügt über zahlreiche Methoden zum Verwalten von Webparts-Seiten. Ein großer Satz von Methoden, die hier nicht aufgeführt sind, deren Namen das Format auf*EventName*. Diese Methoden in der Regel ihre zugeordnete Ereignis ausgelöst, und geben Sie das Ereignis mit einem Handler des Typs <xref:System.Web.UI.WebControls.WebParts.WebPartEventHandler>. Die meisten dieser Methoden können von Entwicklern, die von erben überschrieben werden die <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Klasse. Darüber hinaus können Entwickler von Seiten benutzerdefinierte Handler für die Ereignisse im Zusammenhang mit diesen Methoden bereitstellen. Beispielsweise im Fall von der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded> Ereignis, ein Entwickler konnte hinzufügen ein `OnWebPartAdded` -Attribut auf die `<asp:webpartmanager>` Element im Markup einer Webseite, und weisen Sie anschließend eine benutzerdefinierte Methode mit dem Attribut benennen Sie benutzerdefinierte Behandlung für das Ereignis bereitstellen. Das Attribut entspricht der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded%2A> -Methode, und dieses grundlegende Muster der eignet sich für die meisten Webparts-Ereignisse und ihre zugeordneten Methoden für die Ereignisbehandlung.  
  
 Darüber hinaus die <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Steuerelement verfügt über spezielle Methoden, um die Aufgabe des Verwaltens <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelemente (und Server oder Benutzer Steuerelemente verwendet, als <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelemente). Zu diesen Methoden gehören <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>, und <xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A>.  
  
 Eine andere Gruppe von Methoden ist für Verbindungen spezialisiert. Dazu gehören Methoden wie z. B. <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateAvailableTransformers%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints%2A>, und <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints%2A>.  
  
 Schließlich einige <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Methoden zu konzentrieren, Funktionen zur Personalisierung. Dazu gehören <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.LoadControlState%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SetPersonalizationDirty%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Load%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Save%2A>, und <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SaveControlState%2A>.  
  
 Weitere Informationen zu anderen <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Methoden, die über zugegriffen werden kann die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Internals%2A> Eigenschaft finden Sie in der Dokumentation für die <xref:System.Web.UI.WebControls.WebParts.WebPartManagerInternals> Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht deklarative und die programmgesteuerte Verwendung von der <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Steuerelement.  
  
 Das Codebeispiel besteht aus vier Teilen:  
  
-   Ein Benutzersteuerelement, das Ihnen ermöglicht, ändern Sie die Anzeigemodi auf einer Webparts-Seite.  
  
-   Eine Webseite mit zwei benutzerdefinierte <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelemente, die verbunden werden können, und ein `<asp:webpartmanager>` Element.  
  
-   Eine Quellcodedatei, die zwei benutzerdefinierte enthält <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelemente und eine benutzerdefinierte Schnittstelle.  
  
-   Eine Erläuterung der Funktionsweise des Beispiels in einem Browser.  
  
 Das Benutzersteuerelement verfügt über ein Dropdownlisten-Steuerelement, das zeigt die möglichen Anzeigemodi auf einer Seite, erhält die Webparts-Steuerelemente, die auf der Seite vorhanden sind. In diesem Codebeispiel wird die Webseite auf, wird dieses Benutzersteuerelement direkt unterhalb der deklariert die <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Element im Markup der Seite, und es wird eine `Register` -Direktive am oberen Rand der Webseite zur Registrierung des Steuerelements. Informationen zu Modi und eine Beschreibung des Quellcodes in diesem Steuerelement finden Sie unter [Exemplarische Vorgehensweise: Ändern des Anzeigemodus auf einer Webparts-Seite](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0).  
  
 [!code-aspx-csharp[WebParts_WebPartManager_SimpleConnection#6](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/CS/displaymodemenucs.ascx#6)]
 [!code-aspx-vb[WebParts_WebPartManager_SimpleConnection#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/VB/DisplayModeMenuVB.ascx#6)]  
  
 Das deklarative Markup für die Webseite enthält `Register` -Direktiven für das Benutzersteuerelement und die benutzerdefinierten Steuerelemente. Besteht eine `<asp:webpartmanager>` Element, ein `<asp:webpartzone>` Element enthält die benutzerdefinierten Steuerelemente und ein `<asp:connectionszone>` Element. Die Seite enthält außerdem einige Inlinecode, die Verbindung bezogene Ereignisse für behandelt die <xref:System.Web.UI.WebControls.WebParts.WebPartManager> steuern; Sie können die Auswirkung dieses Codes feststellen, wie Sie eine Verbindung herstellen und Trennen von Steuerelementen.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_SimpleConnection#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/CS/webpartmanagerConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_SimpleConnection#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/VB/webpartmanagerConnectionVB.aspx#1)]  
  
 Der dritte Teil des Beispiels wird der Quellcode für die Steuerelemente. Beachten Sie, dass eine Schnittstelle mit dem Namen `IZipCode`, und diese Schnittstelle wird implementiert, der `ZipCodeWebPart` Klasse. Diese Klasse verfügt über eine spezielle Rückrufmethode, die mit dem Namen `ProvideIZipCode` , die als Anbieter fungiert. Der andere Typ, der mit dem Namen `WeatherWebPart`, wird auch mit einer speziellen Methode mit dem Namen implementiert `GetIZipCode`, wodurch das Steuerelement, das als ein Consumer der anderer Steuerelemente fungiert.  
  
 Für das Codebeispiel ausführen müssen Sie diesen Quellcode kompilieren. Sie können es explizit kompilieren und legen Sie die resultierende Assembly im Bin-Ordner der Website oder dem globalen Assemblycache. Alternativ können Sie den Quellcode im Ordner "App_Code" des Standorts, ablegen, wo er zur Laufzeit dynamisch kompiliert wird. Dieses Codebeispiel wird davon ausgegangen, dass Sie die Quelle in eine Assembly kompiliert wurden und die `Register` -Direktive in der Webseite verweist auf den Assemblynamen. Eine exemplarische Vorgehensweise zum Kompilieren, veranschaulicht, finden Sie unter [Exemplarische Vorgehensweise: Entwickeln und Verwenden eines benutzerdefinierten Webserver-Steuerelements](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08).  
  
 [!code-csharp[WebParts_WebPartManager_SimpleConnection#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_SimpleConnection#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/VB/ZipCodeComponent.vb#2)]  
  
 Nachdem Sie die Webseite in einem Browser geladen haben, klicken Sie auf die **Anzeigemodus** Dropdownlisten-Steuerelement, und wählen **verbinden** Verbinden-Modus zu wechseln. Verbinden Sie-Modus verwendet die `<asp:connectionszone>` Element, um Verbindungen zwischen Steuerelementen erstellen können. Im Modus verbinden, klicken Sie auf den Pfeil nach unten in der Titelleiste des der **Postleitzahl** Steuerelement, um seine Verbmenü aktivieren, und klicken Sie dann auf **verbinden**. Nachdem die Verbindung Benutzeroberfläche angezeigt wird, klicken Sie auf die **erstellen Sie eine Verbindung mit einem Consumer** Link. Eine Zelle angezeigt wird, die über ein Dropdown-Listenfeld-Steuerelement verfügt. Wählen Sie **Weather Control** in der Dropdownliste aus, und klicken Sie dann auf **verbinden** zum Herstellen die Verbindung der beiden Steuerelemente. Klicken Sie auf **schließen**, und verwenden Sie dann die **Anzeigemodus** Dropdown-Liste aus, um die Seite zum normalen Durchsuchen-Modus zurückkehren. Sie können eine Postleitzahl eingeben, und der Consumer-Steuerelement wird mit dem eingegebenen Wert aktualisiert werden. Da die `ZipCode` Eigenschaft markiert wurde, mit der `Personalizable` Attribut im Quellcode, der Wert dieser Eigenschaft bleiben in Browsersitzungen, speichern daher den Wert von einem Benutzer eingegeben. Eine komplexere Consumer-Steuerelement konnte schalten die Postleitzahl, Wetterdaten basierend auf den Code und zeigen Sie es für einen Benutzer.  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>Die <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> Steuerelement erweitert werden soll. Da es ist daher vom zentralen zum Webparts-Anwendungen, wenn Sie einem bestimmten Typ zu erweitern oder im Webparts-Steuerelementsatz in vielen Fällen steuern möchten auch erweitern, muss die <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> Klasse, da es wahrscheinlich eine Eigenschaft oder Methode, die erforderlich ist ist, damit  der benutzerdefinierte Typ Arbeit im Kontext einer Webparts-Anwendung. Referenzdokumentation für die Webparts (finden Sie unter <see cref="N:System.Web.UI.WebControls.WebParts" />), wenn diskutieren Erweitern einer Webparts eingeben, häufig erwähnt herrscht vorgenommen werden, um das Erweitern der <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> -Klasse auch oder zeigt, wie Sie ein Codebeispiel hierfür erweitern.</para>
    </block>
    <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartManagerInternals" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WebPartManager ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WebPartManager();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.%23ctor%2A> Konstruktor initialisiert verschiedene wichtige Variablen verwendet werden, indem die <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Steuerelement. Eine Zuweisung, die direkt für alle Webparts-Seiten wirkt sich auf ist die Tatsache, dass die der Standardanzeigemodus der Seite auf die Durchsuchen-Modus festgelegt ist (<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ActivateConnections">
      <MemberSignature Language="C#" Value="protected virtual void ActivateConnections ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ActivateConnections() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ActivateConnections ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ActivateConnections();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Aktiviert alle derzeit inaktiven Verbindungen auf einer Webseite.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A> Methode wird aufgerufen, für jede Anforderung an eine Seite zum Aktivieren der vorhandener Verbindungen zwischen <xref:System.Web.UI.WebControls.WebParts.WebPart> und anderen Serversteuerelementen, die in den <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> Zonen. In einigen Fällen für die Instanz, wenn ein Konflikt in den Verbindungen aktiviert wurde, wird diese Methode wiederum ruft die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> Methode, um die problematische Verbindung zu beenden. Beim Trennungsprozess die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> Ereignis wird ausgelöst. Entwickler können dieses Ereignis normalerweise abbrechen jedoch in der Groß-/Kleinschreibung, dies ein Konflikt zwischen der Verbindungen, es kann nicht abgebrochen werden, ist da die <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Steuerelement muss den Konflikt zu lösen, um den Prozess des Aktivierens Verbindungen fertig zu stellen. Weitere Informationen finden Sie unter <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> Ereignis.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddWebPart">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPart AddWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart, System.Web.UI.WebControls.WebParts.WebPartZoneBase zone, int zoneIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.UI.WebControls.WebParts.WebPart AddWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart, class System.Web.UI.WebControls.WebParts.WebPartZoneBase zone, int32 zoneIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::UI::WebControls::WebParts::WebPart ^ AddWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart, System::Web::UI::WebControls::WebParts::WebPartZoneBase ^ zone, int zoneIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="zone" Type="System.Web.UI.WebControls.WebParts.WebPartZoneBase" />
        <Parameter Name="zoneIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="webPart">Der <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> (bzw. das Server- oder Benutzersteuerelement), der einer Webseite hinzugefügt oder auf einer Seite geöffnet werden soll.</param>
        <param name="zone">Die <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />, der <c>webPart</c> hinzugefügt wird.</param>
        <param name="zoneIndex">Eine ganze Zahl, die die Ordnungsposition darstellt, an der sich <c>webPart</c> in <c>zone</c> im Verhältnis zu anderen Steuerelementen in <c>zone</c> befindet.</param>
        <summary>Stellt die programmgesteuerte Standardmethode zum Hinzufügen von <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />-Steuerelementen auf einer Webseite bereit.</summary>
        <returns>Ein <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />-Steuerelement, das der Seite hinzugefügt wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A> Methode wird verwendet, beide hinzuzufügende neue dynamische <xref:System.Web.UI.WebControls.WebParts.WebPart> steuert, zu einer Seite und statische oder dynamische Steuerelemente geöffnet, die zuvor auf einer Seite geschlossen wurden. Wenn die Methode aufgerufen wird, um ein neues Steuerelement hinzuzufügen, erstellt es tatsächlich eine Kopie des Steuerelements verwiesen wird, der `webPart` Parameter. Damit Entwickler verweisen soll, wird eine neue ID für die Kopie des Steuerelements generiert die <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelement von der Methode zum Abrufen der neuen ID-Wert zurückgegeben. Wenn die Methode aufgerufen wird, um ein zuvor geschlossenen Steuerelement erneut zu öffnen, gibt es einen direkten Verweis auf das Steuerelement verweist die `webPart` Parameter.  
  
> [!IMPORTANT]
>  Sollten Sie immer verwenden die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A> -Methode, statt über das <xref:System.Web.UI.ControlCollection.Add%2A> -Methode der Auflistung der Steuerelemente auf die verwiesen wird durch die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Controls%2A?displayProperty=nameWithType> hinzuzufügenden Eigenschaft <xref:System.Web.UI.WebControls.WebParts.WebPart> -Steuerelemente programmgesteuert zur Seite, da mit der <xref:System.Web.UI.ControlCollection.Add%2A> Methode löst eine Ausnahme aus. Hinzufügen des Steuerelements, die keine <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelement (also ein Serversteuerelement, die mit umbrochen wird eine <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> Steuerelement zur Laufzeit), sollten Sie rufen Sie zuerst die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A> Methode, um das Steuerelement zu erstellen, und rufen Sie dann die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A> Methode hinzufügen das Steuerelement. Eine Demonstration dieses Ansatzes sind finden Sie im Beispielabschnitt.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A> Methode, um ein Steuerelement programmgesteuert zu einer Seite hinzufügen. Das Seitenmarkup enthält eine leere `<asp:webpartzone>` Element, und ein `<asp:webpartmanager>` Element. Beim ersten die **Kalender hinzufügen** Schaltfläche geklickt wird, den Code im Ereignis Ereignishandler erstellt ein <xref:System.Web.UI.WebControls.Calendar> steuern und fügt es einer Zone als eine <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> -Objekt Aufrufen der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A> Methode.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/CS/wpmgDeleteWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/VB/wpmgDeleteWebPartVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" /> ist <see langword="null" />.  
  
 \- oder –  
  
 <paramref name="zone" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="zone" /> wird nicht in der Auflistung der Zonen des <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />-Steuerelements registriert.  
  
 \- oder –  
  
 <paramref name="webPart" /> befindet sich bereits in <paramref name="zone" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Wert von <paramref name="zoneIndex" /> beträgt weniger als 0 (null).</exception>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart(System.Web.UI.Control)" />
      </Docs>
    </Member>
    <Member MemberName="AuthorizeWebPart">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventHandler AuthorizeWebPart;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventHandler AuthorizeWebPart" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AuthorizeWebPart As WebPartAuthorizationEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartAuthorizationEventHandler ^ AuthorizeWebPart;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn die <see cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized" />-Methode aufgerufen wird, um zu bestimmen, ob einer Seite ein <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />-Steuerelement oder Serversteuerelement hinzugefügt werden kann.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> Ereignis tritt auf, wenn ein <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelement zu einer Seite hinzugefügt wird. Es gibt eine Reihe von allgemeine Szenarien, in denen ein Steuerelement zu einer Seite hinzugefügt werden kann. Eine vollständige Beschreibung dieser finden Sie im Abschnitt "Hinweise" der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> Methode. Wenn ein Steuerelement hinzugefügt wird, muss überprüft werden, finden, ob die <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> Eigenschaft festgelegt wurde, und wenn dies der Fall ist, gibt an, ob das Steuerelement ist autorisiert, auf der Seite hinzugefügt werden.  
  
 Entwickler können Ereignishandler für das <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> Ereignis, um das Filtern von Steuerelementen bereitzustellen. Wenn ein Steuerelement <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> Eigenschaftswert erfüllt nicht die Kriterien in der Ereignishandlercode, wird nicht das Steuerelement auf der Seite hinzugefügt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie festzulegende einen benutzerdefinierten Ereignishandler für das <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> Ereignis, die automatisch die Standardeinstellung außer Kraft setzt <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A> Methode.  
  
 Der Code in der `mgr1_AuthorizeWebPart` Methode überprüft, ob die Steuerelemente auf der Seite ihren jeweiligen haben <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> Eigenschaftswerte festlegen, um `user` und, wenn dies der Fall ist, gibt `true`, was bedeutet, dass sie autorisiert und zur Seite hinzugefügt. Dies setzt voraus, dass das Standardverfahren besteht darin, Benutzern im Personalisierung Benutzerbereich Steuerelemente mit einer Seite anzeigen. Beachten Sie jedoch, dass in diesem Beispiel der Steuerelemente ist seine <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> -Eigenschaftswert festgelegt wird, um `admin`. Entwickler möglicherweise dieser Filter auf eine spezielle Steuerelement platzieren, die für nur Administratoren finden Sie unter entwickelt wurde. Dieses Steuerelement wird die autorisierungsprüfung Fehlschlagen der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> Ereignis, und werden nicht angezeigt. Beachten Sie, dass Steuerelemente, die nicht die Eigenschaft festgelegt haben, ebenfalls angezeigt werden; Sie wird angenommen, dass nicht Teil eines Filterszenarios da ihre <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> keine Eigenschaften festgelegt werden.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_AuthorizeWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_AuthorizeWebPart/CS/AuthorizeWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_AuthorizeWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_AuthorizeWebPart/VB/AuthorizeWebPartVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized" />
      </Docs>
    </Member>
    <Member MemberName="AvailableTransformers">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.TransformerTypeCollection AvailableTransformers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.TransformerTypeCollection AvailableTransformers" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AvailableTransformers As TransformerTypeCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::TransformerTypeCollection ^ AvailableTransformers { System::Web::UI::WebControls::WebParts::TransformerTypeCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.TransformerTypeCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Auflistung von <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" />-Objekten ab, die zum Erstellen von Webparts-Verbindungen zwischen Serversteuerelementen zur Verfügung stehen.</summary>
        <value>Eine <see cref="T:System.Web.UI.WebControls.WebParts.TransformerTypeCollection" />, die einen Satz von <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" />-Objekten enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft verwendet die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateAvailableTransformers%2A> Methode, um den Sammlungssatz zu erstellen. Standardmäßig wird die verfügbaren Transformatoren aus der Konfigurationsdatei gelesen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginWebPartConnecting">
      <MemberSignature Language="C#" Value="public virtual void BeginWebPartConnecting (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginWebPartConnecting(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginWebPartConnecting(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">Das Steuerelement, für das die Verbindung gebildet wird.</param>
        <summary>Startet den Prozess, mit dem zwei <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />-Steuerelemente miteinander verbunden werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting%2A> Methode vorhanden ist, sodass der Prozess zum Erstellen von Verbindungen zwischen Steuerelementen in unterschiedliche Stufen, erhalten Entwickler eine bessere Kontrolle über den Verbindungsprozess erfolgen kann. Die Methode führt eine Reihe von anfängliche Überprüfungen, um sicherzustellen, dass `webPart` befindet sich in einem Zustand, in dem eine Verbindung legitimen gebildet werden kann. Wenn `webPart` übergibt alle Überprüfungen dann als des aktuell ausgewählten Steuerelements festgelegt wird (finden Sie unter der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A> Eigenschaft), und das Herstellen einer Verbindung Prozess kann fortgesetzt werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der aktuelle Anzeigemodus auf der Seite lautet nicht <see cref="F:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode" />.</exception>
        <exception cref="T:System.ArgumentException">
          Der <paramref name="webPart" /> ist geschlossen.  
  
 \- oder –  
  
 <paramref name="webPart" /> gehört nicht der <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" />-Auflistung an.  
  
 - oder -   
  
 <paramref name="webPart" /> ist identisch mit dem <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" />-Steuerelement.</exception>
        <block subset="none" type="overrides">
          <para>Entwickler, die erweitert die <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> Steuerelement diese Methode in einer abgeleiteten Klasse außer Kraft setzen möchten. Eine bestünde Herangehensweise Aufrufen der Basismethode und fügen Sie dann einige zusätzliche benutzerdefinierte Behandlung; oder kann den Prozess gestartet wird, eine Verbindung zwischen Steuerelementen vollständig angepasst werden soll. Beispielsweise empfiehlt es sich um sicherzustellen, dass bestimmte Daten verfügbar sind, bevor Sie die Verbindung zu erstellen.</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting" />
      </Docs>
    </Member>
    <Member MemberName="BeginWebPartEditing">
      <MemberSignature Language="C#" Value="public virtual void BeginWebPartEditing (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginWebPartEditing(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginWebPartEditing(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">Das zu bearbeitende Steuerelement.</param>
        <summary>Startet den Prozess der Bearbeitung eines <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />-Steuerelements.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing%2A> Methode vorhanden ist, sodass der Prozess von Steuerelementen zur Bearbeitung in unterschiedliche Stufen, erhalten Entwickler eine bessere Kontrolle über den Prozess ausgeführt werden kann. Die Methode führt eine Reihe von anfängliche Überprüfungen, um sicherzustellen, dass `webPart` befindet sich in einem Zustand, in denen sie bearbeitet werden kann. Wenn `webPart` übergibt alle Überprüfungen dann als des aktuell ausgewählten Steuerelements festgelegt wird (finden Sie unter der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A> Eigenschaft), und der Bearbeitung fortfahren kann.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der aktuelle Anzeigemodus auf der Seite lautet nicht <see cref="F:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode" />.</exception>
        <exception cref="T:System.ArgumentException">
          Der <paramref name="webPart" /> ist geschlossen.  
  
 \- oder –  
  
 <paramref name="webPart" /> gehört nicht der <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" />-Auflistung an.  
  
 - oder -   
  
 <paramref name="webPart" /> ist identisch mit dem <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" />-Steuerelement.</exception>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing" />
      </Docs>
    </Member>
    <Member MemberName="BrowseDisplayMode">
      <MemberSignature Language="C#" Value="public static readonly System.Web.UI.WebControls.WebParts.WebPartDisplayMode BrowseDisplayMode;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Web.UI.WebControls.WebParts.WebPartDisplayMode BrowseDisplayMode" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BrowseDisplayMode As WebPartDisplayMode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ BrowseDisplayMode;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt den Standardanzeigemodus für Seiten dar, die Webparts-Steuerelemente enthalten. Dieses Feld ist schreibgeschützt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode> Feld verweist auf ein benutzerdefiniertes <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> -Objekt, das erstellt und enthalten die <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Steuerelement. Da dies ein statisches Objekt ist, finden Sie es direkt über die <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Klasse ohne eine Instanz des Steuerelements.  
  
 Wenn eine Seite mit den Webparts-erste geladen Steuerelemente, befindet sich im <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode> (Durchsuchenmodus) standardmäßig. Wenn Benutzer einfach genauso wie in einer normalen Webseite durchsuchen, bleibt die Seite im Durchsuchenmodus. Wenn möchten, dass Benutzer einer Seite Layout, Steuerelemente, Darstellung oder Verhalten anpassen, müssen sie die Seite wechseln, in einem speziellen Anzeigemodi erhältlich der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> Eigenschaft.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode> programmgesteuert Feld. Der Code füllt eine Dropdownliste mit den unterstützten Anzeigemodi, die in diesem Fall zu durchsuchen und Entwurf sind. Beachten Sie, dass der `Page_PreRender` -Methode, die dem Code wird überprüft, ob die aktuelle <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> -Eigenschaftensatz auf <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>. Wenn dies der Fall ist, `Label1` werden angezeigt, und falls nicht, `Label1` wird ausgeblendet.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_BrowseDisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_BrowseDisplayMode/CS/wpmgrBrowseDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_BrowseDisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_BrowseDisplayMode/VB/wpmgrBrowseDisplayModevb.aspx#1)]  
  
 Nachdem Sie die Seite in einem Browser geladen haben, können Sie im Durchsuchenmodus standardmäßig. Beachten Sie die Bezeichnung auf der Seite, die angibt, dass Sie im Durchsuchenmodus sind. Verwenden Sie das Dropdownlisten-Steuerelement, um die Seite in den Entwurfsmodus zu wechseln. Beachten Sie, dass aufgrund des Codes in der `Page_PreRender` -Methode, die Bezeichnung wird jetzt ausgeblendet.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CanConnectWebParts">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Prüft die <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />-Steuerelemente, die an einer Verbindung teilnehmen sollen, um zu bestimmen, ob diese verbunden werden können.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A> Methode wird verwendet, um zu bestimmen, ob zwei <xref:System.Web.UI.WebControls.WebParts.WebPart> -Steuerelemente verbunden werden können. Die Methode wird normalerweise verwendet, als eine bedingte Überprüfung vor dem Aufruf der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A> Methode.  
  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A> Methode überprüft eine Reihe von Kriterien, die erfüllt sein müssen, damit zwei Steuerelemente eine Verbindung bilden können. Die folgende Liste fasst die primären Kriterien zum Herstellen einer Verbindung. Wenn alle genannten Kriterien (sowie einige zusätzlichen internen Bedingungen) erfüllt sind, gibt die Methode `true`, was bedeutet, dass die Steuerelemente verbunden werden können:  
  
-   Die Anbieter- und dürfen nicht `null`, und sie müssen enthalten sein, in der Auflistung der Steuerelemente auf die verwiesen wird durch die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> Eigenschaft.  
  
-   Der Anbieter und der Consumer darf nicht dasselbe Steuerelement sein. In anderen Worten: eine <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelement kann keine Verbindung mit sich selbst.  
  
-   Die <xref:System.Web.UI.WebControls.WebParts.ConnectionPoint> nicht mit Objekten (Verbindungspunkte) für den Anbieter sowie den Consumer `null`.  
  
-   Der Anbieter und der Consumer können nicht geschlossen werden kann (weder Steuerelement <xref:System.Web.UI.WebControls.WebParts.WebPart.IsClosed%2A> Eigenschaft kann `true`).  
  
-   Die <xref:System.Web.UI.WebControls.WebParts.ConnectionPoint.ControlType%2A> Eigenschaft des Verbindungspunkt-Steuerelements muss dem Typ des Steuerelements von Verbraucher- und Anbieter entsprechen.  
  
-   Die Verbindungspunkte müssen beide aktiviert sein (ihre <xref:System.Web.UI.WebControls.WebParts.ConnectionPoint.GetEnabled%2A> Methoden müssen zurückgeben `true`).  
  
-   Jeder Verbindungspunkt muss nicht versuchen, mehr Verbindungen als der angegebene Wert in eine eigene bilden <xref:System.Web.UI.WebControls.WebParts.ConnectionPoint.AllowsMultipleConnections%2A> Eigenschaft.  
  
-   Wenn eine <xref:System.Web.UI.WebControls.WebParts.WebPartTransformer> Objekt (Transformer) ist erforderlich, um nicht kompatible Steuerelemente zu verbinden, kann nicht mehr `null`. Wenn die Steuerelemente bereits kompatibel sind, die Transformer muss jedoch sein `null`.  
  
-   Die Transformer (sofern verwendet) verwiesen werden muss, der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers%2A> Auflistung.  
  
-   Transformer (sofern verwendet) muss es sich um Schnittstellen verfügen, die mit dem Anbieter und der Consumer kompatibel sind, damit sie Daten zwischen den zwei Steuerelementen transformieren kann. Die sekundären Schnittstellen des Consumers und Anbieter müssen zudem kompatibel sein.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts" />
      </Docs>
    </MemberGroup>
    <Member MemberName="CanConnectWebParts">
      <MemberSignature Language="C#" Value="public bool CanConnectWebParts (System.Web.UI.WebControls.WebParts.WebPart provider, System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPart consumer, System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CanConnectWebParts(class System.Web.UI.WebControls.WebParts.WebPart provider, class System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPart consumer, class System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ProviderConnectionPoint,System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CanConnectWebParts(System::Web::UI::WebControls::WebParts::WebPart ^ provider, System::Web::UI::WebControls::WebParts::ProviderConnectionPoint ^ providerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPart ^ consumer, System::Web::UI::WebControls::WebParts::ConsumerConnectionPoint ^ consumerConnectionPoint);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="providerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
        <Parameter Name="consumer" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="consumerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
      </Parameters>
      <Docs>
        <param name="provider">Das Steuerelement, das Daten für <c>consumer</c> bereitstellt, wenn die Steuerelemente miteinander verbunden sind.</param>
        <param name="providerConnectionPoint">Ein <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" />, der es <c>provider</c> ermöglicht, an einer Verbindung teilzunehmen.</param>
        <param name="consumer">Das Steuerelement, das Daten von <c>provider</c> empfängt, wenn die Steuerelemente miteinander verbunden sind.</param>
        <param name="consumerConnectionPoint">Ein <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" />, der als Rückrufmethode fungiert, damit <c>consumer</c> an einer Verbindung teilnehmen kann.</param>
        <summary>Prüft die <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />-Steuerelemente, die an einer Verbindung teilnehmen sollen, um zu bestimmen, ob diese verbunden werden können, falls das Consumer- und Anbietersteuerelement über kompatible Schnittstellen verfügen und kein <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" />-Objekt erforderlich ist.</summary>
        <returns>Ein boolescher Wert, der angibt, ob <paramref name="provider" /> und <paramref name="consumer" /> verbunden werden können.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird verwendet, um eine Verbindung herstellen `provider` und `consumer` Wenn beide Steuerelemente über kompatible Verbindungspunkttypen verfügen, damit ein <xref:System.Web.UI.WebControls.WebParts.WebPartTransformer> Objekt ist nicht erforderlich. Möglicherweise möchten Sie diese Methode verwenden, um sicherzustellen, dass die beiden Steuerelemente vor dem Aufruf verbunden werden können <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A> eine programmgesteuerte Verbindung zu erstellen.  
  
 Diese Überladung verwendet dieselbe Implementierung wie die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%28System.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ProviderConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ConsumerConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPartTransformer%29> methodenüberladung mit die einzige Ausnahme, dass diese Überladung einen Transformer nicht erforderlich ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie diese Methode verwendet wird.  
  
 Das Codebeispiel besteht aus vier Teilen:  
  
-   Ein Benutzersteuerelement, das Ihnen ermöglicht, ändern Sie die Anzeigemodi auf einer Webparts-Seite.  
  
-   Eine Webseite mit zwei benutzerdefinierte <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelemente, die verbunden werden können, ein `<asp:webpartmanager>` -Element, und einige Ereignisbehandlungscode, die erstellt, eine Verbindung unter Verwendung der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A> Methode.  
  
-   Eine Quellcodedatei, die zwei benutzerdefinierte enthält <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelemente und eine benutzerdefinierte Schnittstelle.  
  
-   Eine Erläuterung der Funktionsweise des Beispiels in einem Browser.  
  
 Der erste Teil des Codebeispiels wird das Benutzersteuerelement zum Ändern des Anzeigemodus. Sie können den Quellcode für das Benutzersteuerelement abrufen, der im Abschnitt "Beispiel" die <xref:System.Web.UI.WebControls.WebParts.WebPartManager> -Klassenübersicht. Weitere Informationen zu Anzeigemodi und zur Funktionsweise des Benutzersteuerelements, finden Sie unter [Exemplarische Vorgehensweise: Ändern des Anzeigemodus auf einer Webparts-Seite](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0).  
  
 Das deklarative Markup für die Webseite enthält `Register` -Direktiven für das Benutzersteuerelement und die benutzerdefinierten Steuerelemente. Besteht eine `<asp:webpartmanager>` Element, ein `<asp:webpartzone>` Element enthält die benutzerdefinierten Steuerelemente und ein `<asp:connectionszone>` Element. Beachten Sie, dass in der `Page_Load` -Methode, der Code überprüft, ob die Verbindung hergestellt werden kann und, wenn dies der Fall ist, definiert einen Anbieter, ein Consumer und ihre jeweiligen Verbindungspunkte und fügt dann eine neue Verbindung auf den Satz von statischen Verbindungen verweist die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A>Eigenschaft.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/CS/wpmgrStaticConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/VB/wpmgrStaticConnectionVB.aspx#1)]  
  
 Der dritte Teil des Beispiels wird der Quellcode für die Steuerelemente. Er enthält eine Schnittstelle und zwei benutzerdefinierte <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelemente, eines als einen Anbieter und der andere als Consumer fungiert. Schreibberechtigung kompatibel Verbindungspunkte (beide erkennen die `IZipCode` Schnittstelle), ein Transformer ist nicht erforderlich, um die Verbindung herzustellen. Für das Codebeispiel ausführen müssen Sie diesen Quellcode kompilieren. Sie können es explizit kompilieren und legen Sie die resultierende Assembly im Bin-Ordner der Website oder dem globalen Assemblycache. Alternativ können Sie den Quellcode im Ordner "App_Code" des Standorts, ablegen, wo er zur Laufzeit dynamisch kompiliert wird. Eine exemplarische Vorgehensweise zum Kompilieren, veranschaulicht, finden Sie unter [Exemplarische Vorgehensweise: Entwickeln und Verwenden eines benutzerdefinierten Webserver-Steuerelements](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08).  
  
 [!code-csharp[WebParts_WebPartManager_StaticConnections#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_StaticConnections#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/VB/ZipCodeComponent.vb#2)]  
  
 Nachdem Sie die Webseite in einem Browser geladen haben, klicken Sie auf die **Anzeigemodus** Dropdownlisten-Steuerelement, und wählen **verbinden** Verbinden-Modus zu wechseln. Verbinden Sie-Modus verwendet die `<asp:connectionszone>` Element, um Verbindungen zwischen Steuerelementen erstellen können. Im Modus verbinden, klicken Sie auf den Pfeil nach unten in der Titelleiste des der **Postleitzahl** Steuerelement, um seine Verbmenü aktivieren, und klicken Sie dann auf **verbinden**. Beachten Sie, dass durch den Code in den bereits eine Verbindung erstellt wurde, nachdem die Verbindungs-Benutzeroberfläche (UI) angezeigt wird, die `Page_Load` Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanConnectWebParts">
      <MemberSignature Language="C#" Value="public virtual bool CanConnectWebParts (System.Web.UI.WebControls.WebParts.WebPart provider, System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPart consumer, System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPartTransformer transformer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanConnectWebParts(class System.Web.UI.WebControls.WebParts.WebPart provider, class System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPart consumer, class System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPartTransformer transformer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ProviderConnectionPoint,System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint,System.Web.UI.WebControls.WebParts.WebPartTransformer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanConnectWebParts(System::Web::UI::WebControls::WebParts::WebPart ^ provider, System::Web::UI::WebControls::WebParts::ProviderConnectionPoint ^ providerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPart ^ consumer, System::Web::UI::WebControls::WebParts::ConsumerConnectionPoint ^ consumerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPartTransformer ^ transformer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="providerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
        <Parameter Name="consumer" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="consumerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
        <Parameter Name="transformer" Type="System.Web.UI.WebControls.WebParts.WebPartTransformer" />
      </Parameters>
      <Docs>
        <param name="provider">Das Steuerelement, das Daten für <c>consumer</c> bereitstellt, wenn die Steuerelemente miteinander verbunden sind.</param>
        <param name="providerConnectionPoint">Ein <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" />, der als Rückrufmethode fungiert, damit <c>provider</c> an einer Verbindung teilnehmen kann.</param>
        <param name="consumer">Das Steuerelement, das Daten von <c>provider</c> empfängt, wenn die Steuerelemente miteinander verbunden sind.</param>
        <param name="consumerConnectionPoint">Ein <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" />, der als Rückrufmethode fungiert, damit <c>consumer</c> an einer Verbindung teilnehmen kann.</param>
        <param name="transformer">Ein <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" />, der eine Verbindung zwischen einem inkompatiblen <c>provider</c>-Objekt und <c>consumer</c> ermöglicht.</param>
        <summary>Prüft die <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />-Steuerelemente, die an einer Verbindung teilnehmen sollen, um zu bestimmen, ob diese verbunden werden können, und erstellt mithilfe eines <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" />-Objekts eine Verbindung zwischen einem nicht kompatiblen Consumer und Anbieter.</summary>
        <returns>Ein boolescher Wert, der angibt, ob <paramref name="provider" /> und <paramref name="consumer" /> eine Verbindung bilden können.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird verwendet, um eine Verbindung herstellen `provider` und `consumer` Wenn beide Steuerelemente inkompatible Verbindungspunkttypen verfügen, damit ein <xref:System.Web.UI.WebControls.WebParts.WebPartTransformer> Objekt ist erforderlich. Möglicherweise möchten Sie diese Methode verwenden, um sicherzustellen, dass die beiden Steuerelemente vor dem Aufruf verbunden werden können <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A> eine programmgesteuerte Verbindung zu erstellen.  
  
 Diese Überladung verwendet dieselbe Implementierung wie die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%28System.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ProviderConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ConsumerConnectionPoint%29> methodenüberladung mit die einzige Ausnahme, dass diese Überladung einen Transformer benötigt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CatalogDisplayMode">
      <MemberSignature Language="C#" Value="public static readonly System.Web.UI.WebControls.WebParts.WebPartDisplayMode CatalogDisplayMode;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Web.UI.WebControls.WebParts.WebPartDisplayMode CatalogDisplayMode" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CatalogDisplayMode As WebPartDisplayMode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ CatalogDisplayMode;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt den Anzeigemodus dar, in dem Serversteuerelemente aus einem Katalog von Steuerelementen einer Seite hinzugefügt werden. Dieses Feld ist schreibgeschützt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode> Feld verweist auf ein benutzerdefiniertes <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> -Objekt, das erstellt und enthalten die <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Steuerelement. Da dies ein statisches Objekt ist, finden Sie es direkt über die <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Klasse ohne eine Instanz des Steuerelements.  
  
 Wenn Benutzer möchten auf eine Seite, das Hinzufügen von Steuerelementen, wenn ein Katalog von Serversteuerelementen verfügbar ist, können sie die Seite wechseln <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode> (Katalogmodus), und die Katalog-Benutzeroberfläche (UI) wird angezeigt. Die Benutzeroberfläche für eine Webparts-Katalog wird bereitgestellt, indem eine <xref:System.Web.UI.WebControls.WebParts.CatalogZoneBase> zone Steuerelement. Entwickler fügen diese Zone der Seite zur Entwurfszeit und Serversteuerelemente klicken Sie dann auf die Zone hinzufügen, sodass Benutzer können diese Steuerelemente auf den Seiten zur Laufzeit hinzufügen, werden. Nachdem der Entwickler diese Steuerelemente hinzugefügt, wird Katalogmodus einen unterstützten Anzeigemodus auf der Seite, da die erforderlichen Steuerelemente vorhanden sind, Katalogmodus zu aktivieren.  
  
 Wenn ein Benutzer Schaltet eine Seite, um die Katalog-Modus, der Zone und die Serversteuerelemente, die sichtbar hinzugefügt wurden und der Benutzer kann Steuerelemente aus dem Katalog auf der Seite hinzufügen oder Entfernen von Steuerelementen auf der Seite auswählen. Nachdem Sie die Steuerelemente auf der Seite hinzugefügt wurden, wird sie im normalen Durchsuchenmodus angezeigt, und die Seite aktualisiert wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode> programmgesteuert Feld. Der Code füllt eine Dropdownliste mit den unterstützten Anzeigemodi für die Seite durchsuchen, Entwurf und Katalog in diesem Fall sind. Der Katalogmodus ist verfügbar, weil die `<asp:CatalogZone>` Element und seinen untergeordneten Elementen auf der Webseite. Beachten Sie, dass der `Page_PreRender` -Methode, die dem Code wird überprüft, ob die aktuelle <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> -Eigenschaftensatz auf <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode>. Wenn dies der Fall ist, `Label1` werden angezeigt, und falls nicht, `Label1` wird ausgeblendet.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_CatalogDisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CatalogDisplayMode/CS/wpmgrCatalogDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_CatalogDisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CatalogDisplayMode/VB/wpmgrCatalogDisplayModevb.aspx#1)]  
  
 Nachdem Sie die Seite in einem Browser geladen haben, können Sie im Durchsuchenmodus standardmäßig. Beachten Sie, dass die Bezeichnung auf der Seite ausgeblendet ist. Verwenden Sie das Dropdownlisten-Steuerelement auf um der Seite ", Katalogmodus zu wechseln. Beachten Sie, dass aufgrund des Codes in der `Page_PreRender` -Methode, die die Bezeichnung ist jetzt sichtbar. Sie können wählen Sie das Steuerelement im Katalog, und fügen Sie es, die einer von beiden Zonen auf der Seite hinzu.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />
      </Docs>
    </Member>
    <Member MemberName="CheckRenderClientScript">
      <MemberSignature Language="C#" Value="protected virtual bool CheckRenderClientScript ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool CheckRenderClientScript() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CheckRenderClientScript" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CheckRenderClientScript () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool CheckRenderClientScript();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Prüft die Funktionen des Browsers, von dem die Anforderung stammt, sowie den Wert der <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript" />-Eigenschaft, um festzustellen, ob Clientskripts wiedergegeben werden sollen.</summary>
        <returns>Ein boolescher Wert, der angibt, ob Clientskripts wiedergegeben werden sollen.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript" />
      </Docs>
    </Member>
    <Member MemberName="CloseProviderWarning">
      <MemberSignature Language="C#" Value="public virtual string CloseProviderWarning { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CloseProviderWarning" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property CloseProviderWarning As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ CloseProviderWarning { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Warnung ab, die angezeigt wird, wenn ein Benutzer ein Steuerelement schließt, das als Anbieter für andere Steuerelemente in einer Verbindung fungiert, oder legt diese Warnung fest.</summary>
        <value>Eine Zeichenfolge, die die Warnmeldung enthält. Der Standardwert ist eine von .NET Framework bereitgestellte kulturspezifische Meldung.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein Benutzer schließt eine <xref:System.Web.UI.WebControls.WebParts.WebPart> steuern, die normalerweise keine Meldung angezeigt wird. Weitere Informationen zum Schließen von Steuerelementen finden Sie unter der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A> Methode.  
  
 Jedoch, wenn ein Steuerelement auf ein anderes Steuerelement verbunden ist und als Anbieter von Daten in die Steuerelemente fungiert, wird ein Standardtext für die Warnung angezeigt, wenn ein Benutzer versucht, das Steuerelement zu schließen. Die Nachricht weist die Benutzer, dass ein Anbietersteuerelement zu schließen, der bedeutet, die steuert, zu diesem Anbieter verbunden wird wird, als Consumer anzuzeigenden Daten nutzen nicht mehr verfügbar. Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning%2A> Eigenschaft ermöglicht Entwicklern die Warnmeldung anpassen, die dem Benutzer angezeigt wird.  
  
 Wenn ein Entwickler diese Eigenschaft eine leere oder null-Zeichenfolge zuweist, wird keine Warnhinweisfeld angezeigt, wenn ein Benutzer schließt eine <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelement, das einen Anbieter.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning%2A> Eigenschaft, um Benutzern eine benutzerdefinierte Warnung anzuzeigen.  
  
 Das Codebeispiel besteht aus vier Teilen:  
  
-   Ein Benutzersteuerelement, das Ihnen ermöglicht, ändern Sie die Anzeigemodi auf einer Webparts-Seite.  
  
-   Eine Quellcodedatei, die zwei benutzerdefinierte enthält <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelemente und eine benutzerdefinierte Schnittstelle.  
  
-   Eine Webseite mit zwei benutzerdefinierte <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelemente, die verbunden werden können und ein `<asp:webpartmanager>` Element.  
  
-   Eine Erläuterung der Funktionsweise des Beispiels in einem Browser.  
  
 Der folgende Code enthält nur die Webseite Teil des Beispiels. Sie benötigen außerdem des benutzerdefinierten Benutzersteuerelements und der Quellcode für die benutzerdefinierten Steuerelemente, die oben genannten. Rufen Sie diese zwei Elemente im Abschnitt "Beispiel" von der <xref:System.Web.UI.WebControls.WebParts.WebPartManager> -Klassenübersicht.  
  
 Der folgende Code der Webseite veranschaulicht, wie eine benutzerdefinierte Warnmeldung zum Zuweisen der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning%2A> Eigenschaft in deklarativem Markup in der `<asp:webpartmanager>` Element.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_CloseProviderWarning#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CloseProviderWarning/CS/webpartmanagerConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_CloseProviderWarning#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CloseProviderWarning/VB/webpartmanagerConnectionVB.aspx#1)]  
  
 Nachdem Sie die Webseite in einem Browser geladen haben, klicken Sie auf die **Anzeigemodus** Dropdownlisten-Steuerelement, und wählen **verbinden** Verbinden-Modus zu wechseln. Verbinden Sie-Modus verwendet die `<asp:connectionszone>` Element, um Verbindungen zwischen Steuerelementen erstellen können. Im Modus verbinden, klicken Sie auf den Pfeil nach unten in der Titelleiste des der **Postleitzahl** Steuerelement, um seine Verbmenü aktivieren, und klicken Sie dann auf **verbinden**. Nachdem die Verbindungs-Benutzeroberfläche (UI) angezeigt wird, klicken Sie auf die **erstellen Sie eine Verbindung mit einem Consumer** Link. Eine Zelle angezeigt wird, die über ein Dropdown-Listenfeld-Steuerelement verfügt. Wählen Sie **Weather Control** in der Dropdownliste aus, und klicken Sie auf auf **verbinden** zum Herstellen die Verbindung der beiden Steuerelemente. Klicken Sie auf **schließen**, und verwenden Sie dann die **Anzeigemodus** Dropdown-Liste aus, um die Seite zum normalen Durchsuchen-Modus zurückkehren. Klicken Sie abschließend auf das Menü für die Verben für die **Postleitzahl** steuern (Dies ist das Anbietersteuerelement in diesem Fall), und wählen Sie **schließen**. Die benutzerdefinierte Meldung zugeordnet wurden, die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning%2A> Eigenschaft wird angezeigt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloseWebPart">
      <MemberSignature Language="C#" Value="public void CloseWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CloseWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CloseWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">Ein <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />-Steuerelement oder Serversteuerelement, das in einer <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> geschlossen wird.</param>
        <summary>Schließt ein <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />-Steuerelement, sodass es auf einer Webseite zwar nicht wiedergegeben wird, aber erneut geöffnet werden kann.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A> -Methode entfernt einen <xref:System.Web.UI.WebControls.WebParts.WebPart> oder andere Server steuern, sodass er nicht auf der Webseite gerendert wird, die es ursprünglich enthalten. Das geschlossene Steuerelement hinzugefügt wird ein <xref:System.Web.UI.WebControls.WebParts.PageCatalogPart> -Objekt, das behält einen Verweis auf das Steuerelement geschlossen und ermöglicht es für das Steuerelement auf der Seite wiederhergestellt werden. Geschlossene <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelement weiterhin angezeigt wird, in der Auflistung verweist die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> Eigenschaft.  
  
 Schließen eines Steuerelements unterscheidet sich von löschen. Geschlossenen Steuerelemente sind immer noch verfügbar ist, auf eine Seite wiederhergestellt werden, aber eine gelöschte Instanz eines Steuerelements wird dauerhaft gelöscht und kann nicht wiederhergestellt werden. Unabhängig davon, ob eine <xref:System.Web.UI.WebControls.WebParts.WebPart> oder Serversteuerelement (deklariert in das Markup der Seite) statisch oder dynamisch (Seite entweder programmgesteuert oder durch einen Benutzer aus einem Webparts-Katalog hinzugefügt), geschlossen und erneut auf einer Seite geöffnet werden kann.  
  
 Benutzer können in der Regel schließen ein <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelement, indem seine Verbmenü und das Verb schließen. Ein Steuerelement kann auch geschlossen werden, durch den direkten Aufruf der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A> -Methode und übergeben sie einen Verweis auf `webPart`.  
  
 Auf einer Seite, auf dem <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelemente geschlossen wurden, wenn ein Entwickler deklariert eine `<asp:catalogzone>` Element, und fügt Sie darin ein `<asp:pagecatalogpart>` Element, es bietet eine einfache Benutzeroberfläche (UI) zum Wiederherstellen von geschlossenen Steuerelemente auf der Seite zur Laufzeit. Benutzer können die Seite in den Kataloganzeigemodus wechseln und den Seitenkatalog die geschlossenen Steuerelemente angezeigt. Benutzer hinzufügen und wählen Sie die geschlossenen Steuerelemente können wieder an die Seite an einer beliebigen Position sie erhalten möchten, und klicken Sie dann der ausgewählten Steuerelemente auf der Seite wiederhergestellt werden, und wie gewohnt gerendert.  
  
 Wenn die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A> -Methode aufgerufen wird, löst Sie mehrere Ereignisse: <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging> (wenn es mehrere Steuerelemente sind), und <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> (wenn es verbundenen Steuerelemente). Normalerweise können Entwickler diese Ereignisse abbrechen, aber in bestimmten Fällen ist es nicht möglich, die sie "Abbrechen". Einzelheiten finden Sie in der Dokumentation für die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging>, und <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> Ereignisse.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt, wie Sie die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A>-Methode verwenden.  
  
 Das Codebeispiel besteht aus vier Teilen:  
  
-   Ein Benutzersteuerelement, das Sie Seitenanzeigemodi ändern kann.  
  
-   Eine benutzerdefinierte <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelement.  
  
-   Eine Webseite.  
  
-   Eine Erläuterung der Funktionsweise des Beispiels in einem Browser.  
  
 Der erste Teil des Codebeispiels wird das Benutzersteuerelement zum Ändern des Anzeigemodus. Sie können den Quellcode für das Benutzersteuerelement abrufen, der im Abschnitt "Beispiel" die <xref:System.Web.UI.WebControls.WebParts.WebPartManager> -Klassenübersicht. Weitere Informationen zu Anzeigemodi und zur Funktionsweise des Benutzersteuerelements, finden Sie unter [Exemplarische Vorgehensweise: Ändern des Anzeigemodus auf einer Webparts-Seite](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0).  
  
 Der zweite Teil des Codebeispiels wird die benutzerdefinierte <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelement. Für das Codebeispiel ausführen müssen Sie diesen Quellcode kompilieren. Sie können es explizit kompilieren und legen Sie die resultierende Assembly im Bin-Ordner der Website oder dem globalen Assemblycache. Alternativ können Sie den Quellcode im Ordner "App_Code" des Standorts, ablegen, wo er zur Laufzeit dynamisch kompiliert wird. Dieses Beispiel verwendet die Methode der dynamischen Kompilierung. Es gibt also keine `Assembly` Attribut in der `Register` Richtlinie für dieses Steuerelement am oberen Rand der Webseite. Eine exemplarische Vorgehensweise zum Kompilieren, veranschaulicht, finden Sie unter [Exemplarische Vorgehensweise: Entwickeln und Verwenden eines benutzerdefinierten Webserver-Steuerelements](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08).  
  
 [!code-csharp[WebParts_WebPartManager_CloseWebPart#3](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CloseWebPart/CS/textdisplaywebpart.cs#3)]
 [!code-vb[WebParts_WebPartManager_CloseWebPart#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CloseWebPart/VB/textdisplaywebpart.vb#3)]  
  
 Der dritte Teil des Codebeispiels wird die Webseite. Diese Seite enthält eine <xref:System.Web.UI.WebControls.WebParts.CatalogZone> Zone mit einem <`asp:pagecatalogpart>` -Element deklariert ist. Dies ist, was geschlossenen enthält <xref:System.Web.UI.WebControls.WebParts.WebPart> steuern und Benutzern ermöglichen, sie wieder zur Seite hinzuzufügen. Die `Button1_Click` direkt Methodenaufrufe der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A> Methode, um das benutzerdefinierte <xref:System.Web.UI.WebControls.WebParts.WebPart> steuern, auch wenn ein Benutzer das Steuerelement über das Verbenmenü auch schließen kann.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_CloseWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CloseWebPart/CS/closeWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_CloseWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CloseWebPart/VB/closeWebPartVB.aspx#1)]  
  
 Nachdem Sie die Seite in einem Browser geladen haben, schließen Sie die benutzerdefinierte <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelement, indem Sie auf Verbmenü (das Pfeilsymbol) im Header des Steuerelements, und klicken Sie auf **schließen**. Die Seite jetzt in den Katalogmodus ändern, indem Sie auswählen **Katalog** in der **Anzeigemodus** Dropdownlisten-Steuerelement. Der Seitenkatalog wird mit dem geschlossenen Steuerelement angezeigt. Wählen Sie das Kontrollkästchen neben dem geschlossenen Steuerelement aus, klicken Sie auf **hinzufügen** auf der Seite hinzugefügt wird, und klicken Sie dann auf **schließen** in den Durchsuchen-Modus zurück. Das Steuerelement wird auf der Seite "wiederhergestellt. Schließen Sie es erneut, diesmal durch Klicken auf die **WebPart schließen** Schaltfläche.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="webPart" /> ist nicht in der <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" />-Auflistung enthalten.  
  
 \- oder –  
  
 <paramref name="webPart" /> ist ein freigegebenes Steuerelement und wurde bereits von einem anderen Benutzer geschlossen.</exception>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.AllowClose" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.IsClosed" />
      </Docs>
    </Member>
    <Member MemberName="ConnectDisplayMode">
      <MemberSignature Language="C#" Value="public static readonly System.Web.UI.WebControls.WebParts.WebPartDisplayMode ConnectDisplayMode;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Web.UI.WebControls.WebParts.WebPartDisplayMode ConnectDisplayMode" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ConnectDisplayMode As WebPartDisplayMode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ ConnectDisplayMode;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt den Anzeigemodus dar, in dem eine spezielle Benutzeroberfläche dargestellt wird, in der Benutzer Verbindungen zwischen <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />-Steuerelementen verwalten. Dieses Feld ist schreibgeschützt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode> Feld verweist auf ein benutzerdefiniertes <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> -Objekt, das erstellt und enthalten die <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Steuerelement. Da dies ein statisches Objekt ist, finden Sie es direkt über die <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Klasse ohne eine Instanz des Steuerelements.  
  
 Wenn Benutzer Verbindungen zwischen verwalten möchten <xref:System.Web.UI.WebControls.WebParts.WebPart> auf einer Webseite gesteuert werden, wenn eine <xref:System.Web.UI.WebControls.WebParts.ConnectionsZone> Zone auf der Seite deklariert wurde, können sie die Seite in Wechseln der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode> Modus. Die Connect-Anzeigemodus zeigt eine spezielle Benutzeroberfläche zum Verwalten von Verbindungen, darunter die Möglichkeit, eine Verbindung herstellen oder Trennen von Steuerelementen, und so bearbeiten Sie die Details der vorhandenen Verbindungen.  
  
 Wenn Sie Benutzern die Möglichkeit zum Verwalten von Verbindungen mit der Benutzeroberfläche von Webparts-Steuerelementsatzes bereitgestellten bereitstellen möchten, müssen Sie deklarieren eine `<asp:connectionszone>` Element im Markup der Seite. Im Gegensatz zu den Elementen für die anderen Typen von <xref:System.Web.UI.WebControls.WebParts.WebZone> Zonen, Sie müssen nicht in dieses Element keine weiteren Tags hinzufügen, deklarieren Sie einfach das Element selbst.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode> Modus.  
  
 Das Codebeispiel besteht aus drei Teilen:  
  
-   Eine Quelldatei, die eine Schnittstelle und benutzerdefinierte enthält <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelemente, die eine Verbindung bilden können.  
  
-   Eine Webseite, bietet eine Benutzeroberfläche für Verbindungen und Arbeiten mit veranschaulicht, die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode> Modus.  
  
-   Eine Erläuterung zum Ausführen des Beispiels.  
  
 Der erste Teil des Codebeispiels ist eine Quelldatei, die eine Schnittstelle und zwei benutzerdefinierte enthält <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelemente, die entwickelt wurden, damit sie miteinander verbunden werden können. Für das Codebeispiel ausführen müssen Sie diesen Quellcode kompilieren. Sie können es explizit kompilieren und legen Sie die resultierende Assembly im Bin-Ordner der Website oder dem globalen Assemblycache. Alternativ können Sie den Quellcode im Ordner "App_Code" des Standorts, ablegen, wo er zur Laufzeit dynamisch kompiliert wird. Dieses Codebeispiel verwendet die Methode der dynamischen Kompilierung. Eine exemplarische Vorgehensweise zum Kompilieren, veranschaulicht, finden Sie unter [Exemplarische Vorgehensweise: Entwickeln und Verwenden eines benutzerdefinierten Webserver-Steuerelements](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08).  
  
 [!code-csharp[WebParts_WebPartManager_ConnectDisplayMode#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectDisplayMode/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_ConnectDisplayMode#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectDisplayMode/VB/ZipCodeComponent.vb#2)]  
  
 Der zweite Teil des Beispiels wird eine Webseite, die die benutzerdefinierten Steuerelemente hostet. Innerhalb des Servers `<script>` Tags auf der Seite werden verschiedene Methoden für das Auffüllen eine Dropdownliste mit den auf der Seite verfügbaren Anzeigemodi. Benutzer kann diese aus der Dropdown-Liste so ändern Sie die Seite Anzeigemodus auswählen. Einer der verfügbaren Anzeigemodi ist Anzeigemodus, eine Verbindung herstellen, da ein `<asp:connectionszone>` Element im Markup der Seite deklariert ist. Beachten Sie, dass dieses Element keine untergeordneten Elemente enthält. Es dient nur dazu, um die Verwaltung von Datenbankverbindungen Benutzeroberfläche für Benutzer zu aktivieren.  
  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode> Modus wird in diesem Beispiel an zwei Orten angezeigt. Zunächst in der `Page_Init` -Methode, der Verbindungsanzeigemodus der Dropdown-Liste der Anzeigemodi, hinzugefügt wird, als der Code durchläuft die Auflistung verwiesen wird, der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> Eigenschaft. Zweitens die `Page_PreRender` Methode überprüft, ob den aktuelle Anzeigemodus auf der Seite und wenn der aktuelle Modus ist <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>, wird eine Meldung angezeigt, einem <xref:System.Web.UI.WebControls.Label> Steuerelement.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_ConnectDisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectDisplayMode/CS/ConnectDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_ConnectDisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectDisplayMode/VB/ConnectDisplayModeVB.aspx#1)]  
  
 Nachdem Sie die Seite in einem Browser geladen haben, klicken Sie auf die Dropdown-Liste, und wählen Sie **verbinden** So wechseln Sie die Seite in den Anzeigemodus für die Verbindung herstellen. Beachten Sie, dass eine darüber informiert Meldung, dass die Seite im Anzeigemodus verbinden. Klicken Sie nun auf die Verbmenü (ein Pfeilsymbol) in der Titelleiste eines der <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelemente, und klicken Sie dann auf **verbinden** im Verbmenü. Klicken Sie nachdem die Verbindung, die Benutzeroberfläche angezeigt wird auf den Link, um eine Verbindung zu erstellen. Verwenden Sie die Dropdown-Liste innerhalb der Verbindung UI, der angezeigt wird, wählen Sie die Steuerelemente, die die Verbindung beteiligt, und klicken Sie auf die **verbinden** Schaltfläche. Die Verbindung hergestellt wird. Klicken Sie auf die **schließen** Schaltfläche, und dann mithilfe die Dropdown Liste am oberen Rand der Seite die Informationen zum Durchsuchen der Anzeigemodus zurückzugeben.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />
      </Docs>
    </Member>
    <Member MemberName="Connections">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartConnectionCollection Connections { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartConnectionCollection Connections" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Connections" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Connections As WebPartConnectionCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ Connections { System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Verweis auf die Auflistung aller aktuellen Verbindungen auf einer Webseite ab.</summary>
        <value>Eine <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionCollection" />, die einen Satz von <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" />-Objekten enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Connections%2A> Eigenschaft bietet eine Möglichkeit, den aktuellen Satz von Verbindungen auf einer Seite zugreifen. Die Auflistung an sich schreibgeschützt ist, und Entwickler, die eine bestimmte Verbindung aus der Auflistung bearbeiten möchten, sollten verwenden <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Methoden, z. B. <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A> und <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht deklarative und die programmgesteuerte Verwendung von der <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Steuerelement.  
  
 Das Codebeispiel besteht aus vier Teilen:  
  
-   Ein Benutzersteuerelement, das Ihnen ermöglicht, ändern Sie die Anzeigemodi auf einer Webparts-Seite.  
  
-   Eine Webseite mit zwei benutzerdefinierte <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelemente, die verbunden werden können, und ein `<asp:webpartmanager>` Element.  
  
-   Eine Quellcodedatei, die zwei benutzerdefinierte enthält <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelemente und eine benutzerdefinierte Schnittstelle.  
  
-   Eine Erläuterung der Funktionsweise des Beispiels in einem Browser.  
  
 Der folgende Code enthält nur die Webseite Teil des Beispiels. Sie benötigen außerdem des benutzerdefinierten Benutzersteuerelements und der Quellcode für die benutzerdefinierten Steuerelemente, die oben genannten. Rufen Sie diese zwei Elemente im Abschnitt "Beispiel" von der <xref:System.Web.UI.WebControls.WebParts.WebPartManager> -Klassenübersicht.  
  
 Der folgende Code für die Webseite veranschaulicht, wie die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Connections%2A> -Eigenschaft programmgesteuert auf die Anzahl von aktuellen Verbindungen auf einer Seite abzurufen. Beachten Sie, dass in der `<script>` Tag-Abschnitt, der Code zum Behandeln von zwei Ereignissen für die <xref:System.Web.UI.WebControls.WebParts.WebPartManager> steuern greift auf die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Connections%2A> Eigenschaft, um die Anzahl der zu erhalten.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_SimpleConnection#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/CS/webpartmanagerConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_SimpleConnection#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/VB/webpartmanagerConnectionVB.aspx#1)]  
  
 Nachdem Sie die Webseite in einem Browser geladen haben, klicken Sie auf die **Anzeigemodus** Dropdownlisten-Steuerelement, und wählen **verbinden** Verbinden-Modus zu wechseln. Verbinden Sie-Modus verwendet die `<asp:connectionszone>` Element, um Verbindungen zwischen Steuerelementen erstellen können. Im Modus verbinden, klicken Sie auf den Pfeil nach unten in der Titelleiste des der **Postleitzahl** Steuerelement, um seine Verbmenü aktivieren, und klicken Sie dann auf **verbinden**. Nachdem die Verbindungs-Benutzeroberfläche (UI) angezeigt wird, klicken Sie auf die **erstellen Sie eine Verbindung mit einem Consumer** Link. Eine Zelle angezeigt wird, die über ein Dropdown-Listenfeld-Steuerelement verfügt. Wählen Sie **Weather Control** in der Dropdownliste aus, und klicken Sie auf auf **verbinden** zum Herstellen die Verbindung der beiden Steuerelemente. Klicken Sie auf **schließen**, und verwenden Sie dann die **Anzeigemodus** Dropdown-Liste aus, um die Seite zum normalen Durchsuchen-Modus zurückkehren. Beachten Sie, dass eine Bezeichnung nun die Anzahl der Verbindungen und die Anzahl der zeigt <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelemente. Wenn Sie nun zurückkehren, um Verbindungsmodus, und trennen Sie die beiden steuert, wenn Sie auf die Durchsuchen-Modus zurückkehren, des Bezeichnungsfelds Inhalt aktualisiert werden soll, und es darf keine Verbindungen.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" />
      </Docs>
    </Member>
    <Member MemberName="ConnectionsActivated">
      <MemberSignature Language="C#" Value="public event EventHandler ConnectionsActivated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ConnectionsActivated" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ConnectionsActivated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ConnectionsActivated;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, nachdem nicht nur alle aktuellen Webparts-Verbindungen auf einer Seite verbunden wurden, sondern diese auch begonnen haben, Daten aktiv zwischen den an den einzelnen Verbindungen beteiligten Consumer- und Anbietersteuerelementen auszutauschen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis tritt des Lebenszyklus von Verbindungen nachdem eine Seite der Ladevorgang abgeschlossen ist. Sie kommt auch nach der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected> -Ereignis, das nur das gibt an der <xref:System.Web.UI.WebControls.WebParts.WebPart> oder Serversteuerelemente, die in einer bestimmten Verbindung erfolgreich hergestellt haben. In einem Fall mehrere Verbindungen auf einer Seite sind die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated> Methode gibt an, dass alle gültigen Webparts-Verbindungen auf einer Seite jetzt aktiv ist und die Daten gemeinsam nutzen. Zu wissen, dass alle Verbindungen aktiv sind, können Entwickler führen Sie eine beliebige Anzahl von Aufgaben, einschließlich der Benachrichtigung der Benutzer über den Status der Verbindungen benachrichtigen Consumer-Steuerelementen zu verarbeiten und Anzeigen von Daten aus den Anbietern und so weiter.  
  
 Dieses Ereignis zugeordnet ist die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated%2A> -Methode, die das Ereignis auslöst, und ermöglicht es Entwicklern, benutzerdefinierte Handler für das Ereignis zu erstellen.  
  
 Entwickler von Seiten können einen benutzerdefinierten Handler für das Ereignis erstellen, durch Hinzufügen der `OnConnectionsActivated` -Attribut auf die `<asp:webpartmanager>` Element auf der Seite, und weisen Sie dann einen Namen für die benutzerdefinierte Methode für das Attribut.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated(System.EventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating" />
      </Docs>
    </Member>
    <Member MemberName="ConnectionsActivating">
      <MemberSignature Language="C#" Value="public event EventHandler ConnectionsActivating;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ConnectionsActivating" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ConnectionsActivating As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ConnectionsActivating;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, während alle erstellten Webparts-Verbindungen auf einer Webseite aktiviert werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Lebenszyklus von Verbindungen, dieses Ereignis tritt auf, wie eine Seite kurz vor dem Ausführen der Ladevorgang abgeschlossen wird die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A> -Methode aufgerufen wird. Es unterscheidet sich von der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting> Ereignis, das eine bestimmte Verbindung zwischen betrifft <xref:System.Web.UI.WebControls.WebParts.WebPart> oder andere Serversteuerelemente. Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating> Ereignis tritt auf, wenn alle möglichen Verbindungen auf einer Seite angeschlossen wurden und aktiviert werden sollen.  
  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating> Ereignis zugeordnet ist die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating%2A> -Methode, die das Ereignis auslöst. Entwickler von Steuerelementen, die auf den Typ von Verbindungen zu erweitern, die auf eine Seite hinzugefügt werden können möchten konnte überschreiben Sie die geschützte <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating%2A> Methode und weitere Typen von Verbindungen zu aktivieren.  
  
 Entwickler von Seiten können einen benutzerdefinierten Handler für das Ereignis erstellen, durch Hinzufügen der `OnConnectionsActivating` -Attribut auf die `<asp:webpartmanager>` Element auf der Seite, und weisen Sie dann einen Namen für die benutzerdefinierte Methode für das Attribut.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating(System.EventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ConnectWebParts">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt eine Verbindung zwischen zwei <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />-Steuerelementen (oder sonstigen Serversteuerelementen, die Verbindungen bilden können), die sich in einer <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />-Zone befinden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A> Methode bildet eine Verbindung zwischen zwei beliebigen <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelemente, die verbunden werden können. Vor dem Aufrufen dieser Methode, um eine Verbindung zu erstellen, kann auch aufgerufen werden soll die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A> Methode in einer bedingten stellen Sie sicher, dass die Steuerelemente den Anforderungen zum Herstellen einer Verbindung.  
  
> [!NOTE]
>  Es ist auch möglich, eine Verbindung zwischen zwei Serversteuerelemente zu erstellen, die nicht <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelemente. Im Allgemeinen die beiden Steuerelemente benutzerdefinierte Serversteuerelemente sein müsste (z. B. die Steuerelemente, die von erben <xref:System.Web.UI.WebControls.WebControl> oder vorhandene ASP.NET-Serversteuerelemente), damit Sie die erforderlichen Elemente hinzufügen können. Die Steuerelemente würde auch die unten angegebenen erfüllt haben.  
  
 Jede Art von Szenario mit einer Verbindung zwischen zwei Steuerelementen muss eine Verbindung herstellen, werden die folgenden Anforderungen erfüllen:  
  
-   Jedes Steuerelement befindet sich in einem <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> Zone (es muss nicht in derselben Zone).  
  
-   Wie in der Webparts-Steuerelementsatz implementiert, implementiert das Anbietersteuerelement in einer Verbindung eine Schnittstelle als öffentliche Methode, die als Rückruf an den Anbieter fungiert, und es wurde eine `ConnectionProvider` Metadatenattribut auf die Methode, die sie als eine anbieterverbindung zu kennzeichnen Zeigen Sie. Da die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints%2A> -Methode, die Anbieter-Verbindungspunkte ruft virtuell ist, ein abgeleiteter <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Steuerelement nicht unbedingt das gleiche Metadatenattribut verwenden.  
  
-   Wie in der Webparts-Steuerelementsatz implementiert wird, hat der Consumer-Steuerelement in einer Verbindung auch eine besondere Methode, die zum Abrufen eines Verweises auf die Schnittstelle, die Rückrufmethode für den Anbieter verfügbar gemacht werden kann, und der Consumer hat eine `ConnectionConsumer` Metadatenattribut auf Zeigen Sie die Methode, die sie als eine Consumerverbindungspunkt zu kennzeichnen. Da die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints%2A> Methode, ruft Consumer-Verbindungspunkte ist virtuell, ein abgeleiteter <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Steuerelement nicht unbedingt das gleiche Metadatenattribut verwenden.  
  
-   Die Rückrufmethoden müssen entweder kompatibel sein, der Consumer den Typ des verwenden kann Schnittstelle bereitgestellt, in der Anbieter die Rückrufmethode (d. h., dass der Consumer- und die Daten direkt freigeben können), oder der Entwickler muss ein <xref:System.Web.UI.WebControls.WebParts.WebPartTransformer> -Objekt hinzu Transformieren von Daten des Anbieters in ein Formular, das vom Consumer verwendet werden kann.  
  
    > [!IMPORTANT]
    >  Wenn Sie nicht über eine Transformer benötigen, verwenden Sie die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%28System.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ProviderConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ConsumerConnectionPoint%29> -methodenüberladung. Wenn Sie einen Transformer benötigen, verwenden die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%28System.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ProviderConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ConsumerConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPartTransformer%29> -methodenüberladung.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts" />
      </Docs>
    </MemberGroup>
    <Member MemberName="ConnectWebParts">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartConnection ConnectWebParts (System.Web.UI.WebControls.WebParts.WebPart provider, System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPart consumer, System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.UI.WebControls.WebParts.WebPartConnection ConnectWebParts(class System.Web.UI.WebControls.WebParts.WebPart provider, class System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPart consumer, class System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ProviderConnectionPoint,System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::UI::WebControls::WebParts::WebPartConnection ^ ConnectWebParts(System::Web::UI::WebControls::WebParts::WebPart ^ provider, System::Web::UI::WebControls::WebParts::ProviderConnectionPoint ^ providerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPart ^ consumer, System::Web::UI::WebControls::WebParts::ConsumerConnectionPoint ^ consumerConnectionPoint);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="providerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
        <Parameter Name="consumer" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="consumerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
      </Parameters>
      <Docs>
        <param name="provider">Ein <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />-Steuerelement, das die Funktion erfüllt, Daten für ein anderes, mit ihm verbundenes Steuerelement bereitzustellen.</param>
        <param name="providerConnectionPoint">Eine Methode, die als Rückrufmethode für die Verbindung fungiert. Entsprechend der Implementierung im Webparts-Steuerelementsatz ist dies eine öffentliche Methode in <c>provider</c>, die mit einem <see langword="ConnectionProvider" />-Metadatenattribut gekennzeichnet ist.</param>
        <param name="consumer">Ein <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />-Steuerelement, das die Funktion erfüllt, Daten von <c>provider</c> zu empfangen und dann zu verarbeiten oder anzuzeigen.</param>
        <param name="consumerConnectionPoint">Eine Methode, die eine Verbindung mit <c>providerConnectionPoint</c> herstellt, um die Daten für die Verbindung zu empfangen. Entsprechend der Implementierung im Webparts-Steuerelementsatz ist dies eine öffentliche Methode in <c>consumer</c>, die mit einem <see langword="ConnectionConsumer" />-Metadatenattribut gekennzeichnet ist.</param>
        <summary>Erstellt nur mithilfe der Verweise auf die Steuerelemente und ihre angegebenen <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />-Objekte eine Verbindung zwischen zwei <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />-Steuerelementen oder <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" />-Steuerelementen.</summary>
        <returns>Eine <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" /> mit den Informationen zum Anbieter und Consumer, die für eine Verbindung benötigt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung wird verwendet, um Steuerelemente zu verbinden, wenn ihre Verbindungspunkte ausreichend kompatibel sind, dass sie ohne eine Verbindung herstellen können eine <xref:System.Web.UI.WebControls.WebParts.WebPartTransformer> Objekt. Wenn diese Überladung der Methode aufgerufen wird, sie einfach den Aufruf an die andere überladene Version der Methode übergibt, und übergibt `null` für den Parameter, benötigt eine <xref:System.Web.UI.WebControls.WebParts.WebPartTransformer> Objekt.  
  
 Wenn Sie versuchen, zwei Steuerelemente programmgesteuert zu verbinden, können Sie die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A> Methode bedingte gesucht wird, um zu bestimmen, ob die Steuerelemente direkt verbunden werden können.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie diese Methode verwendet, um programmgesteuert eine Verbindung zu erstellen. Den vollständigen Code zum Ausführen des Beispiels erforderlich sind, finden Sie im Beispielabschnitt von der <xref:System.Web.UI.WebControls.WebParts.WebPartManager> -Klassenübersicht. Aus diesem Beispiel benötigen Sie den Quellcode für das Benutzersteuerelement, die Sie auf der Seite Anzeigemodi ändern kann, und den Quellcode für die beiden benutzerdefinierten <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelemente.  
  
 Der Code für die Webseite, die die beiden hostet steuert folgt. Die Seite verwendet `Register` -Direktiven am Anfang, das Benutzersteuerelement und die benutzerdefinierten Steuerelemente zu deklarieren. Die benutzerdefinierten Steuerelemente werden dann auf die verwiesen wird deklarativ in einer `<asp:webpartzone>` Element. Der Code, behandelt der `Button1_Click` Methode erstellt eine Verbindung zwischen den Steuerelementen mithilfe der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A> Methode.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_ConnectWebParts1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectWebParts1/CS/wpmgrConnectWebPartsCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_ConnectWebParts1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectWebParts1/VB/wpmgrConnectWebPartsVB.aspx#1)]  
  
 Nachdem Sie die Seite in einem Browser zu laden, klicken Sie auf die **Connect WebPart Controls** Schaltfläche, um die Verbindung zu bilden. Sie können einige Daten in das Textfeld eingeben, und klicken Sie auf die **Geben Sie die Postleitzahl 5 Ziffern** Schaltfläche, um zu veranschaulichen, dass die Steuerelemente verbunden sind, und diese Daten in das erste Steuerelement eingegeben werden in der zweiten aktualisiert.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Auflistung der dynamischen Auflistungen des <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />-Steuerelements ist schreibgeschützt.</exception>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Connections" />
      </Docs>
    </Member>
    <Member MemberName="ConnectWebParts">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.WebPartConnection ConnectWebParts (System.Web.UI.WebControls.WebParts.WebPart provider, System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPart consumer, System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPartTransformer transformer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.WebPartConnection ConnectWebParts(class System.Web.UI.WebControls.WebParts.WebPart provider, class System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPart consumer, class System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPartTransformer transformer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ProviderConnectionPoint,System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint,System.Web.UI.WebControls.WebParts.WebPartTransformer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::WebPartConnection ^ ConnectWebParts(System::Web::UI::WebControls::WebParts::WebPart ^ provider, System::Web::UI::WebControls::WebParts::ProviderConnectionPoint ^ providerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPart ^ consumer, System::Web::UI::WebControls::WebParts::ConsumerConnectionPoint ^ consumerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPartTransformer ^ transformer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="providerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
        <Parameter Name="consumer" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="consumerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
        <Parameter Name="transformer" Type="System.Web.UI.WebControls.WebParts.WebPartTransformer" />
      </Parameters>
      <Docs>
        <param name="provider">Ein <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />, der die Funktion erfüllt, Daten für ein anderes, mit ihm verbundenes Steuerelement bereitzustellen.</param>
        <param name="providerConnectionPoint">Eine öffentliche Methode in <c>provider</c>, die mit einem <see langword="ConnectionProvider" />-Metadatenattribut gekennzeichnet ist und als Rückrufmethode für die Verbindung fungiert.</param>
        <param name="consumer">Ein <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />, der die Funktion erfüllt, Daten von <c>provider</c> oder <c>transformer</c> zu empfangen und dann zu verarbeiten oder anzuzeigen.</param>
        <param name="consumerConnectionPoint">Eine öffentliche Methode in <c>consumer</c>, die mit einem <see langword="ConnectionConsumer" />-Metadatenattribut gekennzeichnet ist und eine Verbindung mit <c>providerConnectionPoint</c> herstellt, um die Daten für die Verbindung zu empfangen.</param>
        <param name="transformer">Ein <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" />, der eine Verbindung zwischen zwei Steuerelementen ermöglicht, indem er die Daten von <c>provider</c> in ein Format konvertiert, das von <c>consumer</c> verarbeitet werden kann.</param>
        <summary>Erstellt mithilfe der Verweise auf die Steuerelemente, ihre angegebenen <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />-Objekte und ein <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />-Objekt eine Verbindung zwischen zwei <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" />-Steuerelementen oder <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" />-Steuerelementen.</summary>
        <returns>Eine <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" />, die die Informationen zum Anbieter, Consumer und Transformator enthält, die für eine Verbindung benötigt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung wird verwendet, um Steuerelemente zu verbinden, wenn ihre Verbindungspunkte nicht kompatibel sind. Die Inkompatibilität tritt auf, wenn `consumer` implementiert eine andere Schnittstelle als `provider` als Verbindung erforderlich. Transformer konvertiert die Daten in einen Typ, der von interpretiert werden kann `consumer`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Verbindungen wurden bereits in <see cref="E:System.Web.UI.Control.PreRender" /> aktiviert.</exception>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Connections" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" />
      </Docs>
    </Member>
    <Member MemberName="Controls">
      <MemberSignature Language="C#" Value="public override System.Web.UI.ControlCollection Controls { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ControlCollection Controls" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Controls As ControlCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::ControlCollection ^ Controls { System::Web::UI::ControlCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ControlCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Auflistung aller <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />-Steuerelemente, Serversteuerelemente oder Benutzersteuerelemente ab, die in <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />-Zonen auf einer Webseite enthalten sind und vom <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />-Steuerelement verwaltet werden.</summary>
        <value>Eine <see cref="T:System.Web.UI.ControlCollection" />, die alle vom <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />-Steuerelement verwalteten Steuerelemente enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Controls%2A> Eigenschaft verweist nicht auf den andere Steuerelemente, die verweist die <xref:System.Web.UI.WebControls.WebParts.WebPartManager> zu steuern, wie die verschiedenen Zonensteuerelemente <xref:System.Web.UI.WebControls.WebParts.EditorPart> oder <xref:System.Web.UI.WebControls.WebParts.CatalogPart> Steuerelemente und andere.  
  
 Diese Eigenschaft wird verwendet, durch die Webparts-Steuerelementsatzes und in den meisten Fällen der Entwicklung, die sie nicht dazu gedacht ist, die aus dem Code aufgerufen werden. Aus diesem Grund, obwohl die Eigenschaft öffentlich ist, wird diese von IntelliSense ausgeblendet. Entwickler, die zum Zugriff auf die Auflistung von <xref:System.Web.UI.WebControls.WebParts.WebPart> oder andere Serversteuerelemente, die von verwaltet die <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Steuerelement die zu verwendende seine <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> Eigenschaft.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts" />
      </Docs>
    </Member>
    <Member MemberName="CopyWebPart">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.WebParts.WebPart CopyWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.WebPart CopyWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::WebControls::WebParts::WebPart ^ CopyWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">Das zu kopierende <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />-Steuerelement oder Serversteuerelement.</param>
        <summary>Wird vom Webparts-Steuerelementsatz verwendet, um eine Kopie eines <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />-Steuerelements oder Serversteuerelements anzulegen und diese dem Steuerelement auf einer Webseite hinzuzufügen.</summary>
        <returns>Ein <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />, der einer Seite hinzugefügt werden soll.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können nicht Aufrufen der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A> -Methode direkt aus dem Code. Diese Methode wird intern von aufgerufen der <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Steuerelement im Rahmen des Vorgangs zum Hinzufügen eines neuen dynamisches <xref:System.Web.UI.WebControls.WebParts.WebPart> oder Steuerelement zu einer Seite. Ein dynamische Steuerelement wird zu einer Seite programmgesteuert oder über die Webparts-Benutzeroberfläche (UI), z. B. hinzugefügt von einem Benutzer das Hinzufügen eines Steuerelements aus einem Katalog von Steuerelementen, im Gegensatz zu einem statischen Steuerelement, die direkt in das Markup der Seite deklariert ist.  
  
> [!NOTE]
>  Die Methode kann in einer abgeleiteten Klasse überschrieben werden, wenn der Entwickler die Methode zum Behandeln von zusätzlichen steuern das Kopieren von Szenarien aktiviert werden soll. Weitere Informationen finden Sie unter Hinweise zu erben-Abschnitt.  
  
 Wenn ein neues dynamisches Steuerelement hinzugefügt wird, wird jedoch eine <xref:System.Web.UI.WebControls.WebParts.WebPart> -Steuerelement, das <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A> Methode gibt eine neue Instanz des Steuerelements. Wenn das hinzugefügte Steuerelement einen anderen Typ von Serversteuerelement (z. B. ein Benutzersteuerelement, ein benutzerdefiniertes Steuerelement oder ein ASP.NET-Steuerelement) ist, das Steuerelement wird bereits haben umschlossen werden mit einem <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> Objekt, indem Sie die Webparts-Steuerelementsatzes. Wenn die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A> Methode findet eine <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> -Steuerelement, gibt es eine neue Instanz der der <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> Steuerelement mit einer neuen Instanz des untergeordneten Steuerelements darin eingeschlossen.  
  
 Wenn die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A> Methode erstellt eine neue Kopie eines Steuerelements zurückgegeben wird, auch die Werte aller Eigenschaften auf ihre Standardwerte zurückgesetzt. Beachten Sie, dass wenn Sie möchten die Werte der personalisierbaren Eigenschaften beibehalten und haben sie in die neue Instanz des Steuerelements kopiert, rufen Sie die <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.CopyPersonalizationState%2A> Methode ebenfalls. Der letzte Schritt durchgeführt, indem die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A> Methode besteht im Aufrufen der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicWebPartID%2A> Methode, um eine neue ID für das Steuerelement abzurufen.  
  
> [!NOTE]
>  Da die Methode eine neue ID für eine kopierte Steuerelement erhält, sollten Sie nicht verlassen zum Verweisen auf ein dynamisches Steuerelement, das einer Seite, nach seiner ursprünglichen ID. hinzugefügt wird Stattdessen sollten Sie die neue Instanz des Steuerelements, das von der Methode zurückgegebenen verweisen.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Die Methode wird als deklariert <see langword="virtual" /> , damit Entwickler vererben konnte die <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> -Klasse, überschreiben Sie die Methode, und geben Sie für zusätzliche Szenarien, in dem sie Kopien von Steuerelementen erstellen konnte. Beispielsweise könnte die Methode optional als Eingabe ein Steuerelement empfangen, die in eine XML-Datei serialisiert wurde. Die Methode konnte die XML-Datei (falls vorhanden) deserialisieren und rufen Sie die Basismethode, um die vorhandenen Fälle zu behandeln und eine neue Instanz der zurückzugebenden ein <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> Steuerelement.</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="CreateAvailableTransformers">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.WebParts.TransformerTypeCollection CreateAvailableTransformers ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.TransformerTypeCollection CreateAvailableTransformers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateAvailableTransformers" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateAvailableTransformers () As TransformerTypeCollection" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::WebControls::WebParts::TransformerTypeCollection ^ CreateAvailableTransformers();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.TransformerTypeCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt einen Satz von in der Konfigurationsdatei einer Website angegebenen Transformatoren und fügt sie der Auflistung der Transformatoren hinzu, auf die die <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers" />-Eigenschaft verweist.</summary>
        <returns>Die Auflistung der in der Konfigurationsdatei einer Website angegebenen Transformatoren.</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>Diese Methode kann überschrieben werden, um zusätzliche Transformatoren hinzuzufügen, die von der Anwendung verwendet werden kann. Beispielsweise konnte die Methode geschrieben werden, um eine Liste der verfügbaren Transformatoren von einem Webdienst abzurufen.</para>
        </block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers" />
      </Docs>
    </Member>
    <Member MemberName="CreateControlCollection">
      <MemberSignature Language="C#" Value="protected override sealed System.Web.UI.ControlCollection CreateControlCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Web.UI.ControlCollection CreateControlCollection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateControlCollection" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Function CreateControlCollection () As ControlCollection" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Web::UI::ControlCollection ^ CreateControlCollection();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.ControlCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt die Auflistung aller Steuerelemente zurück, die vom <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />-Steuerelement auf einer Webseite verwaltet werden. Diese Klasse kann nicht vererbt werden.</summary>
        <returns>Eine <see cref="T:System.Web.UI.ControlCollection" />, die alle mit dem <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />-Steuerelement verwalteten Webparts-Steuerelemente enthält.</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>Da diese Methode geschützt und versiegelt ist, ist sichtbar für Klassen, die von erben die <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> Klasse, aber es kann nicht überschrieben werden.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="CreateDisplayModes">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection CreateDisplayModes ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection CreateDisplayModes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateDisplayModes () As WebPartDisplayModeCollection" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::WebControls::WebParts::WebPartDisplayModeCollection ^ CreateDisplayModes();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt den Satz aller möglichen Anzeigemodi für eine Webparts-Anwendung.</summary>
        <returns>Eine <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection" />, die alle unterstützten Anzeigemodi enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode erstellt die Liste aller möglichen Anzeigemodi, nicht nur die Anzeigemodi für eine bestimmte Seite unterstützt. Weitere Informationen zu den unterstützten Anzeigemodi, finden Sie unter der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> Eigenschaft.  
  
 Standardmäßig erstellt der Webparts-Steuerelementsatz den folgenden Satz von Anzeigemodi für Webparts-Seiten verwendet werden soll:  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode>  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode>  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode>  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>  
  
 Entwickler können benutzerdefinierte Anzeigemodi erstellen, mit oder ohne zugehörige benutzerdefinierte Zonen, die Ableitung der <xref:System.Web.UI.WebControls.WebParts.WebZone> oder <xref:System.Web.UI.WebControls.WebParts.ToolZone> Klassen. Um einen benutzerdefinierten Anzeigemodus zu erstellen, müssen Sie erben von der <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> -Klasse, um den Anzeigemodus als unterstützten Modus auf einer Seite hinzuzufügen, müssen Sie erben von der <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Klasse, und überschreiben die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes%2A> Methode.  
  
 Beim Hinzufügen von Anzeigemodi mithilfe der <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection.Add%2A> -Methode, Sie sollten sie in der Reihenfolge hinzugefügt, dass Sie in alle Steuerelemente der Benutzeroberfläche (UI) angezeigt werden sollen (z. B. eine <xref:System.Web.UI.WebControls.ListBox> Steuerelement), bereitstellen, Benutzern die möglichen Anzeigemodi auf einer Seite.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt, wie Sie die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes%2A>-Methode verwenden.  
  
 Das Codebeispiel besteht aus fünf Teilen:  
  
-   Ein Benutzersteuerelement, das Ihnen ermöglicht, ändern Sie die Anzeigemodi auf einer Webparts-Seite.  
  
-   Eine Webseite, die die anderen Steuerelemente hostet.  
  
-   Ein Benutzersteuerelement, das befindet eine <xref:System.Web.UI.WebControls.WebParts.WebPartZone> Zone auf der Webseite und ermöglicht es Ihnen, eingeben und Anzeigen von Text in eine Bezeichnung.  
  
-   Eine Quellcodedatei, die zwei Steuerelemente enthält. Eine ist ein benutzerdefiniertes <xref:System.Web.UI.WebControls.WebParts.WebPartManager> -Steuerelement, und die andere ist ein benutzerdefiniertes <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> Objekt, das Standard-Anzeigemodi der Seite hinzugefügt.  
  
-   Eine Quellcodedatei, die zwei benutzerdefinierte enthält <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelemente und eine benutzerdefinierte Schnittstelle.  
  
-   Eine Erläuterung der Funktionsweise des Beispiels in einem Browser.  
  
 Der erste Teil des Codebeispiels wird das Benutzersteuerelement zum Ändern des Anzeigemodus. Sie können den Quellcode für das Benutzersteuerelement abrufen, der im Abschnitt "Beispiel" die <xref:System.Web.UI.WebControls.WebParts.WebPartManager> -Klassenübersicht. Weitere Informationen zu Anzeigemodi und zur Funktionsweise des Benutzersteuerelements, finden Sie unter [Exemplarische Vorgehensweise: Ändern des Anzeigemodus auf einer Webparts-Seite](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0).  
  
 Der zweite Teil des Beispiels wird die Webseite. Es enthält zwei <xref:System.Web.UI.WebControls.WebParts.WebPartZone> Steuerelemente, die sowohl Benutzersteuerelemente und das benutzerdefinierte <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Steuerelement. Beachten Sie, dass die `Register` Direktiven am oberen Rand der Seite auf die Benutzersteuerelemente und den Namespace-URI für die kompilierten Steuerelemente verweisen.  
  
 [!code-aspx-csharp[Webparts_WebPartManager_CreateDisplayModes#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/CS/createDisplayModeCS.aspx#1)]
 [!code-aspx-vb[Webparts_WebPartManager_CreateDisplayModes#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/VB/createDisplayModeVB.aspx#1)]  
  
 Der dritte Teil des Beispiels ist das Benutzersteuerelement zum eingeben und Anzeigen von Text. Er verwendet ein <xref:System.Web.UI.WebControls.MultiView> Steuerelement mehrere Ansichten der Benutzeroberfläche zu erstellen. Eine Ansicht wird angezeigt, mit der `Button1` Schaltfläche, die andere ohne. Beachten Sie, dass in der überschriebenen `OnPreRender` -Methode, der Code überprüft, um festzustellen, ob die Seite befindet sich derzeit im benutzerdefinierten Anzeigemodus befindet, und wenn dies der Fall ist, zeigt die erste Ansicht des Benutzersteuerelements, die die Schaltfläche "" enthält. Wenn die Seite nicht in den benutzerdefinierten Anzeigemodus, z. B. ist wenn die Seite im Modus "Durchsuchen" oder Entwurf ist, wird die Schaltfläche ausgeblendet.  
  
 [!code-aspx-csharp[Webparts_WebPartManager_CreateDisplayModes#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/CS/TextDisplaycs.ascx#2)]
 [!code-aspx-vb[Webparts_WebPartManager_CreateDisplayModes#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/VB/TextDisplayvb.ascx#2)]  
  
 Der vierte Teil des Beispiels wird die Quelldatei für die beiden benutzerdefinierten Klassen. Beachten Sie, dass die benutzerdefinierte <xref:System.Web.UI.WebControls.WebParts.WebPartManager> -Klasse überschreibt die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes%2A> -Methode und ruft zuerst die base-Methode, um die Standard-Anzeigemodi hinzuzufügen, und fügt dann die benutzerdefinierte Anzeigemodus. Die benutzerdefinierte Klasse Anzeigemodus, `InLineEditDisplayMode`, einfach erbt von <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode>, legt den Namen des Anzeigemodus im Konstruktor fest und überschreibt eine Reihe die grundlegenden Eigenschaften, die Merkmale der benutzerdefinierten Anzeige herzustellen.  
  
 Für das Codebeispiel ausführen müssen Sie diesen Quellcode kompilieren. Sie können es explizit kompilieren und legen Sie die resultierende Assembly im Bin-Ordner der Website oder dem globalen Assemblycache. Alternativ können Sie den Quellcode im Ordner "App_Code" des Standorts, ablegen, wo er zur Laufzeit dynamisch kompiliert wird. Eine exemplarische Vorgehensweise zum Kompilieren, veranschaulicht, finden Sie unter [Exemplarische Vorgehensweise: Entwickeln und Verwenden eines benutzerdefinierten Webserver-Steuerelements](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08).  
  
 [!code-csharp[Webparts_WebPartManager_CreateDisplayModes#3](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/CS/CustomDisplayMode.cs#3)]
 [!code-vb[Webparts_WebPartManager_CreateDisplayModes#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/VB/CustomDisplayMode.vb#3)]  
  
 Führen Sie im Codebeispiel wird geladen Sie die Seite in einem Browser werden. Beachten Sie, dass die Seite derzeit im Durchsuchenmodus ist, und keine Schaltfläche sichtbar ist. Mithilfe der **Anzeigemodus** Dropdown-Listensteuerelement, ändern Sie die Seite **Inline Edit Display** Modus, und nun die `Button1` Schaltfläche in der unteren Benutzersteuerelement sichtbar ist. Fügen Sie Text hinzu, und klicken Sie auf die Schaltfläche, um das Steuerelement zu aktualisieren. Beachten Sie, dass die angezeigte Seite zurückgegeben wird, um den Durchsuchen-Modus, der von Ihnen eingegebene Text jetzt angezeigt wird und die Schaltfläche erneut ausgeblendet ist, da die Seite nicht mehr im benutzerdefinierten Anzeigemodus befindet.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateDynamicConnectionID">
      <MemberSignature Language="C#" Value="protected virtual string CreateDynamicConnectionID ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance string CreateDynamicConnectionID() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicConnectionID" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateDynamicConnectionID () As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::String ^ CreateDynamicConnectionID();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft einen eindeutigen Wert ab, der als ID für eine dynamische Verbindung verwendet wird.</summary>
        <returns>Eine Zeichenfolge, die eine eindeutige ID für eine Verbindung enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicConnectionID%2A> Methode generiert einen GUID-Wert und konvertiert es in eine Zeichenfolge, die als eindeutige ID für eine Verbindung dient. Die Methode wird jedes Mal aufgerufen, wenn eine dynamische Verbindung erstellt wird.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Entwickler können diese Methode in einer abgeleiteten überschreiben <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> Klasse so ändern Sie die Implementierung zum Generieren einer eindeutigen ID an.</para>
        </block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicWebPartID(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="CreateDynamicWebPartID">
      <MemberSignature Language="C#" Value="protected virtual string CreateDynamicWebPartID (Type webPartType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance string CreateDynamicWebPartID(class System.Type webPartType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicWebPartID(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateDynamicWebPartID (webPartType As Type) As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::String ^ CreateDynamicWebPartID(Type ^ webPartType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="webPartType">Der <see cref="T:System.Type" /> des Steuerelements, für das eine ID generiert wird.</param>
        <summary>Generiert eine eindeutige ID für ein dynamisches <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />-Steuerelement.</summary>
        <returns>Eine Zeichenfolge mit der eindeutigen ID.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelemente zu einer Webseite hinzugefügt werden, sie können statisch (d. h., das Steuerelement wird im Markup Seite deklariert) oder dynamisch (d. h., sie programmgesteuert hinzugefügt werden) sein. In jedem Szenario, in dem die <xref:System.Web.UI.WebControls.WebParts.WebPartManager> -Steuerelement erstellt neue dynamische Steuerelemente der Seite hinzufügen, ruft diese Methode, um eine eindeutige ID zu generieren.  
  
 Die Methode ist virtuell, sodass Entwickler sie überschreiben können, wenn sie eine benutzerdefinierte Implementierung für das Generieren der ID bereitstellen möchten  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPartType" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateErrorWebPart">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.WebParts.ErrorWebPart CreateErrorWebPart (string originalID, string originalTypeName, string originalPath, string genericWebPartID, string errorMessage);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.ErrorWebPart CreateErrorWebPart(string originalID, string originalTypeName, string originalPath, string genericWebPartID, string errorMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateErrorWebPart(System.String,System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateErrorWebPart (originalID As String, originalTypeName As String, originalPath As String, genericWebPartID As String, errorMessage As String) As ErrorWebPart" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::WebControls::WebParts::ErrorWebPart ^ CreateErrorWebPart(System::String ^ originalID, System::String ^ originalTypeName, System::String ^ originalPath, System::String ^ genericWebPartID, System::String ^ errorMessage);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.ErrorWebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="originalID" Type="System.String" />
        <Parameter Name="originalTypeName" Type="System.String" />
        <Parameter Name="originalPath" Type="System.String" />
        <Parameter Name="genericWebPartID" Type="System.String" />
        <Parameter Name="errorMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="originalID">Eine Zeichenfolge, die die ID des Steuerelements darstellt, bei dem der Fehler aufgetreten ist. Wenn <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> am Fehler beteiligt ist, entspricht die ID der ID von dessen untergeordneten Serversteuerelement.</param>
        <param name="originalTypeName">Eine Zeichenfolge, die den Namen des <see cref="T:System.Type" /> des Steuerelements darstellt, bei dem der Fehler aufgetreten ist. Wenn <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> am Fehler beteiligt ist, entspricht der Typname dem Typ von dessen untergeordneten Serversteuerelement.</param>
        <param name="originalPath">Eine Zeichenfolge, die den Pfad zu einem Benutzersteuerelement enthält, wenn ein <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> mit einem ungeordneten Benutzersteuerelement am Fehler beteiligt ist.</param>
        <param name="genericWebPartID">Eine Zeichenfolge, die die ID eines <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> zurückgibt, wenn dieser Steuerelementtyp am Fehler beim Laden oder Erstellen eines Steuerelements beteiligt war.</param>
        <param name="errorMessage">Eine Zeichenfolge, die die Fehlermeldung enthält, die auf der Seite angezeigt wird.</param>
        <summary>Erstellt ein spezielles Steuerelement, das auf eine Seite eingefügt wird und das für Endbenutzer angezeigt wird, wenn der Versuch fehlschlägt, ein dynamisches <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />-Steuerelement zu laden oder zu erstellen.</summary>
        <returns>Ein <see cref="T:System.Web.UI.WebControls.WebParts.ErrorWebPart" />, der auf einer Seite anstelle eines Steuerelements eingefügt wird, bei dem ein Fehler beim Laden oder Erstellen aufgetreten ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateErrorWebPart%2A> Methode wird aufgerufen, wenn der Webparts-Steuerelementsatz Versuch zum Laden oder erstellen Sie eine Instanz eines dynamischen <xref:System.Web.UI.WebControls.WebParts.WebPart> oder Serversteuerelement, und sie aus irgendeinem Grund fehlschlägt. Die Methode erstellt ein <xref:System.Web.UI.WebControls.WebParts.ErrorWebPart> Objekt zugewiesen, das eine Fehlermeldung angezeigt, und gibt ihn zurück. Die <xref:System.Web.UI.WebControls.WebParts.ErrorWebPart> -Steuerelement wird anstelle des Steuerelements, die nicht eingefügt werden soll, und die Fehlermeldung wird angezeigt, auf der Seite.  
  
 Sie können nicht Aufrufen der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateErrorWebPart%2A> -Methode direkt aus dem Code. Sie können jedoch von erben die <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Klasse, und erweitern Sie die Methode. Einzelheiten finden Sie die Hinweise für Vererber-Abschnitt.  
  
 Endbenutzer können mit arbeiten ein <xref:System.Web.UI.WebControls.WebParts.ErrorWebPart> Steuern auf einer Seite ähnlich wie auch der Fall ist ein normaler <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelement. Um die Fehlermeldung zu entfernen, können sie das Steuerelement schließen, indem Sie auf der schließen-Verb an diesem Punkt das Steuerelement hinzugefügt werden wird, eine <xref:System.Web.UI.WebControls.WebParts.PageCatalogPart> Objekt, wie jedes andere geschlossenen Steuerelement. Wenn ein Endbenutzer Löscht eine <xref:System.Web.UI.WebControls.WebParts.ErrorWebPart> -Steuerelement, das Serversteuerelement, die konnte nicht geladen werden ebenfalls auf der Seite gelöscht.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn die Informationen, die in zurückgegeben wird, angepasst werden soll die <see cref="T:System.Web.UI.WebControls.WebParts.ErrorWebPart" /> -Steuerelement, überschreiben Sie die <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateErrorWebPart(System.String,System.String,System.String,System.String,System.String)" /> -Methode aufrufen die Basismethode die Basismethode übergebenen Parameter unterschiedliche Werte zugewiesen, und kehren Sie dann das resultierende zurück<see cref="T:System.Web.UI.WebControls.WebParts.ErrorWebPart" />Steuerelement. Angenommen, wenn Sie nicht möchten, dass Endbenutzer finden Sie unter der <paramref name="originalPath" /> Wert (die den Pfad des virtuellen Verzeichnisses von Benutzersteuerelementen anzeigen würde), beim Aufrufen der Basismethode übergeben Sie eine leere Zeichenfolge ("") für diesen Parameter.  
  
 Sie können auch das Verhalten anpassen der <see cref="T:System.Web.UI.WebControls.WebParts.ErrorWebPart" /> selbst, können Sie steuern, indem Sie die von ihm erben. Angenommen, Sie möchten möglicherweise außer Kraft setzen die <see cref="P:System.Web.UI.WebControls.WebParts.Part.Title" /> oder <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.AllowMinimize" /> Eigenschaft.</para>
        </block>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.ErrorWebPart" />
      </Docs>
    </Member>
    <Member MemberName="CreatePersonalization">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.WebParts.WebPartPersonalization CreatePersonalization ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.WebPartPersonalization CreatePersonalization() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreatePersonalization () As WebPartPersonalization" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::WebControls::WebParts::WebPartPersonalization ^ CreatePersonalization();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartPersonalization</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt ein Personalisierungsobjekt zurück, das die Personalisierungsdaten eines Benutzers für die aktuelle Webseite enthält.</summary>
        <returns>Eine <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" />, die Personalisierungsdaten eines Benutzers enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization%2A> Methode gibt ein Objekt enthalten, und verwalten die benutzerspezifische personalisierungseinstellungen für die aktuelle Seite zurück. Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager> -Steuerelement verwaltet dieses Objekt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateWebPart">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.GenericWebPart CreateWebPart (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.GenericWebPart CreateWebPart(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::GenericWebPart ^ CreateWebPart(System::Web::UI::Control ^ control);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.GenericWebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">Ein Serversteuerelement, das kein <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />-Steuerelement ist.</param>
        <summary>Umschließt ein Serversteuerelement, das kein <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />-Steuerelement ist, mit einem <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />-Objekt, sodass das Steuerelement über Webparts-Funktionen verfügt.</summary>
        <returns>Ein <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />, der <paramref name="control" /> umschließt und damit dessen Verwendung als echtes <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />-Steuerelement ermöglicht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A> Methode ist die wichtigsten Mechanismus zum Aktivieren von Serversteuerelemente, die nicht <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelemente auf die gleiche Funktionalität wie ein <xref:System.Web.UI.WebControls.WebParts.WebPart> -Steuerelement, und daher vollständig in Webparts-Anwendungen teilnehmen. Mithilfe dieser Methode können Entwickler völlig erweitern Sie die Anzahl der Serversteuerelemente, die sie in einer Webparts-Anwendung verwenden können, da praktisch jeder Art von Webserversteuerelement – standard ASP.NET-Steuerelementen Benutzersteuerelemente und benutzerdefinierte Steuerelemente – können verwendet werden.  
  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Steuerelement verwendet diese Methode auch in anderen Szenarios Serversteuerelemente mit umschließen einer <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> Objekt. Wenn Benutzer hinzufügen Serversteuerelemente zu einer Seite mit der <xref:System.Web.UI.WebControls.WebParts.ImportCatalogPart> zu steuern, wenn die importierten Steuerelement keine <xref:System.Web.UI.WebControls.WebParts.WebPart> -Steuerelement, die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A> -Methode aufgerufen wird. Auch, wenn Serversteuerelemente in deklariert Persistenzformat innerhalb einer <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> Zone auf einer Webseite der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A> Methode wird aufgerufen, für alle Steuerelemente, die nicht <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelemente.  
  
 Ein Serversteuerelement einer Zone programmgesteuert hinzuzufügen, wird ein typischer Ansatz verwenden die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A> Methode, um das Steuerelement mit umschließen einer <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> Objekt, und rufen Sie anschließend die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A> Methode, um das Steuerelement auf die Auflistung aller hinzufügen <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelemente auf der Seite, die verweist die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> Eigenschaft.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A> Methode. In der `Button2_Click method`, die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A> Methode wird aufgerufen, um das Umschließen einer <xref:System.Web.UI.WebControls.Calendar> steuern mit eine <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> Objekt vor dem Hinzufügen der Zone.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/CS/wpmgDeleteWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/VB/wpmgDeleteWebPartVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Diese Methode kann überschrieben werden, um eine abgeleitete <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> Klasse stattdessen der Basisklasse bereitgestellt, mit dem Webparts-Steuerelementsatz.</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="DeleteWarning">
      <MemberSignature Language="C#" Value="public virtual string DeleteWarning { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DeleteWarning" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property DeleteWarning As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ DeleteWarning { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine benutzerdefinierte Warnmeldung ab oder legt diese fest, die angezeigt wird, wenn Endbenutzer ein Steuerelement löschen.</summary>
        <value>Eine Zeichenfolge, die den Text der Warnmeldung enthält. Der Standardwert ist eine lokalisierte Warnmeldung.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein Benutzer löscht eine <xref:System.Web.UI.WebControls.WebParts.WebPart> steuern, normalerweise ein Standardtext für die Warnung wird angezeigt. Wenn diese Instanz eines Steuerelements gelöscht wird, der Löschvorgang permanent ist, wird der Benutzer gewarnt. Der Entwickler der Seite möglicherweise Benutzer bereit, mit der Möglichkeit, eine neue Instanz des Steuerelements zur Seite hinzuzufügen (z. B. über einen Katalog mit <xref:System.Web.UI.WebControls.WebParts.WebPart> -Steuerelemente oder über die Möglichkeiten zum programmgesteuerten), jedoch die aktuelle Instanz eines Steuerelements, das gelöscht wird, wird dauerhaft entfernt. Das Dialogfeld, das die Warnung angezeigt wird, enthält eine Schaltfläche für den Benutzer um den Löschvorgang abzubrechen, falls gewünscht.  
  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A> Eigenschaft ermöglicht Entwicklern die Warnmeldung festlegen, die dem Benutzer angezeigt wird.  
  
 Wenn ein Entwickler eine leere Zeichenfolge weist ("") Wert für diese Eigenschaft, die keine Warnung Meldungsdialogfeld wird angezeigt, wenn ein Benutzer löscht eine <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelement.  
  
> [!NOTE]
>  Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A> Eigenschaft wird nicht angezeigt, bei statischen <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelemente und Serversteuerelemente. Statische Steuerelemente sind Serversteuerelemente, die innerhalb von deklariert werden eine <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> Zone im Markup einer Webseite. Da solche Steuerelemente statisch sind, können keine sie gelöscht werden, damit die Warnung löschen in diesem Fall niemals angezeigt wird. Statische Steuerelemente können von einem Benutzer geschlossen werden, aber ein geschlossenes Steuerelement wird hinzugefügt, die Seite-Katalog, aus dem er wieder zur Seite von einem Benutzer hinzugefügt werden kann während ein gelöschten Steuerelements nicht wiederhergestellt werden kann.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A> Eigenschaft deklarativ und programmgesteuert.  
  
 Es gibt vier Teile im Codebeispiel:  
  
-   Ein Benutzersteuerelement, das Sie Seitenanzeigemodi ändern kann.  
  
-   Eine benutzerdefinierte <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelement.  
  
-   Eine Webseite.  
  
-   Eine Erläuterung der Funktionsweise des Beispiels in einem Browser.  
  
 Der erste Teil des Codebeispiels wird das Benutzersteuerelement zum Ändern des Anzeigemodus. Sie können den Quellcode für das Benutzersteuerelement abrufen, der im Abschnitt "Beispiel" die <xref:System.Web.UI.WebControls.WebParts.WebPartManager> -Klassenübersicht. Weitere Informationen zu Anzeigemodi und zur Funktionsweise des Benutzersteuerelements, finden Sie unter [Exemplarische Vorgehensweise: Ändern des Anzeigemodus auf einer Webparts-Seite](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0).  
  
 Der zweite Teil des Codebeispiels wird die benutzerdefinierte <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelement. Für das Codebeispiel ausführen müssen Sie diesen Quellcode kompilieren. Sie können es explizit kompilieren und legen Sie die resultierende Assembly im Bin-Ordner der Website oder dem globalen Assemblycache. Alternativ können Sie den Quellcode im Ordner "App_Code" des Standorts, ablegen, wo er zur Laufzeit dynamisch kompiliert wird. Dieses Beispiel verwendet die Methode der dynamischen Kompilierung. Es gibt also keine `Assembly` Attribut in der `Register` Richtlinie für dieses Steuerelement am oberen Rand der Webseite. Eine exemplarische Vorgehensweise zum Kompilieren, veranschaulicht, finden Sie unter [Exemplarische Vorgehensweise: Entwickeln und Verwenden eines benutzerdefinierten Webserver-Steuerelements](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08).  
  
 [!code-csharp[WebParts_WebPartManager_DeleteWarning#3](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWarning/CS/textdisplaywebpart.cs#3)]
 [!code-vb[WebParts_WebPartManager_DeleteWarning#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWarning/VB/textdisplaywebpart.vb#3)]  
  
 Der dritte Teil des Codebeispiels wird die Webseite. Diese Seite enthält eine <xref:System.Web.UI.WebControls.WebParts.CatalogZone> Zone, mit dem benutzerdefinierten <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelement in der Zone deklariert, sodass ein Benutzer sie auf der Seite zur Laufzeit hinzufügen kann. Beachten Sie, dass nur dynamische Steuerelemente (Steuerelemente, die auf eine Seite programmgesteuert oder aus einem Katalog wie diesem hinzugefügt werden) von einer Seite gelöscht werden können. Statische Steuerelemente (Steuerelemente, die innerhalb von deklariert werden eine <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> Zone im Markup der Seite) können geschlossen, aber nie gelöscht. Die `<asp:webpartmanager>` Element deklariert einen benutzerdefinierten Wert für die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A> Eigenschaft mithilfe der `DeleteWarning` Attribut. Die `Button1_Click` Methode weist einen anderen benutzerdefinierten Wert an die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A> Eigenschaft.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DeleteWarning#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWarning/CS/deleteWarningCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DeleteWarning#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWarning/VB/deleteWarningVB.aspx#1)]  
  
 Nachdem Sie die Seite in einem Browser zu laden, müssen Sie zum Hinzufügen der <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelement auf der Seite. Mithilfe der **Anzeigemodus** Dropdownlisten-Steuerelement, wählen Sie Katalogmodus. Wenn der Katalog angezeigt wird, wählen Sie das Kontrollkästchen neben dem benutzerdefinierten Steuerelement, klicken Sie auf **hinzufügen** auf der Seite hinzugefügt wird, und klicken Sie dann auf **schließen** in den Durchsuchen-Modus zurück. Nun, dass das Steuerelement sichtbar ist, können Sie es löschen. Mithilfe der **Anzeigemodus** erneut zu steuern, indem Sie die Seite in den Entwurfsmodus versetzt (Sie können keine Steuerelemente löschen, während die Seite im Durchsuchenmodus befindet). Klicken Sie auf die Verbmenü (das Pfeilsymbol) im Header des der <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelement, und wählen Sie **löschen**. Die Warnung, die Sie festlegen, auf die `DeleteWarning` Attribut angezeigt wird. Klicken Sie auf **"Abbrechen"**. Klicken Sie nun auf die Schaltfläche "mit der Bezeichnung" **Änderung löschen Warnung**, welche Änderungen programmgesteuert den Wert der Eigenschaft. Wählen Sie im Menü Verben für das Steuerelement **löschen** erneut aus, und beachten Sie, die dieses Mal die anderen Warnmeldung angezeigt wird.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="DeleteWebPart">
      <MemberSignature Language="C#" Value="public void DeleteWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">Das zu löschende Serversteuerelement.</param>
        <summary>Löscht eine dynamische Instanz eines <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />-Steuerelements unwiderruflich von einer Webseite.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart%2A> -Methode dauerhaft entfernt das Steuerelement, dargestellt durch die `webPart` Parameter aus einer Seite. Im Gegensatz zu einem geschlossenen Steuerelement, das hinzugefügt der <xref:System.Web.UI.WebControls.WebParts.PageCatalogPart> steuern und hinzugefügt werden können erneut an die Seite eine Instanz eines gelöschten kann nie wieder an die Seite hinzugefügt werden.  
  
> [!NOTE]
>  Gemäß der Implementierung von Webparts-Steuerelements festgelegt ist, wird die Möglichkeit für Benutzer So löschen Sie einen dynamischen <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelement auf der Personalisierungsbereich, in dem das Steuerelement zu einer Seite hinzugefügt wurde, und der Benutzer abhängig ist. Wenn das Steuerelement hinzugefügt wird, wenn die Seite ist im freigegebenen Bereich (von einem Benutzer, die über Berechtigungen verfügt) kann dann das Steuerelement von einzelnen Benutzern gelöscht werden, wenn die Seite im Benutzerbereich durchgeführt wird.  
  
 Nur dynamische Steuerelemente können gelöscht werden. Dynamische Steuerelemente werden programmgesteuert oder durch Hinzufügen von Steuerelementen aus einem Katalog Benutzer zu einer Seite hinzugefügt. Statische Steuerelemente werden zu einer Seite deklarativ im Markup oder der Persistenz-Format hinzugefügt. Da die deklarativen Tags im Markup permanent vorhanden sind, statische Steuerelemente können nicht gelöscht werden, aber geschlossen und erneut geöffnet werden kann.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt, wie Sie die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart%2A>-Methode verwenden. Beim ersten die **Kalender hinzufügen** Schaltfläche geklickt wird, den Code im Ereignis Ereignishandler erstellt ein <xref:System.Web.UI.WebControls.Calendar> steuern und fügt es einer Zone als ein <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> Objekt. Da das Steuerelement programmgesteuert hinzugefügt wird, ist ein dynamisches Steuerelement und können deshalb gelöscht werden. Wenn ein Benutzer klickt auf die **Kalender löschen** Schaltfläche der Code stellt sicher, dass das Steuerelement vorhanden ist, und sie dann durch Aufrufen löscht der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart%2A> Methode.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/CS/wpmgDeleteWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/VB/wpmgDeleteWebPartVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.IsClosed" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.IsStatic" />
      </Docs>
    </Member>
    <Member MemberName="DesignDisplayMode">
      <MemberSignature Language="C#" Value="public static readonly System.Web.UI.WebControls.WebParts.WebPartDisplayMode DesignDisplayMode;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Web.UI.WebControls.WebParts.WebPartDisplayMode DesignDisplayMode" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DesignDisplayMode As WebPartDisplayMode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ DesignDisplayMode;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt den Anzeigemodus dar, in dem das Layout von Webseiten mit Webparts-Steuerelementen geändert wird. Dieses Feld ist schreibgeschützt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode> Feld verweist auf ein benutzerdefiniertes <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> -Objekt, das erstellt und enthalten die <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Steuerelement. Da dies ein statisches Objekt ist, finden Sie es direkt über die <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Klasse ohne eine Instanz des Steuerelements.  
  
 Wenn eine Seite mit den Webparts-erste geladen Steuerelemente, befindet sich im <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode> (Durchsuchenmodus) standardmäßig. Wenn Sie möchten, dass Benutzer das Layout der Seite zu ändern, indem Sie Steuerelemente für verschiedene Zonen oder innerhalb von Zonen zu verschieben, müssen sie die Seite wechseln <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode> (Entwurfsmodus). Im Entwurfsmodus befindet die Benutzeroberfläche (UI) für die verschiedenen Zonen wird angezeigt, und Benutzer können Steuerelemente ziehen, um das Layout zu ändern.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode> programmgesteuert Feld. Der Code füllt eine Dropdownliste mit den unterstützten Anzeigemodi für die Seite die in diesem Fall zu durchsuchen und Entwurf sind. Beachten Sie, dass der `Page_PreRender` -Methode, die dem Code wird überprüft, ob die aktuelle <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> -Eigenschaftensatz auf <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode>. Wenn dies der Fall ist, `Label1` werden angezeigt, und falls nicht, `Label1` wird ausgeblendet.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DesignDisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DesignDisplayMode/CS/wpmgrDesignDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DesignDisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DesignDisplayMode/VB/wpmgrDesignDisplayModevb.aspx#1)]  
  
 Nachdem Sie die Seite in einem Browser geladen haben, können Sie im Durchsuchenmodus standardmäßig. Beachten Sie, dass die Bezeichnung auf der Seite ausgeblendet ist. Verwenden Sie das Dropdownlisten-Steuerelement, um die Seite in den Entwurfsmodus zu wechseln. Beachten Sie, dass aufgrund des Codes in der `Page_PreRender` -Methode, die die Bezeichnung ist jetzt sichtbar.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />
      </Docs>
    </Member>
    <Member MemberName="DisconnectWebPart">
      <MemberSignature Language="C#" Value="protected virtual void DisconnectWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DisconnectWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void DisconnectWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">Ein <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />-Steuerelement, dessen Verbindungen getrennt werden müssen.</param>
        <summary>Entfernt ein <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />-Steuerelement oder Serversteuerelement, das geschlossen oder gelöscht wird, aus allen Verbindungen, an denen es beteiligt ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> Methode wird intern aufgerufen, von dem Webparts-Steuerelementsatz festgelegt, wenn ein Steuerelement auf einer Seite geschlossen oder von einer Seite gelöscht. In solch einem Szenario wird die Methode zum Entfernen des Steuerelements aus der alle Verbindungen aufgerufen, in dem sie als Consumer oder Anbieter beteiligt. Wenn das Steuerelement aus eine Verbindung entfernt wird, ruft diese Methode auch die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> Beenden alle Verbindungen in der Methode `webPart` beteiligt war.  
  
 Wenn die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> -Methode aufgerufen wird, löst es das <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> Ereignis. Normalerweise kann dieses Ereignis abgebrochen werden, jedoch in beiden Fällen es kann nicht abgebrochen werden. Einen Fall tritt auf, während Anforderungen auf der Seite, wenn der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A> Methode wird aufgerufen. Liegt ein Konflikt zwischen der vorhandenen Verbindungen die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> Methode wird aufgerufen, um eine der in Konflikt stehenden Verbindungen und in dieser Instanz schließen die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> Ereignis kann nicht abgebrochen werden, da der Konflikt nicht gelöst werden muss.  
  
 Im anderen Fall tritt auf, wenn eine <xref:System.Web.UI.WebControls.WebParts.WebPart> oder -Steuerelement, das derzeit verbunden ist geschlossen oder gelöscht wird. In diesem Fall aufgrund des Steuerelements wird aus entfernt die Seite, muss die Verbindung daher ebenfalls programmbedingt beendet werden nicht auf "Abbrechen kann" die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> Ereignis, um den Prozess beim Beenden einer Verbindung zu unterbrechen. Weitere Informationen finden Sie beim <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>-Ereignis.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt, wie Sie die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>-Methode verwenden. Verwenden von zwei benutzerdefinierten <xref:System.Web.UI.WebControls.WebParts.WebPart> -Steuerelemente auf der Webseite können Sie erstellen Sie eine Verbindung zwischen den Steuerelementen per Mausklick, während eine andere Schaltfläche die Steuerelemente trennen können. Wenn Sie eines der Steuerelemente, schließen während die Seite im Durchsuchenmodus ist und die Steuerelemente verbunden sind, eine Überschreibung der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> Methode trennt das geschlossene Steuerelement, beendet die Verbindung und zeigt eine Meldung.  
  
 Das Codebeispiel besteht aus vier Teilen:  
  
-   Ein Benutzersteuerelement für Anzeigemodi ändern.  
  
-   Eine Quelldatei, die mit einem benutzerdefinierten <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelemente.  
  
-   Eine Webseite, um die Steuerelemente zu hosten.  
  
-   Eine Erläuterung der Funktionsweise des Beispiels in einem Browser.  
  
 Der erste Teil des Codebeispiels wird das Benutzersteuerelement zum Ändern des Anzeigemodus. Sie können den Quellcode für das Benutzersteuerelement abrufen, der im Abschnitt "Beispiel" die <xref:System.Web.UI.WebControls.WebParts.WebPartManager> -Klassenübersicht. Weitere Informationen zu Anzeigemodi und zur Funktionsweise des Benutzersteuerelements, finden Sie unter [Exemplarische Vorgehensweise: Ändern des Anzeigemodus auf einer Webparts-Seite](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0).  
  
 Der zweite Teil ist die Datei mit dem Quellcode für die beiden benutzerdefinierten <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelemente, die verbunden werden soll, sowie eine benutzerdefinierte <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Steuerelement. Für das Codebeispiel ausführen müssen Sie diesen Quellcode kompilieren. Sie können es explizit kompilieren und legen Sie die resultierende Assembly im Bin-Ordner der Website oder dem globalen Assemblycache. Alternativ können Sie den Quellcode im Ordner "App_Code" des Standorts, ablegen, wo er zur Laufzeit dynamisch kompiliert wird. In diesem Beispiel verwendet die dynamische Kompilierung, damit die `Register` -Direktive, die auf diese Komponenten auf der Webseite dementsprechend deklariert wird am oberen Rand der Webseite. Eine exemplarische Vorgehensweise, die Optionen zur Kompilierung veranschaulicht, finden Sie unter [Exemplarische Vorgehensweise: Entwickeln und Verwenden eines benutzerdefinierten Webserver-Steuerelements](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08).  
  
 Beachten Sie im Quellcode, geerbte Steuerelement `MyWebPartManager` überschreibt die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> Methode. Diese Methode prüft jede Verbindung in eine Seite, um festzustellen, ob das Steuerelement geschlossen wird die Verbindung beteiligt ist und, wenn dies der Fall ist, ruft die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> Methode, um die Verbindung zu beenden. Dies ist identisch mit die grundlegende Implementierung der Methode in der <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Steuerelement. Die überschriebene Methode passt klicken Sie dann die grundlegende Implementierung durch Schreiben einer Nachricht auf der Seite an.  
  
 [!code-csharp[WebParts_WebPartManager_DisconnectWebParts#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_DisconnectWebParts#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/VB/ZipCodeComponent.vb#2)]  
  
 Der dritte Teil des Codebeispiels wird die Webseite. Beachten Sie, dass im oberen Bereich, er enthält `Register` Direktiven so registrieren Sie das Benutzersteuerelement, und die dynamisch kompilierte Assembly mit dem <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelemente. Die Seite verfügt über zwei primäre Methoden. Die `Button1_Click` Methode erstellt eine Verbindung zwischen den Steuerelementen, während die `Button2_Click` -Methode trennt die Steuerelemente.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DisconnectWebParts#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/CS/wpmgrDisconnectWebPartsCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DisconnectWebParts#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/VB/wpmgrDisconnectWebPartsVB.aspx#1)]  
  
 Nachdem Sie die Seite zu laden, klicken Sie auf die **verbinden** Schaltfläche, um die Steuerelemente zu verbinden. Klicken Sie dann klicken Sie auf die Verbmenü in eines der Steuerelemente (auf den Pfeil nach unten im Header des Steuerelements), und wählen Sie **schließen** aus Verbmenü. Wenn Sie versuchen, das Steuerelement zu schließen, die überschriebene Methode wird aufgerufen, die Verbindung beendet wird und auf der Seite die Meldung geschrieben wird. Wenn Sie die Seite, um das geschlossene Steuerelement wiederherstellen und mit anderen Optionen experimentieren, klicken zurücksetzen möchten die **Zurücksetzen des Benutzerzustands** Link zur Personalisierungsdaten entfernen und Wiederherstellen der ursprünglichen Zustand der Seite.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts(System.Web.UI.WebControls.WebParts.WebPartConnection)" />
      </Docs>
    </Member>
    <Member MemberName="DisconnectWebParts">
      <MemberSignature Language="C#" Value="public virtual void DisconnectWebParts (System.Web.UI.WebControls.WebParts.WebPartConnection connection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DisconnectWebParts(class System.Web.UI.WebControls.WebParts.WebPartConnection connection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts(System.Web.UI.WebControls.WebParts.WebPartConnection)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub DisconnectWebParts (connection As WebPartConnection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void DisconnectWebParts(System::Web::UI::WebControls::WebParts::WebPartConnection ^ connection);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="connection" Type="System.Web.UI.WebControls.WebParts.WebPartConnection" />
      </Parameters>
      <Docs>
        <param name="connection">Eine <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" />, die die Verbindung zwischen Serversteuerelementen darstellt.</param>
        <summary>Führt den Prozess des Trennens von auf einer Webseite verbundenen Serversteuerelementen aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> -Methode führt beim Beenden einer Verbindung zwischen der vollständige Prozess <xref:System.Web.UI.WebControls.WebParts.WebPart> oder Serversteuerelemente, wenn Sie sie übergeben die `connection` Parameter.  
  
 Diese Methode wird verwendet, um Steuerelemente zu trennen, wenn Sie beim Platzieren einer `<asp:connectionszone>` Element auf einer Webseite, um eine Benutzeroberfläche (UI) zum Verwalten von Verbindungen bereitzustellen. Wenn eine Seite im Verbinden Anzeigemodus (<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>), eine aktuelle Verbindung vorhanden ist, und Benutzer können eine Schaltfläche, die aufruft, klicken Sie auf die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> Methode, um die Verbindung zu beenden.  
  
 Sie können auch aufrufen, die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> -Methode direkt aus Ihrem Code, wenn Sie Steuerelemente programmgesteuert, ohne dass hinzuzufügende trennen möchten eine `<asp:connectionszone>` Element zu einer Seite.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt, wie Sie die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>-Methode verwenden. Verwenden von zwei benutzerdefinierten <xref:System.Web.UI.WebControls.WebParts.WebPart> -Steuerelemente auf der Webseite können Sie erstellen Sie eine Verbindung zwischen den Steuerelementen per Mausklick, während eine andere Schaltfläche die Steuerelemente trennen können.  
  
 Das Codebeispiel besteht aus vier Teilen:  
  
-   Ein Benutzersteuerelement für Anzeigemodi ändern.  
  
-   Eine Quelldatei, die mit einem benutzerdefinierten <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelemente.  
  
-   Eine Webseite, um die Steuerelemente zu hosten.  
  
-   Eine Erläuterung der Funktionsweise des Beispiels in einem Browser.  
  
 Der erste Teil des Codebeispiels wird das Benutzersteuerelement zum Ändern des Anzeigemodus. Sie können den Quellcode für das Benutzersteuerelement abrufen, der im Abschnitt "Beispiel" die <xref:System.Web.UI.WebControls.WebParts.WebPartManager> -Klassenübersicht. Weitere Informationen zu Anzeigemodi und zur Funktionsweise des Benutzersteuerelements, finden Sie unter [Exemplarische Vorgehensweise: Ändern des Anzeigemodus auf einer Webparts-Seite](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0).  
  
 Der zweite Teil ist eine Datei mit dem Quellcode für die beiden benutzerdefinierten <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelemente, die verbunden werden soll. Für das Codebeispiel ausführen müssen Sie diesen Quellcode kompilieren. Sie können es explizit kompilieren und legen Sie die resultierende Assembly im Bin-Ordner der Website oder dem globalen Assemblycache. Alternativ können Sie den Quellcode im Ordner "App_Code" des Standorts, ablegen, wo er zur Laufzeit dynamisch kompiliert wird. In diesem Beispiel verwendet die dynamische Kompilierung, damit die `Register` -Direktive, die auf diese Komponenten auf der Webseite dementsprechend deklariert wird am oberen Rand der Webseite. Eine exemplarische Vorgehensweise, die Optionen zur Kompilierung veranschaulicht, finden Sie unter [Exemplarische Vorgehensweise: Entwickeln und Verwenden eines benutzerdefinierten Webserver-Steuerelements](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08).  
  
 [!code-csharp[WebParts_WebPartManager_DisconnectWebParts#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_DisconnectWebParts#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/VB/ZipCodeComponent.vb#2)]  
  
 Der dritte Teil des Codebeispiels wird die Webseite. Beachten Sie, dass im oberen Bereich, er enthält `Register` Direktiven so registrieren Sie das Benutzersteuerelement und die dynamisch kompilierte Assembly mit dem <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelemente. Die Seite verfügt über zwei primäre Methoden. Die `Button1_Click` Methode erstellt eine Verbindung zwischen den Steuerelementen und der `Button2_Click` -Methode trennt die Steuerelemente.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DisconnectWebParts#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/CS/wpmgrDisconnectWebPartsCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DisconnectWebParts#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/VB/wpmgrDisconnectWebPartsVB.aspx#1)]  
  
 Nachdem Sie die Seite geladen haben, können Sie klicken die **verbinden** Schaltfläche, um die Steuerelemente zu verbinden. Wenn Sie Text in das Textfeld-Steuerelement eingeben, und klicken Sie dann auf die **EINGABETASTE** Schaltfläche der Text wird in der verbundenen-Steuerelement (es wird nicht angezeigt, wenn die Steuerelemente getrennt wurden) angezeigt werden. Wenn Sie auf die **trennen** Schaltfläche, die Steuerelemente werden getrennt. Sie können den Verbindungsstatus der Steuerelemente überprüfen, indem Sie mit der **Anzeigemodus** Dropdown-Listensteuerelement zum Wechseln von der Seite "in" **verbinden** Modus. Nachdem Sie auf diese Weise, klicken Sie in der Titelleiste eines der Steuerelemente auf die Verbmenü (dargestellt durch einen Pfeil), und wählen die **verbinden** Element. Die Verbindung UI wird angezeigt. Es ist verfügbar, da es ist ein `<asp:connectionszone>` Element deklariert wird, auf der Seite. Sie können auch eine Verbindung herstellen und trennen die Steuerelemente über diese Benutzeroberfläche.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="connection" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="connection" /> ist weder in <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections" /> noch in <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" /> enthalten.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections" /> ist schreibgeschützt.  
  
 \- oder –  
  
 <paramref name="connection" /> wurde bereits von <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections" /> getrennt.  
  
 \- oder –  
  
 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" /> ist schreibgeschützt.  
  
 \- oder –  
  
 <paramref name="connection" /> wurde bereits von <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" /> getrennt.</exception>
        <block subset="none" type="overrides">
          <para>Sie können außer Kraft setzen die <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts(System.Web.UI.WebControls.WebParts.WebPartConnection)" /> Methode, wenn Sie die standardmäßige Implementierung für das Trennen der Verbindung ändern möchten <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> Steuerelemente. Wenn Sie die Methode überschreiben, und Sie einfach eine gewisse Implementierung der vorhandenen Methode hinzufügen möchten, können Sie die Basismethode vor der Ausführung von Ihren eigenen Codes aufrufen.</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="DisplayMode">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.WebPartDisplayMode DisplayMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartDisplayMode DisplayMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property DisplayMode As WebPartDisplayMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ DisplayMode { System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ get(); void set(System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den aktiven Anzeigemodus für eine Webseite ab, die Webparts-Steuerelemente enthält, oder legt diesen fest.</summary>
        <value>Ein <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />, der den Anzeigemodus einer Seite bestimmt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Seite, die Webparts-Steuerelemente enthält, wird immer in einem von mehreren möglichen Anzeigemodi. Ausführliche Informationen zu Anzeigemodi finden Sie unter [Web Parts Page Display Modes](http://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4).  
  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager> -Klasse erstellt die Anzeigemodi für eine Webseite. Verwenden die Basis <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> -Klasse, die <xref:System.Web.UI.WebControls.WebParts.WebPartManager> -Steuerelements erstellt mehrere standard-Modus Objekte anzuzeigen, die für Seiten verwendet werden können, die Webparts-Steuerelemente enthalten. Dieser standard Anzeigemodi in beschrieben werden die <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> -Klassenübersicht.  
  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager> -Steuerelement verwaltet außerdem die Anzeigemodi für Seiten, die Webparts-Steuerelemente verwenden. Mithilfe der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> -Eigenschaft, die <xref:System.Web.UI.WebControls.WebParts.WebPartManager> -Steuerelement behält einen Verweis auf den aktuellen Anzeigemodus auf einer Seite. Sie können auch die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> Eigenschaft, um eine Seite in unterschiedlichen Modi zu wechseln. Ein Beispiel für das Ändern des Anzeigemodus auf einer Seite, die Webparts-Steuerelemente verwendet, finden Sie unter [Exemplarische Vorgehensweise: Ändern des Anzeigemodus auf einer Webparts-Seite](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0).  
  
 Im Rahmen der Verwaltung des Anzeigemodus der <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Steuerelement bietet auch Ereignisse und Ereignishandler, die im Zusammenhang mit Modi angezeigt, wie z. B. die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged%2A> Methode und die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging%2A> Methode. Diese Methoden bieten einen Mechanismus zum Anpassen des Verhaltens einer Seite und sogar für einen benutzerdefinierten Anzeigemodus hinzufügen.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die programmgesteuerte Verwendung von der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> Eigenschaft. Die Schaltflächen am unteren Rand der Seite können Sie nach dem Laden der Seite in einem Browser, Anzeigemodi wechseln. Die Seite ist im Durchsuchenmodus standardmäßig geladen wird. Wenn Sie in den Entwurfsmodus wechseln, können Sie Serversteuerelemente von einer Zone in eine andere ziehen oder zwei Steuerelemente innerhalb einer Zone anordnen. Wenn Sie den Bearbeitungsmodus wechseln, können Sie Verbmenü im Header des entweder die Serversteuerelemente klicken **bearbeiten**, und bearbeiten Sie das Steuerelement mit der bereitgestellten bearbeiten-Benutzeroberfläche (UI).  
  
> [!NOTE]
>  Wechseln zwischen Anzeigemodi in einer Webparts-Anwendung ist üblich, und möglicherweise möchten bieten eine konsistente und wiederverwendbare Möglichkeit dazu auf alle Seiten, die Webparts-Steuerelemente enthalten. Ein Beispiel für ein Benutzersteuerelement, Änderungen, Modi und, die anzeigen auf viele Seiten wiederverwendet werden kann, finden Sie unter [Exemplarische Vorgehensweise: Ändern des Anzeigemodus auf einer Webparts-Seite](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0).  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisplayMode/CS/wpmgrDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisplayMode/VB/wpmgrDisplayModevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Das <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />-Objekt, das der Eigenschaft zugewiesen wird, lautet <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Das <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />-Objekt, das der Eigenschaft zugewiesen wird, entspricht keinem der unterstützten Anzeigemodi.  
  
 \- oder –  
  
 Das <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />-Objekt, das der Eigenschaft zugewiesen wird, ist deaktiviert.</exception>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes" />
      </Docs>
    </Member>
    <Member MemberName="DisplayModeChanged">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventHandler DisplayModeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventHandler DisplayModeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DisplayModeChanged As WebPartDisplayModeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartDisplayModeEventHandler ^ DisplayModeChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, nachdem sich der aktuelle Anzeigemodus auf einer Webparts-Seite geändert wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Anzeigemodi sind ein wesentlicher Bestandteil des Webparts-Anwendungen. Wenn Benutzer auf einen anderen Anzeigemodus auf einer Webseite wechseln, wird die Seite oft sehr unterschiedlich dargestellt, abhängig vom Zweck des neuen Anzeigemodus dauern. Nachdem Sie ein Anzeigemodus geändert wurde, können Sie möchten bestimmte Änderungen in der Benutzeroberfläche (UI), z. B. ein- oder Ausblenden bestimmter Steuerelemente ändern die Darstellung der ausgewählten UI-Elemente, und so weiter.  
  
> [!NOTE]
>  Weitere Informationen zu Anzeigemodi finden Sie unter [Web Parts Page Display Modes](http://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4). Weitere Informationen zum Verwenden von Ereignissen finden Sie unter [wie: Behandeln von Ereignissen in einer Web Forms-Anwendung](~/docs/standard/events/how-to-consume-events-in-a-web-forms-application.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged(System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="DisplayModeChanging">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventHandler DisplayModeChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventHandler DisplayModeChanging" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanging" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DisplayModeChanging As WebPartDisplayModeCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartDisplayModeCancelEventHandler ^ DisplayModeChanging;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn ein Benutzer auf einer Webseite auf ein Verb klickt, das den Prozess des Umschaltens in einen anderen Anzeigemodus startet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Anzeigemodi sind ein wesentlicher Bestandteil des Webparts-Anwendungen. Wenn Benutzer auf einen anderen Anzeigemodus auf einer Webseite wechseln, wird die Seite oft sehr unterschiedlich dargestellt, abhängig vom Zweck des neuen Anzeigemodus dauern. Nachdem ein Benutzer den Prozess zu einem neuen Anzeigemodus wechseln, indem Sie auf das Verb initiiert, möchten Sie möglicherweise bestimmte Änderungen in der Benutzeroberfläche (UI) stellen die <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs.NewDisplayMode%2A> -Eigenschaft können Sie bestimmen, was der neuen Anzeigemodus gestellt werden, und ändern Sie die verschiedenen UI Elemente entsprechend. Eine hilfreiche Möglichkeit hierzu ist, überschreiben die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging%2A> Methode zum Anpassen der Benutzeroberfläche.  
  
> [!NOTE]
>  Weitere Informationen zu Anzeigemodi finden Sie unter [Web Parts Page Display Modes](http://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4). Weitere Informationen zum Verwenden von Ereignissen finden Sie unter [wie: Behandeln von Ereignissen in einer Web Forms-Anwendung](~/docs/standard/events/how-to-consume-events-in-a-web-forms-application.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging(System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="DisplayModes">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection DisplayModes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection DisplayModes" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DisplayModes As WebPartDisplayModeCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartDisplayModeCollection ^ DisplayModes { System::Web::UI::WebControls::WebParts::WebPartDisplayModeCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine schreibgeschützte Auflistung aller Anzeigemodi ab, die einem <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />-Steuerelement zugeordnet sind.</summary>
        <value>Eine <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection" />, die den Satz der dem <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />-Steuerelement zugeordneten <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />-Objekte enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes%2A> Eigenschaftsverweisen, die alle zugeordneten Anzeigemodi im Unterschied zu den <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> -Eigenschaft, die nur die Anzeigemodi, die verfügbar sind verweist (unterstützt), auf der aktuellen Seite.  
  
 Zwei der bereitgestellten Anzeigemodi, durchsuchen und Entwurf, werden immer auf einer Seite unterstützt. Die anderen drei Anzeigemodi, Edit, Katalog und Verbindungen, werden nur unterstützt, wenn eine Seite mit den entsprechenden Typ der Zone, die für einen bestimmten Anzeigemodus Arbeit erforderlich ist. Angenommen, Sie Seite keine enthält ein <xref:System.Web.UI.WebControls.WebParts.EditorZone> Zone, scheint der Bearbeitungsmodus für die Anzeige in der Auflistung verweist die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes%2A> -Eigenschaft, aber nicht in der Auflistung verweist angezeigt werden würden die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> Eigenschaft.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, die programmgesteuerte Verwendung der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes%2A> Eigenschaft. Der Code verwendet diese Eigenschaft zum Auffüllen der Liste mit allen im Webparts-Steuerelementsatz verfügbaren Anzeigemodi, auch solche, die auf der aktuellen Seite nicht unterstützt werden. In diesem Groß-/Kleinschreibung, den Katalog und Modi werden nicht unterstützt, da die entsprechenden erforderlichen Zonen nicht auf der Seite vorhanden sind.  
  
 Die anderen drei Anzeigemodi – durchsuchen, Entwerfen und bearbeiten – werden auf der Seite unterstützt. Bearbeiten-Modus wird unterstützt, da die Seite enthält eine <xref:System.Web.UI.WebControls.WebParts.EditorZone> zone, beim Durchsuchen und Entwurfsmodi werden immer unterstützt.  
  
 Laden Sie die Seite in einem Browser, können Sie das Dropdownlisten-Steuerelement verwenden, um die Seite Durchsuchen-Modus in den Entwurfsmodus zu wechseln und dann in den Bearbeitungsmodus. In den Bearbeitungsmodus wechseln, können Sie auf die Dropdown-Verbmenü im Header der eines der Serversteuerelemente, und wählen **bearbeiten** auf das Steuerelement zu bearbeiten. Beachten Sie, dass bei Auswahl des **Katalog** oder **verbinden** in der Dropdown-Liste wird eine Fehlerseite generiert.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DisplayModes#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisplayModes/CS/wpmgrDisplayModescs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DisplayModes#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisplayModes/VB/wpmgrDisplayModesvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes" />
      </Docs>
    </Member>
    <Member MemberName="DynamicConnections">
      <MemberSignature Language="C#" Value="protected internal System.Web.UI.WebControls.WebParts.WebPartConnectionCollection DynamicConnections { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartConnectionCollection DynamicConnections" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" />
      <MemberSignature Language="VB.NET" Value="Protected Friend ReadOnly Property DynamicConnections As WebPartConnectionCollection" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ DynamicConnections { System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Auflistung aller dynamischen Verbindungen ab, die auf einer Webseite derzeit vorhanden sind.</summary>
        <value>Eine <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionCollection" />, die Verweise auf alle dynamischen Verbindungen auf einer Seite enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dynamische Verbindungen sind Verbindungen, die im Gegensatz zur statisch programmgesteuert erstellt werden. Statische Verbindungen werden durch die Deklaration im Markup der Web Forms-Seite erstellt. Dynamische Verbindungen werden entweder programmgesteuert oder durch einen Benutzer erstellen eine Verbindung mit der Verbindungs-Benutzeroberfläche (UI) gebildet.  
  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections%2A> -Auflistung ist schreibgeschützt und sein Inhalt kann nicht geändert werden, bietet programmgesteuerten Zugriff auf jedes dynamische Verbindungsobjekt.  
  
> [!NOTE]
>  Zum Ausführen häufig verwendeter Vorgänge wie z. B. eine Verbindung herstellen oder trennen <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelemente, Entwickler sollten verwendet die öffentlichen Methoden auf die <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Klasse, z. B. <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> und <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>, anstatt zu versuchen, eine Verbindung direkt zu ändern Objekte in der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections%2A> Auflistung.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicConnectionID" />
      </Docs>
    </Member>
    <Member MemberName="EditDisplayMode">
      <MemberSignature Language="C#" Value="public static readonly System.Web.UI.WebControls.WebParts.WebPartDisplayMode EditDisplayMode;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Web.UI.WebControls.WebParts.WebPartDisplayMode EditDisplayMode" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly EditDisplayMode As WebPartDisplayMode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ EditDisplayMode;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt den Anzeigemodus dar, in dem Endbenutzer Serversteuerelemente bearbeiten können. Dieses Feld ist schreibgeschützt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode> Feld verweist auf ein benutzerdefiniertes <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> -Objekt, das erstellt und enthalten die <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Steuerelement. Da dies ein statisches Objekt ist, finden Sie es direkt über die <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Klasse ohne eine Instanz des Steuerelements.  
  
 Wenn eine Seite mit den Webparts-erste geladen Steuerelemente, befindet sich im <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode> (Durchsuchenmodus) standardmäßig. Wenn Benutzer soll ein Serversteuerelement zu bearbeiten, müssen sie die Seite wechseln <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode> (edit Mode). Zweitens müssen sie ein Steuerelement zu bearbeiten, indem Sie auf Bearbeiten-Verb, auf die Verbmenü im Header des Steuerelements, auswählen. Nachdem das Steuerelement im Bearbeitungsmodus befindet, wird die Bearbeitung Benutzeroberfläche (UI) für die Bearbeitung des ausgewählten Steuerelements angezeigt.  
  
 Um Bearbeitungsmodus auf einer Seite zu aktivieren, muss die Seite enthalten mindestens eine <xref:System.Web.UI.WebControls.WebParts.EditorZone> Zone, die eine oder mehrere der bereitgestellten Edit enthält Steuerelemente, z. B. die <xref:System.Web.UI.WebControls.WebParts.LayoutEditorPart> Steuerelement oder benutzerdefinierte Steuerelemente.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode> programmgesteuert Feld. Der Code füllt eine Dropdownliste mit den unterstützten Anzeigemodi für die Seite zum Durchsuchen, Entwerfen und Bearbeiten in diesem Fall sind. Zur Unterstützung der Bearbeitung, ein `<asp:EditorZone>` Element wird auf der Seite. Beachten Sie, dass der `Page_PreRender` -Methode, die dem Code wird überprüft, ob die aktuelle <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> -Eigenschaftensatz auf <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode>. Wenn dies der Fall ist, `Label1` werden angezeigt, und falls nicht, `Label1` wird ausgeblendet.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_EditDisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_EditDisplayMode/CS/wpmgrEditDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_EditDisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_EditDisplayMode/VB/wpmgrEditDisplayModevb.aspx#1)]  
  
 Nachdem Sie die Seite in einem Browser geladen haben, können Sie im Durchsuchenmodus standardmäßig. Beachten Sie, dass die Bezeichnung auf der Seite ausgeblendet wird. Verwenden Sie das Dropdownlisten-Steuerelement, um die Seite, um den Bearbeitungsmodus wechseln. Beachten Sie, dass aufgrund des Codes in der `Page_PreRender` -Methode, die die Bezeichnung ist jetzt sichtbar. Klicken Sie auf die **bearbeiten** Verb im Verbmenü auf eines der Steuerelemente, aktivieren Sie dieses Steuerelement bearbeiten.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />
      </Docs>
    </Member>
    <Member MemberName="EnableClientScript">
      <MemberSignature Language="C#" Value="public virtual bool EnableClientScript { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableClientScript" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property EnableClientScript As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool EnableClientScript { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab oder legt ihn fest, der bestimmt, ob auf einer Webseite mit einem <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />-Steuerelement clientseitige Skripts aktiviert sind.</summary>
        <value>Ein boolescher Wert, der angibt, ob auf der Seite Clientskripts ausgeführt werden können. Der Standardwert ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript%2A> Eigenschaft bietet eine Möglichkeit für Entwickler Clientskripts deaktivieren. Sie sollten sich um Clientskripts aus Sicherheitsgründen deaktivieren und um sicherzustellen, dass alle Benutzer eine Seite eine ähnlichen Benutzeroberfläche hat, auch wenn sie andere Browser verwenden.  
  
 Sie können durch Hinzufügen von Clientskripts deaktivieren einer `EnableClientScript` -Attribut auf die <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Element auf einer Webseite, wie in der folgenden Codezeile deklarativen Code:  
  
 `<asp:webpartmanager id="manager" runat="server"`  
  
 `EnableClientScript="false" />`  
  
 Darüber hinaus können Entwickler diese Eigenschaft eliminieren, indem Sie erben von der <xref:System.Web.UI.WebControls.WebParts.WebPartManager> -Klasse und Festlegen der standardmäßigen Wert `false`.  
  
 Die Webparts-Steuerelementsatz verwendet Clientskripts um einige der Client-Benutzeroberfläche (UI) und Funktionen zur Personalisierung ermöglichen. Wenn Sie Client deaktivieren scripting Webparts Steuerelemente weiterhin funktionieren, aber einige Funktionen deaktiviert werden. Die Fähigkeit, ziehen Steuerelemente in anderen Zonen ist deaktiviert, sowie die Möglichkeit, die Verben in einem Dropdown-Verbenmenü in der Titelleiste eines Steuerelements rendern (die Verben werden stattdessen in der Titelleiste des Steuerelements als Links angezeigt).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableTheming">
      <MemberSignature Language="C#" Value="public override bool EnableTheming { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableTheming" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.EnableTheming" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property EnableTheming As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool EnableTheming { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, dass die Verwendung von Designs auf einer Webseite aktiviert ist.</summary>
        <value>Ein boolescher Wert, der angibt, ob Designs aktiviert sind. <see langword="true" /> in allen Fällen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Steuerelement überschreibt die <xref:System.Web.UI.Control.EnableTheming%2A> Eigenschaft, um sicherzustellen, dass sie stets einen Wert zurückgibt `true`. Dies geschieht, da die Webparts-Steuerelementsatzes die Verwendung von Designs bereit erfordert, um die Webparts zu rendern steuert, die untergeordnete Steuerelemente von werden die <xref:System.Web.UI.WebControls.WebParts.WebPartManager> -Steuerelement, und dass die Benutzeroberfläche (UI) einer Webseite zu bilden. Z. B. Designs werden verwendet, um die verschiedenen Zonen zu rendern, und die Steuerelemente, die in den Zonen, einschließlich der verschiedenen Typen von befinden Teil Steuerelemente (Steuerelemente, die von erben die <xref:System.Web.UI.WebControls.WebParts.Part> Klasse), Benutzersteuerelemente, ASP.NET-Serversteuerelemente und benutzerdefinierte Server Steuerelemente.  
  
 Obwohl die überschriebene <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EnableTheming%2A> Eigenschaft als Schreib-Lese-Eigenschaft in Übereinstimmung mit der Basiseigenschaft implementiert wird, da programmbedingt immer einen Wert zurückgeben müssen, legen Sie die Eigenschaft kann nicht `true`. Wenn Sie versuchen, die Eigenschaft festlegen einer <xref:System.NotSupportedException> Ausnahme wird ausgelöst.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Es wurde versucht, den Eigenschaftswert festzulegen.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndWebPartConnecting">
      <MemberSignature Language="C#" Value="public virtual void EndWebPartConnecting ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndWebPartConnecting() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndWebPartConnecting ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndWebPartConnecting();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Schließt den Prozess ab, mit dem eine Verbindung zwischen einem <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />-Steuerelement und einem anderen Steuerelement erstellt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting%2A> Methode beendet ist, die das Herstellen einer Verbindung eine <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelement zu einem anderen Steuerelement. Dies ist das Gegenstück zu der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting%2A> Methode.  
  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting%2A> Methode wird sichergestellt, dass die Personalisierungsobjekt verweist die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> Eigenschaft änderbar ist, das ist erforderlich, da, bilden eine Verbindung selbst ein Typ der Anpassung ist. Die Methode wird dann sichergestellt, dass die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A> Objekt ist kein `null`, und zum Schluss ruft das <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Das Steuerelement, auf das die <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" />-Eigenschaft verweist, ist <see langword="null" />.</exception>
        <block subset="none" type="overrides">
          <para>Entwickler, die erweitert die <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> Steuerelement diese Methode in einer abgeleiteten Klasse außer Kraft setzen möchten. Eine Herangehensweise bestünde zum Aufrufen der Basismethode, und fügen Sie dann einige zusätzliche benutzerdefinierte Behandlung oder möglicherweise den gesamten Prozess Abschluss eine Verbindung zwischen Steuerelementen vollständig angepasst werden soll.</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="EndWebPartEditing">
      <MemberSignature Language="C#" Value="public virtual void EndWebPartEditing ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndWebPartEditing() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndWebPartEditing ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndWebPartEditing();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Schließt den Prozess der Bearbeitung eines <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />-Steuerelements ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing%2A> Methode beendet den Prozess der Bearbeitung einer <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelement. Dies ist das Gegenstück zu der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing%2A> Methode.  
  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing%2A> Methode wird sichergestellt, dass die Personalisierungsobjekt verweist die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> Eigenschaft änderbar ist, das ist erforderlich, da ein Steuerelement bearbeiten ist ein Prozess, die geändert werden kann. Die Methode wird dann sichergestellt, dass die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A> Objekt ist kein `null`, sodass die aktuell ausgewählte <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelement ändern kann, und ruft schließlich die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Das Steuerelement, auf das die <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" />-Eigenschaft verweist, ist <see langword="null" />.</exception>
        <block subset="none" type="overrides">
          <para>Entwickler, die erweitert die <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> Steuerelement diese Methode in einer abgeleiteten Klasse außer Kraft setzen möchten. Eine Herangehensweise bestünde zum Aufrufen der Basismethode, und fügen Sie dann einige zusätzliche benutzerdefinierte Behandlung oder möglicherweise den gesamten Prozess Abschluss der Bearbeitung eines Steuerelements vollständig angepasst werden soll. Sie können z. B. in die Überschreibungsmethode, rufen zuerst die Basismethode und die fügen Sie Code, der bestimmt, welche Bearbeitung Änderungen vorgenommen wurden, und zeigt die Liste der Änderungen an den Endbenutzer als Bestätigung.</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="ExportSensitiveDataWarning">
      <MemberSignature Language="C#" Value="public virtual string ExportSensitiveDataWarning { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ExportSensitiveDataWarning" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.ExportSensitiveDataWarning" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ExportSensitiveDataWarning As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ExportSensitiveDataWarning { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Text einer Warnmeldung ab, die angezeigt wird, wenn versucht wird, vertrauliche Zustandsdaten aus einem <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />-Steuerelement zu exportieren, oder legt diesen Text fest.</summary>
        <value>Eine Zeichenfolge, die die Warnmeldung enthält. Die Standardmeldung ist ein von .NET Framework bereitgestellter kulturspezifischer Wert.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein Benutzer versucht, so exportieren Sie vertrauliche Daten aus einer <xref:System.Web.UI.WebControls.WebParts.WebPart> steuern, wenn der zu exportierenden Daten stammen aus einem Element, die im Quellcode als vertraulich markiert wurde, wird eine Warnmeldung angezeigt, für den Benutzer in einem Meldungsfeld an, die sie auffordert, die sensible Daten werden exportiert wird, und bietet eine Möglichkeit zum Abbrechen des Exports. Entwickler können ein bestimmtes Element Daten als vertraulich markieren, durch Festlegen der `isSensitive` Parameter von der `[Personalizable]` -Attribut auf `true` für das Element. Weitere Informationen zu diesem Attribut und diesem Parameter finden Sie unter der <xref:System.Web.UI.WebControls.WebParts.PersonalizableAttribute> Klasse.  
  
> [!IMPORTANT]
>  Bei Verwendung der Funktion zum Exportieren von Webparts konnte potenziell vertrauliche Daten nicht autorisierten Benutzern exportiert werden. Einzelheiten zum Schutz vor dieser Bedrohung finden Sie unter [Sichern von Webseiten Teile](http://msdn.microsoft.com/library/8ada6210-ed00-4157-b3e9-a7e87e77caa2).  
  
 Die Standardnachricht angezeigt, wenn Benutzer versuchen, zu exportieren. Doch durch Zuweisen eines Werts zur der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportSensitiveDataWarning%2A> -Eigenschaft, können Sie eine benutzerdefinierte Meldung der Warnung bereitstellen.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die deklarative Verwendung des der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportSensitiveDataWarning%2A> Eigenschaft.  
  
 Der Code für die folgenden Webseite verwendet einen Standard <xref:System.Web.UI.WebControls.BulletedList> steuern und platziert sie in einer Zone. Das Steuerelement wird mit umschlossen werden eine <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> Steuerelement zur Laufzeit, wodurch es "true" fungieren <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelement. Die das Steuerelement exportierbar ein `ExportMode` -Attribut hinzugefügt, die `<asp:bulletedlist>` Element und den Wert des Attributs auf festgelegt ist <xref:System.Web.UI.WebControls.WebParts.WebPartExportMode.All>, was bedeutet, dass diese vertraulichen und nicht vertrauliche Daten exportiert werden kann. Beachten Sie außerdem, dass in der `<asp:webpartmanager>` Element, das `ExportSensitiveDataWarning` Attribut ist ein benutzerdefinierter Wert zugewiesen.  
  
 Beachten Sie, dass für das Codebeispiel funktioniert, gibt es eine Einstellung, die Sie in der Datei "Web.config" So aktivieren Sie die Webparts Description-Dateien exportieren hinzufügen müssen. Stellen Sie sicher, dass Sie eine Datei "Web.config" im gleichen Verzeichnis wie die Webseite für dieses Codebeispiel verfügen. Innerhalb der `<system.web>` Abschnitt, stellen Sie sicher, dass eine `<webParts>` Element mit einem `enableExport` -Attributsatz zur `true`, wie im folgenden Markup.  
  
 `<webParts enableExport="true">`  
  
 `...`  
  
 `</webParts>`  
  
 [!code-aspx-csharp[WebParts_WebPartManager_ExportSensitiveData#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_ExportSensitiveData/CS/wpmgrExportSensitiveWarningCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_ExportSensitiveData#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_ExportSensitiveData/VB/wpmgrExportSensitiveWarningVB.aspx#1)]  
  
 Nachdem Sie die Seite in einem Browser geladen haben, klicken Sie auf Verbmenü (dargestellt durch einen Pfeil nach unten), in der Titelleiste des Steuerelements, das Links enthält. Wählen Sie im Verbenmenü **exportieren**, und beachten Sie, die ein Meldungsfeld mit der benutzerdefinierte Warnung angezeigt wird. Wenn Sie den Export fortsetzen möchten, klicken Sie auf **OK**, dem können Sie eine lokale Kopie einer XML-Beschreibungsdatei mit allen Daten über das Steuerelement zu speichern.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.ExportMode" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Xml.XmlWriter)" />
      </Docs>
    </Member>
    <Member MemberName="ExportWebPart">
      <MemberSignature Language="C#" Value="public virtual void ExportWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart, System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ExportWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart, class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Xml.XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ExportWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart, System::Xml::XmlWriter ^ writer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="webPart">Das Steuerelement, dessen Daten exportiert werden.</param>
        <param name="writer">Ein <see cref="T:System.Xml.XmlWriter" />, der die exportierten Daten von <c>webPart</c> in eine XML-Beschreibungsdatei schreibt.</param>
        <summary>Erstellt eine XML-Beschreibungsdatei, die Zustands- und Eigenschaftendaten für ein Serversteuerelement enthält.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart%2A> -Methode assembliert verschiedene Zustands- und Daten aus `webPart` in eine XML-Datei. Informationen über das Steuerelement selbst, einschließlich seiner Assembly, Zustandsdaten und Eigenschaftendaten enthält. Der Benutzer, die den Export initiiert kann die XML-Datei auf den Datenträger auf dem lokalen Computer oder im Netzwerk speichern. Andere Benutzer können dann Beschreibung in einer anderen Seite oder Website importieren und Anwenden von Zustands- und Daten in eine andere Instanz von `webPart`. Dadurch entsteht einen schnelle und bequeme Mechanismus für Benutzer freigeben und Wiederverwenden von ihren Einstellungen auf Serversteuerelemente, und auch bietet Entwicklern eine Möglichkeit zum steuern das Aussehen und Verhalten der exportierten und importierten Steuerelemente.  
  
 Eigenschaften für `webPart` werden standardmäßig nicht exportiert. Um den Export einer Eigenschaft zu aktivieren, müssen Sie markieren ihn mit dem `[Personalizable]` -Attribut im Quellcode. Sie können optional auch markieren, eine exportierbare Eigenschaft enthält vertrauliche Daten durch Festlegen der `isSensitive` Parameter von der `[Personalizable]` -Attribut auf `true`. Standardmäßig `isSensitive` ist `false`. Entwickler können die Parameter festlegen, um `true` um anzugeben, dass die Daten beachtet werden.  
  
 So aktivieren Sie `webPart` um exportiert werden, ein Entwickler legt seine <xref:System.Web.UI.WebControls.WebParts.WebPart.ExportMode%2A> Eigenschaftswert angibt, der entweder <xref:System.Web.UI.WebControls.WebParts.WebPartExportMode.All> (alle personalisierbare und vertrauliche Eigenschaften einschließlich), oder auf <xref:System.Web.UI.WebControls.WebParts.WebPartExportMode.NonSensitiveData>, dem exportiert alles mit Ausnahme von vertraulichen Eigenschaften .  
  
> [!IMPORTANT]
>  Zulassen, dass Benutzer, die zum Exportieren von Daten aus den Steuerelementen, und klicken Sie zum Importieren von Daten in andere Steuerelemente umfasst einige Sicherheitsrisiken. Entwickler sollten die Methode, die weiter oben erläuterten, zum Schutz sensibler Daten verwenden, und wenn sie das Risiko der Offenlegung von Daten vollständig vermeiden möchten, sollten sie Export nicht aktivieren, auf `webPart` überhaupt. Ausführliche auf Sicherheitsprobleme Webparts finden Sie unter [Sichern von Webseiten Teile](http://msdn.microsoft.com/library/8ada6210-ed00-4157-b3e9-a7e87e77caa2).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" /> ist <see langword="null" />.  
  
 \- oder –  
  
 <paramref name="writer" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="webPart" /> ist nicht in der Auflistung von Steuerelementen enthalten, auf die in <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" /> verwiesen wird.  
  
 \- oder –  
  
 Die <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.ExportMode" />-Eigenschaft von <paramref name="webPart" /> ist auf den Wert <see cref="F:System.Web.UI.WebControls.WebParts.WebPartExportMode.None" /> festgelegt. Dies bedeutet, dass der Export für <paramref name="webPart" /> deaktiviert ist.</exception>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.ExportMode" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart(System.Xml.XmlReader,System.String@)" />
      </Docs>
    </Member>
    <Member MemberName="Focus">
      <MemberSignature Language="C#" Value="public override void Focus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Focus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.Focus" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Focus ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Focus();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Überschrieben, um zu verhindern, dass der Fokus auf das <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />-Steuerelement gesetzt wird, weil dieses keine Benutzeroberfläche besitzt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Focus%2A> Methode überschreibt die <xref:System.Web.UI.Control.Focus%2A?displayProperty=nameWithType> -Methode, und löst eine Ausnahme aus, wenn ein Aufrufer der Methode aufruft. Da die <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Steuerelement über keine Benutzeroberfläche verfügt und nie für Benutzer sichtbar ist, kann es niemals zulassen, den Fokus auf sich selbst festgelegt werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Ein Aufrufer versucht, die <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.Focus" />-Methode aufzurufen, was bei einem Steuerelement ohne Benutzeroberfläche nicht unterstützt wird.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetConsumerConnectionPoints">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection GetConsumerConnectionPoints (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection GetConsumerConnectionPoints(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::ConsumerConnectionPointCollection ^ GetConsumerConnectionPoints(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">Ein Serversteuerelement, das als Consumer in einer Verbindung fungiert.</param>
        <summary>Ruft eine Auflistung von <see cref="T:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />-Objekten ab, die als Verbindungspunkte von einem Serversteuerelement verwendet werden können, das als Consumer in einer Webparts-Verbindung fungiert.</summary>
        <returns>Eine <see cref="T:System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection" />, die alle Verbindungspunkte im Consumer enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Immer eine Webparts-Verbindung umfasst genau zwei Steuerelemente als Datenanbieter, das andere fungiert als Consumer von Daten dient. Jedes Steuerelement benötigen eine oder mehrere Methoden, die als Verbindungspunkte definiert sind. Im Fall eines Consumersteuerelements seine Verbindungspunkte sind <xref:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint> Objekte. Das Abrufen der Consumerverbindungspunkte ist ein notwendiger Schritt in einer Webparts-Verbindung zu bilden.  
  
 Ein Consumer benötigen immer mindestens ein Verbindungspunkt, um eine Verbindung herstellen zu können. Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints%2A> Methode überprüft, ein Consumer-Steuerelement, und ruft eine Auflistung aller Verbindungspunkte ab. Wenn ein <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelement hat keine Verbindungspunkte, gibt die Methode eine leere Auflistung zurück.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt, wie Sie die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints%2A>-Methode verwenden.  
  
 Das Codebeispiel besteht aus vier Teilen:  
  
-   Ein Benutzersteuerelement, das Ihnen ermöglicht, ändern Sie die Anzeigemodi auf einer Webparts-Seite.  
  
-   Eine Webseite mit zwei benutzerdefinierte <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelemente, die verbunden werden können, und ein `<asp:webpartmanager>` Element.  
  
-   Eine Quellcodedatei, die zwei benutzerdefinierte enthält <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelemente und eine benutzerdefinierte Schnittstelle.  
  
-   Eine Erläuterung der Funktionsweise des Beispiels in einem Browser.  
  
 Der erste Teil des Codebeispiels wird das Benutzersteuerelement zum Ändern des Anzeigemodus. Sie können den Quellcode für das Benutzersteuerelement abrufen, der im Abschnitt "Beispiel" die <xref:System.Web.UI.WebControls.WebParts.WebPartManager> -Klassenübersicht. Weitere Informationen zu Anzeigemodi und zur Funktionsweise des Benutzersteuerelements, finden Sie im Thema [Exemplarische Vorgehensweise: Ändern des Anzeigemodus auf einer Webparts-Seite](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0).  
  
 Das deklarative Markup für die Webseite enthält `Register` -Direktiven für das Benutzersteuerelement und die benutzerdefinierten Steuerelemente. Besteht eine `<asp:webpartmanager>` Element, ein `<asp:webpartzone>` Element enthält die benutzerdefinierten Steuerelemente und ein `<asp:connectionszone>` Element. Beachten Sie, dass in der `Page_Load` -Methode, der Code überprüft, ob eine Verbindung ist bereits vorhanden und, falls nicht, einen Anbieter, ein Consumer und ihre jeweiligen Verbindungspunkte definiert und fügt dann eine neue Verbindung auf den Satz von statischen Verbindungen verweist die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A> Eigenschaft. Beachten Sie, dass die <xref:System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection> mit abgerufenen Objekts die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints%2A> Methode übergeben, die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A> Methode, um zu bestimmen, ob eine Verbindung zwischen den zwei Steuerelementen erstellt werden kann.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/CS/wpmgrStaticConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/VB/wpmgrStaticConnectionVB.aspx#1)]  
  
 Der dritte Teil des Beispiels wird der Quellcode für die Steuerelemente. Sie können dieser Code und die Anweisungen zu kompilieren, der im Abschnitt "Beispiel" Abrufen der <xref:System.Web.UI.WebControls.WebParts.WebPartManager> -Klassenübersicht.  
  
 Nachdem Sie die Webseite in einem Browser geladen haben, klicken Sie auf die **Anzeigemodus** Dropdownlisten-Steuerelement, und wählen **verbinden** Verbinden-Modus zu wechseln. Verbinden Sie-Modus verwendet die `<asp:connectionszone>` Element, um Verbindungen zwischen Steuerelementen erstellen können. Im Modus verbinden, klicken Sie auf den Pfeil nach unten in der Titelleiste des der **Postleitzahl** Steuerelement, um seine Verbmenü aktivieren, und klicken Sie dann auf **verbinden**. Beachten Sie, dass durch den Code in den bereits eine Verbindung erstellt wurde, nachdem die Verbindungs-Benutzeroberfläche (UI) angezeigt wird, die `Page_Load` Methode. Wenn Sie in einer späteren Browsersitzung zu dieser Seite zurückkehren, werden diese statische Verbindung bereits eingerichtet werden und muss nicht jedes Mal neu erstellt werden, die die Seite geladen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" /> ist <see langword="null" />.</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentWebPartManager">
      <MemberSignature Language="C#" Value="public static System.Web.UI.WebControls.WebParts.WebPartManager GetCurrentWebPartManager (System.Web.UI.Page page);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Web.UI.WebControls.WebParts.WebPartManager GetCurrentWebPartManager(class System.Web.UI.Page page) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager(System.Web.UI.Page)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Web::UI::WebControls::WebParts::WebPartManager ^ GetCurrentWebPartManager(System::Web::UI::Page ^ page);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartManager</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="page" Type="System.Web.UI.Page" />
      </Parameters>
      <Docs>
        <param name="page">Die Webseite, die eine Instanz von <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> enthält.</param>
        <summary>Ruft einen Verweis auf die aktuelle Instanz des <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />-Steuerelements auf einer Seite ab.</summary>
        <returns>Ein <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />, der auf die aktuelle Instanz des Steuerelements auf einer Seite verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager%2A> Methode ist nützlich in Kontexten, in dem Sie einen Verweis auf die aktuelle abrufen möchten <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Steuerelement. Ein häufiges Szenario, in denen dies wäre möglich, ist, wenn Sie ein benutzerdefiniertes Steuerelement schreiben, die während der Entwicklung wissen, welche die ID des kann nicht die <xref:System.Web.UI.WebControls.WebParts.WebPartManager> -Steuerelement auf einer Seite sein wird.  
  
> [!NOTE]
>  Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager%2A> Methode ist statisch, damit Sie sie aufrufen können, ohne eine Instanz der direkt einem <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Steuerelement.  
  
 Einige Steuerelemente im Webparts-Steuerelementsatz, z. B. <xref:System.Web.UI.WebControls.WebParts.WebPart> -Steuerelemente haben eine <xref:System.Web.UI.WebControls.WebParts.WebPart.WebPartManager%2A> Eigenschaft, die einen Verweis auf die aktuelle abrufen können <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Steuerelement. Daher sollten bei der Arbeit mit solche Steuerelemente Sie diese Eigenschaft verwenden, um einen Verweis abzurufen.  
  
 Wenn Codierung in einem Kontext, in dem Sie die ID des kennen, die <xref:System.Web.UI.WebControls.WebParts.WebPartManager> steuern, z. B. Schreiben Code Inline innerhalb einer Webseite, ist es am einfachsten und am effizientesten, verweisen direkt an die <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Steuerung mithilfe seiner ID  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt, wie Sie die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager%2A>-Methode verwenden. Das Beispiel besteht aus zwei Teilen: ein benutzerdefiniertes Steuerelement und einer Webseite, die das Steuerelement hostet.  
  
 Die benutzerdefinierte <xref:System.Web.UI.WebControls.Label> steuern verwendet der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager%2A> Methode zum Abrufen der ID des der <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Steuerelement auf der aktuellen Seite und zeigt die-ID.  
  
 [!code-csharp[WebParts_WebPartManager_GetCurrentWebPartManager#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_GetCurrentWebPartManager/CS/MyManagerIDLabel.cs#2)]
 [!code-vb[WebParts_WebPartManager_GetCurrentWebPartManager#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_GetCurrentWebPartManager/VB/MyManagerIDLabel.vb#2)]  
  
 Das folgende Codebeispiel stellt die Webseite, die das Steuerelement im hostet eine <xref:System.Web.UI.WebControls.WebParts.WebPartZone> Zone.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_GetCurrentWebPartManager#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_GetCurrentWebPartManager/CS/getCurrentWPManagerCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_GetCurrentWebPartManager#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_GetCurrentWebPartManager/VB/getcurrentWPManagervb.aspx#1)]  
  
 Nachdem Sie die Seite in einem Browser geladen haben, beachten Sie, dass die ID des aktuellen <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Steuerelement wird angezeigt, in die benutzerdefinierte <xref:System.Web.UI.WebControls.Label> Steuerelement.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="page" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetDisplayTitle">
      <MemberSignature Language="C#" Value="protected internal virtual string GetDisplayTitle (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance string GetDisplayTitle(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetDisplayTitle(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::String ^ GetDisplayTitle(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">Das Steuerelement, für das die Methode den Wert von <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle" /> zurückgibt.</param>
        <summary>Ruft eine Zeichenfolge ab, die den Wert für die <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle" />-Eigenschaft eines <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />-Steuerelements enthält.</summary>
        <returns>Eine Zeichenfolge, die den berechneten Wert von <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle" /> für <paramref name="webPart" /> enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ruft den berechneten Wert der <xref:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle%2A> -Eigenschaft für `webPart`. Wenn Entwickler weisen einen Wert, der die <xref:System.Web.UI.WebControls.WebParts.Part.Title%2A> Eigenschaft ein <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelement diese Methode gibt den Wert, der als Titel angezeigt. Der berechnete Wert für unbenannte Steuerelemente besteht aus einer Zahl in eine Zeichenfolge mit der Nummer, der angibt, die Sequenznummer des Steuerelements in der aktuellen Zone angefügt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="webPart" /> ist nicht in der <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" />-Auflistung enthalten.</exception>
        <block subset="none" type="overrides">
          <para>Diese Methode kann überschrieben werden, um ändern, wie die Anzeige Standardtitel berechnet wird.</para>
        </block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle" />
      </Docs>
    </Member>
    <Member MemberName="GetExportUrl">
      <MemberSignature Language="C#" Value="public string GetExportUrl (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetExportUrl(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetExportUrl(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetExportUrl(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">Der <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />, der exportiert wird.</param>
        <summary>Ruft den relativen virtuellen Pfad und die Abfragezeichenfolge ab, die bei dem Versuch, ein <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />-Steuerelement zu exportieren, Teil der Anforderung sind.</summary>
        <returns>Eine Zeichenfolge, die den relativen virtuellen Pfad und die Abfragezeichenfolge enthält, die zusammen die Anforderung zum Exportieren eines Steuerelements bilden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der zurückgegebene Wert den <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetExportUrl%2A> Methode entspricht dem relativen virtuellen Pfad an den Serverspeicherort der Seite, die das Steuerelement enthält, sowie den Wert der angefügten Abfragezeichenfolge, die bildet die exportanforderung an den Server gesendet. Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetExportUrl%2A> Methode die Zeichenfolge codiert, bevor die Anforderung gesendet werden, um Schutz vor Angriffen durch böswillige Skripts zugelassen.  
  
> [!NOTE]
>  Weitere Informationen zum Sichern von Webparts-Anwendungen finden Sie unter [Sichern von Webseiten Teile](http://msdn.microsoft.com/library/8ada6210-ed00-4157-b3e9-a7e87e77caa2).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Xml.XmlWriter)" />
      </Docs>
    </Member>
    <Member MemberName="GetGenericWebPart">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.GenericWebPart GetGenericWebPart (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.UI.WebControls.WebParts.GenericWebPart GetGenericWebPart(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::UI::WebControls::WebParts::GenericWebPart ^ GetGenericWebPart(System::Web::UI::Control ^ control);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.GenericWebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">Ein Serversteuerelement, das sich in einer <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> befindet und zur Laufzeit als untergeordnetes Steuerelement eines <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> umschlossen wird.</param>
        <summary>Ruft einen Verweis auf die Instanz des <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />-Steuerelements ab, die ein Serversteuerelement enthält.</summary>
        <returns>Ein <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />, der <paramref name="control" /> als untergeordnetes Steuerelement umschließt. Die Methode gibt <see langword="null" /> zurück, wenn <paramref name="control" /> nicht in einem <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> enthalten ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Im Allgemeinen stehen zwei Kategorien von Steuerelementen, die Entwickler in platzieren <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> Zonen zur Teilnahme an Webparts-Anwendungen: <xref:System.Web.UI.WebControls.WebParts.WebPart> -Steuerelemente, die von erben die <xref:System.Web.UI.WebControls.WebParts.WebPart> Basisklasse und anderen Serversteuerelementen, die standardmäßige sein können ASP.NET-Steuerelemente, benutzerdefinierte Steuerelemente oder Benutzersteuerelemente. Wenn eines dieser Steuerelemente in platziert eine <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> Zone, nimmt es die Funktionalität von einer <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelement. Ein <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelement diese Funktionalität grundsätzlich, jedoch nicht der Fall ist der andere Arten von Serversteuerelementen. So aktivieren Sie den anderen Serversteuerelementen fungieren als <xref:System.Web.UI.WebControls.WebParts.WebPart> steuert, wann sie in platziert werden eine <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> Zone umschließt ASP.NET mit einer <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> Steuerelement. Da die <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> Steuerelement erbt direkt von der <xref:System.Web.UI.WebControls.WebParts.WebPart> -Klasse, bietet der untergeordneten Steuerelemente mit "true" Webparts-Funktionen.  
  
 Seitenentwickler sollten häufig zur Laufzeit zum Abrufen eines Verweises auf die <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> Steuerelement, das eines der Steuerelemente in einer Zone enthält. Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart%2A> -Methode ermöglicht es ihnen, einen Verweis zum Abrufen der <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> Steuerelement.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart%2A> Methode. Das Codebeispiel enthält ein <xref:System.Web.UI.WebControls.Calendar> Steuerelement deklariert innerhalb einer <xref:System.Web.UI.WebControls.WebParts.WebPartZone> Zone. Die `Button1_Click` Methode gibt zuerst die ID des der <xref:System.Web.UI.WebControls.Calendar> Steuerelement eine Bezeichnung, und klicken Sie dann verwendet der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart%2A> Methode zum Abrufen der eines Verweis auf die <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> Steuerelement, das den Kalender umschließt. Die ID des der <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> -Steuerelement, und die ID des untergeordneten Steuerelements (also die <xref:System.Web.UI.WebControls.Calendar> Steuerelement), werden zu einer zweiten Bezeichnung gedruckt.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_GetGenericWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_GetGenericWebPart/CS/getGenericWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_GetGenericWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_GetGenericWebPart/VB/getGenericWebPartVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="control" /> ist <see langword="null" />.</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />
      </Docs>
    </Member>
    <Member MemberName="GetProviderConnectionPoints">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection GetProviderConnectionPoints (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection GetProviderConnectionPoints(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::ProviderConnectionPointCollection ^ GetProviderConnectionPoints(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">Ein Serversteuerelement, das als Anbieter in einer Verbindung fungiert.</param>
        <summary>Ruft eine Auflistung von <see cref="T:System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />-Objekten ab, die als Verbindungspunkte von einem Serversteuerelement verwendet werden können, das als Anbieter in einer Webparts-Verbindung fungiert.</summary>
        <returns>Eine <see cref="T:System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection" />, die alle Verbindungspunkte im Anbieter enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Immer eine Webparts-Verbindung umfasst genau zwei Steuerelemente als Datenanbieter, das andere fungiert als Consumer von Daten dient. Jedes Steuerelement benötigen eine oder mehrere Methoden, die als Verbindungspunkte definiert sind. Im Fall eines Anbietersteuerelements seine Verbindungspunkte sind <xref:System.Web.UI.WebControls.WebParts.ProviderConnectionPoint> Objekte.  
  
 Ein Anbieter benötigen immer mindestens ein Verbindungspunkt, um eine Verbindung herstellen zu können. Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints%2A> Methode überprüft ein Anbietersteuerelement, und ruft eine Auflistung aller Verbindungspunkte ab. Das Abrufen der Anbieterverbindungspunkte ist ein notwendiger Schritt in einer Webparts-Verbindung zu bilden.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt, wie Sie die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints%2A>-Methode verwenden.  
  
 Das Beispiel besteht aus vier Teilen:  
  
-   Ein Benutzersteuerelement, das Ihnen ermöglicht, ändern Sie die Anzeigemodi auf einer Webparts-Seite.  
  
-   Eine Webseite mit zwei benutzerdefinierte <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelemente, die verbunden werden können, und ein `<asp:webpartmanager>` Element.  
  
-   Eine Quellcodedatei, die zwei benutzerdefinierte enthält <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelemente und eine benutzerdefinierte Schnittstelle.  
  
-   Eine Erläuterung der Funktionsweise des Beispiels in einem Browser.  
  
 Der erste Teil des Codebeispiels wird das Benutzersteuerelement zum Ändern des Anzeigemodus. Sie können den Quellcode für das Benutzersteuerelement abrufen, der im Abschnitt "Beispiel" die <xref:System.Web.UI.WebControls.WebParts.WebPartManager> -Klassenübersicht. Weitere Informationen zu Anzeigemodi und zur Funktionsweise des Benutzersteuerelements, finden Sie unter [Exemplarische Vorgehensweise: Ändern des Anzeigemodus auf einer Webparts-Seite](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0).  
  
 Das deklarative Markup für die Webseite enthält `Register` -Direktiven für das Benutzersteuerelement und die benutzerdefinierten Steuerelemente. Besteht eine `<asp:webpartmanager>` Element, ein `<asp:webpartzone>` Element enthält die benutzerdefinierten Steuerelemente und ein `<asp:connectionszone>` Element. Beachten Sie, dass in der `Page_Load` -Methode, der Code überprüft, ob eine Verbindung ist bereits vorhanden und, falls nicht, einen Anbieter, ein Consumer und ihre jeweiligen Verbindungspunkte definiert und fügt dann eine neue Verbindung auf den Satz von statischen Verbindungen verweist die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A> Eigenschaft. Beachten Sie, dass die <xref:System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection> mit abgerufenen Objekts die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints%2A> Methode übergeben, die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A> Methode, um zu bestimmen, ob eine Verbindung zwischen den zwei Steuerelementen erstellt werden kann.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/CS/wpmgrStaticConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/VB/wpmgrStaticConnectionVB.aspx#1)]  
  
 Der dritte Teil des Beispiels wird der Quellcode für die Steuerelemente. Sie können dieser Code und die Anweisungen zu kompilieren, der im Abschnitt "Beispiel" Abrufen der <xref:System.Web.UI.WebControls.WebParts.WebPartManager> -Klassenübersicht.  
  
 Nachdem Sie die Webseite in einem Browser geladen haben, klicken Sie auf die **Anzeigemodus** Dropdownlisten-Steuerelement, und wählen **verbinden** Verbinden-Modus zu wechseln. Verbinden Sie-Modus verwendet die `<asp:connectionszone>` Element, um Verbindungen zwischen Steuerelementen erstellen können. Im Modus verbinden, klicken Sie auf den Pfeil nach unten in der Titelleiste des der **Postleitzahl** Steuerelement, um seine Verbmenü aktivieren, und klicken Sie dann auf **verbinden**. Beachten Sie, dass durch den Code in den bereits eine Verbindung erstellt wurde, nachdem die Verbindungs-Benutzeroberfläche (UI) angezeigt wird, die `Page_Load` Methode. Wenn Sie in einer späteren Browsersitzung zu dieser Seite zurückkehren, werden diese statische Verbindung bereits eingerichtet werden und muss nicht jedes Mal neu erstellt werden, die die Seite geladen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" /> ist <see langword="null" />.</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="ImportWebPart">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.WebPart ImportWebPart (System.Xml.XmlReader reader, out string errorMessage);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.WebPart ImportWebPart(class System.Xml.XmlReader reader, [out] string&amp; errorMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart(System.Xml.XmlReader,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ImportWebPart (reader As XmlReader, ByRef errorMessage As String) As WebPart" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::WebPart ^ ImportWebPart(System::Xml::XmlReader ^ reader, [Runtime::InteropServices::Out] System::String ^ % errorMessage);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="errorMessage" Type="System.String&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="reader">Ein <see cref="T:System.Xml.XmlReader" />, der die Zustands- und Eigenschaftendaten aus der zu importierenden XML-Beschreibungsdatei liest.</param>
        <param name="errorMessage">Ein <see cref="T:System.String" />, der angezeigt wird, wenn während des Imports ein Fehler auftritt.</param>
        <summary>Importiert eine XML-Beschreibungsdatei, die Zustands- und Eigenschaftendaten für ein <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />-Steuerelement enthält, und wendet die Daten auf das Steuerelement an.</summary>
        <returns>Ein <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />-Steuerelement (oder ein Serversteuerelement, das mit einem <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> umschlossen ist und daher als <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> behandelt wird), auf das in der importierten XML-Beschreibungsdatei verwiesen wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart%2A> -Methode importiert eine XML-Beschreibungsdatei durch die erstellte die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart%2A> Methode nach einem Serversteuerelement. Es ist nicht das tatsächliche Serversteuerelement, das importiert wird, aber nur der Description-Datei, Status und die Eigenschaft zum Steuerelement enthält. Das Steuerelement und die Assembly verwiesen wird, in der Description-Datei müssen bereits auf dem Server verfügbar sein, in denen ein Benutzer versucht, die Description-Datei zu importieren.  
  
 Zum Importieren eines Steuerelements zu aktivieren, muss ein Entwickler Hinzufügen einer <xref:System.Web.UI.WebControls.WebParts.CatalogZone> Steuerelement auf der Seite, wo Import aktiviert werden. In der Zone ein <xref:System.Web.UI.WebControls.WebParts.ImportCatalogPart> Steuerelement muss hinzugefügt werden. Dieses Steuerelement stellt eine Datei (Dialogfeld), die ermöglicht Benutzern das Durchsuchen und die, die zu importierende Beschreibungsdatei zu suchen.  
  
 Nachdem ein Benutzer eine Beschreibungsdatei sucht und den Import startet, wird die Description-Datei lesen, durch die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart%2A> Methode. Wenn keine Fehler vorliegen, und wenn die Assembly und das Steuerelement gefunden werden, wird das Serversteuerelement, in den Katalog in hinzugefügt der <xref:System.Web.UI.WebControls.WebParts.ImportCatalogPart> Steuerelement und die verschiedenen Eigenschaften- und Zustandsdaten Daten, die in der Description-Datei angegeben, die auf das Steuerelement angewendet werden. Der Benutzer kann dann wählen Sie das Steuerelement und der Seite hinzugefügt wird.  
  
> [!IMPORTANT]
>  Wie die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart%2A> -Methode, die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart%2A> Methode verfügt über einige potenzielle Sicherheitsrisiken. Da es beinhaltet das Importieren von Daten in einer Website, könnte ein böswilliger Benutzer versuchen, zum Einfügen von fehlerhaften Daten oder sogar Skriptcode in der Description-Datei, die importiert werden. Klicken Sie dann konnte die ungültigen Daten auf einer Seite oder in einer Datenbank angezeigt werden, oder das eingefügte Skript ausführen kann. Einen Überblick über die potenziellen Risiken im Zusammenhang mit dem Import von Beschreibungsdateien sowie Möglichkeiten zur Vermeidung dieser Risiken finden Sie unter [Sichern von Webseiten Teile](http://msdn.microsoft.com/library/8ada6210-ed00-4157-b3e9-a7e87e77caa2).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="reader" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.EndOfStreamException">
          <paramref name="reader" /> konnte die Datei nicht lesen.  
  
 \- oder –  
  
 <paramref name="reader" /> hätte eine Importfehlermeldung anzeigen müssen, fand aber in der Datei keine entsprechende Meldung.  
  
 \- oder –  
  
 <paramref name="reader" /> hat das Ende der Datei erreicht, ohne das XML-Element gefunden zu haben, das die exportierten Daten enthält.</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.ImportCatalogPart" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Xml.XmlWriter)" />
      </Docs>
    </Member>
    <Member MemberName="Internals">
      <MemberSignature Language="C#" Value="protected System.Web.UI.WebControls.WebParts.WebPartManagerInternals Internals { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartManagerInternals Internals" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Internals" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Internals As WebPartManagerInternals" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::UI::WebControls::WebParts::WebPartManagerInternals ^ Internals { System::Web::UI::WebControls::WebParts::WebPartManagerInternals ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartManagerInternals</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Verweis auf die <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManagerInternals" />-Klasse ab, die verwendet wird, um einen Satz von Methoden zu kombinieren und aufzuteilen, die eigentlich in der <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />-Klasse implementiert sind, aber vor allem für Steuerelemententwickler nützlich sind.</summary>
        <value>Ein <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManagerInternals" />-Objekt, über das <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> auf die verschiedenen Methoden verweisen kann, die in <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManagerInternals" /> aufgeteilt wurden.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Internals%2A> Eigenschaft macht die APIs aufrufen, in einen Satz von <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Methoden, die größtenteils Erweiterbarkeit verwendet werden.  
  
 Die entworfene Möglichkeit, diese internen Methoden wird über den Zugriff auf die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Internals%2A> Eigenschaft. Da die Eigenschaft geschützt ist, können nur darauf zugreifen und rufen Sie die Methoden innerhalb einer Instanz von der <xref:System.Web.UI.WebControls.WebParts.WebPartManagerInternals> Klasse durch Erben von der <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Klasse.  
  
> [!NOTE]
>  Diese Eigenschaft wird von IntelliSense in ausgeblendet [!INCLUDE[vsprvsext](~/includes/vsprvsext-md.md)]. Allerdings in einer abgeleiteten <xref:System.Web.UI.WebControls.WebParts.WebPartManager> -Klasse, können Sie die Eigenschaft und ihre verschiedenen Member weiterhin zugreifen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsAuthorized">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Bestimmt, ob einer Seite ein <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />-Steuerelement oder ein anderes Serversteuerelement hinzugefügt werden kann.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Teil der Flexibilität des Webparts-Features ist die Möglichkeit, Webseiten zur Laufzeit Serversteuerelemente hinzuzufügen. Es gibt diverse häufig vorkommende Szenarien, in denen ein Serversteuerelement (erfolgen kann eine benutzerdefinierte <xref:System.Web.UI.WebControls.WebParts.WebPart> -Steuerelement, ein benutzerdefiniertes Steuerelement, ein benutzerdefiniertes Steuerelement oder ein ASP.NET-Steuerelement) hinzugefügt werden können.  
  
 In den folgenden allgemeinen Szenarien der Webparts-Steuerelementsatz Satz Versuche Serversteuerelemente zu einer Seite hinzufügen und die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> Methode wird aufgerufen, um zu erteilen:  
  
-   Wenn ein Steuerelement hinzugefügt wird, deklarieren Sie es in das Markup einer Webseite in einem <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> Zone.  
  
-   Wenn ein Serversteuerelement programmgesteuert zu einer Zone hinzugefügt wird.  
  
-   Wenn ein Benutzer ein Serversteuerelement in einer Webparts-Katalog von Steuerelementen importiert.  
  
-   Wenn ein vorhandenes wird Webserversteuerelement aus dem Personalisierungsdatenspeicher geladen.  
  
-   Wenn ein Steuerelement hinzugefügt wird ein <xref:System.Web.UI.WebControls.WebParts.DeclarativeCatalogPart> Steuerelement in einem Katalog von Serversteuerelementen verfügbar machen.  
  
 In jedem Szenario, in dem Steuerelemente hinzugefügt werden, die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> Methode wird aufgerufen, um sicherzustellen, dass alle Autorisierungskriterien erfüllt sind, um ein Steuerelement hinzugefügt werden kann. Wenn ein Steuerelement autorisiert ist, wird er normalerweise wäre, wenn es keine Filterszenarios wurde hinzugefügt. Wenn ein Steuerelement nicht autorisiert ist, kann die Webparts-Steuerelementsatzes in mehrere Möglichkeiten, je nach Kontext reagieren. Die Steuerelementsatzes kann ohne Meldung fehl, einen nicht autorisierten Teil hinzufügen (wenn es nicht erforderlich ist, den Benutzer zu informieren), es kann eine Fehlermeldung angezeigt oder können sie eine Instanz des Hinzufügen der <xref:System.Web.UI.WebControls.WebParts.UnauthorizedWebPart> Klasse als Platzhalter. Dieser Platzhalterobjekt ist auf der Seite nicht sichtbar, aber Sie werden in den Quellcode der Seite, um anzugeben, dass ein nicht autorisierter Steuerelement ausgeschlossen wurde.  
  
 Die Determinante der gibt an, ob ein Steuerelement autorisiert ist, ist der Autorisierungsfilter. Ein Autorisierungsfilter ist ein Feature in der Webparts-Steuerelementsatz, der ermöglicht es Entwicklern, die von einer Seite alle Steuerelemente ausschließen, die die angegebenen Kriterien nicht erfüllen.  
  
 Um ein Filterszenario zu erstellen, müssen Entwickler zwei Dinge tun. Zunächst müssen sie einen String-Wert (der Wert kann beliebige sein), zum Zuweisen der <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> -Eigenschaft jedes <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelement, die sie in diesem Szenario verwenden möchten. Sie können diese Eigenschaft für andere Typen von Serversteuerelementen, die nicht auch einen Wert zuweisen <xref:System.Web.UI.WebControls.WebParts.WebPart> steuert, da, wenn sie in gespeichert werden <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> Zonen, solche Steuerelemente sind in eingeschlossen ein <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> Steuerelement zur Laufzeit und dieses Steuerelement erbt die <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> Eigenschaft.  
  
 Der zweite erforderliche Schritt zum Erstellen eines Filterszenarios ist entweder Überschreibung der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29> -Methode, oder erstellen einen Ereignishandler für das <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> Ereignis. In diesen Methoden kann Entwickler Überprüfen der <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> -Eigenschaft, und wenn der Wert gibt an, dass das Steuerelement nicht autorisiert werden soll, dass der Entwickler der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> Methode gibt einen Wert von `false`.  
  
> [!NOTE]
>  Codebeispiele und eine Beschreibung zum Einrichten eines benutzerdefinierten Filtern Szenario mit der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> -Methode finden Sie unter den Themen für die Überladung der Methode.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />
      </Docs>
    </MemberGroup>
    <Member MemberName="IsAuthorized">
      <MemberSignature Language="C#" Value="public bool IsAuthorized (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsAuthorized(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsAuthorized(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">Ein <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />-Steuerelement oder ein anderes Serversteuerelement, dessen Autorisierung geprüft wird.</param>
        <summary>Führt die ersten Schritte des Prozesses aus, mit dem bestimmt wird, ob für das Steuerelement eine Autorisierung vorhanden ist und es einer Seite hinzugefügt werden darf.</summary>
        <returns>Ein boolescher Wert, der angibt, ob <paramref name="webPart" /> einer Seite hinzugefügt werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> Methode ist die erste Methode aufgerufen, indem Sie die Webparts-Steuerelementsatz zum Überprüfen der Autorisierung für eine <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelement. Er akzeptiert `webPart` als Parameter, und startet einen Prozess, der letztlich bestimmt, ob das Steuerelement auf einer Seite hinzugefügt wird. Rufen Sie diese Methode aus dem Code direkt fest, wenn Sie benötigen, um zu bestimmen, ob ein bestimmtes Steuerelement autorisiert ist.  
  
 Diese Methode führt die anfängliche Aufgaben, um zu bestimmen, ob das Steuerelement erbt die <xref:System.Web.UI.WebControls.WebParts.WebPart> Klasse oder ist eine <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> steuern und, wenn dies der Fall ist, welcher Typ von untergeordneten Steuerelementen es enthält. Um die Autorisierung abzuschließen, ruft er die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29> Methode überladen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie zum Aufrufen der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Web.UI.WebControls.WebParts.WebPart%29> -Methode aus dem Code, um zu bestimmen, ob ein Steuerelement autorisiert ist, eine Seite hinzugefügt werden.  
  
 Das Codebeispiel besteht aus drei Teilen:  
  
-   Eine benutzerdefinierte <xref:System.Web.UI.WebControls.WebParts.WebPartManager> -Steuerelement, überschreibt die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> Methode.  
  
-   Eine Webseite, erstellt einen Filter für, eine <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelement.  
  
-   Eine Erläuterung dazu, wie im Codebeispiel wird ausgeführt.  
  
 Dieses Codebeispiel verwendet eine benutzerdefinierte <xref:System.Web.UI.WebControls.WebParts.WebPartManager> -Steuerelement, überschreibt die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29> Überladung der Methode, um benutzerdefinierte Behandlung anzugeben der <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> Eigenschaft. Dieses Steuerelement für einen Eigenschaftswert, der überprüft `admin` und, wenn der Wert vorhanden ist, autorisiert das Steuerelement. Wenn ein Steuerelement einen anderen Wert aufweist, ist es nicht autorisiert; Steuerelemente ohne den Wert der Eigenschaft sind ebenfalls berechtigt, wie sie nicht als Teil der Filterszenarios Filterszenario.  
  
 Für dieses Codebeispiel ausführen müssen Sie diesen Quellcode kompilieren. Sie können es explizit kompilieren und legen Sie die resultierende Assembly im Bin-Ordner der Website oder dem globalen Assemblycache. Alternativ können Sie den Quellcode im Ordner "App_Code" des Standorts, ablegen, wo er zur Laufzeit dynamisch kompiliert wird. Dieses Codebeispiel verwendet die dynamische Kompilierungsmethode. Eine exemplarische Vorgehensweise zum Kompilieren, veranschaulicht, finden Sie unter [Exemplarische Vorgehensweise: Entwickeln und Verwenden eines benutzerdefinierten Webserver-Steuerelements](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08).  
  
 [!code-csharp[WebParts_WebPartManager_IsAuthorized#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/CS/MyManagerAuthorize.cs#2)]
 [!code-vb[WebParts_WebPartManager_IsAuthorized#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/VB/MyManagerAuthorize.vb#2)]  
  
 Der zweite Teil des Codebeispiels wird ein Filter erstellt, der ein Steuerelement ausgeschlossen werden kann. Der folgenden Webseite enthält drei ASP.NET-Serversteuerelemente in ein `<asp:webpartzone>` Element. Beachten Sie, die die ersten und zweiten-Steuerelemente haben ihre <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> Eigenschaften auf unterschiedliche Werte festgelegt, und die dritte weist nicht die Eigenschaft. Dieser Autorisierungswert kann zur Laufzeit überprüft werden, und das Steuerelement kann auf der Seite hinzugefügt werden, wenn der Filter vom Entwickler festgelegten Kriterien übereinstimmt. Beachten Sie außerdem, dass in der `Page_Load` -Methode, ruft der Code die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Web.UI.WebControls.WebParts.WebPart%29> Methode, um zu bestimmen, ob jedes Steuerelement autorisiert ist, und daher wird jedes Steuerelement <xref:System.Web.UI.WebControls.WebParts.WebPart.ExportMode%2A> Eigenschaft.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_IsAuthorized#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/CS/IsAuthorizedCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_IsAuthorized#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/VB/IsAuthorizedVB.aspx#1)]  
  
 Beachten Sie, dass für das Codebeispiel funktioniert, Sie eine Einstellung in der Datei "Web.config" So aktivieren Sie die Webparts Description-Dateien exportieren hinzufügen müssen. Stellen Sie sicher, dass Sie eine Datei "Web.config" im gleichen Verzeichnis wie die Webseite für dieses Codebeispiel verfügen. Innerhalb der `<system.web>` Abschnitt, stellen Sie sicher, dass eine `<webParts>` Element mit einem `enableExport` -Attributsatz zur `true`, wie im folgenden Markup.  
  
 `<webParts enableExport="true">`  
  
 `...`  
  
 `</webParts>`  
  
 Nachdem Sie die Seite in einem Browser zu laden, beachten Sie, dass das erste Steuerelement angezeigt wird, da er die Kriterien in der überschriebenen Methode übereinstimmt. Das zweite Steuerelement ist nicht auf der Seite hinzugefügt, da er vom Filter ausgeschlossen ist. Das dritte Steuerelement wird ebenfalls hinzugefügt, da sie keinen seine <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> Eigenschaftensatz. Beachten Sie, dass wenn Sie über das Menüsymbol Verben in der Titelleiste des entweder Steuerelements klicken, beide können exportiert werden, da ihre jeweiligen <xref:System.Web.UI.WebControls.WebParts.WebPart.ExportMode%2A> Eigenschaftswerte zugewiesen wurden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" /> ist <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Diese Methode wird direkt aus dem Code aufgerufen. Wenn Sie größere programmgesteuerte Kontrolle über den Autorisierungsprozess erhalten möchten, können Sie überschreiben die <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized(System.Type,System.String,System.String,System.Boolean)" /> Methode überladen.</para>
        </block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="IsAuthorized">
      <MemberSignature Language="C#" Value="public virtual bool IsAuthorized (Type type, string path, string authorizationFilter, bool isShared);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAuthorized(class System.Type type, string path, string authorizationFilter, bool isShared) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized(System.Type,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsAuthorized(Type ^ type, System::String ^ path, System::String ^ authorizationFilter, bool isShared);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="authorizationFilter" Type="System.String" />
        <Parameter Name="isShared" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">Der <see cref="T:System.Type" /> des Steuerelements, das auf die entsprechende Autorisierung überprüft wird.</param>
        <param name="path">Der relative Anwendungspfad zur Quelldatei des Steuerelements, das autorisiert wird, sofern das Steuerelement ein Benutzersteuerelement ist.</param>
        <param name="authorizationFilter">Der <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter" />-Eigenschaft des <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />-Steuerelements wird ein beliebiger Zeichenfolgenwert zugewiesen, der verwendet wird, um zu prüfen, ob für ein Steuerelement eine Autorisierung vorhanden ist und es einer Seite hinzugefügt werden darf.</param>
        <param name="isShared">Gibt an, ob das zur Autorisierung überprüfte Steuerelement freigegeben ist, d. h., ob es für alle Benutzer einer Anwendung sichtbar ist und ob dessen <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.IsShared" />-Eigenschaftswert auf <see langword="true" /> festgelegt ist.</param>
        <summary>Führt die letzten Schritte des Prozesses aus, mit dem bestimmt wird, ob für das Steuerelement eine Autorisierung vorhanden ist und es einer Seite hinzugefügt werden darf.</summary>
        <returns>Ein boolescher Wert, der angibt, ob für ein Steuerelement eine Autorisierung vorhanden ist und es einer Seite hinzugefügt werden darf.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29> überladene Methode führt die abschließenden Schritte bestimmen, ob ein Steuerelement autorisiert ist, eine Seite hinzugefügt werden. Die Methode wird sichergestellt, dass `type` ist ein gültiger Typ, und dass `path` verfügt über einen Wert nur, wenn das zu überprüfende Steuerelement ein benutzerdefiniertes Steuerelement ist. Dann er die kritischen ruft <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A> -Methode, die löst die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> Ereignis.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht das Überschreiben der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> Methode, um zu bestimmen, ob ein Steuerelement autorisiert ist, eine Seite hinzugefügt werden.  
  
 Der erste Schritt besteht darin einen Filter erstellen, der ein Steuerelement ausgeschlossen werden können. Der folgenden Webseite enthält drei ASP.NET-Serversteuerelemente in ein `<asp:webpartzone>` Element. Beachten Sie, die die ersten und zweiten-Steuerelemente haben ihre <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> Eigenschaften auf unterschiedliche Werte festgelegt, und die dritte weist nicht die Eigenschaft. Dieser Autorisierungswert kann zur Laufzeit überprüft werden, und das Steuerelement kann auf der Seite hinzugefügt werden, wenn der Filter vom Entwickler festgelegten Kriterien übereinstimmt.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_IsAuthorized#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/CS/IsAuthorizedCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_IsAuthorized#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/VB/IsAuthorizedVB.aspx#1)]  
  
 Der zweite Schritt besteht darin, überschreiben die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29> -Methode, und erstellen Sie benutzerdefinierte Behandlung für Autorisierungsfilter. Beachten Sie, dass der Code zuerst überprüft, ob die Eigenschaft einen Wert aufweist, damit jedes, das Steuerelement weist keinen der <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> Eigenschaft automatisch hinzugefügt werden. Wenn ein Steuerelement einen Filter verfügt, gibt der Code `true` nur, wenn der Filterwert gleich `admin`. Dies zeigt einen einfachen Mechanismus, für die Anzeige von bestimmten Steuerelementen auf bestimmte Benutzer, abhängig von ihrer Rolle verwendet werden können. Während ein vollständiges Beispiel mithilfe von Rollen nicht Gegenstand dieses Themas ist, können Sie die gleiche Logik als die überschriebene Methode in diesem Codebeispiel verwenden mit dem Unterschied, dass Sie überprüfen können, ob der aktuelle Benutzer Mitglied einer Rolle ist, die den Wert des Autorisierungsfilter entspricht , und fügen Sie dann auf das Steuerelement nur für diesen Benutzer. Auf diese Weise können Sie Seiten, in denen einige Benutzer sehen alle Steuerelemente und andere Benutzer sehen nur die ausgewählten Steuerelemente, erstellen. Wie die Logik, die den Filter überprüft aussehen könnte, wenn Sie Rollen verwendet, sieht folgendermaßen aus:  
  
```vb  
If Roles.IsUserInRole(Page.User.Identity.Name, authorizationFilter) Then  
  return True  
Else  
  return False  
End If  
```  
  
```csharp  
if(Roles.IsUserInRole(Page.User.Identity.Name, authorizationFilter))  
    return true;  
else  
    return false;  
```  
  
 Für das Codebeispiel ausführen müssen Sie diesen Quellcode kompilieren. Sie können es explizit kompilieren und legen Sie die resultierende Assembly im Bin-Ordner der Website oder dem globalen Assemblycache. Alternativ können Sie den Quellcode im Ordner "App_Code" des Standorts, ablegen, wo er zur Laufzeit dynamisch kompiliert wird. Dieses Codebeispiel verwendet die dynamische Kompilierungsmethode. Eine exemplarische Vorgehensweise zum Kompilieren, veranschaulicht, finden Sie unter [Exemplarische Vorgehensweise: Entwickeln und Verwenden eines benutzerdefinierten Webserver-Steuerelements](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08).  
  
 [!code-csharp[WebParts_WebPartManager_IsAuthorized#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/CS/MyManagerAuthorize.cs#2)]
 [!code-vb[WebParts_WebPartManager_IsAuthorized#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/VB/MyManagerAuthorize.vb#2)]  
  
 Nachdem Sie die Seite in einem Browser zu laden, beachten Sie, dass das erste Steuerelement angezeigt wird, da er die Kriterien in der überschriebenen Methode übereinstimmt. Das zweite Steuerelement ist nicht auf der Seite hinzugefügt, da seine Filterwert ausgeschlossen ist. Das dritte Steuerelement hinzugefügt wird, da sie keinen seine <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> Eigenschaftensatz. Wenn Sie den Wert der Eigenschaft, auf das zweite Steuerelement ändern zu entsprechen, der das erste Steuerelement, und klicken Sie dann die Seite erneut ausführen, wird das zweite Steuerelement ebenfalls hinzugefügt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> ist ein Benutzersteuerelement, und <paramref name="path" /> ist entweder <see langword="null" /> oder eine leere Zeichenfolge ("").  
  
 \- oder –  
  
 <paramref name="type" /> ist kein Benutzersteuerelement, und <paramref name="path" /> ist ein Wert zugewiesen.</exception>
        <block subset="none" type="overrides">
          <para>Diese Methode kann überschrieben werden, durch Erben von der <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> Klasse, wenn Sie beim Prüfen der Autorisierung zusätzliche Behandlung bereitstellen möchten. Möglicherweise möchten Sie die Methode, um Werte für bestimmte Einchecken überschreiben die <paramref name="authorizationFilter" /> Parameter, und anhand des Werts, gibt einen booleschen Wert, der bestimmt, ob das Steuerelement auf einer Seite hinzugefügt wird.  
  
 Für Seitenentwickler, die auch für Autorisierungsfilter prüfen und benutzerdefinierte Behandlung bereitstellen möchten, besteht die Möglichkeit zum Ausführen dieser Inline in einer ASPX-Seite oder in einem Code-Behind-Datei ohne von Klassen erben. Sie können einen alternativen Ereignishandler auf der Seite deklarieren die <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" /> Methode der <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> Steuerelement. Weitere Informationen und ein Beispiel finden Sie unter der <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" /> Methode.</para>
        </block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="IsCustomPersonalizationStateDirty">
      <MemberSignature Language="C#" Value="protected virtual bool IsCustomPersonalizationStateDirty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCustomPersonalizationStateDirty" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property IsCustomPersonalizationStateDirty As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool IsCustomPersonalizationStateDirty { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob Personalisierungsänderungen vorgenommen wurden, die Personalisierungsdetails auf der Seitenebene betreffen, die durch das <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />-Steuerelement gesteuert werden.</summary>
        <value>Ein boolescher Wert, der angibt, ob Personalisierungsänderungen vorgenommen wurden. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager> steuern verwendet der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty%2A> -Eigenschaft intern an, ob die Daten auf Seitenebene Personalisierung zu verfolgen, die er verwaltet geändert wurde. Die Personalisierungsdaten ändert, wenn verschiedene Personalisierung Aktionen auf Seitenebene, z. B. hinzufügen oder Entfernen von Benutzern beziehenden <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelemente, die eine Verbindung herstellen oder Trennen von Steuerelementen, Ändern des Layouts einer Seite Steuerelemente und andere Aktionen verschoben.  
  
> [!NOTE]
>  Benutzer können auch Personalisierung auf der Steuerelementebene, d. sie personalisierungsänderungen für ein bestimmtes Steuerelement machen h., ausführen und die Änderungen betreffen nur das entsprechende Steuerelement. Ein Beispiel ist das Steuerelement bearbeiten und Ändern der Titeltext oder die Hintergrundfarbe. Steuerungsebene Personalisierung wirkt sich nicht auf der Seitenebene Personalisierungsdaten nachverfolgt werden die <xref:System.Web.UI.WebControls.WebParts.WebPartManager> -Steuerelement, daher wird der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty%2A> Eigenschaftswert wird nicht geändert, um `true` tritt Steuerungsebene Personalisierung.  
  
 Obwohl die Methode geschützt wird und nicht werden, direkt von einem Aufrufer zugegriffen kann die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A> Eigenschaft zugegriffen werden kann, direkt vom Aufrufer und wird der Wert dieser Eigenschaft zurückgegeben.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.PersonalizationState.IsDirty" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.PersonalizationState.SetDirty" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#IsDirty" />
      </Docs>
    </Member>
    <Member MemberName="LoadControlState">
      <MemberSignature Language="C#" Value="protected internal override void LoadControlState (object savedState);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void LoadControlState(object savedState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.LoadControlState(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub LoadControlState (savedState As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void LoadControlState(System::Object ^ savedState);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="savedState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="savedState">Enthält die gespeicherten Zustandsdaten, die geladen werden sollen.</param>
        <summary>Lädt Daten zum Steuerelementzustand, die bei einer vorherigen Seitenanforderung gespeichert wurden und bei einer nachfolgenden Anforderung wiederhergestellt werden müssen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.LoadControlState%2A> Methode ist hilfreich für die Wiederherstellung von Daten, die über Postbacks einer Seite hinweg beibehalten werden soll, auch wenn die <xref:System.Web.UI.Control.EnableViewState%2A> -Eigenschaftensatz auf `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="savedState" /> ist kein gültiger <see cref="P:System.Web.UI.PageStatePersister.ControlState" />.</exception>
        <altmember cref="M:System.Web.UI.Control.LoadControlState(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="LoadCustomPersonalizationState">
      <MemberSignature Language="C#" Value="protected virtual void LoadCustomPersonalizationState (System.Web.UI.WebControls.WebParts.PersonalizationDictionary state);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void LoadCustomPersonalizationState(class System.Web.UI.WebControls.WebParts.PersonalizationDictionary state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub LoadCustomPersonalizationState (state As PersonalizationDictionary)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void LoadCustomPersonalizationState(System::Web::UI::WebControls::WebParts::PersonalizationDictionary ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />
      </Parameters>
      <Docs>
        <param name="state">Ein <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />, das die zu ladenden Zustandsdaten enthält.</param>
        <summary>Speichert die benutzerdefinierten Personalisierungsdaten, die zur späteren Verwendung im Initialisierungsprozess von den Personalisierungsobjekten an das <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />-Steuerelement übergeben wurden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState%2A> Methode bietet gespeicherten Zustand der Daten in Form einer <xref:System.Web.UI.WebControls.WebParts.PersonalizationDictionary> Objekt. Diese Daten werden schließlich zum Laden von Personalisierungsdaten in Webparts-Steuerelemente und zum Durchführen anderer Initialisierungsaufgaben verwendet.  
  
> [!NOTE]
>  Diese Methode wird aufgerufen, von einer Sequenz von Methoden, die beginnt, wenn die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.TrackViewState%2A> -Methode fordert ursprünglich zugeordneten <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization> Personalisierungsdaten zu verwendendes Objekt die <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Steuerelement.  
  
 Diese Methode kann nicht direkt aus Ihrem Code abgerufen werden. Sie können jedoch direkt aufrufen der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Load%2A> Aufrufe der Methode, die selbst die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState%2A> -Methode und gibt die Personalisierungsdaten.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Entwickler können außer Kraft setzen die <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" /> Methode in einer abgeleiteten <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> Klasse.</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Load(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      </Docs>
    </Member>
    <Member MemberName="MediumPermissionSet">
      <MemberSignature Language="C#" Value="protected virtual System.Security.PermissionSet MediumPermissionSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.PermissionSet MediumPermissionSet" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.MediumPermissionSet" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property MediumPermissionSet As PermissionSet" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Security::PermissionSet ^ MediumPermissionSet { System::Security::PermissionSet ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein <see cref="T:System.Security.PermissionSet" />-Objekt ab, das nur die <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Execution" />-Berechtigung und die <see cref="F:System.Web.AspNetHostingPermissionLevel.Medium" />-Berechtigung gewährt.</summary>
        <value>Ein <see cref="T:System.Security.PermissionSet" />-Objekt, das nur die <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Execution" />-Berechtigung und die <see cref="F:System.Web.AspNetHostingPermissionLevel.Medium" />-Berechtigung gewährt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Security.PermissionSet> von dieser Eigenschaft zurückgegebene Objekt wird während des Imports für die Typdeserialisierung verwendet.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinimalPermissionSet">
      <MemberSignature Language="C#" Value="protected virtual System.Security.PermissionSet MinimalPermissionSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.PermissionSet MinimalPermissionSet" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.MinimalPermissionSet" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property MinimalPermissionSet As PermissionSet" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Security::PermissionSet ^ MinimalPermissionSet { System::Security::PermissionSet ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein <see cref="T:System.Security.PermissionSet" />-Objekt ab, das nur die <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Execution" />-Berechtigung und die <see cref="F:System.Web.AspNetHostingPermissionLevel.Minimal" />-Berechtigung gewährt.</summary>
        <value>Ruft ein <see cref="T:System.Security.PermissionSet" />-Objekt ab, das nur die <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Execution" />-Berechtigung und die <see cref="F:System.Web.AspNetHostingPermissionLevel.Minimal" />-Berechtigung gewährt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Security.PermissionSet> wird von dieser Eigenschaft zurückgegebenen Objekts während des Imports für alle Elemente außer Geben Sie die Deserialisierung verwendet.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveWebPart">
      <MemberSignature Language="C#" Value="public virtual void MoveWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart, System.Web.UI.WebControls.WebParts.WebPartZoneBase zone, int zoneIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void MoveWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart, class System.Web.UI.WebControls.WebParts.WebPartZoneBase zone, int32 zoneIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void MoveWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart, System::Web::UI::WebControls::WebParts::WebPartZoneBase ^ zone, int zoneIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="zone" Type="System.Web.UI.WebControls.WebParts.WebPartZoneBase" />
        <Parameter Name="zoneIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="webPart">Der <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> oder ein anderes Serversteuerelement, das verschoben wird.</param>
        <param name="zone">Die Ziel-<see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />, in die <c>webPart</c> verschoben wird.</param>
        <param name="zoneIndex">Eine ganze Zahl, die den Index von <c>webPart</c> im Verhältnis zu anderen Steuerelementen innerhalb von <c>zone</c> angibt.</param>
        <summary>Verschiebt ein <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />-Steuerelement oder ein Serversteuerelement aus einer <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />-Zone in eine andere Zone oder an eine neue Position innerhalb derselben Zone.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager> steuern verwendet der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A> -Methode verschieben `webPart` an einem neuen Speicherort in derselben Zone oder in eine andere Zone. Rufen Sie diese Methode, direkt aus dem Code, und er wird auch aufgerufen, wenn ein Benutzer ein Steuerelement an eine neue Position in der Webparts-Benutzeroberfläche (UI) mithilfe der verschiedenen Optionen bewegt wird.  
  
 Eine Reihe von Bedingungen muss erfüllt sein, damit `webPart` verschoben werden können, sowie bei den meisten werden von Elementen, die im Abschnitt "Ausnahmen" dieses Themas aufgeführten angegeben werden. Wenn `webPart` wurde nicht innerhalb einer <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> Zone zunächst kann nicht in eine andere Zone verschoben werden.  
  
 Nachdem die Bedingungen erfüllt sind, tritt die folgende Sequenz von Aktionen zum Verschieben `webPart`:  
  
1.  Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving%2A>-Methode löst das <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving>-Ereignis aus.  
  
2.  `webPart` wird von der aktuellen Zone (falls erforderlich), entfernt und der neuen Zone oder eine neue Position innerhalb der aktuellen Zone hinzugefügt.  
  
3.  Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved%2A>-Methode löst das <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved>-Ereignis aus.  
  
4.  Die `zoneIndex` von jedem <xref:System.Web.UI.WebControls.WebParts.WebPart> -Steuerelement im Ursprung und Ziel-Zonen wird zurückgesetzt, um das verschobene Steuerelement wider.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie zum Aufrufen der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A> -Methode direkt aus dem Code zum Verschieben einer <xref:System.Web.UI.WebControls.WebParts.WebPart> -Steuerelement aus einer Zone auf einen anderen.  
  
 Das Codebeispiel besteht aus drei Teilen:  
  
-   Ein Benutzersteuerelement für Anzeigemodi ändern.  
  
-   Eine Webseite, um die Steuerelemente zu hosten.  
  
-   Eine Erläuterung dazu, wie im Codebeispiel wird ausgeführt.  
  
 Der erste Teil des Codebeispiels wird das Benutzersteuerelement zum Ändern des Anzeigemodus. Sie können den Quellcode für das Benutzersteuerelement abrufen, der im Abschnitt "Beispiel" die <xref:System.Web.UI.WebControls.WebParts.WebPartManager> -Klassenübersicht. Weitere Informationen zu Anzeigemodi und zur Funktionsweise des Benutzersteuerelements, finden Sie unter [Exemplarische Vorgehensweise: Ändern des Anzeigemodus auf einer Webparts-Seite](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0).  
  
 Der zweite Teil des Beispiels wird eine Webseite mit zwei Zonen, von denen jede zwei Serversteuerelemente enthält. Wenn ein Benutzer klickt auf die **Move WebPart** Schaltfläche auf der Seite, die den Code in die `Button1_Click` Methode wird ein Steuerelement aus der ersten Zone an eine neue Position in der zweiten Zone verschoben. Beachten Sie, die der Code zunächst aufrufen muss die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart%2A> Methode zum Abrufen der <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> -Objekt, das dient als Wrapper für die `list1` Steuerelement. Dies ist erforderlich, da der erste Parameter der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A> Methode erfordert eine <xref:System.Web.UI.WebControls.WebParts.WebPart> zu steuern, wohingegen `list1` ist ein ASP.NET-Serversteuerelement.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_MoveWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_MoveWebPart/CS/MoveWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_MoveWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_MoveWebPart/VB/MoveWebPartVB.aspx#1)]  
  
 Nachdem die Seite geladen wird, klicken Sie auf die **Move WebPart** Schaltfläche zu sehen, die das Steuerelement, das Links enthält, die in die mittlere Position in der zweiten Zone verschoben wird. Diese Bewegung des Steuerelements erfolgt programmgesteuert durch Aufrufen der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A> Methode. Sie können auch die **Anzeigemodus** Dropdownlisten-Steuerelement auf die Seite in den Entwurfsmodus und im Entwurfsmodus zu wechseln können Sie die Steuerelemente an verschiedene Zonen oder an andere Positionen innerhalb derselben Zone ziehen. Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A> Methode wird auch aufgerufen, indem die <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Steuerelement behandelt solche Benutzerinitiierte verschoben wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="webPart" /> ist in der <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" />-Auflistung des <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />-Steuerelements nicht enthalten.  
  
 \- oder –  
  
 <paramref name="zone" /> ist in der <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Zones" />-Auflistung des <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />-Steuerelements nicht enthalten.  
  
 \- oder –  
  
 Die Zone, auf die die <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.Zone" />-Eigenschaft des <paramref name="webPart" />-Steuerelements verweist, lautet <see langword="null" />. Dies bedeutet, dass <paramref name="webPart" /> derzeit in keiner Zone enthalten ist.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPart" /> oder <paramref name="zone" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="zoneIndex" /> ist kleiner als Null.</exception>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving(System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnAuthorizeWebPart">
      <MemberSignature Language="C#" Value="protected virtual void OnAuthorizeWebPart (System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnAuthorizeWebPart(class System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnAuthorizeWebPart (e As WebPartAuthorizationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnAuthorizeWebPart(System::Web::UI::WebControls::WebParts::WebPartAuthorizationEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs" />, das Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" />-Ereignis aus und ruft, falls vorhanden, einen Handler für das Ereignis auf.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A> Methode wird aufgerufen, indem Sie die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> Methode, wenn ein <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelement für die Autorisierung auf einer Seite hinzugefügt werden überprüft wird. Wenn die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A> -Methode aufgerufen wird, löst es das <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> Ereignis, und wenn eine Handlermethode für das Ereignis vorhanden ist, ruft den Handler.  
  
 Der Prozess der Autorisierung <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelemente ist ein wichtiges Feature von Webparts. Jede <xref:System.Web.UI.WebControls.WebParts.WebPart> oder -Steuerelement, das einer Zone hinzugefügt wird, die <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Steuerelement durchläuft einen Autorisierungsvorgang, um zu bestimmen, ob das Steuerelement hinzugefügt werden kann. Standardmäßig bietet der Webparts-Steuerelementsatz keine Filterkriterien verhindern, dass die Steuerelemente, die zu einer Zone hinzugefügt werden. Aber die Steuerelementsatzes bietet die Mechanismen, die für Entwickler eigene Filterkriterien erstellen. Mit diesen Mechanismen können Sie benutzerdefinierte vorkommender Filterszenarios erstellen. Beispielsweise können Sie einen Filter erstellen, sodass ist ein Benutzer in einer Administratorrolle sein, bestimmte Steuerelemente würde zu einer Zone hinzugefügt werden, wenn die Seite gerendert wird, und wenn der Benutzer in einer Benutzerrolle ist, diese Kontrollen nicht hinzugefügt werden würde.  
  
 Sind die Mechanismen für die Filtersteuerelemente während des Autorisierungsprozesses der <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> Eigenschaft <xref:System.Web.UI.WebControls.WebParts.WebPart> -Steuerelemente, die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> und <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A> Methoden, und die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> Ereignis auf der <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Steuerelement.  
  
 Zum Erstellen eines Filterszenarios sind im Wesentlichen zwei Aufgaben. Zunächst, Zuweisen von Zeichenfolgen, die die <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> -Eigenschaft jedes <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelement, die Sie filtern möchten. Diese Zeichenfolgenwerte können beliebige, jedoch dürfen sie Kriterien, nach denen gefiltert werden soll. Beispielsweise mussten Sie ein bestimmtes Steuerelement nur ein Zone, wenn einen Administrator hinzuzufügenden Benutzer Anzeige der Seite und dann könnten Sie einen Zeichenfolgenwert der zuweisen `admin` der Eigenschaft. Sie könnten dann verwenden die ASP.NET-Funktion für Rollen und alle Benutzer Ihrer Website zu verschiedenen Rollen wie z. B. Administrator, Manager und Benutzer hinzufügen. Beim Laden einer Seite wird der würde überprüfen, welche Rolle ein Benutzer aufweist, vergleichen Sie sie mit dem Wert des Autorisierungsfilter auf ein Steuerelement, das überprüft wird, und (zum Beispiel) wird des Benutzers in einer Administratorrolle sein, und legen Sie mussten des Steuerelements <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> Wert `admin`, kann das Steuerelement hinzugefügt werden.  
  
 Der zweite Schritt beim Erstellen eines Filterszenarios wird zum Schreiben von Code zum Überprüfen der <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> Eigenschaftswerte auf <xref:System.Web.UI.WebControls.WebParts.WebPart> steuert und zu bestimmen, ob jedes Steuerelement autorisiert ist, bevor sie der Zone hinzugefügt wird. Es gibt zwei Optionen für diesen Filter Code platzieren. Die erste Option ist die bevorzugte Option für Entwickler von Seiten. Können, erstellen Sie eine Methode zum Behandeln der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> Ereignis direkt in die Webseite Serverskriptcode oder in einer Trennung-Codedatei. Ordnen Sie die Methode mit dem Ereignis, durch Hinzufügen der `OnAuthorizeWebPart` -Attribut zum Tag für den <xref:System.Web.UI.WebControls.WebParts.WebPartManager> auf der Seite zu steuern, wie im folgenden Markup Beispielcode gezeigt.  
  
```  
<asp:webpartmanager id="manager1" runat="server"   
   OnAuthorizeWebPart="manager1_AuthorizeWebPart" />  
```  
  
 Alle Ihre benutzerdefinierten Methode wird jede Check <xref:System.Web.UI.WebControls.WebParts.WebPart> für die Filterkriterien zu steuern und auf Grundlage der Ergebnisse weisen Sie anschließend einen booleschen Wert, der <xref:System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs.IsAuthorized%2A> Eigenschaft von der <xref:System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs> Objekts, um anzugeben, ob die <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelement möglich hinzugefügt. Der Code im Beispielabschnitt veranschaulicht, wie dies.  
  
 Die zweite Option Filterung Codes zu platzieren, ist das erben die <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Klasse, und überschreiben eine Methode, um die Filterkriterien zu überprüfen. Die beiden Methoden außer Kraft setzen, zu diesem Zweck die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29?displayProperty=nameWithType> Methode oder die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A> Methode. Beide Methoden funktioniert, zwar in den meisten Fällen ist es besser, überschreiben die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> -Methode, weil sie Sie größere programmgesteuerte Kontrolle über die gesamte Autorisierung, wohingegen bereitstellt der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A> Methode ist nur eine bestimmte Aufgabe , die zum Auslösen des Ereignisses und überprüfen Sie nach einem Ausnahmehandler ist. Ein Codebeispiel für eine benutzerdefinierte <xref:System.Web.UI.WebControls.WebParts.WebPartManager> -Klasse, überschreibt die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> -Methode finden Sie unter der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29?displayProperty=nameWithType> Überladung der Methode.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie für einen benutzerdefinierten Ereignishandler Festlegen der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> -Ereignis, damit der Ereignishandler benutzerdefinierten Filtern Code bereitstellen kann die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A> Methode. In diesem Beispiel wäre eine typische Möglichkeit für Entwickler einer Seite Geben Sie eine Filterung Szenario und die Autorisierung des <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelemente auf einer Seite hinzugefügt werden.  
  
 Auf der Webseite, beachten Sie, dass die `<asp:webpartmanager>` Element verfügt über die `OnAuthorizeWebPart` Attribut mit dem Namen des ereignishandlers zugewiesen. Die Methode überprüft, ob die Steuerelemente auf der Seite ihren jeweiligen haben <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> Eigenschaftswerte festlegen, um `admin` und, wenn dies der Fall ist, gibt `true`, was bedeutet, dass sie autorisiert und zur Seite hinzugefügt.  
  
> [!NOTE]
>  Beachten Sie, die steuert, die keinen Wert zugewiesen ist, die <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> Eigenschaft werden ebenfalls hinzugefügt, da sie nicht als Teil eines Filterszenarios angenommen werden. Wäre dies eine gängige Methode in einem Filterszenario: Einige Steuerelemente werden gefiltert und andere nicht, da davon ausgegangen, wird werden für alle Benutzer verfügbar sein.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_AuthorizeWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_AuthorizeWebPart/CS/AuthorizeWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_AuthorizeWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_AuthorizeWebPart/VB/AuthorizeWebPartVB.aspx#1)]  
  
 Da Einrichten von Benutzern zu Rollen nicht Gegenstand dieses Themas ist, wird in diesem Codebeispiel wird von Benutzerrollen in die Filterung nicht überprüft. Allerdings ist das Szenario der Filterung Steuerelemente entsprechend Benutzerrollen wahrscheinlich eines der häufigsten Verwendungszwecke von diesem Filterfunktion. Wenn Sie auf der Website-Rollen haben und Sie Benutzerrollen in diese Methode, um Steuerelemente zu filtern überprüfen möchten, ähnelt die Methode den folgenden Codeblock (im Gegensatz zu den einfacherer Ansatz im vorangehenden Codebeispiel, die Rollen nicht verwendet).  
  
```vb  
Protected Sub WebPartManager1_AuthorizeWebPart(ByVal sender _  
  As Object, ByVal e As WebPartAuthorizationEventArgs)  
  
  If String.IsNullOrEmpty(e.AuthorizationFilter) Then  
    If Roles.IsUserInRole(Page.User.Identity.Name, _  
      e.AuthorizationFilter) Then  
  
      e.IsAuthorized = True  
    Else  
      e.IsAuthorized = False  
    End If  
  End If  
  
End Sub  
```  
  
```csharp  
protected void mgr1_AuthorizeWebPart(object sender,   
  WebPartAuthorizationEventArgs e)  
{  
  if (!String.IsNullOrEmpty(e.AuthorizationFilter))  
  {  
    if(Roles.IsUserInRole(Page.User.Identity.Name, e.authorizationFilter))  
      e.IsAuthorized = true;  
    else  
      e.IsAuthorized = false;  
  }  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" />
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized" />
      </Docs>
    </Member>
    <Member MemberName="OnConnectionsActivated">
      <MemberSignature Language="C#" Value="protected virtual void OnConnectionsActivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnConnectionsActivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnConnectionsActivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnConnectionsActivated(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated" />-Ereignis aus, das anzeigt, dass eine Seite und ihre Steuerelemente geladen sind und dass die Verbindungen auf der Seite aktiviert wurden, um mit dem Austausch von Daten zu beginnen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated%2A> -Methode löst das <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated> Ereignis aus, nachdem eine Seite den Ladevorgang abgeschlossen ist. Die Methode bietet eine Möglichkeit, einen Handler für das Ereignis hinzuzufügen.  
  
 Seite-Entwickler können fügen einen benutzerdefinierten Handler für das Ereignis hinzu, indem ein `OnConnectionsActivated` -Attribut auf die `<asp:webpartmanager>` Element in einer Seite, und weisen Sie dann einen Namen für die benutzerdefinierte Methode für das Attribut.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Entwickler können außer Kraft setzen die <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated(System.EventArgs)" /> Methode in einer abgeleiteten <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> Klasse.</para>
        </block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated" />
      </Docs>
    </Member>
    <Member MemberName="OnConnectionsActivating">
      <MemberSignature Language="C#" Value="protected virtual void OnConnectionsActivating (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnConnectionsActivating(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnConnectionsActivating (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnConnectionsActivating(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating" />-Ereignis aus, das anzeigt, dass eine Seite und ihre Steuerelemente geladen wurden und dass mit dem Aktivieren von Verbindungen begonnen werden kann.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating%2A> -Methode löst das <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating> -Ereignis, das bietet Entwicklern einen Mechanismus für den Prozess des Aktivierens Verbindungen programmgesteuert anpassen.  
  
 Seite-Entwickler können fügen einen benutzerdefinierten Handler für das Ereignis hinzu, indem ein `OnConnectionsActivating` -Attribut auf die `<asp:webpartmanager>` Element in einer Seite, und weisen Sie dann einen Namen für die benutzerdefinierte Methode für das Attribut.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Entwickler können außer Kraft setzen die <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating(System.EventArgs)" /> Methode in einer abgeleiteten <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> Klasse.</para>
        </block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating" />
      </Docs>
    </Member>
    <Member MemberName="OnDisplayModeChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnDisplayModeChanged (System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDisplayModeChanged(class System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged(System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDisplayModeChanged (e As WebPartDisplayModeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDisplayModeChanged(System::Web::UI::WebControls::WebParts::WebPartDisplayModeEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs" />-Objekt, das Ereignisdaten enthält, die einem geänderten Anzeigemodus zugeordnet sind.</param>
        <summary>Löst das <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanged" />-Ereignis aus, um anzuzeigen, dass das <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />-Steuerelement auf einer Webseite den Prozess des Umschaltens von einem Anzeigemodus in einen anderen abgeschlossen hat.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged%2A> Methode in der Basisklasse löst lediglich zu bilden die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanged> Ereignis.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Sie können außer Kraft setzen die <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged(System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs)" /> Methode. Beispielsweise nach einer Änderung der Anzeigemodus, möglicherweise an der Darstellung der Benutzeroberfläche (UI), ändern möchten je nach der Anzeige Modus ist Bestandteil der <see cref="P:System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs.OldDisplayMode" /> Eigenschaft. Oder Sie möchten bestimmte Inhalte ausblenden oder Anzeigen eines bestimmten Steuerelements.  
  
 Wenn Sie die Methode überschreiben, müssen Sie normalerweise die Basismethode als letzten Schritt der überschriebenen Methode aufrufen, damit der benutzerdefinierte Code zuerst ausgeführt, und das Ereignis, last ausgelöst wird, gibt an, dass die Änderung abgeschlossen ist.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnDisplayModeChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnDisplayModeChanging (System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDisplayModeChanging(class System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging(System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDisplayModeChanging (e As WebPartDisplayModeCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDisplayModeChanging(System::Web::UI::WebControls::WebParts::WebPartDisplayModeCancelEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />-Objekt, das Ereignisdaten enthält, die einem sich ändernden Anzeigemodus zugeordnet sind.</param>
        <summary>Löst das <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanging" />-Ereignis aus, um anzuzeigen, dass das <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />-Steuerelement auf einer Webseite gerade von einem Anzeigemodus in einen anderen umgeschaltet wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging%2A> Methode in der Basisklasse löst lediglich zu bilden die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanging> Ereignis.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Sie können außer Kraft setzen die <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging(System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs)" /> Methode. Z. B. ein Anzeigemodus geändert wird, Sie möchten überprüfen, welche die neue Anzeigemodus (mithilfe der <see cref="P:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs.NewDisplayMode" /> Eigenschaft), und ändern Sie ein Element in der Benutzeroberfläche (UI), basierend auf der neuen Anzeigemodus. Wenn Sie einen benutzerdefinierten Anzeigemodus hatten, empfiehlt es sich um bestimmte Steuerelemente sichtbar zu machen, wenn der benutzerdefinierte Modus ist mit der neuen Anzeigemodus werden.  
  
 Wenn Sie diese Methode überschreiben, müssen Sie die Basismethode, damit das Ereignis ausgelöst wird, um anzugeben, dass ein Anzeigemodus begonnen hat, so ändern Sie normalerweise als ersten Schritt die überschriebene Methode aufrufen. Anschließend kann Ihren benutzerdefinierte Code Änderungen in der Benutzeroberfläche (UI) vornehmen, bevor der neue Anzeigemodus tatsächlich angezeigt wird.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnInit">
      <MemberSignature Language="C#" Value="protected internal override void OnInit (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnInit(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnInit(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnInit (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnInit(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Web.UI.Control.Init" />-Ereignis aus, das das erste Ereignis im Lebenszyklus des <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />-Steuerelements ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnInit%2A> Methodenaufrufe die Basismethode löst die <xref:System.Web.UI.Control.Init> -Ereignis für das Steuerelement, und einige vorbereitende Schritte, z. B. sicherstellen, dass nur eine Instanz vorhanden ist, werden ausgeführt der <xref:System.Web.UI.WebControls.WebParts.WebPartManager> auf einer Seite zu steuern, und laden die Personalisierungsdaten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Es ist ein weiteres <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />-Steuerelement auf der Seite vorhanden.</exception>
        <altmember cref="E:System.Web.UI.Control.Init" />
      </Docs>
    </Member>
    <Member MemberName="OnPreRender">
      <MemberSignature Language="C#" Value="protected internal override void OnPreRender (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnPreRender(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnPreRender(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnPreRender (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnPreRender(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Web.UI.Control.PreRender" />-Ereignis aus, das unmittelbar vor der Wiedergabe eines <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />-Steuerelements auf einer Webseite eintritt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnPreRender%2A> Methodenaufrufe die Basismethode löst die <xref:System.Web.UI.Control.PreRender> -Ereignis für das Steuerelement und registriert mehrere Clientskripts, die auf den Seiten benötigt werden, die Webparts enthalten steuert.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.Control.PreRender" />
      </Docs>
    </Member>
    <Member MemberName="OnSelectedWebPartChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnSelectedWebPartChanged (System.Web.UI.WebControls.WebParts.WebPartEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSelectedWebPartChanged(class System.Web.UI.WebControls.WebParts.WebPartEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSelectedWebPartChanged (e As WebPartEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSelectedWebPartChanged(System::Web::UI::WebControls::WebParts::WebPartEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Web.UI.WebControls.WebParts.WebPartEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" />-Ereignis aus, das eintritt, nachdem ein <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />-Steuerelement entweder neu ausgewählt wurde oder seine Auswahl aufgehoben wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A> -Methode löst das <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged> -Ereignis, das Zeitpunkt in der Regel einen Punkt ist, in denen ein Entwickler kann die Darstellung der Benutzeroberfläche (UI) ändern möchten. Beispielsweise, wenn ein neues <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelement ausgewählt ist, wird der Webparts-Steuerelementsatz ändert sich des Renderns des Steuerelements neu ausgewählte. Nach Auswahl des Steuerelements deaktiviert ist, wird das Rendering normal zurückgegeben.  
  
 Nachdem ein Benutzer einen bestimmten auswählt <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelement für die Bearbeitung der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A> -Methode aufgerufen wird. Wenn der Benutzer abgeschlossen ist, das Steuerelement bearbeiten und wird, mit dem Ergebnis geschlossen, dass die Auswahl des Steuerelements gelöscht wird, die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A> -Methode erneut aufgerufen.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Es gibt mehrere Optionen, die im Zusammenhang mit der <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" /> Ereignis, um es Entwicklern ermöglichen, die das Rendern anzupassen, das auftritt, nachdem das ausgewählte Steuerelement geändert wurde. In deklarativen Code innerhalb der <see langword="&lt;asp:webpartmanager&gt;" /> Element legen fest, dass die <see langword="OnSelectedWebPartChanged" /> Attribut, und weisen Sie den Namen einer benutzerdefinierten Methode zu. In der benutzerdefinierten Methode können Sie das Rendering der ausgewählten Steuerelemente ändern, bei des Ereignisses eintreten. Eine andere Möglichkeit ist das erben die <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> Klasse, und überschreiben Sie die Methode. Eine dritte Möglichkeit ist das Rendering auf der Ebene der Zone anpassen; Sie können z. B. erben von der <see cref="T:System.Web.UI.WebControls.WebParts.EditorZoneBase" /> Klasse, und überschreiben die <see cref="M:System.Web.UI.WebControls.WebParts.EditorZoneBase.OnSelectedWebPartChanged(System.Object,System.Web.UI.WebControls.WebParts.WebPartEventArgs)" /> Methode, um das Rendering von Steuerelementen, aktiviert und deaktiviert werden, während der Bearbeitung anzupassen.</para>
        </block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnSelectedWebPartChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnSelectedWebPartChanging (System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSelectedWebPartChanging(class System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSelectedWebPartChanging (e As WebPartCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSelectedWebPartChanging(System::Web::UI::WebControls::WebParts::WebPartCancelEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging" />-Ereignis aus, das während des Prozesses eintritt, bei dem das derzeit ausgewählte <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />-Steuerelement geändert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging%2A> -Methode löst das <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging> Ereignis, das während des Prozesses ändern, die auftritt, <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelement ausgewählt ist.  
  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Steuerelement verwendet diese Methode, und das zugeordnete Ereignis, um eine Möglichkeit bereit, einen Prozess abzubrechen, in dem das ausgewählte Steuerelement geändert wird. Z. B. die Methode aufgerufen wird, innerhalb der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing%2A> -Methode, und auch in der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing%2A> -Methode zum bieten einer Möglichkeit, den Prozess abzubrechen. Wenn ein Benutzer das Verb "Abbrechen", auf ein Steuerelement, die bearbeitet wird klickt gerade, das Steuerelement ist nicht mehr ausgewählt und Bearbeitung Änderungen werden nicht gespeichert, da die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging%2A> Methode ermöglicht die Bearbeitung abgebrochen.  
  
> [!NOTE]
>  Die Methode wird auf ähnliche Weise aufgerufen, während die Methoden, die starten und Beenden der Verbindung von einem <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelement auf ein anderes Steuerelement, um diesen Prozess abbrechen zu aktivieren.  
  
 Seite-Entwickler können einen benutzerdefinierten Handler für erstellen die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging> Ereignis durch Hinzufügen der `OnSelectedWebPartChanging` -Attribut auf die `<asp:webpartmanager>` Element im deklarativen Seitenmarkup und dem Attribut den Namen einer benutzerdefinierten Methode zuweisen.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnUnload">
      <MemberSignature Language="C#" Value="protected internal override void OnUnload (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnUnload(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnUnload(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnUnload (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnUnload(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ereignisdaten, die dem Löschvorgang des Steuerelements zugeordnet sind.</param>
        <summary>Löst das <see cref="E:System.Web.UI.Control.Unload" />-Basisereignis aus und löscht die <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />-Instanz von einer Webseite.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartAdded">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartAdded (System.Web.UI.WebControls.WebParts.WebPartEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartAdded(class System.Web.UI.WebControls.WebParts.WebPartEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartAdded (e As WebPartEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartAdded(System::Web::UI::WebControls::WebParts::WebPartEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Web.UI.WebControls.WebParts.WebPartEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded" />-Ereignis aus, das eintritt, nachdem einer Seite ein <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />-Steuerelement hinzugefügt wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded%2A> Methode wird aufgerufen, während der Vorgang des Hinzufügens von einer <xref:System.Web.UI.WebControls.WebParts.WebPart> -Steuerelement (oder einem anderen Serversteuerelement, das hinzugefügt wird, eine <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> Zone) zu einer Seite.  
  
 Seite-Entwickler können einen benutzerdefinierten Handler für erstellen die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded> Ereignis durch Hinzufügen der `OnWebPartAdded` -Attribut auf die <`asp:webpartmanager>` Element und das Attribut einen benutzerdefinierten Methodennamen zuweisen.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded" />
      </Docs>
    </Member>
    <Member MemberName="OnWebPartAdding">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartAdding (System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartAdding(class System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding(System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartAdding (e As WebPartAddingEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartAdding(System::Web::UI::WebControls::WebParts::WebPartAddingEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding" />-Ereignis aus, das eintritt, während einer <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />-Zone ein <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />-Steuerelement (oder ein Server- bzw. Benutzersteuerelement) hinzugefügt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding%2A> -Methode löst das <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding> Ereignis, um anzugeben, dass ein Steuerelement gerade hinzugefügt wird. Die Methode bietet auch die Möglichkeit, den Prozess des hinzufügen abzubrechen. Wenn das Steuerelement erfolgreich hinzugefügt wurde, die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded> Ereignis folgt.  
  
 Entwickler von Seiten können einen benutzerdefinierten Handler für das zugeordnete Ereignis bereitstellen, durch Hinzufügen der `OnWebPartAdding` -Attribut auf die `<asp:webpartmanager>` Element auf einer Webseite, und weisen Sie dann einen Namen für die benutzerdefinierte Methode für das Attribut.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Entwickler von abgeleiteten <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> Klassen können überschreiben, die <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding(System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs)" /> Methode zum Anpassen der Ereignisbehandlung.</para>
        </block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnWebPartClosed">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartClosed (System.Web.UI.WebControls.WebParts.WebPartEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartClosed(class System.Web.UI.WebControls.WebParts.WebPartEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartClosed (e As WebPartEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartClosed(System::Web::UI::WebControls::WebParts::WebPartEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Web.UI.WebControls.WebParts.WebPartEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed" />-Ereignis aus, um anzuzeigen, dass ein Steuerelement von einer Seite entfernt worden ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed%2A> -Methode löst das <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed> Ereignis gibt an, dass eine <xref:System.Web.UI.WebControls.WebParts.WebPart> -Steuerelement (oder einem anderen Server oder das Benutzersteuerelement) wurde erfolgreich auf einer Seite geschlossen.  
  
 Schließen einer <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelement bedeutet, dass es auf einer Seite zu entfernen, damit diese nicht gerendert und in einer speziellen platzieren halten Objekt so einen Seitenkatalog genannte. Eine Seitenkatalog, entspricht die <xref:System.Web.UI.WebControls.WebParts.PageCatalogPart> steuern, verwaltet Verweise auf geschlossene <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelemente für jede Seite. Wenn eine <xref:System.Web.UI.WebControls.WebParts.PageCatalogPart> -Steuerelement deklariert wird, auf einer Seite innerhalb einer <xref:System.Web.UI.WebControls.WebParts.CatalogZone> Zone, Benutzern in den Kataloganzeigemodus schalten und wieder an die Seite alle Steuerelemente, die zuvor geschlossen wurden hinzufügen können.  
  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed%2A> Methode bietet die Möglichkeit zum Erstellen eines benutzerdefinierten Handlers für das <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed> Ereignis. Seite-Entwickler können fügen einen benutzerdefinierten Handler für das Ereignis hinzu, indem ein `OnWebPartClosed` -Attribut auf die `<asp:webpartmanager>` Element in einer Seite, und weisen Sie dann einen Namen für die benutzerdefinierte Methode für das Attribut. Eine nützliche Aufgabe, die ein Entwickler bei dieser Methode ausführen kann, ist einen Platzhalter anstelle der geschlossenen Steuerelement anzuzeigen, die zusammen mit einer QuickInfo, die Benutzer zu informieren, würde das Steuerelement zurück zur Seite hinzufügen.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="OnWebPartClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartClosing (System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartClosing(class System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartClosing (e As WebPartCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartClosing(System::Web::UI::WebControls::WebParts::WebPartCancelEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing" />-Ereignis aus, das eintritt, während ein <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />-Steuerelement oder ein Serversteuerelement von einer Seite entfernt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing%2A> -Methode löst das <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing> Ereignis, um anzugeben, dass ein Steuerelement gerade geschlossen oder von einer Seite entfernt wird. Die Methode bietet auch die Option zum Abbrechen der Schließvorgang. Wenn das Steuerelement auf der Seite erfolgreich entfernt wird die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed> Ereignis folgt.  
  
 Entwickler von Seiten können einen benutzerdefinierten Handler für das zugeordnete Ereignis bereitstellen, durch Hinzufügen der `OnWebPartClosinging` -Attribut auf die `<asp:webpartmanager>` Element auf einer Webseite, und weisen Sie dann einen Namen für die benutzerdefinierte Methode für das Attribut.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Entwickler von abgeleiteten <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> Klassen können überschreiben, die <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" /> Methode zum Anpassen der Ereignisbehandlung.</para>
        </block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="OnWebPartDeleted">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartDeleted (System.Web.UI.WebControls.WebParts.WebPartEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartDeleted(class System.Web.UI.WebControls.WebParts.WebPartEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleted(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartDeleted (e As WebPartEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartDeleted(System::Web::UI::WebControls::WebParts::WebPartEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Web.UI.WebControls.WebParts.WebPartEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted" />-Ereignis aus, das eintritt, nachdem ein <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />-Steuerelement unwiderruflich von einer Seite gelöscht wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleted%2A> Methode wird aufgerufen, während der Prozess des Löschens einer <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelement (oder einem anderen Serversteuerelement, das hinzugefügt wird, eine <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> Zone) von einer Seite.  
  
 Seite-Entwickler können einen benutzerdefinierten Handler für erstellen die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted> Ereignis durch Hinzufügen der `OnWebPartDeleted` -Attribut auf die <`asp:webpartmanager>` Element und das Attribut einen benutzerdefinierten Methodennamen zuweisen.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted" />
      </Docs>
    </Member>
    <Member MemberName="OnWebPartDeleting">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartDeleting (System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartDeleting(class System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartDeleting (e As WebPartCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartDeleting(System::Web::UI::WebControls::WebParts::WebPartCancelEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting" />-Ereignis aus, das anzeigt, dass gerade ein dynamisches <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />-Steuerelement (oder ein Server- bzw. Benutzersteuerelement in einer <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />-Zone) gelöscht wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nur dynamische <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelemente können gelöscht werden, und wenn ein Steuerelement gelöscht wird, wird die Instanz des Steuerelements wird von einer Seite dauerhaft entfernt und kann nicht wiederhergestellt werden. Dynamische <xref:System.Web.UI.WebControls.WebParts.WebPart> -Steuerelemente werden programmgesteuert hinzugefügt werden, oder aus einem Katalog Webparts im Gegensatz zu statische Steuerelemente, werden im Markup einer Webseite.  
  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting%2A> -Methode löst das <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting> Ereignis, um anzugeben, dass ein Steuerelement aus der Zone dauerhaft gelöscht wird. Außerdem bietet die Methode die Gelegenheit, um den Löschvorgang abzubrechen. Wenn das Steuerelement auf der Seite erfolgreich gelöscht wurde der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted> Ereignis folgt.  
  
 Entwickler von Seiten können einen benutzerdefinierten Handler für das zugeordnete Ereignis bereitstellen, durch Hinzufügen der `OnWebPartDeleting` -Attribut auf die `<asp:webpartmanager>` Element auf einer Webseite, und weisen Sie dann einen Namen für die benutzerdefinierte Methode für das Attribut.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Entwickler von abgeleiteten <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> Klassen können überschreiben, die <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" /> Methode zum Anpassen der Ereignisbehandlung.</para>
        </block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="OnWebPartMoved">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartMoved (System.Web.UI.WebControls.WebParts.WebPartEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartMoved(class System.Web.UI.WebControls.WebParts.WebPartEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartMoved (e As WebPartEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartMoved(System::Web::UI::WebControls::WebParts::WebPartEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Web.UI.WebControls.WebParts.WebPartEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved" />-Ereignis aus, das eintritt, nachdem ein <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />-Steuerelement an eine andere Position auf einer Seite verschoben wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved%2A> -Methode löst die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved> Ereignis am Ende der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A> -Methode, die wird sichergestellt, dass es sich bei der Migration eines Steuerelements abgeschlossen ist, bevor code im Ereignis Handler ausgeführt wird.  
  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved> Ereignis wird ausgelöst, wenn ein Steuerelement ist innerhalb der aktuellen Zone oder in eine andere Zone verschoben, und es unerheblich ist, ob die Verschiebung erfolgt programmgesteuert oder durch einen Benutzer, die Sie das Steuerelement ziehen.  
  
 Seite-Entwickler können einen benutzerdefinierten Handler für erstellen die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved> Ereignis durch Hinzufügen der `OnWebPartMoved` -Attribut auf die <`asp:webpartmanager>` Element und das Attribut einen benutzerdefinierten Methodennamen zuweisen.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved" />
      </Docs>
    </Member>
    <Member MemberName="OnWebPartMoving">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartMoving (System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartMoving(class System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving(System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartMoving (e As WebPartMovingEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartMoving(System::Web::UI::WebControls::WebParts::WebPartMovingEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving" />-Ereignis aus, das anzeigt, dass gerade ein dynamisches <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />-Steuerelement oder ein Server- bzw. Benutzersteuerelement in einer <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />-Zone verschoben wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving%2A> -Methode löst die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving> Ereignis, das auftritt, wenn eine <xref:System.Web.UI.WebControls.WebParts.WebPart> oder andere Webserversteuerelement innerhalb einer Zone oder in eine andere Zone verschoben wird. Die Methode bietet auch die Möglichkeit, den Prozess des verschieben abzubrechen. Wenn die Verschiebung erfolgreich abgeschlossen wird, die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved> Ereignis folgt.  
  
 Entwickler von Seiten können einen benutzerdefinierten Handler für das zugeordnete Ereignis bereitstellen, durch Hinzufügen der `OnWebPartMoving` -Attribut auf die `<asp:webpartmanager>` Element auf einer Webseite, und weisen Sie dann einen Namen für die benutzerdefinierte Methode für das Attribut.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Entwickler von abgeleiteten <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> Klassen können überschreiben, die <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving(System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs)" /> Methode zum Anpassen der Ereignisbehandlung.</para>
        </block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnWebPartsConnected">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartsConnected (System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartsConnected(class System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnected(System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartsConnected (e As WebPartConnectionsEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartsConnected(System::Web::UI::WebControls::WebParts::WebPartConnectionsEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" />-Ereignis aus, das auftritt, nachdem eine Verbindung zwischen <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />-Steuerelementen erstellt wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnected%2A> -Methode löst das entsprechende Ereignis am Ende der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A> Methode, die sicherstellt, dass die erforderlichen Schritte zum Verbinden von zwei Steuerelementen abgeschlossen sind, bevor Code im Ereignishandler ausgeführt wird.  
  
 Die Methode ermöglicht die programmgesteuerte Kontrolle über den Prozess der Erstellung von Verbindungen, und das zugeordnete Ereignis ist eine praktische Punkt, an dem die Benutzeroberfläche (UI) aktualisieren oder einem Benutzer benachrichtigen, dass eine Verbindung hergestellt wurde.  
  
 Seite-Entwickler können einen benutzerdefinierten Handler für erstellen die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected> Ereignis durch Hinzufügen der `OnWebPartsConnected` -Attribut auf die <`asp:webpartmanager>` Element und das Attribut einen benutzerdefinierten Methodennamen zuweisen.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" />
      </Docs>
    </Member>
    <Member MemberName="OnWebPartsConnecting">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartsConnecting (System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartsConnecting(class System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartsConnecting (e As WebPartConnectionsCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartsConnecting(System::Web::UI::WebControls::WebParts::WebPartConnectionsCancelEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting" />-Ereignis aus, das eintritt, während eine Verbindung zwischen zwei <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />-Steuerelementen oder Server- bzw. Benutzersteuerelementen in einer <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />-Zone erstellt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting%2A> -Methode löst das <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting> Ereignis, das auftritt, wenn zwei Steuerelemente zum Herstellen einer Verbindung versuchen. Die Methode bietet die Möglichkeit, den Verbindungsversuch abzubrechen. Wenn die Verbindung erfolgreich ist, wird die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected> Ereignis folgt.  
  
 Entwickler von Seiten können einen benutzerdefinierten Handler für das zugeordnete Ereignis bereitstellen, durch Hinzufügen der `OnWebPartsConnecting` -Attribut auf die `<asp:webpartmanager>` Element auf einer Webseite, und weisen Sie dann einen Namen für die benutzerdefinierte Methode für das Attribut.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Entwickler von abgeleiteten <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> Klassen können überschreiben, die <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" /> Methode zum Anpassen der Ereignisbehandlung.</para>
        </block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" />
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts" />
      </Docs>
    </Member>
    <Member MemberName="OnWebPartsDisconnected">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartsDisconnected (System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartsDisconnected(class System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnected(System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartsDisconnected (e As WebPartConnectionsEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartsDisconnected(System::Web::UI::WebControls::WebParts::WebPartConnectionsEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected" />-Ereignis aus, das auftritt, nachdem eine Verbindung zwischen <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />-Steuerelementen getrennt wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnected%2A> -Methode löst das entsprechende Ereignis am Ende der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> -Methode, die den Prozess des Trennens einer Verbindung zwischen zwei Steuerelementen ausführt.  
  
 Die Methode stellt programmgesteuerte Kontrolle über den Prozess beim Beenden einer Verbindung, sodass Entwickler den Benutzer darüber informieren könnte, nehmen Sie Änderungen an der Benutzeroberfläche (UI) oder andere Änderungen vornehmen, um die Anwendung.  
  
 Seite-Entwickler können einen benutzerdefinierten Handler für erstellen die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected> Ereignis durch Hinzufügen der `OnWebPartsDisconnected` -Attribut auf die <`asp:webpartmanager>` Element und das Attribut einen benutzerdefinierten Methodennamen zuweisen.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected" />
      </Docs>
    </Member>
    <Member MemberName="OnWebPartsDisconnecting">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartsDisconnecting (System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartsDisconnecting(class System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartsDisconnecting (e As WebPartConnectionsCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartsDisconnecting(System::Web::UI::WebControls::WebParts::WebPartConnectionsCancelEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting" />-Ereignis aus, das anzeigt, dass gerade eine Verbindung zwischen zwei <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />-Steuerelementen oder Server- bzw. Benutzersteuerelementen in einer <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />-Zone beendet wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting%2A> -Methode löst das <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> Ereignis, das auftritt, wenn zwei Steuerelemente eine Verbindung beenden. Die Methode bietet die Möglichkeit, den Trennungsprozess "Abbrechen". Wenn die Verbindung erfolgreich entfernt wird, die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected> Ereignis folgt.  
  
 Entwickler von Seiten können einen benutzerdefinierten Handler für das zugeordnete Ereignis bereitstellen, durch Hinzufügen der `OnWebPartsDisconnecting` -Attribut auf die `<asp:webpartmanager>` Element auf einer Webseite, und weisen Sie dann einen Namen für die benutzerdefinierte Methode für das Attribut.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Entwickler von abgeleiteten <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> Klassen können überschreiben, die <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" /> Methode zum Anpassen der Ereignisbehandlung.</para>
        </block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts(System.Web.UI.WebControls.WebParts.WebPartConnection)" />
      </Docs>
    </Member>
    <Member MemberName="Personalization">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartPersonalization Personalization { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartPersonalization Personalization" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Personalization As WebPartPersonalization" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartPersonalization ^ Personalization { System::Web::UI::WebControls::WebParts::WebPartPersonalization ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartPersonalization</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Verweis auf ein Objekt ab, das Personalisierungsdaten für eine Webseite enthält.</summary>
        <value>Eine <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" />, die Personalisierungsdaten enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> Eigenschaft bietet eine Möglichkeit, den Zugriff auf die <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization> -Objekt, das einer Seite über zugeordnet ist die <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Steuerelement. Diese Eigenschaft verwenden, können Sie die verschiedenen Elemente des Objekts Personalisierung zugreifen. Beispielsweise können Sie die <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ToggleScope%2A> Methode, um die Seite Personalisierungsbereich aus wechseln freigegebene Benutzerbereich (oder umgekehrt). Sie können die aktuellen Personalisierungsbereich der Seite auch ermitteln, ob die Personalisierung auch dann auf der Seite aktiviert ist, welcher Anbieter für die Personalisierungsdaten und vieles mehr verwendet wird.  
  
 Beachten Sie, die die Daten verweist die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> Eigenschaft ist nur für die auf Seitenebene-Personalisierungsdaten, die von verfolgt werden die <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Steuerelement. Steuerelementspezifische Personalisierungsdaten, z. B. die Werte der personalisierbar Eigenschaften auf <xref:System.Web.UI.WebControls.WebParts.WebPart> steuert, ist nicht Teil der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> Eigenschaft.  
  
> [!NOTE]
>  Weitere Informationen zum Personalisieren von Webparts finden Sie unter [Web Parts Personalization Overview](http://msdn.microsoft.com/library/7dc34f74-52aa-4082-b98d-2bcf9e07e320).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> Eigenschaft programmgesteuert.  
  
 Der folgenden Webseite können Benutzer in den Bearbeitungsmodus wechseln, um bestimmte Aspekte des Bearbeiten der <xref:System.Web.UI.WebControls.Calendar> Steuerelement. Die **ein-/ausschalten Bereich** Schaltfläche wechselt die Seite auf Benutzer oder freigegebenen Personalisierungsbereich. Die **Bearbeitungsmodus** und **Durchsuchenmodus** Schaltflächen schalten Sie die Seite in den entsprechenden Anzeigemodus. Beachten Sie, dass in der `<script>` tag Abschnitt der Datei, zwei Methoden, die Behandlung von Ereignissen verwenden die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> Eigenschaft, um nützliche Member des zugrunde liegenden Objekts zuzugreifen. Verwenden Sie diese Methoden insbesondere die <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ToggleScope%2A> Methode und die <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.Scope%2A> Eigenschaft des Objekts, der Zugriff erfolgt über die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> Eigenschaft.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_Personalization#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_Personalization/CS/wpmgrPersonalizationCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_Personalization#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_Personalization/VB/wpmgrPersonalizationVB.aspx#1)]  
  
 Für das Codebeispiel ausführen müssen Sie auch einen oder mehrere Benutzer personalisieren von Seiten im freigegebenen Bereich aktivieren. Fügen Sie einen Eintrag in der Datei "Web.config" in der `<system.web>` Abschnitt sieht das folgende Markup.  
  
```  
<webParts>  
  <personalization>  
    <authorization>  
      <allow  
        users="[Replace the text and brackets with a user name or   
           group.]"  
        roles="admin"   
        verbs="enterSharedScope"  />  
    </authorization>  
  </personalization>  
</webParts>   
```  
  
 Nachdem Sie die Seite in einem Browser zu laden, klicken Sie auf die **ein-/ausschalten Bereich** Schaltfläche, und beachten Sie, die die Seite jetzt besagt, dass der Bereich freigegeben ist. Klicken Sie auf **Bearbeitungsmodus** um den Anzeigemodus zu ändern, klicken Sie auf die Verbmenü des sichtbaren Steuerelements, und wählen Sie **bearbeiten** aus dem Menü. Beachten Sie, dass die Benutzeroberfläche (UI) für beide Bearbeitungssteuerelemente wird angezeigt. Klicken Sie nun auf **Durchsuchenmodus** zurückkehren zu normalen Durchsuchen. Wenn die Seite angezeigt wird, befindet sich im freigegebenen Bereich, klicken Sie auf **ein-/ausschalten Bereich** erneut aus, um sicherzustellen, dass die Seite ist im Gültigkeitsbereich des Benutzers. Als Nächstes führen Sie die gleichen Schritte aus, um erneut, das Steuerelement zu bearbeiten, aber beachten, dass jetzt in der Benutzeroberfläche zum Bearbeiten der <xref:System.Web.UI.WebControls.WebParts.BehaviorEditorPart> Steuerelement nicht angezeigt. Ist, dass dieses Steuerelement funktioniert nur, wenn die Seite im freigegebenen Personalisierungsbereich befindet.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScript">
      <MemberSignature Language="C#" Value="protected virtual void RegisterClientScript ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void RegisterClientScript() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.RegisterClientScript" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub RegisterClientScript ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void RegisterClientScript();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ermöglicht dem <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />-Steuerelement die Ausgabe von clientseitigen Skripts, die für verschiedene Personalisierungsfeatures verwendet werden, z. B. zum Ziehen von <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />-Steuerelementen auf einer Webseite.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Web.UI.Page.RegisterClientScriptBlock(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Render">
      <MemberSignature Language="C#" Value="protected internal override void Render (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void Render(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.Render(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub Render (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void Render(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Ein <see cref="T:System.Web.UI.HtmlTextWriter" />, der den an die Seite zu schreibenden Inhalt des Steuerelements empfängt.</param>
        <summary>Überschrieben, um zu verhindern, dass das <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />-Steuerelement Inhalt wiedergibt.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveControlState">
      <MemberSignature Language="C#" Value="protected internal override object SaveControlState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance object SaveControlState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.SaveControlState" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Function SaveControlState () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override System::Object ^ SaveControlState();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Speichert Zustandsdaten für das <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />-Steuerelement, sodass die Daten bei einer späteren Anforderung an die Webseite, die das Steuerelement enthält, wiederhergestellt werden können.</summary>
        <returns>Ein <see cref="T:System.Object" />, das die gespeicherten Zustandsdaten des Steuerelements enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SaveControlState%2A> Methode speichert Zustandsdaten für Eigenschaften, die über die Seitenpostbacks beibehalten werden soll, auch wenn die <xref:System.Web.UI.Control.EnableViewState%2A> -Eigenschaftensatz auf `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveCustomPersonalizationState">
      <MemberSignature Language="C#" Value="protected virtual void SaveCustomPersonalizationState (System.Web.UI.WebControls.WebParts.PersonalizationDictionary state);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void SaveCustomPersonalizationState(class System.Web.UI.WebControls.WebParts.PersonalizationDictionary state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub SaveCustomPersonalizationState (state As PersonalizationDictionary)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void SaveCustomPersonalizationState(System::Web::UI::WebControls::WebParts::PersonalizationDictionary ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />
      </Parameters>
      <Docs>
        <param name="state">Ein <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />, das die zu ladenden Zustandsdaten enthält.</param>
        <summary>Speichert benutzerdefinierte Personalisierungszustandsdaten, die vom <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />-Steuerelement verwaltet werden, sodass diese Daten bei jedem erneuten Laden der Seite neu geladen werden können.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState%2A> Methode ist gerade Personalisierung, wichtig, weil sie personalisierte benutzereinstellungen für zukünftige Browsersitzungen gespeichert werden kann und Zugriffe auf eine Seite. Die Methode speichert benutzerdefinierte Personalisierungszustandsdaten, z. B. die folgenden Elemente enthält: dynamische <xref:System.Web.UI.WebControls.WebParts.WebPart> oder Serversteuerelemente, die eine Seite hinzugefügt oder aus einer Seite, Steuerelemente, die auf einer Seite; verschoben wurden und dynamische Verbindungen, darauf gelöscht wurden erstellt oder gelöscht wurde.  
  
 Diese Methode kann nicht direkt aus Ihrem Code abgerufen werden. Sie können jedoch Aufrufen der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Save%2A> -Methode, die selbst ruft diese Methode, um Personalisierungsdaten zu speichern.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Entwickler können diese Methode in einer abgeleiteten überschreiben <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> Klasse, um den Prozess des Speicherns von Personalisierungsdaten anzupassen.</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Save(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      </Docs>
    </Member>
    <Member MemberName="SelectedWebPart">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPart SelectedWebPart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPart SelectedWebPart" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SelectedWebPart As WebPart" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPart ^ SelectedWebPart { System::Web::UI::WebControls::WebParts::WebPart ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPart</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Verweis auf ein <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />-Steuerelement oder sonstiges Serversteuerelement ab, das derzeit zur Bearbeitung oder zum Erstellen einer Verbindung mit einem anderen Steuerelement ausgewählt ist.</summary>
        <value>Ein <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />-Steuerelement, das derzeit zur Bearbeitung oder zum Erstellen einer Verbindung ausgewählt ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A> Eigenschaft gibt einen Verweis auf eine <xref:System.Web.UI.WebControls.WebParts.WebPart> oder einem anderen Serversteuerelement, die derzeit für die Bearbeitung oder zum Erstellen einer Verbindung mit einem anderen Steuerelement ausgewählt ist.  
  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Steuerelement bietet mehrere nützliche Methoden und Ereignisse für die Behandlung des Prozess der Auswahl eines Steuerelements. Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging> Ereignis tritt auf, unmittelbar nach einem Steuerelement ausgewählt ist, aber bevor Änderungen vorgenommen werden. Um einige Aktionen für das Steuerelement durchzuführen, nachdem diese Option ausgewählt ist, überschreiben die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging%2A> Methode. Sie möchten beispielsweise ändern Sie die Darstellung eines Steuerelements, die ausgewählt ist, aber noch nicht geändert, visuell hervorgehoben, welches Steuerelement ausgewählt ist.  
  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged> Ereignis tritt auf, unmittelbar nach dem Abschluss des ausgewählten Steuerelements geändert wurde. Um einige Aktionen für das Steuerelement durchzuführen, nachdem es geändert wurde, überschreiben die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A> Methode.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.SetSelectedWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging" />
      </Docs>
    </Member>
    <Member MemberName="SelectedWebPartChanged">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartEventHandler SelectedWebPartChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartEventHandler SelectedWebPartChanged" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SelectedWebPartChanged As WebPartEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartEventHandler ^ SelectedWebPartChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, nachdem auf einer Webseite die Auswahl eines <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />-Steuerelements aufgehoben und auf ein anderes Steuerelement übertragen wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis dient in Verbindung mit der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A> Methode, um die Benutzeroberfläche (UI) des ausgewählten Steuerelements ändern. Wenn der Benutzer die Seite in den Entwurfsmodus wechselt, z. B. (<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode>), und wählt dann eine <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelement mit der Absicht an, an eine neue Position ziehen, es ist üblich, das Rendering des ausgewählten Steuerelements z. B. durch Ändern der Farbe ändern seine Rahmen oder Hintergrund, während diese Option ausgewählt ist.  
  
> [!NOTE]
>  Weitere Informationen zum Verwenden von Ereignissen finden Sie unter [wie: Behandeln von Ereignissen in einer Web Forms-Anwendung](~/docs/standard/events/how-to-consume-events-in-a-web-forms-application.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="SelectedWebPartChanging">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler SelectedWebPartChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler SelectedWebPartChanging" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SelectedWebPartChanging As WebPartCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartCancelEventHandler ^ SelectedWebPartChanging;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt während des Prozesses ein, mit dem das auf der Webseite derzeit ausgewählte <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />-Steuerelement oder Serversteuerelement geändert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis dient in Verbindung mit der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging%2A> Methode. Seite-Entwickler können in ihren Code einen Ereignishandler erstellen, durch Hinzufügen der `OnSelectedWebPartChanging` -Attribut auf die `<asp:webpartmanager>` Element in einer Seite und dem Wert des Attributs auf den Namen einer benutzerdefinierten Methode festlegen, die das Ereignis behandelt.  
  
 Dieses Ereignis wird während des Prozesses begonnen oder beendet eine Verbindung zwischen Steuerelementen und wenn öffnend und schließend eine Bearbeitung eines Steuerelements. Weitere Informationen finden Sie unter der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging%2A> Methode.  
  
 Normalerweise, wenn die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging> Ereignis wird ausgelöst, als direktes Ergebnis einer Benutzeraktion, die das ausgewählte Steuerelement zu ändern, kann das Ereignis abgebrochen werden. Es ist jedoch ein Szenario, in dem das Ereignis abgebrochen werden kann. Wenn eine <xref:System.Web.UI.WebControls.WebParts.WebPartZone> -Steuerelement gelöscht wird, die <xref:System.Web.UI.WebControls.WebParts.WebPart> müssen alle darin enthaltenen Steuerelemente geschlossen werden, da Sie sonst verwaist werden. In diesem Fall die <xref:System.Web.UI.WebControls.WebParts.WebPartManager> steuern geschlossen wird, wird die <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelemente, nicht der Benutzer, und sie müssen bestimmen, welches Steuerelement gerade ausgewählt ist und Zeitpunkt zum Ändern der Auswahl ohne jede Möglichkeit einer Unterbrechung, damit den Prozess der Bereinigung abgeschlossen werden kann alle Steuerelemente. Aus diesem Grund entwurfsbedingt die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging> Methode kann nicht in diesem Szenario nicht abgebrochen werden. Ein verwandtes Ereignis, das abgebrochen werden kann, finden Sie unter der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing> Ereignis.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="SetPersonalizationDirty">
      <MemberSignature Language="C#" Value="protected void SetPersonalizationDirty ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetPersonalizationDirty() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.SetPersonalizationDirty" />
      <MemberSignature Language="VB.NET" Value="Protected Sub SetPersonalizationDirty ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetPersonalizationDirty();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Legt ein Flag fest, das angibt, dass benutzerdefinierte Personalisierungsdaten für das <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />-Steuerelement geändert wurden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SetPersonalizationDirty%2A> Methode setzt ein Flag, das letztendlich die Personalisierungskomponenten im Webparts-Steuerelementsatz zum Speichern der aktualisierte Personalisierungsdaten verursacht. Weitere Informationen zu den Szenarien, die Änderungen an den Personalisierungsdaten nachverfolgt werden, indem Sie dazu die <xref:System.Web.UI.WebControls.WebParts.WebPartManager> steuern, finden Sie unter der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A> Eigenschaft.  
  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SetPersonalizationDirty%2A> Methode kann nicht direkt aus Ihrem Code aufgerufen werden, und kann nicht überschrieben werden, da er intern durch die Webparts-Steuerelementsatz als Teil des Webparts Personalisierungsfeatures verwendet wird.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Die Methode kann aufgerufen werden durch eine abgeleitete <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> Klasse. Dies wäre es hilfreich, wenn Sie die Personalisierung anpassen, Komponenten des Webparts-Steuerelements festgelegt und müssen daher den Prozess Festlegen von Flags für Personalisierungsdaten steuern, möchten.</para>
        </block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#IsDirty" />
      </Docs>
    </Member>
    <Member MemberName="SetSelectedWebPart">
      <MemberSignature Language="C#" Value="protected void SetSelectedWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetSelectedWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.SetSelectedWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetSelectedWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">Ein <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />-Steuerelement oder Serversteuerelement, das ausgewählt wurde.</param>
        <summary>Legt den Wert der <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" />-Eigenschaft auf das derzeit ausgewählte <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />-Steuerelement oder Serversteuerelement fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SetSelectedWebPart%2A> Methode wird aufgerufen, während die Prozesse, die beginnen oder enden Bearbeitung der Steuerung gemäß der `webPart` Parameter sowie diejenigen, die beginnen oder enden eine Verbindung mit `webPart`.  
  
 Am Anfang der Prozesse bearbeiten und Verbindung `webPart` ist das Steuerelement, das bearbeitet werden, oder geben Sie eine Verbindung ausgewählt wurde.  
  
 Am Ende der Prozesse bearbeiten und Verbindung `null` wird zum Übergeben der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SetSelectedWebPart%2A> -Methode, die Ergebnisse in das momentan ausgewählte Steuerelement nicht mehr ausgewählt werden.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" />
      </Docs>
    </Member>
    <Member MemberName="SkinID">
      <MemberSignature Language="C#" Value="public override string SkinID { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SkinID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.SkinID" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property SkinID As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ SkinID { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine leere Zeichenfolge ("") ab oder liegt diese fest, sodass keine Skin auf das <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />-Steuerelement angewendet werden kann.</summary>
        <value>Eine leere Zeichenfolge, die verhindert, dass dem <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />-Steuerelement eine Skin zugewiesen wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SkinID%2A> Eigenschaft überschreibt die geerbte <xref:System.Web.UI.Control.SkinID%2A?displayProperty=nameWithType> Eigenschaft, um zu verhindern, dass die <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Steuerelement, das ein Steuerelement unsichtbar Designs ist. Die Implementierung der Eigenschaft wird verhindert, dass ein Design zugewiesen wird, wird durch zurückgeben immer eine leere Zeichenfolge aus der `get` -Zugriffsmethode und immer eine Ausnahme auszulösen, wenn der Versuch zum Festlegen eines Werts der `set` Accessor.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Es wurde versucht, den Eigenschaftswert festzulegen.</exception>
        <altmember cref="P:System.Web.UI.Control.SkinID" />
      </Docs>
    </Member>
    <Member MemberName="StaticConnections">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartConnectionCollection StaticConnections { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartConnectionCollection StaticConnections" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StaticConnections As WebPartConnectionCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ StaticConnections { System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Verweis auf die Auflistung aller als statische Verbindungen definierten <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" />-Objekte auf einer Webseite ab.</summary>
        <value>Eine <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionCollection" />, die alle statischen Verbindungen auf der Seite enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A> Eigenschaft wird verwendet, durch die <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Steuerelement zum Nachverfolgen und verwalten alle statische Verbindungen auf einer Seite. Eine statische Verbindung, im Gegensatz zu einer dynamischen Verbindung muss nicht auf eine Seite hinzugefügt werden, jedes Mal, wenn die Seite gerendert wird.  
  
 Die Auflistung verweist diese Eigenschaft enthält die statische Verbindungen, die auf der Seite vorhanden sind, ob sie programmgesteuert erstellt oder angegeben werden ein `<asp:webpartconnection>` Element im Markup der Seite.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die programmgesteuerte Verwendung von der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A> Eigenschaft.  
  
 Das Codebeispiel besteht aus vier Teilen:  
  
-   Ein Benutzersteuerelement, das Ihnen ermöglicht, ändern Sie die Anzeigemodi auf einer Webparts-Seite.  
  
-   Eine Quellcodedatei, die zwei benutzerdefinierte enthält <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelemente und eine benutzerdefinierte Schnittstelle.  
  
-   Eine Webseite mit zwei benutzerdefinierte <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelemente, die verbunden werden können, und ein `<asp:webpartmanager>` Element.  
  
-   Eine Erläuterung der Funktionsweise des Beispiels in einem Browser.  
  
 Der folgende Code enthält nur die Webseite Teil des Beispiels. Sie müssen auch die ersten beiden Teile des Beispiels--des benutzerdefinierten Benutzersteuerelements und den Quellcode für die benutzerdefinierten Steuerelemente und die Schnittstelle der im Abschnitt "Beispiel" Abrufen der <xref:System.Web.UI.WebControls.WebParts.WebPartManager> -Klassenübersicht. In diesem Thema wird auch erläutert, die Optionen für die Kompilierung der <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelemente.  
  
 Der dritte Teil des Codebeispiels wird die Webseite. Das deklarative Markup für die Seite enthält `Register` -Direktiven für das Benutzersteuerelement und die benutzerdefinierten Steuerelemente. Besteht eine `<asp:webpartmanager>` Element, ein `<asp:webpartzone>` Element enthält die benutzerdefinierten Steuerelemente und ein `<asp:connectionszone>` Element. Beachten Sie, dass in der `Page_Load` -Methode, der Code überprüft, ob eine Verbindung ist bereits vorhanden und, falls nicht, einen Anbieter, ein Consumer und ihre jeweiligen Verbindungspunkte definiert und fügt dann eine neue Verbindung auf den Satz von statischen Verbindungen verweist die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A> Eigenschaft.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/CS/wpmgrStaticConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/VB/wpmgrStaticConnectionVB.aspx#1)]  
  
 Nachdem Sie die Webseite in einem Browser geladen haben, klicken Sie auf die **Anzeigemodus** Dropdownlisten-Steuerelement, und wählen **verbinden** Verbinden-Modus zu wechseln. Verbinden Sie-Modus verwendet die `<asp:connectionszone>` Element, um Verbindungen zwischen Steuerelementen erstellen können. Im Modus verbinden, klicken Sie auf den Pfeil nach unten in der Titelleiste des der **Postleitzahl** Steuerelement, um seine Verbmenü aktivieren, und klicken Sie dann auf **verbinden**. Beachten Sie, dass durch den Code in den bereits eine Verbindung erstellt wurde, nachdem die Verbindungs-Benutzeroberfläche (UI) angezeigt wird, die `Page_Load` Methode. Wenn Sie in einer späteren Browsersitzung zu dieser Seite zurückkehren, werden diese statische Verbindung bereits eingerichtet werden und muss nicht jedes Mal neu erstellt werden, die die Seite geladen.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" />
      </Docs>
    </Member>
    <Member MemberName="SupportedDisplayModes">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection SupportedDisplayModes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection SupportedDisplayModes" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SupportedDisplayModes As WebPartDisplayModeCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartDisplayModeCollection ^ SupportedDisplayModes { System::Web::UI::WebControls::WebParts::WebPartDisplayModeCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine schreibgeschützte Auflistung aller Anzeigemodi ab, die auf einer bestimmten Webseite verfügbar sind.</summary>
        <value>Eine <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection" />, die den Satz der auf einer bestimmten Webseite verfügbaren <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />-Objekte enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> Eigenschaft enthält nur die Anzeigemodi, die tatsächlich verfügbar sind, auf einer Seite, erhält die Arten von Zonensteuerelemente, die auf der Seite vorhanden sind.  
  
> [!NOTE]
>  Anzeigemodi können deaktiviert werden, und wenn Sie ein Anzeigemodus deaktiviert ist, es wird nicht hinzugefügt der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> -Auflistung, auch wenn der entsprechende Typ der Zone, die diese Anzeigemodus unterstützt auf der Seite vorhanden ist.  
  
 Der Durchsuchenmodus und Entwurfsmodus werden immer unterstützt. Die Anzeigemodi, deren variieren kann, werden die Bearbeitung Katalog, und verbinden Sie die Modi. Jede dieser Anzeigemodi bezieht sich auf eine bestimmte Art von <xref:System.Web.UI.WebControls.WebParts.ToolZone> Steuerelement. Es ist das Vorhandensein dieser speziell typisierte Zone auf einer Webseite, die einen bestimmten Anzeigemodus der Auflistung verweist hinzuzufügende bewirkt, dass die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> Eigenschaft. Angenommen, eine Webseite enthält ein <xref:System.Web.UI.WebControls.WebParts.EditorZone> zone aber keine <xref:System.Web.UI.WebControls.WebParts.CatalogZone> zone, und klicken Sie dann der Bearbeitungsmodus für die Anzeige einer der unterstützten Modi auf dieser Seite ist, aber der Anzeigemodus der Katalog wird nicht unterstützt.  
  
> [!NOTE]
>  Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> Eigenschaft unterscheidet sich von der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes%2A> -Eigenschaft, die verweist auf eine Auflistung, die alle mit dem aktuellen verfügbaren Anzeigemodi enthält <xref:System.Web.UI.WebControls.WebParts.WebPartManager> steuern, selbst solche, die auf eine bestimmte Seite nicht unterstützt werden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, die programmgesteuerte Verwendung der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> Eigenschaft. Der Code verwendet diese Eigenschaft zum Auffüllen der Liste mit nur die in der aktuellen Webseite verfügbaren Anzeigemodi an.  
  
 Es gibt drei Anzeigemodi unterstützt auf dieser Seite: Durchsuchen, Entwerfen und bearbeiten. Die ersten beiden sind immer verfügbar, und der Bearbeitungsmodus ist in diesem Codebeispiel verfügbar, da die Seite enthält eine <xref:System.Web.UI.WebControls.WebParts.EditorZone> Steuerelement. Der Katalog und Modi nicht angezeigt werden, da die entsprechenden Zonen nicht auf dieser Seite befinden.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_SupportedDisplayModes#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_SupportedDisplayModes/CS/wpmgrSuppDisplayModescs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_SupportedDisplayModes#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_SupportedDisplayModes/VB/wpmgrSuppDisplayModesvb.aspx#1)]  
  
 Laden Sie die Seite in einem Browser, können Sie das Dropdownlisten-Steuerelement verwenden, um die Seite Durchsuchen-Modus in den Entwurfsmodus zu wechseln und dann in den Bearbeitungsmodus. In den Bearbeitungsmodus wechseln, können Sie auf die Dropdown-Verbmenü im Header der eines der Serversteuerelemente, und wählen **bearbeiten** auf das Steuerelement zu bearbeiten.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty">
      <MemberSignature Language="C#" Value="bool System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#IsDirty" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsDirty As Boolean Implements IPersonalizable.IsDirty" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob mit dem <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />-Steuerelement verwaltete benutzerdefinierte Personalisierungszustandsdaten auf einer Webseite geändert wurden.</summary>
        <value>Ein boolescher Wert, der angibt, ob die Personalisierungszustandsdaten geändert wurden.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A> Eigenschaft bietet eine Möglichkeit für den Aufrufer, um zu bestimmen, ob die Personalisierung Daten anzugeben, die von verwalteten der <xref:System.Web.UI.WebControls.WebParts.WebPartManager> -Steuerelements geändert hat. Wenn Benutzer personalisieren Seitenebene Details, z. B. durch Ändern des Seitenlayouts, erstellen oder Löschen von Verbindungen, hinzufügen oder Löschen von Steuerelementen, die Personalisierungsdaten von und verwaltet die <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Änderungen steuern. Dies ist eine Pass-Through-Methode, die für Aufrufer der Wert für den geschützten zurückgegeben <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty%2A> -Eigenschaft, die von Aufrufern nicht direkt zugegriffen werden kann.  
  
> [!NOTE]
>  Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A> -Eigenschaft nicht an, ob personalisierbar Eigenschaftswerte oder einzelne Eigenschaften, die die Darstellung der einzelnen beeinflussen <xref:System.Web.UI.WebControls.WebParts.WebPart> -Steuerelemente wurden geändert. Steuerungsebene Personalisierung werden für jedes Steuerelement einzeln nachverfolgt. Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A> Eigenschaft gibt nur an, ob Personalisierungsdaten, die auf Seitenebene und durch erfolgt die <xref:System.Web.UI.WebControls.WebParts.WebPartManager> -Steuerelements geändert hat.  
  
 Die folgende Liste beschreibt einige allgemeine Instanzen von Personalisierung, die dazu führen würde, dass die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A> -Eigenschaft zum Zurückgeben von Wert `true`gibt an, die <xref:System.Web.UI.WebControls.WebParts.WebPartManager> -Steuerelement Personalisierungsdaten geändert:  
  
-   Schließen einen statischen <xref:System.Web.UI.WebControls.WebParts.WebPart> -Steuerelement (oder Server oder das Benutzersteuerelement) auf einer Seite.  
  
-   Wiederherstellen einen geschlossenen statischen <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelement aus einem Seitenkatalog auf einer Seite.  
  
-   Verschieben Sie jedes Steuerelement innerhalb einer Zone oder in eine andere Zone.  
  
-   Hinzufügen eines Steuerelements aus einem Katalog von <xref:System.Web.UI.WebControls.WebParts.WebPart> oder Serversteuerelemente oder ein Steuerelement programmgesteuert hinzufügen.  
  
-   Erstellen einer Verbindung zwischen zwei <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelemente, die entweder programmgesteuert oder mithilfe der Verbindungs-Benutzeroberfläche (UI).  
  
-   Das Löschen einer Verbindung zwischen zwei <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelemente, die entweder programmgesteuert oder über die Benutzeroberfläche für Verbindungen.  
  
 Zum Wert dieser Eigenschaft zuzugreifen, müssen Sie eine Umwandlung der <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Steuerelementinstanz auf die <xref:System.Web.UI.WebControls.WebParts.IPersonalizable> -Schnittstelle, sondern entwerfen die lesen können die <xref:System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty%2A> Eigenschaftswert.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht eine einfache Verwendung von der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A> Eigenschaft an, dass einige allgemeine Seite Personalisierung Instanzen, aufgrund derer eine <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Personalisierungsdaten zum Ändern des Steuerelements.  
  
 Das Codebeispiel besteht aus vier Teilen:  
  
-   Ein Benutzersteuerelement, mit dem Sie den Anzeigemodus auf einer Seite zu ändern, die Webparts-Steuerelemente enthält.  
  
-   Eine Quelldatei mit dem Code für zwei benutzerdefinierte <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelemente, die verbunden werden können und eine Schnittstelle.  
  
-   Eine Webseite, die alle Steuerelemente hostet.  
  
-   Eine Erläuterung, wie im Codebeispiel funktioniert.  
  
 Der erste Teil des Codebeispiels wird das Benutzersteuerelement zum Ändern des Anzeigemodus. Sie können den Quellcode für das Benutzersteuerelement abrufen, der im Abschnitt "Beispiel" die <xref:System.Web.UI.WebControls.WebParts.WebPartManager> -Klassenübersicht. Informationen zu Anzeigemodi und zur Funktionsweise des Benutzersteuerelements finden Sie unter [Exemplarische Vorgehensweise: Ändern des Anzeigemodus auf einer Webparts-Seite](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0).  
  
 Der zweite Teil des Beispiels wird die Quelldatei mit der benutzerdefinierten Steuerelemente und die Schnittstelle an. Beachten Sie, dass die `IZipCode` -Schnittstelle macht eine Methode, und diese Methode implementiert wird, in der benutzerdefinierten `ZipCodeWebPart` Steuerelement fungiert als eine Rückrufmethode aktivieren `ZipCodeWebPart` in einem Szenario mit einer Verbindung als Anbieter zu fungieren. Die Steuerelemente, `WeatherWebPart`, fungiert als Consumer in einer Verbindung zu steuern; die Schnittstelle gebotenen beanspruchen kann `ZipCodeWebPart`. In einer realen Anwendung `WeatherWebPart` konnte einen personalisierten PLZ-Wert vom Anbieter nutzen und geben Sie grafische Wetterdaten für Benutzer.  
  
 Für das Codebeispiel ausführen müssen Sie diesen Quellcode kompilieren. Sie können es explizit kompilieren und legen Sie die resultierende Assembly im Bin-Ordner der Website oder dem globalen Assemblycache. Alternativ können Sie den Quellcode im Ordner "App_Code" des Standorts, ablegen, wo er zur Laufzeit dynamisch kompiliert wird. Dieses Codebeispiel verwendet die dynamische Kompilierung; Beachten Sie daher, dass die `Register` Richtlinie für diese Komponente am oberen Rand der Webseite enthält nur `TagPrefix` und `Namespace` Attribute, ohne eine `Assembly` Attribut. Eine exemplarische Vorgehensweise zum Kompilieren, veranschaulicht, finden Sie unter [Exemplarische Vorgehensweise: Entwickeln und Verwenden eines benutzerdefinierten Webserver-Steuerelements](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08).  
  
 [!code-csharp[WebParts_WebPartManager_IsDirty#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsDirty/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_IsDirty#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsDirty/VB/ZipCodeComponent.vb#2)]  
  
 Der dritte Teil des Codebeispiels wird die Webseite. Beachten Sie, dass es zwei enthält <xref:System.Web.UI.WebControls.WebParts.WebPartZone> Zonen, mit der ersten Anweisung mit einem der beiden benutzerdefinierten <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelemente. Es gibt auch eine <xref:System.Web.UI.WebControls.WebParts.CatalogZone> Zone, die einen Standard enthält <xref:System.Web.UI.WebControls.Calendar> Steuerelement, das Benutzer zur Seite hinzufügen können. Die `<asp:connectionszone>` -Element stellt eine Verbindung Ihrer Benutzeroberfläche für Benutzer zum Erstellen von Verbindungen zwischen Steuerelementen bereit. In der `Page_PreRender` -Methode, um festzustellen, ob die Personalisierungsdaten geändert wurde und wenn dies der Fall ist, prüft, aktualisiert den Text des `Label1`.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_IsDirty#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsDirty/CS/wpmgrIsDirtyCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_IsDirty#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsDirty/VB/wpmgrIsDirtyVB.aspx#1)]  
  
 Nachdem Sie die Seite in einem Browser geladen haben, versuchen Sie, erstellen einige der Szenarien aufgeführt, die im Abschnitt "Hinweise" dieses Themas, die die Personalisierungsdaten geändert wird. Wie Sie verschiedene Änderungen vornehmen, wenn eine Änderung eines der Personalisierung Szenarios von verfolgt beinhaltet die <xref:System.Web.UI.WebControls.WebParts.WebPartManager> zu steuern, den Text der der `Label1` Steuerelement wird angezeigt, um anzugeben, dass die Personalisierungsdaten geändert wurden. Sie haben unter anderem folgende Möglichkeiten:  
  
-   Erstellen Sie eine Verbindung zwischen Steuerelementen, indem Sie auf die **Connect WebPart Controls** Schaltfläche.  
  
-   Verwenden der **Anzeigemodus** Dropdownlisten-Steuerelement auf der Seite ", Katalogmodus wechseln und fügen Sie der **Kalender** Steuerelement auf dem zweiten <xref:System.Web.UI.WebControls.WebParts.WebPartZone> Zone.  
  
-   Änderung wieder die Seite auf die Durchsuchen-Modus, klicken Sie auf die Verbmenü (mit einem Pfeil in der Titelleiste angezeigt) für die **Kalender** Steuerelement, und wählen Sie **schließen** zum Schließen und die Seite "Katalog hinzufügen.  
  
-   Die Seite zum Katalogmodus zurückkehren und Hinzufügen der **Kalender** die Steuerung wieder an die Seite.  
  
-   Verwenden der **Anzeigemodus** steuern, um die Seite in den Entwurfsmodus zu wechseln und das Layout der Steuerelemente durch Ziehen eine oder mehrere dieser Header in einer anderen Zone oder an eine andere Position in der gleichen Zone neu anordnen.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.IPersonalizable" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.PersonalizationState" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty" />
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.WebControls.WebParts.IPersonalizable.Load">
      <MemberSignature Language="C#" Value="void IPersonalizable.Load (System.Web.UI.WebControls.WebParts.PersonalizationDictionary state);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.WebControls.WebParts.IPersonalizable.Load(class System.Web.UI.WebControls.WebParts.PersonalizationDictionary state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Load(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      <MemberSignature Language="VB.NET" Value="Sub Load (state As PersonalizationDictionary) Implements IPersonalizable.Load" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.WebControls.WebParts.IPersonalizable.Load(System::Web::UI::WebControls::WebParts::PersonalizationDictionary ^ state) = System::Web::UI::WebControls::WebParts::IPersonalizable::Load;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.WebControls.WebParts.IPersonalizable.Load(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />
      </Parameters>
      <Docs>
        <param name="state">Ein <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />, das die zu ladenden Zustandsdaten enthält.</param>
        <summary>Gibt zuvor gespeicherte benutzerdefinierte Personalisierungszustandsdaten zurück, die in das <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />-Steuerelement geladen werden müssen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist eine Implementierung der <xref:System.Web.UI.WebControls.WebParts.IPersonalizable.Load%2A?displayProperty=nameWithType> -Methode, die es ermöglicht dem Webparts-Steuerelementsatz für direkt den Zugriff auf den geschützten festgelegt <xref:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState%2A?displayProperty=nameWithType> Methode. Wenn diese Methode aufgerufen wird, speichert Sie die benutzerdefinierten persönlichen Daten, die von verwalteten der <xref:System.Web.UI.WebControls.WebParts.WebPartManager> -Steuerelement und die zuvor im dauerhaften Datenspeicher zur späteren Verwendung in den Initialisierungsprozess gespeichert wurden.  
  
> [!NOTE]
>  In den meisten Fällen muss Seiten- und Entwicklercode nicht zum Aufrufen dieser Methode, da es in erster Linie von der Webparts-Steuerelementsatz als Mechanismus zum Abrufen von Personalisierungsdaten verwendet wird.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ein Szenario, in dem Entwickler diese Methode verwenden würden, wird die entwickeln sie eine benutzerdefinierte Personalisierung Framework anstelle der verwendet, das von der Webparts-Steuerelementsatz bereitgestellt wird. In solchen Fällen können Entwickler von erben die <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> Klasse, und überschreiben die <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization" /> Methode, um eine benutzerdefinierte Implementierung von zurückzugeben eine <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" /> Objekt. Die benutzerdefinierte <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" /> Objekt würde die Implementierung von Aufrufen der <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Load(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" /> Methode zum geeigneten Zeitpunkt zum Laden von Personalisierungsdaten für benutzerdefinierte.</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.WebControls.WebParts.IPersonalizable.Save">
      <MemberSignature Language="C#" Value="void IPersonalizable.Save (System.Web.UI.WebControls.WebParts.PersonalizationDictionary state);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.WebControls.WebParts.IPersonalizable.Save(class System.Web.UI.WebControls.WebParts.PersonalizationDictionary state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Save(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      <MemberSignature Language="VB.NET" Value="Sub Save (state As PersonalizationDictionary) Implements IPersonalizable.Save" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.WebControls.WebParts.IPersonalizable.Save(System::Web::UI::WebControls::WebParts::PersonalizationDictionary ^ state) = System::Web::UI::WebControls::WebParts::IPersonalizable::Save;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.WebControls.WebParts.IPersonalizable.Save(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />
      </Parameters>
      <Docs>
        <param name="state">Ein <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />, das die zu speichernden Zustandsdaten enthält.</param>
        <summary>Speichert benutzerdefinierte Personalisierungszustandsdaten, die vom <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />-Steuerelement verwaltet werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Save%2A> Methode ist eine Implementierung von der <xref:System.Web.UI.WebControls.WebParts.IPersonalizable.Save%2A?displayProperty=nameWithType> -Methode, die es ermöglicht dem Webparts-Steuerelementsatz für direkt den Zugriff auf den geschützten festgelegt <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState%2A?displayProperty=nameWithType> Methode. Wenn diese Methode aufgerufen wird, speichert er alle personalisierte Daten, die von verwalteten der <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Steuerelement im permanenten Datenspeicher für eine Webparts-Anwendung konfiguriert.  
  
> [!NOTE]
>  In den meisten Fällen muss Seiten- und Entwicklercode nicht zum Aufrufen dieser Methode, da es in erster Linie von der Webparts-Steuerelementsatz als Mechanismus zum Speichern von Personalisierungsdaten verwendet wird.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ein Szenario, in dem Entwickler diese Methode verwenden würde, wird die entwickeln sie eine benutzerdefinierte Personalisierung Framework anstelle der verwendet, das von der Webparts-Steuerelementsatz bereitgestellt wird. In solchen Fällen können Entwickler von erben die <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> Klasse, und überschreiben die <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization" /> Methode, um eine benutzerdefinierte Implementierung von zurückzugeben eine <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" /> Objekt. Die benutzerdefinierte <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" /> Objekt würde die Implementierung von Aufrufen der <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Save(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" /> Methode zum geeigneten Zeitpunkt zum Speichern der von benutzerdefinierten Personalisierungsdaten.</para>
        </block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#IsDirty" />
      </Docs>
    </Member>
    <Member MemberName="TrackViewState">
      <MemberSignature Language="C#" Value="protected override void TrackViewState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void TrackViewState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.TrackViewState" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub TrackViewState ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void TrackViewState();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wendet Personalisierungszustandsdaten auf das <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />-Steuerelement an und ruft die Basismethode auf, um die Nachverfolgung von Änderungen an Ansichtszustandsdaten für das Steuerelement zu aktivieren.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Änderungen an den Ansichtszustand Daten befinden sich einem <xref:System.Web.UI.StateBag> Objekt, und durch des Steuerelements zugegriffen werden kann <xref:System.Web.UI.Control.ViewState%2A> Eigenschaft.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Visible">
      <MemberSignature Language="C#" Value="public override bool Visible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Visible" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Visible" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Visible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool Visible { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, mit dessen Hilfe untergeordnete Steuerelemente sichtbar sein können.</summary>
        <value>Ein boolescher Wert, der angibt, ob ein <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />-Steuerelement und dessen untergeordnete Steuerelemente sichtbar sind. <see langword="true" /> in allen Fällen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Steuerelement überschreibt die <xref:System.Web.UI.Control.Visible%2A?displayProperty=nameWithType> Wert zurückzugebende Eigenschaft `true` für die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Visible%2A> Eigenschaft. Obwohl die <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Steuerelement selbst ist nicht sichtbar, die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Visible%2A> -Eigenschaft muss festgelegt werden, um `true` , damit alle untergeordneten Steuerelemente standardmäßig sichtbar sind.  
  
 Wenn Sie versuchen, das Festlegen des Werts der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Visible%2A> -Eigenschaft, wird immer ein Fehler generiert, da die <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Steuerelement Verhalten der Basiseigenschaft überschrieben hat und verhindert, dass die Eigenschaft einen Wert zuweist.  
  
 Diese Eigenschaft kann nicht in visuellen Designern gebunden werden, jedoch kann zur Laufzeit gebunden werden. Weitere Informationen finden Sie unter <xref:System.ComponentModel.BindableAttribute>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Es wurde versucht, der Eigenschaft einen Wert zuzuordnen.</exception>
      </Docs>
    </Member>
    <Member MemberName="WebPartAdded">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartAdded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartAdded" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartAdded As WebPartEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartEventHandler ^ WebPartAdded;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, nachdem ein dynamisches <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />-Steuerelement oder sonstiges Serversteuerelement einer <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />-Zone hinzugefügt wurde, um anzuzeigen, dass das Steuerelement erfolgreich hinzugefügt wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded> eignet sich Ereignis gibt an, dass ein dynamisches Steuerelement (ein Steuerelement programmgesteuert hinzugefügt und im Gegensatz zu in-Seitenmarkup deklariert wird) zu einer Zone erfolgreich hinzugefügt wurde. In Verbindung mit der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded%2A> -Methode, die das Ereignis bietet Entwicklern eine Möglichkeit zum Aktualisieren der Benutzeroberfläche (UI) oder benachrichtigen Sie Benutzer an, dass ein Steuerelement erfolgreich hinzugefügt wurde.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding" />
      </Docs>
    </Member>
    <Member MemberName="WebPartAdding">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartAddingEventHandler WebPartAdding;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartAddingEventHandler WebPartAdding" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartAdding As WebPartAddingEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartAddingEventHandler ^ WebPartAdding;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartAddingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, während einer <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />-Zone ein dynamisches <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />-Steuerelement oder ein anderes Serversteuerelement hinzugefügt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding> Ereignis wird ausgelöst, durch die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding%2A> -Methode auf, nachdem der Prozess des Hinzufügens eines Steuerelements zu einer Zone mit dem begonnen hat. Dieses Ereignis bietet die Möglichkeit, den Prozess abzubrechen, bevor er abgeschlossen ist. Wenn der Prozess des Hinzufügens erfolgreich ist, wird dieses Ereignis gefolgt von der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded> Ereignis.  
  
 Seite-Entwickler können benutzerdefinierte Handler für das Ereignis bereitstellen, durch Hinzufügen der `OnWebPartAdding` -Attribut auf die `<asp:webpartmanager>` Element in einer Seite und dem Attribut einen benutzerdefinierten Methodennamen zuweisen.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding(System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded" />
      </Docs>
    </Member>
    <Member MemberName="WebPartClosed">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartClosed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartClosed" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartClosed As WebPartEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartEventHandler ^ WebPartClosed;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn ein <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />-Steuerelement (oder Server- bzw. Benutzersteuerelement) von einer Seite entfernt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed> Ereignis gibt an, dass ein Steuerelement von einem Benutzer oder programmgesteuert erfolgreich geschlossen wurde. Schließen einer <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelement bedeutet, dass es auf einer Seite zu entfernen, damit diese nicht gerendert und in einer speziellen platzieren halten Objekt so einen Seitenkatalog genannte. Eine Seitenkatalog, entspricht die <xref:System.Web.UI.WebControls.WebParts.PageCatalogPart> steuern, verwaltet Verweise auf geschlossene <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelemente für jede Seite. Wenn eine <xref:System.Web.UI.WebControls.WebParts.PageCatalogPart> -Steuerelement deklariert wird, auf einer Seite innerhalb einer <xref:System.Web.UI.WebControls.WebParts.CatalogZone> Zone, Benutzern in Kataloganzeigemodus auf einer Seite wechseln und wieder zu einer Seite alle Steuerelemente, die zuvor geschlossene hinzufügen können.  
  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed> Ereignis zugeordnet ist die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed%2A> -Methode, die das Ereignis auslöst und stellt einen Handler für es.  
  
 Seite-Entwickler können fügen einen benutzerdefinierten Handler für das Ereignis hinzu, indem ein `OnWebPartClosed` -Attribut auf die `<asp:webpartmanager>` Element in einer Seite, und weisen Sie dann einen Namen für die benutzerdefinierte Methode für das Attribut.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="WebPartClosing">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler WebPartClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler WebPartClosing" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartClosing As WebPartCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartCancelEventHandler ^ WebPartClosing;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, während ein <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />-Steuerelement (oder ein Server- bzw. Benutzersteuerelement) von einer Seite entfernt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing> Ereignis wird ausgelöst, durch die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing%2A> Methode bei der <xref:System.Web.UI.WebControls.WebParts.WebPartManager> -Steuerelement ist ein Steuerelement. Wenn das Entfernen des Steuerelements erfolgreich ist, wird dieses Ereignis gefolgt von der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed> Ereignis.  
  
 Entwickler von Seiten können einen benutzerdefinierten Handler für das Ereignis bereitstellen, durch Hinzufügen der `OnWebPartClosed` -Attribut auf die <`asp:webpartmanager>` Element in einer Seite und dem Attribut einen benutzerdefinierten Methodennamen zuweisen.  
  
 Normalerweise, wenn die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing> Ereignis wird ausgelöst, als direktes Ergebnis einer schließenden Benutzer eine <xref:System.Web.UI.WebControls.WebParts.WebPart> -Steuerelement, das Ereignis abgebrochen werden kann. Es ist jedoch ein Szenario, in dem das Ereignis abgebrochen werden kann. Wenn eine <xref:System.Web.UI.WebControls.WebParts.WebPartZone> -Steuerelement gelöscht wird, die <xref:System.Web.UI.WebControls.WebParts.WebPart> müssen alle darin enthaltenen Steuerelemente geschlossen werden, da Sie sonst verwaist werden. In diesem Fall die <xref:System.Web.UI.WebControls.WebParts.WebPartManager> steuern geschlossen wird, wird die <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelemente, die nicht für den Benutzer. Und wann die <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Steuerelement gerade aufgerufen wird die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A> Methode, um jedes Steuerelement zu schließen und die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing> Ereignis wird ausgelöst, die das Ereignis kann nicht (entwurfsbedingt) abgebrochen werden, da die <xref:System.Web.UI.WebControls.WebParts.WebPartManager> muss das Bereinigen von abzuschließen Steuerelemente für alle der Zone.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="WebPartDeleted">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartDeleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartDeleted" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartDeleted As WebPartEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartEventHandler ^ WebPartDeleted;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, nachdem ein <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />-Steuerelement oder sonstiges Serversteuerelement aus einer <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />-Zone gelöscht wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted> eignet sich Ereignis gibt an, dass ein dynamisches Steuerelement (ein Steuerelement programmgesteuert hinzugefügt und im Gegensatz zu in-Seitenmarkup deklariert wird) aus einer Zone wurde erfolgreich gelöscht wurde. In Verbindung mit der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleted%2A> -Methode, die das Ereignis bietet Entwicklern eine Möglichkeit zum Aktualisieren der Benutzeroberfläche (UI) oder Benutzer darüber zu benachrichtigen, dass ein Steuerelement erfolgreich gelöscht wurde.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleted(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="WebPartDeleting">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler WebPartDeleting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler WebPartDeleting" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartDeleting As WebPartCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartCancelEventHandler ^ WebPartDeleting;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, während eine Instanz eines dynamischen <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />-Steuerelements oder eines anderen Serversteuerelements dauerhaft aus einer <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />-Zone gelöscht wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting> Ereignis wird ausgelöst, durch die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting%2A> Methode, die während des Löschvorgangs für eines dynamischen Steuerelements (eins programmgesteuert oder durch einen Benutzer über die Benutzeroberfläche des Webparts hinzugefügt wurde). Das Ereignis bietet die Möglichkeit, den Prozess abzubrechen, bevor er abgeschlossen ist. Wenn der Löschvorgang erfolgreich abgeschlossen wird, wird dieses Ereignis gefolgt von der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted> Ereignis.  
  
 Seite-Entwickler können benutzerdefinierte Handler für das Ereignis bereitstellen, durch Hinzufügen der `OnWebPartDeleting` -Attribut auf die `<asp:webpartmanager>` Element in einer Seite und dem Attribut einen benutzerdefinierten Methodennamen zuweisen.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      </Docs>
    </Member>
    <Member MemberName="WebPartMoved">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartMoved;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartMoved" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartMoved As WebPartEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartEventHandler ^ WebPartMoved;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, nachdem ein <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />-Steuerelement oder Serversteuerelement an eine andere Position auf einer Webseite verschoben wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis gilt (deklariert in das Markup einer Webseite) statische und dynamische Steuerelemente ab. Er zugeordnet ist die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved%2A> Methode. Da das Ereignis ausgelöst wird, nachdem ein Verschiebevorgang abgeschlossen wurde, können Entwickler einen Ereignishandler, um eine Benachrichtigung an Benutzer, eine Validierung oder einige andere Aktionen bieten einschließen. Um einen Ereignishandler hinzuzufügen, fügen Sie ein `OnWebPartMoved` -Attribut auf die `<asp:webpartmanager>` Element in einer Seite, und weisen Sie den Namen einer benutzerdefinierten Methode für das Attribut.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="WebPartMoving">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartMovingEventHandler WebPartMoving;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartMovingEventHandler WebPartMoving" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartMoving As WebPartMovingEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartMovingEventHandler ^ WebPartMoving;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartMovingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, während ein in einer <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />-Zone enthaltenes <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />-Steuerelement oder ein anderes Serversteuerelement verschoben wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving> Ereignis wird ausgelöst, wenn eine <xref:System.Web.UI.WebControls.WebParts.WebPart> oder andere Webserversteuerelement innerhalb der eigenen Zone oder in eine andere Zone verschoben wird. Dies kann auftreten, wenn ein Benutzer ein Steuerelement zieht und es wird eine programmgesteuerte verschieben.  
  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving> Ereignis wird ausgelöst, durch die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving%2A> -Methode, und es bietet die Möglichkeit, den Prozess des verschieben Abbrechen, bevor er abgeschlossen ist. Wenn der Verschiebevorgang abgeschlossen ist und das Steuerelement in eine neue Position eingefügt, dieses Ereignis von gefolgt wird der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved> Ereignis.  
  
 Entwickler von Seiten können einen benutzerdefinierten Handler für das Ereignis erstellen, durch Hinzufügen der `OnWebPartMoving` -Attribut auf die `<asp:webpartmanager>` Element und das Attribut einen benutzerdefinierten Methodennamen zuweisen.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving(System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="WebParts">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartCollection WebParts { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartCollection WebParts" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WebParts As WebPartCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartCollection ^ WebParts { System::Web::UI::WebControls::WebParts::WebPartCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Verweis auf alle vom <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />-Steuerelement auf einer Webseite nachverfolgten <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />-Steuerelemente ab.</summary>
        <value>Eine <see cref="T:System.Web.UI.WebControls.WebParts.WebPartCollection" />, die Verweise auf einen Satz von <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />-Steuerelementen enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> Eigenschaft wird verwendet, durch die <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Steuerelement zum Nachverfolgen von allen <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelemente, die in enthaltenen <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> Zonen auf der Seite. Obwohl die Auflistung schreibgeschützt ist, können Sie einzelne zugreifen <xref:System.Web.UI.WebControls.WebParts.WebPart> programmgesteuert über die Auflistung und nehmen Sie Änderungen auf diese steuert.  
  
> [!NOTE]
>  Es ist möglich, dass eine <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelement platziert werden, auf einer Seite außerhalb von einer <xref:System.Web.UI.WebControls.WebParts.WebPartZone> Zone, die Ergebnisse im Steuerelement nicht nachverfolgt werden die <xref:System.Web.UI.WebControls.WebParts.WebPartManager> steuern oder verwiesen wird, seine <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> Auflistung. Es ist jedoch wenig Sinn, verwenden eine <xref:System.Web.UI.WebControls.WebParts.WebPart> außerhalb einer Zone zu steuern, da es dann seine Funktionalität Webparts verliert und als ein normaler Serversteuerelement fungiert.  
  
 Jeder Typ von Steuerelement, die in einer Zone ab, ob eine benutzerdefinierte platziert werden kann <xref:System.Web.UI.WebControls.WebParts.WebPart> -Steuerelement, einem Standardsteuerelement ASP.NET, ein benutzerdefiniertes Steuerelement oder ein benutzerdefiniertes Steuerelement, als behandelt werden kann ein <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelement zur Laufzeit. Wenn ein Steuerelement, das keine <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelement befindet sich ein <xref:System.Web.UI.WebControls.WebParts.WebPartZone> Zone, zur Laufzeit ASP.NET dient als Wrapper für das Steuerelement mit einer <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> Objekt, sodass das Steuerelement "true" Verhalten kann <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelement. Aus diesem Grund mithilfe der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> -Eigenschaft, die <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Steuerelement kann jeden Typ des Steuerelements, unabhängig davon, ob es abgeleitet Nachverfolgen der <xref:System.Web.UI.WebControls.WebParts.WebPart> Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> -Eigenschaft programmgesteuert auf einzelne Zugriff <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelemente. Beachten Sie, dass im deklarativen Markup für die Webseite in der `<asp:webpartzone>` Element, es werden zwei standard ASP.NET-Serversteuerelemente. Obwohl diese nicht von erben die <xref:System.Web.UI.WebControls.WebParts.WebPart> Klasse, da sie in einer Zone sind mit umbrochen eine <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> -Objekt zur Laufzeit und wird daher enthalten sein, in der Auflistung verweist die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> Eigenschaft. Sie können auch benutzerdefinierte hinzufügen <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelemente, Benutzersteuerelemente oder benutzerdefinierte Steuerelemente in dieser Zone, und sie würde die gleiche Weise verarbeitet werden.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_WebParts#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_WebParts/CS/wpmgrWebPartsCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_WebParts#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_WebParts/VB/wpmgrWebPartsVB.aspx#1)]  
  
 Beachten Sie, dass für das Codebeispiel funktioniert, Sie eine Einstellung in der Datei "Web.config" So aktivieren Sie die Webparts Description-Dateien exportieren hinzufügen müssen. Stellen Sie sicher, dass Sie eine Datei "Web.config" im gleichen Verzeichnis wie die Webseite für dieses Codebeispiel verfügen. Innerhalb der `<system.web>` Abschnitt, stellen Sie sicher, dass eine `<webParts>` Element mit einem `enableExport` -Attributsatz zur `true`, wie im folgenden Markup.  
  
 `<webParts enableExport="true">`  
  
 `...`  
  
 `</webParts>`  
  
 Nachdem die Seite in einem Browser zu laden, wenn Sie auf die **WebPart Count** Schaltfläche, die der Code verwendet die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> Eigenschaft, um die Anzahl der Steuerelemente in der Auflistung zurück. Wenn Sie auf die **Kalendertitels ausblenden** Schaltfläche, den Code der Kalender geändert, damit es mit nur einem Rahmen und ohne Titel gerendert werden soll.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WebPartsConnected">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler WebPartsConnected;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler WebPartsConnected" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartsConnected As WebPartConnectionsEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartConnectionsEventHandler ^ WebPartsConnected;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, nachdem eine bestimmte Verbindung zwischen <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />-Steuerelementen (bzw. Server- oder Benutzersteuerelementen) erstellt wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected> Ereignis zugeordnet ist die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnected%2A> Methode. Das Ereignis ist hilfreich, da Nachdem Sie wissen, dass eine Verbindung hergestellt wurde, möchten Sie möglicherweise informiert den Benutzer der Fakt, oder ändern sich sogar die Benutzeroberfläche (UI) der Seite. Beispielsweise empfiehlt es sich um eine Grafik anzuzeigen, die erfolgreich eine Verbindung zwischen zwei Steuerelementen schlägt vor, oder eine kurze Meldung anzeigen und ändern Sie dann den Anzeigemodus für die Seite wieder in den Durchsuchen-Modus.  
  
 Seite-Entwickler können mit diesem Ereignis einen benutzerdefinierten Ereignishandler zuordnen, durch Hinzufügen der `OnWebPartsConnected` -Attribut auf die `<asp:webpartmanager>` Element auf der Seite und dem Attribut einen benutzerdefinierten Methodennamen zuweisen.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnected(System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="WebPartsConnecting">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler WebPartsConnecting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler WebPartsConnecting" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartsConnecting As WebPartConnectionsCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartConnectionsCancelEventHandler ^ WebPartsConnecting;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, während eine Verbindung zwischen <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />-Steuerelementen (oder in einer <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />-Zone platzierten Server- bzw. Benutzersteuerelementen) erstellt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting> Ereignis wird ausgelöst, durch die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting%2A> -Methode, und wird signalisiert, dass der Verbindungsprozess begonnen hat (ein Benutzer hat z. B. ein Steuerelement ausgewählt und eine Connect-Verb geklickt), aber noch nicht abgeschlossen ist. Das Ereignis bietet die Möglichkeit, eine Verbindung abzubrechen, bevor er abgeschlossen ist. Wenn die Verbindung erfolgreich abgeschlossen wird, wird dieses Ereignis gefolgt von der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected> Ereignis.  
  
 Seite-Entwickler können fügen einen benutzerdefinierten Handler für das Ereignis hinzu, indem die `OnWebPartsConnecting` -Attribut auf die `<asp:webpartmanager>` -Element und das Attribut einen benutzerdefinierten Methodennamen zuweisen.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" />
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts" />
      </Docs>
    </Member>
    <Member MemberName="WebPartsDisconnected">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler WebPartsDisconnected;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler WebPartsDisconnected" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartsDisconnected As WebPartConnectionsEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartConnectionsEventHandler ^ WebPartsDisconnected;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, nachdem eine Verbindung zwischen zwei <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />-Steuerelementen oder Serversteuerelementen beendet wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected> Ereignis zugeordnet ist die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnected%2A> Methode. Das Ereignis ist hilfreich, da nach dem Sie wissen, dass eine Verbindung beendet wird, Sie möchten möglicherweise informiert den Benutzer darüber, führen Sie einige Bereinigungsaktionen im Code oder andere Änderungen vornehmen, in der Benutzeroberfläche (UI).  
  
 Seite-Entwickler können mit diesem Ereignis einen benutzerdefinierten Ereignishandler zuordnen, durch Hinzufügen der `OnWebPartsDisConnected` -Attribut auf die `<asp:webpartmanager>` Element auf der Seite und dem Attribut einen benutzerdefinierten Methodennamen zuweisen.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnected(System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="WebPartsDisconnecting">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler WebPartsDisconnecting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler WebPartsDisconnecting" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartsDisconnecting As WebPartConnectionsCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartConnectionsCancelEventHandler ^ WebPartsDisconnecting;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, während die Verbindung zwischen zuvor verbundenen <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />-Steuerelementen oder Serversteuerelementen beendet wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> Ereignis wird ausgelöst, durch die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting%2A> -Methode, und es signalisiert die Tatsache, dass ein Benutzer ein Trennen-Verb geklickt hat oder die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> andernfalls-Methode aufgerufen wurde. Das Ereignis bietet die Möglichkeit zum Abbrechen des Prozess beim Beenden einer Verbindung, bevor er abgeschlossen ist. Wenn die Verbindung erfolgreich beendet wird, wird dieses Ereignis gefolgt von der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected> Ereignis.  
  
 Seite-Entwickler können fügen einen benutzerdefinierten Handler für das Ereignis hinzu, indem die `OnWebPartsDisconnecting` -Attribut auf die `<asp:webpartmanager>` -Element und das Attribut einen benutzerdefinierten Methodennamen zuweisen.  
  
 Normalerweise, wenn die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> Ereignis als direktes Ergebnis einer Benutzeraktion, die eine Verbindung beendet wird, kann das Ereignis abgebrochen werden. Es gibt jedoch mehrere Szenarien, in denen das Ereignis abgebrochen werden kann. Im ersten Fall ist, wenn eine <xref:System.Web.UI.WebControls.WebParts.WebPartZone> -Steuerelement gelöscht wird, die <xref:System.Web.UI.WebControls.WebParts.WebPart> müssen alle darin enthaltenen Steuerelemente geschlossen werden, da Sie sonst verwaist werden. In diesem Fall die <xref:System.Web.UI.WebControls.WebParts.WebPartManager> steuern geschlossen wird, wird die <xref:System.Web.UI.WebControls.WebParts.WebPart> Steuerelemente, nicht der Benutzer, und es zudem muss können Sie die Verbindungen des verbundenen Steuerelemente ohne jede Möglichkeit einer Unterbrechung, beenden, damit den Prozess der bereinigen und Schließen von abgeschlossen werden kann alle Steuerelemente. Aus diesem Grund entwurfsbedingt die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> Methode kann nicht in diesem Szenario nicht abgebrochen werden. Ein verwandtes Ereignis, das abgebrochen werden kann, finden Sie unter der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing> Ereignis.  
  
 Das zweite Szenario, in dem die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> Ereignis kann nicht abgebrochen ist, wenn die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A> -Methode aufgerufen wird (Dies wird während der für jede Anforderung an eine Seite, z. B. aufgerufen), und es ist eine Art von Konflikt in der vorhandenen Verbindungen auf einer Seite. Z. B. ein Benutzer vielleicht Steuerelement y, X-Steuerelement herstellt jedoch einen freigegebenen Benutzerkontos verbindet Steuerelement X Z steuern und Steuerelement X ist noch nicht zulässig, um mehrere Verbindungen zu bilden. In diesem Fall die einzelnen Benutzer für die Verbindung Vorrang, und die <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Steuerelement löst den Konflikt durch Aufrufen der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> -Methode und beim Beenden der Verbindung zwischen x und z für den bestimmten Benutzer. Da diese Trennung entscheidend dafür, dass die Auflösung des Konflikts, beabsichtigt ist die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> Ereignis kann nicht in diesem Szenario nicht abgebrochen werden.  
  
 Das dritte Szenario in der die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> Methode kann nicht abgebrochen ist, wenn eine <xref:System.Web.UI.WebControls.WebParts.WebPart> oder -Steuerelement, das derzeit verbunden ist, wird entweder gelöscht oder geschlossen. Da das Steuerelement definitiv stattfinden wird, auf der Seite entfernt werden soll, ist es eine logische Notwendigkeit seine Verbindung entfernen möchten. Aus diesem Grund, wenn der <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Steuerelement ruft der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> -Methode, die wiederum löst der <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> Ereignis entwurfsbedingt gibt es ist keine Möglichkeit zum Abbrechen des Ereignisses.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts(System.Web.UI.WebControls.WebParts.WebPartConnection)" />
      </Docs>
    </Member>
    <Member MemberName="Zones">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartZoneCollection Zones { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartZoneCollection Zones" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Zones" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Zones As WebPartZoneCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartZoneCollection ^ Zones { System::Web::UI::WebControls::WebParts::WebPartZoneCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartZoneCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Verweis auf eine Auflistung aller <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />-Zonen auf einer Webseite ab.</summary>
        <value>Eine <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneCollection" />, die auf einen Satz von <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />-Zonen verweist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Zones%2A> Eigenschaft wird verwendet, durch die <xref:System.Web.UI.WebControls.WebParts.WebPartManager> Steuerelement zum Nachverfolgen der <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> Zonen auf einer Webseite. Beachten Sie, dass die Eigenschaft nicht alle Typen von Zonen verwiesen wird. nur von abgeleiteten Zonen verweist die <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> Klasse, einschließlich <xref:System.Web.UI.WebControls.WebParts.WebPartZone> Zonen.  
  
 Auch wenn die Auflistung, die auf die verwiesen wird durch die Eigenschaft schreibgeschützt ist, können Sie es verwenden, um den Zugriff auf die einzelnen Objekte in der Auflistung und programmgesteuert mit ihnen arbeiten.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Zones%2A> -Eigenschaft programmgesteuert auf einzelne Zugriff <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> Steuerelemente einer zone. Beachten Sie, dass im deklarativen Markup für die Webseite, es zwei gibt `<asp:webpartzone>` Elemente, die jeweils ein Serversteuerelement. In der `<script>` Abschnitt der Seite verwendet der Code die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Zones%2A> Eigenschaft, um die einzelnen Zonen, die Zone IDs auflisten, und ändern Sie die Farbe des Hintergrunds für die zweite Zone zuzugreifen.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_Zones#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_Zones/CS/wpmgrzonescs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_Zones#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_Zones/VB/wpmgrzonesvb.aspx#1)]  
  
 Beachten Sie, dass für das Codebeispiel funktioniert, Sie eine Einstellung in der Datei "Web.config" So aktivieren Sie die Webparts Description-Dateien exportieren hinzufügen müssen. Stellen Sie sicher, dass Sie eine Datei "Web.config" im gleichen Verzeichnis wie die Webseite für dieses Codebeispiel verfügen. Innerhalb der `<system.web>` Abschnitt, stellen Sie sicher, dass eine `<webParts>` Element mit einem `enableExport` -Attributsatz zur `true`, wie im folgenden Markup.  
  
 `<webParts enableExport="true">`  
  
 `...`  
  
 `</webParts>`  
  
 Nachdem die Seite in einem Browser zu laden, wenn Sie auf die **List Zone IDs** Schaltfläche, die der Code verwendet die <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Zones%2A> Eigenschaft, um die IDs aller Zonen in der Auflistung. Wenn Sie auf die **Change Zone BackColor** Schaltfläche, den Code wird die Hintergrundfarbe der zweiten Zone.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>