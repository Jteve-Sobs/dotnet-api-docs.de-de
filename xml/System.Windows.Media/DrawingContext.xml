<Type Name="DrawingContext" FullName="System.Windows.Media.DrawingContext">
  <Metadata><Meta Name="ms.openlocfilehash" Value="425f4a86e37d7204135a62d15f9bc7ece6f3cae8" /><Meta Name="ms.sourcegitcommit" Value="b53d35b4a410c949742abd4c6a989d1af5357bca" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="07/21/2020" /><Meta Name="ms.locfileid" Value="86643658" /></Metadata><TypeSignature Language="C#" Value="public abstract class DrawingContext : System.Windows.Threading.DispatcherObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit DrawingContext extends System.Windows.Threading.DispatcherObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Media.DrawingContext" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class DrawingContext&#xA;Inherits DispatcherObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class DrawingContext abstract : System::Windows::Threading::DispatcherObject, IDisposable" />
  <TypeSignature Language="F#" Value="type DrawingContext = class&#xA;    inherit DispatcherObject&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Threading.DispatcherObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Beschreibt visuellen Inhalt mithilfe der Befehle „draw“, „push“ und „pop“.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden <xref:System.Windows.Media.DrawingContext> Sie, um ein-Element <xref:System.Windows.Media.Visual> oder ein-Element <xref:System.Windows.Media.Drawing> mit visuellen Inhalt aufzufüllen.  
  
 Obwohl die <xref:System.Windows.Media.DrawingContext> Draw-Methoden ähnlich wie die Draw-Methoden des <xref:System.Drawing.Graphics?displayProperty=nameWithType> Typs aussehen, funktionieren Sie sehr anders: <xref:System.Windows.Media.DrawingContext> wird mit einem Grafiksystem im beibehaltenen Modus verwendet, während der <xref:System.Drawing.Graphics?displayProperty=nameWithType> Typ mit einem Grafiksystem im unmittelbaren Modus verwendet wird. Wenn Sie <xref:System.Windows.Media.DrawingContext> die draw-Befehle eines-Objekts verwenden, speichern Sie tatsächlich eine Reihe von Renderinganweisungen (obwohl der genaue Speichermechanismus vom Objekttyp abhängig ist, der den bereitstellt <xref:System.Windows.Media.DrawingContext> ), der später vom Grafiksystem verwendet wird. Sie zeichnen nicht in Echtzeit auf den Bildschirm. Weitere Informationen zur Funktionsweise des WPF-Grafik Systems (Windows Presentation Foundation) finden Sie unter [Übersicht über das WPF-Grafik Rendering](/dotnet/framework/wpf/graphics-multimedia/wpf-graphics-rendering-overview).  
  
 Sie können niemals direkt instanziieren <xref:System.Windows.Media.DrawingContext> . Sie können jedoch einen Zeichnungs Kontext von bestimmten Methoden abrufen, z <xref:System.Windows.Media.DrawingGroup.Open%2A?displayProperty=nameWithType> . b. und <xref:System.Windows.Media.DrawingVisual.RenderOpen%2A?displayProperty=nameWithType> .  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein <xref:System.Windows.Media.DrawingContext> aus einem abgerufen <xref:System.Windows.Media.DrawingVisual> und zum Zeichnen eines Rechtecks verwendet.  
  
 [!code-csharp[drawingvisualsample#101](~/samples/snippets/csharp/VS_Snippets_Wpf/DrawingVisualSample/CSharp/Window1.xaml.cs#101)]
 [!code-vb[drawingvisualsample#101](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DrawingVisualSample/visualbasic/window1.xaml.vb#101)]  
  
 Im nächsten Beispiel werden die <xref:System.Windows.Media.DrawingContext.PushOpacity%2A> <xref:System.Windows.Media.DrawingContext.PushEffect%2A> Befehle, und veranschaulicht <xref:System.Windows.Media.DrawingContext.Pop%2A> . Die <xref:System.Windows.Media.DrawingContext> wird aus einem abgerufen <xref:System.Windows.Media.DrawingGroup> und mithilfe eines- <xref:System.Windows.Controls.Image> Steuer Elements angezeigt.  
  
 [!code-csharp[DrawingContext_procedural_snip#PushEffectExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/DrawingContext_procedural_snip/CSharp/PushEffectExample.cs#pusheffectexamplewholepage)]
 [!code-vb[DrawingContext_procedural_snip#PushEffectExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DrawingContext_procedural_snip/visualbasic/pusheffectexample.vb#pusheffectexamplewholepage)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Media.DrawingGroup" />
    <altmember cref="T:System.Windows.Media.Drawing" />
  </Docs>
  <Members>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public abstract void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.Close" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void Close();" />
      <MemberSignature Language="F#" Value="abstract member Close : unit -&gt; unit" Usage="drawingContext.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Schließt den <see cref="T:System.Windows.Media.DrawingContext" /> und leert den Inhalt. Anschließend kann der <see cref="T:System.Windows.Media.DrawingContext" /> nicht geändert werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.DrawingContext>Muss geschlossen werden, bevor der zugehörige Inhalt gerendert werden kann, aber nachdem er geschlossen wurde, kann er nicht mehr geändert werden. Für diesen Aufruf ist es nicht erforderlich, dass alle pushaufrufe von per Pop entfernt wurden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Dieses Objekt wurde bereits geschlossen oder freigegeben.</exception>
      </Docs>
    </Member>
    <Member MemberName="DisposeCore">
      <MemberSignature Language="C#" Value="protected abstract void DisposeCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DisposeCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DisposeCore" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub DisposeCore ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void DisposeCore();" />
      <MemberSignature Language="F#" Value="abstract member DisposeCore : unit -&gt; unit" Usage="drawingContext.DisposeCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt alle vom <see cref="T:System.Windows.Media.DrawingContext" /> verwendeten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode nicht direkt aus dem Code aufzurufen; Verwenden Sie <xref:System.Windows.Media.DrawingContext.System%23IDisposable%23Dispose%2A> stattdessen die-Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Das Objekt wurde bereits geschlossen oder verworfen.</exception>
        <altmember cref="M:System.Windows.Media.DrawingContext.System#IDisposable#Dispose" />
      </Docs>
    </Member>
    <Member MemberName="DrawDrawing">
      <MemberSignature Language="C#" Value="public abstract void DrawDrawing (System.Windows.Media.Drawing drawing);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawDrawing(class System.Windows.Media.Drawing drawing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawDrawing(System.Windows.Media.Drawing)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub DrawDrawing (drawing As Drawing)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DrawDrawing(System::Windows::Media::Drawing ^ drawing);" />
      <MemberSignature Language="F#" Value="abstract member DrawDrawing : System.Windows.Media.Drawing -&gt; unit" Usage="drawingContext.DrawDrawing drawing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="drawing" Type="System.Windows.Media.Drawing" />
      </Parameters>
      <Docs>
        <param name="drawing">Die anzufügende Zeichnung.</param>
        <summary>Zeichnet das angegebene <see cref="T:System.Windows.Media.Drawing" />-Objekt.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawEllipse">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zeichnet eine Ellipse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawEllipse">
      <MemberSignature Language="C#" Value="public abstract void DrawEllipse (System.Windows.Media.Brush brush, System.Windows.Media.Pen pen, System.Windows.Point center, double radiusX, double radiusY);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawEllipse(class System.Windows.Media.Brush brush, class System.Windows.Media.Pen pen, valuetype System.Windows.Point center, float64 radiusX, float64 radiusY) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawEllipse(System.Windows.Media.Brush,System.Windows.Media.Pen,System.Windows.Point,System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub DrawEllipse (brush As Brush, pen As Pen, center As Point, radiusX As Double, radiusY As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DrawEllipse(System::Windows::Media::Brush ^ brush, System::Windows::Media::Pen ^ pen, System::Windows::Point center, double radiusX, double radiusY);" />
      <MemberSignature Language="F#" Value="abstract member DrawEllipse : System.Windows.Media.Brush * System.Windows.Media.Pen * System.Windows.Point * double * double -&gt; unit" Usage="drawingContext.DrawEllipse (brush, pen, center, radiusX, radiusY)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Windows.Media.Brush" />
        <Parameter Name="pen" Type="System.Windows.Media.Pen" />
        <Parameter Name="center" Type="System.Windows.Point" />
        <Parameter Name="radiusX" Type="System.Double" />
        <Parameter Name="radiusY" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="brush">Der Pinsel, mit dem die Ellipse ausgefüllt werden soll.  Dies ist optional und kann <see langword="null" /> sein. Wenn der Pinsel <see langword="null" /> ist, wird keine Füllung gezeichnet.</param>
        <param name="pen">Der Stift, mit dem der Strich der Ellipse gezeichnet werden soll.  Dies ist optional und kann <see langword="null" /> sein. Wenn der Stift <see langword="null" /> ist, wird kein Strich gezeichnet.</param>
        <param name="center">Die Position des Mittelpunkts der Ellipse.</param>
        <param name="radiusX">Der horizontale Radius der Ellipse.</param>
        <param name="radiusY">Der vertikale Radius der Ellipse.</param>
        <summary>Zeichnet eine Ellipse mit dem angegebenen <see cref="T:System.Windows.Media.Brush" /> und <see cref="T:System.Windows.Media.Pen" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Pinsel und der Stift können beide sein `null` .  Wenn der Pinsel ist `null` , wird keine Füllung ausgeführt.  Wenn der Stift ist `null` , wird kein Stoke-Vorgang ausgeführt.  Wenn der Stift und der Pinsel sind `null` , ist das Zeichnen nicht sichtbar.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawEllipse">
      <MemberSignature Language="C#" Value="public abstract void DrawEllipse (System.Windows.Media.Brush brush, System.Windows.Media.Pen pen, System.Windows.Point center, System.Windows.Media.Animation.AnimationClock centerAnimations, double radiusX, System.Windows.Media.Animation.AnimationClock radiusXAnimations, double radiusY, System.Windows.Media.Animation.AnimationClock radiusYAnimations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawEllipse(class System.Windows.Media.Brush brush, class System.Windows.Media.Pen pen, valuetype System.Windows.Point center, class System.Windows.Media.Animation.AnimationClock centerAnimations, float64 radiusX, class System.Windows.Media.Animation.AnimationClock radiusXAnimations, float64 radiusY, class System.Windows.Media.Animation.AnimationClock radiusYAnimations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawEllipse(System.Windows.Media.Brush,System.Windows.Media.Pen,System.Windows.Point,System.Windows.Media.Animation.AnimationClock,System.Double,System.Windows.Media.Animation.AnimationClock,System.Double,System.Windows.Media.Animation.AnimationClock)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub DrawEllipse (brush As Brush, pen As Pen, center As Point, centerAnimations As AnimationClock, radiusX As Double, radiusXAnimations As AnimationClock, radiusY As Double, radiusYAnimations As AnimationClock)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DrawEllipse(System::Windows::Media::Brush ^ brush, System::Windows::Media::Pen ^ pen, System::Windows::Point center, System::Windows::Media::Animation::AnimationClock ^ centerAnimations, double radiusX, System::Windows::Media::Animation::AnimationClock ^ radiusXAnimations, double radiusY, System::Windows::Media::Animation::AnimationClock ^ radiusYAnimations);" />
      <MemberSignature Language="F#" Value="abstract member DrawEllipse : System.Windows.Media.Brush * System.Windows.Media.Pen * System.Windows.Point * System.Windows.Media.Animation.AnimationClock * double * System.Windows.Media.Animation.AnimationClock * double * System.Windows.Media.Animation.AnimationClock -&gt; unit" Usage="drawingContext.DrawEllipse (brush, pen, center, centerAnimations, radiusX, radiusXAnimations, radiusY, radiusYAnimations)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Windows.Media.Brush" />
        <Parameter Name="pen" Type="System.Windows.Media.Pen" />
        <Parameter Name="center" Type="System.Windows.Point" />
        <Parameter Name="centerAnimations" Type="System.Windows.Media.Animation.AnimationClock" />
        <Parameter Name="radiusX" Type="System.Double" />
        <Parameter Name="radiusXAnimations" Type="System.Windows.Media.Animation.AnimationClock" />
        <Parameter Name="radiusY" Type="System.Double" />
        <Parameter Name="radiusYAnimations" Type="System.Windows.Media.Animation.AnimationClock" />
      </Parameters>
      <Docs>
        <param name="brush">Der Pinsel, mit dem die Ellipse ausgefüllt werden soll.  Dies ist optional und kann <see langword="null" /> sein. Wenn der Pinsel <see langword="null" /> ist, wird keine Füllung gezeichnet.</param>
        <param name="pen">Der Stift, mit dem der Strich der Ellipse gezeichnet werden soll.  Dies ist optional und kann <see langword="null" /> sein. Wenn der Stift <see langword="null" /> ist, wird kein Strich gezeichnet.</param>
        <param name="center">Die Position des Mittelpunkts der Ellipse.</param>
        <param name="centerAnimations">Die Uhr, mit dem der Mittelpunkt der Ellipse animiert werden soll, oder <see langword="null" /> für keine Animation. Diese Uhr muss aus einer <see cref="T:System.Windows.Media.Animation.AnimationTimeline" /> erstellt werden, mit der <see cref="T:System.Windows.Point" />-Objekte animiert werden können.</param>
        <param name="radiusX">Der horizontale Radius der Ellipse.</param>
        <param name="radiusXAnimations">Die Uhr zum Animieren des x-Radius der Ellipse oder <see langword="null" /> für keine Animation. Diese Uhr muss aus einer <see cref="T:System.Windows.Media.Animation.AnimationTimeline" /> erstellt werden, mit der <see cref="T:System.Double" />-Objekte animiert werden können.</param>
        <param name="radiusY">Der vertikale Radius der Ellipse.</param>
        <param name="radiusYAnimations">Die Uhr zum Animieren des y-Radius der Ellipse oder <see langword="null" /> für keine Animation. Diese Uhr muss aus einer <see cref="T:System.Windows.Media.Animation.AnimationTimeline" /> erstellt werden, mit der <see cref="T:System.Double" />-Objekte animiert werden können.</param>
        <summary>Zeichnet eine Ellipse mit dem angegebenen <see cref="T:System.Windows.Media.Brush" /> und <see cref="T:System.Windows.Media.Pen" /> und wendet die angegebenen Animationsuhren an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Pinsel und der Stift können beide sein `null` .  Wenn der Pinsel ist `null` , wird keine Füllung ausgeführt.  Wenn der Stift ist `null` , wird kein Stoke-Vorgang ausgeführt.  Wenn der Stift und der Pinsel sind `null` , ist das Zeichnen nicht sichtbar.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawGeometry">
      <MemberSignature Language="C#" Value="public abstract void DrawGeometry (System.Windows.Media.Brush brush, System.Windows.Media.Pen pen, System.Windows.Media.Geometry geometry);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawGeometry(class System.Windows.Media.Brush brush, class System.Windows.Media.Pen pen, class System.Windows.Media.Geometry geometry) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawGeometry(System.Windows.Media.Brush,System.Windows.Media.Pen,System.Windows.Media.Geometry)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub DrawGeometry (brush As Brush, pen As Pen, geometry As Geometry)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DrawGeometry(System::Windows::Media::Brush ^ brush, System::Windows::Media::Pen ^ pen, System::Windows::Media::Geometry ^ geometry);" />
      <MemberSignature Language="F#" Value="abstract member DrawGeometry : System.Windows.Media.Brush * System.Windows.Media.Pen * System.Windows.Media.Geometry -&gt; unit" Usage="drawingContext.DrawGeometry (brush, pen, geometry)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Windows.Media.Brush" />
        <Parameter Name="pen" Type="System.Windows.Media.Pen" />
        <Parameter Name="geometry" Type="System.Windows.Media.Geometry" />
      </Parameters>
      <Docs>
        <param name="brush">Der <see cref="T:System.Windows.Media.Brush" /> zum Ausfüllen der <see cref="T:System.Windows.Media.Geometry" />. Dies ist optional und kann <see langword="null" /> sein. Wenn der Pinsel <see langword="null" /> ist, wird keine Füllung gezeichnet.</param>
        <param name="pen">Der <see cref="T:System.Windows.Media.Pen" />, mit dem die <see cref="T:System.Windows.Media.Geometry" /> gezeichnet werden soll. Dies ist optional und kann <see langword="null" /> sein. Wenn der Stift <see langword="null" /> ist, wird kein Strich gezeichnet.</param>
        <param name="geometry">Das zu zeichnende <see cref="T:System.Windows.Media.Geometry" />.</param>
        <summary>Zeichnet die angegebene <see cref="T:System.Windows.Media.Geometry" /> unter Verwendung der angegebenen <see cref="T:System.Windows.Media.Brush" />- und <see cref="T:System.Windows.Media.Pen" />-Elemente.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawGlyphRun">
      <MemberSignature Language="C#" Value="public abstract void DrawGlyphRun (System.Windows.Media.Brush foregroundBrush, System.Windows.Media.GlyphRun glyphRun);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawGlyphRun(class System.Windows.Media.Brush foregroundBrush, class System.Windows.Media.GlyphRun glyphRun) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawGlyphRun(System.Windows.Media.Brush,System.Windows.Media.GlyphRun)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub DrawGlyphRun (foregroundBrush As Brush, glyphRun As GlyphRun)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DrawGlyphRun(System::Windows::Media::Brush ^ foregroundBrush, System::Windows::Media::GlyphRun ^ glyphRun);" />
      <MemberSignature Language="F#" Value="abstract member DrawGlyphRun : System.Windows.Media.Brush * System.Windows.Media.GlyphRun -&gt; unit" Usage="drawingContext.DrawGlyphRun (foregroundBrush, glyphRun)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="foregroundBrush" Type="System.Windows.Media.Brush" />
        <Parameter Name="glyphRun" Type="System.Windows.Media.GlyphRun" />
      </Parameters>
      <Docs>
        <param name="foregroundBrush">Der Pinsel zum Zeichnen des Texts.</param>
        <param name="glyphRun">Der zu zeichnende Text.</param>
        <summary>Zeichnet den angegebenen Text.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawImage">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zeichnet ein Bild in dem vom angegebenen <see cref="T:System.Windows.Rect" /> definierten Bereich.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public abstract void DrawImage (System.Windows.Media.ImageSource imageSource, System.Windows.Rect rectangle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawImage(class System.Windows.Media.ImageSource imageSource, valuetype System.Windows.Rect rectangle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawImage(System.Windows.Media.ImageSource,System.Windows.Rect)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub DrawImage (imageSource As ImageSource, rectangle As Rect)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DrawImage(System::Windows::Media::ImageSource ^ imageSource, System::Windows::Rect rectangle);" />
      <MemberSignature Language="F#" Value="abstract member DrawImage : System.Windows.Media.ImageSource * System.Windows.Rect -&gt; unit" Usage="drawingContext.DrawImage (imageSource, rectangle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="imageSource" Type="System.Windows.Media.ImageSource" />
        <Parameter Name="rectangle" Type="System.Windows.Rect" />
      </Parameters>
      <Docs>
        <param name="imageSource">Das zu zeichnende Bild.</param>
        <param name="rectangle">Der Bereich, in dem <c>bitmapSource</c> gezeichnet werden soll.</param>
        <summary>Zeichnet ein Bild in dem vom angegebenen <see cref="T:System.Windows.Rect" /> definierten Bereich.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public abstract void DrawImage (System.Windows.Media.ImageSource imageSource, System.Windows.Rect rectangle, System.Windows.Media.Animation.AnimationClock rectangleAnimations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawImage(class System.Windows.Media.ImageSource imageSource, valuetype System.Windows.Rect rectangle, class System.Windows.Media.Animation.AnimationClock rectangleAnimations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawImage(System.Windows.Media.ImageSource,System.Windows.Rect,System.Windows.Media.Animation.AnimationClock)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub DrawImage (imageSource As ImageSource, rectangle As Rect, rectangleAnimations As AnimationClock)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DrawImage(System::Windows::Media::ImageSource ^ imageSource, System::Windows::Rect rectangle, System::Windows::Media::Animation::AnimationClock ^ rectangleAnimations);" />
      <MemberSignature Language="F#" Value="abstract member DrawImage : System.Windows.Media.ImageSource * System.Windows.Rect * System.Windows.Media.Animation.AnimationClock -&gt; unit" Usage="drawingContext.DrawImage (imageSource, rectangle, rectangleAnimations)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="imageSource" Type="System.Windows.Media.ImageSource" />
        <Parameter Name="rectangle" Type="System.Windows.Rect" />
        <Parameter Name="rectangleAnimations" Type="System.Windows.Media.Animation.AnimationClock" />
      </Parameters>
      <Docs>
        <param name="imageSource">Das zu zeichnende Bild.</param>
        <param name="rectangle">Der Bereich, in dem <c>bitmapSource</c> gezeichnet werden soll.</param>
        <param name="rectangleAnimations">Die Uhr, mit der Größe und Abmessungen des Rechtecks animiert werden sollen, oder <see langword="null" /> für keine Animation. Diese Uhr muss aus einer <see cref="T:System.Windows.Media.Animation.AnimationTimeline" /> erstellt werden, mit der <see cref="T:System.Windows.Rect" />-Objekte animiert werden können.</param>
        <summary>Zeichnet ein Bild in dem vom angegebenen <see cref="T:System.Windows.Rect" /> definierten Bereich und wendet die angegebene Animationsuhr an.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawLine">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zeichnet eine Linie mit dem angegebenen <see cref="T:System.Windows.Media.Pen" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawLine">
      <MemberSignature Language="C#" Value="public abstract void DrawLine (System.Windows.Media.Pen pen, System.Windows.Point point0, System.Windows.Point point1);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawLine(class System.Windows.Media.Pen pen, valuetype System.Windows.Point point0, valuetype System.Windows.Point point1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawLine(System.Windows.Media.Pen,System.Windows.Point,System.Windows.Point)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub DrawLine (pen As Pen, point0 As Point, point1 As Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DrawLine(System::Windows::Media::Pen ^ pen, System::Windows::Point point0, System::Windows::Point point1);" />
      <MemberSignature Language="F#" Value="abstract member DrawLine : System.Windows.Media.Pen * System.Windows.Point * System.Windows.Point -&gt; unit" Usage="drawingContext.DrawLine (pen, point0, point1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Windows.Media.Pen" />
        <Parameter Name="point0" Type="System.Windows.Point" />
        <Parameter Name="point1" Type="System.Windows.Point" />
      </Parameters>
      <Docs>
        <param name="pen">Der Stift, mit dem die Linie gezeichnet werden soll.</param>
        <param name="point0">Der Startpunkt der Linie.</param>
        <param name="point1">Der Endpunkt der Linie.</param>
        <summary>Zeichnet mit dem angegebenen <see cref="T:System.Windows.Media.Pen" /> eine Linie zwischen den angegebenen Punkten.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawLine">
      <MemberSignature Language="C#" Value="public abstract void DrawLine (System.Windows.Media.Pen pen, System.Windows.Point point0, System.Windows.Media.Animation.AnimationClock point0Animations, System.Windows.Point point1, System.Windows.Media.Animation.AnimationClock point1Animations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawLine(class System.Windows.Media.Pen pen, valuetype System.Windows.Point point0, class System.Windows.Media.Animation.AnimationClock point0Animations, valuetype System.Windows.Point point1, class System.Windows.Media.Animation.AnimationClock point1Animations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawLine(System.Windows.Media.Pen,System.Windows.Point,System.Windows.Media.Animation.AnimationClock,System.Windows.Point,System.Windows.Media.Animation.AnimationClock)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub DrawLine (pen As Pen, point0 As Point, point0Animations As AnimationClock, point1 As Point, point1Animations As AnimationClock)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DrawLine(System::Windows::Media::Pen ^ pen, System::Windows::Point point0, System::Windows::Media::Animation::AnimationClock ^ point0Animations, System::Windows::Point point1, System::Windows::Media::Animation::AnimationClock ^ point1Animations);" />
      <MemberSignature Language="F#" Value="abstract member DrawLine : System.Windows.Media.Pen * System.Windows.Point * System.Windows.Media.Animation.AnimationClock * System.Windows.Point * System.Windows.Media.Animation.AnimationClock -&gt; unit" Usage="drawingContext.DrawLine (pen, point0, point0Animations, point1, point1Animations)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Windows.Media.Pen" />
        <Parameter Name="point0" Type="System.Windows.Point" />
        <Parameter Name="point0Animations" Type="System.Windows.Media.Animation.AnimationClock" />
        <Parameter Name="point1" Type="System.Windows.Point" />
        <Parameter Name="point1Animations" Type="System.Windows.Media.Animation.AnimationClock" />
      </Parameters>
      <Docs>
        <param name="pen">Der Stift zum Zeichnen der Linie.</param>
        <param name="point0">Der Startpunkt der Linie.</param>
        <param name="point0Animations">Die Uhr, mit der der Anfangspunkt der Linie animiert werden soll, oder <see langword="null" /> für keine Animation. Diese Uhr muss aus einer <see cref="T:System.Windows.Media.Animation.AnimationTimeline" /> erstellt werden, mit der <see cref="T:System.Windows.Point" />-Objekte animiert werden können.</param>
        <param name="point1">Der Endpunkt der Linie.</param>
        <param name="point1Animations">Die Uhr, mit der der Endpunkt der Linie animiert werden soll, oder <see langword="null" /> für keine Animation. Diese Uhr muss aus einer <see cref="T:System.Windows.Media.Animation.AnimationTimeline" /> erstellt werden, mit der <see cref="T:System.Windows.Point" />-Objekte animiert werden können.</param>
        <summary>Zeichnet mit dem angegebenen <see cref="T:System.Windows.Media.Pen" /> eine Linie zwischen den angegebenen Punkten und wendet die angegebenen Animationsuhren an.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawRectangle">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zeichnet ein Rechteck.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawRectangle">
      <MemberSignature Language="C#" Value="public abstract void DrawRectangle (System.Windows.Media.Brush brush, System.Windows.Media.Pen pen, System.Windows.Rect rectangle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawRectangle(class System.Windows.Media.Brush brush, class System.Windows.Media.Pen pen, valuetype System.Windows.Rect rectangle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawRectangle(System.Windows.Media.Brush,System.Windows.Media.Pen,System.Windows.Rect)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub DrawRectangle (brush As Brush, pen As Pen, rectangle As Rect)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DrawRectangle(System::Windows::Media::Brush ^ brush, System::Windows::Media::Pen ^ pen, System::Windows::Rect rectangle);" />
      <MemberSignature Language="F#" Value="abstract member DrawRectangle : System.Windows.Media.Brush * System.Windows.Media.Pen * System.Windows.Rect -&gt; unit" Usage="drawingContext.DrawRectangle (brush, pen, rectangle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Windows.Media.Brush" />
        <Parameter Name="pen" Type="System.Windows.Media.Pen" />
        <Parameter Name="rectangle" Type="System.Windows.Rect" />
      </Parameters>
      <Docs>
        <param name="brush">Der Pinsel, mit dem das Rechteck ausgefüllt werden soll.  Dies ist optional und kann <see langword="null" /> sein. Wenn der Pinsel <see langword="null" /> ist, wird keine Füllung gezeichnet.</param>
        <param name="pen">Der Stift, mit dem der Strich des Rechtecks gezeichnet werden soll.  Dies ist optional und kann <see langword="null" /> sein. Wenn der Stift <see langword="null" /> ist, wird kein Strich gezeichnet.</param>
        <param name="rectangle">Das zu zeichnende Rechteck.</param>
        <summary>Zeichnet ein Rechteck mit dem angegebenen <see cref="T:System.Windows.Media.Brush" /> und <see cref="T:System.Windows.Media.Pen" />. Der Stift und der Pinsel können <see langword="null" /> sein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Pinsel und der Stift können beide sein `null` .  Wenn der Pinsel ist `null` , wird keine Füllung ausgeführt.  Wenn der Stift ist `null` , wird kein Strich ausgeführt.  Wenn der Stift und der Pinsel sind `null` , ist das Zeichnen nicht sichtbar.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawRectangle">
      <MemberSignature Language="C#" Value="public abstract void DrawRectangle (System.Windows.Media.Brush brush, System.Windows.Media.Pen pen, System.Windows.Rect rectangle, System.Windows.Media.Animation.AnimationClock rectangleAnimations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawRectangle(class System.Windows.Media.Brush brush, class System.Windows.Media.Pen pen, valuetype System.Windows.Rect rectangle, class System.Windows.Media.Animation.AnimationClock rectangleAnimations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawRectangle(System.Windows.Media.Brush,System.Windows.Media.Pen,System.Windows.Rect,System.Windows.Media.Animation.AnimationClock)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub DrawRectangle (brush As Brush, pen As Pen, rectangle As Rect, rectangleAnimations As AnimationClock)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DrawRectangle(System::Windows::Media::Brush ^ brush, System::Windows::Media::Pen ^ pen, System::Windows::Rect rectangle, System::Windows::Media::Animation::AnimationClock ^ rectangleAnimations);" />
      <MemberSignature Language="F#" Value="abstract member DrawRectangle : System.Windows.Media.Brush * System.Windows.Media.Pen * System.Windows.Rect * System.Windows.Media.Animation.AnimationClock -&gt; unit" Usage="drawingContext.DrawRectangle (brush, pen, rectangle, rectangleAnimations)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Windows.Media.Brush" />
        <Parameter Name="pen" Type="System.Windows.Media.Pen" />
        <Parameter Name="rectangle" Type="System.Windows.Rect" />
        <Parameter Name="rectangleAnimations" Type="System.Windows.Media.Animation.AnimationClock" />
      </Parameters>
      <Docs>
        <param name="brush">Der Pinsel, mit dem das Rechteck ausgefüllt werden soll.  Dies ist optional und kann <see langword="null" /> sein. Wenn der Pinsel <see langword="null" /> ist, wird keine Füllung gezeichnet.</param>
        <param name="pen">Der Stift, mit dem der Strich des Rechtecks gezeichnet werden soll.  Dies ist optional und kann <see langword="null" /> sein. Wenn der Stift <see langword="null" /> ist, wird kein Strich gezeichnet.</param>
        <param name="rectangle">Das zu zeichnende Rechteck.</param>
        <param name="rectangleAnimations">Die Uhr, mit der Größe und Abmessungen des Rechtecks animiert werden sollen, oder <see langword="null" /> für keine Animation. Diese Uhr muss aus einer <see cref="T:System.Windows.Media.Animation.AnimationTimeline" /> erstellt werden, mit der <see cref="T:System.Windows.Rect" />-Objekte animiert werden können.</param>
        <summary>Zeichnet ein Rechteck mit dem angegebenen <see cref="T:System.Windows.Media.Brush" /> und <see cref="T:System.Windows.Media.Pen" /> und wendet die angegebenen Animationsuhren an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Pinsel und der Stift können beide sein `null` .  Wenn der Pinsel ist `null` , wird keine Füllung ausgeführt.  Wenn der Stift ist `null` , wird kein Stoke-Vorgang ausgeführt.  Wenn der Stift und der Pinsel sind `null` , ist das Zeichnen nicht sichtbar.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawRoundedRectangle">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zeichnet ein abgerundetes Rechteck.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawRoundedRectangle">
      <MemberSignature Language="C#" Value="public abstract void DrawRoundedRectangle (System.Windows.Media.Brush brush, System.Windows.Media.Pen pen, System.Windows.Rect rectangle, double radiusX, double radiusY);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawRoundedRectangle(class System.Windows.Media.Brush brush, class System.Windows.Media.Pen pen, valuetype System.Windows.Rect rectangle, float64 radiusX, float64 radiusY) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawRoundedRectangle(System.Windows.Media.Brush,System.Windows.Media.Pen,System.Windows.Rect,System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub DrawRoundedRectangle (brush As Brush, pen As Pen, rectangle As Rect, radiusX As Double, radiusY As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DrawRoundedRectangle(System::Windows::Media::Brush ^ brush, System::Windows::Media::Pen ^ pen, System::Windows::Rect rectangle, double radiusX, double radiusY);" />
      <MemberSignature Language="F#" Value="abstract member DrawRoundedRectangle : System.Windows.Media.Brush * System.Windows.Media.Pen * System.Windows.Rect * double * double -&gt; unit" Usage="drawingContext.DrawRoundedRectangle (brush, pen, rectangle, radiusX, radiusY)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Windows.Media.Brush" />
        <Parameter Name="pen" Type="System.Windows.Media.Pen" />
        <Parameter Name="rectangle" Type="System.Windows.Rect" />
        <Parameter Name="radiusX" Type="System.Double" />
        <Parameter Name="radiusY" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="brush">Der zum Ausfüllen des Rechtecks verwendete Pinsel.</param>
        <param name="pen">Der zum Zeichnen des Strichs für das Rechteck verwendete Stift.</param>
        <param name="rectangle">Das zu zeichnende Rechteck.</param>
        <param name="radiusX">Der Radius in der x-Dimension der abgerundeten Ecken.  Dieser Wert wird an den Bereich von 0 bis <see cref="P:System.Windows.Rect.Width" />/2 geklammert.</param>
        <param name="radiusY">Der Radius in der y-Dimension der abgerundeten Ecken.  Dieser Wert wird an einen Wert zwischen 0 und <see cref="P:System.Windows.Rect.Height" />/2 geklammert.</param>
        <summary>Zeichnet ein abgerundetes Rechteck mit dem angegebenen <see cref="T:System.Windows.Media.Brush" /> und <see cref="T:System.Windows.Media.Pen" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Pinsel und der Stift können beide sein `null` .  Wenn der Pinsel ist `null` , wird keine Füllung ausgeführt.  Wenn der Stift ist `null` , wird kein Stoke-Vorgang ausgeführt.  Wenn der Stift und der Pinsel sind `null` , ist das Zeichnen nicht sichtbar.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawRoundedRectangle">
      <MemberSignature Language="C#" Value="public abstract void DrawRoundedRectangle (System.Windows.Media.Brush brush, System.Windows.Media.Pen pen, System.Windows.Rect rectangle, System.Windows.Media.Animation.AnimationClock rectangleAnimations, double radiusX, System.Windows.Media.Animation.AnimationClock radiusXAnimations, double radiusY, System.Windows.Media.Animation.AnimationClock radiusYAnimations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawRoundedRectangle(class System.Windows.Media.Brush brush, class System.Windows.Media.Pen pen, valuetype System.Windows.Rect rectangle, class System.Windows.Media.Animation.AnimationClock rectangleAnimations, float64 radiusX, class System.Windows.Media.Animation.AnimationClock radiusXAnimations, float64 radiusY, class System.Windows.Media.Animation.AnimationClock radiusYAnimations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawRoundedRectangle(System.Windows.Media.Brush,System.Windows.Media.Pen,System.Windows.Rect,System.Windows.Media.Animation.AnimationClock,System.Double,System.Windows.Media.Animation.AnimationClock,System.Double,System.Windows.Media.Animation.AnimationClock)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub DrawRoundedRectangle (brush As Brush, pen As Pen, rectangle As Rect, rectangleAnimations As AnimationClock, radiusX As Double, radiusXAnimations As AnimationClock, radiusY As Double, radiusYAnimations As AnimationClock)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DrawRoundedRectangle(System::Windows::Media::Brush ^ brush, System::Windows::Media::Pen ^ pen, System::Windows::Rect rectangle, System::Windows::Media::Animation::AnimationClock ^ rectangleAnimations, double radiusX, System::Windows::Media::Animation::AnimationClock ^ radiusXAnimations, double radiusY, System::Windows::Media::Animation::AnimationClock ^ radiusYAnimations);" />
      <MemberSignature Language="F#" Value="abstract member DrawRoundedRectangle : System.Windows.Media.Brush * System.Windows.Media.Pen * System.Windows.Rect * System.Windows.Media.Animation.AnimationClock * double * System.Windows.Media.Animation.AnimationClock * double * System.Windows.Media.Animation.AnimationClock -&gt; unit" Usage="drawingContext.DrawRoundedRectangle (brush, pen, rectangle, rectangleAnimations, radiusX, radiusXAnimations, radiusY, radiusYAnimations)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Windows.Media.Brush" />
        <Parameter Name="pen" Type="System.Windows.Media.Pen" />
        <Parameter Name="rectangle" Type="System.Windows.Rect" />
        <Parameter Name="rectangleAnimations" Type="System.Windows.Media.Animation.AnimationClock" />
        <Parameter Name="radiusX" Type="System.Double" />
        <Parameter Name="radiusXAnimations" Type="System.Windows.Media.Animation.AnimationClock" />
        <Parameter Name="radiusY" Type="System.Double" />
        <Parameter Name="radiusYAnimations" Type="System.Windows.Media.Animation.AnimationClock" />
      </Parameters>
      <Docs>
        <param name="brush">Der zum Ausfüllen des Rechtecks verwendete Pinsel oder <see langword="null" /> für keine Füllung.</param>
        <param name="pen">Der zum Zeichnen des Strichs für das Rechteck verwendete Stift, oder <see langword="null" /> für keinen Strich.</param>
        <param name="rectangle">Das zu zeichnende Rechteck.</param>
        <param name="rectangleAnimations">Die Uhr, mit der Größe und Abmessungen des Rechtecks animiert werden sollen, oder <see langword="null" /> für keine Animation. Diese Uhr muss aus einer <see cref="T:System.Windows.Media.Animation.AnimationTimeline" /> erstellt werden, mit der <see cref="T:System.Windows.Rect" />-Objekte animiert werden können.</param>
        <param name="radiusX">Der Radius in der x-Dimension der abgerundeten Ecken.  Dieser Wert wird an den Bereich von 0 bis <see cref="P:System.Windows.Rect.Width" />/2 geklammert.</param>
        <param name="radiusXAnimations">Die Uhr, mit der der <paramref name="radiusX" />-Wert des Rechtecks animiert werden soll, oder <see langword="null" /> für keine Animation. Diese Uhr muss aus einer <see cref="T:System.Windows.Media.Animation.AnimationTimeline" /> erstellt werden, mit der <see cref="T:System.Double" />-Werte animiert werden können.</param>
        <param name="radiusY">Der Radius in der y-Dimension der abgerundeten Ecken.  Dieser Wert wird an einen Wert zwischen 0 und <see cref="P:System.Windows.Rect.Height" />/2 geklammert.</param>
        <param name="radiusYAnimations">Die Uhr, mit der der <paramref name="radiusY" />-Wert des Rechtecks animiert werden soll, oder <see langword="null" /> für keine Animation. Diese Uhr muss aus einer <see cref="T:System.Windows.Media.Animation.AnimationTimeline" /> erstellt werden, mit der <see cref="T:System.Double" />-Werte animiert werden können.</param>
        <summary>Zeichnet ein abgerundetes Rechteck mit dem angegebenen <see cref="T:System.Windows.Media.Brush" /> und <see cref="T:System.Windows.Media.Pen" /> und wendet die angegebenen Animationsuhren an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Pinsel und der Stift können beide sein `null` .  Wenn der Pinsel ist `null` , wird keine Füllung ausgeführt.  Wenn der Stift ist `null` , wird kein Stoke-Vorgang ausgeführt.  Wenn der Stift und der Pinsel sind `null` , ist das Zeichnen nicht sichtbar.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawText">
      <MemberSignature Language="C#" Value="public void DrawText (System.Windows.Media.FormattedText formattedText, System.Windows.Point origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawText(class System.Windows.Media.FormattedText formattedText, valuetype System.Windows.Point origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawText(System.Windows.Media.FormattedText,System.Windows.Point)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DrawText (formattedText As FormattedText, origin As Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawText(System::Windows::Media::FormattedText ^ formattedText, System::Windows::Point origin);" />
      <MemberSignature Language="F#" Value="member this.DrawText : System.Windows.Media.FormattedText * System.Windows.Point -&gt; unit" Usage="drawingContext.DrawText (formattedText, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="formattedText" Type="System.Windows.Media.FormattedText" />
        <Parameter Name="origin" Type="System.Windows.Point" />
      </Parameters>
      <Docs>
        <param name="formattedText">Der zu zeichnende formatierte Text.</param>
        <param name="origin">Die Position, an der der Text gezeichnet werden soll.</param>
        <summary>Zeichnet formatierten Text an der angegebenen Position.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Das Objekt wurde bereits geschlossen oder verworfen.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawVideo">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zeichnet ein Video im angegebenen Bereich.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawVideo">
      <MemberSignature Language="C#" Value="public abstract void DrawVideo (System.Windows.Media.MediaPlayer player, System.Windows.Rect rectangle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawVideo(class System.Windows.Media.MediaPlayer player, valuetype System.Windows.Rect rectangle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawVideo(System.Windows.Media.MediaPlayer,System.Windows.Rect)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub DrawVideo (player As MediaPlayer, rectangle As Rect)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DrawVideo(System::Windows::Media::MediaPlayer ^ player, System::Windows::Rect rectangle);" />
      <MemberSignature Language="F#" Value="abstract member DrawVideo : System.Windows.Media.MediaPlayer * System.Windows.Rect -&gt; unit" Usage="drawingContext.DrawVideo (player, rectangle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="player" Type="System.Windows.Media.MediaPlayer" />
        <Parameter Name="rectangle" Type="System.Windows.Rect" />
      </Parameters>
      <Docs>
        <param name="player">Das zu zeichnende Medium.</param>
        <param name="rectangle">Der Bereich, in dem <paramref name="player" /> gezeichnet werden soll.</param>
        <summary>Zeichnet ein Video im angegebenen Bereich.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beachten Sie, dass die Medien gestreckt werden, um in den Bereich zu passen, der durch den Rechteck Parameter definiert wird. Wenn Rechteck und Medien verschiedene Seitenverhältnisse aufweisen, wird eine Verzerrung auftreten. Um mehr Kontrolle darüber zu erhalten, wie Medien zum Ausfüllen eines Bereichs verwendet werden, verwenden <xref:System.Windows.Media.DrawingContext.DrawRectangle%2A> Sie den-Befehl, um ein Rechteck zu zeichnen und es mit einem zu füllen <xref:System.Windows.Media.VisualBrush> , das Medien enthält.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawVideo">
      <MemberSignature Language="C#" Value="public abstract void DrawVideo (System.Windows.Media.MediaPlayer player, System.Windows.Rect rectangle, System.Windows.Media.Animation.AnimationClock rectangleAnimations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawVideo(class System.Windows.Media.MediaPlayer player, valuetype System.Windows.Rect rectangle, class System.Windows.Media.Animation.AnimationClock rectangleAnimations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawVideo(System.Windows.Media.MediaPlayer,System.Windows.Rect,System.Windows.Media.Animation.AnimationClock)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub DrawVideo (player As MediaPlayer, rectangle As Rect, rectangleAnimations As AnimationClock)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DrawVideo(System::Windows::Media::MediaPlayer ^ player, System::Windows::Rect rectangle, System::Windows::Media::Animation::AnimationClock ^ rectangleAnimations);" />
      <MemberSignature Language="F#" Value="abstract member DrawVideo : System.Windows.Media.MediaPlayer * System.Windows.Rect * System.Windows.Media.Animation.AnimationClock -&gt; unit" Usage="drawingContext.DrawVideo (player, rectangle, rectangleAnimations)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="player" Type="System.Windows.Media.MediaPlayer" />
        <Parameter Name="rectangle" Type="System.Windows.Rect" />
        <Parameter Name="rectangleAnimations" Type="System.Windows.Media.Animation.AnimationClock" />
      </Parameters>
      <Docs>
        <param name="player">Das zu zeichnende Medium.</param>
        <param name="rectangle">Der Bereich, in dem das Medium gezeichnet werden soll.</param>
        <param name="rectangleAnimations">Die Uhr, mit der Größe und Abmessungen des Rechtecks animiert werden sollen, oder <see langword="null" /> für keine Animation. Diese Uhr muss aus einer <see cref="T:System.Windows.Media.Animation.AnimationTimeline" /> erstellt werden, mit der <see cref="T:System.Windows.Rect" />-Objekte animiert werden können.</param>
        <summary>Zeichnet ein Video im angegebenen Bereich und wendet die angegebene Animationsuhr an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beachten Sie, dass die Medien gestreckt werden, um in den Bereich zu passen, der durch den Rechteck Parameter definiert wird. Wenn Rechteck und Medien verschiedene Seitenverhältnisse aufweisen, wird eine Verzerrung auftreten. Um mehr Kontrolle darüber zu erhalten, wie Medien zum Ausfüllen eines Bereichs verwendet werden, verwenden <xref:System.Windows.Media.DrawingContext.DrawRectangle%2A> Sie den-Befehl, um ein Rechteck zu zeichnen und es mit einem zu füllen <xref:System.Windows.Media.VisualBrush> , das Medien enthält.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Pop">
      <MemberSignature Language="C#" Value="public abstract void Pop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Pop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.Pop" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub Pop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void Pop();" />
      <MemberSignature Language="F#" Value="abstract member Pop : unit -&gt; unit" Usage="drawingContext.Pop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Holt den letzten Vorgang für Durchlässigkeitsmaske, Durchlässigkeit, Clip, Effekt oder Transformation, der im Zeichnungskontext abgelegt wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nachdem ein Vorgang per Pop-Vorgang beendet wurde, wird er nicht mehr auf nachfolgende Zeichnungs Befehle angewendet.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die Auswirkung des- <xref:System.Windows.Media.DrawingContext.Pop%2A> Befehls.  
  
 [!code-csharp[DrawingContext_procedural_snip#PopExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/DrawingContext_procedural_snip/CSharp/PopExample.cs#popexamplewholepage)]
 [!code-vb[DrawingContext_procedural_snip#PopExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DrawingContext_procedural_snip/visualbasic/popexample.vb#popexamplewholepage)]  
  
 Die folgende Abbildung zeigt die Ausgabe dieses Beispiels:  
  
 ![Mit unterschiedlichen Deckkraftwerten gezeichnete Rechtecke](~/add/media/graphicsmm-drawingcontextpopexample.gif "Mit unterschiedlichen Deckkraftwerten gezeichnete Rechtecke")  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PushClip">
      <MemberSignature Language="C#" Value="public abstract void PushClip (System.Windows.Media.Geometry clipGeometry);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PushClip(class System.Windows.Media.Geometry clipGeometry) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.PushClip(System.Windows.Media.Geometry)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub PushClip (clipGeometry As Geometry)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void PushClip(System::Windows::Media::Geometry ^ clipGeometry);" />
      <MemberSignature Language="F#" Value="abstract member PushClip : System.Windows.Media.Geometry -&gt; unit" Usage="drawingContext.PushClip clipGeometry" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clipGeometry" Type="System.Windows.Media.Geometry" />
      </Parameters>
      <Docs>
        <param name="clipGeometry">Der Ausschneidebereich, der auf nachfolgende Zeichnungsbefehle angewendet werden soll.</param>
        <summary>Legt den angegebenen Ausschneidebereich im Zeichnungskontext ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Clip-Bereich gilt für alle nachfolgenden Zeichnungs Befehle, bis er durch den Befehl entfernt wird <xref:System.Windows.Media.DrawingContext.Pop%2A> .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PushEffect">
      <MemberSignature Language="C#" Value="public abstract void PushEffect (System.Windows.Media.Effects.BitmapEffect effect, System.Windows.Media.Effects.BitmapEffectInput effectInput);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PushEffect(class System.Windows.Media.Effects.BitmapEffect effect, class System.Windows.Media.Effects.BitmapEffectInput effectInput) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.PushEffect(System.Windows.Media.Effects.BitmapEffect,System.Windows.Media.Effects.BitmapEffectInput)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub PushEffect (effect As BitmapEffect, effectInput As BitmapEffectInput)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void PushEffect(System::Windows::Media::Effects::BitmapEffect ^ effect, System::Windows::Media::Effects::BitmapEffectInput ^ effectInput);" />
      <MemberSignature Language="F#" Value="abstract member PushEffect : System.Windows.Media.Effects.BitmapEffect * System.Windows.Media.Effects.BitmapEffectInput -&gt; unit" Usage="drawingContext.PushEffect (effect, effectInput)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Obsolete("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="effect" Type="System.Windows.Media.Effects.BitmapEffect" />
        <Parameter Name="effectInput" Type="System.Windows.Media.Effects.BitmapEffectInput" />
      </Parameters>
      <Docs>
        <param name="effect">Der Effekt, der auf nachfolgende Zeichnungen angewendet werden soll.</param>
        <param name="effectInput">Der Bereich, auf den der Effekt angewendet wird, oder <see langword="null" />, wenn der Effekt auf den gesamten Bereich nachfolgender Zeichnungen angewendet werden soll.</param>
        <summary>Legt den angegebenen <see cref="T:System.Windows.Media.Effects.BitmapEffect" /> im Zeichnungskontext ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Effekt wird auf alle nachfolgenden Zeichnungsvorgänge angewendet, bis er durch den <xref:System.Windows.Media.DrawingContext.Pop%2A> Befehl entfernt wird.  
  
   
  
## Examples  
 Im folgenden Beispiel werden die <xref:System.Windows.Media.DrawingContext.PushOpacity%2A> <xref:System.Windows.Media.DrawingContext.PushEffect%2A> Befehle, und veranschaulicht <xref:System.Windows.Media.DrawingContext.Pop%2A> .  
  
 [!code-csharp[DrawingContext_procedural_snip#PushEffectExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/DrawingContext_procedural_snip/CSharp/PushEffectExample.cs#pusheffectexamplewholepage)]
 [!code-vb[DrawingContext_procedural_snip#PushEffectExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DrawingContext_procedural_snip/visualbasic/pusheffectexample.vb#pusheffectexamplewholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PushGuidelineSet">
      <MemberSignature Language="C#" Value="public abstract void PushGuidelineSet (System.Windows.Media.GuidelineSet guidelines);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PushGuidelineSet(class System.Windows.Media.GuidelineSet guidelines) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.PushGuidelineSet(System.Windows.Media.GuidelineSet)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub PushGuidelineSet (guidelines As GuidelineSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void PushGuidelineSet(System::Windows::Media::GuidelineSet ^ guidelines);" />
      <MemberSignature Language="F#" Value="abstract member PushGuidelineSet : System.Windows.Media.GuidelineSet -&gt; unit" Usage="drawingContext.PushGuidelineSet guidelines" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guidelines" Type="System.Windows.Media.GuidelineSet" />
      </Parameters>
      <Docs>
        <param name="guidelines">Der auf nachfolgende Zeichnungen anzuwendende Satz von Richtlinien.</param>
        <summary>Legt den angegebenen <see cref="T:System.Windows.Media.GuidelineSet" /> im Zeichnungskontext ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die festgelegte Richtlinie gilt für alle nachfolgenden Zeichnungs Befehle, bis Sie durch den Vorgang entfernt wird <xref:System.Windows.Media.DrawingContext.Pop%2A> .  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Media.GuidelineSet" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PushOpacity">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Legt die angegebene Durchlässigkeitseinstellung im Zeichnungskontext ab.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PushOpacity">
      <MemberSignature Language="C#" Value="public abstract void PushOpacity (double opacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PushOpacity(float64 opacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.PushOpacity(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub PushOpacity (opacity As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void PushOpacity(double opacity);" />
      <MemberSignature Language="F#" Value="abstract member PushOpacity : double -&gt; unit" Usage="drawingContext.PushOpacity opacity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opacity" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="opacity">Der Durchlässigkeitsfaktor, der auf nachfolgende Zeichnungsbefehle angewendet werden soll. Dieser Faktor wird durch vorherige <see cref="M:System.Windows.Media.DrawingContext.PushOpacity(System.Double)" />-Operationen erhöht.</param>
        <summary>Legt die angegebene Durchlässigkeitseinstellung im Zeichnungskontext ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Deckkraft wird in alle nachfolgenden Zeichnungs Befehle gemischt, bis Sie durch den <xref:System.Windows.Media.DrawingContext.Pop%2A> Befehl entfernt wird.  
  
   
  
## Examples  
 Im folgenden Beispiel werden die <xref:System.Windows.Media.DrawingContext.PushOpacity%2A> <xref:System.Windows.Media.DrawingContext.PushEffect%2A> Befehle, und veranschaulicht <xref:System.Windows.Media.DrawingContext.Pop%2A> .  
  
 [!code-csharp[DrawingContext_procedural_snip#PushEffectExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/DrawingContext_procedural_snip/CSharp/PushEffectExample.cs#pusheffectexamplewholepage)]
 [!code-vb[DrawingContext_procedural_snip#PushEffectExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DrawingContext_procedural_snip/visualbasic/pusheffectexample.vb#pusheffectexamplewholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PushOpacity">
      <MemberSignature Language="C#" Value="public abstract void PushOpacity (double opacity, System.Windows.Media.Animation.AnimationClock opacityAnimations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PushOpacity(float64 opacity, class System.Windows.Media.Animation.AnimationClock opacityAnimations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.PushOpacity(System.Double,System.Windows.Media.Animation.AnimationClock)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub PushOpacity (opacity As Double, opacityAnimations As AnimationClock)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void PushOpacity(double opacity, System::Windows::Media::Animation::AnimationClock ^ opacityAnimations);" />
      <MemberSignature Language="F#" Value="abstract member PushOpacity : double * System.Windows.Media.Animation.AnimationClock -&gt; unit" Usage="drawingContext.PushOpacity (opacity, opacityAnimations)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opacity" Type="System.Double" />
        <Parameter Name="opacityAnimations" Type="System.Windows.Media.Animation.AnimationClock" />
      </Parameters>
      <Docs>
        <param name="opacity">Der Durchlässigkeitsfaktor, der auf nachfolgende Zeichnungsbefehle angewendet werden soll. Dieser Faktor wird durch vorherige <see cref="M:System.Windows.Media.DrawingContext.PushOpacity(System.Double)" />-Operationen erhöht.</param>
        <param name="opacityAnimations">Die Uhr, mit der der Durchlässigkeitswert animiert werden soll, oder <see langword="null" /> für keine Animation. Diese Uhr muss aus einer <see cref="T:System.Windows.Media.Animation.AnimationTimeline" /> erstellt werden, mit der <see cref="T:System.Double" />-Werte animiert werden können.</param>
        <summary>Legt die angegebene Durchlässigkeitseinstellung im Zeichnungskontext ab und wendet die angegebene Animationsuhr an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Deckkraft wird in alle nachfolgenden Zeichnungs Befehle gemischt, bis Sie durch den <xref:System.Windows.Media.DrawingContext.Pop%2A> Befehl entfernt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PushOpacityMask">
      <MemberSignature Language="C#" Value="public abstract void PushOpacityMask (System.Windows.Media.Brush opacityMask);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PushOpacityMask(class System.Windows.Media.Brush opacityMask) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.PushOpacityMask(System.Windows.Media.Brush)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub PushOpacityMask (opacityMask As Brush)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void PushOpacityMask(System::Windows::Media::Brush ^ opacityMask);" />
      <MemberSignature Language="F#" Value="abstract member PushOpacityMask : System.Windows.Media.Brush -&gt; unit" Usage="drawingContext.PushOpacityMask opacityMask" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opacityMask" Type="System.Windows.Media.Brush" />
      </Parameters>
      <Docs>
        <param name="opacityMask">Die Durchlässigkeitsmaske, die auf nachfolgende Zeichnungen angewendet werden soll. Die Alphawerte dieses Pinsels bestimmen die Durchlässigkeit der Zeichnung, auf die er angewendet wird.</param>
        <summary>Legt die angegebene Durchlässigkeitsmaske im Zeichnungskontext ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Maske wird auf alle nachfolgenden Zeichnungs Befehle angewendet, bis Sie durch den <xref:System.Windows.Media.DrawingContext.Pop%2A> Vorgang entfernt wird.  
  
 Weitere Informationen zum Erstellen von Deck Kraft Masken finden Sie unter Übersicht über die Deck [Kraft Masken](/dotnet/framework/wpf/graphics-multimedia/opacity-masks-overview).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PushTransform">
      <MemberSignature Language="C#" Value="public abstract void PushTransform (System.Windows.Media.Transform transform);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PushTransform(class System.Windows.Media.Transform transform) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.PushTransform(System.Windows.Media.Transform)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub PushTransform (transform As Transform)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void PushTransform(System::Windows::Media::Transform ^ transform);" />
      <MemberSignature Language="F#" Value="abstract member PushTransform : System.Windows.Media.Transform -&gt; unit" Usage="drawingContext.PushTransform transform" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transform" Type="System.Windows.Media.Transform" />
      </Parameters>
      <Docs>
        <param name="transform">Die Transformation, die auf nachfolgende Zeichnungsbefehle angewendet werden soll.</param>
        <summary>Legt den angegebenen <see cref="T:System.Windows.Media.Transform" /> im Zeichnungskontext ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Transformation gilt für alle nachfolgenden Zeichnungs Befehle, bis Sie durch den <xref:System.Windows.Media.DrawingContext.Pop%2A> Befehl entfernt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberSignature Language="F#" Value="abstract member System.IDisposable.Dispose : unit -&gt; unit&#xA;override this.System.IDisposable.Dispose : unit -&gt; unit" Usage="drawingContext.System.IDisposable.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Dieser Member unterstützt die [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]-Infrastruktur und ist nicht für die direkte Verwendung im Code vorgesehen.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VerifyApiNonstructuralChange">
      <MemberSignature Language="C#" Value="protected virtual void VerifyApiNonstructuralChange ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void VerifyApiNonstructuralChange() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.VerifyApiNonstructuralChange" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub VerifyApiNonstructuralChange ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void VerifyApiNonstructuralChange();" />
      <MemberSignature Language="F#" Value="abstract member VerifyApiNonstructuralChange : unit -&gt; unit&#xA;override this.VerifyApiNonstructuralChange : unit -&gt; unit" Usage="drawingContext.VerifyApiNonstructuralChange " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Dieser Member unterstützt die [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]-Infrastruktur und ist nicht für die direkte Verwendung im Code vorgesehen.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
