<Type Name="VisualBrush" FullName="System.Windows.Media.VisualBrush">
  <Metadata><Meta Name="ms.openlocfilehash" Value="891092ff72cc164f79e0d1aa744be8d11bacb931" /><Meta Name="ms.sourcegitcommit" Value="9506e50ec7beb4fa30206b9840dc546b035a6600" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="07/23/2020" /><Meta Name="ms.locfileid" Value="86988129" /></Metadata><TypeSignature Language="C#" Value="public sealed class VisualBrush : System.Windows.Media.TileBrush" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit VisualBrush extends System.Windows.Media.TileBrush" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Media.VisualBrush" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class VisualBrush&#xA;Inherits TileBrush" />
  <TypeSignature Language="C++ CLI" Value="public ref class VisualBrush sealed : System::Windows::Media::TileBrush" />
  <TypeSignature Language="F#" Value="type VisualBrush = class&#xA;    inherit TileBrush" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed VisualBrush extends System.Windows.Media.TileBrush" FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Media.TileBrush</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Zeichnet einen Bereich mit einem <see cref="P:System.Windows.Media.VisualBrush.Visual" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es gibt zwei Möglichkeiten, den <xref:System.Windows.Media.VisualBrush.Visual%2A> Inhalt einer anzugeben <xref:System.Windows.Media.VisualBrush> .  
  
-   Erstellen Sie einen neuen <xref:System.Windows.Media.Visual> , und verwenden Sie ihn zum Festlegen der- <xref:System.Windows.Media.VisualBrush.Visual%2A> Eigenschaft von <xref:System.Windows.Media.VisualBrush> .  
  
-   Verwenden Sie ein vorhandenes <xref:System.Windows.Media.Visual> , das ein doppeltes Bild des Ziels erstellt <xref:System.Windows.Media.Visual> . Anschließend können Sie mit dem <xref:System.Windows.Media.VisualBrush> interessante Effekte erstellen, z. b. Reflektion und Vergrößerung.  
  
 Wenn Sie einen neuen <xref:System.Windows.Media.VisualBrush.Visual%2A> für einen definieren, <xref:System.Windows.Media.VisualBrush> <xref:System.Windows.Media.Visual> der ein ist (z. b. <xref:System.Windows.UIElement> ein Panel oder Steuerelement), wird das Layoutsystem auf dem <xref:System.Windows.UIElement> und seinen untergeordneten Elementen ausgeführt, wenn die- <xref:System.Windows.Media.VisualBrush.AutoLayoutContent%2A> Eigenschaft auf festgelegt ist `true` . Der Stamm ist aber <xref:System.Windows.UIElement> im Wesentlichen vom Rest des Systems isoliert. Stile, Storyboards und externes Layout können diese Grenze nicht durchdringen. Daher sollten Sie die Größe des Stamms explizit angeben <xref:System.Windows.UIElement> , da das einzige übergeordnete Element das <xref:System.Windows.Media.VisualBrush> -Element ist und sich daher nicht automatisch für den Bereich eignet, der gezeichnet wird. Weitere Informationen zum Layout in [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] finden Sie unter [Layout](/dotnet/framework/wpf/advanced/layout).  
  
 Aktualisierungen an der visuellen Struktur eines <xref:System.Windows.Media.VisualBrush> werden nicht weitergegeben, wenn ein <xref:System.Windows.Media.Effects.BitmapEffect> in der übergeordneten Kette des Pinsels ist. Sie können diese Einschränkung umgehen, indem Sie ein Update der Szene für das Objekt über der Auswirkung erzwingen. Sie können <xref:System.Windows.UIElement.InvalidateVisual%2A> eine Animation zum Erzwingen eines Szenen Updates abrufen oder einschließen.  
  
 Frei wählbare **Features:** Da es von der-Klasse erbt <xref:System.Windows.Freezable> , <xref:System.Windows.Media.VisualBrush> stellt die-Klasse mehrere besondere Features bereit: <xref:System.Windows.Media.VisualBrush> -Objekte können als deklariert und für mehrere-Objekte freigegeben werden. Weitere Informationen zu den verschiedenen Funktionen, die von-Objekten bereitgestellt werden <xref:System.Windows.Freezable> , finden Sie unter [Übersicht über](/dotnet/framework/wpf/advanced/freezable-objects-overview)frei wählbare Objekte.  
  
> [!NOTE]
>  Ein <xref:System.Windows.Media.VisualBrush> kann nicht als schreibgeschützt festgelegt werden (eingefroren), wenn seine- <xref:System.Windows.Media.VisualBrush.Visual%2A> Eigenschaft auf einen anderen Wert als festgelegt ist. `null.`  
  
 ]]></format>
    </remarks>
    <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=160049">VisualBrush-Beispiel</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Media.VisualBrush" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public VisualBrush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.VisualBrush.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; VisualBrush();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Media.VisualBrush" />-Klasse.</summary>
        <remarks>To be added.</remarks>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=160049">VisualBrush-Beispiel</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public VisualBrush (System.Windows.Media.Visual visual);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.Media.Visual visual) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.VisualBrush.#ctor(System.Windows.Media.Visual)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (visual As Visual)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; VisualBrush(System::Windows::Media::Visual ^ visual);" />
      <MemberSignature Language="F#" Value="new System.Windows.Media.VisualBrush : System.Windows.Media.Visual -&gt; System.Windows.Media.VisualBrush" Usage="new System.Windows.Media.VisualBrush visual" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="visual" Type="System.Windows.Media.Visual" />
      </Parameters>
      <Docs>
        <param name="visual">Der Inhalt des neuen <see cref="T:System.Windows.Media.VisualBrush" />.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Media.VisualBrush" />-Klasse, die den angegebenen <see cref="P:System.Windows.Media.VisualBrush.Visual" /> enthält.</summary>
        <remarks>To be added.</remarks>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=160049">VisualBrush-Beispiel</related>
      </Docs>
    </Member>
    <Member MemberName="AutoLayoutContent">
      <MemberSignature Language="C#" Value="public bool AutoLayoutContent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoLayoutContent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.VisualBrush.AutoLayoutContent" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoLayoutContent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AutoLayoutContent { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutoLayoutContent : bool with get, set" Usage="System.Windows.Media.VisualBrush.AutoLayoutContent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob dieser <see cref="T:System.Windows.Media.VisualBrush" /> das Layout für das eigene <see cref="P:System.Windows.Media.VisualBrush.Visual" /> ausführt, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn dieser Pinsel das Layout für das eigene <see cref="P:System.Windows.Media.VisualBrush.Visual" /> ausführen soll, andernfalls <see langword="false" />. Der Standardwert ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn diese Eigenschaft auf festgelegt wird, wirkt sich `true` dies nur dann aus, wenn es sich bei diesem Pinsel um <xref:System.Windows.Media.VisualBrush.Visual%2A> eine nicht-übergeordnete <xref:System.Windows.UIElement>  
  
<a name="dependencyPropertyInfo_AutoLayoutContent"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Media.VisualBrush.AutoLayoutContentProperty>|  
|Metadateneigenschaften auf `true` festgelegt|Keine|  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die Auswirkungen der <xref:System.Windows.Media.VisualBrush.AutoLayoutContent%2A> -Eigenschaft auf eine nicht übergeordnete-Eigenschaft <xref:System.Windows.UIElement> .  
  
 [!code-csharp[visualbrush_markup_snip#AutoLayoutContentNonParentedUIElementExample](~/samples/snippets/csharp/VS_Snippets_Wpf/visualbrush_markup_snip/CSharp/AutoLayoutContentExample.cs#autolayoutcontentnonparenteduielementexample)]
 [!code-vb[visualbrush_markup_snip#AutoLayoutContentNonParentedUIElementExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/visualbrush_markup_snip/visualbasic/autolayoutcontentexample.vb#autolayoutcontentnonparenteduielementexample)]
 [!code-xaml[visualbrush_markup_snip#AutoLayoutContentNonParentedUIElementExample](~/samples/snippets/xaml/VS_Snippets_Wpf/visualbrush_markup_snip/XAML/AutoLayoutContentExample.xaml#autolayoutcontentnonparenteduielementexample)]  
  
 Die folgende Abbildung zeigt die Ausgabe des Beispiels:  
  
 ![AutoLayoutContent mit einem nicht&#45;übergeordneten UIElement](~/add/media/graphicsmm-visualbrush-autolayoutcontentproperty-nonparented.png "AutoLayoutContent mit einem nicht übergeordneten UIElement")  
  
 Im nächsten Beispiel werden die Auswirkungen der- <xref:System.Windows.Media.VisualBrush.AutoLayoutContent%2A> Eigenschaft auf ein übergeordnetes Element veranschaulicht <xref:System.Windows.UIElement> .  
  
 [!code-csharp[visualbrush_markup_snip#AutoLayoutContentParentedUIElementExample](~/samples/snippets/csharp/VS_Snippets_Wpf/visualbrush_markup_snip/CSharp/AutoLayoutContentExample.cs#autolayoutcontentparenteduielementexample)]
 [!code-vb[visualbrush_markup_snip#AutoLayoutContentParentedUIElementExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/visualbrush_markup_snip/visualbasic/autolayoutcontentexample.vb#autolayoutcontentparenteduielementexample)]
 [!code-xaml[visualbrush_markup_snip#AutoLayoutContentParentedUIElementExample](~/samples/snippets/xaml/VS_Snippets_Wpf/visualbrush_markup_snip/XAML/AutoLayoutContentExample.xaml#autolayoutcontentparenteduielementexample)]  
  
 Die folgende Abbildung zeigt die Ausgabe des Beispiels:  
  
 ![AutoLayoutContent mit einem übergeordneten UIElement](~/add/media/graphicsmm-visualbrush-autolayoutcontentproperty-parented.png "AutoLayoutContent mit einem übergeordneten UIElement")  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoLayoutContentProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AutoLayoutContentProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AutoLayoutContentProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Media.VisualBrush.AutoLayoutContentProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AutoLayoutContentProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AutoLayoutContentProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable AutoLayoutContentProperty : System.Windows.DependencyProperty" Usage="System.Windows.Media.VisualBrush.AutoLayoutContentProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Media.VisualBrush.AutoLayoutContent" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public System.Windows.Media.VisualBrush Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Media.VisualBrush Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.VisualBrush.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As VisualBrush" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::VisualBrush ^ Clone();" />
      <MemberSignature Language="F#" Value="override this.Clone : unit -&gt; System.Windows.Media.VisualBrush" Usage="visualBrush.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.VisualBrush</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt einen änderbaren Klon dieser <see cref="T:System.Windows.Media.VisualBrush" />, indem tiefe Kopien der Werte dieses Objekts erzeugt werden.</summary>
        <returns>Ein änderbarer Klon des aktuellen Objekts. Die <see cref="P:System.Windows.Freezable.IsFrozen" />-Eigenschaft des geklonten Objekts ist <see langword="false" />, auch wenn die <see cref="P:System.Windows.Freezable.IsFrozen" />-Eigenschaft der Quelle <see langword="true" /> war.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird verwendet, um änderbare Kopien von fixierten <xref:System.Windows.Freezable> Objekten (oder einem beliebigen <xref:System.Windows.Freezable> Objekt) zu liefern. Aus Gründen der praktische überschattet diese Methode die geerbte Version durch eine stark typisierte Implementierung.  
  
 Weitere Informationen finden Sie unter <xref:System.Windows.Freezable.Clone%2A?displayProperty=nameWithType>.  
  
 Beim Kopieren von Abhängigkeitseigenschaften kopiert diese Methode Ressourcenverweise und Datenbindungen (die aber möglicherweise nicht mehr aufgelöst werden können), jedoch keine Animationen oder ihre aktuellen Werte.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValue">
      <MemberSignature Language="C#" Value="public System.Windows.Media.VisualBrush CloneCurrentValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Media.VisualBrush CloneCurrentValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.VisualBrush.CloneCurrentValue" />
      <MemberSignature Language="VB.NET" Value="Public Function CloneCurrentValue () As VisualBrush" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::VisualBrush ^ CloneCurrentValue();" />
      <MemberSignature Language="F#" Value="override this.CloneCurrentValue : unit -&gt; System.Windows.Media.VisualBrush" Usage="visualBrush.CloneCurrentValue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.VisualBrush</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt einen änderbaren Klon des <see cref="T:System.Windows.Media.VisualBrush" />-Objekts, indem tiefe Kopien der aktuellen Werte dieses Objekts erzeugt werden. Ressourcenverweise, Datenbindungen und Animationen werden nicht kopiert, ihre aktuellen Werte werden jedoch kopiert.</summary>
        <returns>Ein änderbarer Klon des aktuellen Objekts. Die <see cref="P:System.Windows.Freezable.IsFrozen" />-Eigenschaft des geklonten Objekts ist <see langword="false" />, auch wenn die <see cref="P:System.Windows.Freezable.IsFrozen" />-Eigenschaft der Quelle <see langword="true" /> war.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird verwendet, um änderbare Kopien von fixierten <xref:System.Windows.Freezable> Objekten (oder einem beliebigen <xref:System.Windows.Freezable> Objekt) zu liefern. Aus Gründen der praktische überschattet diese Methode die geerbte Version durch eine stark typisierte Implementierung.  
  
 Weitere Informationen finden Sie unter <xref:System.Windows.Freezable.CloneCurrentValue%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceCore">
      <MemberSignature Language="C#" Value="protected override System.Windows.Freezable CreateInstanceCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Freezable CreateInstanceCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.VisualBrush.CreateInstanceCore" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function CreateInstanceCore () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Freezable ^ CreateInstanceCore();" />
      <MemberSignature Language="F#" Value="abstract member CreateInstanceCore : unit -&gt; System.Windows.Freezable&#xA;override this.CreateInstanceCore : unit -&gt; System.Windows.Freezable" Usage="visualBrush.CreateInstanceCore " FrameworkAlternate="net-5.0" />
      <MemberSignature Language="F#" Value="override this.CreateInstanceCore : unit -&gt; System.Windows.Freezable" Usage="visualBrush.CreateInstanceCore " FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetContentBounds">
      <MemberSignature Language="C#" Value="protected override void GetContentBounds (out System.Windows.Rect contentBounds);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void GetContentBounds([out] valuetype System.Windows.Rect&amp; contentBounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.VisualBrush.GetContentBounds(System.Windows.Rect@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub GetContentBounds (ByRef contentBounds As Rect)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void GetContentBounds([Runtime::InteropServices::Out] System::Windows::Rect % contentBounds);" />
      <MemberSignature Language="F#" Value="override this.GetContentBounds : Rect -&gt; unit" Usage="visualBrush.GetContentBounds contentBounds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="contentBounds" Type="System.Windows.Rect" RefType="out" />
      </Parameters>
      <Docs>
        <param name="contentBounds">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected override void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.VisualBrush.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="visualBrush.OnPropertyChanged e" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="F#" Value="override this.OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="visualBrush.OnPropertyChanged e" FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Visual">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Visual Visual { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Visual Visual" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.VisualBrush.Visual" />
      <MemberSignature Language="VB.NET" Value="Public Property Visual As Visual" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Visual ^ Visual { System::Windows::Media::Visual ^ get(); void set(System::Windows::Media::Visual ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Visual : System.Windows.Media.Visual with get, set" Usage="System.Windows.Media.VisualBrush.Visual" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Visual</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Inhalt des Pinsels ab oder legt ihn fest.</summary>
        <value>Der Inhalt des Pinsels. Der Standardwert ist <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es gibt zwei Möglichkeiten, den <xref:System.Windows.Media.VisualBrush.Visual%2A> Inhalt einer anzugeben <xref:System.Windows.Media.VisualBrush> .  
  
-   Erstellen Sie einen neuen <xref:System.Windows.Media.Visual> , und verwenden Sie ihn zum Festlegen der- <xref:System.Windows.Media.VisualBrush.Visual%2A> Eigenschaft von <xref:System.Windows.Media.VisualBrush> .  
  
-   Verwenden Sie ein vorhandenes <xref:System.Windows.Media.Visual> , das ein doppeltes Bild des Ziels erstellt <xref:System.Windows.Media.Visual> . Anschließend können Sie mit dem <xref:System.Windows.Media.VisualBrush> interessante Effekte erstellen, z. b. Reflektion und Vergrößerung.  
  
 <xref:System.Windows.Media.Visual> ist in der WPF-Klassenhierarchie sehr hoch, sodass eine sehr große Anzahl von Objekten möglicherweise als visuelles Element dient, das Sie für eine verwenden <xref:System.Windows.Media.VisualBrush> . die gesamte Liste kann hier nicht angezeigt werden. Weitere <xref:System.Windows.Media.Visual> Informationen finden Sie im Abschnitt "Vererbungs Hierarchie", in dem die sofort abgeleiteten Klassen angezeigt werden. Sie können dann auf die sofort abgeleiteten Klassen klicken und die Hierarchien durchlaufen, um einen Eindruck von allen Möglichkeiten zu erhalten. Auf der obersten Ebene werden die beiden häufigsten Kategorien von Objekten, die Sie für eine verwenden können, <xref:System.Windows.Media.VisualBrush> <xref:System.Windows.UIElement> oder verwendet <xref:System.Windows.Media.ContainerVisual> . <xref:System.Windows.UIElement> umfasst im Grunde alle Benutzeroberflächen Elemente, die andernfalls an der Benutzeroberfläche für eine WPF-Anwendung teilnehmen können. <xref:System.Windows.Media.ContainerVisual> enthält ein <xref:System.Windows.Media.DrawingGroup> -Objekt, das ein oder mehrere von <xref:System.Windows.Media.Drawing> abgeleitete-Objekte enthält.  
  
 Wenn Sie einen neuen <xref:System.Windows.Media.VisualBrush.Visual%2A> für einen definieren, <xref:System.Windows.Media.VisualBrush> <xref:System.Windows.Media.Visual> der ein ist (z. b. <xref:System.Windows.UIElement> ein Panel oder Steuerelement), wird das Layoutsystem auf dem <xref:System.Windows.UIElement> und seinen untergeordneten Elementen ausgeführt, wenn die- <xref:System.Windows.Media.VisualBrush.AutoLayoutContent%2A> Eigenschaft auf festgelegt ist `true` . Der <xref:System.Windows.UIElement> Stamm ist aber im Wesentlichen vom restlichen System isoliert; Stile, Storyboards und externes Layout, die vom übergeordneten Element, in dem der Pinsel angewendet wird, vorgeschrieben sind, können diese Grenze nicht durchdringen. Daher sollten Sie die Größe des Stamms explizit angeben <xref:System.Windows.UIElement> , da das einzige übergeordnete Element das <xref:System.Windows.Media.VisualBrush> -Element ist und sich daher nicht automatisch für den Bereich eignet, der gezeichnet wird. Weitere Informationen zum Layout in [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] finden Sie unter [Layout](/dotnet/framework/wpf/advanced/layout).  
  
 Aktualisierungen an der visuellen Struktur eines <xref:System.Windows.Media.VisualBrush> werden nicht weitergegeben, wenn ein <xref:System.Windows.Media.Effects.BitmapEffect> in der übergeordneten Kette des Pinsels ist. Sie können diese Einschränkung umgehen, indem Sie ein Update der Szene für das Objekt über der Auswirkung erzwingen. Sie können <xref:System.Windows.UIElement.InvalidateVisual%2A> eine Animation zum Erzwingen eines Szenen Updates abrufen oder einschließen.  
  
> [!NOTE]
>  Ein <xref:System.Windows.Media.VisualBrush> kann nicht als schreibgeschützt festgelegt werden (eingefroren), wenn seine- <xref:System.Windows.Media.VisualBrush.Visual%2A> Eigenschaft auf einen anderen Wert als festgelegt ist. `null.`  
  
<a name="xamlPropertyElementUsage_Visual"></a>   
## <a name="xaml-property-element-usage"></a>Verwendung von XAML-Eigenschaftenelementen  
  
```  
<object>  
  <object.Visual>  
    singleVisualRoot  
  </object.Visual>  
</object>  
```  
  
<a name="xamlAttributeUsage_Visual"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
 <*Objekt* `Visual` = "{*BindingExpression*}"/>  
  
- oder -
  
 <*Objekt* `Visual` = "{*resourceexpression*}"/>  
  
<a name="xamlValues_Visual"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 `singleVisualRoot`  
 Ein einzelnes Objekt Element, das ein neues visuelles Element für den Pinsel definiert. Dabei muss es sich um ein Objekt handeln, das von abgeleitet wird <xref:System.Windows.Media.Visual> . Siehe Hinweise.  
  
 `bindingExpression`  
 Ein, der zu einer vorhandenen-Instanz ausgewertet wird <xref:System.Windows.Media.Visual> .  
  
 `resourceExpression`  
 Ein `StaticResource` oder `DynamicResource` , das zu einer vorhandenen-Instanz ausgewertet wird <xref:System.Windows.Media.Visual> . Siehe [XAML-Ressourcen](/dotnet/framework/wpf/advanced/xaml-resources)  
  
<a name="dependencyPropertyInfo_Visual"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Media.VisualBrush.VisualProperty>|  
|Metadateneigenschaften auf `true` festgelegt|Keine|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty VisualProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty VisualProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Media.VisualBrush.VisualProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly VisualProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ VisualProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable VisualProperty : System.Windows.DependencyProperty" Usage="System.Windows.Media.VisualBrush.VisualProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Media.VisualBrush.Visual" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
