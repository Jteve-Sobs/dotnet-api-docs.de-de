<Type Name="VisualBrush" FullName="System.Windows.Media.VisualBrush">
  <Metadata><Meta Name="ms.openlocfilehash" Value="11ef56df160876cd46a3526da0a54145c4e69c22" /><Meta Name="ms.sourcegitcommit" Value="b0947fed0227b6b2e292d7efb43705b488b130aa" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="04/29/2020" /><Meta Name="ms.locfileid" Value="82487933" /></Metadata><TypeSignature Language="C#" Value="public sealed class VisualBrush : System.Windows.Media.TileBrush" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit VisualBrush extends System.Windows.Media.TileBrush" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Media.VisualBrush" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class VisualBrush&#xA;Inherits TileBrush" />
  <TypeSignature Language="C++ CLI" Value="public ref class VisualBrush sealed : System::Windows::Media::TileBrush" />
  <TypeSignature Language="F#" Value="type VisualBrush = class&#xA;    inherit TileBrush" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed VisualBrush extends System.Windows.Media.TileBrush" FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Media.TileBrush</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Zeichnet einen Bereich mit einem <see cref="P:System.Windows.Media.VisualBrush.Visual" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es gibt zwei Möglichkeiten, den <xref:System.Windows.Media.VisualBrush.Visual%2A> Inhalt eines <xref:System.Windows.Media.VisualBrush>anzugeben.  
  
-   Erstellen Sie einen neuen <xref:System.Windows.Media.Visual>, und verwenden Sie ihn, um die <xref:System.Windows.Media.VisualBrush.Visual%2A>-Eigenschaft der <xref:System.Windows.Media.VisualBrush>festzulegen.  
  
-   Verwenden Sie eine vorhandene <xref:System.Windows.Media.Visual>, die ein doppeltes Abbild der Ziel <xref:System.Windows.Media.Visual>erstellt. Sie können dann die <xref:System.Windows.Media.VisualBrush> verwenden, um interessante Effekte zu erstellen, wie z. b. Reflektion und Vergrößerung.  
  
 Wenn Sie eine neue <xref:System.Windows.Media.VisualBrush.Visual%2A> für eine <xref:System.Windows.Media.VisualBrush> definieren und <xref:System.Windows.Media.Visual> ein <xref:System.Windows.UIElement> ist (z. b. ein Panel oder Steuerelement), wird das Layoutsystem auf dem <xref:System.Windows.UIElement> und seinen untergeordneten Elementen ausgeführt, wenn die <xref:System.Windows.Media.VisualBrush.AutoLayoutContent%2A>-Eigenschaft auf `true`festgelegt ist. Der Stamm <xref:System.Windows.UIElement> ist jedoch im Wesentlichen vom Rest des Systems isoliert. Stile, Storyboards und externe Layouts können diese Grenze nicht durchdringen. Daher sollten Sie die Größe des Stamm <xref:System.Windows.UIElement>explizit angeben, da das einzige übergeordnete Element das <xref:System.Windows.Media.VisualBrush> ist und sich daher nicht automatisch an den Bereich anpassen kann, der gezeichnet wird. Weitere Informationen zum Layout in [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] finden Sie unter [Layout](~/docs/framework/wpf/advanced/layout.md).  
  
 Aktualisierungen an der visuellen Struktur einer <xref:System.Windows.Media.VisualBrush> werden nicht weitergegeben, wenn sich ein <xref:System.Windows.Media.Effects.BitmapEffect> in der übergeordneten Kette des Pinsels befindet. Sie können diese Einschränkung umgehen, indem Sie ein Update der Szene für das Objekt über der Auswirkung erzwingen. Sie können <xref:System.Windows.UIElement.InvalidateVisual%2A> oder eine Animation zum Erzwingen eines Szenen Updates aufzurufen.  
  
 Frei wählbare **Features:** Da es von der <xref:System.Windows.Freezable>-Klasse erbt, bietet die <xref:System.Windows.Media.VisualBrush>-Klasse mehrere besondere Features: <xref:System.Windows.Media.VisualBrush> Objekte können als deklariert und von mehreren Objekten gemeinsam genutzt werden. Weitere Informationen zu den verschiedenen Funktionen, die von <xref:System.Windows.Freezable> Objekten bereitgestellt werden, finden Sie in der [Übersicht über](~/docs/framework/wpf/advanced/freezable-objects-overview.md)frei wählbare Objekte.  
  
> [!NOTE]
>  Eine <xref:System.Windows.Media.VisualBrush> kann nicht als schreibgeschützt festgelegt werden (eingefroren), wenn die <xref:System.Windows.Media.VisualBrush.Visual%2A>-Eigenschaft auf einen anderen Wert als festgelegt ist `null.`  
  
 ]]></format>
    </remarks>
    <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=160049">VisualBrush-Beispiel</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Media.VisualBrush" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public VisualBrush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.VisualBrush.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; VisualBrush();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Media.VisualBrush" />-Klasse.</summary>
        <remarks>To be added.</remarks>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=160049">VisualBrush-Beispiel</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public VisualBrush (System.Windows.Media.Visual visual);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.Media.Visual visual) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.VisualBrush.#ctor(System.Windows.Media.Visual)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (visual As Visual)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; VisualBrush(System::Windows::Media::Visual ^ visual);" />
      <MemberSignature Language="F#" Value="new System.Windows.Media.VisualBrush : System.Windows.Media.Visual -&gt; System.Windows.Media.VisualBrush" Usage="new System.Windows.Media.VisualBrush visual" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="visual" Type="System.Windows.Media.Visual" />
      </Parameters>
      <Docs>
        <param name="visual">Der Inhalt des neuen <see cref="T:System.Windows.Media.VisualBrush" />.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Media.VisualBrush" />-Klasse, die den angegebenen <see cref="P:System.Windows.Media.VisualBrush.Visual" /> enthält.</summary>
        <remarks>To be added.</remarks>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=160049">VisualBrush-Beispiel</related>
      </Docs>
    </Member>
    <Member MemberName="AutoLayoutContent">
      <MemberSignature Language="C#" Value="public bool AutoLayoutContent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoLayoutContent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.VisualBrush.AutoLayoutContent" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoLayoutContent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AutoLayoutContent { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutoLayoutContent : bool with get, set" Usage="System.Windows.Media.VisualBrush.AutoLayoutContent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob dieser <see cref="T:System.Windows.Media.VisualBrush" /> das Layout für das eigene <see cref="P:System.Windows.Media.VisualBrush.Visual" /> ausführt, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn dieser Pinsel das Layout für das eigene <see cref="P:System.Windows.Media.VisualBrush.Visual" /> ausführen soll, andernfalls <see langword="false" />. Der Standardwert lautet <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Festlegen dieser Eigenschaft auf `true` wirkt sich nur dann aus, wenn der <xref:System.Windows.Media.VisualBrush.Visual%2A> dieses Pinsels eine nicht übergeordnete <xref:System.Windows.UIElement>ist.  
  
<a name="dependencyPropertyInfo_AutoLayoutContent"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Media.VisualBrush.AutoLayoutContentProperty>|  
|Metadateneigenschaften auf `true` festgelegt|Keine|  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die Auswirkungen der <xref:System.Windows.Media.VisualBrush.AutoLayoutContent%2A>-Eigenschaft auf eine nicht übergeordnete <xref:System.Windows.UIElement>.  
  
 [!code-csharp[visualbrush_markup_snip#AutoLayoutContentNonParentedUIElementExample](~/samples/snippets/csharp/VS_Snippets_Wpf/visualbrush_markup_snip/CSharp/AutoLayoutContentExample.cs#autolayoutcontentnonparenteduielementexample)]
 [!code-vb[visualbrush_markup_snip#AutoLayoutContentNonParentedUIElementExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/visualbrush_markup_snip/visualbasic/autolayoutcontentexample.vb#autolayoutcontentnonparenteduielementexample)]
 [!code-xaml[visualbrush_markup_snip#AutoLayoutContentNonParentedUIElementExample](~/samples/snippets/xaml/VS_Snippets_Wpf/visualbrush_markup_snip/XAML/AutoLayoutContentExample.xaml#autolayoutcontentnonparenteduielementexample)]  
  
 Die folgende Abbildung zeigt die Ausgabe des Beispiels:  
  
 ![AutoLayoutContent mit einem nicht&#45;übergeordneten UIElement](~/add/media/graphicsmm-visualbrush-autolayoutcontentproperty-nonparented.png "AutoLayoutContent mit einem nicht übergeordneten UIElement")  
  
 Im nächsten Beispiel werden die Auswirkungen der <xref:System.Windows.Media.VisualBrush.AutoLayoutContent%2A>-Eigenschaft auf eine übergeordnete <xref:System.Windows.UIElement>gezeigt.  
  
 [!code-csharp[visualbrush_markup_snip#AutoLayoutContentParentedUIElementExample](~/samples/snippets/csharp/VS_Snippets_Wpf/visualbrush_markup_snip/CSharp/AutoLayoutContentExample.cs#autolayoutcontentparenteduielementexample)]
 [!code-vb[visualbrush_markup_snip#AutoLayoutContentParentedUIElementExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/visualbrush_markup_snip/visualbasic/autolayoutcontentexample.vb#autolayoutcontentparenteduielementexample)]
 [!code-xaml[visualbrush_markup_snip#AutoLayoutContentParentedUIElementExample](~/samples/snippets/xaml/VS_Snippets_Wpf/visualbrush_markup_snip/XAML/AutoLayoutContentExample.xaml#autolayoutcontentparenteduielementexample)]  
  
 Die folgende Abbildung zeigt die Ausgabe des Beispiels:  
  
 ![AutoLayoutContent mit einem übergeordneten UIElement](~/add/media/graphicsmm-visualbrush-autolayoutcontentproperty-parented.png "AutoLayoutContent mit einem übergeordneten UIElement")  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoLayoutContentProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AutoLayoutContentProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AutoLayoutContentProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Media.VisualBrush.AutoLayoutContentProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AutoLayoutContentProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AutoLayoutContentProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable AutoLayoutContentProperty : System.Windows.DependencyProperty" Usage="System.Windows.Media.VisualBrush.AutoLayoutContentProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Media.VisualBrush.AutoLayoutContent" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public System.Windows.Media.VisualBrush Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Media.VisualBrush Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.VisualBrush.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As VisualBrush" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::VisualBrush ^ Clone();" />
      <MemberSignature Language="F#" Value="override this.Clone : unit -&gt; System.Windows.Media.VisualBrush" Usage="visualBrush.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.VisualBrush</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt einen änderbaren Klon dieser <see cref="T:System.Windows.Media.VisualBrush" />, indem tiefe Kopien der Werte dieses Objekts erzeugt werden.</summary>
        <returns>Ein änderbarer Klon des aktuellen Objekts. Die <see cref="P:System.Windows.Freezable.IsFrozen" />-Eigenschaft des geklonten Objekts ist <see langword="false" />, auch wenn die <see cref="P:System.Windows.Freezable.IsFrozen" />-Eigenschaft der Quelle <see langword="true." /> ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird verwendet, um änderbare Kopien von fixierten <xref:System.Windows.Freezable> Objekten (oder einem beliebigen <xref:System.Windows.Freezable> Objekt) zu liefern. Aus Gründen der praktische überschattet diese Methode die geerbte Version durch eine stark typisierte Implementierung.  
  
 Weitere Informationen finden Sie unter <xref:System.Windows.Freezable.Clone%2A?displayProperty=nameWithType>.  
  
 Beim Kopieren von Abhängigkeitseigenschaften kopiert diese Methode Ressourcenverweise und Datenbindungen (die aber möglicherweise nicht mehr aufgelöst werden können), jedoch keine Animationen oder ihre aktuellen Werte.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValue">
      <MemberSignature Language="C#" Value="public System.Windows.Media.VisualBrush CloneCurrentValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Media.VisualBrush CloneCurrentValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.VisualBrush.CloneCurrentValue" />
      <MemberSignature Language="VB.NET" Value="Public Function CloneCurrentValue () As VisualBrush" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::VisualBrush ^ CloneCurrentValue();" />
      <MemberSignature Language="F#" Value="override this.CloneCurrentValue : unit -&gt; System.Windows.Media.VisualBrush" Usage="visualBrush.CloneCurrentValue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.VisualBrush</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt einen änderbaren Klon des <see cref="T:System.Windows.Media.VisualBrush" />-Objekts, indem tiefe Kopien der aktuellen Werte dieses Objekts erzeugt werden. Ressourcenverweise, Datenbindungen und Animationen werden nicht kopiert, ihre aktuellen Werte werden jedoch kopiert.</summary>
        <returns>Ein änderbarer Klon des aktuellen Objekts. Die <see cref="P:System.Windows.Freezable.IsFrozen" />-Eigenschaft des geklonten Objekts ist <see langword="false" />, auch wenn die <see cref="P:System.Windows.Freezable.IsFrozen" />-Eigenschaft der Quelle <see langword="true" /> war.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird verwendet, um änderbare Kopien von fixierten <xref:System.Windows.Freezable> Objekten (oder einem beliebigen <xref:System.Windows.Freezable> Objekt) zu liefern. Aus Gründen der praktische überschattet diese Methode die geerbte Version durch eine stark typisierte Implementierung.  
  
 Weitere Informationen finden Sie unter <xref:System.Windows.Freezable.CloneCurrentValue%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceCore">
      <MemberSignature Language="C#" Value="protected override System.Windows.Freezable CreateInstanceCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Freezable CreateInstanceCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.VisualBrush.CreateInstanceCore" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function CreateInstanceCore () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Freezable ^ CreateInstanceCore();" />
      <MemberSignature Language="F#" Value="override this.CreateInstanceCore : unit -&gt; System.Windows.Freezable" Usage="visualBrush.CreateInstanceCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetContentBounds">
      <MemberSignature Language="C#" Value="protected override void GetContentBounds (out System.Windows.Rect contentBounds);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void GetContentBounds([out] valuetype System.Windows.Rect&amp; contentBounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.VisualBrush.GetContentBounds(System.Windows.Rect@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub GetContentBounds (ByRef contentBounds As Rect)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void GetContentBounds([Runtime::InteropServices::Out] System::Windows::Rect % contentBounds);" />
      <MemberSignature Language="F#" Value="override this.GetContentBounds : Rect -&gt; unit" Usage="visualBrush.GetContentBounds contentBounds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="contentBounds" Type="System.Windows.Rect" RefType="out" />
      </Parameters>
      <Docs>
        <param name="contentBounds">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected override void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.VisualBrush.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="override this.OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="visualBrush.OnPropertyChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Visual">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Visual Visual { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Visual Visual" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.VisualBrush.Visual" />
      <MemberSignature Language="VB.NET" Value="Public Property Visual As Visual" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Visual ^ Visual { System::Windows::Media::Visual ^ get(); void set(System::Windows::Media::Visual ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Visual : System.Windows.Media.Visual with get, set" Usage="System.Windows.Media.VisualBrush.Visual" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Visual</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Inhalt des Pinsels ab oder legt ihn fest.</summary>
        <value>Der Inhalt des Pinsels. Der Standardwert lautet <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es gibt zwei Möglichkeiten, den <xref:System.Windows.Media.VisualBrush.Visual%2A> Inhalt eines <xref:System.Windows.Media.VisualBrush>anzugeben.  
  
-   Erstellen Sie einen neuen <xref:System.Windows.Media.Visual>, und verwenden Sie ihn, um die <xref:System.Windows.Media.VisualBrush.Visual%2A>-Eigenschaft der <xref:System.Windows.Media.VisualBrush>festzulegen.  
  
-   Verwenden Sie eine vorhandene <xref:System.Windows.Media.Visual>, die ein doppeltes Abbild der Ziel <xref:System.Windows.Media.Visual>erstellt. Sie können dann die <xref:System.Windows.Media.VisualBrush> verwenden, um interessante Effekte zu erstellen, wie z. b. Reflektion und Vergrößerung.  
  
 <xref:System.Windows.Media.Visual> in der WPF-Klassenhierarchie sehr hoch ist, kann eine sehr große Anzahl von Objekten möglicherweise als visuelles Element dienen, das Sie für eine <xref:System.Windows.Media.VisualBrush>verwenden. die gesamte Liste kann hier nicht angezeigt werden. Siehe <xref:System.Windows.Media.Visual>; Weitere Informationen finden Sie im Abschnitt "Vererbungs Hierarchie", in dem die sofort abgeleiteten Klassen angezeigt werden. Sie können dann auf die sofort abgeleiteten Klassen klicken und die Hierarchien durchlaufen, um einen Eindruck von allen Möglichkeiten zu erhalten. Auf der obersten Ebene werden die beiden gängigsten Kategorien von Objekten, die Sie für eine <xref:System.Windows.Media.VisualBrush> verwenden können, <xref:System.Windows.UIElement> oder <xref:System.Windows.Media.ContainerVisual>. <xref:System.Windows.UIElement> umfasst im Grunde alle Benutzeroberflächen Elemente, die andernfalls an der Benutzeroberfläche für eine WPF-Anwendung teilnehmen können. <xref:System.Windows.Media.ContainerVisual> enthält ein <xref:System.Windows.Media.DrawingGroup>, das mindestens ein <xref:System.Windows.Media.Drawing>abgeleitetes Objekt enthält.  
  
 Wenn Sie eine neue <xref:System.Windows.Media.VisualBrush.Visual%2A> für eine <xref:System.Windows.Media.VisualBrush> definieren und <xref:System.Windows.Media.Visual> ein <xref:System.Windows.UIElement> ist (z. b. ein Panel oder Steuerelement), wird das Layoutsystem auf dem <xref:System.Windows.UIElement> und seinen untergeordneten Elementen ausgeführt, wenn die <xref:System.Windows.Media.VisualBrush.AutoLayoutContent%2A>-Eigenschaft auf `true`festgelegt ist. Der Stamm <xref:System.Windows.UIElement> ist jedoch im Wesentlichen vom Rest des Systems isoliert. Stile, Storyboards und das externe Layout, die vom übergeordneten Element, in dem der Pinsel angewendet wird, vorgeschrieben sind, können diese Grenze nicht durchdringen. Daher sollten Sie die Größe des Stamm <xref:System.Windows.UIElement>explizit angeben, da das einzige übergeordnete Element das <xref:System.Windows.Media.VisualBrush> ist und sich daher nicht automatisch an den Bereich anpassen kann, der gezeichnet wird. Weitere Informationen zum Layout in [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] finden Sie unter [Layout](~/docs/framework/wpf/advanced/layout.md).  
  
 Aktualisierungen an der visuellen Struktur einer <xref:System.Windows.Media.VisualBrush> werden nicht weitergegeben, wenn sich ein <xref:System.Windows.Media.Effects.BitmapEffect> in der übergeordneten Kette des Pinsels befindet. Sie können diese Einschränkung umgehen, indem Sie ein Update der Szene für das Objekt über der Auswirkung erzwingen. Sie können <xref:System.Windows.UIElement.InvalidateVisual%2A> oder eine Animation zum Erzwingen eines Szenen Updates aufzurufen.  
  
> [!NOTE]
>  Eine <xref:System.Windows.Media.VisualBrush> kann nicht als schreibgeschützt festgelegt werden (eingefroren), wenn die <xref:System.Windows.Media.VisualBrush.Visual%2A>-Eigenschaft auf einen anderen Wert als festgelegt ist `null.`  
  
<a name="xamlPropertyElementUsage_Visual"></a>   
## <a name="xaml-property-element-usage"></a>Verwendung von XAML-Eigenschaftenelementen  
  
```  
<object>  
  <object.Visual>  
    singleVisualRoot  
  </object.Visual>  
</object>  
```  
  
<a name="xamlAttributeUsage_Visual"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
 <- *Objekt* `Visual`= "{*BindingExpression*}"/>  
  
- oder -
  
 <- *Objekt* `Visual`= "{*resourceexpression*}"/>  
  
<a name="xamlValues_Visual"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 `singleVisualRoot`  
 Ein einzelnes Objekt Element, das ein neues visuelles Element für den Pinsel definiert. Dabei muss es sich um ein Objekt handeln, das von <xref:System.Windows.Media.Visual>abgeleitet ist. Siehe Hinweise.  
  
 `bindingExpression`  
 Ein, der zu einer vorhandenen <xref:System.Windows.Media.Visual>-Instanz ausgewertet wird.  
  
 `resourceExpression`  
 Eine `StaticResource` oder `DynamicResource`, die zu einer vorhandenen <xref:System.Windows.Media.Visual> Instanz ausgewertet wird. Siehe [XAML-Ressourcen](~/docs/framework/wpf/advanced/xaml-resources.md)  
  
<a name="dependencyPropertyInfo_Visual"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Media.VisualBrush.VisualProperty>|  
|Metadateneigenschaften auf `true` festgelegt|Keine|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty VisualProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty VisualProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Media.VisualBrush.VisualProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly VisualProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ VisualProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable VisualProperty : System.Windows.DependencyProperty" Usage="System.Windows.Media.VisualBrush.VisualProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Media.VisualBrush.Visual" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
