<Type Name="ContainerVisual" FullName="System.Windows.Media.ContainerVisual">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="6529a016eca8af1ed739cba106eee6308b45974d" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48622250" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ContainerVisual : System.Windows.Media.Visual" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ContainerVisual extends System.Windows.Media.Visual" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Media.ContainerVisual" />
  <TypeSignature Language="VB.NET" Value="Public Class ContainerVisual&#xA;Inherits Visual" />
  <TypeSignature Language="C++ CLI" Value="public ref class ContainerVisual : System::Windows::Media::Visual" />
  <TypeSignature Language="F#" Value="type ContainerVisual = class&#xA;    inherit Visual" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Media.Visual</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Verwaltet eine Auflistung von <see cref="T:System.Windows.Media.Visual" />-Objekten.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Media.ContainerVisual> Klasse dient als Container für eine Auflistung von <xref:System.Windows.Media.Visual> Objekte. Die <xref:System.Windows.Media.DrawingVisual> Klasse leitet sich von der <xref:System.Windows.Media.ContainerVisual> -Klasse so, dass die <xref:System.Windows.Media.DrawingVisual> Klasse kann auch eine Auflistung von visuellen Objekten enthalten.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie erstellen eine <xref:System.Windows.Media.ContainerVisual> -Objekt, das als übergeordnetes Element, für zwei verwendet wird <xref:System.Windows.Media.DrawingVisual> Objekte. Objekte, die hinzugefügt werden, die <xref:System.Windows.Media.ContainerVisual> Objekt muss in umgekehrter Z-Reihenfolge (von unten nach oben) hinzugefügt werden, um sicherzustellen, dass sie in der richtigen Zeichnungsreihenfolge gerendert werden. In der Reihenfolge für die visuelle Struktur ordnungsgemäß aufgelistet werden sollen, das Beispiel enthält den überschriebene Implementierungen der <xref:System.Windows.Media.ContainerVisual.GetVisualChild%2A> Methode und <xref:System.Windows.Media.ContainerVisual.VisualChildrenCount%2A> Eigenschaft.  
  
 [!code-csharp[ContainerVisualHost#ContainerVisualHost01](~/samples/snippets/csharp/VS_Snippets_Wpf/ContainerVisualHost/CSharp/Window1.xaml.cs#containervisualhost01)]
 [!code-vb[ContainerVisualHost#ContainerVisualHost01](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContainerVisualHost/visualbasic/window1.xaml.vb#containervisualhost01)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ContainerVisual ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.ContainerVisual.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ContainerVisual();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Erstellt eine neue Instanz der <see cref="T:System.Windows.Media.ContainerVisual" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie eine neue Instanz der Erstellen einer <xref:System.Windows.Media.ContainerVisual> Objekt und klicken Sie dann untergeordnete visuelle Objekte hinzu.  
  
 [!code-csharp[ContainerVisualSnippets#ContainerVisualSnippet1](~/samples/snippets/csharp/VS_Snippets_Wpf/ContainerVisualSnippets/CSharp/Window1.xaml.cs#containervisualsnippet1)]
 [!code-vb[ContainerVisualSnippets#ContainerVisualSnippet1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContainerVisualSnippets/visualbasic/window1.xaml.vb#containervisualsnippet1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BitmapEffect">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Effects.BitmapEffect BitmapEffect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Effects.BitmapEffect BitmapEffect" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.BitmapEffect" />
      <MemberSignature Language="VB.NET" Value="Public Property BitmapEffect As BitmapEffect" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Effects::BitmapEffect ^ BitmapEffect { System::Windows::Media::Effects::BitmapEffect ^ get(); void set(System::Windows::Media::Effects::BitmapEffect ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BitmapEffect : System.Windows.Media.Effects.BitmapEffect with get, set" Usage="System.Windows.Media.ContainerVisual.BitmapEffect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.Obsolete("Avoid using BitmapEffects as they have very poor performance characteristics.  They will be deprecated in a future version.  Consider using the UIElement.Effect property and ShaderEffects where appropriate instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Effects.BitmapEffect</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen <see cref="T:System.Windows.Media.Effects.BitmapEffect" />-Wert für das <see cref="T:System.Windows.Media.ContainerVisual" /> ab oder legt diesen fest.</summary>
        <value>Der Bitmapeffekt für dieses visuelle Objekt.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BitmapEffectInput">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Effects.BitmapEffectInput BitmapEffectInput { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Effects.BitmapEffectInput BitmapEffectInput" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.BitmapEffectInput" />
      <MemberSignature Language="VB.NET" Value="Public Property BitmapEffectInput As BitmapEffectInput" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Effects::BitmapEffectInput ^ BitmapEffectInput { System::Windows::Media::Effects::BitmapEffectInput ^ get(); void set(System::Windows::Media::Effects::BitmapEffectInput ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BitmapEffectInput : System.Windows.Media.Effects.BitmapEffectInput with get, set" Usage="System.Windows.Media.ContainerVisual.BitmapEffectInput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.Obsolete("Avoid using BitmapEffects as they have very poor performance characteristics.  They will be deprecated in a future version.  Consider using the UIElement.Effect property and ShaderEffects where appropriate instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Effects.BitmapEffectInput</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen <see cref="T:System.Windows.Media.Effects.BitmapEffectInput" />-Wert für das <see cref="T:System.Windows.Media.ContainerVisual" /> ab oder legt diesen fest.</summary>
        <value>Der Bitmapeffekteingabewert für dieses visuelle Objekt.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CacheMode">
      <MemberSignature Language="C#" Value="public System.Windows.Media.CacheMode CacheMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.CacheMode CacheMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.CacheMode" />
      <MemberSignature Language="VB.NET" Value="Public Property CacheMode As CacheMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::CacheMode ^ CacheMode { System::Windows::Media::CacheMode ^ get(); void set(System::Windows::Media::CacheMode ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CacheMode : System.Windows.Media.CacheMode with get, set" Usage="System.Windows.Media.ContainerVisual.CacheMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.CacheMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine zwischengespeicherte Darstellung des <see cref="T:System.Windows.Media.ContainerVisual" /> ab oder legt diese fest.</summary>
        <value>Ein <see cref="T:System.Windows.Media.CacheMode" />, der eine zwischengespeicherte Darstellung von <see cref="T:System.Windows.Media.ContainerVisual" /> enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Legen Sie die <xref:System.Windows.Media.ContainerVisual.CacheMode%2A> Eigenschaft, wenn Sie müssen zum Erhöhen der Leistung für Inhalte, die zum Rendern zeitaufwändig ist. Weitere Informationen finden Sie unter <xref:System.Windows.Media.BitmapCache>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.UIElement.CacheMode" />
        <altmember cref="P:System.Windows.Media.Visual.VisualCacheMode" />
        <altmember cref="T:System.Windows.Media.BitmapCache" />
        <altmember cref="T:System.Windows.Media.BitmapCacheBrush" />
      </Docs>
    </Member>
    <Member MemberName="Children">
      <MemberSignature Language="C#" Value="public System.Windows.Media.VisualCollection Children { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.VisualCollection Children" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.Children" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Children As VisualCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::VisualCollection ^ Children { System::Windows::Media::VisualCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Children : System.Windows.Media.VisualCollection" Usage="System.Windows.Media.ContainerVisual.Children" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.VisualCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Auflistung der untergeordneten Elemente des <see cref="T:System.Windows.Media.ContainerVisual" /> ab.</summary>
        <value>Eine <see cref="T:System.Windows.Media.VisualCollection" />, die die untergeordneten Elemente des <see cref="T:System.Windows.Media.ContainerVisual" /> enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel zeigt das Abrufen der <xref:System.Windows.Media.VisualCollection> aus einem <xref:System.Windows.Media.ContainerVisual> Objekt.  
  
 [!code-csharp[ContainerVisualSnippets#ContainerVisualSnippet3](~/samples/snippets/csharp/VS_Snippets_Wpf/ContainerVisualSnippets/CSharp/Window1.xaml.cs#containervisualsnippet3)]
 [!code-vb[ContainerVisualSnippets#ContainerVisualSnippet3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContainerVisualSnippets/visualbasic/window1.xaml.vb#containervisualsnippet3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clip">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Geometry Clip { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Geometry Clip" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.Clip" />
      <MemberSignature Language="VB.NET" Value="Public Property Clip As Geometry" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Geometry ^ Clip { System::Windows::Media::Geometry ^ get(); void set(System::Windows::Media::Geometry ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Clip : System.Windows.Media.Geometry with get, set" Usage="System.Windows.Media.ContainerVisual.Clip" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Geometry</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Ausschneidebereich des <see cref="T:System.Windows.Media.ContainerVisual" /> ab oder legt diesen fest.</summary>
        <value>Die <see cref="T:System.Windows.Media.Geometry" />, die den Ausschneidebereich definiert.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.UIElement.Clip" />
      </Docs>
    </Member>
    <Member MemberName="ContentBounds">
      <MemberSignature Language="C#" Value="public System.Windows.Rect ContentBounds { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Rect ContentBounds" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.ContentBounds" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContentBounds As Rect" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Rect ContentBounds { System::Windows::Rect get(); };" />
      <MemberSignature Language="F#" Value="member this.ContentBounds : System.Windows.Rect" Usage="System.Windows.Media.ContainerVisual.ContentBounds" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Rect</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das umgebende Feld für den Inhalt des <see cref="T:System.Windows.Media.ContainerVisual" /> ab.</summary>
        <value>Ein <see cref="T:System.Windows.Rect" />, das das umgebende Feld angibt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Windows.Media.ContainerVisual.DescendantBounds%2A> Eigenschaft, um die Gesamtmenge aller umgebenden Felder für alle Nachfolgerelemente des des Inhalts zurückzugeben eine <xref:System.Windows.Media.ContainerVisual> -Objekt, aber nicht das Objekt selbst.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie das umschließende Rechteck des Abrufen einer <xref:System.Windows.Media.ContainerVisual> Objekt.  
  
 [!code-csharp[ContainerVisualSnippets#ContainerVisualSnippet4](~/samples/snippets/csharp/VS_Snippets_Wpf/ContainerVisualSnippets/CSharp/Window1.xaml.cs#containervisualsnippet4)]
 [!code-vb[ContainerVisualSnippets#ContainerVisualSnippet4](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContainerVisualSnippets/visualbasic/window1.xaml.vb#containervisualsnippet4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DescendantBounds">
      <MemberSignature Language="C#" Value="public System.Windows.Rect DescendantBounds { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Rect DescendantBounds" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.DescendantBounds" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DescendantBounds As Rect" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Rect DescendantBounds { System::Windows::Rect get(); };" />
      <MemberSignature Language="F#" Value="member this.DescendantBounds : System.Windows.Rect" Usage="System.Windows.Media.ContainerVisual.DescendantBounds" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Rect</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Gesamtmenge aller umgebenden Felder des Inhalts für alle Nachfolgerelemente des <see cref="T:System.Windows.Media.ContainerVisual" /> ab, doch ohne das umgebende Feld für den Inhalt des <see cref="T:System.Windows.Media.ContainerVisual" />.</summary>
        <value>Ein <see cref="T:System.Windows.Rect" />, das das umgebende Feld der Gesamtmenge angibt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Abrufen der <xref:System.Windows.Media.ContainerVisual.ContentBounds%2A> das zwischengespeicherte umgebende Rechteckfeld für die zurückzugebende Eigenschaft der <xref:System.Windows.Media.ContainerVisual> selbst.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie das umschließende Rechteck des Abrufen einer <xref:System.Windows.Media.ContainerVisual> Nachfolger des Objekts.  
  
 [!code-csharp[ContainerVisualSnippets#ContainerVisualSnippet4](~/samples/snippets/csharp/VS_Snippets_Wpf/ContainerVisualSnippets/CSharp/Window1.xaml.cs#containervisualsnippet4)]
 [!code-vb[ContainerVisualSnippets#ContainerVisualSnippet4](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContainerVisualSnippets/visualbasic/window1.xaml.vb#containervisualsnippet4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Effect">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Effects.Effect Effect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Effects.Effect Effect" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.Effect" />
      <MemberSignature Language="VB.NET" Value="Public Property Effect As Effect" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Effects::Effect ^ Effect { System::Windows::Media::Effects::Effect ^ get(); void set(System::Windows::Media::Effects::Effect ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Effect : System.Windows.Media.Effects.Effect with get, set" Usage="System.Windows.Media.ContainerVisual.Effect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Effects.Effect</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Bitmapeffekt ab, der auf das <see cref="T:System.Windows.Media.ContainerVisual" />-Objekt angewendet werden soll, oder legt ihn fest.</summary>
        <value>Ein <see cref="T:System.Windows.Media.Effects.Effect" />, der den Bitmapeffekt darstellt.</value>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.Media.Effects.Effect" />
        <altmember cref="T:System.Windows.Media.Effects.ShaderEffect" />
      </Docs>
    </Member>
    <Member MemberName="GetVisualChild">
      <MemberSignature Language="C#" Value="protected override sealed System.Windows.Media.Visual GetVisualChild (int index);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Media.Visual GetVisualChild(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.ContainerVisual.GetVisualChild(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Function GetVisualChild (index As Integer) As Visual" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Media::Visual ^ GetVisualChild(int index);" />
      <MemberSignature Language="F#" Value="override this.GetVisualChild : int -&gt; System.Windows.Media.Visual" Usage="containerVisual.GetVisualChild index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Visual</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Eine 32-Bit-Ganzzahl mit Vorzeichen, die den Indexwert des untergeordneten <see cref="T:System.Windows.Media.Visual" /> darstellt. Der Wert von <c>index</c> muss zwischen 0 und <see cref="P:System.Windows.Media.ContainerVisual.VisualChildrenCount" /> –1 liegen.</param>
        <summary>Gibt ein angegebenes untergeordnetes <see cref="T:System.Windows.Media.Visual" /> für das übergeordnete <see cref="T:System.Windows.Media.ContainerVisual" /> zurück.</summary>
        <returns>Das untergeordnete <see cref="T:System.Windows.Media.Visual" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardmäßig eine <xref:System.Windows.Media.ContainerVisual> verfügt nicht über alle untergeordneten Elemente.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie erstellen eine <xref:System.Windows.Media.ContainerVisual> -Objekt, das als übergeordnetes Element, für zwei verwendet wird <xref:System.Windows.Media.DrawingVisual> Objekte. Objekte, die hinzugefügt werden, die <xref:System.Windows.Media.ContainerVisual> Objekt muss in umgekehrter Z-Reihenfolge (von unten nach oben) hinzugefügt werden, um sicherzustellen, dass sie in der richtigen Zeichnungsreihenfolge gerendert werden. In der Reihenfolge für die visuelle Struktur ordnungsgemäß aufgelistet werden sollen, das Beispiel enthält den überschriebene Implementierungen der <xref:System.Windows.Media.ContainerVisual.GetVisualChild%2A> Methode und <xref:System.Windows.Media.ContainerVisual.VisualChildrenCount%2A> Eigenschaft.  
  
 [!code-csharp[ContainerVisualHost#ContainerVisualHost01](~/samples/snippets/csharp/VS_Snippets_Wpf/ContainerVisualHost/CSharp/Window1.xaml.cs#containervisualhost01)]
 [!code-vb[ContainerVisualHost#ContainerVisualHost01](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContainerVisualHost/visualbasic/window1.xaml.vb#containervisualhost01)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Die visuelle Struktur kann nicht geändert werden, während dieses Aufrufs.</para>
        </block>
        <altmember cref="P:System.Windows.Media.ContainerVisual.VisualChildrenCount" />
      </Docs>
    </Member>
    <MemberGroup MemberName="HitTest">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt das oberste visuelle Objekt eines Treffertests zurück.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="HitTest">
      <MemberSignature Language="C#" Value="public System.Windows.Media.HitTestResult HitTest (System.Windows.Point point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Media.HitTestResult HitTest(valuetype System.Windows.Point point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.ContainerVisual.HitTest(System.Windows.Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::HitTestResult ^ HitTest(System::Windows::Point point);" />
      <MemberSignature Language="F#" Value="override this.HitTest : System.Windows.Point -&gt; System.Windows.Media.HitTestResult" Usage="containerVisual.HitTest point" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.HitTestResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Windows.Point" />
      </Parameters>
      <Docs>
        <param name="point">Der Punktwert, für den ein Treffertest ausgeführt werden soll.</param>
        <summary>Gibt durch Angeben von <see cref="T:System.Windows.Point" /> das oberste visuelle Objekt eines Treffertests zurück.</summary>
        <returns>Das als <see cref="T:System.Windows.Media.HitTestResult" />-Typ zurückgegebene Ergebnis des Treffertests.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Media.HitTestResult.VisualHit%2A> -Eigenschaft des Rückgabewerts darstellt der <xref:System.Windows.Media.Visual> Objekt, das ermittelt wurde.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt das Abrufen der <xref:System.Windows.Media.HitTestResult> Rückgabewert aus der <xref:System.Windows.Media.ContainerVisual.HitTest%2A> Methode.  
  
 [!code-csharp[ContainerVisualSnippets#ContainerVisualSnippet2](~/samples/snippets/csharp/VS_Snippets_Wpf/ContainerVisualSnippets/CSharp/Window1.xaml.cs#containervisualsnippet2)]
 [!code-vb[ContainerVisualSnippets#ContainerVisualSnippet2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContainerVisualSnippets/visualbasic/window1.xaml.vb#containervisualsnippet2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HitTest">
      <MemberSignature Language="C#" Value="public void HitTest (System.Windows.Media.HitTestFilterCallback filterCallback, System.Windows.Media.HitTestResultCallback resultCallback, System.Windows.Media.HitTestParameters hitTestParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void HitTest(class System.Windows.Media.HitTestFilterCallback filterCallback, class System.Windows.Media.HitTestResultCallback resultCallback, class System.Windows.Media.HitTestParameters hitTestParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.ContainerVisual.HitTest(System.Windows.Media.HitTestFilterCallback,System.Windows.Media.HitTestResultCallback,System.Windows.Media.HitTestParameters)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void HitTest(System::Windows::Media::HitTestFilterCallback ^ filterCallback, System::Windows::Media::HitTestResultCallback ^ resultCallback, System::Windows::Media::HitTestParameters ^ hitTestParameters);" />
      <MemberSignature Language="F#" Value="override this.HitTest : System.Windows.Media.HitTestFilterCallback * System.Windows.Media.HitTestResultCallback * System.Windows.Media.HitTestParameters -&gt; unit" Usage="containerVisual.HitTest (filterCallback, resultCallback, hitTestParameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filterCallback" Type="System.Windows.Media.HitTestFilterCallback" />
        <Parameter Name="resultCallback" Type="System.Windows.Media.HitTestResultCallback" />
        <Parameter Name="hitTestParameters" Type="System.Windows.Media.HitTestParameters" />
      </Parameters>
      <Docs>
        <param name="filterCallback">Der Delegat, der es Ihnen ermöglicht, in den Treffertestergebnissen die Teile der visuellen Struktur zu ignorieren, die nicht verarbeitet werden sollen.</param>
        <param name="resultCallback">Der Delegat, mit dem die Rückgabe der Treffertestinformationen gesteuert wird.</param>
        <param name="hitTestParameters">Definiert den Satz von Parametern für einen Treffertest.</param>
        <summary>Initialisiert einen Treffertest für das <see cref="T:System.Windows.Media.ContainerVisual" />-Objekt, indem das <see cref="T:System.Windows.Media.HitTestFilterCallback" />- und das <see cref="T:System.Windows.Media.HitTestResultCallback" />-Objekt verwendet werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `filterCallback` Parameter kann null sein. in diesem Fall wird es ignoriert. Wenn `filterCallback` nicht `null`, er wird aufgerufen, bevor Sie `resultCallback`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Offset">
      <MemberSignature Language="C#" Value="public System.Windows.Vector Offset { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Vector Offset" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.Offset" />
      <MemberSignature Language="VB.NET" Value="Public Property Offset As Vector" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Vector Offset { System::Windows::Vector get(); void set(System::Windows::Vector value); };" />
      <MemberSignature Language="F#" Value="member this.Offset : System.Windows.Vector with get, set" Usage="System.Windows.Media.ContainerVisual.Offset" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Vector</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Wert für den Offset des <see cref="T:System.Windows.Media.ContainerVisual" /> von seinem Bezugspunkt ab oder legt diesen fest.</summary>
        <value>Ein <see cref="T:System.Windows.Vector" />, der den Offsetwert des <see cref="T:System.Windows.Media.ContainerVisual" /> darstellt.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Opacity">
      <MemberSignature Language="C#" Value="public double Opacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Opacity" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.Opacity" />
      <MemberSignature Language="VB.NET" Value="Public Property Opacity As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Opacity { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.Opacity : double with get, set" Usage="System.Windows.Media.ContainerVisual.Opacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Durchlässigkeit des <see cref="T:System.Windows.Media.ContainerVisual" /> ab oder legt diese fest, wobei 0=transparent und 1=undurchlässig ist.</summary>
        <value>Ein Wert von 0 bis 1, der einen Bereich von vollkommen transparent bis vollkommen undurchlässig angibt. Der Wert 0 gibt an, dass das <see cref="T:System.Windows.Media.ContainerVisual" /> vollkommen transparent ist, während der Wert 1 angibt, dass das <see cref="T:System.Windows.Media.ContainerVisual" /> vollkommen undurchlässig ist. Der Wert 0,5 gibt an, dass das Element zu 50 Prozent undurchlässig ist, der Wert 0,725 gibt an, dass es zu 72,5 Prozent undurchlässig ist usw. Kleinere Werte als 0 werden als 0 behandelt, größere Werte als 1 als 1.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.UIElement.Opacity" />
      </Docs>
    </Member>
    <Member MemberName="OpacityMask">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Brush OpacityMask { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Brush OpacityMask" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.OpacityMask" />
      <MemberSignature Language="VB.NET" Value="Public Property OpacityMask As Brush" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Brush ^ OpacityMask { System::Windows::Media::Brush ^ get(); void set(System::Windows::Media::Brush ^ value); };" />
      <MemberSignature Language="F#" Value="member this.OpacityMask : System.Windows.Media.Brush with get, set" Usage="System.Windows.Media.ContainerVisual.OpacityMask" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Brush</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Pinsel ab, der eine mögliche Durchlässigkeitsmaske für das <see cref="T:System.Windows.Media.ContainerVisual" /> angibt, oder legt diesen fest.</summary>
        <value>Ein Wert vom Typ <see cref="T:System.Windows.Media.Brush" />, der den Wert für die Durchlässigkeitsmaske des <see cref="T:System.Windows.Media.ContainerVisual" /> darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Deckkraftmasken können verwendet werden, um Effekte wie z. B. korrigieren, basierend auf den Werten der Alphakanal des Pinsels zu erstellen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ Parent { System::Windows::DependencyObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.Windows.DependencyObject" Usage="System.Windows.Media.ContainerVisual.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das übergeordnete <see cref="T:System.Windows.Media.Visual" /> für das <see cref="T:System.Windows.Media.ContainerVisual" /> ab.</summary>
        <value>Das übergeordnete Element des visuellen Objekts.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beachten Sie, die dies als zurückgegeben wird <xref:System.Windows.DependencyObject>, anstatt eine "rohen" Objekt.  
  
 Diese Eigenschaft möglicherweise zurück `null` in einer nicht verbundenen Struktur, oder wenn Sie auf den Stamm der Struktur auf der Ebene des Fensters durchlaufen haben.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Transform">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Transform Transform { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Transform Transform" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.Transform" />
      <MemberSignature Language="VB.NET" Value="Public Property Transform As Transform" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Transform ^ Transform { System::Windows::Media::Transform ^ get(); void set(System::Windows::Media::Transform ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Transform : System.Windows.Media.Transform with get, set" Usage="System.Windows.Media.ContainerVisual.Transform" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Transform</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die auf das <see cref="T:System.Windows.Media.ContainerVisual" /> angewendete Transformation ab oder legt diese fest.</summary>
        <value>Der Transformationswert.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.Transform> ist eine Basisklasse, die viele verschiedene Arten der Transformationen vereinheitlicht. Ausführliche Informationen finden Sie unter <xref:System.Windows.Media.Transform>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualChildrenCount">
      <MemberSignature Language="C#" Value="protected override sealed int VisualChildrenCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 VisualChildrenCount" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.VisualChildrenCount" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable ReadOnly Property VisualChildrenCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property int VisualChildrenCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.VisualChildrenCount : int" Usage="System.Windows.Media.ContainerVisual.VisualChildrenCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anzahl der untergeordneten Elemente für das <see cref="T:System.Windows.Media.ContainerVisual" /> ab.</summary>
        <value>Die Anzahl der untergeordneten Elemente in der <see cref="T:System.Windows.Media.VisualCollection" /> des <see cref="T:System.Windows.Media.ContainerVisual" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardmäßig eine <xref:System.Windows.Media.ContainerVisual> verfügt nicht über alle untergeordneten Elemente.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie erstellen eine <xref:System.Windows.Media.ContainerVisual> -Objekt, das als übergeordnetes Element, für zwei verwendet wird <xref:System.Windows.Media.DrawingVisual> Objekte. Objekte, die hinzugefügt werden, die <xref:System.Windows.Media.ContainerVisual> Objekt muss in umgekehrter Z-Reihenfolge (von unten nach oben) hinzugefügt werden, um sicherzustellen, dass sie in der richtigen Zeichnungsreihenfolge gerendert werden. In der Reihenfolge für die visuelle Struktur ordnungsgemäß aufgelistet werden sollen, das Beispiel enthält den überschriebene Implementierungen der <xref:System.Windows.Media.ContainerVisual.GetVisualChild%2A> Methode und <xref:System.Windows.Media.ContainerVisual.VisualChildrenCount%2A> Eigenschaft.  
  
 [!code-csharp[ContainerVisualHost#ContainerVisualHost01](~/samples/snippets/csharp/VS_Snippets_Wpf/ContainerVisualHost/CSharp/Window1.xaml.cs#containervisualhost01)]
 [!code-vb[ContainerVisualHost#ContainerVisualHost01](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContainerVisualHost/visualbasic/window1.xaml.vb#containervisualhost01)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Abgeleitete Klassen <see cref="T:System.Windows.Media.ContainerVisual" /> müssen implementieren die <see cref="P:System.Windows.Media.ContainerVisual.VisualChildrenCount" /> Eigenschaft zum Auflisten der untergeordneten visuellen Elemente. Die abgeleitete Eigenschaft muss die Anzahl der untergeordneten Elemente für Zurückgeben der <see cref="T:System.Windows.Media.ContainerVisual" />.  
  
Die visuelle Struktur kann nicht geändert werden, während dieses Aufrufs.</para>
        </block>
        <altmember cref="M:System.Windows.Media.ContainerVisual.GetVisualChild(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="XSnappingGuidelines">
      <MemberSignature Language="C#" Value="public System.Windows.Media.DoubleCollection XSnappingGuidelines { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.DoubleCollection XSnappingGuidelines" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.XSnappingGuidelines" />
      <MemberSignature Language="VB.NET" Value="Public Property XSnappingGuidelines As DoubleCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::DoubleCollection ^ XSnappingGuidelines { System::Windows::Media::DoubleCollection ^ get(); void set(System::Windows::Media::DoubleCollection ^ value); };" />
      <MemberSignature Language="F#" Value="member this.XSnappingGuidelines : System.Windows.Media.DoubleCollection with get, set" Usage="System.Windows.Media.ContainerVisual.XSnappingGuidelines" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.DoubleCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die (horizontale) x-Führungslinie für das <see cref="T:System.Windows.Media.ContainerVisual" /> ab oder legt diese fest.</summary>
        <value>Die horizontale Führungslinie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pixelausrichtung ist der Prozess, der in dem Inhaltslayout behoben wird, sodass Objektkanten gerätespezifischen Pixel gerendert werden. Das [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]-Grafiksystem verwendet geräteunabhängige Einheiten, um die Unabhängigkeit von der Auflösung und vom Gerät zu aktivieren. Jedes geräteunabhängige Pixel skaliert automatisch mit der [!INCLUDE[TLA#tla_dpi](~/includes/tlasharptla-dpi-md.md)]-Einstellung des Systems. Dadurch wird die ordnungsgemäße Skalierung von [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]-Anwendungen für unterschiedliche [!INCLUDE[TLA2#tla_dpi](~/includes/tla2sharptla-dpi-md.md)]-Einstellungen bereitgestellt, und die Anwendung ist automatisch bereit für [!INCLUDE[TLA2#tla_dpi](~/includes/tla2sharptla-dpi-md.md)].  
  
 Aber dies [!INCLUDE[TLA2#tla_dpi](~/includes/tla2sharptla-dpi-md.md)] Unabhängigkeit kann unregelmäßiges Edge-Rendering aufgrund von Antialiasing erstellen. Diese Artefakte, die häufig als "soft" oder unscharf Kanten betrachtet können auftreten, wenn die Position eines Rands in der Mitte eines Gerätepixels anstatt zwischen die Gerätepixel fällt. Um dieses Problem zu beheben [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] bietet eine Möglichkeit für Objektkanten in einer visuellen Struktur über die pixelausrichtung, an "ausgerichtet" beseitigen der weichen Kanten erzeugten Anti-Aliasing.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.ContainerVisual.YSnappingGuidelines" />
      </Docs>
    </Member>
    <Member MemberName="YSnappingGuidelines">
      <MemberSignature Language="C#" Value="public System.Windows.Media.DoubleCollection YSnappingGuidelines { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.DoubleCollection YSnappingGuidelines" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.YSnappingGuidelines" />
      <MemberSignature Language="VB.NET" Value="Public Property YSnappingGuidelines As DoubleCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::DoubleCollection ^ YSnappingGuidelines { System::Windows::Media::DoubleCollection ^ get(); void set(System::Windows::Media::DoubleCollection ^ value); };" />
      <MemberSignature Language="F#" Value="member this.YSnappingGuidelines : System.Windows.Media.DoubleCollection with get, set" Usage="System.Windows.Media.ContainerVisual.YSnappingGuidelines" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.DoubleCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die (vertikale) Y-Führungslinie für das <see cref="T:System.Windows.Media.ContainerVisual" /> ab oder legt diese fest.</summary>
        <value>Die vertikale Führungslinie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pixelausrichtung ist der Prozess, der in dem Inhaltslayout behoben wird, sodass Objektkanten gerätespezifischen Pixel gerendert werden. Das [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]-Grafiksystem verwendet geräteunabhängige Einheiten, um die Unabhängigkeit von der Auflösung und vom Gerät zu aktivieren. Jedes geräteunabhängige Pixel skaliert automatisch mit der [!INCLUDE[TLA#tla_dpi](~/includes/tlasharptla-dpi-md.md)]-Einstellung des Systems. Dadurch wird die ordnungsgemäße Skalierung von [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]-Anwendungen für unterschiedliche [!INCLUDE[TLA2#tla_dpi](~/includes/tla2sharptla-dpi-md.md)]-Einstellungen bereitgestellt, und die Anwendung ist automatisch bereit für [!INCLUDE[TLA2#tla_dpi](~/includes/tla2sharptla-dpi-md.md)].  
  
 Aber dies [!INCLUDE[TLA2#tla_dpi](~/includes/tla2sharptla-dpi-md.md)] Unabhängigkeit kann unregelmäßiges Edge-Rendering aufgrund von Antialiasing erstellen. Diese Artefakte, die häufig als "soft" oder unscharf Kanten betrachtet können auftreten, wenn die Position eines Rands in der Mitte eines Gerätepixels anstatt zwischen die Gerätepixel fällt. Um dieses Problem zu beheben [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] bietet eine Möglichkeit für Objektkanten in einer visuellen Struktur über die pixelausrichtung, an "ausgerichtet" beseitigen der weichen Kanten erzeugten Anti-Aliasing.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.ContainerVisual.XSnappingGuidelines" />
      </Docs>
    </Member>
  </Members>
</Type>