<Type Name="RenderOptions" FullName="System.Windows.Media.RenderOptions">
  <Metadata><Meta Name="ms.openlocfilehash" Value="2dc182b849772f6867103703fc5543c4da508f0c" /><Meta Name="ms.sourcegitcommit" Value="8ae9a18b248625c8e1851e607c00346a64849587" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="12/17/2019" /><Meta Name="ms.locfileid" Value="75179602" /></Metadata><TypeSignature Language="C#" Value="public static class RenderOptions" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit RenderOptions extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Media.RenderOptions" />
  <TypeSignature Language="VB.NET" Value="Public Class RenderOptions" />
  <TypeSignature Language="C++ CLI" Value="public ref class RenderOptions abstract sealed" />
  <TypeSignature Language="F#" Value="type RenderOptions = class" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Stellt Optionen zum Steuern des Renderingverhaltens von Objekten bereit.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können die angefügten Eigenschaften der <xref:System.Windows.Media.RenderOptions>-Klasse verwenden, um Optionen für das Rendering von Text-und visuellen Elementen in der WPF-Anwendung anzugeben. Diese Optionen ermöglichen es Ihnen, das Rendering für Geschwindigkeit oder Qualität zu optimieren.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Media.RenderCapability" />
    <related type="Article" href="https://msdn.microsoft.com/library/67cafaad-57ad-4ecb-9c08-57fac144393e">Leistungs Profilerstellungstools für WPF</related>
  </Docs>
  <Members>
    <Member MemberName="BitmapScalingMode">
      <MemberSignature Language="C#" Value="see GetBitmapScalingMode, and SetBitmapScalingMode" />
      <MemberSignature Language="ILAsm" Value="see GetBitmapScalingMode, and SetBitmapScalingMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.RenderOptions.BitmapScalingMode" />
      <MemberSignature Language="VB.NET" Value="see GetBitmapScalingMode, and SetBitmapScalingMode" />
      <MemberSignature Language="F#" Value="see GetBitmapScalingMode, and SetBitmapScalingMode" Usage="see GetBitmapScalingMode, and SetBitmapScalingMode" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft den <see cref="T:System.Windows.Media.BitmapScalingMode" /> für ein angegebenes <see cref="T:System.Windows.DependencyObject" /> ab oder legt diesen fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie die <xref:System.Windows.Media.RenderOptions.BitmapScalingMode%2A>-Eigenschaft auf einem <xref:System.Windows.UIElement> oder <xref:System.Windows.Media.DrawingGroup> Nachfolger, der eine Bitmap animiert.  
  
 Beim Animieren der Skalierung von Bitmaps kann der Standardalgorithmus für das Resampling von Bildern hoher Qualität zuweilen einen solchen Umfang an Systemressourcen beanspruchen, dass eine Verringerung der Einzelbildrate auftritt und Animationen ruckartig wiedergegeben werden. Wenn Sie die <xref:System.Windows.Media.RenderOptions.BitmapScalingMode%2A>-Eigenschaft auf <xref:System.Windows.Media.BitmapScalingMode.LowQuality?displayProperty=nameWithType>festlegen, können Sie eine reibungslosere Animation beim Skalieren einer Bitmap erstellen.  
  
 Wenn Sie auf diese Eigenschaft im Code zugreifen möchten, verwenden Sie die Methoden <xref:System.Windows.Media.RenderOptions.GetBitmapScalingMode%2A> und <xref:System.Windows.Media.RenderOptions.SetBitmapScalingMode%2A>.  
  
<a name="dependencyPropertyInfo_BitmapScalingMode"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Media.RenderOptions.BitmapScalingModeProperty>|  
|Metadateneigenschaften auf `true` festgelegt|Keine|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.RenderOptions.GetBitmapScalingMode(System.Windows.DependencyObject)" />
        <altmember cref="M:System.Windows.Media.RenderOptions.SetBitmapScalingMode(System.Windows.DependencyObject,System.Windows.Media.BitmapScalingMode)" />
      </Docs>
    </Member>
    <Member MemberName="BitmapScalingModeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BitmapScalingModeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BitmapScalingModeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Media.RenderOptions.BitmapScalingModeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BitmapScalingModeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BitmapScalingModeProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable BitmapScalingModeProperty : System.Windows.DependencyProperty" Usage="System.Windows.Media.RenderOptions.BitmapScalingModeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die angefügte <see cref="P:System.Windows.Media.RenderOptions.BitmapScalingMode" />-Eigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CacheInvalidationThresholdMaximum">
      <MemberSignature Language="C#" Value="see GetCacheInvalidationThresholdMaximum, and SetCacheInvalidationThresholdMaximum" />
      <MemberSignature Language="ILAsm" Value="see GetCacheInvalidationThresholdMaximum, and SetCacheInvalidationThresholdMaximum" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMaximum" />
      <MemberSignature Language="VB.NET" Value="see GetCacheInvalidationThresholdMaximum, and SetCacheInvalidationThresholdMaximum" />
      <MemberSignature Language="F#" Value="see GetCacheInvalidationThresholdMaximum, and SetCacheInvalidationThresholdMaximum" Usage="see GetCacheInvalidationThresholdMaximum, and SetCacheInvalidationThresholdMaximum" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft den oberen Cacheaufhebungs-Schwellenwert für ein angegebenes <see cref="T:System.Windows.DependencyObject" /> ab oder legt diesen fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese angefügte Eigenschaft wird von <xref:System.Windows.Media.TileBrush> und den abgeleiteten Typen unterstützt. Es ist für die Verwendung mit Pinseln vorgesehen, die zwischen Flächen wie <xref:System.Windows.Media.DrawingBrush> und <xref:System.Windows.Media.VisualBrush>haben. Dies hat nur Auswirkungen, wenn die <xref:System.Windows.Media.RenderOptions.CachingHint%2A>-Eigenschaft auf <xref:System.Windows.Media.CachingHint.Cache>festgelegt ist.  
  
 Standardmäßig speichert [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] den gerenderten Inhalt von <xref:System.Windows.Media.DrawingBrush>-und <xref:System.Windows.Media.VisualBrush>-Objekten nicht zwischen. In statischen Szenarios, in denen weder der Inhalt noch die Verwendung des Pinsels in der Szene geändert wird, bietet das Zwischenspeichern des Inhalts einen Vorteil, da er Videospeicher speichert. Wenn ein Pinsel mit statischem Inhalt auf nicht statische Weise verwendet wird, besteht das Standardverhalten von [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] darin, den gesamten Inhalt des Pinsels jedes Frame wiederzugeben, auch wenn sich der Inhalt ändert. Dies geschieht z. b., wenn ein statischer <xref:System.Windows.Media.DrawingBrush> oder <xref:System.Windows.Media.VisualBrush> der Oberfläche eines rotierenden 3D-Objekts zugeordnet wird. Das erneute Rendern des statischen Inhalts kann sich negativ auf die Leistung auswirken.  
  
 Durch Festlegen der <xref:System.Windows.Media.RenderOptions.CachingHint%2A> angefügten-Eigenschaft des Pinsels auf <xref:System.Windows.Media.CachingHint.Cache>können Sie die Leistung mithilfe von zwischengespeicherten Versionen der gekachelten Pinsel Objekte steigern.  
  
 Die <xref:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMinimum%2A>-und <xref:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMaximum%2A>-Eigenschaftswerte sind Werte relativer Größe, die bestimmen, wann das <xref:System.Windows.Media.TileBrush>-Objekt aufgrund von Skalierungs Änderungen erneut generiert werden soll. Wenn die <xref:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMaximum%2A>-Eigenschaft z. b. auf 2,0 festgelegt ist, muss der Cache für die <xref:System.Windows.Media.TileBrush> nur dann erneut generiert werden, wenn die Größe das Zweifache des aktuellen Caches überschreitet.  
  
 Wenn Sie auf diese Eigenschaft im Code zugreifen möchten, verwenden Sie die Methoden <xref:System.Windows.Media.RenderOptions.GetCacheInvalidationThresholdMaximum%2A> und <xref:System.Windows.Media.RenderOptions.SetCacheInvalidationThresholdMaximum%2A>.  
  
<a name="dependencyPropertyInfo_CacheInvalidationThresholdMaximum"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMaximumProperty>|  
|Metadateneigenschaften auf `true` festgelegt|Keine|  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie Sie die Option Caching Hint für eine <xref:System.Windows.Media.DrawingBrush>verwenden.  
  
 [!code-xml[RenderOptions#CachingXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/RenderOptions/CSharp/Window1.xaml#cachingxaml)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.RenderOptions.GetCacheInvalidationThresholdMaximum(System.Windows.DependencyObject)" />
        <altmember cref="M:System.Windows.Media.RenderOptions.SetCacheInvalidationThresholdMaximum(System.Windows.DependencyObject,System.Double)" />
        <altmember cref="P:System.Windows.Media.RenderOptions.CachingHint" />
      </Docs>
    </Member>
    <Member MemberName="CacheInvalidationThresholdMaximumProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CacheInvalidationThresholdMaximumProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CacheInvalidationThresholdMaximumProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMaximumProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CacheInvalidationThresholdMaximumProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CacheInvalidationThresholdMaximumProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CacheInvalidationThresholdMaximumProperty : System.Windows.DependencyProperty" Usage="System.Windows.Media.RenderOptions.CacheInvalidationThresholdMaximumProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die angefügte <see cref="P:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMaximum" />-Eigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CacheInvalidationThresholdMinimum">
      <MemberSignature Language="C#" Value="see GetCacheInvalidationThresholdMinimum, and SetCacheInvalidationThresholdMinimum" />
      <MemberSignature Language="ILAsm" Value="see GetCacheInvalidationThresholdMinimum, and SetCacheInvalidationThresholdMinimum" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMinimum" />
      <MemberSignature Language="VB.NET" Value="see GetCacheInvalidationThresholdMinimum, and SetCacheInvalidationThresholdMinimum" />
      <MemberSignature Language="F#" Value="see GetCacheInvalidationThresholdMinimum, and SetCacheInvalidationThresholdMinimum" Usage="see GetCacheInvalidationThresholdMinimum, and SetCacheInvalidationThresholdMinimum" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft den unteren Cacheaufhebungs-Schwellenwert für ein angegebenes <see cref="T:System.Windows.DependencyObject" /> ab oder legt diesen fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese angefügte Eigenschaft wird von <xref:System.Windows.Media.TileBrush> und den abgeleiteten Typen unterstützt. Es ist für die Verwendung mit Pinseln vorgesehen, die zwischen Flächen wie <xref:System.Windows.Media.DrawingBrush> und <xref:System.Windows.Media.VisualBrush>haben. Dies hat nur Auswirkungen, wenn die <xref:System.Windows.Media.RenderOptions.CachingHint%2A>-Eigenschaft auf <xref:System.Windows.Media.CachingHint.Cache>festgelegt ist.  
  
 Standardmäßig speichert [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] den gerenderten Inhalt von <xref:System.Windows.Media.DrawingBrush>-und <xref:System.Windows.Media.VisualBrush>-Objekten nicht zwischen. In statischen Szenarios, in denen weder der Inhalt noch die Verwendung des Pinsels in der Szene geändert wird, bietet das Zwischenspeichern des Inhalts einen Vorteil, da er Videospeicher speichert. Wenn ein Pinsel mit statischem Inhalt auf nicht statische Weise verwendet wird, besteht das Standardverhalten von [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] darin, den gesamten Inhalt des Pinsels jedes Frame wiederzugeben, auch wenn sich der Inhalt ändert. Dies geschieht z. b., wenn ein statischer <xref:System.Windows.Media.DrawingBrush> oder <xref:System.Windows.Media.VisualBrush> der Oberfläche eines rotierenden 3D-Objekts zugeordnet wird. Das erneute Rendern des statischen Inhalts kann sich negativ auf die Leistung auswirken.  
  
 Durch Festlegen der <xref:System.Windows.Media.RenderOptions.CachingHint%2A> angefügten-Eigenschaft des Pinsels auf <xref:System.Windows.Media.CachingHint.Cache>können Sie die Leistung mithilfe von zwischengespeicherten Versionen der gekachelten Pinsel Objekte steigern.  
  
 Die <xref:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMinimum%2A>-und <xref:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMaximum%2A>-Eigenschaftswerte sind Werte relativer Größe, die bestimmen, wann das <xref:System.Windows.Media.TileBrush>-Objekt aufgrund von Skalierungs Änderungen erneut generiert werden soll. Wenn die <xref:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMinimum%2A>-Eigenschaft beispielsweise auf 0,5 festgelegt ist, muss der Cache für die <xref:System.Windows.Media.TileBrush> nur dann erneut generiert werden, wenn ihre Größe auf weniger als eine halbe Hälfte der aktuellen Cache Größe reduziert wird.  
  
 Wenn Sie auf diese Eigenschaft im Code zugreifen möchten, verwenden Sie die Methoden <xref:System.Windows.Media.RenderOptions.GetCacheInvalidationThresholdMinimum%2A> und <xref:System.Windows.Media.RenderOptions.SetCacheInvalidationThresholdMinimum%2A>.  
  
<a name="dependencyPropertyInfo_CacheInvalidationThresholdMinimum"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMinimumProperty>|  
|Metadateneigenschaften auf `true` festgelegt|Keine|  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie Sie die Option Caching Hint für eine <xref:System.Windows.Media.DrawingBrush>verwenden.  
  
 [!code-xml[RenderOptions#CachingXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/RenderOptions/CSharp/Window1.xaml#cachingxaml)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.RenderOptions.GetCacheInvalidationThresholdMinimum(System.Windows.DependencyObject)" />
        <altmember cref="M:System.Windows.Media.RenderOptions.SetCacheInvalidationThresholdMinimum(System.Windows.DependencyObject,System.Double)" />
        <altmember cref="P:System.Windows.Media.RenderOptions.CachingHint" />
      </Docs>
    </Member>
    <Member MemberName="CacheInvalidationThresholdMinimumProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CacheInvalidationThresholdMinimumProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CacheInvalidationThresholdMinimumProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMinimumProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CacheInvalidationThresholdMinimumProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CacheInvalidationThresholdMinimumProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CacheInvalidationThresholdMinimumProperty : System.Windows.DependencyProperty" Usage="System.Windows.Media.RenderOptions.CacheInvalidationThresholdMinimumProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die angefügte <see cref="P:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMinimum" />-Eigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CachingHint">
      <MemberSignature Language="C#" Value="see GetCachingHint, and SetCachingHint" />
      <MemberSignature Language="ILAsm" Value="see GetCachingHint, and SetCachingHint" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.RenderOptions.CachingHint" />
      <MemberSignature Language="VB.NET" Value="see GetCachingHint, and SetCachingHint" />
      <MemberSignature Language="F#" Value="see GetCachingHint, and SetCachingHint" Usage="see GetCachingHint, and SetCachingHint" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, dass die dargestellten Inhalte sofern möglich zwischengespeichert werden sollen, oder legt diesen fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese angefügte Eigenschaft wird von <xref:System.Windows.Media.TileBrush> und den abgeleiteten Typen unterstützt. Es ist für die Verwendung mit Pinseln vorgesehen, die zwischen Flächen wie <xref:System.Windows.Media.DrawingBrush> und <xref:System.Windows.Media.VisualBrush>haben.  
  
 Standardmäßig speichert [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] den gerenderten Inhalt von <xref:System.Windows.Media.DrawingBrush>-und <xref:System.Windows.Media.VisualBrush>-Objekten nicht zwischen. In statischen Szenarios, in denen weder der Inhalt noch die Verwendung des Pinsels in der Szene geändert wird, bietet das Caching keinen Vorteil, da es Videospeicher bietet. Wenn ein Pinsel mit statischem Inhalt auf nicht statische Weise verwendet wird, besteht das Standardverhalten von [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] darin, den gesamten Inhalt des Pinsels jedes Frame wiederzugeben, auch wenn sich der Inhalt ändert. Dies geschieht z. b., wenn ein statischer <xref:System.Windows.Media.DrawingBrush> oder <xref:System.Windows.Media.VisualBrush> der Oberfläche eines rotierenden 3D-Objekts zugeordnet wird. Das erneute Rendern des statischen Inhalts kann sich negativ auf die Leistung auswirken.  
  
 Durch Festlegen der <xref:System.Windows.Media.RenderOptions.CachingHint%2A> angefügten-Eigenschaft des Pinsels auf <xref:System.Windows.Media.CachingHint.Cache>können Sie die Leistung mithilfe von zwischengespeicherten Versionen der gekachelten Pinsel Objekte steigern.  
  
 Die <xref:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMinimum%2A>-und <xref:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMaximum%2A>-Eigenschaftswerte sind Werte relativer Größe, die bestimmen, wann das <xref:System.Windows.Media.TileBrush>-Objekt aufgrund von Skalierungs Änderungen erneut generiert werden soll. Wenn die <xref:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMaximum%2A>-Eigenschaft z. b. auf 2,0 festgelegt ist, muss der Cache für die <xref:System.Windows.Media.TileBrush> nur dann erneut generiert werden, wenn die Größe das Zweifache des aktuellen Caches überschreitet.  
  
 Wenn Sie auf diese Eigenschaft im Code zugreifen möchten, verwenden Sie die Methoden <xref:System.Windows.Media.RenderOptions.GetCachingHint%2A> und <xref:System.Windows.Media.RenderOptions.SetCachingHint%2A>.  
  
<a name="dependencyPropertyInfo_CachingHint"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Media.RenderOptions.CachingHintProperty>|  
|Metadateneigenschaften auf `true` festgelegt|Keine|  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie Sie die Option Caching Hint für eine <xref:System.Windows.Media.DrawingBrush>verwenden.  
  
 [!code-xml[RenderOptions#CachingXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/RenderOptions/CSharp/Window1.xaml#cachingxaml)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.RenderOptions.GetCachingHint(System.Windows.DependencyObject)" />
        <altmember cref="M:System.Windows.Media.RenderOptions.SetCachingHint(System.Windows.DependencyObject,System.Windows.Media.CachingHint)" />
        <altmember cref="P:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMinimum" />
        <altmember cref="P:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMaximum" />
      </Docs>
    </Member>
    <Member MemberName="CachingHintProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CachingHintProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CachingHintProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Media.RenderOptions.CachingHintProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CachingHintProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CachingHintProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CachingHintProperty : System.Windows.DependencyProperty" Usage="System.Windows.Media.RenderOptions.CachingHintProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die angefügte <see cref="P:System.Windows.Media.RenderOptions.CachingHint" />-Eigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearTypeHint">
      <MemberSignature Language="C#" Value="see GetClearTypeHint, and SetClearTypeHint" />
      <MemberSignature Language="ILAsm" Value="see GetClearTypeHint, and SetClearTypeHint" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.RenderOptions.ClearTypeHint" />
      <MemberSignature Language="VB.NET" Value="see GetClearTypeHint, and SetClearTypeHint" />
      <MemberSignature Language="F#" Value="see GetClearTypeHint, and SetClearTypeHint" Usage="see GetClearTypeHint, and SetClearTypeHint" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft einen Wert ab, der für die Rendering-Engine angibt, ob Text mit ClearType gerendert werden kann, oder legt diesen fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie die <xref:System.Windows.Media.RenderOptions.ClearTypeHint%2A> angefügte-Eigenschaft, um anzugeben, dass Text in einem bestimmten Teil der visuellen Struktur mit ClearType gerendert werden kann.  
  
 ClearType-Text wird nicht ordnungsgemäß auf einem Hintergrund angezeigt, der nicht vollständig deckend ist. Zwischen Rendering-Ziele wie <xref:System.Windows.UIElement.Effect%2A>, <xref:System.Windows.UIElement.OpacityMask%2A>, <xref:System.Windows.Media.VisualBrush>, <xref:System.Windows.Media.DrawingBrush>, <xref:System.Windows.UIElement.Clip%2A>und <xref:System.Windows.UIElement.Opacity%2A>können zu Hintergründen führen, die nicht vollständig transparent sind. WPF deaktiviert ClearType, wenn erkannt wird, dass der Puffer, in den der Text gezeichnet wird, einen transparenten Hintergrund haben könnte.  
  
 Legen Sie die <xref:System.Windows.Media.RenderOptions.ClearTypeHint%2A>-Eigenschaft auf <xref:System.Windows.Media.ClearTypeHint.Enabled> fest, um anzugeben, dass eine Teilstruktur für das ClearType-Text Rendering sicher ist. Dies geschieht nur, wenn Sie sicher sein können, dass der Text in einen vollständig transparenten Hintergrund gerendert wird. Wenn ein Element in der Teilstruktur Transparenz einleitet, können Sie ClearType aktivieren. Allerdings können Renderingprobleme auftreten. Wenn ein Teil der Teilstruktur mehr zwischenrenderingziele einführt, müssen Sie <xref:System.Windows.Media.RenderOptions.ClearTypeHint%2A> für die untergeordneten Elemente dieser Unterstruktur erneut festlegen.  
  
 In der folgenden Liste wird gezeigt, wie sichergestellt wird, dass der mit ClearType gerenderte Text ordnungsgemäß angezeigt wird.  
  
-   Stellen Sie keine zwischengeschalteten Renderziele zwischen <xref:System.Windows.Media.RenderOptions.ClearTypeHint%2A> und dem Text, der mit ClearType gerendert werden soll.  
  
-   Weisen Sie dem Text einen nicht transparenten Hintergrund zu, der so nah wie möglich in der visuellen Struktur ist.  
  
-   Beachten Sie, dass <xref:System.Windows.Media.RenderOptions.ClearTypeHint%2A> ClearType für eine Unterstruktur erneut aktiviert. das Rendern von ClearType wird jedoch nicht erzwungen.  
  
-   Beachten Sie, dass <xref:System.Windows.Media.RenderOptions.ClearTypeHint%2A> Ihre Systemeinstellungen oder <xref:System.Windows.Media.TextOptions.TextRenderingMode%2A> Einstellungen nicht außer Kraft setzt.  
  
> [!NOTE]
>  Die <xref:System.Windows.Media.RenderOptions.ClearTypeHint%2A> angefügte Eigenschaft wirkt sich nicht auf das <xref:System.Windows.Controls.TextBox> Steuerelement aus. Es funktioniert jedoch mit dem <xref:System.Windows.Controls.TextBlock>-Steuerelement.  
  
> [!NOTE]
>  Bei vielen Steuerelementen hat die <xref:System.Windows.Media.RenderOptions.ClearTypeHint%2A> angefügte-Eigenschaft keine Auswirkung, es sei denn, Sie legen einen nicht transparenten Hintergrund hinter dem Text fest.  
  
 Wenn Sie auf diese Eigenschaft im Code zugreifen möchten, verwenden Sie die Methoden <xref:System.Windows.Media.RenderOptions.GetClearTypeHint%2A> und <xref:System.Windows.Media.RenderOptions.SetClearTypeHint%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie sich die <xref:System.Windows.Media.RenderOptions.ClearTypeHint%2A>-Eigenschaft auf verschiedene Verzweigungen der visuellen Struktur auswirkt. Im ersten TextBlock-Steuerelement wird Text mit ClearType gerendert, da der TextBlock die Einstellung vom Hauptfenster erbt. Im zweiten TextBlock wird ClearType nicht verwendet, da die <xref:System.Windows.UIElement.OpacityMask%2A>-Eigenschaft des übergeordneten Elements festgelegt ist. Im dritten TextBlock wird <xref:System.Windows.Media.RenderOptions.ClearTypeHint%2A> verwendet, aber es können Renderingprobleme auftreten.  
  
```xaml
<Window x:Class="ClearTypeHintDemo.Window1"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Window1" Height="300" Width="300"
        AllowsTransparency="True" 
        WindowStyle="None" 
        RenderOptions.ClearTypeHint="Enabled" 
        Background="White">
    <Window.Resources>
        <LinearGradientBrush x:Key="opacityBrush" >
            <GradientStop Color="#FF000000" Offset="0.0" />
            <GradientStop Color="#00000000" Offset="1.0" />
        </LinearGradientBrush>
    </Window.Resources>

    <StackPanel>
        <TextBlock Text="This text is rendered with ClearType." />
        <StackPanel OpacityMask="{StaticResource opacityBrush}" >
            <TextBlock Text="This text is not rendered with ClearType." />
            <TextBlock RenderOptions.ClearTypeHint="Enabled" 
                       Text="This text is rendered with ClearType but may alpha-blend incorrectly." />
        </StackPanel>
    </StackPanel>
</Window>  
```

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearTypeHintProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ClearTypeHintProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ClearTypeHintProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Media.RenderOptions.ClearTypeHintProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ClearTypeHintProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ClearTypeHintProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ClearTypeHintProperty : System.Windows.DependencyProperty" Usage="System.Windows.Media.RenderOptions.ClearTypeHintProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die angefügte <see cref="P:System.Windows.Media.RenderOptions.ClearTypeHint" />-Eigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EdgeMode">
      <MemberSignature Language="C#" Value="see GetEdgeMode, and SetEdgeMode" />
      <MemberSignature Language="ILAsm" Value="see GetEdgeMode, and SetEdgeMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.RenderOptions.EdgeMode" />
      <MemberSignature Language="VB.NET" Value="see GetEdgeMode, and SetEdgeMode" />
      <MemberSignature Language="F#" Value="see GetEdgeMode, and SetEdgeMode" Usage="see GetEdgeMode, and SetEdgeMode" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft den <see cref="T:System.Windows.Media.EdgeMode" />-Enumerationswert für einen primitiven Typ ohne Text ab, der bestimmt, wie dessen Ränder gerendert werden, oder legt diesen fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie die <xref:System.Windows.Media.RenderOptions.EdgeMode%2A> angefügte Eigenschaft, um die Renderingleistung zu verbessern, indem Sie angeben, dass ein visuelles Objekt mit Alias Kanten gerendert Text Objekte werden immer mit Antialiasing angezeigt und sind nicht betroffen, indem der Wert für den Randmodus festgelegt wird. Wenn Sie den Wert des edgemodus eines visuellen Objekts festlegen, werden alle untergeordneten Zeichen primitiven des visuellen Objekts auf denselben edgemoduswert festgelegt.  
  
 Wenn Sie auf diese Eigenschaft im Code zugreifen möchten, verwenden Sie die Methoden <xref:System.Windows.Media.RenderOptions.GetEdgeMode%2A> und <xref:System.Windows.Media.RenderOptions.SetEdgeMode%2A>.  
  
<a name="dependencyPropertyInfo_EdgeMode"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Media.RenderOptions.EdgeModeProperty>|  
|Metadateneigenschaften auf `true` festgelegt|Keine|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.RenderOptions.GetEdgeMode(System.Windows.DependencyObject)" />
        <altmember cref="M:System.Windows.Media.RenderOptions.SetEdgeMode(System.Windows.DependencyObject,System.Windows.Media.EdgeMode)" />
      </Docs>
    </Member>
    <Member MemberName="EdgeModeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty EdgeModeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty EdgeModeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Media.RenderOptions.EdgeModeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly EdgeModeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ EdgeModeProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable EdgeModeProperty : System.Windows.DependencyProperty" Usage="System.Windows.Media.RenderOptions.EdgeModeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die angefügte <see cref="P:System.Windows.Media.RenderOptions.EdgeMode" />-Eigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBitmapScalingMode">
      <MemberSignature Language="C#" Value="public static System.Windows.Media.BitmapScalingMode GetBitmapScalingMode (System.Windows.DependencyObject target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.Media.BitmapScalingMode GetBitmapScalingMode(class System.Windows.DependencyObject target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.RenderOptions.GetBitmapScalingMode(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetBitmapScalingMode (target As DependencyObject) As BitmapScalingMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Media::BitmapScalingMode GetBitmapScalingMode(System::Windows::DependencyObject ^ target);" />
      <MemberSignature Language="F#" Value="static member GetBitmapScalingMode : System.Windows.DependencyObject -&gt; System.Windows.Media.BitmapScalingMode" Usage="System.Windows.Media.RenderOptions.GetBitmapScalingMode target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.AttachedPropertyBrowsableForType(typeof(System.Windows.DependencyObject))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.BitmapScalingMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="target">Das Abhängigkeitsobjekt, aus dem der Wert der angefügten <see cref="P:System.Windows.Media.RenderOptions.BitmapScalingMode" />-Eigenschaft abgerufen werden soll.</param>
        <summary>Gibt den Wert der angefügten <see cref="P:System.Windows.Media.RenderOptions.BitmapScalingMode" />-Eigenschaft für ein angegebenes Abhängigkeitsobjekt zurück.</summary>
        <returns>Der aktuelle Wert der angefügten <see cref="P:System.Windows.Media.RenderOptions.BitmapScalingMode" />-Eigenschaft für das angegebene Abhängigkeitsobjekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie Sie die <xref:System.Windows.Media.BitmapScalingMode> für ein Bild Objekt erhalten.  
  
 [!code-csharp[RenderOptions#RenderOptionsSnippet1](~/samples/snippets/csharp/VS_Snippets_Wpf/RenderOptions/CSharp/Window1.xaml.cs#renderoptionssnippet1)]
 [!code-vb[RenderOptions#RenderOptionsSnippet1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RenderOptions/visualbasic/window1.xaml.vb#renderoptionssnippet1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der angegebene <paramref name="target" /> ist gleich <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Media.RenderOptions.SetBitmapScalingMode(System.Windows.DependencyObject,System.Windows.Media.BitmapScalingMode)" />
      </Docs>
    </Member>
    <Member MemberName="GetCacheInvalidationThresholdMaximum">
      <MemberSignature Language="C#" Value="public static double GetCacheInvalidationThresholdMaximum (System.Windows.DependencyObject target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 GetCacheInvalidationThresholdMaximum(class System.Windows.DependencyObject target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.RenderOptions.GetCacheInvalidationThresholdMaximum(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCacheInvalidationThresholdMaximum (target As DependencyObject) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double GetCacheInvalidationThresholdMaximum(System::Windows::DependencyObject ^ target);" />
      <MemberSignature Language="F#" Value="static member GetCacheInvalidationThresholdMaximum : System.Windows.DependencyObject -&gt; double" Usage="System.Windows.Media.RenderOptions.GetCacheInvalidationThresholdMaximum target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.AttachedPropertyBrowsableForType(typeof(System.Windows.Media.TileBrush))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="target">Das Abhängigkeitsobjekt, aus dem der Wert der angefügten <see cref="P:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMaximum" />-Eigenschaft abgerufen werden soll.</param>
        <summary>Gibt den Wert der angefügten <see cref="P:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMaximum" />-Eigenschaft für ein angegebenes Abhängigkeitsobjekt zurück.</summary>
        <returns>Der aktuelle Wert der angefügten <see cref="P:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMaximum" />-Eigenschaft für das angegebene Abhängigkeitsobjekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie die Cache Hinweis Werte für eine <xref:System.Windows.Media.DrawingBrush>abgerufen werden.  
  
 [!code-csharp[RenderOptions#RenderOptionsSnippet4](~/samples/snippets/csharp/VS_Snippets_Wpf/RenderOptions/CSharp/Window1.xaml.cs#renderoptionssnippet4)]
 [!code-vb[RenderOptions#RenderOptionsSnippet4](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RenderOptions/visualbasic/window1.xaml.vb#renderoptionssnippet4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der angegebene <paramref name="target" /> ist gleich <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Media.RenderOptions.GetCachingHint(System.Windows.DependencyObject)" />
        <altmember cref="M:System.Windows.Media.RenderOptions.GetCacheInvalidationThresholdMinimum(System.Windows.DependencyObject)" />
      </Docs>
    </Member>
    <Member MemberName="GetCacheInvalidationThresholdMinimum">
      <MemberSignature Language="C#" Value="public static double GetCacheInvalidationThresholdMinimum (System.Windows.DependencyObject target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 GetCacheInvalidationThresholdMinimum(class System.Windows.DependencyObject target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.RenderOptions.GetCacheInvalidationThresholdMinimum(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCacheInvalidationThresholdMinimum (target As DependencyObject) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double GetCacheInvalidationThresholdMinimum(System::Windows::DependencyObject ^ target);" />
      <MemberSignature Language="F#" Value="static member GetCacheInvalidationThresholdMinimum : System.Windows.DependencyObject -&gt; double" Usage="System.Windows.Media.RenderOptions.GetCacheInvalidationThresholdMinimum target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.AttachedPropertyBrowsableForType(typeof(System.Windows.Media.TileBrush))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="target">Das Abhängigkeitsobjekt, aus dem der Wert der angefügten <see cref="P:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMinimum" />-Eigenschaft abgerufen werden soll.</param>
        <summary>Gibt den Wert der angefügten <see cref="P:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMinimum" />-Eigenschaft für ein angegebenes Abhängigkeitsobjekt zurück.</summary>
        <returns>Der aktuelle Wert der angefügten <see cref="P:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMinimum" />-Eigenschaft für das angegebene Abhängigkeitsobjekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie die Cache Hinweis Werte für eine <xref:System.Windows.Media.DrawingBrush>abgerufen werden.  
  
 [!code-csharp[RenderOptions#RenderOptionsSnippet4](~/samples/snippets/csharp/VS_Snippets_Wpf/RenderOptions/CSharp/Window1.xaml.cs#renderoptionssnippet4)]
 [!code-vb[RenderOptions#RenderOptionsSnippet4](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RenderOptions/visualbasic/window1.xaml.vb#renderoptionssnippet4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der angegebene <paramref name="target" /> ist gleich <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Media.RenderOptions.GetCachingHint(System.Windows.DependencyObject)" />
        <altmember cref="M:System.Windows.Media.RenderOptions.GetCacheInvalidationThresholdMaximum(System.Windows.DependencyObject)" />
      </Docs>
    </Member>
    <Member MemberName="GetCachingHint">
      <MemberSignature Language="C#" Value="public static System.Windows.Media.CachingHint GetCachingHint (System.Windows.DependencyObject target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.Media.CachingHint GetCachingHint(class System.Windows.DependencyObject target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.RenderOptions.GetCachingHint(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCachingHint (target As DependencyObject) As CachingHint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Media::CachingHint GetCachingHint(System::Windows::DependencyObject ^ target);" />
      <MemberSignature Language="F#" Value="static member GetCachingHint : System.Windows.DependencyObject -&gt; System.Windows.Media.CachingHint" Usage="System.Windows.Media.RenderOptions.GetCachingHint target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.AttachedPropertyBrowsableForType(typeof(System.Windows.Media.TileBrush))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.CachingHint</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="target">Das Abhängigkeitsobjekt, aus dem der Wert der angefügten <see cref="P:System.Windows.Media.RenderOptions.CachingHint" />-Eigenschaft abgerufen werden soll.</param>
        <summary>Gibt den Wert der angefügten <see cref="P:System.Windows.Media.RenderOptions.CachingHint" />-Eigenschaft für ein angegebenes Abhängigkeitsobjekt zurück.</summary>
        <returns>Der aktuelle Wert der angefügten <see cref="P:System.Windows.Media.RenderOptions.CachingHint" />-Eigenschaft für das angegebene Abhängigkeitsobjekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie die Cache Hinweis Werte für eine <xref:System.Windows.Media.DrawingBrush>abgerufen werden.  
  
 [!code-csharp[RenderOptions#RenderOptionsSnippet4](~/samples/snippets/csharp/VS_Snippets_Wpf/RenderOptions/CSharp/Window1.xaml.cs#renderoptionssnippet4)]
 [!code-vb[RenderOptions#RenderOptionsSnippet4](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RenderOptions/visualbasic/window1.xaml.vb#renderoptionssnippet4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der angegebene <paramref name="target" /> ist gleich <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Media.RenderOptions.GetCacheInvalidationThresholdMinimum(System.Windows.DependencyObject)" />
        <altmember cref="M:System.Windows.Media.RenderOptions.GetCacheInvalidationThresholdMaximum(System.Windows.DependencyObject)" />
      </Docs>
    </Member>
    <Member MemberName="GetClearTypeHint">
      <MemberSignature Language="C#" Value="public static System.Windows.Media.ClearTypeHint GetClearTypeHint (System.Windows.DependencyObject target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.Media.ClearTypeHint GetClearTypeHint(class System.Windows.DependencyObject target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.RenderOptions.GetClearTypeHint(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetClearTypeHint (target As DependencyObject) As ClearTypeHint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Media::ClearTypeHint GetClearTypeHint(System::Windows::DependencyObject ^ target);" />
      <MemberSignature Language="F#" Value="static member GetClearTypeHint : System.Windows.DependencyObject -&gt; System.Windows.Media.ClearTypeHint" Usage="System.Windows.Media.RenderOptions.GetClearTypeHint target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0;netcore-3.1">
          <AttributeName>System.Windows.AttachedPropertyBrowsableForType(typeof(System.Windows.DependencyObject))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.ClearTypeHint</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="target">Das <see cref="T:System.Windows.DependencyObject" />, für das die angefügte <see cref="P:System.Windows.Media.RenderOptions.ClearTypeHint" />-Eigenschaft abgerufen werden soll.</param>
        <summary>Ruft den Wert der angefügten <see cref="P:System.Windows.Media.RenderOptions.ClearTypeHint" />-Eigenschaft für das angegebene Element ab.</summary>
        <returns>Der Wert der angefügten <see cref="P:System.Windows.Media.RenderOptions.ClearTypeHint" />-Eigenschaft für <paramref name="target" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEdgeMode">
      <MemberSignature Language="C#" Value="public static System.Windows.Media.EdgeMode GetEdgeMode (System.Windows.DependencyObject target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.Media.EdgeMode GetEdgeMode(class System.Windows.DependencyObject target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.RenderOptions.GetEdgeMode(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEdgeMode (target As DependencyObject) As EdgeMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Media::EdgeMode GetEdgeMode(System::Windows::DependencyObject ^ target);" />
      <MemberSignature Language="F#" Value="static member GetEdgeMode : System.Windows.DependencyObject -&gt; System.Windows.Media.EdgeMode" Usage="System.Windows.Media.RenderOptions.GetEdgeMode target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.AttachedPropertyBrowsableForType(typeof(System.Windows.DependencyObject))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.EdgeMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="target">Das Abhängigkeitsobjekt, aus dem der Wert der angefügten <see cref="P:System.Windows.Media.RenderOptions.EdgeMode" />-Eigenschaft abgerufen werden soll.</param>
        <summary>Gibt den Wert der angefügten <see cref="P:System.Windows.Media.RenderOptions.EdgeMode" />-Eigenschaft für ein angegebenes Abhängigkeitsobjekt zurück.</summary>
        <returns>Der aktuelle Wert der angefügten <see cref="P:System.Windows.Media.RenderOptions.EdgeMode" />-Eigenschaft für das angegebene Abhängigkeitsobjekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Standardwert für Zeichen primitive, die keine Textzeichen sind, z. b. <xref:System.Windows.Shapes.Ellipse> und <xref:System.Windows.Shapes.Polygon>, wird <xref:System.Windows.Media.EdgeMode.Unspecified>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der angegebene <paramref name="target" /> ist gleich <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ProcessRenderMode">
      <MemberSignature Language="C#" Value="public static System.Windows.Interop.RenderMode ProcessRenderMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Interop.RenderMode ProcessRenderMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.RenderOptions.ProcessRenderMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ProcessRenderMode As RenderMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Interop::RenderMode ProcessRenderMode { System::Windows::Interop::RenderMode get(); void set(System::Windows::Interop::RenderMode value); };" />
      <MemberSignature Language="F#" Value="member this.ProcessRenderMode : System.Windows.Interop.RenderMode with get, set" Usage="System.Windows.Media.RenderOptions.ProcessRenderMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Interop.RenderMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt die Einstellungen des Modus zum Rendern für den aktuellen Prozess an.</summary>
        <value>Die <see cref="T:System.Windows.Interop.RenderMode" />-Einstellung für den aktuellen Prozess.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie die <xref:System.Windows.Media.RenderOptions.ProcessRenderMode%2A>-Eigenschaft, um das Software Rendering für den aktuellen Prozess zu erzwingen. Sie können viele Renderingprobleme vermeiden, die in WPF-Anwendungen auftreten und durch externe Probleme verursacht werden, wenn Sie die Einstellung für das Software Rendering ändern.  
  
 Wenn die Anwendung beim Starten der Anwendung Renderingprobleme erkennt (z. b. langsame Frameraten), können Sie den Renderingmodus nur auf Software festlegen. Außerdem empfiehlt es sich, die Benutzereinstellung zu aktivieren, während die Anwendung ausgeführt wird.  
  
 Die <xref:System.Windows.Interop.RenderMode.SoftwareOnly> Einstellung überschreibt die <xref:System.Windows.Interop.HwndTarget.RenderMode%2A> Einstellung. Die Rangfolge für das Software Rendering lautet wie folgt:  
  
1.  Disablehwacceleration-Registrierungsschlüssel  
  
2.  <xref:System.Windows.Media.RenderOptions.ProcessRenderMode%2A>  
  
3.  <xref:System.Windows.Interop.HwndTarget.RenderMode%2A> (pro Ziel)  
  
 **Beachten Sie** <xref:System.Windows.Media.RenderOptions.ProcessRenderMode%2A> eine Einstellung angibt und nicht notwendigerweise den tatsächlichen Renderingmodus ändert. Andere Teile des Systems können diese Einstellung überschreiben und das System in das Software Rendering erzwingen.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">Zum Festlegen dieser Eigenschaft. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="T:System.Windows.Interop.RenderMode" />
      </Docs>
    </Member>
    <Member MemberName="SetBitmapScalingMode">
      <MemberSignature Language="C#" Value="public static void SetBitmapScalingMode (System.Windows.DependencyObject target, System.Windows.Media.BitmapScalingMode bitmapScalingMode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetBitmapScalingMode(class System.Windows.DependencyObject target, valuetype System.Windows.Media.BitmapScalingMode bitmapScalingMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.RenderOptions.SetBitmapScalingMode(System.Windows.DependencyObject,System.Windows.Media.BitmapScalingMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetBitmapScalingMode(System::Windows::DependencyObject ^ target, System::Windows::Media::BitmapScalingMode bitmapScalingMode);" />
      <MemberSignature Language="F#" Value="static member SetBitmapScalingMode : System.Windows.DependencyObject * System.Windows.Media.BitmapScalingMode -&gt; unit" Usage="System.Windows.Media.RenderOptions.SetBitmapScalingMode (target, bitmapScalingMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
        <Parameter Name="bitmapScalingMode" Type="System.Windows.Media.BitmapScalingMode" />
      </Parameters>
      <Docs>
        <param name="target">Der <see cref="T:System.Windows.UIElement" />- oder der <see cref="T:System.Windows.Media.DrawingGroup" />-Nachfolger, für den der Wert der <see cref="P:System.Windows.Media.RenderOptions.BitmapScalingMode" />-Eigenschaft festgelegt werden soll.</param>
        <param name="bitmapScalingMode">Der neue Wert, auf den die Eigenschaft festgelegt werden soll.</param>
        <summary>Legt den Wert der angefügten <see cref="P:System.Windows.Media.RenderOptions.BitmapScalingMode" />-Eigenschaft für ein angegebenes Abhängigkeitsobjekt fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie die <xref:System.Windows.Media.RenderOptions.SetBitmapScalingMode%2A>-Methode für einen <xref:System.Windows.UIElement> oder <xref:System.Windows.Media.DrawingGroup> Nachfolger, der eine Bitmap animiert.  
  
 Beim Animieren der Skalierung von Bitmaps kann der Standardalgorithmus für das Resampling von Bildern hoher Qualität zuweilen einen solchen Umfang an Systemressourcen beanspruchen, dass eine Verringerung der Einzelbildrate auftritt und Animationen ruckartig wiedergegeben werden. Wenn Sie die <xref:System.Windows.Media.RenderOptions.BitmapScalingMode%2A>-Eigenschaft des <xref:System.Windows.Media.RenderOptions>-Objekts auf <xref:System.Windows.Media.BitmapScalingMode.LowQuality>festlegen, können Sie eine reibungslosere Animation beim Skalieren einer Bitmap erstellen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie die <xref:System.Windows.Media.BitmapScalingMode> für ein <xref:System.Windows.Controls.Image>-Objekt festgelegt wird.  
  
 [!code-csharp[RenderOptions#RenderOptionsSnippet2](~/samples/snippets/csharp/VS_Snippets_Wpf/RenderOptions/CSharp/Window1.xaml.cs#renderoptionssnippet2)]
 [!code-vb[RenderOptions#RenderOptionsSnippet2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RenderOptions/visualbasic/window1.xaml.vb#renderoptionssnippet2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der angegebene <paramref name="target" /> ist gleich <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Media.RenderOptions.GetBitmapScalingMode(System.Windows.DependencyObject)" />
      </Docs>
    </Member>
    <Member MemberName="SetCacheInvalidationThresholdMaximum">
      <MemberSignature Language="C#" Value="public static void SetCacheInvalidationThresholdMaximum (System.Windows.DependencyObject target, double cacheInvalidationThresholdMaximum);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCacheInvalidationThresholdMaximum(class System.Windows.DependencyObject target, float64 cacheInvalidationThresholdMaximum) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.RenderOptions.SetCacheInvalidationThresholdMaximum(System.Windows.DependencyObject,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCacheInvalidationThresholdMaximum (target As DependencyObject, cacheInvalidationThresholdMaximum As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCacheInvalidationThresholdMaximum(System::Windows::DependencyObject ^ target, double cacheInvalidationThresholdMaximum);" />
      <MemberSignature Language="F#" Value="static member SetCacheInvalidationThresholdMaximum : System.Windows.DependencyObject * double -&gt; unit" Usage="System.Windows.Media.RenderOptions.SetCacheInvalidationThresholdMaximum (target, cacheInvalidationThresholdMaximum)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
        <Parameter Name="cacheInvalidationThresholdMaximum" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="target">Das Abhängigkeitsobjekt, für das der Wert der <see cref="P:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMaximum" />-Eigenschaft festgelegt werden soll.</param>
        <param name="cacheInvalidationThresholdMaximum">Der neue Wert, auf den die Eigenschaft festgelegt werden soll.</param>
        <summary>Legt den Wert der angefügten <see cref="P:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMaximum" />-Eigenschaft für ein angegebenes Abhängigkeitsobjekt fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um die <xref:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMaximum%2A> angefügte-Eigenschaft im Code festzulegen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie Sie die Option Caching Hint für eine <xref:System.Windows.Media.DrawingBrush>verwenden.  
  
 [!code-csharp[RenderOptions#RenderOptionsSnippet3](~/samples/snippets/csharp/VS_Snippets_Wpf/RenderOptions/CSharp/Window1.xaml.cs#renderoptionssnippet3)]
 [!code-vb[RenderOptions#RenderOptionsSnippet3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RenderOptions/visualbasic/window1.xaml.vb#renderoptionssnippet3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der angegebene <paramref name="target" /> ist gleich <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Media.RenderOptions.SetCachingHint(System.Windows.DependencyObject,System.Windows.Media.CachingHint)" />
        <altmember cref="M:System.Windows.Media.RenderOptions.SetCacheInvalidationThresholdMinimum(System.Windows.DependencyObject,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="SetCacheInvalidationThresholdMinimum">
      <MemberSignature Language="C#" Value="public static void SetCacheInvalidationThresholdMinimum (System.Windows.DependencyObject target, double cacheInvalidationThresholdMinimum);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCacheInvalidationThresholdMinimum(class System.Windows.DependencyObject target, float64 cacheInvalidationThresholdMinimum) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.RenderOptions.SetCacheInvalidationThresholdMinimum(System.Windows.DependencyObject,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCacheInvalidationThresholdMinimum (target As DependencyObject, cacheInvalidationThresholdMinimum As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCacheInvalidationThresholdMinimum(System::Windows::DependencyObject ^ target, double cacheInvalidationThresholdMinimum);" />
      <MemberSignature Language="F#" Value="static member SetCacheInvalidationThresholdMinimum : System.Windows.DependencyObject * double -&gt; unit" Usage="System.Windows.Media.RenderOptions.SetCacheInvalidationThresholdMinimum (target, cacheInvalidationThresholdMinimum)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
        <Parameter Name="cacheInvalidationThresholdMinimum" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="target">Das Abhängigkeitsobjekt, für das der Wert der <see cref="P:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMinimum" />-Eigenschaft festgelegt werden soll.</param>
        <param name="cacheInvalidationThresholdMinimum">Der neue Wert, auf den die Eigenschaft festgelegt werden soll.</param>
        <summary>Legt den Wert der angefügten <see cref="P:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMinimum" />-Eigenschaft für ein angegebenes Abhängigkeitsobjekt fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um die <xref:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMinimum%2A> angefügte-Eigenschaft im Code festzulegen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie Sie die Option Caching Hint für eine <xref:System.Windows.Media.DrawingBrush>verwenden.  
  
 [!code-csharp[RenderOptions#RenderOptionsSnippet3](~/samples/snippets/csharp/VS_Snippets_Wpf/RenderOptions/CSharp/Window1.xaml.cs#renderoptionssnippet3)]
 [!code-vb[RenderOptions#RenderOptionsSnippet3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RenderOptions/visualbasic/window1.xaml.vb#renderoptionssnippet3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der angegebene <paramref name="target" /> ist gleich <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Media.RenderOptions.SetCachingHint(System.Windows.DependencyObject,System.Windows.Media.CachingHint)" />
        <altmember cref="M:System.Windows.Media.RenderOptions.SetCacheInvalidationThresholdMaximum(System.Windows.DependencyObject,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="SetCachingHint">
      <MemberSignature Language="C#" Value="public static void SetCachingHint (System.Windows.DependencyObject target, System.Windows.Media.CachingHint cachingHint);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCachingHint(class System.Windows.DependencyObject target, valuetype System.Windows.Media.CachingHint cachingHint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.RenderOptions.SetCachingHint(System.Windows.DependencyObject,System.Windows.Media.CachingHint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCachingHint(System::Windows::DependencyObject ^ target, System::Windows::Media::CachingHint cachingHint);" />
      <MemberSignature Language="F#" Value="static member SetCachingHint : System.Windows.DependencyObject * System.Windows.Media.CachingHint -&gt; unit" Usage="System.Windows.Media.RenderOptions.SetCachingHint (target, cachingHint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
        <Parameter Name="cachingHint" Type="System.Windows.Media.CachingHint" />
      </Parameters>
      <Docs>
        <param name="target">Das Abhängigkeitsobjekt, für das der Wert der <see cref="P:System.Windows.Media.RenderOptions.CachingHint" />-Eigenschaft festgelegt werden soll.</param>
        <param name="cachingHint">Der neue Wert, auf den die Eigenschaft festgelegt werden soll.</param>
        <summary>Legt den Wert der angefügten <see cref="P:System.Windows.Media.RenderOptions.CachingHint" />-Eigenschaft für ein angegebenes Abhängigkeitsobjekt fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardmäßig speichert [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] den gerenderten Inhalt von <xref:System.Windows.Media.DrawingBrush>-und <xref:System.Windows.Media.VisualBrush>-Objekten nicht zwischen. In statischen Szenarios, in denen weder der Inhalt noch die Verwendung des Pinsels in der Szene geändert wird, bietet das Caching keinen Vorteil, da es Videospeicher bietet. Wenn ein Pinsel mit statischem Inhalt auf nicht statische Weise verwendet wird, besteht das Standardverhalten von [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] darin, den gesamten Inhalt des Pinsels jedes Frame wiederzugeben, auch wenn sich der Inhalt ändert. Dies geschieht z. b., wenn ein statischer <xref:System.Windows.Media.DrawingBrush> oder <xref:System.Windows.Media.VisualBrush> der Oberfläche eines rotierenden 3D-Objekts zugeordnet wird. Das erneute Rendern des statischen Inhalts kann sich negativ auf die Leistung auswirken.  
  
 Durch Festlegen der <xref:System.Windows.Media.RenderOptions.CachingHint%2A> angefügten-Eigenschaft des Pinsels auf <xref:System.Windows.Media.CachingHint.Cache>können Sie die Leistung mithilfe von zwischengespeicherten Versionen der gekachelten Pinsel Objekte steigern.  
  
 Die <xref:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMinimum%2A>-und <xref:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMaximum%2A>-Eigenschaftswerte sind Werte relativer Größe, die bestimmen, wann das <xref:System.Windows.Media.TileBrush>-Objekt aufgrund von Skalierungs Änderungen erneut generiert werden soll. Wenn die <xref:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMaximum%2A>-Eigenschaft z. b. auf 2,0 festgelegt ist, muss der Cache für die <xref:System.Windows.Media.TileBrush> nur dann erneut generiert werden, wenn die Größe das Zweifache des aktuellen Caches überschreitet.  
  
 Verwenden Sie diese Methode, um die <xref:System.Windows.Media.RenderOptions.CachingHint%2A> angefügte-Eigenschaft im Code festzulegen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie Sie die Option Caching Hint für eine <xref:System.Windows.Media.DrawingBrush>verwenden.  
  
 [!code-csharp[RenderOptions#RenderOptionsSnippet3](~/samples/snippets/csharp/VS_Snippets_Wpf/RenderOptions/CSharp/Window1.xaml.cs#renderoptionssnippet3)]
 [!code-vb[RenderOptions#RenderOptionsSnippet3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RenderOptions/visualbasic/window1.xaml.vb#renderoptionssnippet3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der angegebene <paramref name="target" /> ist gleich <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Media.RenderOptions.SetCacheInvalidationThresholdMaximum(System.Windows.DependencyObject,System.Double)" />
        <altmember cref="M:System.Windows.Media.RenderOptions.SetCacheInvalidationThresholdMinimum(System.Windows.DependencyObject,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="SetClearTypeHint">
      <MemberSignature Language="C#" Value="public static void SetClearTypeHint (System.Windows.DependencyObject target, System.Windows.Media.ClearTypeHint clearTypeHint);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetClearTypeHint(class System.Windows.DependencyObject target, valuetype System.Windows.Media.ClearTypeHint clearTypeHint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.RenderOptions.SetClearTypeHint(System.Windows.DependencyObject,System.Windows.Media.ClearTypeHint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetClearTypeHint(System::Windows::DependencyObject ^ target, System::Windows::Media::ClearTypeHint clearTypeHint);" />
      <MemberSignature Language="F#" Value="static member SetClearTypeHint : System.Windows.DependencyObject * System.Windows.Media.ClearTypeHint -&gt; unit" Usage="System.Windows.Media.RenderOptions.SetClearTypeHint (target, clearTypeHint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="clearTypeHint" Type="System.Windows.Media.ClearTypeHint" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="target">Das <see cref="T:System.Windows.DependencyObject" />, für das die angefügte <see cref="P:System.Windows.Media.RenderOptions.ClearTypeHint" />-Eigenschaft festgelegt werden soll.</param>
        <param name="clearTypeHint">Der neue <see cref="P:System.Windows.Media.RenderOptions.ClearTypeHint" />-Wert.</param>
        <summary>Legt den Wert der angefügten <see cref="P:System.Windows.Media.RenderOptions.ClearTypeHint" />-Eigenschaft für das angegebene Element fest.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Der angegebene <paramref name="target" /> ist gleich <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetEdgeMode">
      <MemberSignature Language="C#" Value="public static void SetEdgeMode (System.Windows.DependencyObject target, System.Windows.Media.EdgeMode edgeMode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetEdgeMode(class System.Windows.DependencyObject target, valuetype System.Windows.Media.EdgeMode edgeMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.RenderOptions.SetEdgeMode(System.Windows.DependencyObject,System.Windows.Media.EdgeMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetEdgeMode(System::Windows::DependencyObject ^ target, System::Windows::Media::EdgeMode edgeMode);" />
      <MemberSignature Language="F#" Value="static member SetEdgeMode : System.Windows.DependencyObject * System.Windows.Media.EdgeMode -&gt; unit" Usage="System.Windows.Media.RenderOptions.SetEdgeMode (target, edgeMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
        <Parameter Name="edgeMode" Type="System.Windows.Media.EdgeMode" />
      </Parameters>
      <Docs>
        <param name="target">Das Abhängigkeitsobjekt, für das der Wert der <see cref="P:System.Windows.Media.RenderOptions.EdgeMode" />-Eigenschaft festgelegt werden soll.</param>
        <param name="edgeMode">Der neue Wert, auf den die Eigenschaft festgelegt werden soll.</param>
        <summary>Legt den Wert der angefügten <see cref="P:System.Windows.Media.RenderOptions.EdgeMode" />-Eigenschaft für ein angegebenes Abhängigkeitsobjekt fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Text Objekte werden immer mit Antialiasing angezeigt und sind nicht betroffen, indem der Wert für den Randmodus festgelegt wird. Wenn Sie den Wert des edgemodus eines visuellen Objekts festlegen, werden alle untergeordneten Zeichen primitiven des visuellen Objekts auf denselben edgemoduswert festgelegt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie die <xref:System.Windows.Media.RenderOptions.SetEdgeMode%2A>-Methode verwendet wird, um den Kanten Modus für ein visuelles Objekt auf <xref:System.Windows.Media.EdgeMode.Aliased>festzulegen.  
  
 [!code-csharp[VisualSnippets#SetEdgeMode](~/samples/snippets/csharp/VS_Snippets_Wpf/VisualSnippets/CSharp/Snippets.cs#setedgemode)]
 [!code-vb[VisualSnippets#SetEdgeMode](~/samples/snippets/visualbasic/VS_Snippets_Wpf/VisualSnippets/visualbasic/snippets.vb#setedgemode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der angegebene <paramref name="target" /> ist gleich <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
