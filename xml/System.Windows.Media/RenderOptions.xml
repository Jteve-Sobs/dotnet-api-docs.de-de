<Type Name="RenderOptions" FullName="System.Windows.Media.RenderOptions">
  <Metadata><Meta Name="ms.openlocfilehash" Value="70d44f193ad41d142457afe1c71d6ad46c31e0c3" /><Meta Name="ms.sourcegitcommit" Value="2767b5903996fbd7e2b81eda1114dfc9d0d9db63" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="05/02/2019" /><Meta Name="ms.locfileid" Value="65009212" /></Metadata><TypeSignature Language="C#" Value="public static class RenderOptions" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit RenderOptions extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Media.RenderOptions" />
  <TypeSignature Language="VB.NET" Value="Public Class RenderOptions" />
  <TypeSignature Language="C++ CLI" Value="public ref class RenderOptions abstract sealed" />
  <TypeSignature Language="F#" Value="type RenderOptions = class" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Bietet Optionen zum Steuern des Renderingverhaltens von Objekten.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können die angefügten Eigenschaften von der <xref:System.Windows.Media.RenderOptions> Klasse, um Optionen für das Rendern von Text und visuelle Elemente in der WPF-Anwendung anzugeben. Diese Optionen ermöglichen Ihnen, die Darstellung für die Schnelligkeit oder Qualität optimieren.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Media.RenderCapability" />
    <related type="Article" href="https://msdn.microsoft.com/library/67cafaad-57ad-4ecb-9c08-57fac144393e">Leistungsprofilerstellungstools für WPF</related>
  </Docs>
  <Members>
    <Member MemberName="BitmapScalingMode">
      <MemberSignature Language="C#" Value="see GetBitmapScalingMode, and SetBitmapScalingMode" />
      <MemberSignature Language="ILAsm" Value="see GetBitmapScalingMode, and SetBitmapScalingMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.RenderOptions.BitmapScalingMode" />
      <MemberSignature Language="VB.NET" Value="see GetBitmapScalingMode, and SetBitmapScalingMode" />
      <MemberSignature Language="F#" Value="see GetBitmapScalingMode, and SetBitmapScalingMode" Usage="see GetBitmapScalingMode, and SetBitmapScalingMode" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft ab oder legt die <see cref="T:System.Windows.Media.BitmapScalingMode" /> für einen angegebenen <see cref="T:System.Windows.DependencyObject" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Windows.Media.RenderOptions.BitmapScalingMode%2A> Eigenschaft für eine <xref:System.Windows.UIElement> oder <xref:System.Windows.Media.DrawingGroup> Nachfolger, die eine Bitmap animiert.  
  
 Beim Animieren der Skalierung von Bitmaps kann der Standardalgorithmus für das Resampling von Bildern hoher Qualität zuweilen einen solchen Umfang an Systemressourcen beanspruchen, dass eine Verringerung der Einzelbildrate auftritt und Animationen ruckartig wiedergegeben werden. Durch Festlegen der <xref:System.Windows.Media.RenderOptions.BitmapScalingMode%2A> Eigenschaft <xref:System.Windows.Media.BitmapScalingMode.LowQuality?displayProperty=nameWithType>, Sie können Animationen erstellen, wenn eine Bitmap skaliert.  
  
 Verwenden Sie diese Eigenschaft im Code den Zugriff auf die <xref:System.Windows.Media.RenderOptions.GetBitmapScalingMode%2A> und <xref:System.Windows.Media.RenderOptions.SetBitmapScalingMode%2A> Methoden.  
  
<a name="dependencyPropertyInfo_BitmapScalingMode"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Feld "ID"|<xref:System.Windows.Media.RenderOptions.BitmapScalingModeProperty>|  
|Legen Sie auf der Metadaten-Eigenschaften `true`|Keiner|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.RenderOptions.GetBitmapScalingMode(System.Windows.DependencyObject)" />
        <altmember cref="M:System.Windows.Media.RenderOptions.SetBitmapScalingMode(System.Windows.DependencyObject,System.Windows.Media.BitmapScalingMode)" />
      </Docs>
    </Member>
    <Member MemberName="BitmapScalingModeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BitmapScalingModeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BitmapScalingModeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Media.RenderOptions.BitmapScalingModeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BitmapScalingModeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BitmapScalingModeProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable BitmapScalingModeProperty : System.Windows.DependencyProperty" Usage="System.Windows.Media.RenderOptions.BitmapScalingModeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die angefügte <see cref="P:System.Windows.Media.RenderOptions.BitmapScalingMode" />-Eigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CacheInvalidationThresholdMaximum">
      <MemberSignature Language="C#" Value="see GetCacheInvalidationThresholdMaximum, and SetCacheInvalidationThresholdMaximum" />
      <MemberSignature Language="ILAsm" Value="see GetCacheInvalidationThresholdMaximum, and SetCacheInvalidationThresholdMaximum" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMaximum" />
      <MemberSignature Language="VB.NET" Value="see GetCacheInvalidationThresholdMaximum, and SetCacheInvalidationThresholdMaximum" />
      <MemberSignature Language="F#" Value="see GetCacheInvalidationThresholdMaximum, and SetCacheInvalidationThresholdMaximum" Usage="see GetCacheInvalidationThresholdMaximum, and SetCacheInvalidationThresholdMaximum" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Übernimmt oder bestimmt den Cache oberen cacheaufhebungs-Schwellenwert für einen bestimmten <see cref="T:System.Windows.DependencyObject" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Angefügte Eigenschaft wird von unterstützt <xref:System.Windows.Media.TileBrush> und seine abgeleiteten Typen. Es soll mithilfe von Pinseln verwendet werden, die fortgeschrittene Oberflächen, z. B. auf <xref:System.Windows.Media.DrawingBrush> und <xref:System.Windows.Media.VisualBrush>. Es hat nur Auswirkungen, wenn die <xref:System.Windows.Media.RenderOptions.CachingHint%2A> -Eigenschaftensatz auf <xref:System.Windows.Media.CachingHint.Cache>.  
  
 In der Standardeinstellung [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] zwischenspeichert, wenn der gerenderte Inhalt von <xref:System.Windows.Media.DrawingBrush> und <xref:System.Windows.Media.VisualBrush> Objekte. In statischen Szenarios, in denen weder der Inhalt noch die Verwendung des Pinsels in der Szene geändert werden, bietet nicht Zwischenspeichern der Inhalte der Vorteil, da Videospeicher gespart wird. Wenn ein Pinsel mit statischem Inhalt verwendet wird, auf nicht statische Weise das Standardverhalten des [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] erneuten Rendern der gesamte Inhalt des Pinsels wird jeden Frame, selbst wenn der Inhalt unverändert bleibt. Angenommen, dies geschieht, wenn eine statische <xref:System.Windows.Media.DrawingBrush> oder <xref:System.Windows.Media.VisualBrush> der Oberfläche eines sich drehenden 3D-Objekts zugeordnet ist. Den statischen Inhalt erneut zu rendern kann sich negativ auf die Leistung auswirken.  
  
 Durch Festlegen der <xref:System.Windows.Media.RenderOptions.CachingHint%2A> angefügte Eigenschaft des Pinsels auf <xref:System.Windows.Media.CachingHint.Cache>, Sie können die Leistung mithilfe von zwischengespeicherten Versionen der gekachelten Pinselobjekte erhöhen.  
  
 Die <xref:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMinimum%2A> und <xref:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMaximum%2A> Eigenschaftswerte sind Werte von relativer Größe, die bestimmen, wann die <xref:System.Windows.Media.TileBrush> Objekt aufgrund einer geänderten Skalierung neu generiert werden sollte. Z. B., wenn die <xref:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMaximum%2A> -Eigenschaftensatz auf 2.0, den Cache für die <xref:System.Windows.Media.TileBrush> muss erneut generiert werden, nur, wenn seine Größe doppelt so groß wie die Größe des aktuellen Caches überschreitet.  
  
 Verwenden Sie diese Eigenschaft im Code den Zugriff auf die <xref:System.Windows.Media.RenderOptions.GetCacheInvalidationThresholdMaximum%2A> und <xref:System.Windows.Media.RenderOptions.SetCacheInvalidationThresholdMaximum%2A> Methoden.  
  
<a name="dependencyPropertyInfo_CacheInvalidationThresholdMaximum"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Feld "ID"|<xref:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMaximumProperty>|  
|Legen Sie auf der Metadaten-Eigenschaften `true`|Keiner|  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie mit die Zwischenspeicherungshinweisoption für eine <xref:System.Windows.Media.DrawingBrush>.  
  
 [!code-xml[RenderOptions#CachingXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/RenderOptions/CSharp/Window1.xaml#cachingxaml)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.RenderOptions.GetCacheInvalidationThresholdMaximum(System.Windows.DependencyObject)" />
        <altmember cref="M:System.Windows.Media.RenderOptions.SetCacheInvalidationThresholdMaximum(System.Windows.DependencyObject,System.Double)" />
        <altmember cref="P:System.Windows.Media.RenderOptions.CachingHint" />
      </Docs>
    </Member>
    <Member MemberName="CacheInvalidationThresholdMaximumProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CacheInvalidationThresholdMaximumProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CacheInvalidationThresholdMaximumProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMaximumProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CacheInvalidationThresholdMaximumProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CacheInvalidationThresholdMaximumProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CacheInvalidationThresholdMaximumProperty : System.Windows.DependencyProperty" Usage="System.Windows.Media.RenderOptions.CacheInvalidationThresholdMaximumProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die angefügte <see cref="P:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMaximum" />-Eigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CacheInvalidationThresholdMinimum">
      <MemberSignature Language="C#" Value="see GetCacheInvalidationThresholdMinimum, and SetCacheInvalidationThresholdMinimum" />
      <MemberSignature Language="ILAsm" Value="see GetCacheInvalidationThresholdMinimum, and SetCacheInvalidationThresholdMinimum" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMinimum" />
      <MemberSignature Language="VB.NET" Value="see GetCacheInvalidationThresholdMinimum, and SetCacheInvalidationThresholdMinimum" />
      <MemberSignature Language="F#" Value="see GetCacheInvalidationThresholdMinimum, and SetCacheInvalidationThresholdMinimum" Usage="see GetCacheInvalidationThresholdMinimum, and SetCacheInvalidationThresholdMinimum" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Übernimmt oder bestimmt den Cache unteren cacheaufhebungs-Schwellenwert für einen bestimmten <see cref="T:System.Windows.DependencyObject" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Angefügte Eigenschaft wird von unterstützt <xref:System.Windows.Media.TileBrush> und seine abgeleiteten Typen. Es soll mithilfe von Pinseln verwendet werden, die fortgeschrittene Oberflächen, z. B. auf <xref:System.Windows.Media.DrawingBrush> und <xref:System.Windows.Media.VisualBrush>. Es hat nur Auswirkungen, wenn die <xref:System.Windows.Media.RenderOptions.CachingHint%2A> -Eigenschaftensatz auf <xref:System.Windows.Media.CachingHint.Cache>.  
  
 In der Standardeinstellung [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] zwischenspeichert, wenn der gerenderte Inhalt von <xref:System.Windows.Media.DrawingBrush> und <xref:System.Windows.Media.VisualBrush> Objekte. In statischen Szenarios, in denen weder der Inhalt noch die Verwendung des Pinsels in der Szene geändert werden, bietet nicht Zwischenspeichern der Inhalte der Vorteil, da Videospeicher gespart wird. Wenn ein Pinsel mit statischem Inhalt in eine nicht statische verwendet wird wie das Standardverhalten des [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] erneuten Rendern der gesamte Inhalt des Pinsels wird jeden Frame, selbst wenn der Inhalt unverändert bleibt. Angenommen, dies geschieht, wenn eine statische <xref:System.Windows.Media.DrawingBrush> oder <xref:System.Windows.Media.VisualBrush> der Oberfläche eines sich drehenden 3D-Objekts zugeordnet ist. Den statischen Inhalt erneut zu rendern kann sich negativ auf die Leistung auswirken.  
  
 Durch Festlegen der <xref:System.Windows.Media.RenderOptions.CachingHint%2A> angefügte Eigenschaft des Pinsels auf <xref:System.Windows.Media.CachingHint.Cache>, Sie können die Leistung mithilfe von zwischengespeicherten Versionen der gekachelten Pinselobjekte erhöhen.  
  
 Die <xref:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMinimum%2A> und <xref:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMaximum%2A> Eigenschaftswerte sind Werte von relativer Größe, die bestimmen, wann die <xref:System.Windows.Media.TileBrush> Objekt aufgrund einer geänderten Skalierung neu generiert werden sollte. Z. B., wenn die <xref:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMinimum%2A> Eigenschaft ist auf 0,5 festgelegt, den Cache für die <xref:System.Windows.Media.TileBrush> muss erneut generiert werden, nur, wenn die Größe auf weniger als die Hälfte der Größe des aktuellen Caches reduziert wird.  
  
 Verwenden Sie diese Eigenschaft im Code den Zugriff auf die <xref:System.Windows.Media.RenderOptions.GetCacheInvalidationThresholdMinimum%2A> und <xref:System.Windows.Media.RenderOptions.SetCacheInvalidationThresholdMinimum%2A> Methoden.  
  
<a name="dependencyPropertyInfo_CacheInvalidationThresholdMinimum"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Feld "ID"|<xref:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMinimumProperty>|  
|Legen Sie auf der Metadaten-Eigenschaften `true`|Keiner|  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie mit die Zwischenspeicherungshinweisoption für eine <xref:System.Windows.Media.DrawingBrush>.  
  
 [!code-xml[RenderOptions#CachingXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/RenderOptions/CSharp/Window1.xaml#cachingxaml)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.RenderOptions.GetCacheInvalidationThresholdMinimum(System.Windows.DependencyObject)" />
        <altmember cref="M:System.Windows.Media.RenderOptions.SetCacheInvalidationThresholdMinimum(System.Windows.DependencyObject,System.Double)" />
        <altmember cref="P:System.Windows.Media.RenderOptions.CachingHint" />
      </Docs>
    </Member>
    <Member MemberName="CacheInvalidationThresholdMinimumProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CacheInvalidationThresholdMinimumProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CacheInvalidationThresholdMinimumProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMinimumProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CacheInvalidationThresholdMinimumProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CacheInvalidationThresholdMinimumProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CacheInvalidationThresholdMinimumProperty : System.Windows.DependencyProperty" Usage="System.Windows.Media.RenderOptions.CacheInvalidationThresholdMinimumProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die angefügte <see cref="P:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMinimum" />-Eigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CachingHint">
      <MemberSignature Language="C#" Value="see GetCachingHint, and SetCachingHint" />
      <MemberSignature Language="ILAsm" Value="see GetCachingHint, and SetCachingHint" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.RenderOptions.CachingHint" />
      <MemberSignature Language="VB.NET" Value="see GetCachingHint, and SetCachingHint" />
      <MemberSignature Language="F#" Value="see GetCachingHint, and SetCachingHint" Usage="see GetCachingHint, and SetCachingHint" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft ab oder legt einen Wert, der angibt, die dargestellten Inhalte sofern möglich zwischengespeichert werden sollen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Angefügte Eigenschaft wird von unterstützt <xref:System.Windows.Media.TileBrush> und seine abgeleiteten Typen. Es soll mithilfe von Pinseln verwendet werden, die fortgeschrittene Oberflächen, z. B. auf <xref:System.Windows.Media.DrawingBrush> und <xref:System.Windows.Media.VisualBrush>.  
  
 In der Standardeinstellung [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] zwischenspeichert, wenn der gerenderte Inhalt von <xref:System.Windows.Media.DrawingBrush> und <xref:System.Windows.Media.VisualBrush> Objekte. In statischen Szenarios, in denen weder der Inhalt noch die Verwendung des Pinsels in der Szene geändert werden, bietet nicht Zwischenspeichern der Vorteil, da Videospeicher gespart wird. Wenn ein Pinsel mit statischem Inhalt verwendet wird, auf nicht statische Weise das Standardverhalten des [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] erneuten Rendern der gesamte Inhalt des Pinsels wird jeden Frame, selbst wenn der Inhalt unverändert bleibt. Angenommen, dies geschieht, wenn eine statische <xref:System.Windows.Media.DrawingBrush> oder <xref:System.Windows.Media.VisualBrush> der Oberfläche eines sich drehenden 3D-Objekts zugeordnet ist. Den statischen Inhalt erneut zu rendern kann sich negativ auf die Leistung auswirken.  
  
 Durch Festlegen der <xref:System.Windows.Media.RenderOptions.CachingHint%2A> angefügte Eigenschaft des Pinsels auf <xref:System.Windows.Media.CachingHint.Cache>, Sie können die Leistung mithilfe von zwischengespeicherten Versionen der gekachelten Pinselobjekte erhöhen.  
  
 Die <xref:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMinimum%2A> und <xref:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMaximum%2A> Eigenschaftswerte sind Werte von relativer Größe, die bestimmen, wann die <xref:System.Windows.Media.TileBrush> Objekt aufgrund einer geänderten Skalierung neu generiert werden sollte. Z. B., wenn die <xref:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMaximum%2A> -Eigenschaftensatz auf 2.0, den Cache für die <xref:System.Windows.Media.TileBrush> muss erneut generiert werden, nur, wenn seine Größe doppelt so groß wie die Größe des aktuellen Caches überschreitet.  
  
 Verwenden Sie diese Eigenschaft im Code den Zugriff auf die <xref:System.Windows.Media.RenderOptions.GetCachingHint%2A> und <xref:System.Windows.Media.RenderOptions.SetCachingHint%2A> Methoden.  
  
<a name="dependencyPropertyInfo_CachingHint"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Feld "ID"|<xref:System.Windows.Media.RenderOptions.CachingHintProperty>|  
|Legen Sie auf der Metadaten-Eigenschaften `true`|Keiner|  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie mit die Zwischenspeicherungshinweisoption für eine <xref:System.Windows.Media.DrawingBrush>.  
  
 [!code-xml[RenderOptions#CachingXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/RenderOptions/CSharp/Window1.xaml#cachingxaml)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.RenderOptions.GetCachingHint(System.Windows.DependencyObject)" />
        <altmember cref="M:System.Windows.Media.RenderOptions.SetCachingHint(System.Windows.DependencyObject,System.Windows.Media.CachingHint)" />
        <altmember cref="P:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMinimum" />
        <altmember cref="P:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMaximum" />
      </Docs>
    </Member>
    <Member MemberName="CachingHintProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CachingHintProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CachingHintProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Media.RenderOptions.CachingHintProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CachingHintProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CachingHintProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CachingHintProperty : System.Windows.DependencyProperty" Usage="System.Windows.Media.RenderOptions.CachingHintProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die angefügte <see cref="P:System.Windows.Media.RenderOptions.CachingHint" />-Eigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearTypeHint">
      <MemberSignature Language="C#" Value="see GetClearTypeHint, and SetClearTypeHint" />
      <MemberSignature Language="ILAsm" Value="see GetClearTypeHint, and SetClearTypeHint" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.RenderOptions.ClearTypeHint" />
      <MemberSignature Language="VB.NET" Value="see GetClearTypeHint, and SetClearTypeHint" />
      <MemberSignature Language="F#" Value="see GetClearTypeHint, and SetClearTypeHint" Usage="see GetClearTypeHint, and SetClearTypeHint" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft ab oder legt einen Wert ab, der Rendering-Engine angibt, ob Text mit ClearType gerendert werden kann.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Windows.Media.RenderOptions.ClearTypeHint%2A> angefügte Eigenschaft, um anzugeben, dass Text mit ClearType in einem bestimmten Teil der visuellen Struktur gerendert werden kann.  
  
 ClearType-Text werden in einem Hintergrundthread, der nicht vollständig deckend ist, wird nicht richtig angezeigt. Zwischenrenderingziele, z. B. <xref:System.Windows.UIElement.Effect%2A>, <xref:System.Windows.UIElement.OpacityMask%2A>, <xref:System.Windows.Media.VisualBrush>, <xref:System.Windows.Media.DrawingBrush>, <xref:System.Windows.UIElement.Clip%2A>, und <xref:System.Windows.UIElement.Opacity%2A>, Hintergründen, die nicht vollständig deckend sind können eingeführt werden. WPF wird ClearType deaktiviert, wenn erkannt wird, dass der Puffer, in dem Text gezeichnet wird, einen transparenten Hintergrund hätte.  
  
 Legen Sie die <xref:System.Windows.Media.RenderOptions.ClearTypeHint%2A> Eigenschaft <xref:System.Windows.Media.ClearTypeHint.Enabled> um anzugeben, dass eine Teilstruktur für ClearType-Text-Rendering sicher ist. Führen Sie dies nur, wenn Sie sicher sein können, dass die Textdarstellung einer vollständig deckend Hintergrund. Wenn ein Element in der Teilstruktur Transparenz eingeführt wird, können Sie ClearType aktivieren. Allerdings können die Renderingprobleme auftreten. Wenn ein Teil der Teilstruktur weitere fortgeschrittene Renderingzwischenziele eingeführt werden, müssen Sie festlegen <xref:System.Windows.Media.RenderOptions.ClearTypeHint%2A> für die untergeordneten Elemente dieser Teilstruktur erneut.  
  
 Die folgende Liste enthält, wie Sie sicherstellen, dass Text mit ClearType gerendert werden korrekt angezeigt wird.  
  
-   Configuration Manager keine Zwischenrenderingzielen zwischen <xref:System.Windows.Media.RenderOptions.ClearTypeHint%2A> und den Text mit ClearType gerendert werden soll.  
  
-   Weisen Sie einen nicht transparenten Hintergrund, der so nah wie möglich, in der visuellen Struktur auf den Text ist.  
  
-   Beachten Sie, <xref:System.Windows.Media.RenderOptions.ClearTypeHint%2A> erneut aktiviert ClearType für eine Teilstruktur; allerdings wird ClearType-Rendering nicht erzwungen wird.  
  
-   Beachten Sie, <xref:System.Windows.Media.RenderOptions.ClearTypeHint%2A> überschreibt nicht die Systemeinstellungen oder <xref:System.Windows.Media.TextOptions.TextRenderingMode%2A> Einstellungen.  
  
> [!NOTE]
>  Die <xref:System.Windows.Media.RenderOptions.ClearTypeHint%2A> angefügte Eigenschaft hat keine Auswirkungen auf die <xref:System.Windows.Controls.TextBox> steuern; allerdings funktioniert mit den <xref:System.Windows.Controls.TextBlock> Steuerelement.  
  
> [!NOTE]
>  Bei zahlreichen Steuerelementen die <xref:System.Windows.Media.RenderOptions.ClearTypeHint%2A> angefügte Eigenschaft hat keine Auswirkungen, es sei denn, die Sie festlegen, dass einen nicht transparenten Hintergrund hinter dem Text.  
  
 Verwenden Sie diese Eigenschaft im Code den Zugriff auf die <xref:System.Windows.Media.RenderOptions.GetClearTypeHint%2A> und <xref:System.Windows.Media.RenderOptions.SetClearTypeHint%2A> Methoden.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die <xref:System.Windows.Media.RenderOptions.ClearTypeHint%2A> Eigenschaft wirkt sich auf verschiedenen Verzweigungen der visuellen Struktur. In der ersten TextBlock-Steuerelement wird Text mit ClearType gerendert, da der Textblock im Hauptfenster die Einstellung erbt. Im zweiten Textblock, ClearType wird nicht verwendet, da des übergeordnete Elements des <xref:System.Windows.UIElement.OpacityMask%2A> festgelegt wird. Im dritten TextBlock <xref:System.Windows.Media.RenderOptions.ClearTypeHint%2A> verwendet wird, aber Renderingprobleme können auftreten.  
  
```xaml
<Window x:Class="ClearTypeHintDemo.Window1"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Window1" Height="300" Width="300"
        AllowsTransparency="True" 
        WindowStyle="None" 
        RenderOptions.ClearTypeHint="Enabled" 
        Background="White">
    <Window.Resources>
        <LinearGradientBrush x:Key="opacityBrush" >
            <GradientStop Color="#FF000000" Offset="0.0" />
            <GradientStop Color="#00000000" Offset="1.0" />
        </LinearGradientBrush>
    </Window.Resources>

    <StackPanel>
        <TextBlock Text="This text is rendered with ClearType." />
        <StackPanel OpacityMask="{StaticResource opacityBrush}" >
            <TextBlock Text="This text is not rendered with ClearType." />
            <TextBlock RenderOptions.ClearTypeHint="Enabled" 
                       Text="This text is rendered with ClearType but may alpha-blend incorrectly." />
        </StackPanel>
    </StackPanel>
</Window>  
```

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearTypeHintProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ClearTypeHintProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ClearTypeHintProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Media.RenderOptions.ClearTypeHintProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ClearTypeHintProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ClearTypeHintProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ClearTypeHintProperty : System.Windows.DependencyProperty" Usage="System.Windows.Media.RenderOptions.ClearTypeHintProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die angefügte <see cref="P:System.Windows.Media.RenderOptions.ClearTypeHint" />-Eigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EdgeMode">
      <MemberSignature Language="C#" Value="see GetEdgeMode, and SetEdgeMode" />
      <MemberSignature Language="ILAsm" Value="see GetEdgeMode, and SetEdgeMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.RenderOptions.EdgeMode" />
      <MemberSignature Language="VB.NET" Value="see GetEdgeMode, and SetEdgeMode" />
      <MemberSignature Language="F#" Value="see GetEdgeMode, and SetEdgeMode" Usage="see GetEdgeMode, and SetEdgeMode" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Übernimmt oder bestimmt den <see cref="T:System.Windows.Media.EdgeMode" /> Enumerationswert für einen nicht-Text-primitiven Typ, der bestimmt, wie dessen Ränder gerendert werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Windows.Media.RenderOptions.EdgeMode%2A> angefügte Eigenschaft zur Verbesserung der Renderingleistung durch angeben, die mit einem Alias versehen Kante ein visuellen Objekts gerendert werden soll. Textobjekte werden immer mit Antialiasing angezeigt und sind durch Festlegen des Werts der Edge-Modus nicht betroffen. Wenn Sie den Wert des Edge-Modus eines visuellen Objekts festlegen, werden alle untergeordneten Zeichnungsprimitiven des visuellen Objekts auf den gleichen Wert des Edge-Modus festgelegt.  
  
 Verwenden Sie diese Eigenschaft im Code den Zugriff auf die <xref:System.Windows.Media.RenderOptions.GetEdgeMode%2A> und <xref:System.Windows.Media.RenderOptions.SetEdgeMode%2A> Methoden.  
  
<a name="dependencyPropertyInfo_EdgeMode"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Feld "ID"|<xref:System.Windows.Media.RenderOptions.EdgeModeProperty>|  
|Legen Sie auf der Metadaten-Eigenschaften `true`|Keiner|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.RenderOptions.GetEdgeMode(System.Windows.DependencyObject)" />
        <altmember cref="M:System.Windows.Media.RenderOptions.SetEdgeMode(System.Windows.DependencyObject,System.Windows.Media.EdgeMode)" />
      </Docs>
    </Member>
    <Member MemberName="EdgeModeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty EdgeModeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty EdgeModeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Media.RenderOptions.EdgeModeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly EdgeModeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ EdgeModeProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable EdgeModeProperty : System.Windows.DependencyProperty" Usage="System.Windows.Media.RenderOptions.EdgeModeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die angefügte <see cref="P:System.Windows.Media.RenderOptions.EdgeMode" />-Eigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBitmapScalingMode">
      <MemberSignature Language="C#" Value="public static System.Windows.Media.BitmapScalingMode GetBitmapScalingMode (System.Windows.DependencyObject target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.Media.BitmapScalingMode GetBitmapScalingMode(class System.Windows.DependencyObject target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.RenderOptions.GetBitmapScalingMode(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetBitmapScalingMode (target As DependencyObject) As BitmapScalingMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Media::BitmapScalingMode GetBitmapScalingMode(System::Windows::DependencyObject ^ target);" />
      <MemberSignature Language="F#" Value="static member GetBitmapScalingMode : System.Windows.DependencyObject -&gt; System.Windows.Media.BitmapScalingMode" Usage="System.Windows.Media.RenderOptions.GetBitmapScalingMode target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.AttachedPropertyBrowsableForType(typeof(System.Windows.DependencyObject))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.BitmapScalingMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="target">Das Abhängigkeitsobjekt, von dem der Wert der angefügten <see cref="P:System.Windows.Media.RenderOptions.BitmapScalingMode" />-Eigenschaft abgerufen wird.</param>
        <summary>Gibt den Wert der angefügten <see cref="P:System.Windows.Media.RenderOptions.BitmapScalingMode" />-Eigenschaft für ein angegebenes Abhängigkeitsobjekt zurück.</summary>
        <returns>Der aktuelle Wert der angefügten <see cref="P:System.Windows.Media.RenderOptions.BitmapScalingMode" />-Eigenschaft für das angegebene Abhängigkeitsobjekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie erhalten die <xref:System.Windows.Media.BitmapScalingMode> für ein Image-Objekt.  
  
 [!code-csharp[RenderOptions#RenderOptionsSnippet1](~/samples/snippets/csharp/VS_Snippets_Wpf/RenderOptions/CSharp/Window1.xaml.cs#renderoptionssnippet1)]
 [!code-vb[RenderOptions#RenderOptionsSnippet1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RenderOptions/visualbasic/window1.xaml.vb#renderoptionssnippet1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der angegebene <paramref name="target" /> ist gleich <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Media.RenderOptions.SetBitmapScalingMode(System.Windows.DependencyObject,System.Windows.Media.BitmapScalingMode)" />
      </Docs>
    </Member>
    <Member MemberName="GetCacheInvalidationThresholdMaximum">
      <MemberSignature Language="C#" Value="public static double GetCacheInvalidationThresholdMaximum (System.Windows.DependencyObject target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 GetCacheInvalidationThresholdMaximum(class System.Windows.DependencyObject target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.RenderOptions.GetCacheInvalidationThresholdMaximum(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCacheInvalidationThresholdMaximum (target As DependencyObject) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double GetCacheInvalidationThresholdMaximum(System::Windows::DependencyObject ^ target);" />
      <MemberSignature Language="F#" Value="static member GetCacheInvalidationThresholdMaximum : System.Windows.DependencyObject -&gt; double" Usage="System.Windows.Media.RenderOptions.GetCacheInvalidationThresholdMaximum target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.AttachedPropertyBrowsableForType(typeof(System.Windows.Media.TileBrush))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="target">Das Abhängigkeitsobjekt, von dem der Wert der angefügten <see cref="P:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMaximum" />-Eigenschaft abgerufen wird.</param>
        <summary>Gibt den Wert der angefügten <see cref="P:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMaximum" />-Eigenschaft für ein angegebenes Abhängigkeitsobjekt zurück.</summary>
        <returns>Der aktuelle Wert der angefügten <see cref="P:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMaximum" />-Eigenschaft für das angegebene Abhängigkeitsobjekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie zum Abrufen der Zwischenspeicherung Hinweis Werte für eine <xref:System.Windows.Media.DrawingBrush>.  
  
 [!code-csharp[RenderOptions#RenderOptionsSnippet4](~/samples/snippets/csharp/VS_Snippets_Wpf/RenderOptions/CSharp/Window1.xaml.cs#renderoptionssnippet4)]
 [!code-vb[RenderOptions#RenderOptionsSnippet4](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RenderOptions/visualbasic/window1.xaml.vb#renderoptionssnippet4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der angegebene <paramref name="target" /> ist gleich <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Media.RenderOptions.GetCachingHint(System.Windows.DependencyObject)" />
        <altmember cref="M:System.Windows.Media.RenderOptions.GetCacheInvalidationThresholdMinimum(System.Windows.DependencyObject)" />
      </Docs>
    </Member>
    <Member MemberName="GetCacheInvalidationThresholdMinimum">
      <MemberSignature Language="C#" Value="public static double GetCacheInvalidationThresholdMinimum (System.Windows.DependencyObject target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 GetCacheInvalidationThresholdMinimum(class System.Windows.DependencyObject target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.RenderOptions.GetCacheInvalidationThresholdMinimum(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCacheInvalidationThresholdMinimum (target As DependencyObject) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double GetCacheInvalidationThresholdMinimum(System::Windows::DependencyObject ^ target);" />
      <MemberSignature Language="F#" Value="static member GetCacheInvalidationThresholdMinimum : System.Windows.DependencyObject -&gt; double" Usage="System.Windows.Media.RenderOptions.GetCacheInvalidationThresholdMinimum target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.AttachedPropertyBrowsableForType(typeof(System.Windows.Media.TileBrush))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="target">Das Abhängigkeitsobjekt, von dem der Wert der angefügten <see cref="P:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMinimum" />-Eigenschaft abgerufen wird.</param>
        <summary>Gibt den Wert der angefügten <see cref="P:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMinimum" />-Eigenschaft für ein angegebenes Abhängigkeitsobjekt zurück.</summary>
        <returns>Der aktuelle Wert der angefügten <see cref="P:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMinimum" />-Eigenschaft für das angegebene Abhängigkeitsobjekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie zum Abrufen der Zwischenspeicherung Hinweis Werte für eine <xref:System.Windows.Media.DrawingBrush>.  
  
 [!code-csharp[RenderOptions#RenderOptionsSnippet4](~/samples/snippets/csharp/VS_Snippets_Wpf/RenderOptions/CSharp/Window1.xaml.cs#renderoptionssnippet4)]
 [!code-vb[RenderOptions#RenderOptionsSnippet4](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RenderOptions/visualbasic/window1.xaml.vb#renderoptionssnippet4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der angegebene <paramref name="target" /> ist gleich <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Media.RenderOptions.GetCachingHint(System.Windows.DependencyObject)" />
        <altmember cref="M:System.Windows.Media.RenderOptions.GetCacheInvalidationThresholdMaximum(System.Windows.DependencyObject)" />
      </Docs>
    </Member>
    <Member MemberName="GetCachingHint">
      <MemberSignature Language="C#" Value="public static System.Windows.Media.CachingHint GetCachingHint (System.Windows.DependencyObject target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.Media.CachingHint GetCachingHint(class System.Windows.DependencyObject target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.RenderOptions.GetCachingHint(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCachingHint (target As DependencyObject) As CachingHint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Media::CachingHint GetCachingHint(System::Windows::DependencyObject ^ target);" />
      <MemberSignature Language="F#" Value="static member GetCachingHint : System.Windows.DependencyObject -&gt; System.Windows.Media.CachingHint" Usage="System.Windows.Media.RenderOptions.GetCachingHint target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.AttachedPropertyBrowsableForType(typeof(System.Windows.Media.TileBrush))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.CachingHint</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="target">Das Abhängigkeitsobjekt, von dem der Wert der angefügten <see cref="P:System.Windows.Media.RenderOptions.CachingHint" />-Eigenschaft abgerufen wird.</param>
        <summary>Gibt den Wert der angefügten <see cref="P:System.Windows.Media.RenderOptions.CachingHint" />-Eigenschaft für ein angegebenes Abhängigkeitsobjekt zurück.</summary>
        <returns>Der aktuelle Wert der angefügten <see cref="P:System.Windows.Media.RenderOptions.CachingHint" />-Eigenschaft für das angegebene Abhängigkeitsobjekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie zum Abrufen der Zwischenspeicherung Hinweis Werte für eine <xref:System.Windows.Media.DrawingBrush>.  
  
 [!code-csharp[RenderOptions#RenderOptionsSnippet4](~/samples/snippets/csharp/VS_Snippets_Wpf/RenderOptions/CSharp/Window1.xaml.cs#renderoptionssnippet4)]
 [!code-vb[RenderOptions#RenderOptionsSnippet4](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RenderOptions/visualbasic/window1.xaml.vb#renderoptionssnippet4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der angegebene <paramref name="target" /> ist gleich <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Media.RenderOptions.GetCacheInvalidationThresholdMinimum(System.Windows.DependencyObject)" />
        <altmember cref="M:System.Windows.Media.RenderOptions.GetCacheInvalidationThresholdMaximum(System.Windows.DependencyObject)" />
      </Docs>
    </Member>
    <Member MemberName="GetClearTypeHint">
      <MemberSignature Language="C#" Value="public static System.Windows.Media.ClearTypeHint GetClearTypeHint (System.Windows.DependencyObject target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.Media.ClearTypeHint GetClearTypeHint(class System.Windows.DependencyObject target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.RenderOptions.GetClearTypeHint(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetClearTypeHint (target As DependencyObject) As ClearTypeHint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Media::ClearTypeHint GetClearTypeHint(System::Windows::DependencyObject ^ target);" />
      <MemberSignature Language="F#" Value="static member GetClearTypeHint : System.Windows.DependencyObject -&gt; System.Windows.Media.ClearTypeHint" Usage="System.Windows.Media.RenderOptions.GetClearTypeHint target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Windows.AttachedPropertyBrowsableForType(typeof(System.Windows.DependencyObject))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.ClearTypeHint</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="target">Die <see cref="T:System.Windows.DependencyObject" /> zum Abrufen der <see cref="P:System.Windows.Media.RenderOptions.ClearTypeHint" /> angefügte Eigenschaft für.</param>
        <summary>Ruft den Wert der <see cref="P:System.Windows.Media.RenderOptions.ClearTypeHint" /> angefügte Eigenschaft des angegebenen Elements.</summary>
        <returns>Der Wert des der <see cref="P:System.Windows.Media.RenderOptions.ClearTypeHint" /> angefügte Eigenschaft für <paramref name="target" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEdgeMode">
      <MemberSignature Language="C#" Value="public static System.Windows.Media.EdgeMode GetEdgeMode (System.Windows.DependencyObject target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.Media.EdgeMode GetEdgeMode(class System.Windows.DependencyObject target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.RenderOptions.GetEdgeMode(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEdgeMode (target As DependencyObject) As EdgeMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Media::EdgeMode GetEdgeMode(System::Windows::DependencyObject ^ target);" />
      <MemberSignature Language="F#" Value="static member GetEdgeMode : System.Windows.DependencyObject -&gt; System.Windows.Media.EdgeMode" Usage="System.Windows.Media.RenderOptions.GetEdgeMode target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.AttachedPropertyBrowsableForType(typeof(System.Windows.DependencyObject))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.EdgeMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="target">Das Abhängigkeitsobjekt, von dem der Wert der angefügten <see cref="P:System.Windows.Media.RenderOptions.EdgeMode" />-Eigenschaft abgerufen wird.</param>
        <summary>Gibt den Wert der angefügten <see cref="P:System.Windows.Media.RenderOptions.EdgeMode" />-Eigenschaft für ein angegebenes Abhängigkeitsobjekt zurück.</summary>
        <returns>Der aktuelle Wert der angefügten <see cref="P:System.Windows.Media.RenderOptions.EdgeMode" />-Eigenschaft für das angegebene Abhängigkeitsobjekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Standardwert für Zeichnungsprimitiven ohne Text, z. B. <xref:System.Windows.Shapes.Ellipse> und <xref:System.Windows.Shapes.Polygon>, ist <xref:System.Windows.Media.EdgeMode.Unspecified>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der angegebene <paramref name="target" /> ist gleich <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ProcessRenderMode">
      <MemberSignature Language="C#" Value="public static System.Windows.Interop.RenderMode ProcessRenderMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Interop.RenderMode ProcessRenderMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.RenderOptions.ProcessRenderMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ProcessRenderMode As RenderMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Interop::RenderMode ProcessRenderMode { System::Windows::Interop::RenderMode get(); void set(System::Windows::Interop::RenderMode value); };" />
      <MemberSignature Language="F#" Value="member this.ProcessRenderMode : System.Windows.Interop.RenderMode with get, set" Usage="System.Windows.Media.RenderOptions.ProcessRenderMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Interop.RenderMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, der Rendering-Modus-Einstellung für den aktuellen Prozess.</summary>
        <value>Die <see cref="T:System.Windows.Interop.RenderMode" /> Einstellung für den aktuellen Prozess.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Windows.Media.RenderOptions.ProcessRenderMode%2A> Eigenschaft Softwarerendering für den aktuellen Prozess zu erzwingen. Viele Probleme bei der Darstellung können vermieden werden, die in WPF-Anwendungen auftreten und, die durch externe Probleme verursacht werden, wenn Sie die Einstellung auf Softwarerendering ändern.  
  
 Beim Starten, der Anwendung Wenn Ihre Anwendung Renderingprobleme, z. B. langsame Frameraten, erkennt können Sie den Renderingmodus für nur Software festlegen. Darüber hinaus empfiehlt es sich um die Benutzer-Einstellung während der Ausführung der Anwendung zu aktivieren.  
  
 Die <xref:System.Windows.Interop.RenderMode.SoftwareOnly> Einstellung überschreibt die <xref:System.Windows.Interop.HwndTarget.RenderMode%2A> festlegen. Die Rangfolge für Elemente des Softwarerendering ist:  
  
1.  Registrierungsschlüssel DisableHWAcceleration  
  
2.  <xref:System.Windows.Media.RenderOptions.ProcessRenderMode%2A>  
  
3.  <xref:System.Windows.Interop.HwndTarget.RenderMode%2A> (pro-Ziel)  
  
 **Beachten Sie** <xref:System.Windows.Media.RenderOptions.ProcessRenderMode%2A> legt fest, und nicht unbedingt den eigentliche Rendering-Modus ändert. Andere Teile des Systems können außer Kraft setzen dieser Einstellung und erzwingen, dass das System in Software-Rendering.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">zum Festlegen dieser Eigenschaft. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="T:System.Windows.Interop.RenderMode" />
      </Docs>
    </Member>
    <Member MemberName="SetBitmapScalingMode">
      <MemberSignature Language="C#" Value="public static void SetBitmapScalingMode (System.Windows.DependencyObject target, System.Windows.Media.BitmapScalingMode bitmapScalingMode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetBitmapScalingMode(class System.Windows.DependencyObject target, valuetype System.Windows.Media.BitmapScalingMode bitmapScalingMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.RenderOptions.SetBitmapScalingMode(System.Windows.DependencyObject,System.Windows.Media.BitmapScalingMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetBitmapScalingMode(System::Windows::DependencyObject ^ target, System::Windows::Media::BitmapScalingMode bitmapScalingMode);" />
      <MemberSignature Language="F#" Value="static member SetBitmapScalingMode : System.Windows.DependencyObject * System.Windows.Media.BitmapScalingMode -&gt; unit" Usage="System.Windows.Media.RenderOptions.SetBitmapScalingMode (target, bitmapScalingMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
        <Parameter Name="bitmapScalingMode" Type="System.Windows.Media.BitmapScalingMode" />
      </Parameters>
      <Docs>
        <param name="target">Der <see cref="T:System.Windows.UIElement" />- oder der <see cref="T:System.Windows.Media.DrawingGroup" />-Nachfolger, für den der Wert der <see cref="P:System.Windows.Media.RenderOptions.BitmapScalingMode" />-Eigenschaft festgelegt werden soll.</param>
        <param name="bitmapScalingMode">Der neue Wert, auf den die Eigenschaft festgelegt werden soll.</param>
        <summary>Legt den Wert der angefügten <see cref="P:System.Windows.Media.RenderOptions.BitmapScalingMode" />-Eigenschaft für ein angegebenes Abhängigkeitsobjekt fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Windows.Media.RenderOptions.SetBitmapScalingMode%2A> Methode für eine <xref:System.Windows.UIElement> oder <xref:System.Windows.Media.DrawingGroup> Nachfolger, die eine Bitmap animiert.  
  
 Beim Animieren der Skalierung von Bitmaps kann der Standardalgorithmus für das Resampling von Bildern hoher Qualität zuweilen einen solchen Umfang an Systemressourcen beanspruchen, dass eine Verringerung der Einzelbildrate auftritt und Animationen ruckartig wiedergegeben werden. Durch Festlegen der <xref:System.Windows.Media.RenderOptions.BitmapScalingMode%2A> Eigenschaft der <xref:System.Windows.Media.RenderOptions> -Objekt <xref:System.Windows.Media.BitmapScalingMode.LowQuality>, Sie können Animationen erstellen, wenn eine Bitmap skaliert.  
  
   
  
## Examples  
 Im folgende Beispiel veranschaulicht die legen Sie die <xref:System.Windows.Media.BitmapScalingMode> für eine <xref:System.Windows.Controls.Image> Objekt.  
  
 [!code-csharp[RenderOptions#RenderOptionsSnippet2](~/samples/snippets/csharp/VS_Snippets_Wpf/RenderOptions/CSharp/Window1.xaml.cs#renderoptionssnippet2)]
 [!code-vb[RenderOptions#RenderOptionsSnippet2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RenderOptions/visualbasic/window1.xaml.vb#renderoptionssnippet2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der angegebene <paramref name="target" /> ist gleich <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Media.RenderOptions.GetBitmapScalingMode(System.Windows.DependencyObject)" />
      </Docs>
    </Member>
    <Member MemberName="SetCacheInvalidationThresholdMaximum">
      <MemberSignature Language="C#" Value="public static void SetCacheInvalidationThresholdMaximum (System.Windows.DependencyObject target, double cacheInvalidationThresholdMaximum);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCacheInvalidationThresholdMaximum(class System.Windows.DependencyObject target, float64 cacheInvalidationThresholdMaximum) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.RenderOptions.SetCacheInvalidationThresholdMaximum(System.Windows.DependencyObject,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCacheInvalidationThresholdMaximum (target As DependencyObject, cacheInvalidationThresholdMaximum As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCacheInvalidationThresholdMaximum(System::Windows::DependencyObject ^ target, double cacheInvalidationThresholdMaximum);" />
      <MemberSignature Language="F#" Value="static member SetCacheInvalidationThresholdMaximum : System.Windows.DependencyObject * double -&gt; unit" Usage="System.Windows.Media.RenderOptions.SetCacheInvalidationThresholdMaximum (target, cacheInvalidationThresholdMaximum)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
        <Parameter Name="cacheInvalidationThresholdMaximum" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="target">Das Abhängigkeitsobjekt, für das der Wert der <see cref="P:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMaximum" />-Eigenschaft festgelegt werden soll.</param>
        <param name="cacheInvalidationThresholdMaximum">Der neue Wert, auf den die Eigenschaft festgelegt werden soll.</param>
        <summary>Legt den Wert der angefügten <see cref="P:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMaximum" />-Eigenschaft für ein angegebenes Abhängigkeitsobjekt fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode zum Festlegen der <xref:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMaximum%2A> angefügte Eigenschaft im Code.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie mit die Zwischenspeicherungshinweisoption für eine <xref:System.Windows.Media.DrawingBrush>.  
  
 [!code-csharp[RenderOptions#RenderOptionsSnippet3](~/samples/snippets/csharp/VS_Snippets_Wpf/RenderOptions/CSharp/Window1.xaml.cs#renderoptionssnippet3)]
 [!code-vb[RenderOptions#RenderOptionsSnippet3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RenderOptions/visualbasic/window1.xaml.vb#renderoptionssnippet3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der angegebene <paramref name="target" /> ist gleich <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Media.RenderOptions.SetCachingHint(System.Windows.DependencyObject,System.Windows.Media.CachingHint)" />
        <altmember cref="M:System.Windows.Media.RenderOptions.SetCacheInvalidationThresholdMinimum(System.Windows.DependencyObject,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="SetCacheInvalidationThresholdMinimum">
      <MemberSignature Language="C#" Value="public static void SetCacheInvalidationThresholdMinimum (System.Windows.DependencyObject target, double cacheInvalidationThresholdMinimum);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCacheInvalidationThresholdMinimum(class System.Windows.DependencyObject target, float64 cacheInvalidationThresholdMinimum) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.RenderOptions.SetCacheInvalidationThresholdMinimum(System.Windows.DependencyObject,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCacheInvalidationThresholdMinimum (target As DependencyObject, cacheInvalidationThresholdMinimum As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCacheInvalidationThresholdMinimum(System::Windows::DependencyObject ^ target, double cacheInvalidationThresholdMinimum);" />
      <MemberSignature Language="F#" Value="static member SetCacheInvalidationThresholdMinimum : System.Windows.DependencyObject * double -&gt; unit" Usage="System.Windows.Media.RenderOptions.SetCacheInvalidationThresholdMinimum (target, cacheInvalidationThresholdMinimum)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
        <Parameter Name="cacheInvalidationThresholdMinimum" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="target">Das Abhängigkeitsobjekt, für das der Wert der <see cref="P:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMinimum" />-Eigenschaft festgelegt werden soll.</param>
        <param name="cacheInvalidationThresholdMinimum">Der neue Wert, auf den die Eigenschaft festgelegt werden soll.</param>
        <summary>Legt den Wert der angefügten <see cref="P:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMinimum" />-Eigenschaft für ein angegebenes Abhängigkeitsobjekt fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode zum Festlegen der <xref:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMinimum%2A> angefügte Eigenschaft im Code.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie mit die Zwischenspeicherungshinweisoption für eine <xref:System.Windows.Media.DrawingBrush>.  
  
 [!code-csharp[RenderOptions#RenderOptionsSnippet3](~/samples/snippets/csharp/VS_Snippets_Wpf/RenderOptions/CSharp/Window1.xaml.cs#renderoptionssnippet3)]
 [!code-vb[RenderOptions#RenderOptionsSnippet3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RenderOptions/visualbasic/window1.xaml.vb#renderoptionssnippet3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der angegebene <paramref name="target" /> ist gleich <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Media.RenderOptions.SetCachingHint(System.Windows.DependencyObject,System.Windows.Media.CachingHint)" />
        <altmember cref="M:System.Windows.Media.RenderOptions.SetCacheInvalidationThresholdMaximum(System.Windows.DependencyObject,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="SetCachingHint">
      <MemberSignature Language="C#" Value="public static void SetCachingHint (System.Windows.DependencyObject target, System.Windows.Media.CachingHint cachingHint);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCachingHint(class System.Windows.DependencyObject target, valuetype System.Windows.Media.CachingHint cachingHint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.RenderOptions.SetCachingHint(System.Windows.DependencyObject,System.Windows.Media.CachingHint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCachingHint(System::Windows::DependencyObject ^ target, System::Windows::Media::CachingHint cachingHint);" />
      <MemberSignature Language="F#" Value="static member SetCachingHint : System.Windows.DependencyObject * System.Windows.Media.CachingHint -&gt; unit" Usage="System.Windows.Media.RenderOptions.SetCachingHint (target, cachingHint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
        <Parameter Name="cachingHint" Type="System.Windows.Media.CachingHint" />
      </Parameters>
      <Docs>
        <param name="target">Das Abhängigkeitsobjekt, für das der Wert der <see cref="P:System.Windows.Media.RenderOptions.CachingHint" />-Eigenschaft festgelegt werden soll.</param>
        <param name="cachingHint">Der neue Wert, auf den die Eigenschaft festgelegt werden soll.</param>
        <summary>Legt den Wert der angefügten <see cref="P:System.Windows.Media.RenderOptions.CachingHint" />-Eigenschaft für ein angegebenes Abhängigkeitsobjekt fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der Standardeinstellung [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] zwischenspeichert, wenn der gerenderte Inhalt von <xref:System.Windows.Media.DrawingBrush> und <xref:System.Windows.Media.VisualBrush> Objekte. In statischen Szenarios, in denen weder der Inhalt noch die Verwendung des Pinsels in der Szene geändert werden, bietet nicht Zwischenspeichern der Vorteil, da Videospeicher gespart wird. Wenn ein Pinsel mit statischem Inhalt verwendet wird, auf nicht statische Weise das Standardverhalten des [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] erneuten Rendern der gesamte Inhalt des Pinsels wird jeden Frame, selbst wenn der Inhalt unverändert bleibt. Angenommen, dies geschieht, wenn eine statische <xref:System.Windows.Media.DrawingBrush> oder <xref:System.Windows.Media.VisualBrush> der Oberfläche eines sich drehenden 3D-Objekts zugeordnet ist. Den statischen Inhalt erneut zu rendern kann sich negativ auf die Leistung auswirken.  
  
 Durch Festlegen der <xref:System.Windows.Media.RenderOptions.CachingHint%2A> angefügte Eigenschaft des Pinsels auf <xref:System.Windows.Media.CachingHint.Cache>, Sie können die Leistung mithilfe von zwischengespeicherten Versionen der gekachelten Pinselobjekte erhöhen.  
  
 Die <xref:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMinimum%2A> und <xref:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMaximum%2A> Eigenschaftswerte sind Werte von relativer Größe, die bestimmen, wann die <xref:System.Windows.Media.TileBrush> Objekt aufgrund einer geänderten Skalierung neu generiert werden sollte. Z. B., wenn die <xref:System.Windows.Media.RenderOptions.CacheInvalidationThresholdMaximum%2A> -Eigenschaftensatz auf 2.0, den Cache für die <xref:System.Windows.Media.TileBrush> muss erneut generiert werden, nur, wenn seine Größe doppelt so groß wie die Größe des aktuellen Caches überschreitet.  
  
 Verwenden Sie diese Methode zum Festlegen der <xref:System.Windows.Media.RenderOptions.CachingHint%2A> angefügte Eigenschaft im Code.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie mit die Zwischenspeicherungshinweisoption für eine <xref:System.Windows.Media.DrawingBrush>.  
  
 [!code-csharp[RenderOptions#RenderOptionsSnippet3](~/samples/snippets/csharp/VS_Snippets_Wpf/RenderOptions/CSharp/Window1.xaml.cs#renderoptionssnippet3)]
 [!code-vb[RenderOptions#RenderOptionsSnippet3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RenderOptions/visualbasic/window1.xaml.vb#renderoptionssnippet3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der angegebene <paramref name="target" /> ist gleich <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Media.RenderOptions.SetCacheInvalidationThresholdMaximum(System.Windows.DependencyObject,System.Double)" />
        <altmember cref="M:System.Windows.Media.RenderOptions.SetCacheInvalidationThresholdMinimum(System.Windows.DependencyObject,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="SetClearTypeHint">
      <MemberSignature Language="C#" Value="public static void SetClearTypeHint (System.Windows.DependencyObject target, System.Windows.Media.ClearTypeHint clearTypeHint);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetClearTypeHint(class System.Windows.DependencyObject target, valuetype System.Windows.Media.ClearTypeHint clearTypeHint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.RenderOptions.SetClearTypeHint(System.Windows.DependencyObject,System.Windows.Media.ClearTypeHint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetClearTypeHint(System::Windows::DependencyObject ^ target, System::Windows::Media::ClearTypeHint clearTypeHint);" />
      <MemberSignature Language="F#" Value="static member SetClearTypeHint : System.Windows.DependencyObject * System.Windows.Media.ClearTypeHint -&gt; unit" Usage="System.Windows.Media.RenderOptions.SetClearTypeHint (target, clearTypeHint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="clearTypeHint" Type="System.Windows.Media.ClearTypeHint" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="target">Die <see cref="T:System.Windows.DependencyObject" /> Festlegen der <see cref="P:System.Windows.Media.RenderOptions.ClearTypeHint" /> angefügte Eigenschaft auf.</param>
        <param name="clearTypeHint">Der neue <see cref="P:System.Windows.Media.RenderOptions.ClearTypeHint" />-Wert.</param>
        <summary>Legt den Wert für die <see cref="P:System.Windows.Media.RenderOptions.ClearTypeHint" /> angefügte Eigenschaft des angegebenen Elements.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Der angegebene <paramref name="target" /> ist gleich <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetEdgeMode">
      <MemberSignature Language="C#" Value="public static void SetEdgeMode (System.Windows.DependencyObject target, System.Windows.Media.EdgeMode edgeMode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetEdgeMode(class System.Windows.DependencyObject target, valuetype System.Windows.Media.EdgeMode edgeMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.RenderOptions.SetEdgeMode(System.Windows.DependencyObject,System.Windows.Media.EdgeMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetEdgeMode(System::Windows::DependencyObject ^ target, System::Windows::Media::EdgeMode edgeMode);" />
      <MemberSignature Language="F#" Value="static member SetEdgeMode : System.Windows.DependencyObject * System.Windows.Media.EdgeMode -&gt; unit" Usage="System.Windows.Media.RenderOptions.SetEdgeMode (target, edgeMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
        <Parameter Name="edgeMode" Type="System.Windows.Media.EdgeMode" />
      </Parameters>
      <Docs>
        <param name="target">Das Abhängigkeitsobjekt, für das der Wert der <see cref="P:System.Windows.Media.RenderOptions.EdgeMode" />-Eigenschaft festgelegt werden soll.</param>
        <param name="edgeMode">Der neue Wert, auf den die Eigenschaft festgelegt werden soll.</param>
        <summary>Legt den Wert der angefügten <see cref="P:System.Windows.Media.RenderOptions.EdgeMode" />-Eigenschaft für ein angegebenes Abhängigkeitsobjekt fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Textobjekte werden immer mit Antialiasing angezeigt und sind durch Festlegen des Werts der Edge-Modus nicht betroffen. Wenn Sie den Wert des Edge-Modus eines visuellen Objekts festlegen, werden alle untergeordneten Zeichnungsprimitiven des visuellen Objekts auf den gleichen Wert des Edge-Modus festgelegt.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie mit der <xref:System.Windows.Media.RenderOptions.SetEdgeMode%2A> Methode zum Festlegen der Edge-Modus für ein visuelles Objekt zu <xref:System.Windows.Media.EdgeMode.Aliased>.  
  
 [!code-csharp[VisualSnippets#SetEdgeMode](~/samples/snippets/csharp/VS_Snippets_Wpf/VisualSnippets/CSharp/Snippets.cs#setedgemode)]
 [!code-vb[VisualSnippets#SetEdgeMode](~/samples/snippets/visualbasic/VS_Snippets_Wpf/VisualSnippets/visualbasic/snippets.vb#setedgemode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der angegebene <paramref name="target" /> ist gleich <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>