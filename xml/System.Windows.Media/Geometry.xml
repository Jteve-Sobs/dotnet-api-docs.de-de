<Type Name="Geometry" FullName="System.Windows.Media.Geometry">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="105b1b7938c2a6547065e81d2e24486607e9baa0" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37553660" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Geometry : System.Windows.Media.Animation.Animatable, IFormattable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract Geometry extends System.Windows.Media.Animation.Animatable implements class System.IFormattable" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Media.Geometry" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Geometry&#xA;Inherits Animatable&#xA;Implements IFormattable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Geometry abstract : System::Windows::Media::Animation::Animatable, IFormattable" />
  <TypeSignature Language="F#" Value="type Geometry = class&#xA;    inherit Animatable&#xA;    interface IFormattable&#xA;    interface DUCE.IResource" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Media.Animation.Animatable</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.Media.GeometryConverter))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.ValueSerializer(typeof(System.Windows.Media.Converters.GeometryValueSerializer))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Classes that derive from this abstract base class define geometric shapes. <see cref="T:System.Windows.Media.Geometry" /> objects can be used for clipping, hit-testing, and rendering 2-D graphic data.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="geometry-compared-to-shape"></a>Im Vergleich zu einer Form vom Typ Geometry  
 Die <xref:System.Windows.Shapes.Shape?displayProperty=nameWithType> -Klasse verfügt über eine <xref:System.Windows.Shapes.Shape.Fill%2A>, <xref:System.Windows.Shapes.Shape.Stroke%2A>, und andere Eigenschaften zu rendern, die <xref:System.Windows.Media.Geometry> und das Fehlen von abgeleiteten Klassen. Die <xref:System.Windows.Shapes.Shape> -Klasse ist eine <xref:System.Windows.FrameworkElement> und aus diesem Grund ist das Layoutsystem; Teil davon abgeleiteten Klassen können verwendet werden, wie der Inhalt eines Elements, das unterstützt <xref:System.Windows.UIElement> untergeordnete Elemente.  
  
 Die <xref:System.Windows.Media.Geometry> -Klasse, auf der anderen Seite einfach die Geometrie einer Form definiert und kann nicht selbst gerendert. Aufgrund seiner Einfachheit hat es eine größere Anzahl von verwendet wird.  
  
 **Funktionen von Freezable:** , da es erbt die <xref:System.Windows.Freezable> -Klasse, die <xref:System.Windows.Media.Geometry> stellt mehrere spezielle Features bereit: <xref:System.Windows.Media.Geometry> Objekte deklariert werden können, wie für mehrere Objekte, die zur Verbesserung der Schreibschutz versehen wurden freigegeben Leistung, geklont und threadsicher gemacht. Weitere Informationen zu den verschiedenen Funktionen von <xref:System.Windows.Freezable> Objekten finden Sie [Übersicht über Freezable-Objekte](~/docs/framework/wpf/advanced/freezable-objects-overview.md).  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>Obwohl diese Klasse abstrakt ist, ist er nicht öffentlich erweiterbar.</para>
    </block>
    <altmember cref="T:System.Windows.Shapes.Path" />
  </Docs>
  <Members>
    <Member MemberName="Bounds">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Rect Bounds { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Rect Bounds" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Geometry.Bounds" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Bounds As Rect" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Rect Bounds { System::Windows::Rect get(); };" />
      <MemberSignature Language="F#" Value="member this.Bounds : System.Windows.Rect" Usage="System.Windows.Media.Geometry.Bounds" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Rect</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a <see cref="T:System.Windows.Rect" /> that specifies the axis-aligned bounding box of the <see cref="T:System.Windows.Media.Geometry" />.</summary>
        <value>Die an einer Achse ausgerichtete umgebende Feld von der <see cref="T:System.Windows.Media.Geometry" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ist den Bereich, der möglicherweise durch die Strichbreite hinzugefügt nicht berücksichtigt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Geometry Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Media.Geometry Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Geometry.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Geometry" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::Geometry ^ Clone();" />
      <MemberSignature Language="F#" Value="override this.Clone : unit -&gt; System.Windows.Media.Geometry" Usage="geometry.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Geometry</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Creates a modifiable clone of the <see cref="T:System.Windows.Media.Geometry" />, making deep copies of the object's values. When copying dependency properties, this method copies resource references and data bindings (but they might no longer resolve) but not animations or their current values.</summary>
        <returns>A modifiable clone of the current object. The cloned object's <see cref="P:System.Windows.Freezable.IsFrozen" /> property will be <see langword="false" /> even if the source's <see cref="P:System.Windows.Freezable.IsFrozen" /> property was <see langword="true." /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird verwendet, um änderbare Kopien zu erzeugen fixierten <xref:System.Windows.Freezable> Objekte (oder ein beliebiges <xref:System.Windows.Freezable> Objekt). Der Einfachheit halber führt Shadowing für diese Methode die geerbte Version mit einer Implementierung mit starker Typisierung.  
  
 Weitere Informationen finden Sie unter <xref:System.Windows.Freezable.Clone%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValue">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Geometry CloneCurrentValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Media.Geometry CloneCurrentValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Geometry.CloneCurrentValue" />
      <MemberSignature Language="VB.NET" Value="Public Function CloneCurrentValue () As Geometry" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::Geometry ^ CloneCurrentValue();" />
      <MemberSignature Language="F#" Value="member this.CloneCurrentValue : unit -&gt; System.Windows.Media.Geometry" Usage="geometry.CloneCurrentValue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Geometry</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Creates a modifiable clone of the <see cref="T:System.Windows.Media.Geometry" /> object, making deep copies of the object's current values. Resource references, data bindings, and animations are not copied, but their current values are.</summary>
        <returns>A modifiable clone of the current object. The cloned object's <see cref="P:System.Windows.Freezable.IsFrozen" /> property will be <see langword="false" /> even if the source's <see cref="P:System.Windows.Freezable.IsFrozen" /> property was <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird verwendet, um änderbare Kopien zu erzeugen fixierten <xref:System.Windows.Freezable> Objekte (oder ein beliebiges <xref:System.Windows.Freezable> Objekt). Der Einfachheit halber führt Shadowing für diese Methode die geerbte Version mit einer Implementierung mit starker Typisierung.  
  
 Weitere Informationen finden Sie unter <xref:System.Windows.Freezable.CloneCurrentValue%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Combine">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Combines two <see cref="T:System.Windows.Media.Geometry" /> objects.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static System.Windows.Media.PathGeometry Combine (System.Windows.Media.Geometry geometry1, System.Windows.Media.Geometry geometry2, System.Windows.Media.GeometryCombineMode mode, System.Windows.Media.Transform transform);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Media.PathGeometry Combine(class System.Windows.Media.Geometry geometry1, class System.Windows.Media.Geometry geometry2, valuetype System.Windows.Media.GeometryCombineMode mode, class System.Windows.Media.Transform transform) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Geometry.Combine(System.Windows.Media.Geometry,System.Windows.Media.Geometry,System.Windows.Media.GeometryCombineMode,System.Windows.Media.Transform)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Media::PathGeometry ^ Combine(System::Windows::Media::Geometry ^ geometry1, System::Windows::Media::Geometry ^ geometry2, System::Windows::Media::GeometryCombineMode mode, System::Windows::Media::Transform ^ transform);" />
      <MemberSignature Language="F#" Value="static member Combine : System.Windows.Media.Geometry * System.Windows.Media.Geometry * System.Windows.Media.GeometryCombineMode * System.Windows.Media.Transform -&gt; System.Windows.Media.PathGeometry" Usage="System.Windows.Media.Geometry.Combine (geometry1, geometry2, mode, transform)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.PathGeometry</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="geometry1" Type="System.Windows.Media.Geometry" />
        <Parameter Name="geometry2" Type="System.Windows.Media.Geometry" />
        <Parameter Name="mode" Type="System.Windows.Media.GeometryCombineMode" />
        <Parameter Name="transform" Type="System.Windows.Media.Transform" />
      </Parameters>
      <Docs>
        <param name="geometry1">The first geometry to combine.</param>
        <param name="geometry2">The second geometry to combine.</param>
        <param name="mode">One of the enumeration values that specifies how the geometries are combined.</param>
        <param name="transform">A transformation to apply to the combined geometry, or <see langword="null" />.</param>
        <summary>Combines the two geometries using the specified <see cref="T:System.Windows.Media.GeometryCombineMode" /> and applies the specified transform to the resulting geometry.</summary>
        <returns>The combined geometry.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verwendet die Standard-Toleranzfaktor (beschriebenen der <xref:System.Windows.Media.Geometry.StandardFlatteningTolerance%2A> Eigenschaft) beim Kombinieren der Geometrien. Um einen eigenen Toleranzfaktor anzugeben, verwenden die <xref:System.Windows.Media.Geometry.Combine%2A> Methode.  
  
 Einige <xref:System.Windows.Media.Geometry> Methoden (z. B. <xref:System.Windows.Media.Geometry.Combine%2A>) zu erzeugen, oder verwenden Sie eine polygonale Approximation der Geometrie. Der Toleranzfaktor gibt die maximale Entfernung zwischen Punkten in der polygonalen Approximation an. Kleinere Toleranzwerte liefern bessere Approximationen, aber erfordert eine höhere verarbeitungsleistung als eine Approximation mit großer Toleranzfaktor.  
  
 Sollte eine sorgfältige Überlegungen einbezogen werden, bei Verwendung <xref:System.Windows.Media.Geometry.Combine%2A> auf eine Union ausgeführt werden, da es CPU sehr teuer sein kann. In den meisten Fällen eine <xref:System.Windows.Media.GeometryGroup> oder <xref:System.Windows.Media.PathGeometry.AddGeometry%2A> besser funktioniert.  
  
 Verwendung <xref:System.Windows.Media.Geometry.Combine%2A> nur, wenn eine der folgenden Bedingungen zutrifft:  
  
-   Der geometrische Vorgang ist es sich nicht um eine Union.  
  
-   Entweder der Geometrien eine <xref:System.Windows.Media.FillRule> Wert <xref:System.Windows.Media.FillRule.EvenOdd> und die Geometrien überschneiden sich (d. h. die <xref:System.Windows.Media.FillRule> ist relevant).  
  
-   Die Uhrzeit ist nicht relevant, aber Leerzeichen sind (z. B. wenn die Geometrie einmal erstellt und dann zwischengespeichert). In der Regel <xref:System.Windows.Media.Geometry.Combine%2A> erzeugt kleinere Ausgabe als <xref:System.Windows.Media.PathGeometry.AddGeometry%2A>.  
  
-   Die resultierende Geometrie gestrichelt oder in eine Pfadanimation verwendet wird und <xref:System.Windows.Media.PathGeometry.AddGeometry%2A> bietet nicht die gewünschte Kontur.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static System.Windows.Media.PathGeometry Combine (System.Windows.Media.Geometry geometry1, System.Windows.Media.Geometry geometry2, System.Windows.Media.GeometryCombineMode mode, System.Windows.Media.Transform transform, double tolerance, System.Windows.Media.ToleranceType type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Media.PathGeometry Combine(class System.Windows.Media.Geometry geometry1, class System.Windows.Media.Geometry geometry2, valuetype System.Windows.Media.GeometryCombineMode mode, class System.Windows.Media.Transform transform, float64 tolerance, valuetype System.Windows.Media.ToleranceType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Geometry.Combine(System.Windows.Media.Geometry,System.Windows.Media.Geometry,System.Windows.Media.GeometryCombineMode,System.Windows.Media.Transform,System.Double,System.Windows.Media.ToleranceType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Media::PathGeometry ^ Combine(System::Windows::Media::Geometry ^ geometry1, System::Windows::Media::Geometry ^ geometry2, System::Windows::Media::GeometryCombineMode mode, System::Windows::Media::Transform ^ transform, double tolerance, System::Windows::Media::ToleranceType type);" />
      <MemberSignature Language="F#" Value="static member Combine : System.Windows.Media.Geometry * System.Windows.Media.Geometry * System.Windows.Media.GeometryCombineMode * System.Windows.Media.Transform * double * System.Windows.Media.ToleranceType -&gt; System.Windows.Media.PathGeometry" Usage="System.Windows.Media.Geometry.Combine (geometry1, geometry2, mode, transform, tolerance, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.PathGeometry</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="geometry1" Type="System.Windows.Media.Geometry" />
        <Parameter Name="geometry2" Type="System.Windows.Media.Geometry" />
        <Parameter Name="mode" Type="System.Windows.Media.GeometryCombineMode" />
        <Parameter Name="transform" Type="System.Windows.Media.Transform" />
        <Parameter Name="tolerance" Type="System.Double" />
        <Parameter Name="type" Type="System.Windows.Media.ToleranceType" />
      </Parameters>
      <Docs>
        <param name="geometry1">The first geometry to combine.</param>
        <param name="geometry2">The second geometry to combine.</param>
        <param name="mode">One of the enumeration values that specifies how the geometries are combined.</param>
        <param name="transform">A transformation to apply to the combined geometry, or <see langword="null" />.</param>
        <param name="tolerance">The maximum bounds on the distance between points in the polygonal approximation of the geometries. Smaller values produce more accurate results but cause slower execution. If <c>tolerance</c> is less than .000001, .000001 is used instead.</param>
        <param name="type">One of the <see cref="T:System.Windows.Media.ToleranceType" /> values that specifies whether the tolerance factor is an absolute value or relative to the area of the geometry.</param>
        <summary>Combines the two geometries using the specified <see cref="T:System.Windows.Media.GeometryCombineMode" /> and tolerance factor, and applies the specified transform to the resulting geometry.</summary>
        <returns>The combined geometry.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Einige <xref:System.Windows.Media.Geometry> Methoden (z. B. <xref:System.Windows.Media.Geometry.Combine%2A>) zu erzeugen, oder verwenden Sie eine polygonale Approximation der Geometrie. Der Toleranzfaktor gibt die maximale Entfernung zwischen Punkten in der polygonalen Approximation an. Kleinere Toleranzwerte liefern bessere Approximationen, aber erfordert eine höhere verarbeitungsleistung als eine Approximation mit großer Toleranzfaktor.  
  
 Sollte eine sorgfältige Überlegungen einbezogen werden, bei Verwendung <xref:System.Windows.Media.Geometry.Combine%2A> auf eine Union ausgeführt werden, da es CPU sehr teuer sein kann. In den meisten Fällen eine <xref:System.Windows.Media.GeometryGroup> oder <xref:System.Windows.Media.PathGeometry.AddGeometry%2A> besser funktioniert.  
  
 Verwendung <xref:System.Windows.Media.Geometry.Combine%2A> nur, wenn eine der folgenden Bedingungen zutrifft:  
  
-   Der geometrische Vorgang ist es sich nicht um eine Union.  
  
-   Entweder der Geometrien eine <xref:System.Windows.Media.FillRule> Wert <xref:System.Windows.Media.FillRule.EvenOdd> und die Geometrien überschneiden sich (d. h. die <xref:System.Windows.Media.FillRule> ist relevant).  
  
-   Die Uhrzeit ist nicht relevant, aber Leerzeichen sind (z. B. wenn die Geometrie einmal erstellt und dann zwischengespeichert). In der Regel <xref:System.Windows.Media.Geometry.Combine%2A> erzeugt kleinere Ausgabe als <xref:System.Windows.Media.PathGeometry.AddGeometry%2A>.  
  
-   Die resultierende Geometrie gestrichelt oder in eine Pfadanimation verwendet wird und <xref:System.Windows.Media.PathGeometry.AddGeometry%2A> bietet nicht die gewünschte Kontur.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Empty">
      <MemberSignature Language="C#" Value="public static System.Windows.Media.Geometry Empty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Media.Geometry Empty" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Geometry.Empty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Empty As Geometry" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Media::Geometry ^ Empty { System::Windows::Media::Geometry ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Empty : System.Windows.Media.Geometry" Usage="System.Windows.Media.Geometry.Empty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Geometry</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets an empty object.</summary>
        <value>Das leere Geometrieobjekt.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="FillContains">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Indicates whether the <see cref="T:System.Windows.Media.Geometry" /> completely contains the specified <see cref="T:System.Windows.Media.Geometry" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FillContains">
      <MemberSignature Language="C#" Value="public bool FillContains (System.Windows.Media.Geometry geometry);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool FillContains(class System.Windows.Media.Geometry geometry) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Geometry.FillContains(System.Windows.Media.Geometry)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool FillContains(System::Windows::Media::Geometry ^ geometry);" />
      <MemberSignature Language="F#" Value="member this.FillContains : System.Windows.Media.Geometry -&gt; bool" Usage="geometry.FillContains geometry" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="geometry" Type="System.Windows.Media.Geometry" />
      </Parameters>
      <Docs>
        <param name="geometry">The geometry to test for containment.</param>
        <summary>Indicates whether the current geometry completely contains the specified <see cref="T:System.Windows.Media.Geometry" />.</summary>
        <returns>
          <see langword="true" /> if the current geometry completely contains <paramref name="geometry" />; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der standardmäßige Fehlergrenze (beschriebenen der <xref:System.Windows.Media.Geometry.StandardFlatteningTolerance%2A> Eigenschaft) wird verwendet, wenn Sie bestimmen, ob die aktuelle Geometrie die angegebene Geometry-Instanz enthält. Verwenden Sie zum Angeben Ihrer eigenen Fehlergrenze die <xref:System.Windows.Media.Geometry.FillContains%2A> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FillContains">
      <MemberSignature Language="C#" Value="public bool FillContains (System.Windows.Point hitPoint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool FillContains(valuetype System.Windows.Point hitPoint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Geometry.FillContains(System.Windows.Point)" />
      <MemberSignature Language="VB.NET" Value="Public Function FillContains (hitPoint As Point) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool FillContains(System::Windows::Point hitPoint);" />
      <MemberSignature Language="F#" Value="member this.FillContains : System.Windows.Point -&gt; bool" Usage="geometry.FillContains hitPoint" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hitPoint" Type="System.Windows.Point" />
      </Parameters>
      <Docs>
        <param name="hitPoint">The point to test for containment.</param>
        <summary>Indicates whether the geometry contains the specified <see cref="T:System.Windows.Point" />.</summary>
        <returns>
          <see langword="true" /> if the geometry contains <paramref name="hitPoint" />; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Standard-Toleranzfaktor (beschriebenen der <xref:System.Windows.Media.Geometry.StandardFlatteningTolerance%2A> Eigenschaft) wird verwendet, wenn Sie bestimmen, ob die Geometrie den angegebenen Punkt enthält. Um einen eigenen Toleranzfaktor anzugeben, verwenden die <xref:System.Windows.Media.Geometry.FillContains%2A> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FillContains">
      <MemberSignature Language="C#" Value="public bool FillContains (System.Windows.Media.Geometry geometry, double tolerance, System.Windows.Media.ToleranceType type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool FillContains(class System.Windows.Media.Geometry geometry, float64 tolerance, valuetype System.Windows.Media.ToleranceType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Geometry.FillContains(System.Windows.Media.Geometry,System.Double,System.Windows.Media.ToleranceType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool FillContains(System::Windows::Media::Geometry ^ geometry, double tolerance, System::Windows::Media::ToleranceType type);" />
      <MemberSignature Language="F#" Value="member this.FillContains : System.Windows.Media.Geometry * double * System.Windows.Media.ToleranceType -&gt; bool" Usage="geometry.FillContains (geometry, tolerance, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="geometry" Type="System.Windows.Media.Geometry" />
        <Parameter Name="tolerance" Type="System.Double" />
        <Parameter Name="type" Type="System.Windows.Media.ToleranceType" />
      </Parameters>
      <Docs>
        <param name="geometry">The geometry to test for containment.</param>
        <param name="tolerance">The maximum bounds on the distance between points in the polygonal approximation of the geometries. Smaller values produce more accurate results but cause slower execution. If <c>tolerance</c> is less than .000001, .000001 is used instead.</param>
        <param name="type">One of the <see cref="T:System.Windows.Media.ToleranceType" /> values that specifies whether the tolerance factor is an absolute value or relative to the area of the geometry.</param>
        <summary>Indicates whether the current geometry contains the specified <see cref="T:System.Windows.Media.Geometry" />, given the specified margin of error.</summary>
        <returns>
          <see langword="true" /> if the current geometry contains <paramref name="geometry" />, given the specified margin of error; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Einige <xref:System.Windows.Media.Geometry> Methoden (z. B. <xref:System.Windows.Media.Geometry.FillContains%2A>) zu erzeugen, oder verwenden Sie eine polygonale Approximation der Geometrie. Der Toleranzfaktor gibt die maximale Entfernung zwischen Punkten in der polygonalen Approximation an. Kleinere Toleranzwerte liefern bessere Approximationen, aber erfordert eine höhere verarbeitungsleistung als eine Approximation mit großer Toleranzfaktor.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FillContains">
      <MemberSignature Language="C#" Value="public bool FillContains (System.Windows.Point hitPoint, double tolerance, System.Windows.Media.ToleranceType type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool FillContains(valuetype System.Windows.Point hitPoint, float64 tolerance, valuetype System.Windows.Media.ToleranceType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Geometry.FillContains(System.Windows.Point,System.Double,System.Windows.Media.ToleranceType)" />
      <MemberSignature Language="VB.NET" Value="Public Function FillContains (hitPoint As Point, tolerance As Double, type As ToleranceType) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool FillContains(System::Windows::Point hitPoint, double tolerance, System::Windows::Media::ToleranceType type);" />
      <MemberSignature Language="F#" Value="member this.FillContains : System.Windows.Point * double * System.Windows.Media.ToleranceType -&gt; bool" Usage="geometry.FillContains (hitPoint, tolerance, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hitPoint" Type="System.Windows.Point" />
        <Parameter Name="tolerance" Type="System.Double" />
        <Parameter Name="type" Type="System.Windows.Media.ToleranceType" />
      </Parameters>
      <Docs>
        <param name="hitPoint">The point to test for containment.</param>
        <param name="tolerance">The maximum bounds on the distance between points in the polygonal approximation of the geometry. Smaller values produce more accurate results but cause slower execution. If <c>tolerance</c> is less than .000001, .000001 is used instead.</param>
        <param name="type">One of the <see cref="T:System.Windows.Media.ToleranceType" /> values that specifies whether the tolerance factor is an absolute value or relative to the area of the geometry.</param>
        <summary>Indicates whether the geometry contains the specified <see cref="T:System.Windows.Point" />, given the specified margin of error.</summary>
        <returns>
          <see langword="true" /> if the geometry contains <paramref name="hitPoint" />, given the specified margin of error; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Einige <xref:System.Windows.Media.Geometry> Methoden (z. B. <xref:System.Windows.Media.Geometry.FillContains%2A>) zu erzeugen, oder verwenden Sie eine polygonale Approximation der Geometrie. Der Toleranzfaktor gibt die maximale Entfernung zwischen Punkten in der polygonalen Approximation an. Kleinere Toleranzwerte liefern bessere Approximationen, aber erfordert eine höhere verarbeitungsleistung als eine Approximation mit großer Toleranzfaktor.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="FillContainsWithDetail">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns a value that describes the intersection between the geometry and the specified geometry.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FillContainsWithDetail">
      <MemberSignature Language="C#" Value="public System.Windows.Media.IntersectionDetail FillContainsWithDetail (System.Windows.Media.Geometry geometry);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Media.IntersectionDetail FillContainsWithDetail(class System.Windows.Media.Geometry geometry) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Geometry.FillContainsWithDetail(System.Windows.Media.Geometry)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::IntersectionDetail FillContainsWithDetail(System::Windows::Media::Geometry ^ geometry);" />
      <MemberSignature Language="F#" Value="member this.FillContainsWithDetail : System.Windows.Media.Geometry -&gt; System.Windows.Media.IntersectionDetail" Usage="geometry.FillContainsWithDetail geometry" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.IntersectionDetail</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="geometry" Type="System.Windows.Media.Geometry" />
      </Parameters>
      <Docs>
        <param name="geometry">The geometry to test for containment.</param>
        <summary>Returns a value that describes the intersection between the current geometry and the specified geometry.</summary>
        <returns>One of the enumeration values.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Standard-Toleranzfaktor (definiert durch die <xref:System.Windows.Media.Geometry.StandardFlatteningTolerance%2A> Eigenschaft) wird verwendet, wenn Sie bestimmen, ob die aktuelle Geometrie die angegebene Geometry-Instanz enthält. Um einen eigenen Toleranzfaktor anzugeben, verwenden die <xref:System.Windows.Media.Geometry.FillContainsWithDetail%2A> Methode.  
  
 Einige <xref:System.Windows.Media.Geometry> Methoden (z. B. <xref:System.Windows.Media.Geometry.FillContainsWithDetail%2A>) zu erzeugen, oder verwenden Sie eine polygonale Approximation der Geometrie. Der Toleranzfaktor gibt die maximale Entfernung zwischen Punkten in der polygonalen Approximation an. Kleinere Toleranzwerte liefern bessere Approximationen, aber erfordert eine höhere verarbeitungsleistung als eine Approximation mit großer Toleranzfaktor.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FillContainsWithDetail">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Media.IntersectionDetail FillContainsWithDetail (System.Windows.Media.Geometry geometry, double tolerance, System.Windows.Media.ToleranceType type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Windows.Media.IntersectionDetail FillContainsWithDetail(class System.Windows.Media.Geometry geometry, float64 tolerance, valuetype System.Windows.Media.ToleranceType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Geometry.FillContainsWithDetail(System.Windows.Media.Geometry,System.Double,System.Windows.Media.ToleranceType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Windows::Media::IntersectionDetail FillContainsWithDetail(System::Windows::Media::Geometry ^ geometry, double tolerance, System::Windows::Media::ToleranceType type);" />
      <MemberSignature Language="F#" Value="abstract member FillContainsWithDetail : System.Windows.Media.Geometry * double * System.Windows.Media.ToleranceType -&gt; System.Windows.Media.IntersectionDetail&#xA;override this.FillContainsWithDetail : System.Windows.Media.Geometry * double * System.Windows.Media.ToleranceType -&gt; System.Windows.Media.IntersectionDetail" Usage="geometry.FillContainsWithDetail (geometry, tolerance, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.IntersectionDetail</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="geometry" Type="System.Windows.Media.Geometry" />
        <Parameter Name="tolerance" Type="System.Double" />
        <Parameter Name="type" Type="System.Windows.Media.ToleranceType" />
      </Parameters>
      <Docs>
        <param name="geometry">The geometry to test for containment.</param>
        <param name="tolerance">The maximum bounds on the distance between points in the polygonal approximation of the geometries. Smaller values produce more accurate results but cause slower execution. If <c>tolerance</c> is less than .000001, .000001 is used instead.</param>
        <param name="type">One of the <see cref="T:System.Windows.Media.ToleranceType" /> values that specifies whether the tolerance factor is an absolute value or relative to the area of the geometry.</param>
        <summary>Returns a value that describes the intersection between the current geometry and the specified geometry, given the specified margin of error.</summary>
        <returns>One of the enumeration values.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Einige <xref:System.Windows.Media.Geometry> Methoden (z. B. <xref:System.Windows.Media.Geometry.FillContainsWithDetail%2A>) zu erzeugen, oder verwenden Sie eine polygonale Approximation der Geometrie. Der Toleranzfaktor gibt die maximale Entfernung zwischen Punkten in der polygonalen Approximation an. Kleinere Toleranzwerte liefern bessere Approximationen, aber erfordert eine höhere verarbeitungsleistung als eine Approximation mit großer Toleranzfaktor.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetArea">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gets the area of the filled region of a <see cref="T:System.Windows.Media.Geometry" /> object.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetArea">
      <MemberSignature Language="C#" Value="public double GetArea ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance float64 GetArea() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Geometry.GetArea" />
      <MemberSignature Language="VB.NET" Value="Public Function GetArea () As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; double GetArea();" />
      <MemberSignature Language="F#" Value="member this.GetArea : unit -&gt; double" Usage="geometry.GetArea " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets the area of the filled region of the <see cref="T:System.Windows.Media.Geometry" /> object.</summary>
        <returns>The area of the filled region of the geometry.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Einige <xref:System.Windows.Media.Geometry> Methoden (z. B. <xref:System.Windows.Media.Geometry.GetArea%2A>) zu erzeugen, oder verwenden Sie eine polygonale Approximation der Geometrie. Der Toleranzfaktor gibt die maximale Entfernung zwischen Punkten in der polygonalen Approximation an. Kleinere Toleranzwerte liefern bessere Approximationen, aber erfordert eine höhere verarbeitungsleistung als eine Approximation mit großer Toleranzfaktor.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetArea">
      <MemberSignature Language="C#" Value="public virtual double GetArea (double tolerance, System.Windows.Media.ToleranceType type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float64 GetArea(float64 tolerance, valuetype System.Windows.Media.ToleranceType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Geometry.GetArea(System.Double,System.Windows.Media.ToleranceType)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetArea (tolerance As Double, type As ToleranceType) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual double GetArea(double tolerance, System::Windows::Media::ToleranceType type);" />
      <MemberSignature Language="F#" Value="abstract member GetArea : double * System.Windows.Media.ToleranceType -&gt; double&#xA;override this.GetArea : double * System.Windows.Media.ToleranceType -&gt; double" Usage="geometry.GetArea (tolerance, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tolerance" Type="System.Double" />
        <Parameter Name="type" Type="System.Windows.Media.ToleranceType" />
      </Parameters>
      <Docs>
        <param name="tolerance">The maximum bounds on the distance between points in the polygonal approximation of the geometry. Smaller values produce more accurate results but cause slower execution. If <c>tolerance</c> is less than .000001, .000001 is used instead.</param>
        <param name="type">One of the <see cref="T:System.Windows.Media.ToleranceType" /> values that specifies whether the tolerance factor is an absolute value or relative to the area of the geometry.</param>
        <summary>Gets the area, within the specified tolerance, of the filled region of the <see cref="T:System.Windows.Media.Geometry" /> object.</summary>
        <returns>The area of the filled region of the geometry.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Einige <xref:System.Windows.Media.Geometry> Methoden (z. B. <xref:System.Windows.Media.Geometry.GetArea%2A>) zu erzeugen, oder verwenden Sie eine polygonale Approximation der Geometrie. Der Toleranzfaktor gibt die maximale Entfernung zwischen Punkten in der polygonalen Approximation an. Kleinere Toleranzwerte liefern bessere Approximationen, aber erfordert eine höhere verarbeitungsleistung als eine Approximation mit großer Toleranzfaktor.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFlattenedPathGeometry">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gets a <see cref="T:System.Windows.Media.PathGeometry" /> that is a polygonal approximation of the <see cref="T:System.Windows.Media.Geometry" /> object.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFlattenedPathGeometry">
      <MemberSignature Language="C#" Value="public System.Windows.Media.PathGeometry GetFlattenedPathGeometry ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Media.PathGeometry GetFlattenedPathGeometry() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Geometry.GetFlattenedPathGeometry" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFlattenedPathGeometry () As PathGeometry" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::PathGeometry ^ GetFlattenedPathGeometry();" />
      <MemberSignature Language="F#" Value="member this.GetFlattenedPathGeometry : unit -&gt; System.Windows.Media.PathGeometry" Usage="geometry.GetFlattenedPathGeometry " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.PathGeometry</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets a <see cref="T:System.Windows.Media.PathGeometry" /> that is a polygonal approximation of the <see cref="T:System.Windows.Media.Geometry" /> object.</summary>
        <returns>The polygonal approximation of the <see cref="T:System.Windows.Media.Geometry" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verwendet die Standard-Toleranzfaktor (beschriebenen der <xref:System.Windows.Media.Geometry.StandardFlatteningTolerance%2A> Eigenschaft) bei der Verarbeitung der Geometrie. Um einen eigenen Toleranzfaktor anzugeben, verwenden die <xref:System.Windows.Media.Geometry.GetFlattenedPathGeometry%2A> Methode.  
  
 Einige <xref:System.Windows.Media.Geometry> Methoden (z. B. <xref:System.Windows.Media.Geometry.GetFlattenedPathGeometry%2A>) zu erzeugen, oder verwenden Sie eine polygonale Approximation der Geometrie. Der Toleranzfaktor gibt die maximale Entfernung zwischen Punkten in der polygonalen Approximation an. Kleinere Toleranzwerte liefern bessere Approximationen, aber erfordert eine höhere verarbeitungsleistung als eine Approximation mit großer Toleranzfaktor.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFlattenedPathGeometry">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Media.PathGeometry GetFlattenedPathGeometry (double tolerance, System.Windows.Media.ToleranceType type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.Media.PathGeometry GetFlattenedPathGeometry(float64 tolerance, valuetype System.Windows.Media.ToleranceType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Geometry.GetFlattenedPathGeometry(System.Double,System.Windows.Media.ToleranceType)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetFlattenedPathGeometry (tolerance As Double, type As ToleranceType) As PathGeometry" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Windows::Media::PathGeometry ^ GetFlattenedPathGeometry(double tolerance, System::Windows::Media::ToleranceType type);" />
      <MemberSignature Language="F#" Value="abstract member GetFlattenedPathGeometry : double * System.Windows.Media.ToleranceType -&gt; System.Windows.Media.PathGeometry&#xA;override this.GetFlattenedPathGeometry : double * System.Windows.Media.ToleranceType -&gt; System.Windows.Media.PathGeometry" Usage="geometry.GetFlattenedPathGeometry (tolerance, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.PathGeometry</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tolerance" Type="System.Double" />
        <Parameter Name="type" Type="System.Windows.Media.ToleranceType" />
      </Parameters>
      <Docs>
        <param name="tolerance">The maximum bounds on the distance between points in the polygonal approximation of the geometry. Smaller values produce more accurate results but cause slower execution. If <c>tolerance</c> is less than .000001, .000001 is used instead.</param>
        <param name="type">One of the <see cref="T:System.Windows.Media.ToleranceType" /> values that specifies whether the tolerance factor is an absolute value or relative to the area of the geometry.</param>
        <summary>Gets a <see cref="T:System.Windows.Media.PathGeometry" />, within the specified tolerance, that is a polygonal approximation of the <see cref="T:System.Windows.Media.Geometry" /> object.</summary>
        <returns>The polygonal approximation of the <see cref="T:System.Windows.Media.Geometry" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Einige <xref:System.Windows.Media.Geometry> Methoden (z. B. <xref:System.Windows.Media.Geometry.GetFlattenedPathGeometry%2A>) zu erzeugen, oder verwenden Sie eine polygonale Approximation der Geometrie. Der Toleranzfaktor gibt die maximale Entfernung zwischen Punkten in der polygonalen Approximation an. Kleinere Toleranzwerte liefern bessere Approximationen, aber erfordert eine höhere verarbeitungsleistung als eine Approximation mit großer Toleranzfaktor.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetOutlinedPathGeometry">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gets a <see cref="T:System.Windows.Media.PathGeometry" /> that is a simplified outline of the filled region of the <see cref="T:System.Windows.Media.Geometry" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetOutlinedPathGeometry">
      <MemberSignature Language="C#" Value="public System.Windows.Media.PathGeometry GetOutlinedPathGeometry ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Media.PathGeometry GetOutlinedPathGeometry() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Geometry.GetOutlinedPathGeometry" />
      <MemberSignature Language="VB.NET" Value="Public Function GetOutlinedPathGeometry () As PathGeometry" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::PathGeometry ^ GetOutlinedPathGeometry();" />
      <MemberSignature Language="F#" Value="member this.GetOutlinedPathGeometry : unit -&gt; System.Windows.Media.PathGeometry" Usage="geometry.GetOutlinedPathGeometry " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.PathGeometry</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets a <see cref="T:System.Windows.Media.PathGeometry" /> that is a simplified outline of the filled region of the <see cref="T:System.Windows.Media.Geometry" />.</summary>
        <returns>A simplified outline of the filled region of the <see cref="T:System.Windows.Media.Geometry" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verwendet die Standard-Toleranzfaktor (beschriebenen der <xref:System.Windows.Media.Geometry.StandardFlatteningTolerance%2A> Eigenschaft) bei der Verarbeitung der Geometrie. Um einen eigenen Toleranzfaktor anzugeben, verwenden die <xref:System.Windows.Media.Geometry.GetOutlinedPathGeometry%2A> Methode.  
  
 Einige <xref:System.Windows.Media.Geometry> Methoden (z. B. <xref:System.Windows.Media.Geometry.GetOutlinedPathGeometry%2A>) zu erzeugen, oder verwenden Sie eine polygonale Approximation der Geometrie. Der Toleranzfaktor gibt die maximale Entfernung zwischen Punkten in der polygonalen Approximation an. Kleinere Toleranzwerte liefern bessere Approximationen, aber erfordert eine höhere verarbeitungsleistung als eine Approximation mit großer Toleranzfaktor.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetOutlinedPathGeometry">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Media.PathGeometry GetOutlinedPathGeometry (double tolerance, System.Windows.Media.ToleranceType type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.Media.PathGeometry GetOutlinedPathGeometry(float64 tolerance, valuetype System.Windows.Media.ToleranceType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Geometry.GetOutlinedPathGeometry(System.Double,System.Windows.Media.ToleranceType)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetOutlinedPathGeometry (tolerance As Double, type As ToleranceType) As PathGeometry" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Windows::Media::PathGeometry ^ GetOutlinedPathGeometry(double tolerance, System::Windows::Media::ToleranceType type);" />
      <MemberSignature Language="F#" Value="abstract member GetOutlinedPathGeometry : double * System.Windows.Media.ToleranceType -&gt; System.Windows.Media.PathGeometry&#xA;override this.GetOutlinedPathGeometry : double * System.Windows.Media.ToleranceType -&gt; System.Windows.Media.PathGeometry" Usage="geometry.GetOutlinedPathGeometry (tolerance, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.PathGeometry</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tolerance" Type="System.Double" />
        <Parameter Name="type" Type="System.Windows.Media.ToleranceType" />
      </Parameters>
      <Docs>
        <param name="tolerance">The maximum bounds on the distance between points in the polygonal approximation of the geometry. Smaller values produce more accurate results but cause slower execution. If <c>tolerance</c> is less than .000001, .000001 is used instead.</param>
        <param name="type">One of the <see cref="T:System.Windows.Media.ToleranceType" /> values that specifies whether the tolerance factor is an absolute value or relative to the area of the geometry.</param>
        <summary>Gets a <see cref="T:System.Windows.Media.PathGeometry" />, within the specified tolerance, that is a simplified outline of the filled region of the <see cref="T:System.Windows.Media.Geometry" />.</summary>
        <returns>A simplified outline of the filled region of the <see cref="T:System.Windows.Media.Geometry" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Einige <xref:System.Windows.Media.Geometry> Methoden (z. B. <xref:System.Windows.Media.Geometry.GetOutlinedPathGeometry%2A>) zu erzeugen, oder verwenden Sie eine polygonale Approximation der Geometrie. Der Toleranzfaktor gibt die maximale Entfernung zwischen Punkten in der polygonalen Approximation an. Kleinere Toleranzwerte liefern bessere Approximationen, aber erfordert eine höhere verarbeitungsleistung als eine Approximation mit großer Toleranzfaktor.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetRenderBounds">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns an axis-aligned rectangle that is exactly large enough to contain the geometry and its stroke.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetRenderBounds">
      <MemberSignature Language="C#" Value="public System.Windows.Rect GetRenderBounds (System.Windows.Media.Pen pen);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Rect GetRenderBounds(class System.Windows.Media.Pen pen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Geometry.GetRenderBounds(System.Windows.Media.Pen)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Rect GetRenderBounds(System::Windows::Media::Pen ^ pen);" />
      <MemberSignature Language="F#" Value="member this.GetRenderBounds : System.Windows.Media.Pen -&gt; System.Windows.Rect" Usage="geometry.GetRenderBounds pen" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Rect</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Windows.Media.Pen" />
      </Parameters>
      <Docs>
        <param name="pen">An object that describes the area of the geometry's stroke.</param>
        <summary>Returns an axis-aligned rectangle that is exactly large enough to contain the geometry after it has been outlined with the specified <see cref="T:System.Windows.Media.Pen" />.</summary>
        <returns>An axis aligned rectangle that is exactly large enough to contain the outlined geometry.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verwendet die Standard-Toleranzfaktor (beschriebenen der <xref:System.Windows.Media.Geometry.StandardFlatteningTolerance%2A> Eigenschaft) bei der Verarbeitung der Geometrie. Um einen eigenen Toleranzfaktor anzugeben, verwenden die <xref:System.Windows.Media.Geometry.GetRenderBounds%2A> Methode.  
  
 Einige <xref:System.Windows.Media.Geometry> Methoden (z. B. <xref:System.Windows.Media.Geometry.GetRenderBounds%2A>) zu erzeugen, oder verwenden Sie eine polygonale Approximation der Geometrie. Der Toleranzfaktor gibt die maximale Entfernung zwischen Punkten in der polygonalen Approximation an. Kleinere Toleranzwerte liefern bessere Approximationen, aber erfordert eine höhere verarbeitungsleistung als eine Approximation mit großer Toleranzfaktor.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRenderBounds">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Rect GetRenderBounds (System.Windows.Media.Pen pen, double tolerance, System.Windows.Media.ToleranceType type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Windows.Rect GetRenderBounds(class System.Windows.Media.Pen pen, float64 tolerance, valuetype System.Windows.Media.ToleranceType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Geometry.GetRenderBounds(System.Windows.Media.Pen,System.Double,System.Windows.Media.ToleranceType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Windows::Rect GetRenderBounds(System::Windows::Media::Pen ^ pen, double tolerance, System::Windows::Media::ToleranceType type);" />
      <MemberSignature Language="F#" Value="abstract member GetRenderBounds : System.Windows.Media.Pen * double * System.Windows.Media.ToleranceType -&gt; System.Windows.Rect&#xA;override this.GetRenderBounds : System.Windows.Media.Pen * double * System.Windows.Media.ToleranceType -&gt; System.Windows.Rect" Usage="geometry.GetRenderBounds (pen, tolerance, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Rect</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Windows.Media.Pen" />
        <Parameter Name="tolerance" Type="System.Double" />
        <Parameter Name="type" Type="System.Windows.Media.ToleranceType" />
      </Parameters>
      <Docs>
        <param name="pen">An object that describes the area of the geometry's stroke.</param>
        <param name="tolerance">The maximum bounds on the distance between points in the polygonal approximation of the geometry. Smaller values produce more accurate results but cause slower execution. If <c>tolerance</c> is less than .000001, .000001 is used instead.</param>
        <param name="type">One of the <see cref="T:System.Windows.Media.ToleranceType" /> values that specifies whether the tolerance factor is an absolute value or relative to the area of the geometry.</param>
        <summary>Returns an axis-aligned rectangle that is exactly large enough to contain the geometry after it has been outlined with the specified <see cref="T:System.Windows.Media.Pen" />, given the specified tolerance factor.</summary>
        <returns>An axis aligned rectangle that is exactly large enough to contain the outlined geometry.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Einige <xref:System.Windows.Media.Geometry> Methoden (z. B. <xref:System.Windows.Media.Geometry.GetRenderBounds%2A>) zu erzeugen, oder verwenden Sie eine polygonale Approximation der Geometrie. Der Toleranzfaktor gibt die maximale Entfernung zwischen Punkten in der polygonalen Approximation an. Kleinere Toleranzwerte liefern bessere Approximationen, aber erfordert eine höhere verarbeitungsleistung als eine Approximation mit großer Toleranzfaktor.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetWidenedPathGeometry">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gets a <see cref="T:System.Windows.Media.PathGeometry" /> that is the shape defined by the stroke on the <see cref="T:System.Windows.Media.Geometry" /> produced by the specified <see cref="T:System.Windows.Media.Pen" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetWidenedPathGeometry">
      <MemberSignature Language="C#" Value="public System.Windows.Media.PathGeometry GetWidenedPathGeometry (System.Windows.Media.Pen pen);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Media.PathGeometry GetWidenedPathGeometry(class System.Windows.Media.Pen pen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Geometry.GetWidenedPathGeometry(System.Windows.Media.Pen)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::PathGeometry ^ GetWidenedPathGeometry(System::Windows::Media::Pen ^ pen);" />
      <MemberSignature Language="F#" Value="member this.GetWidenedPathGeometry : System.Windows.Media.Pen -&gt; System.Windows.Media.PathGeometry" Usage="geometry.GetWidenedPathGeometry pen" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.PathGeometry</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Windows.Media.Pen" />
      </Parameters>
      <Docs>
        <param name="pen">An object that describes the area of the geometry's stroke.</param>
        <summary>Gets a <see cref="T:System.Windows.Media.PathGeometry" /> that is the shape defined by the stroke on the <see cref="T:System.Windows.Media.Geometry" /> produced by the specified <see cref="T:System.Windows.Media.Pen" />.</summary>
        <returns>The outlined geometry.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Einige <xref:System.Windows.Media.Geometry> Methoden (z. B. <xref:System.Windows.Media.Geometry.GetWidenedPathGeometry%2A>) zu erzeugen, oder verwenden Sie eine polygonale Approximation der Geometrie. Der Toleranzfaktor gibt die maximale Entfernung zwischen Punkten in der polygonalen Approximation an. Kleinere Toleranzwerte liefern bessere Approximationen, aber erfordert eine höhere verarbeitungsleistung als eine Approximation mit großer Toleranzfaktor.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetWidenedPathGeometry">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Media.PathGeometry GetWidenedPathGeometry (System.Windows.Media.Pen pen, double tolerance, System.Windows.Media.ToleranceType type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.Media.PathGeometry GetWidenedPathGeometry(class System.Windows.Media.Pen pen, float64 tolerance, valuetype System.Windows.Media.ToleranceType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Geometry.GetWidenedPathGeometry(System.Windows.Media.Pen,System.Double,System.Windows.Media.ToleranceType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Windows::Media::PathGeometry ^ GetWidenedPathGeometry(System::Windows::Media::Pen ^ pen, double tolerance, System::Windows::Media::ToleranceType type);" />
      <MemberSignature Language="F#" Value="abstract member GetWidenedPathGeometry : System.Windows.Media.Pen * double * System.Windows.Media.ToleranceType -&gt; System.Windows.Media.PathGeometry&#xA;override this.GetWidenedPathGeometry : System.Windows.Media.Pen * double * System.Windows.Media.ToleranceType -&gt; System.Windows.Media.PathGeometry" Usage="geometry.GetWidenedPathGeometry (pen, tolerance, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.PathGeometry</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Windows.Media.Pen" />
        <Parameter Name="tolerance" Type="System.Double" />
        <Parameter Name="type" Type="System.Windows.Media.ToleranceType" />
      </Parameters>
      <Docs>
        <param name="pen">The object used to define the area of the geometry's stroke.</param>
        <param name="tolerance">The maximum bounds on the distance between points in the polygonal approximation of the geometry. Smaller values produce more accurate results but cause slower execution. If <c>tolerance</c> is less than .000001, .000001 is used instead.</param>
        <param name="type">One of the <see cref="T:System.Windows.Media.ToleranceType" /> values that specifies whether the tolerance factor is an absolute value or relative to the area of the geometry.</param>
        <summary>Gets a <see cref="T:System.Windows.Media.PathGeometry" /> that is the shape defined by the stroke on the <see cref="T:System.Windows.Media.Geometry" /> produced by the specified <see cref="T:System.Windows.Media.Pen" />, given the specified tolerance factor.</summary>
        <returns>The geometry, widened by <paramref name="pen" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Einige <xref:System.Windows.Media.Geometry> Methoden (z. B. <xref:System.Windows.Media.Geometry.GetWidenedPathGeometry%2A>) zu erzeugen, oder verwenden Sie eine polygonale Approximation der Geometrie. Der Toleranzfaktor gibt die maximale Entfernung zwischen Punkten in der polygonalen Approximation an. Kleinere Toleranzwerte liefern bessere Approximationen, aber erfordert eine höhere verarbeitungsleistung als eine Approximation mit großer Toleranzfaktor.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEmpty">
      <MemberSignature Language="C#" Value="public abstract bool IsEmpty ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsEmpty() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Geometry.IsEmpty" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function IsEmpty () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool IsEmpty();" />
      <MemberSignature Language="F#" Value="abstract member IsEmpty : unit -&gt; bool" Usage="geometry.IsEmpty " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Determines whether the object is empty.</summary>
        <returns>
          <see langword="true" /> if the geometry is empty; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MayHaveCurves">
      <MemberSignature Language="C#" Value="public abstract bool MayHaveCurves ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MayHaveCurves() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Geometry.MayHaveCurves" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function MayHaveCurves () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool MayHaveCurves();" />
      <MemberSignature Language="F#" Value="abstract member MayHaveCurves : unit -&gt; bool" Usage="geometry.MayHaveCurves " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Determines whether the object might have curved segments.</summary>
        <returns>
          <see langword="true" /> if the geometry object might have curved segments; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Windows.Media.Geometry Parse (string source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Media.Geometry Parse(string source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Geometry.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (source As String) As Geometry" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Media::Geometry ^ Parse(System::String ^ source);" />
      <MemberSignature Language="F#" Value="static member Parse : string -&gt; System.Windows.Media.Geometry" Usage="System.Windows.Media.Geometry.Parse source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Geometry</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">A string that describes the geometry to be created.</param>
        <summary>Creates a new <see cref="T:System.Windows.Media.Geometry" /> instance from the specified string using the current culture.</summary>
        <returns>A new <see cref="T:System.Windows.Media.Geometry" /> instance created from the specified string.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Finden Sie unter [Pfadmarkupsyntax](~/docs/framework/wpf/graphics-multimedia/path-markup-syntax.md) Informationen zur Formatierung dieser Zeichenfolge  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeTransform">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeTransform ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeTransform() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Geometry.ShouldSerializeTransform" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeTransform () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeTransform();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeTransform : unit -&gt; bool" Usage="geometry.ShouldSerializeTransform " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets a value that indicates whether the value of the <see cref="P:System.Windows.Media.Geometry.Transform" /> property should be serialized.</summary>
        <returns>
          <see langword="true" /> if the value of the geometry's <see cref="P:System.Windows.Media.Geometry.Transform" /> property should be serialized; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StandardFlatteningTolerance">
      <MemberSignature Language="C#" Value="public static double StandardFlatteningTolerance { get; }" />
      <MemberSignature Language="ILAsm" Value=".property float64 StandardFlatteningTolerance" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Geometry.StandardFlatteningTolerance" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property StandardFlatteningTolerance As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property double StandardFlatteningTolerance { double get(); };" />
      <MemberSignature Language="F#" Value="member this.StandardFlatteningTolerance : double" Usage="System.Windows.Media.Geometry.StandardFlatteningTolerance" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the standard tolerance used for polygonal approximation.</summary>
        <value>Die Standardtoleranz 0,25.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="StrokeContains">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Determines whether the geometry's stroke contains the specified <see cref="T:System.Windows.Point" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="StrokeContains">
      <MemberSignature Language="C#" Value="public bool StrokeContains (System.Windows.Media.Pen pen, System.Windows.Point hitPoint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StrokeContains(class System.Windows.Media.Pen pen, valuetype System.Windows.Point hitPoint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Geometry.StrokeContains(System.Windows.Media.Pen,System.Windows.Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StrokeContains(System::Windows::Media::Pen ^ pen, System::Windows::Point hitPoint);" />
      <MemberSignature Language="F#" Value="member this.StrokeContains : System.Windows.Media.Pen * System.Windows.Point -&gt; bool" Usage="geometry.StrokeContains (pen, hitPoint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Windows.Media.Pen" />
        <Parameter Name="hitPoint" Type="System.Windows.Point" />
      </Parameters>
      <Docs>
        <param name="pen">An object that determines the area of the geometry's stroke.</param>
        <param name="hitPoint">The point to test for containment.</param>
        <summary>Determines whether the specified <see cref="T:System.Windows.Point" /> is contained in the stroke produced by applying the specified <see cref="T:System.Windows.Media.Pen" /> to the geometry.</summary>
        <returns>
          <see langword="true" /> if <paramref name="hitPoint" /> is contained in the stroke produced by applying the specified <see cref="T:System.Windows.Media.Pen" /> to the geometry; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Standard-Toleranzfaktor (angegeben durch die <xref:System.Windows.Media.Geometry.StandardFlatteningTolerance%2A> Eigenschaft) wird verwendet, wenn Sie bestimmen, ob der angegebene Punkt sich in der Strich der Geometrie befindet. Um einen eigenen Toleranzfaktor anzugeben, verwenden die <xref:System.Windows.Media.Geometry.StrokeContains%2A> überladen.  
  
 Einige <xref:System.Windows.Media.Geometry> Methoden (z. B. <xref:System.Windows.Media.Geometry.StrokeContains%2A>) zu erzeugen, oder verwenden Sie eine polygonale Approximation der Geometrie. Der Toleranzfaktor gibt die maximale Entfernung zwischen Punkten in der polygonalen Approximation an. Kleinere Toleranzwerte liefern bessere Approximationen, aber erfordert eine höhere verarbeitungsleistung als eine Approximation mit großer Toleranzfaktor.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StrokeContains">
      <MemberSignature Language="C#" Value="public bool StrokeContains (System.Windows.Media.Pen pen, System.Windows.Point hitPoint, double tolerance, System.Windows.Media.ToleranceType type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StrokeContains(class System.Windows.Media.Pen pen, valuetype System.Windows.Point hitPoint, float64 tolerance, valuetype System.Windows.Media.ToleranceType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Geometry.StrokeContains(System.Windows.Media.Pen,System.Windows.Point,System.Double,System.Windows.Media.ToleranceType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StrokeContains(System::Windows::Media::Pen ^ pen, System::Windows::Point hitPoint, double tolerance, System::Windows::Media::ToleranceType type);" />
      <MemberSignature Language="F#" Value="member this.StrokeContains : System.Windows.Media.Pen * System.Windows.Point * double * System.Windows.Media.ToleranceType -&gt; bool" Usage="geometry.StrokeContains (pen, hitPoint, tolerance, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Windows.Media.Pen" />
        <Parameter Name="hitPoint" Type="System.Windows.Point" />
        <Parameter Name="tolerance" Type="System.Double" />
        <Parameter Name="type" Type="System.Windows.Media.ToleranceType" />
      </Parameters>
      <Docs>
        <param name="pen">An object that defines the stroke of a geometry.</param>
        <param name="hitPoint">The point to test for containment.</param>
        <param name="tolerance">The maximum bounds on the distance between points in the polygonal approximation of the geometry. Smaller values produce more accurate results but cause slower execution. If <c>tolerance</c> is less than .000001, .000001 is used instead.</param>
        <param name="type">One of the <see cref="T:System.Windows.Media.ToleranceType" /> values that specifies whether the tolerance factor is an absolute value or relative to the area of the geometry.</param>
        <summary>Determines whether the specified <see cref="T:System.Windows.Point" /> is contained in the stroke produced by applying the specified <see cref="T:System.Windows.Media.Pen" /> to the geometry, given the specified margin of error.</summary>
        <returns>
          <see langword="true" /> if the stroke created by applying the specified <see cref="T:System.Windows.Media.Pen" /> to the geometry contains the specified point, given the specified tolerance factor; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Einige <xref:System.Windows.Media.Geometry> Methoden (z. B. <xref:System.Windows.Media.Geometry.StrokeContains%2A>) zu erzeugen, oder verwenden Sie eine polygonale Approximation der Geometrie. Der Toleranzfaktor gibt die maximale Entfernung zwischen Punkten in der polygonalen Approximation an. Kleinere Toleranzwerte liefern bessere Approximationen, aber erfordert eine höhere verarbeitungsleistung als eine Approximation mit großer Toleranzfaktor.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="StrokeContainsWithDetail">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns a value that describes the intersection between the specified geometry and the current geometry's stroke.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="StrokeContainsWithDetail">
      <MemberSignature Language="C#" Value="public System.Windows.Media.IntersectionDetail StrokeContainsWithDetail (System.Windows.Media.Pen pen, System.Windows.Media.Geometry geometry);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Media.IntersectionDetail StrokeContainsWithDetail(class System.Windows.Media.Pen pen, class System.Windows.Media.Geometry geometry) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Geometry.StrokeContainsWithDetail(System.Windows.Media.Pen,System.Windows.Media.Geometry)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::IntersectionDetail StrokeContainsWithDetail(System::Windows::Media::Pen ^ pen, System::Windows::Media::Geometry ^ geometry);" />
      <MemberSignature Language="F#" Value="member this.StrokeContainsWithDetail : System.Windows.Media.Pen * System.Windows.Media.Geometry -&gt; System.Windows.Media.IntersectionDetail" Usage="geometry.StrokeContainsWithDetail (pen, geometry)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.IntersectionDetail</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Windows.Media.Pen" />
        <Parameter Name="geometry" Type="System.Windows.Media.Geometry" />
      </Parameters>
      <Docs>
        <param name="pen">An object that determines the area of the current geometry's stroke.</param>
        <param name="geometry">The geometry to test for containment.</param>
        <summary>Returns a value that describes the intersection between the specified <see cref="T:System.Windows.Media.Geometry" /> and the stroke created by applying the specified <see cref="T:System.Windows.Media.Pen" /> to the current geometry.</summary>
        <returns>One of the enumeration values.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Standard-Toleranzfaktor (definiert durch die <xref:System.Windows.Media.Geometry.StandardFlatteningTolerance%2A> Eigenschaft) wird verwendet, wenn Sie bestimmen, ob die angegebene Geometry-Instanz in der aktuellen Geometrie Strich enthalten ist. Um einen eigenen Toleranzfaktor anzugeben, verwenden die <xref:System.Windows.Media.Geometry.StrokeContainsWithDetail%2A> Methode.  
  
 Einige <xref:System.Windows.Media.Geometry> Methoden (z. B. <xref:System.Windows.Media.Geometry.StrokeContainsWithDetail%2A>) zu erzeugen, oder verwenden Sie eine polygonale Approximation der Geometrie. Der Toleranzfaktor gibt die maximale Entfernung zwischen Punkten in der polygonalen Approximation an. Kleinere Toleranzwerte liefern bessere Approximationen, aber erfordert eine höhere verarbeitungsleistung als eine Approximation mit großer Toleranzfaktor.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StrokeContainsWithDetail">
      <MemberSignature Language="C#" Value="public System.Windows.Media.IntersectionDetail StrokeContainsWithDetail (System.Windows.Media.Pen pen, System.Windows.Media.Geometry geometry, double tolerance, System.Windows.Media.ToleranceType type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Media.IntersectionDetail StrokeContainsWithDetail(class System.Windows.Media.Pen pen, class System.Windows.Media.Geometry geometry, float64 tolerance, valuetype System.Windows.Media.ToleranceType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Geometry.StrokeContainsWithDetail(System.Windows.Media.Pen,System.Windows.Media.Geometry,System.Double,System.Windows.Media.ToleranceType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::IntersectionDetail StrokeContainsWithDetail(System::Windows::Media::Pen ^ pen, System::Windows::Media::Geometry ^ geometry, double tolerance, System::Windows::Media::ToleranceType type);" />
      <MemberSignature Language="F#" Value="member this.StrokeContainsWithDetail : System.Windows.Media.Pen * System.Windows.Media.Geometry * double * System.Windows.Media.ToleranceType -&gt; System.Windows.Media.IntersectionDetail" Usage="geometry.StrokeContainsWithDetail (pen, geometry, tolerance, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.IntersectionDetail</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Windows.Media.Pen" />
        <Parameter Name="geometry" Type="System.Windows.Media.Geometry" />
        <Parameter Name="tolerance" Type="System.Double" />
        <Parameter Name="type" Type="System.Windows.Media.ToleranceType" />
      </Parameters>
      <Docs>
        <param name="pen">An object that determines the area of the current geometry's stroke.</param>
        <param name="geometry">The geometry to test for containment.</param>
        <param name="tolerance">The maximum bounds on the distance between points in the polygonal approximation of the geometries. Smaller values produce more accurate results but cause slower execution. If <c>tolerance</c> is less than .000001, .000001 is used instead.</param>
        <param name="type">One of the <see cref="T:System.Windows.Media.ToleranceType" /> values that specifies whether the tolerance factor is an absolute value or relative to the area of the geometry.</param>
        <summary>Gets a value that describes the intersection between the specified <see cref="T:System.Windows.Media.Geometry" /> and the stroke created by applying the specified <see cref="T:System.Windows.Media.Pen" /> to the current geometry, given the specified margin of error.</summary>
        <returns>One of the enumeration values.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Einige <xref:System.Windows.Media.Geometry> Methoden (z. B. <xref:System.Windows.Media.Geometry.StrokeContainsWithDetail%2A>) zu erzeugen, oder verwenden Sie eine polygonale Approximation der Geometrie. Der Toleranzfaktor gibt die maximale Entfernung zwischen Punkten in der polygonalen Approximation an. Kleinere Toleranzwerte liefern bessere Approximationen, aber erfordert eine höhere verarbeitungsleistung als eine Approximation mit großer Toleranzfaktor.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IFormattable.ToString">
      <MemberSignature Language="C#" Value="string IFormattable.ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance string System.IFormattable.ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Geometry.System#IFormattable#ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToString (format As String, provider As IFormatProvider) As String Implements IFormattable.ToString" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::String ^ System.IFormattable.ToString(System::String ^ format, IFormatProvider ^ provider) = IFormattable::ToString;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">The format to use.  -or-  A null reference (<see langword="Nothing" /> in Visual Basic) to use the default format defined for the type of the <see cref="T:System.IFormattable" /> implementation.</param>
        <param name="provider">The provider to use to format the value.  -or-  A null reference (<see langword="Nothing" /> in Visual Basic) to obtain the numeric format information from the current locale setting of the operating system.</param>
        <summary>Formats the value of the current instance using the specified format.</summary>
        <returns>The value of the current instance in the specified format.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Creates a string representation of the object based on the current culture.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Geometry.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="abstract member ToString : unit -&gt; string&#xA;override this.ToString : unit -&gt; string" Usage="geometry.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Creates a string representation of the object based on the current culture.</summary>
        <returns>A string representation of the object.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Geometry.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="member this.ToString : IFormatProvider -&gt; string" Usage="geometry.ToString provider" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Culture-specific formatting information, or <see langword="null" /> to use the current culture.</param>
        <summary>Creates a string representation of the object using the specified culture-specific formatting information.</summary>
        <returns>A string representation of the object.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Transform">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Transform Transform { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Transform Transform" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Geometry.Transform" />
      <MemberSignature Language="VB.NET" Value="Public Property Transform As Transform" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Transform ^ Transform { System::Windows::Media::Transform ^ get(); void set(System::Windows::Media::Transform ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Transform : System.Windows.Media.Transform with get, set" Usage="System.Windows.Media.Geometry.Transform" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Transform</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the <see cref="T:System.Windows.Media.Transform" /> object applied to a <see cref="T:System.Windows.Media.Geometry" />.</summary>
        <value>Die Transformation angewendet auf die <see cref="T:System.Windows.Media.Geometry" />. Beachten Sie, dass dieser Wert möglicherweise einen einzelnen <see cref="T:System.Windows.Media.Transform" /> oder <see cref="T:System.Windows.Media.TransformCollection" /> umgewandelt als ein <see cref="T:System.Windows.Media.Transform" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt die Identitätstransformation zurück, wenn das aktuelle Objekt kein Transformationswert ist. Andernfalls wird die <xref:System.Windows.Media.Transform> auf das aktuelle Objekt angewendet.  
  
<a name="dependencyPropertyInfo_Transform"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Feld "ID"|<xref:System.Windows.Media.Geometry.TransformProperty>|  
|Legen Sie auf der Metadaten-Eigenschaften `true`|Keiner|  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie mit der <xref:System.Windows.Media.Geometry.Transform%2A> Eigenschaft anwenden einer <xref:System.Windows.Media.RotateTransform> auf eine <xref:System.Windows.Media.Geometry> Objekt.  
  
 Im Beispiel wird eine <xref:System.Windows.Media.GeometryGroup> zum Erstellen einer zusammengesetzten Form aus drei <xref:System.Windows.Media.Geometry> Objekte aus, und klicken Sie dann die Geometrie wird um 45 Grad unter Verwendung der <xref:System.Windows.Media.Geometry.Transform%2A> Eigenschaft.  
  
 [!code-xaml[Transforms_snip#GeometryTransformExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/Transforms_snip/CS/GeometryTransformExample.xaml#geometrytransformexamplewholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TransformProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TransformProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TransformProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Media.Geometry.TransformProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TransformProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TransformProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TransformProperty : System.Windows.DependencyProperty" Usage="System.Windows.Media.Geometry.TransformProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Media.Geometry.Transform" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>