<Type Name="NavigationService" FullName="System.Windows.Navigation.NavigationService">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="ada487929a3270b8b3a3f316486ea10531a71ff1" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39762294" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class NavigationService" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit NavigationService extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Navigation.NavigationService" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class NavigationService" />
  <TypeSignature Language="C++ CLI" Value="public ref class NavigationService sealed" />
  <TypeSignature Language="F#" Value="type NavigationService = class" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Enthält Methoden, Eigenschaften und Ereignisse zur Unterstützung der Navigation.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationService> Kapselt die Möglichkeit, Inhalte innerhalb des Kontexts einer Navigation im Browserstil herunterzuladen.  
  
 Inhalt kann jede Art von .NET Framework-Objekt und HTML-Dateien sein. Im Allgemeinen jedoch Seiten sind die bevorzugte als Weg zum Packen von Inhalten für die Navigation (finden Sie unter <xref:System.Windows.Controls.Page>).  
  
 Inhalt kann navigiert werden, indem Sie eine Instanz eines Objekts bereitzustellen und Aufruf einer Überladung der der <xref:System.Windows.Navigation.NavigationService.Navigate%2A> -Methode, ein Objekt akzeptiert:  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigate%28System.Object%29?displayProperty=nameWithType>  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigate%28System.Object%2CSystem.Object%29?displayProperty=nameWithType>  
  
 Alternativ Inhalt kann navigiert werden, indem ein relativer oder absoluter URI an eine der übergeben der <xref:System.Windows.Navigation.NavigationService.Navigate%2A> methodenüberladungen, die einen URI akzeptiert:  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigate%28System.Uri%29?displayProperty=nameWithType>  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigate%28System.Uri%2CSystem.Object%29?displayProperty=nameWithType>  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigate%28System.Uri%2CSystem.Object%2CSystem.Boolean%29?displayProperty=nameWithType>  
  
 Wenn der Inhalt von URI, zu dem navigiert wird <xref:System.Windows.Navigation.NavigationService> ein Objekt zurück, das den Inhalt enthält.  
  
 Die Lebensdauer einer Navigation kann durch die folgenden Ereignisse nachverfolgt werden:  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigating>  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigated>  
  
-   <xref:System.Windows.Navigation.NavigationService.NavigationProgress>  
  
-   <xref:System.Windows.Navigation.NavigationService.NavigationFailed>  
  
-   <xref:System.Windows.Navigation.NavigationService.NavigationStopped>  
  
-   <xref:System.Windows.Navigation.NavigationService.LoadCompleted>  
  
-   <xref:System.Windows.Navigation.NavigationService.FragmentNavigation>  
  
 Nicht alle Ereignisse werden jedes Mal ausgelöst wird, die eine Navigation. der Satz von Ereignissen, die ausgelöst werden, richtet sich nach den Typ der Navigation, die (Inhalt oder -Fragment) tritt ein, und wie die Navigation abgeschlossen wurde (abgebrochen, beendet oder Fehler).  
  
 Die folgende Abbildung veranschaulicht die Sequenz, die in der diese Ereignisse ausgelöst werden:  
  
 ![Seitennavigations-Flussdiagramm](~/add/media/navigationoverviewfigure11.png "Seitennavigations-Flussdiagramm")  
  
 Während oder nach einer Navigation <xref:System.Windows.Navigation.NavigationService> enthält Informationen zum Inhalt, der zu dem navigiert wird einschließlich des URI des Inhalts, zu dem navigiert (<xref:System.Windows.Navigation.NavigationService.Source%2A>), den URI des aktuellen Inhalts (<xref:System.Windows.Navigation.NavigationService.CurrentSource%2A>), und ein Objekt mit dem Inhalt, zu dem navigiert wurde (<xref:System.Windows.Navigation.NavigationService.Content%2A>).  
  
 Wenn Inhalt navigiert wird, <xref:System.Windows.Navigation.NavigationService> zeichnet die Navigation als einen Eintrag im Navigationsverlauf. Wird ein Eintrag hinzugefügt, dem Navigationsverlauf zurück, wenn eine neue Navigation, durch den Aufruf auftritt der <xref:System.Windows.Navigation.NavigationService.Navigate%2A> -Methode, einen Eintrag im Navigationsverlauf vor, durch den Aufruf navigieren <xref:System.Windows.Navigation.NavigationService.GoForward%2A>. Durch Navigieren zu einem Eintrag im Navigationsverlauf, durch den Aufruf wird ein Eintrag zum Navigationsverlauf vor hinzugefügt <xref:System.Windows.Navigation.NavigationService.GoBack%2A>. <xref:System.Windows.Navigation.NavigationService.CanGoBack%2A> und <xref:System.Windows.Navigation.NavigationService.CanGoForward%2A> melden, ob es Einträge im Navigationsverlauf vor bzw. sind. Darüber hinaus den letzten Eintrag im Navigationsverlauf kann, durch den Aufruf entfernt werden <xref:System.Windows.Navigation.NavigationService.RemoveBackEntry%2A>.  
  
 In der Standardeinstellung <xref:System.Windows.Navigation.NavigationService> keine Instanz eines Objekts mit Inhalt im Navigationsverlauf gespeichert. Stattdessen <xref:System.Windows.Navigation.NavigationService> erstellt eine neue Instanz der Content-Objekts, das jedes Mal indem über den Navigationsverlauf navigiert wird. Dieses Verhalten wurde entworfen, um eine übermäßige speichernutzung zu vermeiden, wenn eine große Anzahl und große Teile des Inhalts zu dem navigiert werden. Daher wird der Zustand des Inhalts nicht über eine Navigation zum nächsten gespeichert. WPF bietet jedoch verschiedene Techniken, die mit denen Sie einen gemeinsam genutzten Zustand für einen Inhalt im Navigationsverlauf speichern können.  
  
 Mithilfe von <xref:System.Windows.Navigation.NavigationService.AddBackEntry%2A>, Sie können auch mehrere Sätze von Status für eine Einzelseiten-Instanz speichern.  
  
 <xref:System.Windows.Navigation.NavigationService> ist eine `sealed` Klasse, und deshalb nicht instanziiert werden; stattdessen <xref:System.Windows.Navigation.NavigationService> von Navigatoren verwendet, um die Navigation zu ermöglichen. In WPF, es gibt zwei Navigatoren: <xref:System.Windows.Navigation.NavigationWindow> und <xref:System.Windows.Controls.Frame>.  
  
 Visuell [!INCLUDE[TLA2#tla_xbap#plural](~/includes/tla2sharptla-xbapsharpplural-md.md)] verwenden [!INCLUDE[TLA2#tla_ie7](~/includes/tla2sharptla-ie7-md.md)] als ein Navigator, um eine integrierte Benutzeroberfläche bereitzustellen. Physisch jedoch [!INCLUDE[TLA2#tla_xbap#plural](~/includes/tla2sharptla-xbapsharpplural-md.md)] verwende <xref:System.Windows.Navigation.NavigationWindow> als Navigator; die <xref:System.Windows.Application.MainWindow%2A> Eigenschaft eine [!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)] auf [!INCLUDE[TLA2#tla_ie7](~/includes/tla2sharptla-ie7-md.md)] gibt einen Verweis auf die <xref:System.Windows.Navigation.NavigationWindow>, und den Navigationsverlauf, die von verwaltet wird die <xref:System.Windows.Navigation.NavigationWindow> ist in den Navigationsverlauf, die von verwalteten integriert [!INCLUDE[TLA2#tla_ie7](~/includes/tla2sharptla-ie7-md.md)] auf folgende Weise:  
  
-   Wenn Inhalt navigiert wird durch Aufrufen von <xref:System.Windows.Navigation.NavigationService.Navigate%2A>, <xref:System.Windows.Navigation.NavigationService.GoBack%2A>, und <xref:System.Windows.Navigation.NavigationService.GoForward%2A> innerhalb einer [!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)] der relevanten Einträge werden ebenfalls hinzugefügt, um [!INCLUDE[TLA2#tla_ie7](~/includes/tla2sharptla-ie7-md.md)] Navigationsverlauf.  
  
-   Wenn Einträge in der [!INCLUDE[TLA2#tla_ie7](~/includes/tla2sharptla-ie7-md.md)] Navigation [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] ausgewählt sind, [!INCLUDE[TLA2#tla_ie7](~/includes/tla2sharptla-ie7-md.md)] bewirkt, dass <xref:System.Windows.Navigation.NavigationService> zurück "oder" Vorwärts navigieren, auf den Inhalt, die von diesen Einträgen zugeordnet ist.  
  
> [!NOTE]
>  Ein <xref:System.Windows.Controls.Frame> Geben Sie einen eigenen Navigationsverlauf können, oder verwenden Sie den Navigationsverlauf des der Navigator, der als Host dienende. Wenn <xref:System.Windows.Controls.Frame> bietet einen eigenen Navigationsverlauf, können sie anzeigen, die eigene Navigations- [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] zum Navigieren durch die Einträge im Navigationsverlauf; diese Einträge werden nicht zum Navigationsverlauf des Hostnavigators hinzugefügt (<xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>, [!INCLUDE[TLA2#tla_iegeneric](~/includes/tla2sharptla-iegeneric-md.md)]) und, folglich kann nicht navigiert werden, bei der Navigation [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] aller (finden Sie unter <xref:System.Windows.Controls.Frame.JournalOwnership%2A>).  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AddBackEntry">
      <MemberSignature Language="C#" Value="public void AddBackEntry (System.Windows.Navigation.CustomContentState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddBackEntry(class System.Windows.Navigation.CustomContentState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.AddBackEntry(System.Windows.Navigation.CustomContentState)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddBackEntry (state As CustomContentState)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddBackEntry(System::Windows::Navigation::CustomContentState ^ state);" />
      <MemberSignature Language="F#" Value="member this.AddBackEntry : System.Windows.Navigation.CustomContentState -&gt; unit" Usage="navigationService.AddBackEntry state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Windows.Navigation.CustomContentState" />
      </Parameters>
      <Docs>
        <param name="state">Ein <see cref="T:System.Windows.Navigation.CustomContentState" />-Objekt, das den anwendungsdefinierten Zustand darstellt, der einem bestimmten Inhalt zugeordnet ist.</param>
        <summary>Fügt einen Eintrag zum Navigationsverlauf zurück hinzu, der ein <see cref="T:System.Windows.Navigation.CustomContentState" />-Objekt enthält.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationService.AddBackEntry%2A>, <xref:System.Windows.Navigation.CustomContentState>, und <xref:System.Windows.Navigation.IProvideCustomContentState> verwendet, um mehrere Sätze von Status für den aktuellen Inhalt zu speichern.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="state" /> ist <see langword="null" />, und es wird kein <see cref="T:System.Windows.Navigation.CustomContentState" />-Objekt von <see cref="M:System.Windows.Navigation.IProvideCustomContentState.GetContentState" /> zurückgegeben.</exception>
        <altmember cref="M:System.Windows.Navigation.NavigationService.RemoveBackEntry" />
      </Docs>
    </Member>
    <Member MemberName="CanGoBack">
      <MemberSignature Language="C#" Value="public bool CanGoBack { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanGoBack" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Navigation.NavigationService.CanGoBack" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanGoBack As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanGoBack { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanGoBack : bool" Usage="System.Windows.Navigation.NavigationService.CanGoBack" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Navigationsverlauf zurück mindestens einen Eintrag enthält.</summary>
        <value>
          <see langword="true" />, wenn der Navigationsverlauf zurück mindestens einen Eintrag enthält, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationService.CanGoBack%2A> um zu bestimmen, ob mindestens ein Eintrag im Navigationsverlauf zurück. Diese Eigenschaft sollte überprüft werden, vor dem Aufruf <xref:System.Windows.Navigation.NavigationService.GoBack%2A>; Wenn <xref:System.Windows.Navigation.NavigationService.GoBack%2A> wird aufgerufen, und es sind keine Einträge im Navigationsverlauf zurück, eine <xref:System.InvalidOperationException> ausgelöst.  
  
> [!NOTE]
>  Wenn der Navigationsverlauf anhand mehrerer Navigationen gemeinsam verwendet wird (<xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>), wird die letzten Eintrag im Navigationsverlauf möglicherweise nicht bereits durch hinzugefügt wurden die <xref:System.Windows.Navigation.NavigationService> für den aktuellen Navigator.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Navigation.NavigationService.CanGoForward" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.GoForward" />
      </Docs>
    </Member>
    <Member MemberName="CanGoForward">
      <MemberSignature Language="C#" Value="public bool CanGoForward { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanGoForward" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Navigation.NavigationService.CanGoForward" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanGoForward As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanGoForward { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanGoForward : bool" Usage="System.Windows.Navigation.NavigationService.CanGoForward" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Navigationsverlauf vor mindestens einen Eintrag enthält.</summary>
        <value>
          <see langword="true" />, wenn der Navigationsverlauf vor mindestens einen Eintrag enthält, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationService.CanGoForward%2A> um zu bestimmen, ob mindestens ein Eintrag im Navigationsverlauf. Diese Eigenschaft sollte überprüft werden, vor dem Aufruf <xref:System.Windows.Navigation.NavigationService.GoForward%2A>; Wenn <xref:System.Windows.Navigation.NavigationService.GoForward%2A> wird aufgerufen, und es sind keine Einträge im Navigationsverlauf vor einer <xref:System.InvalidOperationException> ausgelöst.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Navigation.NavigationService.CanGoBack" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.GoBack" />
      </Docs>
    </Member>
    <Member MemberName="Content">
      <MemberSignature Language="C#" Value="public object Content { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Content" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Navigation.NavigationService.Content" />
      <MemberSignature Language="VB.NET" Value="Public Property Content As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Content { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Content : obj with get, set" Usage="System.Windows.Navigation.NavigationService.Content" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Verweis auf das Objekt ab, das den aktuellen Inhalt enthält, oder legt diesen Verweis fest.</summary>
        <value>Ein Objekt, das ein Verweis auf das Objekt ist, das den aktuellen Inhalt enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Inhalt kann auf zwei Arten festgelegt werden:  
  
-   Direkt, indem er auf einen Verweis auf ein Objekt.  
  
-   Indirekt, durch den Aufruf <xref:System.Windows.Navigation.NavigationService.Navigate%2A>, <xref:System.Windows.Navigation.NavigationService.GoBack%2A>, oder <xref:System.Windows.Navigation.NavigationService.GoForward%2A>.  
  
 Festlegen von <xref:System.Windows.Navigation.NavigationService> initiiert eine neue Navigation; da die Navigation asynchron ist <xref:System.Windows.Navigation.NavigationService.Content%2A> keinen Wert zurück, wenn die Überprüfung wird sofort nach der festgelegt wird.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Windows.Navigation.NavigationService.Navigate" />
      </Docs>
    </Member>
    <Member MemberName="CurrentSource">
      <MemberSignature Language="C#" Value="public Uri CurrentSource { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri CurrentSource" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Navigation.NavigationService.CurrentSource" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentSource As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ CurrentSource { Uri ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentSource : Uri" Usage="System.Windows.Navigation.NavigationService.CurrentSource" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den URI des Inhalts ab, zu dem zuletzt navigiert wurde.</summary>
        <value>Ein <see cref="T:System.Uri" /> für den Inhalt, zu dem zuletzt, wenn navigiert wurde mit einem URI navigiert ist, andernfalls <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert des der <xref:System.Windows.Navigation.NavigationService.CurrentSource%2A> Eigenschaft wird nicht geändert werden, bis die Navigation zu einem anderen URI erfolgreich abgeschlossen wurde.  
  
 <xref:System.Windows.Navigation.NavigationService.CurrentSource%2A> kann mit einem nur-Fragment-URI festgelegt werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FragmentNavigation">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.FragmentNavigationEventHandler FragmentNavigation;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.FragmentNavigationEventHandler FragmentNavigation" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Navigation.NavigationService.FragmentNavigation" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event FragmentNavigation As FragmentNavigationEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::FragmentNavigationEventHandler ^ FragmentNavigation;" />
      <MemberSignature Language="F#" Value="member this.FragmentNavigation : System.Windows.Navigation.FragmentNavigationEventHandler " Usage="member this.FragmentNavigation : System.Windows.Navigation.FragmentNavigationEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.FragmentNavigationEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn die Navigation zu einem Inhaltsfragment gestartet wird. Dies erfolgt sofort, wenn sich das gewünschte Fragment im aktuellen Inhalt befindet oder nachdem der [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]-Quellinhalt geladen wurde, sofern sich das gewünschte Fragment in einem anderen Inhalt befindet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wird standardmäßig ein Inhaltsfragment Content, ist enthalten sind, indem Sie eine benannte <xref:System.Windows.UIElement>, d.h. eine <xref:System.Windows.UIElement> , deren <xref:System.Windows.FrameworkElement.Name%2A> Attribut festgelegt ist, z. B.:  
  
```  
<TextBlock Name="FragmentName">...</TextBlock>  
```  
  
 Navigieren Sie zu einem [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] Fragment durch die Bereitstellung von eines URI mit einem Suffix in das folgende Format:  
  
 \#*FragmentName*  
  
 Das folgende Beispiel zeigt ein Beispiel für ein URI, der zu einem Inhaltsfragment bezieht sich:  
  
 `http://www.microsoft.com/targetpage.xaml#FragmentName`  
  
 Nach dem Laden der Seite "Quelle" (nach <xref:System.Windows.Navigation.NavigationService.LoadCompleted> Ereignis wird ausgelöst), beginnt die Fragmentnavigation und die <xref:System.Windows.Navigation.NavigationService> sucht die [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] Fragment. Wenn die [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] Fragment gefunden wird, <xref:System.Windows.Navigation.NavigationService> weist den Inhalt Navigator (<xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>) an die entsprechende Fragment anzuzeigen. Wenn Sie dieses Verhalten ändern möchten, können Sie behandeln <xref:System.Windows.Navigation.NavigationService.FragmentNavigation> auf Ihren eigenen Fragmentnavigationsverhalten bereitzustellen. <xref:System.Windows.Navigation.NavigationService.FragmentNavigation> Übergeben einer <xref:System.Windows.Navigation.FragmentNavigationEventArgs> Parameter der Eigenschaften verfügbar gemacht, die zu diesem Zweck nützlich sind einschließlich:  
  
-   Der Navigator, der diesen Navigationsdienst besitzt (<xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>).  
  
-   Der FragmentName.  
  
 Sie können behandeln <xref:System.Windows.Navigation.NavigationService.FragmentNavigation> die standardmäßige WPF-Fragment-Implementierung mit einer eigenen Implementierung überschreiben. Wenn Sie dies tun, müssen Sie festlegen <xref:System.Windows.Navigation.FragmentNavigationEventArgs.Handled%2A> zu `true`ist, andernfalls das Standard-WPF-Fragment Verhalten bei der Verarbeitung angewendet wird.  
  
 Vermeiden Sie direkt initiieren Navigation innerhalb einer <xref:System.Windows.Navigation.NavigationService.FragmentNavigation> -Ereignishandler. Da <xref:System.Windows.Navigation.NavigationService.FragmentNavigation> wird ausgelöst, während einer vorhandenen Navigation, eine neue Navigation aus initiiert eine <xref:System.Windows.Navigation.NavigationService.FragmentNavigation> -Ereignishandler erstellt eine geschachtelte Navigation, die dazu führen kann, dass die <xref:System.ExecutionEngineException> ausgelöst wird. Stattdessen können Sie indirekt Navigation initiieren, durch das Erstellen einer asynchronen Arbeitsaufgabe, die mit der <xref:System.Windows.Threading.Dispatcher>.  
  
> [!NOTE]
>  Wenn <xref:System.Windows.Navigation.NavigationService> löst <xref:System.Windows.Navigation.NavigationService.FragmentNavigation>, sie löst ebenfalls <xref:System.Windows.Application.FragmentNavigation?displayProperty=nameWithType> Ereignis auf der <xref:System.Windows.Application> Objekt.  
  
> [!IMPORTANT]
>  Fragmentnavigation wird nicht unterstützt lose [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] Seiten (nur-Markup- [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] Dateien mit `Page` als Stammelement) in den folgenden Fällen:  
>   
>  • Beim Navigieren zu einem Fragment in eine loose [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] Seite.  
>   
>  • Beim Navigieren von einer losen [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] Seite, um ein Fragment in einer anderen losen [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] Seite.  
>   
>  Allerdings eine loose [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] Seite zu den eigenen Fragmenten navigieren kann.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie behandelt <xref:System.Windows.Navigation.NavigationService.FragmentNavigation> Verhalten für die benutzerdefinierte FragmentNavigation bereitstellen. In diesem Fall im Beispiel wird einen Fehler geöffnet [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] Seite, wenn das Fragment in der Quelle [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] Seite wurde nicht gefunden.  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowFragmentNavigationCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindowfragmentnavigationcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowFragmentNavigationCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindowfragmentnavigationcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigating" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigated" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.LoadCompleted" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationProgress" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationStopped" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationFailed" />
      </Docs>
    </Member>
    <Member MemberName="GetNavigationService">
      <MemberSignature Language="C#" Value="public static System.Windows.Navigation.NavigationService GetNavigationService (System.Windows.DependencyObject dependencyObject);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Navigation.NavigationService GetNavigationService(class System.Windows.DependencyObject dependencyObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.GetNavigationService(System.Windows.DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Navigation::NavigationService ^ GetNavigationService(System::Windows::DependencyObject ^ dependencyObject);" />
      <MemberSignature Language="F#" Value="static member GetNavigationService : System.Windows.DependencyObject -&gt; System.Windows.Navigation.NavigationService" Usage="System.Windows.Navigation.NavigationService.GetNavigationService dependencyObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationService</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObject" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="dependencyObject">Das <see cref="T:System.Windows.DependencyObject" /> in einem Inhalt, der von einem Navigator gehostet wird.</param>
        <summary>Ruft einen Verweis auf den <see cref="T:System.Windows.Navigation.NavigationService" /> für den Navigator ab, dessen Inhalt das angegebene <see cref="T:System.Windows.DependencyObject" /> enthält.</summary>
        <returns>Ein Verweis auf den <see cref="T:System.Windows.Navigation.NavigationService" /> für den Navigator, dessen Inhalt das angegebene <see cref="T:System.Windows.DependencyObject" /> enthält. Dies kann in einigen Fällen <see langword="null" /> sein.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Navigator verfügt über eine <xref:System.Windows.Navigation.NavigationService> , das Inhaltsnavigation behandelt. WPF verfügt über zwei Navigatoren: <xref:System.Windows.Navigation.NavigationWindow> und <xref:System.Windows.Controls.Frame>. Zum Verarbeiten von navigationsanforderungen, und Verwalten von Navigationslebensdauer, verwendet ein Navigator dem Navigationsdienst WPF, die als implementiert ist die <xref:System.Windows.Navigation.NavigationService> Klasse. Inhalte, die von einem Navigator gehostet wird, erhalten einen Verweis auf die Navigators <xref:System.Windows.Navigation.NavigationService> durch Aufrufen der <xref:System.Windows.Navigation.NavigationService.GetNavigationService%2A> Methode.  
  
 <xref:System.Windows.Navigation.NavigationService.GetNavigationService%2A> Gibt `null` bei der `dependencyObject`:  
  
-   Ist eine <xref:System.Windows.Navigation.NavigationWindow>.  
  
-   Ist eine <xref:System.Windows.Controls.Frame> , die:  
  
    1.  Wird von einem anderen Navigator gehostet.  
  
    2.  Verfügt über seine <xref:System.Windows.Controls.Frame.JournalOwnership%2A> -Eigenschaftensatz auf <xref:System.Windows.Navigation.JournalOwnership.UsesParentJournal>.  
  
-   Ist nicht Teil des Inhalts, der von einem Navigator gehostet wird.  
  
 WPF bietet zwei Verknüpfungen zum Abrufen eines Verweises auf die <xref:System.Windows.Navigation.NavigationService>:  
  
-   Die <xref:System.Windows.Navigation.NavigationService> , verarbeitet die Navigation zu einer <xref:System.Windows.Controls.Page> aus zugegriffen werden kann die <xref:System.Windows.Controls.Page> selbst durch Abrufen des Werts von der <xref:System.Windows.Controls.Page.NavigationService%2A?displayProperty=nameWithType> Eigenschaft.  
  
-   Die <xref:System.Windows.Navigation.NavigationService> wird, indem eine <xref:System.Windows.Controls.Frame> zur Verarbeitung der Navigation erfolgen können durch Abrufen des Werts der <xref:System.Windows.Controls.Frame.NavigationService%2A> Eigenschaft.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt wie eine <xref:System.Windows.Controls.UserControl> können rufen Sie einen Navigationsdienst durch den Aufruf <xref:System.Windows.Navigation.NavigationService.GetNavigationService%2A>.  
  
 [!code-csharp[NSGetNavigationServiceSnippets#GetNavigationServiceCODE1](~/samples/snippets/csharp/VS_Snippets_Wpf/NSGetNavigationServiceSnippets/CSharp/ContentUserControl.xaml.cs#getnavigationservicecode1)]
 [!code-vb[NSGetNavigationServiceSnippets#GetNavigationServiceCODE1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NSGetNavigationServiceSnippets/visualbasic/contentusercontrol.xaml.vb#getnavigationservicecode1)]  
[!code-csharp[NSGetNavigationServiceSnippets#GetNavigationServiceCODE2](~/samples/snippets/csharp/VS_Snippets_Wpf/NSGetNavigationServiceSnippets/CSharp/ContentUserControl.xaml.cs#getnavigationservicecode2)]
[!code-vb[NSGetNavigationServiceSnippets#GetNavigationServiceCODE2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NSGetNavigationServiceSnippets/visualbasic/contentusercontrol.xaml.vb#getnavigationservicecode2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="dependencyObject" />-Parameter ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GoBack">
      <MemberSignature Language="C#" Value="public void GoBack ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void GoBack() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.GoBack" />
      <MemberSignature Language="VB.NET" Value="Public Sub GoBack ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GoBack();" />
      <MemberSignature Language="F#" Value="member this.GoBack : unit -&gt; unit" Usage="navigationService.GoBack " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Navigiert zum letzten Eintrag im Navigationsverlauf zurück, sofern vorhanden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vor dem Aufruf <xref:System.Windows.Navigation.NavigationService.GoBack%2A>, <xref:System.Windows.Navigation.NavigationService.CanGoBack%2A> Eigenschaft überprüft werden, um zu bestimmen, ob im Navigationsverlauf zurück Einträge vorhanden sind.  
  
   
  
## Examples  
 Im folgende Beispiel navigiert zum letzten Eintrag im Navigationsverlauf an, sofern vorhanden.  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowBackCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindowbackcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowBackCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindowbackcode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Windows.Navigation.NavigationService.GoBack" /> wird aufgerufen, wenn der Navigationsverlauf zurück keine Einträge enthält.</exception>
        <altmember cref="P:System.Windows.Navigation.NavigationService.CanGoForward" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.GoForward" />
      </Docs>
    </Member>
    <Member MemberName="GoForward">
      <MemberSignature Language="C#" Value="public void GoForward ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void GoForward() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.GoForward" />
      <MemberSignature Language="VB.NET" Value="Public Sub GoForward ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GoForward();" />
      <MemberSignature Language="F#" Value="member this.GoForward : unit -&gt; unit" Usage="navigationService.GoForward " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Navigiert zum letzten Eintrag im Navigationsverlauf vor, sofern vorhanden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vor dem Aufruf <xref:System.Windows.Navigation.NavigationService.GoForward%2A>, <xref:System.Windows.Navigation.NavigationService.CanGoForward%2A> Eigenschaft überprüft werden, um zu bestimmen, ob im Navigationsverlauf Einträge vorhanden sind.  
  
   
  
## Examples  
 Im folgende Beispiel navigiert zum letzten Eintrag im Navigationsverlauf vor, sofern vorhanden.  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowForwardCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindowforwardcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowForwardCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindowforwardcode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Windows.Navigation.NavigationService.GoForward" /> wird aufgerufen, wenn der Navigationsverlauf vor keine Einträge enthält.</exception>
        <altmember cref="P:System.Windows.Navigation.NavigationService.CanGoBack" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.GoBack" />
      </Docs>
    </Member>
    <Member MemberName="LoadCompleted">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.LoadCompletedEventHandler LoadCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.LoadCompletedEventHandler LoadCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Navigation.NavigationService.LoadCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LoadCompleted As LoadCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::LoadCompletedEventHandler ^ LoadCompleted;" />
      <MemberSignature Language="F#" Value="member this.LoadCompleted : System.Windows.Navigation.LoadCompletedEventHandler " Usage="member this.LoadCompleted : System.Windows.Navigation.LoadCompletedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.LoadCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn der Inhalt, zu dem navigiert wird, geladen und analysiert und mit dem Rendering begonnen wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie behandeln <xref:System.Windows.Navigation.NavigationService.LoadCompleted> relevanten Informationen über die navigationsanforderung nach Abschluss des Ladevorgangs ermittelt werden sollen. Diese Informationen sind verfügbar, aus der <xref:System.Windows.Navigation.NavigationEventArgs> -Objekt, das an die <xref:System.Windows.Navigation.NavigationService.LoadCompleted> -Ereignishandler und enthält:  
  
-   Der Inhalt und einen URI.  
  
-   Der Navigator (<xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>).  
  
-   Zusätzliche Daten, wenn die Navigation initiiert wurde, durch Aufrufen von entweder <xref:System.Windows.Navigation.NavigationService.Navigate%2A> oder <xref:System.Windows.Navigation.NavigationService.Navigate%2A>.  
  
-   Details der Antwort (mit einem <xref:System.Net.WebResponse> Objekt).  
  
 <xref:System.Windows.Navigation.NavigationService.LoadCompleted> nicht ausgelöst, wenn die Seite "Quelle" konnte nicht gefunden oder werden, in diesem Fall geladen <xref:System.Windows.Navigation.NavigationService.NavigationFailed> ausgelöst wird.  
  
> [!NOTE]
>  Wenn <xref:System.Windows.Navigation.NavigationService> löst <xref:System.Windows.Navigation.NavigationService.LoadCompleted>, sie löst ebenfalls <xref:System.Windows.Application.LoadCompleted?displayProperty=nameWithType> Ereignis auf der <xref:System.Windows.Application> Objekt.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie behandelt <xref:System.Windows.Navigation.NavigationService.LoadCompleted>.  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowLoadCompletedCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindowloadcompletedcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowLoadCompletedCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindowloadcompletedcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigating" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigated" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationProgress" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationStopped" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.FragmentNavigation" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationFailed" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Navigate">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Navigiert asynchron zum angegebenen Quellinhalt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public bool Navigate (object root);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Navigate(object root) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.Navigate(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Navigate (root As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Navigate(System::Object ^ root);" />
      <MemberSignature Language="F#" Value="member this.Navigate : obj -&gt; bool" Usage="navigationService.Navigate root" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="root" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="root">Ein Objekt, das den Inhalt enthält, zu dem navigiert werden soll.</param>
        <summary>Navigiert asynchron zu Inhalt, der in einem Objekt enthalten ist.</summary>
        <returns>
          <see langword="true" />, wenn eine Navigation nicht abgebrochen wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationService.Navigate%2A> Navigiert zur der <xref:System.Object> gemäß `root` , wenn die folgenden Bedingungen erfüllt sind:  
  
-   Die <xref:System.Windows.Navigation.NavigationService.Navigating> -Ereignis nicht abgebrochen wird.  
  
-   Eine webanforderung (finden Sie unter <xref:System.Windows.Navigation.NavigationService.Navigating>) können erstellt werden.  
  
 Wenn `root` ist `null`, den vorhandenen Inhalt (<xref:System.Windows.Navigation.NavigationService.Content%2A>) deaktiviert ist.  
  
> [!NOTE]
>  Wenn die Web-Inhalte herunterladen, erhalten Sie möglicherweise eine Webausnahme (zum Beispiel 404: die Datei nicht gefunden). Sie können solche Ausnahmen behandeln <xref:System.Windows.Navigation.NavigationService.NavigationFailed>.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt das Navigieren zu einem <xref:System.Windows.Controls.Page> -Objekt, das die Struktur der Datenquelle enthält.  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowNavigateObjectCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindownavigateobjectcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowNavigateObjectCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindownavigateobjectcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object,System.Boolean)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public bool Navigate (Uri source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Navigate(class System.Uri source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Function Navigate (source As Uri) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Navigate(Uri ^ source);" />
      <MemberSignature Language="F#" Value="member this.Navigate : Uri -&gt; bool" Usage="navigationService.Navigate source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="source">Ein <see cref="T:System.Uri" />-Objekt, das mit dem URI für den gewünschten Inhalt initialisiert wurde.</param>
        <summary>Navigiert asynchron zu dem Inhalt, der durch einen URI angegeben wird.</summary>
        <returns>
          <see langword="true" />, wenn eine Navigation nicht abgebrochen wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert des `source` möglich, dass eine Web [!INCLUDE[TLA#tla_url](~/includes/tlasharptla-url-md.md)] oder eine gültige Paket-URI (finden Sie unter [Paket-URIs in WPF](~/docs/framework/wpf/app-development/pack-uris-in-wpf.md)).  
  
 <xref:System.Windows.Navigation.NavigationService.Navigate%2A> Navigiert zur angegebenen URI `source` , wenn die folgenden Bedingungen erfüllt sind:  
  
-   Die <xref:System.Windows.Navigation.NavigationService.Navigating> -Ereignis nicht abgebrochen wird.  
  
-   Eine webanforderung (finden Sie unter <xref:System.Windows.Navigation.NavigationService.Navigating>) können erstellt werden.  
  
 Wenn `source` ist `null`, den vorhandenen Inhalt (<xref:System.Windows.Navigation.NavigationService.Content%2A>) deaktiviert ist.  
  
> [!NOTE]
>  Wenn die Web-Inhalte herunterladen, erhalten Sie möglicherweise eine Webausnahme (zum Beispiel 404: die Datei nicht gefunden). Sie können solche Ausnahmen behandeln <xref:System.Windows.Navigation.NavigationService.NavigationFailed>.  
  
 Sie können <xref:System.Windows.Navigation.NavigationService.Navigate%2A> , zu einem Inhaltsfragment navigiert. Wenn der Inhalt, der durch den URI identifiziert den aktuellen Inhalt ist, ist es nicht erneut heruntergeladen.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie zu einem URI navigiert wird.  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowNavigateCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindownavigatecode)]
 [!code-vb[NavigationServiceSnippets#MainWindowNavigateCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindownavigatecode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object,System.Boolean)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Object)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public bool Navigate (object root, object navigationState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Navigate(object root, object navigationState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.Navigate(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Navigate (root As Object, navigationState As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Navigate(System::Object ^ root, System::Object ^ navigationState);" />
      <MemberSignature Language="F#" Value="member this.Navigate : obj * obj -&gt; bool" Usage="navigationService.Navigate (root, navigationState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="root" Type="System.Object" />
        <Parameter Name="navigationState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="root">Ein Objekt, das den Inhalt enthält, zu dem navigiert werden soll.</param>
        <param name="navigationState">Ein Objekt, das Daten enthält, die für die Verarbeitung während der Navigation verwendet werden.</param>
        <summary>Navigiert asynchron zu Inhalt in einem Objekt und übergibt ein Objekt mit Daten, die für die Verarbeitung während der Navigation verwendet werden.</summary>
        <returns>
          <see langword="true" />, wenn eine Navigation nicht abgebrochen wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode hat das gleiche Verhalten wie <xref:System.Windows.Navigation.NavigationService.Navigate%2A?displayProperty=nameWithType>, obwohl ein Objekt statt eines URI übergeben wird.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt das Navigieren zu einem <xref:System.Windows.Controls.Page> Objekt, das den Quellinhalt enthält und die Übergabe der Navigationszustand.  
  
 [!code-csharp[NavigationServiceNavigateObjectStateSnippets#MainWindowCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceNavigateObjectStateSnippets/CSharp/MainWindow.xaml.cs#mainwindowcode)]
 [!code-vb[NavigationServiceNavigateObjectStateSnippets#MainWindowCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceNavigateObjectStateSnippets/visualbasic/mainwindow.xaml.vb#mainwindowcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object,System.Boolean)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public bool Navigate (Uri source, object navigationState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Navigate(class System.Uri source, object navigationState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Navigate (source As Uri, navigationState As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Navigate(Uri ^ source, System::Object ^ navigationState);" />
      <MemberSignature Language="F#" Value="member this.Navigate : Uri * obj -&gt; bool" Usage="navigationService.Navigate (source, navigationState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Uri" />
        <Parameter Name="navigationState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source">Ein <see cref="T:System.Uri" />-Objekt, das mit dem URI für den gewünschten Inhalt initialisiert wurde.</param>
        <param name="navigationState">Ein Objekt, das Daten enthält, die für die Verarbeitung während der Navigation verwendet werden.</param>
        <summary>Navigiert asynchron zum Quellinhalt am URI und übergibt ein Objekt mit Daten, die für die Verarbeitung während der Navigation verwendet werden.</summary>
        <returns>
          <see langword="true" />, wenn eine Navigation nicht abgebrochen wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Da Navigationen asynchron sind, ist es möglich, mehrere Navigationsvorgänge zur gleichen Zeit ausgeführt werden. Wenn zwei untergeordnete Rahmen auf eine einzelne Seite vorhanden sind, könnte z. B. beide Frames navigieren. In diesem Fall die verschiedenen Navigationsereignisse, die vom ausgelöst werden <xref:System.Windows.Navigation.NavigationService> kann, werden ausgelöste mehrmals, eine für jeden Teil des Inhalts, zu dem navigiert wird, aber nicht unbedingt, dass Navigationsereignis. Wenn eine bestimmte navigationsanforderung muss zum Verarbeiten von Daten, die spezifisch für die einzelnen Anforderungen ist, kann nicht es daher Daten verwenden, die für alle navigationsanforderungen verfügbar ist. Sie können stattdessen `navigationState` zum Übergeben von Daten für die Navigation, die verarbeitet wird, um eine navigationsanforderung spezifisch ist.  
  
 Die folgenden Ereignisargumente bieten Zugriff auf den Navigationszustand:  
  
-   <xref:System.Windows.Navigation.NavigatingCancelEventArgs.ExtraData%2A> (die an die <xref:System.Windows.Navigation.NavigationService.Navigating> Ereignis).  
  
-   <xref:System.Windows.Navigation.NavigationEventArgs.ExtraData%2A> (die an die <xref:System.Windows.Navigation.NavigationService.Navigated>, <xref:System.Windows.Navigation.NavigationService.NavigationStopped>, <xref:System.Windows.Navigation.NavigationService.LoadCompleted> Ereignishandler).  
  
   
  
## Examples  
 Im folgende Beispiel wird veranschaulicht, navigieren zu einem URI, und übergeben Navigationszustand.  
  
 [!code-csharp[NavigationServiceNavigateUriStateSnippets#MainWindowCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceNavigateUriStateSnippets/CSharp/MainWindow.xaml.cs#mainwindowcode)]
 [!code-vb[NavigationServiceNavigateUriStateSnippets#MainWindowCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceNavigateUriStateSnippets/visualbasic/mainwindow.xaml.vb#mainwindowcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object,System.Boolean)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Object)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public bool Navigate (Uri source, object navigationState, bool sandboxExternalContent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Navigate(class System.Uri source, object navigationState, bool sandboxExternalContent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Navigate (source As Uri, navigationState As Object, sandboxExternalContent As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Navigate(Uri ^ source, System::Object ^ navigationState, bool sandboxExternalContent);" />
      <MemberSignature Language="F#" Value="member this.Navigate : Uri * obj * bool -&gt; bool" Usage="navigationService.Navigate (source, navigationState, sandboxExternalContent)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Uri" />
        <Parameter Name="navigationState" Type="System.Object" />
        <Parameter Name="sandboxExternalContent" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="source">Ein <see cref="T:System.Uri" />-Objekt, das mit dem URI für den gewünschten Inhalt initialisiert wurde.</param>
        <param name="navigationState">Ein Objekt, das Daten enthält, die für die Verarbeitung während der Navigation verwendet werden.</param>
        <param name="sandboxExternalContent">Lädt Inhalt in eine teilweise vertrauenswürdige Sicherheits-Sandbox herunter (mit dem Standardberechtigungssatz der Internetzone, wenn <see langword="true" />). Der Standardwert ist <see langword="false" />.</param>
        <summary>Navigiert asynchron zum Quellinhalt am URI, übergibt ein Objekt mit dem Navigationszustand für die Verarbeitung während der Navigation und stellt eine Sandboxumgebung für den Inhalt bereit.</summary>
        <returns>
          <see langword="true" />, wenn eine Navigation nicht abgebrochen wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist nur für eigenständige Anwendungen und [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] Inhalt.  
  
 Diese Methode weist dasselbe Verhalten wie <xref:System.Windows.Navigation.NavigationService.Navigate%2A?displayProperty=nameWithType>, und erweitert diese durch, um sicherzustellen, dass der Inhalt heruntergeladen wird in einer teilweise vertrauenswürdigen Sicherheits-Sandbox platziert wird (mit dem Standardberechtigungssatz der Internetzone von Berechtigungen – finden Sie unter [WPF teilweiser Vertrauenswürdigkeit Sicherheit](~/docs/framework/wpf/wpf-partial-trust-security.md)).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Object)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Navigated">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigatedEventHandler Navigated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigatedEventHandler Navigated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Navigation.NavigationService.Navigated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Navigated As NavigatedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigatedEventHandler ^ Navigated;" />
      <MemberSignature Language="F#" Value="member this.Navigated : System.Windows.Navigation.NavigatedEventHandler " Usage="member this.Navigated : System.Windows.Navigation.NavigatedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigatedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn der Inhalt, zu dem navigiert wird, gefunden wurde. Dieses Ereignis ist über die <see cref="P:System.Windows.Navigation.NavigationService.Content" />-Eigenschaft verfügbar, auch wenn diese noch nicht vollständig geladen wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie behandeln <xref:System.Windows.Navigation.NavigationService.Navigated> bei Bedarf, um die relevanten Informationen über die navigationsanforderung erkannt wird, wenn der Download beginnt. Diese Informationen sind verfügbar, aus der <xref:System.Windows.Navigation.NavigationEventArgs> -Objekt, das an die <xref:System.Windows.Navigation.NavigationService.Navigated> -Ereignishandler und enthält:  
  
-   Der Quellseite. Wenn <xref:System.Windows.Navigation.NavigationService.Navigated> ausgelöst wird, zumindest einen Teil von der Quellseite [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] Struktur analysiert, und Ziel-Inhaltssteuerelement hinzugefügt wurde.  
  
-   Der angeforderte URI.  
  
-   Der Navigator (<xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>).  
  
-   Zusätzliche Daten, wenn die Navigation initiiert wurde, durch Aufrufen von entweder <xref:System.Windows.Navigation.NavigationService.Navigate%2A> oder <xref:System.Windows.Navigation.NavigationService.Navigate%2A>.  
  
-   Details der Antwort (mit einem <xref:System.Net.WebResponse> Objekt).  
  
 <xref:System.Windows.Navigation.NavigationService.Navigated> nicht ausgelöst, wenn die Seite "Quelle" konnte nicht gefunden oder werden, in diesem Fall geladen <xref:System.Windows.Navigation.NavigationService.NavigationFailed> ausgelöst wird.  
  
> [!NOTE]
>  Wenn <xref:System.Windows.Navigation.NavigationService> löst <xref:System.Windows.Navigation.NavigationService.NavigationFailed>, sie löst ebenfalls <xref:System.Windows.Application.NavigationFailed?displayProperty=nameWithType> Ereignis auf der <xref:System.Windows.Application> Objekt.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie behandelt <xref:System.Windows.Navigation.NavigationService.Navigated>.  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowNavigatedCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindownavigatedcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowNavigatedCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindownavigatedcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigating" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.LoadCompleted" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationProgress" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationStopped" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.FragmentNavigation" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationFailed" />
      </Docs>
    </Member>
    <Member MemberName="Navigating">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigatingCancelEventHandler Navigating;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigatingCancelEventHandler Navigating" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Navigation.NavigationService.Navigating" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Navigating As NavigatingCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigatingCancelEventHandler ^ Navigating;" />
      <MemberSignature Language="F#" Value="member this.Navigating : System.Windows.Navigation.NavigatingCancelEventHandler " Usage="member this.Navigating : System.Windows.Navigation.NavigatingCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigatingCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn eine neue Navigation angefordert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationService.Navigating> wird ausgelöst, wenn eine neue Navigation angefordert wird, jedoch bevor die Quelle Inhalt angefordert wird, einschließlich der Verwendung:  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigate%2A> wird aufgerufen.  
  
-   <xref:System.Windows.Navigation.NavigationService.GoBack%2A> oder <xref:System.Windows.Navigation.NavigationService.GoForward%2A> aufgerufen wird (oder Auswahl eines Eintrags aus einer Navigation [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]).  
  
-   Ein Inhaltsfragment navigiert wird.  
  
 Sie behandeln <xref:System.Windows.Navigation.NavigationService.Navigating> Wenn Sie relevante Informationen in Bezug auf die navigationsanforderung vor Beginn der Navigation zu ermitteln müssen. Diese Informationen sind verfügbar, aus der <xref:System.Windows.Navigation.NavigatingCancelEventArgs> -Objekt, das an die <xref:System.Windows.Navigation.NavigationService.Navigating> -Ereignishandler.  
  
 Ein <xref:System.Net.WebRequest> -Objekt für die Navigation erstellt wurde und verfügbar ist die <xref:System.Windows.Navigation.NavigatingCancelEventArgs> -Parameter, da die tatsächliche Anforderung an diesem Punkt noch nicht erfolgt ist, können Sie konfigurieren die <xref:System.Net.WebRequest> -Objekts, sofern erforderlich.  
  
 Sie auch behandeln <xref:System.Windows.Navigation.NavigatingCancelEventArgs> Navigation Abbrechen, falls erforderlich, durch Festlegen von <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> auf "true". Wenn Sie die Navigation Abbrechen, werden keine anderen Navigationsereignisse ausgelöst.  
  
> [!NOTE]
>  Wenn Ihre Anwendung im Browser gehostet wird, Sie nicht verhindern, dass den Benutzer die Anwendung verlassen, durch das Abbrechen der <xref:System.Windows.Navigation.NavigationService.Navigating> Ereignis.  
  
 Nachdem der erste Teil des Inhalts von einem Navigator zu dem navigiert wird (<xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>), wird jeder Teil des Inhalts, der weg navigiert wird dem Navigationsverlauf hinzugefügt. Bei Bedarf, um Statusinformationen über den Inhalt zu speichern, Sie von dem weg navigiert sind, können Sie den Status des Journaleintrags für den jeweiligen Inhalt hinzufügen, indem festlegen <xref:System.Windows.Navigation.NavigatingCancelEventArgs.ContentStateToSave%2A> mit einem <xref:System.Windows.Navigation.CustomContentState> Objekt.  
  
> [!NOTE]
>  Wenn <xref:System.Windows.Navigation.NavigationService> löst <xref:System.Windows.Navigation.NavigationService.Navigating>, sie löst ebenfalls <xref:System.Windows.Application.Navigating?displayProperty=nameWithType> Ereignis auf der <xref:System.Windows.Application> Objekt.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie behandelt <xref:System.Windows.Navigation.NavigationService.Navigating> zu erkennen, ob eine Anforderung zum Aktualisieren von statischen Inhalten vorgenommen wurde, und wenn Ja, um die Anforderung abzubrechen.  
  
 <xref:System.Windows.Navigation.NavigationService.Navigating>  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowNavigatingCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindownavigatingcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowNavigatingCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindownavigatingcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Navigation.NavigationService.FragmentNavigation" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigated" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.LoadCompleted" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationProgress" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationStopped" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationFailed" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Refresh" />
      </Docs>
    </Member>
    <Member MemberName="NavigationFailed">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationFailedEventHandler NavigationFailed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationFailedEventHandler NavigationFailed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Navigation.NavigationService.NavigationFailed" />
      <MemberSignature Language="VB.NET" Value="Public Event NavigationFailed As NavigationFailedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigationFailedEventHandler ^ NavigationFailed;" />
      <MemberSignature Language="F#" Value="member this.NavigationFailed : System.Windows.Navigation.NavigationFailedEventHandler " Usage="member this.NavigationFailed : System.Windows.Navigation.NavigationFailedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationFailedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn ein Fehler auftritt, während zum angeforderten Inhalt navigiert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn entweder eine <xref:System.Net.WebException> oder <xref:System.IO.IOException> ausgelöst, während eine Navigation, die <xref:System.Windows.Navigation.NavigationService.NavigationFailed> Ereignis wird ausgelöst. <xref:System.Windows.Navigation.NavigationService.NavigationFailed> Übergeben einer <xref:System.Windows.Navigation.NavigationFailedEventArgs> , kapselt Informationen über die Ausnahme und die Details der Navigation, die die Ausnahme verursacht hat.  
  
 Wenn eine Ausnahme aus einer fehlgeschlagenen Navigation ergibt und nicht behandelt wird, werden die folgenden Ereignisse in der aufgeführten Reihenfolge ausgelöst:  
  
-   <xref:System.Windows.Navigation.NavigationService.NavigationFailed?displayProperty=nameWithType>  
  
-   <xref:System.Windows.Controls.Frame.NavigationFailed?displayProperty=nameWithType> oder <xref:System.Windows.Navigation.NavigationWindow.NavigationFailed?displayProperty=nameWithType>.  
  
-   <xref:System.Windows.Application.NavigationFailed?displayProperty=nameWithType>  
  
-   <xref:System.Windows.Application.DispatcherUnhandledException>  
  
 Wenn ein Navigator (<xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>) gehostet wird, indem Sie einen oder mehrere Navigatoren, `NavigationFailed` nicht für diese ausgelöst wird.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie behandelt <xref:System.Windows.Navigation.NavigationService.NavigationFailed>.  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowNavigationFailedCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindownavigationfailedcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowNavigationFailedCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindownavigationfailedcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Navigation.NavigationService.FragmentNavigation" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigating" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigated" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.LoadCompleted" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationProgress" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationStopped" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Refresh" />
      </Docs>
    </Member>
    <Member MemberName="NavigationProgress">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationProgressEventHandler NavigationProgress;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationProgressEventHandler NavigationProgress" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Navigation.NavigationService.NavigationProgress" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event NavigationProgress As NavigationProgressEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigationProgressEventHandler ^ NavigationProgress;" />
      <MemberSignature Language="F#" Value="member this.NavigationProgress : System.Windows.Navigation.NavigationProgressEventHandler " Usage="member this.NavigationProgress : System.Windows.Navigation.NavigationProgressEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationProgressEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt regelmäßig während eines Downloadvorgangs auf, um Informationen zum Navigationsstatus bereitzustellen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationService.NavigationProgress> Übergeben einer <xref:System.Windows.Navigation.NavigationProgressEventArgs> die folgenden Statusinformationen verfügbar macht:  
  
-   Anzahl der heruntergeladenen Bytes bisher (<xref:System.Windows.Navigation.NavigationProgressEventArgs.BytesRead%2A>).  
  
-   Gesamtanzahl von Byte heruntergeladen (<xref:System.Windows.Navigation.NavigationProgressEventArgs.MaxBytes%2A>).  
  
 <xref:System.Windows.Navigation.NavigationService.NavigationProgress> wird ausgelöst, nachdem für alle 1024 Bytes der Inhalt heruntergeladen und ein weiteres Mal, wenn die Anzahl der verbleibenden Bytes kleiner als 1024 Bytes ist. Aus diesem Grund behandeln <xref:System.Windows.Navigation.NavigationService.NavigationProgress> ist eine gute Möglichkeit zum Nachverfolgen und den Status eines aktuellen Downloads anzeigen.  
  
 <xref:System.Windows.Navigation.NavigationService.NavigationProgress> wird nicht ausgelöst werden, in einigen Fällen, z. B. wenn das gleiche Element Inhalt navigiert wird, oder bei der Navigation zu einem Inhaltsfragment auf Inhalte, die derzeit geladen wird (d. h., der Wert von der <xref:System.Windows.Navigation.NavigationService.Content%2A> Eigenschaft).  
  
 Beim Navigieren zu einer kompilierten XAML-Ressource, die endgültige <xref:System.Windows.Navigation.NavigationService.NavigationProgress> -Ereignis kann nicht ausgelöst werden. Dies bedeutet, dass am Ende des Downloads, die zuletzt gemeldete <xref:System.Windows.Navigation.NavigationProgressEventArgs.BytesRead%2A> Wert möglicherweise nicht gleich der <xref:System.Windows.Navigation.NavigationProgressEventArgs.MaxBytes%2A> Wert. Behandeln der <xref:System.Windows.Navigation.NavigationService.LoadCompleted> Ereignis benachrichtigt werden, wenn die Navigation abgeschlossen ist.  
  
> [!NOTE]
>  Wenn <xref:System.Windows.Navigation.NavigationService> löst <xref:System.Windows.Navigation.NavigationService.NavigationProgress>, sie löst ebenfalls <xref:System.Windows.Application.NavigationProgress?displayProperty=nameWithType> Ereignis auf der <xref:System.Windows.Application> Objekt.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie behandelt <xref:System.Windows.Navigation.NavigationService.NavigationProgress>.  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowNavigationProgressCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindownavigationprogresscode)]
 [!code-vb[NavigationServiceSnippets#MainWindowNavigationProgressCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindownavigationprogresscode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Navigation.NavigationService.FragmentNavigation" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigating" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigated" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.LoadCompleted" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationStopped" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationFailed" />
      </Docs>
    </Member>
    <Member MemberName="NavigationStopped">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationStoppedEventHandler NavigationStopped;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationStoppedEventHandler NavigationStopped" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Navigation.NavigationService.NavigationStopped" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event NavigationStopped As NavigationStoppedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigationStoppedEventHandler ^ NavigationStopped;" />
      <MemberSignature Language="F#" Value="member this.NavigationStopped : System.Windows.Navigation.NavigationStoppedEventHandler " Usage="member this.NavigationStopped : System.Windows.Navigation.NavigationStoppedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationStoppedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn die <see cref="M:System.Windows.Navigation.NavigationService.StopLoading" />-Methode aufgerufen wird oder wenn eine neue Navigation angefordert wird, während eine aktuelle Navigation noch ausgeführt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie behandeln <xref:System.Windows.Navigation.NavigationService.NavigationStopped> Wenn müssen Sie relevante Informationen in Bezug auf die navigationsanforderung ermitteln, wenn der Download beendet wurde. Diese Informationen sind verfügbar, aus der <xref:System.Windows.Navigation.NavigationEventArgs> -Objekt, das an die <xref:System.Windows.Navigation.NavigationService.NavigationStopped> -Ereignishandler und enthält:  
  
-   Der angeforderte URI.  
  
-   Der Navigator (<xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>).  
  
-   Zusätzliche Daten, wenn die Navigation initiiert wurde, durch Aufrufen von entweder <xref:System.Windows.Navigation.NavigationService.Navigate%2A?displayProperty=nameWithType> oder <xref:System.Windows.Navigation.NavigationService.Navigate%2A?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Wenn <xref:System.Windows.Navigation.NavigationService> löst <xref:System.Windows.Navigation.NavigationService.NavigationStopped>, sie löst ebenfalls <xref:System.Windows.Application.NavigationStopped?displayProperty=nameWithType> Ereignis auf der <xref:System.Windows.Application> Objekt.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie behandelt <xref:System.Windows.Navigation.NavigationService.NavigationStopped>.  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowNavigationStoppedCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindownavigationstoppedcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowNavigationStoppedCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindownavigationstoppedcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Navigation.NavigationService.FragmentNavigation" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigating" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigated" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.LoadCompleted" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationProgress" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationFailed" />
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh();" />
      <MemberSignature Language="F#" Value="member this.Refresh : unit -&gt; unit" Usage="navigationService.Refresh " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lädt den aktuellen Inhalt erneut.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der aktuelle Inhalt (durch den Wert der angegebenen die <xref:System.Windows.Navigation.NavigationService.Source%2A> Eigenschaft) navigiert wird in diesem Fall <xref:System.Windows.Navigation.NavigationService> wird den Inhalt nicht erneut heruntergeladen. Um zu erzwingen <xref:System.Windows.Navigation.NavigationService> aufrufen, um auf den Inhalt erneut zu navigieren, <xref:System.Windows.Navigation.NavigationService.Refresh%2A>.  
  
 Beachten Sie, dass der aktuelle Inhalt in diesem Fall navigiert wird durch Aufrufen von <xref:System.Windows.Navigation.NavigationService.Navigate%2A> oder <xref:System.Windows.Navigation.NavigationService.Refresh%2A>, ein neuer Eintrag wird dem Navigationsverlauf nicht hinzugefügt.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigating" />
      </Docs>
    </Member>
    <Member MemberName="RemoveBackEntry">
      <MemberSignature Language="C#" Value="public System.Windows.Navigation.JournalEntry RemoveBackEntry ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Navigation.JournalEntry RemoveBackEntry() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.RemoveBackEntry" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveBackEntry () As JournalEntry" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Navigation::JournalEntry ^ RemoveBackEntry();" />
      <MemberSignature Language="F#" Value="member this.RemoveBackEntry : unit -&gt; System.Windows.Navigation.JournalEntry" Usage="navigationService.RemoveBackEntry " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.JournalEntry</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Entfernt den letzten Journaleintrag aus dem Verlauf zurück.</summary>
        <returns>Der letzte <see cref="T:System.Windows.Navigation.JournalEntry" /> im Navigationsverlauf zurück, sofern dieser vorhanden ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn zwei oder mehrere Navigatoren (<xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>) denselben Navigationsverlauf freigeben, kann von einem Navigator <xref:System.Windows.Navigation.NavigationService.RemoveBackEntry%2A> der Eintrag im Navigationsverlauf zurück für die eine Navigation abgerufen, die in einem anderen Navigator stattgefunden.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Navigation.NavigationService.AddBackEntry(System.Windows.Navigation.CustomContentState)" />
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public Uri Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri Source" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Navigation.NavigationService.Source" />
      <MemberSignature Language="VB.NET" Value="Public Property Source As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ Source { Uri ^ get(); void set(Uri ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Source : Uri with get, set" Usage="System.Windows.Navigation.NavigationService.Source" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den URI des aktuellen Inhalts oder den URI des neuen Inhalts ab, zu dem zurzeit navigiert wird, oder legt diesen fest.</summary>
        <value>Ein <see cref="T:System.Uri" /> , enthält den URI für den aktuellen Inhalt oder den Inhalt, der auf dem zurzeit navigiert wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie diese Eigenschaft auf einen anderen URI als die gerade angezeigt wird, den Navigator festlegen (<xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>) an den angegebenen URI navigiert.  
  
 <xref:System.Windows.Navigation.NavigationService.Source%2A> wird auf den Inhalt festgelegt, die geladen wird, aus dem URI, zu dem navigiert wird, es sei denn, die Navigation nicht abgebrochen wird.  
  
 <xref:System.Windows.Navigation.NavigationService.Source%2A> kann mit einem nur-Fragment-URI festgelegt werden, und kann so festgelegt werden `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StopLoading">
      <MemberSignature Language="C#" Value="public void StopLoading ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void StopLoading() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.StopLoading" />
      <MemberSignature Language="VB.NET" Value="Public Sub StopLoading ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void StopLoading();" />
      <MemberSignature Language="F#" Value="member this.StopLoading : unit -&gt; unit" Usage="navigationService.StopLoading " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Bricht das weitere Herunterladen von Inhalt für die aktuelle Navigationsanforderung ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationService.StopLoading%2A> kann aufgerufen werden, sobald <xref:System.Windows.Navigation.NavigationService.Navigate%2A> zurückgibt und Navigation, die in untergeordneten Rahmen wird beendet.  
  
 (<xref:System.Windows.Controls.Frame>).  
  
 Aufrufen der <xref:System.Windows.Navigation.NavigationService.StopLoading%2A> -Methode löst die <xref:System.Windows.Navigation.NavigationService.NavigationStopped> Ereignis.  
  
> [!NOTE]
>  <xref:System.Windows.Navigation.NavigationService.StopLoading%2A> muss auf dem gleichen Thread aufgerufen werden, die die Navigation initiiert hat.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht das Laden beenden.  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowStopLoadingCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindowstoploadingcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowStopLoadingCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindowstoploadingcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Windows.Navigation.NavigationService.Navigate" />
      </Docs>
    </Member>
  </Members>
</Type>