<Type Name="ArrayPool&lt;T&gt;" FullName="System.Buffers.ArrayPool&lt;T&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="0cd4416c419b70f301ca33ef17107cf4f059b502" /><Meta Name="ms.sourcegitcommit" Value="a3e01ec36374fac54a55add0dcc1e754e394abeb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="03/30/2019" /><Meta Name="ms.locfileid" Value="58722640" /></Metadata><TypeSignature Language="C#" Value="public abstract class ArrayPool&lt;T&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit ArrayPool`1&lt;T&gt; extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Buffers.ArrayPool`1" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ArrayPool(Of T)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public ref class ArrayPool abstract" />
  <TypeSignature Language="F#" Value="type ArrayPool&lt;'T&gt; = class" />
  <AssemblyInfo>
    <AssemblyName>System.Buffers</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <typeparam name="T">Der Typ der Objekte, die im Ressourcenpool.</typeparam>
    <summary>Stellt einen Ressourcenpool bereit, der die Wiederverwendung von Instanzen des Typs <see cref="T:T[]" /> erlaubt</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
 Mithilfe der <xref:System.Buffers.ArrayPool%601> Klasse mieten und Zurückgeben von Puffern (mithilfe der <xref:System.Buffers.ArrayPool%601.Rent%2A> und <xref:System.Buffers.ArrayPool%601.Return%2A> Methoden) kann die Leistung in Situationen, in denen Arrays erstellt und zerstört wird häufig, verbessert, was erhebliche hohe speicherauslastung auf dem Garbage Collector.
  
 ]]></format>
    </remarks>
    <threadsafe>Diese Klasse ist threadsicher. Alle Member können von mehreren Threads gleichzeitig verwendet werden.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ArrayPool ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.ArrayPool`1.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ArrayPool();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Buffers</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Buffers.ArrayPool`1" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
Beachten Sie, dass dieser Konstruktor ist geschützt. Es kann nur von abgeleiteten Klassen aufgerufen werden die <xref:System.Buffers.ArrayPool%601> Klasse. 
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Buffers.ArrayPool&lt;T&gt; Create ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Buffers.ArrayPool`1&lt;!T&gt; Create() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.ArrayPool`1.Create" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create () As ArrayPool(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Buffers::ArrayPool&lt;T&gt; ^ Create();" />
      <MemberSignature Language="F#" Value="static member Create : unit -&gt; System.Buffers.ArrayPool&lt;'T&gt;" Usage="System.Buffers.ArrayPool&lt;'T&gt;.Create " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Buffers</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Buffers.ArrayPool&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt eine neue Instanz der <see cref="T:System.Buffers.ArrayPool`1" />-Klasse.</summary>
        <returns>Eine neue Instanz der <see cref="T:System.Buffers.ArrayPool`1" />-Klasse.</returns>
        <remarks></remarks>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Buffers.ArrayPool&lt;T&gt; Create (int maxArrayLength, int maxArraysPerBucket);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Buffers.ArrayPool`1&lt;!T&gt; Create(int32 maxArrayLength, int32 maxArraysPerBucket) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.ArrayPool`1.Create(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (maxArrayLength As Integer, maxArraysPerBucket As Integer) As ArrayPool(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Buffers::ArrayPool&lt;T&gt; ^ Create(int maxArrayLength, int maxArraysPerBucket);" />
      <MemberSignature Language="F#" Value="static member Create : int * int -&gt; System.Buffers.ArrayPool&lt;'T&gt;" Usage="System.Buffers.ArrayPool&lt;'T&gt;.Create (maxArrayLength, maxArraysPerBucket)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Buffers</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Buffers.ArrayPool&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxArrayLength" Type="System.Int32" />
        <Parameter Name="maxArraysPerBucket" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="maxArrayLength">Die maximale Länge einer Instanz des Arrays, die im Pool gespeichert werden kann.</param>
        <param name="maxArraysPerBucket">Die maximale Anzahl von Instanzen eines Arrays, die in jedem Bucket im Pool gespeichert werden kann. Für einen schnelleren Zugriff gruppiert der Pool Arrays von unterschiedlicher Länge in Buckets.</param>
        <summary>Erstellt eine neue Instanz der <see cref="T:System.Buffers.ArrayPool`1" />-Klasse mit der angegebenen Konfiguration.</summary>
        <returns>Eine neue Instanz der <see cref="T:System.Buffers.ArrayPool`1" />-Klasse mit dem angegebenen Konfigurationsnamen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
Die Instanz von der <xref:System.Buffers.ArrayPool%601> Klasse, die von dieser Methode erstellte gruppiert Arrays in Buckets, ohne mehr als `maxArraysPerBucket` in jedem Bucket, und klicken Sie mit diesen Arrays nicht überschreiten `maxArrayLength` umfassen.
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rent">
      <MemberSignature Language="C#" Value="public abstract T[] Rent (int minimumLength);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance !T[] Rent(int32 minimumLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.ArrayPool`1.Rent(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Rent (minimumLength As Integer) As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;T&gt; ^ Rent(int minimumLength);" />
      <MemberSignature Language="F#" Value="abstract member Rent : int -&gt; 'T[]" Usage="arrayPool.Rent minimumLength" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Buffers</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="minimumLength" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="minimumLength">Die minimale Länge des Arrays.</param>
        <summary>Ruft einen Puffer ab, der die erforderliche Mindestlänge aufweist.</summary>
        <returns>Ein Array vom Typ <see cref="T:T[]" />, das mindestens <paramref name="minimumLength" /> lang ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Dieser Puffer wird an den Aufrufer ausgeliehen und zurückgegeben werden sollen, auf dem gleichen Pool unter Verwendung der <xref:System.Buffers.ArrayPool%601.Return%2A> Methode, sodass die It bei nachfolgenden Aufrufen wiederverwendet werden kann die <xref:System.Buffers.ArrayPool%601.Rent%2A> Methode. Fehler bei der ein gepachteten Puffer zurückgegeben ist kein schwerwiegender Fehler. Allerdings kann auf die Anwendungsleistung verringert, führen wie der Pool möglicherweise erstellen Sie einen neuen Puffer ersetzt die verloren gehen.
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Return">
      <MemberSignature Language="C#" Value="public abstract void Return (T[] array, bool clearArray = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Return(!T[] array, bool clearArray) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.ArrayPool`1.Return(`0[],System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub Return (array As T(), Optional clearArray As Boolean = false)" />
      <MemberSignature Language="F#" Value="abstract member Return : 'T[] * bool -&gt; unit" Usage="arrayPool.Return (array, clearArray)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Buffers</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="clearArray" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="array">Ein Puffer, der dem Pool zurückgegeben werden soll, der zuvor mithilfe der <see cref="M:System.Buffers.ArrayPool`1.Rent(System.Int32)" />-Methode abgerufen wurde.</param>
        <param name="clearArray">Gibt an, ob die Inhalte des Puffers vor der Wiederverwendung gelöscht werden sollen. Wenn <paramref name="clearArray" /> auf <see langword="true" /> festgelegt ist, und wenn der Pool den Puffer für eine weitere Wiederverwendung speichert, löscht die Methode <see cref="M:System.Buffers.ArrayPool`1.Return(`0[],System.Boolean)" /> die Inhalte des <paramref name="array" />-Objekts, sodass der folgende Aufrufer, der die <see cref="M:System.Buffers.ArrayPool`1.Rent(System.Int32)" />-Methode verwendet, den Inhalt des vorherigen Aufrufers nicht sieht. Wenn <paramref name="clearArray" /> auf <see langword="false" /> festgelegt ist, oder wenn der Pool den Puffer freigibt, bleiben die Inhalte des Arrays unverändert.</param>
        <summary>Ein Array wird dem Pool zurückgegeben, das zuvor mithilfe der <see cref="M:System.Buffers.ArrayPool`1.Rent(System.Int32)" />-Methode auf der gleichen <see cref="T:System.Buffers.ArrayPool`1" />-Instanz abgerufen wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Nachdem Sie ein Puffer an den Pool zurückgegeben wurde, kann der Aufrufer gibt alle den Besitz des Puffers und muss nicht verwenden. Der Verweis zurückgegeben wird, über einen Aufruf der <xref:System.Buffers.ArrayPool%601.Rent%2A> Methode muss nur zurückgegeben werden, mithilfe der <xref:System.Buffers.ArrayPool%601.Return%2A> -Methode einmal. Der Standardwert <xref:System.Buffers.ArrayPool%601> möglicherweise daran Festhalten der zurückgegebene Puffer um Mieten ihn dann erneut, oder er kann frei, den zurückgegebenen Puffer Wenn festgestellt wird, der Pool bereits genügend Puffer gespeichert hat.
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shared">
      <MemberSignature Language="C#" Value="public static System.Buffers.ArrayPool&lt;T&gt; Shared { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Buffers.ArrayPool`1&lt;!T&gt; Shared" />
      <MemberSignature Language="DocId" Value="P:System.Buffers.ArrayPool`1.Shared" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Shared As ArrayPool(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Buffers::ArrayPool&lt;T&gt; ^ Shared { System::Buffers::ArrayPool&lt;T&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Shared : System.Buffers.ArrayPool&lt;'T&gt;" Usage="System.Buffers.ArrayPool&lt;'T&gt;.Shared" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Buffers</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Buffers.ArrayPool&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine freigegebene <see cref="T:System.Buffers.ArrayPool`1" />-Instanz ab.</summary>
        <value>Eine freigegebene <see cref="T:System.Buffers.ArrayPool`1" /> Instanz.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Der freigegebene Pool stellt eine Standardimplementierung von der <xref:System.Buffers.ArrayPool%601> -Klasse, die für die allgemeine Anwendbarkeit vorgesehen ist. Eine freigegebene Klasse verwaltet Arrays mit mehreren Größen und möglicherweise übergeben wieder ein größeres Array als angefordert wurde, aber es wird nie übergeben wieder ein kleineres Array als angefordert wurden. Rackplatz einen Puffer über eine gemeinsam genutzte Klasse mit dem <xref:System.Buffers.ArrayPool%601.Rent%2A> Methode führt dazu, in einem vorhandenen Puffer aus dem Pool ausgeführt wird, wenn es sich bei ein entsprechenden Puffer verfügbar ist oder in einem neuen Puffer zugeordnet werden, wenn eine nicht verfügbar ist.
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>