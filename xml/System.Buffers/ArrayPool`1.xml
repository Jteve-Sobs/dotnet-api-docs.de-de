<Type Name="ArrayPool&lt;T&gt;" FullName="System.Buffers.ArrayPool&lt;T&gt;">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="924af3bcdfd42b06e9a7eaf3e33460653c01b53b" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30359614" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class ArrayPool&lt;T&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit ArrayPool`1&lt;T&gt; extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Buffers.ArrayPool`1" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ArrayPool(Of T)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public ref class ArrayPool abstract" />
  <AssemblyInfo>
    <AssemblyName>System.Buffers</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <typeparam name="T">Der Typ der Objekte, die im Ressourcenpool sind.</typeparam>
    <summary>Stellt einen Ressourcenpool bereit, der die Wiederverwendung von Instanzen des Typs <see cref="T:T[]" /> erlaubt</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
 Mithilfe der <xref:System.Buffers.ArrayPool%601> Klasse zu vermieten und Zurückgeben von Puffern (mithilfe der <xref:System.Buffers.ArrayPool%601.Rent%2A> und <xref:System.Buffers.ArrayPool%601.Return%2A> Methoden) kann die Leistung in Situationen, in denen Arrays erstellt und zerstört häufig, verbessern, was Belastung für den Arbeitsspeicher auf dem Garbage Collector.
  
 ]]></format>
    </remarks>
    <threadsafe>Diese Klasse ist threadsicher. Alle Member können von mehreren Threads gleichzeitig verwendet werden.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ArrayPool ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.ArrayPool`1.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ArrayPool();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Buffers</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Buffers.ArrayPool`1" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
Beachten Sie, dass dieser Konstruktor ist geschützt. Es kann nur von von abgeleiteten Klassen aufgerufen werden der <xref:System.Buffers.ArrayPool%601> Klasse. 
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Buffers.ArrayPool&lt;T&gt; Create ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Buffers.ArrayPool`1&lt;!T&gt; Create() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.ArrayPool`1.Create" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create () As ArrayPool(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Buffers::ArrayPool&lt;T&gt; ^ Create();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Buffers</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Buffers.ArrayPool&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt eine neue Instanz der <see cref="T:System.Buffers.ArrayPool`1" />-Klasse.</summary>
        <returns>Eine neue Instanz der <see cref="T:System.Buffers.ArrayPool`1" />-Klasse.</returns>
        <remarks></remarks>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Buffers.ArrayPool&lt;T&gt; Create (int maxArrayLength, int maxArraysPerBucket);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Buffers.ArrayPool`1&lt;!T&gt; Create(int32 maxArrayLength, int32 maxArraysPerBucket) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.ArrayPool`1.Create(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (maxArrayLength As Integer, maxArraysPerBucket As Integer) As ArrayPool(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Buffers::ArrayPool&lt;T&gt; ^ Create(int maxArrayLength, int maxArraysPerBucket);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Buffers</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Buffers.ArrayPool&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxArrayLength" Type="System.Int32" />
        <Parameter Name="maxArraysPerBucket" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="maxArrayLength">Die maximale Länge einer Instanz des Arrays, die im Pool gespeichert werden kann.</param>
        <param name="maxArraysPerBucket">Die maximale Anzahl von Instanzen eines Arrays, die in jedem Bucket im Pool gespeichert werden kann. Für einen schnelleren Zugriff gruppiert der Pool Arrays von unterschiedlicher Länge in Buckets.</param>
        <summary>Erstellt eine neue Instanz der <see cref="T:System.Buffers.ArrayPool`1" />-Klasse mit der angegebenen Konfiguration.</summary>
        <returns>Eine neue Instanz der <see cref="T:System.Buffers.ArrayPool`1" />-Klasse mit dem angegebenen Konfigurationsnamen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
Die Instanz von der <xref:System.Buffers.ArrayPool%601> Klasse, die von dieser Methode erstellt werden Arrays in Buckets gruppieren und ohne mehr als `maxArraysPerBucket` in einem Bucket, und klicken Sie mit diesen Arrays nicht überschreiten `maxArrayLength` lang.
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rent">
      <MemberSignature Language="C#" Value="public abstract T[] Rent (int minimumLength);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance !T[] Rent(int32 minimumLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.ArrayPool`1.Rent(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Rent (minimumLength As Integer) As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;T&gt; ^ Rent(int minimumLength);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Buffers</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="minimumLength" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="minimumLength">Die minimale Länge des Arrays.</param>
        <summary>Ruft einen Puffer ab, der die erforderliche Mindestlänge aufweist.</summary>
        <returns>Ein Array vom Typ <see cref="T:T[]" />, das mindestens <paramref name="minimumLength" /> lang ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Dieser Puffer wird an den Aufrufer ausgeliehen und zurückgegeben werden soll, auf dem gleichen Pool unter Verwendung der <xref:System.Buffers.ArrayPool%601.Return%2A> Methode, sodass die It in nachfolgenden Aufrufen wiederverwendet werden kann die <xref:System.Buffers.ArrayPool%601.Rent%2A> Methode. Fehler zurückzugebenden gepachteten Puffer ist nicht schwerwiegender Fehler. Es kann jedoch für eine eine verringerte Anwendungsleistung, führen, wie der Pool möglicherweise erstellen Sie einen neuen Puffer um verlorene zu ersetzen.
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Return">
      <MemberSignature Language="C#" Value="public abstract void Return (T[] array, bool clearArray = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Return(!T[] array, bool clearArray) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.ArrayPool`1.Return(`0[],System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub Return (array As T(), Optional clearArray As Boolean = false)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Buffers</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="clearArray" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="array">Ein Puffer, der dem Pool zurückgegeben werden soll, der zuvor mithilfe der <see cref="M:System.Buffers.ArrayPool`1.Rent(System.Int32)" />-Methode abgerufen wurde.</param>
        <param name="clearArray">Gibt an, ob die Inhalte des Puffers vor der Wiederverwendung gelöscht werden sollen. Wenn <paramref name="clearArray" /> auf <see langword="true" /> festgelegt ist, und wenn der Pool den Puffer für eine weitere Wiederverwendung speichert, löscht die Methode <see cref="M:System.Buffers.ArrayPool`1.Return(`0[],System.Boolean)" /> die Inhalte des <paramref name="array" />-Objekts, sodass der folgende Aufrufer, der die <see cref="M:System.Buffers.ArrayPool`1.Rent(System.Int32)" />-Methode verwendet, den Inhalt des vorherigen Aufrufers nicht sieht. Wenn <paramref name="clearArray" /> auf <see langword="false" /> festgelegt ist, oder wenn der Pool den Puffer freigibt, bleiben die Inhalte des Arrays unverändert.</param>
        <summary>Ein Array wird dem Pool zurückgegeben, das zuvor mithilfe der <see cref="M:System.Buffers.ArrayPool`1.Rent(System.Int32)" />-Methode auf der gleichen <see cref="T:System.Buffers.ArrayPool`1" />-Instanz abgerufen wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Nachdem Sie ein Puffer an den Pool zurückgegeben wurde, kann der Aufrufer aufgibt alle den Besitz des Puffers und muss nicht verwenden. Der Verweis zurückgegeben wird, über einen Aufruf der <xref:System.Buffers.ArrayPool%601.Rent%2A> -Methode muss nur zurückgegeben werden, mithilfe der <xref:System.Buffers.ArrayPool%601.Return%2A> -Methode einmal. Die Standardeinstellung <xref:System.Buffers.ArrayPool%601> möglicherweise daran Festhalten der zurückgegebene Puffer um vermieten erneut, oder es kann freigeben den zurückgegebenen Puffer, wenn feststellbar ist, dass der Pool bereits ausreichend Puffer gespeichert ist.
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shared">
      <MemberSignature Language="C#" Value="public static System.Buffers.ArrayPool&lt;T&gt; Shared { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Buffers.ArrayPool`1&lt;!T&gt; Shared" />
      <MemberSignature Language="DocId" Value="P:System.Buffers.ArrayPool`1.Shared" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Shared As ArrayPool(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Buffers::ArrayPool&lt;T&gt; ^ Shared { System::Buffers::ArrayPool&lt;T&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Buffers</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Buffers.ArrayPool&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine freigegebene <see cref="T:System.Buffers.ArrayPool`1" />-Instanz ab.</summary>
        <value>Eine freigegebene <see cref="T:System.Buffers.ArrayPool`1" /> Instanz.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Der freigegebene Pool stellt eine Standardimplementierung von der <xref:System.Buffers.ArrayPool%601> -Klasse, die für die allgemeine Anwendbarkeit vorgesehen ist. Eine gemeinsam genutzte Klasse verwaltet Arrays mit verschiedenen Größen und möglicherweise weiter wieder ein größeres Array als angefordert wurde, aber es wird nie manuell wieder eine kleinere Array als angefordert wurde. Mieten einen Puffer mit einer freigegebenen Klasse unter Verwendung der <xref:System.Buffers.ArrayPool%601.Rent%2A> Methode führt zu einem vorhandenen Puffer aus dem Pool entnommen werden, falls ein geeigneter Puffer verfügbar ist oder in ein neuer Puffer reserviert werden, wenn mindestens eine nicht verfügbar ist.
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>