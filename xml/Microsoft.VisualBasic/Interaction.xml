<Type Name="Interaction" FullName="Microsoft.VisualBasic.Interaction">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="066f5d18bb6954443ddf00f4507b470f32e1e4c6" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36658805" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Interaction" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Interaction extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.VisualBasic.Interaction" />
  <TypeSignature Language="VB.NET" Value="Public Module Interaction" />
  <TypeSignature Language="C++ CLI" Value="public ref class Interaction sealed" />
  <TypeSignature Language="F#" Value="type Interaction = class" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic</AssemblyName>
    <AssemblyVersion>10.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>Microsoft.VisualBasic.CompilerServices.StandardModule</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Das <see langword="Interaction" />-Modul enthält Prozeduren für die Interaktion mit Objekten, Anwendungen und Systemen.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Modul unterstützt die Visual Basic-Schlüsselwörter und Laufzeit-Bibliothekscode-Elemente, die andere Programme auszuführen, rufen eine Methode oder Eigenschaft Ausgeben eines akustischen Signals auf dem Computer, eine Befehlszeile-Zeichenfolge angeben, Bearbeiten von COM-Objekten und Steuern von Dialogfeldern.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die `Shell` Funktion zum Ausführen einer Anwendung, die vom Benutzer angegeben wird. Angeben von <xref:Microsoft.VisualBasic.AppWinStyle.NormalFocus?displayProperty=nameWithType> als zweites Argument wird die Anwendung in Normalgröße geöffnet und der Fokus.  
  
```vb  
Dim procID As Integer  
' Run calculator.  
procID = Shell("C:\Windows\system32\calc.exe", AppWinStyle.NormalFocus)  
' The preceding path is for Windows XP.  
' The Windows 2000 path is C:\WINNT\system32\calc.exe.  
```  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName="AppActivate">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Aktiviert eine Anwendung, die bereits ausgeführt wird.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppActivate">
      <MemberSignature Language="C#" Value="public static void AppActivate (int ProcessId);" />
      <MemberSignature Language="ILAsm" Value=".method public static void AppActivate(int32 ProcessId) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.AppActivate(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppActivate (ProcessId As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AppActivate(int ProcessId);" />
      <MemberSignature Language="F#" Value="static member AppActivate : int -&gt; unit" Usage="Microsoft.VisualBasic.Interaction.AppActivate ProcessId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ProcessId" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ProcessId">
          <see langword="Integer" /> zum Angeben der diesem Prozess zugewiesene Win32-Prozess-ID. Sie können die von der <see cref="M:Microsoft.VisualBasic.Interaction.Shell(System.String,Microsoft.VisualBasic.AppWinStyle,System.Boolean,System.Int32)" /> zurückgegebene ID verwenden, sofern diese nicht 0 (null) ist.</param>
        <summary>Aktiviert eine Anwendung, die bereits ausgeführt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie `AppActivate` um aktive Fenster einer Anwendung in den Fokus zu bringen. Sie möglicherweise kein Handle oder ein Verweis auf das aktive Fenster, oder auch wissen, welches Fenster zu einem bestimmten Zeitpunkt aktiv ist. In diesem Fall können keine der <xref:System.Windows.Forms.Control.Focus%2A> Methode.  
  
 Die `AppActivate` -Funktion verschiebt den Fokus auf die genannte Anwendung oder das Fenster aber wirkt sich nicht, ob es maximiert oder minimiert wird. Fokus wechselt Weg von den aktivierter Anwendungsfenster, wenn der Benutzer eine Aktion ändern den Fokus oder das Fenster zu schließen. Sie können die `Shell` Funktion zum Starten einer Anwendung, und legen den Fensterstil.  
  
 Bei Verwendung der `Title` Parameter `AppActivate` verwendet einen Vergleich Groß-/Kleinschreibung jedoch andernfalls erfordert eine genaue Übereinstimmung mit dem Inhalt der Titelleiste. Es wird zunächst über das Fenster auf oberster Ebene und dann die untergeordneten Fenster. Wenn es keine Übereinstimmung gefunden, löst sie eine <xref:System.ArgumentException>.  
  
 Sie können `AppActivate` nur mit Prozessen, die Windows besitzen. Die meisten konsolenanwendungen besitzen keine Windows, d. h., die sie in der Liste der nicht angezeigt werden, verarbeitet `AppActivate` sucht. Wenn von einer Konsolenanwendung ausgeführt wird, wird das System erstellt einen separaten Prozess, um die Anwendung auszuführen und die Ausgabe an den Konsolenprozess zurückgegeben. Daher, wenn Sie die aktuellen Prozess-ID anfordern, erhalten Sie die Prozess-ID, der diese separaten Prozess, anstatt die Konsolenanwendung Prozess-ID.  
  
 Zur Laufzeit die `AppActivate` Funktion aktiviert alle ausgeführten Anwendung mit einem Titel, entspricht `Title` oder mit einem Prozess-ID, entspricht `ProcessId`. Wenn keine genaue Übereinstimmung vorhanden ist, wird jede Anwendung, deren Titelzeichenfolge endet mit, aktiviert `Title`. Wenn mehr als eine Anwendung mit dem Namen `Title`die `AppActivate` Funktion einer aktivieren, nach dem Zufallsprinzip ausgewählt.  
  
> [!NOTE]
>  Die `AppActivate` -Funktion erfordert `UIPermission` an die <xref:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows> Ebene auf, die sich möglicherweise auf ihre Ausführung in teilweise vertrauenswürdigen Umgebungen auswirken. Weitere Informationen finden Sie unter <xref:System.Security.Permissions.UIPermission>.  
  
   
  
## Examples  
 Dieses Beispiel zeigt verschiedene Verwendungsmöglichkeiten der der `AppActivate` Funktion, um ein Anwendungsfenster aktivieren. Wenn kein Editor-Prozess nicht ausgeführt wird, löst das Beispiel ein <xref:System.ArgumentException>. Die `Shell` Verfahren wird davon ausgegangen, die Anwendungen, die in den Pfaden, die angegeben sind.  
  
 [!code-vb[VbVbalrCatRef#11](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.Shell(System.String,Microsoft.VisualBasic.AppWinStyle,System.Boolean,System.Int32)" />
        <altmember cref="M:System.Windows.Forms.Control.Focus" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <Member MemberName="AppActivate">
      <MemberSignature Language="C#" Value="public static void AppActivate (string Title);" />
      <MemberSignature Language="ILAsm" Value=".method public static void AppActivate(string Title) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.AppActivate(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppActivate (Title As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AppActivate(System::String ^ Title);" />
      <MemberSignature Language="F#" Value="static member AppActivate : string -&gt; unit" Usage="Microsoft.VisualBasic.Interaction.AppActivate Title" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Title" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Title">
          <see langword="String" />-Ausdruck, der den Titel auf der Titelleiste der Anwendung angibt, die Sie aktivieren möchten. Sie können den der Anwendung beim Start zugewiesenen Titel verwenden.</param>
        <summary>Aktiviert eine Anwendung, die bereits ausgeführt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie `AppActivate` um aktive Fenster einer Anwendung in den Fokus zu bringen. Sie möglicherweise kein Handle oder ein Verweis auf das aktive Fenster, oder auch wissen, welches Fenster zu einem bestimmten Zeitpunkt aktiv ist. In diesem Fall können keine der <xref:System.Windows.Forms.Control.Focus%2A> Methode.  
  
 Die `AppActivate` -Funktion verschiebt den Fokus auf die genannte Anwendung oder das Fenster aber wirkt sich nicht, ob es maximiert oder minimiert wird. Fokus wechselt Weg von den aktivierter Anwendungsfenster, wenn der Benutzer eine Aktion ändern den Fokus oder das Fenster zu schließen. Sie können die `Shell` Funktion zum Starten einer Anwendung, und legen den Fensterstil.  
  
 Bei Verwendung der `Title` Parameter `AppActivate` verwendet einen Vergleich Groß-/Kleinschreibung jedoch andernfalls erfordert eine genaue Übereinstimmung mit dem Inhalt der Titelleiste. Es wird zunächst über das Fenster auf oberster Ebene und dann die untergeordneten Fenster. Wenn es keine Übereinstimmung gefunden, löst sie eine <xref:System.ArgumentException>.  
  
 Sie können `AppActivate` nur mit Prozessen, die Windows besitzen. Die meisten konsolenanwendungen besitzen keine Windows, d. h., die sie in der Liste der nicht angezeigt werden, verarbeitet `AppActivate` sucht. Wenn von einer Konsolenanwendung ausgeführt wird, wird das System erstellt einen separaten Prozess, um die Anwendung auszuführen und die Ausgabe an den Konsolenprozess zurückgegeben. Daher, wenn Sie die aktuellen Prozess-ID anfordern, erhalten Sie die Prozess-ID, der diese separaten Prozess, anstatt die Konsolenanwendung Prozess-ID.  
  
 Zur Laufzeit die `AppActivate` Funktion aktiviert alle ausgeführten Anwendung mit einem Titel, entspricht `Title` oder mit einem Prozess-ID, entspricht `ProcessId`. Wenn keine genaue Übereinstimmung vorhanden ist, wird jede Anwendung, deren Titelzeichenfolge endet mit, aktiviert `Title`. Wenn mehr als eine Anwendung mit dem Namen `Title`die `AppActivate` Funktion einer aktivieren, nach dem Zufallsprinzip ausgewählt.  
  
> [!NOTE]
>  Die `AppActivate` -Funktion erfordert `UIPermission` an die <xref:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows> Ebene auf, die sich möglicherweise auf ihre Ausführung in teilweise vertrauenswürdigen Umgebungen auswirken. Weitere Informationen finden Sie unter <xref:System.Security.Permissions.UIPermission>.  
  
   
  
## Examples  
 Dieses Beispiel zeigt verschiedene Verwendungsmöglichkeiten der der `AppActivate` Funktion, um ein Anwendungsfenster aktivieren. Wenn kein Editor-Prozess nicht ausgeführt wird, löst das Beispiel ein <xref:System.ArgumentException>. Die `Shell` Verfahren wird davon ausgegangen, die Anwendungen, die in den Pfaden, die angegeben sind.  
  
 [!code-vb[VbVbalrCatRef#11](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.Shell(System.String,Microsoft.VisualBasic.AppWinStyle,System.Boolean,System.Int32)" />
        <altmember cref="M:System.Windows.Forms.Control.Focus" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <Member MemberName="Beep">
      <MemberSignature Language="C#" Value="public static void Beep ();" />
      <MemberSignature Language="ILAsm" Value=".method public static void Beep() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Beep" />
      <MemberSignature Language="VB.NET" Value="Public Sub Beep ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Beep();" />
      <MemberSignature Language="F#" Value="static member Beep : unit -&gt; unit" Usage="Microsoft.VisualBasic.Interaction.Beep " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Spielt einen Signalton über den Lautsprecher des Computers ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Tonhöhe und die Dauer des Signaltons hängen von Ihrer Hardware und Software und daher Computer unterschiedlich sein.  
  
> [!NOTE]
>  Die `Beep` -Funktion erfordert `UIPermission` an die <xref:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows> Ebene auf, die sich möglicherweise auf ihre Ausführung in teilweise vertrauenswürdigen Umgebungen auswirken. Weitere Informationen finden Sie unter <xref:System.Security.Permissions.UIPermission>.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `Beep` Funktion, um einen über den Computer Lautsprecher ausgegeben.  
  
 [!code-vb[VbVbalrCatRef#59](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#59)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CallByName">
      <MemberSignature Language="C#" Value="public static object CallByName (object ObjectRef, string ProcName, Microsoft.VisualBasic.CallType UseCallType, params object[] Args);" />
      <MemberSignature Language="ILAsm" Value=".method public static object CallByName(object ObjectRef, string ProcName, valuetype Microsoft.VisualBasic.CallType UseCallType, object[] Args) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.CallByName(System.Object,System.String,Microsoft.VisualBasic.CallType,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CallByName (ObjectRef As Object, ProcName As String, UseCallType As CallType, ParamArray Args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CallByName(System::Object ^ ObjectRef, System::String ^ ProcName, Microsoft::VisualBasic::CallType UseCallType, ... cli::array &lt;System::Object ^&gt; ^ Args);" />
      <MemberSignature Language="F#" Value="static member CallByName : obj * string * Microsoft.VisualBasic.CallType * obj[] -&gt; obj" Usage="Microsoft.VisualBasic.Interaction.CallByName (ObjectRef, ProcName, UseCallType, Args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ObjectRef" Type="System.Object" />
        <Parameter Name="ProcName" Type="System.String" />
        <Parameter Name="UseCallType" Type="Microsoft.VisualBasic.CallType" />
        <Parameter Name="Args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="ObjectRef">Erforderlich. <see langword="Object" /> Ein Zeiger auf das Objekt, das die Eigenschaft oder Methode verfügbar macht.</param>
        <param name="ProcName">Erforderlich. <see langword="String" /> Ein Zeichenfolgenausdruck, der den Namen der Eigenschaft oder der Methode für das Objekt enthält.</param>
        <param name="UseCallType">Erforderlich. Ein Enumerationsmember vom Typ <see cref="T:Microsoft.VisualBasic.CallType" />, der den Typ der aufgerufenen Prozedur darstellt. Der Wert von <see langword="CallType" /> kann <see langword="Method" />, <see langword="Get" /> oder <see langword="Set" /> sein.</param>
        <param name="Args">Dies ist optional. <see langword="ParamArray" /> Ein Parameterarray mit den Argumenten, die an die aufgerufene Eigenschaft oder Methode übergeben werden sollen.</param>
        <summary>Führt eine Methode für ein Objekt aus oder legt eine Eigenschaft für ein Objekt fest oder gibt diese zurück.</summary>
        <returns>Führt eine Methode für ein Objekt aus oder legt eine Eigenschaft für ein Objekt fest oder gibt diese zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `CallByName` Funktion wird zur Laufzeit verwendet, um eine Eigenschaft abzurufen, eine Eigenschaft festlegen, oder rufen Sie eine Methode.  
  
   
  
## Examples  
 Im folgenden Beispiel verwendet die erste Zeile `CallByName` festzulegende der `Text` Eigenschaft eines Textfelds, die zweite Zeile ruft den Wert des der `Text` -Eigenschaft und die dritte Zeile ruft die `Move` Methode, um das Textfeld zu verschieben.  
  
 [!code-vb[VbVbalrFunctions#99](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#99)]  
  
 [!code-vb[VbVbalrFunctions#20](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#20)]  
  
 Im nächste Beispiel wird die `CallByName` aufzurufende Funktion der `Add` und `Item` Methoden eines Auflistungsobjekts.  
  
 [!code-vb[VbVbalrFunctions#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ungültiger <paramref name="UseCallType" />-Wert; muss <see langword="Method" />, <see langword="Get" /> oder <see langword="Set" /> sein.</exception>
        <altmember cref="T:Microsoft.VisualBasic.CallType" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <Member MemberName="Choose">
      <MemberSignature Language="C#" Value="public static object Choose (double Index, params object[] Choice);" />
      <MemberSignature Language="ILAsm" Value=".method public static object Choose(float64 Index, object[] Choice) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Choose(System.Double,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Choose (Index As Double, ParamArray Choice As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Choose(double Index, ... cli::array &lt;System::Object ^&gt; ^ Choice);" />
      <MemberSignature Language="F#" Value="static member Choose : double * obj[] -&gt; obj" Usage="Microsoft.VisualBasic.Interaction.Choose (Index, Choice)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Index" Type="System.Double" />
        <Parameter Name="Choice" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="Index">Erforderlich. <see langword="Double" /> Numerischer Ausdruck, der einen Wert zwischen 1 und der Anzahl der im <c>Choice</c>-Argument übergebenen Elemente ergibt.</param>
        <param name="Choice">Erforderlich. <see langword="Object" />-Parameterarray. Sie können eine einzelne Variable oder einen Ausdruck, der den <see langword="Object" />-Datentyp ergibt, für eine durch Komma getrennte Liste von <see langword="Object" />-Variablen oder Ausdrücken oder für ein eindimensionales Array von <see langword="Object" />-Elementen angeben.</param>
        <summary>Wählt einen Wert aus einer Liste von Argumenten aus und gibt diesen zurück.</summary>
        <returns>Wählt einen Wert aus einer Liste von Argumenten aus und gibt diesen zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Choose` Funktion gibt ein Element der Liste der übergebenen `Choice()`basierend auf den Wert des `Index`. Das erste Element der Liste ausgewählt ist beim `Index` ist 1. Das letzte Element der Liste ausgewählt ist beim `Index` ist `UBound`(`Choice()`). Wenn `Index` ist außerhalb dieser Grenzen `Choose` gibt `Nothing`.  
  
 Wenn `Index` ist keine ganze Zahl, wird der Wert vor der Auswertung auf die nächste ganze Zahl gerundet.  
  
 Sie können `Choose` um einen Wert in einer Liste von Möglichkeiten zu suchen.  
  
> [!NOTE]
>  Die Ausdrücke in der Argumentliste können Funktionsaufrufe enthalten. Im Rahmen der Vorbereitung der Argumentliste für den Aufruf von `Choose`, Visual Basic-Compiler jede Funktion in jedem Ausdruck aufgerufen wird. Dies bedeutet, dass Sie nicht immer zuverlässig auf eine bestimmte Funktion nicht aufgerufen werden, wenn Sie ein anderen Ausdruck vom ausgewählten `Index`.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `Choose` -Funktion zur Anzeige von eines Namens in der Antwort auf einen Index, an die Prozedur im übergeben der `Ind` Parameter.  
  
 [!code-vb[VbVbalrFunctions#22](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#22)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.IIf(System.Boolean,System.Object,System.Object)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.Switch(System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Command">
      <MemberSignature Language="C#" Value="public static string Command ();" />
      <MemberSignature Language="ILAsm" Value=".method public static string Command() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Command" />
      <MemberSignature Language="VB.NET" Value="Public Function Command () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Command();" />
      <MemberSignature Language="F#" Value="static member Command : unit -&gt; string" Usage="Microsoft.VisualBasic.Interaction.Command " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt den Argumentabschnitt der Befehlszeile zurück, mit der Visual Basic oder ein ausführbares Programm gestartet wird das mit Visual Basic entwickelt wurde. Das <see langword="My" />-Feature bietet höhere Produktivität und Leistung als die <see langword="Command" />-Funktion. Weitere Informationen finden Sie unter <see cref="P:Microsoft.VisualBasic.ApplicationServices.ConsoleApplicationBase.CommandLineArgs" />.</summary>
        <returns>Gibt den Argumentabschnitt der Befehlszeile zurück, mit der Visual Basic oder ein ausführbares Programm gestartet wird das mit Visual Basic entwickelt wurde.  Das <see langword="My" />-Feature bietet höhere Produktivität und Leistung als die <see langword="Command" />-Funktion. Weitere Informationen finden Sie unter <see cref="P:Microsoft.VisualBasic.ApplicationServices.ConsoleApplicationBase.CommandLineArgs" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nachdem die Argumente zurückgegeben werden, können Sie suchen, für allgemeine Trennzeichen, z. B. Leerzeichen, umgekehrten Schrägstrichen weiterleiten, Bindestriche oder Anführungszeichen zu trennen, oder suchen die Zeichenfolge für die einzelnen Parameter.  
  
 Für Anwendungen mit Visual Basic entwickelt und in eine .exe-Datei kompiliert die `Command` idatabasebackupreadstream keine Argumente, die nach dem Namen der Anwendung in der Befehlszeile oben im Formular angezeigt werden: `MyApp(cmdlineargs)`.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `Command` Funktion, um die Befehlszeilenargumente in einem Objekt zurückzugeben, die ein Array enthält.  
  
 [!code-vb[VbVbalrCatRef#58](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#58)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Environment.GetCommandLineArgs" />
        <altmember cref="P:Microsoft.VisualBasic.ApplicationServices.ConsoleApplicationBase.CommandLineArgs" />
      </Docs>
    </Member>
    <Member MemberName="CreateObject">
      <MemberSignature Language="C#" Value="public static object CreateObject (string ProgId, string ServerName = &quot;&quot;);" />
      <MemberSignature Language="ILAsm" Value=".method public static object CreateObject(string ProgId, string ServerName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.CreateObject(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateObject (ProgId As String, Optional ServerName As String = &quot;&quot;) As Object" />
      <MemberSignature Language="F#" Value="static member CreateObject : string * string -&gt; obj" Usage="Microsoft.VisualBasic.Interaction.CreateObject (ProgId, ServerName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ProgId" Type="System.String" />
        <Parameter Name="ServerName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="ProgId">Erforderlich. <see langword="String" /> Die Programm-ID des zu erstellenden Objekts.</param>
        <param name="ServerName">Dies ist optional. <see langword="String" /> Der Name des Netzwerkservers, auf dem das Objekt erstellt wird. Wenn <c>ServerName</c> eine leere Zeichenfolge ("") ist, wird der lokale Computer verwendet.</param>
        <summary>Erstellt und gibt einen Verweis auf ein COM-Objekt zurück. <see langword="CreateObject" /> kann in Visual Basic nur dann zur Erstellung von Klasseninstanzen verwendet werden, wenn diese explizit als COM-Komponenten verfügbar gemacht werden.</summary>
        <returns>Erstellt und gibt einen Verweis auf ein COM-Objekt zurück. <see langword="CreateObject" /> kann in Visual Basic nur dann zur Erstellung von Klasseninstanzen verwendet werden, wenn diese explizit als COM-Komponenten verfügbar gemacht werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um eine Instanz einer COM-Komponente zu erstellen, weisen Sie das zurückgegebene Objekt `CreateObject` einer Objektvariablen:  
  
```vb  
Sub CreateADODB()  
   Dim adoApp As Object  
   adoApp = CreateObject("ADODB.Connection")  
End Sub  
```  
  
 Der Typ des Object-Variablen, die Sie zum Speichern des zurückgegebenen Objekts verwenden kann die Leistung Ihrer Anwendung beeinträchtigen. Deklarieren einer Objektvariablen mit der `As Object` -Klausel erstellt eine Variable, die einen Verweis auf jede Art von Objekt enthalten kann. Allerdings ist der Zugriff auf das Objekt über die Variable *spät gebundene*, d. h. die Bindung erfolgt, wenn das Programm ausgeführt wird. Es gibt viele Gründe für die späte Bindung, einschließlich langsamer Anwendungsleistung sollten.  
  
 Sie können eine Objektvariable, die frühe Bindung führt erstellen – die Bindung erfolgt, wenn das Programm kompiliert wird. Zu diesem Zweck fügen Sie einen Verweis auf die Typbibliothek für das Objekt aus der **COM** auf der Registerkarte die **Verweis hinzufügen** Dialogfeld auf die **Projekt** Menü. Anschließend deklarieren Sie die Objektvariable des angegebenen Typs des Objekts. In den meisten Fällen ist es effizienter, verwenden Sie die `Dim` -Anweisung und eine primäre Interop-Assembly zum Erstellen von Objekten, als es ist die Verwendung der `CreateObject` Funktion.  
  
## <a name="interacting-with-unmanaged-code"></a>Interaktion mit nicht verwaltetem Code  
 Ein weiteres Problem ist, dass die COM-Objekte nicht verwalteten Code verwenden – Code ohne den Vorteil, dass die common Language Runtime. Es ist ziemlich aufwändig kombinieren des verwalteten Codes der Visual Basic mit nicht verwaltetem Code aus COM Wenn Sie einen Verweis auf ein COM-Objekt hinzufügen, sucht Visual Basic eine primäre Interopassembly (PIA) für diese Bibliothek; Wenn ein solches gefunden wird, verwendet sie es. Wenn sie eine PIA nicht gefunden wird, erstellt eine Interop-Assembly, die lokalen Interoperabilitätsklassen für jede Klasse in der COM-Bibliothek enthält. Weitere Informationen finden Sie unter [COM-Interoperabilität in .NET Framework-Anwendungen](~/docs/visual-basic/programming-guide/com-interop/com-interoperability-in-net-framework-applications.md).  
  
 Im Allgemeinen sollten Sie dringend gebundene Objekte und primäre Interop-Assemblys nach Möglichkeit verwenden. In den Beispielen unten verwenden die `CreateObject` -Funktion mit Microsoft Office-Objekte zu Demonstrationszwecken nur zu Testzwecken. Diese Objekte sind jedoch einfacher zu verwenden und zuverlässiger, wenn mit der entsprechenden primären Interopassembly verwendet.  
  
## <a name="creating-an-object-on-a-remote-computer"></a>Erstellen ein Objekt auf einem Remotecomputer  
 Sie können ein Objekt auf einem Remotecomputer im Netzwerk erstellen, übergeben Sie den Namen des Computers, auf die `ServerName` Argument der `CreateObject` Funktion. Dieser Name ist der Name des Computers Teil einen Freigabenamen identisch: für eine Freigabe mit dem Namen "\\\MyServer\Public," `ServerName` ist "MyServer".  
  
> [!NOTE]
>  Verweisen auf COM-Dokumentation (Siehe Microsoft Developer Network) Weitere Informationen zum Bereitstellen einer Anwendung auf einem Remotecomputer im Netzwerk zugegriffen werden kann. Sie müssen möglicherweise einen Registrierungsschlüssel für die Anwendung hinzuzufügen.  
  
 Der folgende Code gibt die Versionsnummer einer Instanz von Excel auf einem Remotecomputer mit dem Namen `MyServer`:  
  
```vb  
Sub CreateRemoteExcelObj()  
    Dim xlApp As Object  
    ' Replace string "\\MyServer" with name of the remote computer.  
    xlApp = CreateObject("Excel.Application", "\\MyServer")  
    MsgBox(xlApp.Version)  
End Sub  
```  
  
 Wenn der Remoteservername falsch ist oder wenn sie nicht verfügbar ist, tritt ein Laufzeitfehler auf.  
  
> [!NOTE]
>  Verwendung `CreateObject` , wenn keine aktuelle Instanz des Objekts vorhanden ist. Wenn bereits eine Instanz des Objekts ausgeführt wird, wird eine neue Instanz gestartet und ein Objekt des angegebenen Typs erstellt wird. Die aktuelle Instanz verwenden oder zum Starten der Anwendung und eine Datei zu laden, verwenden Sie die `GetObject` Funktion. Wenn ein Objekt als ein Einzelinstanz-Objekt registriert hat, nur eine Instanz des Objekts wird erstellt, unabhängig davon, wie oft `CreateObject` ausgeführt wird.  
  
## <a name="creating-framework-objects"></a>Framework-Objekte erstellen  
 Sie können die `CreateObject` Funktion nur zum Erstellen eines COM-Objekts. Es gibt zwar keine genauen äquivalenten Mechanismus zum Erstellen von .NET Framework-Objekt, das <xref:System.Activator> in der <xref:System> -Namespace enthält Methoden, um lokale oder remote-Objekte zu erstellen. Insbesondere die <xref:System.Activator.CreateInstance%2A> Methode oder die <xref:System.Activator.CreateInstanceFrom%2A> Methode kann nützlich sein.  
  
> [!IMPORTANT]
>  Die `CreateObject` -Funktion erfordert die Berechtigung für nicht verwalteten Code, der die Ausführung in teilweise vertrauenswürdigen Umgebungen auswirken. Weitere Informationen finden Sie unter <xref:System.Security.Permissions.SecurityPermission> und [Codezugriffsberechtigungen](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
   
  
## Examples  
 Im folgenden Beispiel wird die `CreateObject` Funktion, um ein Microsoft Excel-Arbeitsblatt zu erstellen und das Arbeitsblatt in einer Datei gespeichert. Um dieses Codebeispiel verwenden zu können, muss Excel auf dem Computer installiert sein, in dem das Programm ausgeführt wird. Darüber hinaus müssen Sie einen Verweis auf die Typbibliothek aus hinzufügen der **COM** auf der Registerkarte die **Verweis hinzufügen** Dialogfeld auf die **Projekt** Menü. Der Name der Typbibliothek variiert abhängig von der Version von Excel auf Ihrem Computer installiert. Die Typbibliothek für Microsoft Excel 2002 lautet z. B. **Microsoft Excel 10.0-Objektbibliothek**.  
  
 [!code-vb[VbVbalrExcelObject#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrExcelObject/VB/Class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception">Server ist nicht verfügbar</exception>
        <exception cref="T:System.IO.FileNotFoundException">Es ist kein Objekt des angegebenen Typs vorhanden.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.GetObject(System.String,System.String)" />
        <altmember cref="T:System.Exception" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:System.Activator" />
        <altmember cref="Overload:System.Activator.CreateInstance" />
        <altmember cref="Overload:System.Activator.CreateInstanceFrom" />
      </Docs>
    </Member>
    <Member MemberName="DeleteSetting">
      <MemberSignature Language="C#" Value="public static void DeleteSetting (string AppName, string Section = null, string Key = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static void DeleteSetting(string AppName, string Section, string Key) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.DeleteSetting(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteSetting (AppName As String, Optional Section As String = null, Optional Key As String = null)" />
      <MemberSignature Language="F#" Value="static member DeleteSetting : string * string * string -&gt; unit" Usage="Microsoft.VisualBasic.Interaction.DeleteSetting (AppName, Section, Key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AppName" Type="System.String" />
        <Parameter Name="Section" Type="System.String" />
        <Parameter Name="Key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AppName">Erforderlich. <see langword="String" />-Ausdruck mit dem Namen der Anwendung oder des Projekts, für die bzw. das der Abschnitt oder die Schlüsseleinstellung gilt.</param>
        <param name="Section">Erforderlich. <see langword="String" />-Ausdruck mit dem Namen des Abschnitts, aus dem die Schlüsseleinstellung gelöscht wird. Wenn nur <c>AppName</c> und <c>Section</c> bereitgestellt werden, wird der angegebene Abschnitt mit allen zugehörigen Schlüsseleinstellungen gelöscht.</param>
        <param name="Key">Dies ist optional. <see langword="String" />-Ausdruck mit dem Namen der Schlüsseleinstellung, die gelöscht wird.</param>
        <summary>Löscht einen Abschnitt oder eine Schlüsseleinstellung aus einen Anwendungseintrag in der Windows-Registrierung. Das <see langword="My" />-Feature bietet bei Registrierungsvorgängen höhere Produktivität und Leistung, als die <see langword="DeleteSetting" />-Funktion. Weitere Informationen finden Sie unter <see cref="P:Microsoft.VisualBasic.Devices.ServerComputer.Registry" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn alle Argumente bereitgestellt werden, wird die angegebene Einstellung gelöscht. Ein Laufzeitfehler tritt auf, wenn Sie versuchen, verwenden Sie `DeleteSetting` auf einen nicht vorhandenen Abschnitt oder Schlüssel festlegen.  
  
 `DeleteSetting` erfordert, dass ein Benutzer angemeldet sein, da die Ausführung unter der `HKEY_LOCAL_USER` Registrierungsschlüssel, der nicht aktiv ist, bis ein Benutzer interaktiv anmeldet.  
  
 Registrierungseinträge, die von einem nicht interaktiven Prozess (z. B. Mtx.exe) zugegriffen werden muss gespeichert werden sollen, unter einem der `HKEY_LOCAL_MACHINE\Software\` oder `HKEY_USER\DEFAULT\Software` Registrierungsschlüssel.  
  
   
  
## Examples  
 Zuerst im folgenden Beispiel wird die `SaveSetting` Verfahren, um Einträge in der Windows-Registrierung für die `MyApp` Anwendung und dann verwendet, die `DeleteSetting` Funktion, um sie zu entfernen. Da keine `Key` Argument angegeben wird, die gesamte `Startup` Abschnitt gelöscht, einschließlich der Name des Abschnitts und aller zugehörigen Schlüssel.  
  
 [!code-vb[VbVbalrCatRef#45](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#45)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Benutzer ist nicht angemeldet.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.GetAllSettings(System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.GetSetting(System.String,System.String,System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.SaveSetting(System.String,System.String,System.String,System.String)" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Environ">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt die zu einer Betriebssystem-Umgebungsvariablen gehörige Zeichenfolge zurück.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Environ">
      <MemberSignature Language="C#" Value="public static string Environ (int Expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static string Environ(int32 Expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Environ(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Environ (Expression As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Environ(int Expression);" />
      <MemberSignature Language="F#" Value="static member Environ : int -&gt; string" Usage="Microsoft.VisualBasic.Interaction.Environ Expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Expression" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="Expression">Erforderlich. Ausdruck, der entweder eine Zeichenfolge mit dem Namen einer Umgebungsvariablen oder eine ganze Zahl auswertet, die der numerischen Position einer Umgebungszeichenfolge in der Tabelle mit Umgebungszeichenfolgen entspricht.</param>
        <summary>Gibt die zu einer Betriebssystem-Umgebungsvariablen gehörige Zeichenfolge zurück.</summary>
        <returns>Gibt die zu einer Betriebssystem-Umgebungsvariablen gehörige Zeichenfolge zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `Expression` enthält eine Zeichenfolge, die <xref:Microsoft.VisualBasic.Interaction.Environ%2A> Funktion gibt den Text, der der angegebenen Umgebung Zeichenfolge zurück – d. h. den Text hinter dem Gleichheitszeichen (=) in der Umgebung Zeichenfolgentabelle für die betreffende Umgebungsvariable. Wenn die Zeichenfolge in `Expression` kann nicht gefunden werden, in der Umgebung-Zeichenfolgentabelle, eine leere Zeichenfolge ("") zurückgegeben.  
  
 Wenn `Expression` enthält eine ganze Zahl, die Zeichenfolge, die numerische Position in der Tabelle zurückgegeben wird. In diesem Fall <xref:Microsoft.VisualBasic.Interaction.Environ%2A> gibt den gesamten Text, einschließlich des Namens der Umgebungsvariablen. Wenn keine Umgebungszeichenfolge vorhanden, an der angegebenen Position ist <xref:Microsoft.VisualBasic.Interaction.Environ%2A> gibt eine Zeichenfolge der Länge 0 (null) zurück.  
  
> [!IMPORTANT]
>  Die <xref:Microsoft.VisualBasic.Interaction.Environ%2A> -Funktion erfordert die Umgebungsberechtigung für die Ausführung in teilweise vertrauenswürdigen Umgebungen auswirken. Weitere Informationen finden Sie unter <xref:System.Security.Permissions.SecurityPermission> und [Codezugriffsberechtigungen](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
   
  
## Examples  
 Dieses Beispiel verwendet die <xref:Microsoft.VisualBasic.Interaction.Environ%2A> Funktion, um die Eintragsnummer und die Länge der angeben der `PATH` -Anweisung in der Tabelle.  
  
 [!code-vb[VbVbalrCatRef#28](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Expression" /> fehlt.</exception>
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <Member MemberName="Environ">
      <MemberSignature Language="C#" Value="public static string Environ (string Expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static string Environ(string Expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Environ(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Environ (Expression As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Environ(System::String ^ Expression);" />
      <MemberSignature Language="F#" Value="static member Environ : string -&gt; string" Usage="Microsoft.VisualBasic.Interaction.Environ Expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Expression" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Expression">Erforderlich. Ausdruck, der entweder eine Zeichenfolge mit dem Namen einer Umgebungsvariablen oder eine ganze Zahl auswertet, die der numerischen Position einer Umgebungszeichenfolge in der Tabelle mit Umgebungszeichenfolgen entspricht.</param>
        <summary>Gibt die zu einer Betriebssystem-Umgebungsvariablen gehörige Zeichenfolge zurück.</summary>
        <returns>Gibt die zu einer Betriebssystem-Umgebungsvariablen gehörige Zeichenfolge zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `Expression` enthält eine Zeichenfolge, die <xref:Microsoft.VisualBasic.Interaction.Environ%2A> Funktion gibt den Text, der der angegebenen Umgebung Zeichenfolge zurück – d. h. den Text hinter dem Gleichheitszeichen (=) in der Umgebung Zeichenfolgentabelle für die betreffende Umgebungsvariable. Wenn die Zeichenfolge in `Expression` kann nicht gefunden werden, in der Umgebung-Zeichenfolgentabelle, eine leere Zeichenfolge ("") zurückgegeben.  
  
 Wenn `Expression` enthält eine ganze Zahl, die Zeichenfolge, die numerische Position in der Tabelle zurückgegeben wird. In diesem Fall <xref:Microsoft.VisualBasic.Interaction.Environ%2A> gibt den gesamten Text, einschließlich des Namens der Umgebungsvariablen. Wenn keine Umgebungszeichenfolge vorhanden, an der angegebenen Position ist <xref:Microsoft.VisualBasic.Interaction.Environ%2A> gibt eine Zeichenfolge der Länge 0 (null) zurück.  
  
> [!IMPORTANT]
>  Die <xref:Microsoft.VisualBasic.Interaction.Environ%2A> -Funktion erfordert die Umgebungsberechtigung für die Ausführung in teilweise vertrauenswürdigen Umgebungen auswirken. Weitere Informationen finden Sie unter <xref:System.Security.Permissions.SecurityPermission> und [Codezugriffsberechtigungen](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
   
  
## Examples  
 Dieses Beispiel verwendet die <xref:Microsoft.VisualBasic.Interaction.Environ%2A> Funktion, um die Eintragsnummer und die Länge der angeben der `PATH` -Anweisung in der Tabelle.  
  
 [!code-vb[VbVbalrCatRef#28](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Expression" /> fehlt.</exception>
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <Member MemberName="GetAllSettings">
      <MemberSignature Language="C#" Value="public static string[,] GetAllSettings (string AppName, string Section);" />
      <MemberSignature Language="ILAsm" Value=".method public static string[,] GetAllSettings(string AppName, string Section) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.GetAllSettings(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAllSettings (AppName As String, Section As String) As String(,)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^, 2&gt; ^ GetAllSettings(System::String ^ AppName, System::String ^ Section);" />
      <MemberSignature Language="F#" Value="static member GetAllSettings : string * string -&gt; string[,]" Usage="Microsoft.VisualBasic.Interaction.GetAllSettings (AppName, Section)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[,]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AppName" Type="System.String" />
        <Parameter Name="Section" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AppName">Erforderlich. <see langword="String" />-Ausdruck mit dem Namen der Anwendung oder des Projekts, deren bzw. dessen Schlüsseleinstellungen angefordert werden.</param>
        <param name="Section">Erforderlich. <see langword="String" />-Ausdruck mit dem Namen des Abschnitts, dessen Schlüsseleinstellungen angefordert werden. <see langword="GetAllSettings" /> gibt ein Objekt zurück, das ein zweidimensionales Zeichenfolgenarray enthält. Die Zeichenfolgen enthalten alle Schlüsseleinstellungen im angegebenen Abschnitt zuzüglich ihrer entsprechenden Werte.</param>
        <summary>Gibt eine Liste der Schlüsseleinstellungen eines Anwendungseintrags in der Windows-Registrierung mit ihren jeweiligen Werten (ursprünglich mit <see langword="SaveSetting" /> erstellt) zurück. Die Verwendung des <see langword="My" />-Features ermöglicht bei Registrierungsvorgängen höhere Produktivität und Leistung als <see langword="GetAllSettings" />. Weitere Informationen finden Sie unter <see cref="P:Microsoft.VisualBasic.Devices.ServerComputer.Registry" />.</summary>
        <returns>Gibt eine Liste der Schlüsseleinstellungen eines Anwendungseintrags in der Windows-Registrierung mit ihren jeweiligen Werten (ursprünglich mit <see langword="SaveSetting" /> erstellt) zurück.  Die Verwendung des <see langword="My" />-Features ermöglicht bei Registrierungsvorgängen höhere Produktivität und Leistung als <see langword="GetAllSettings" />. Weitere Informationen finden Sie unter <see cref="P:Microsoft.VisualBasic.Devices.ServerComputer.Registry" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetAllSettings` Gibt eine nicht initialisierte `Object` Wenn `AppName` oder `Section` ist nicht vorhanden.  
  
 Da die Ausführung unter der `HKEY_LOCAL_USER` Registrierungsschlüssel, der nicht aktiv ist, bis ein Benutzer interaktiv anmeldet, `GetAllSettings` erfordert, dass ein Benutzer angemeldet sein.  
  
 Registrierungseinträge, die von einem nicht interaktiven Prozess (z. B. Mtx.exe) zugegriffen werden muss gespeichert werden sollen, unter einem der `HKEY_LOCAL_MACHINE\Software\` oder `HKEY_USER\DEFAULT\Software` Registrierungsschlüssel.  
  
   
  
## Examples  
 Dieses Beispiel wird zunächst mit der `SaveSetting` Funktion, um Einträge in der Windows-Registrierung für die angegebene Anwendung `AppName`, verwendet dann die `GetAllSettings` Funktion, um die Einstellungen anzuzeigen. Beachten Sie diese Anwendung Namen und `Section` Namen können nicht abgerufen werden, mit `GetAllSettings`. Schließlich die `DeleteSetting` Funktion der Anwendung Einträge entfernt.  
  
 [!code-vb[VbVbalrCatRef#68](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Benutzer ist nicht angemeldet.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.DeleteSetting(System.String,System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.GetSetting(System.String,System.String,System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.SaveSetting(System.String,System.String,System.String,System.String)" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <Member MemberName="GetObject">
      <MemberSignature Language="C#" Value="public static object GetObject (string PathName = null, string Class = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static object GetObject(string PathName, string Class) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.GetObject(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetObject (Optional PathName As String = null, Optional Class As String = null) As Object" />
      <MemberSignature Language="F#" Value="static member GetObject : string * string -&gt; obj" Usage="Microsoft.VisualBasic.Interaction.GetObject (PathName, Class)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
        <Parameter Name="Class" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">Dies ist optional. <see langword="String" /> Der vollständige Pfad und Name der Datei, die das abzurufende Objekt enthält. Wenn <c>PathName</c> weggelassen wird, ist <c>Class</c> erforderlich.</param>
        <param name="Class">Erforderlich, wenn <c>PathName</c> nicht angegeben wird. <see langword="String" /> Eine Zeichenfolge, die die Klasse des Objekts darstellt. Das <c>Class</c>-Argument hat die folgende Syntax und Bestandteile:  <c>Name_der_app</c><c>.</c><c>Objekttyp</c>  [1|1] Parameter  [1|2] Beschreibung  [2|1] <c>Name_der_app</c>  [2|2] Erforderlich. <see langword="String" /> Der Name der Anwendung, die das Objekt bereitstellt.  [3|1] <c>Objekttyp</c>  [3|2] Erforderlich. <see langword="String" /> Der Typ oder die Klasse des zu erstellenden Objekts.</param>
        <summary>Gibt einen Verweis auf ein von einer COM-Komponente bereitgestelltes Objekt zurück.</summary>
        <returns>Gibt einen Verweis auf ein von einer COM-Komponente bereitgestelltes Objekt zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der `GetObject` Funktion, um eine Instanz einer COM-Komponente aus einer Datei zu laden. Dies wird anhand des folgenden Beispiels veranschaulicht.  
  
```vb  
Dim CADObject As Object  
CADObject = GetObject("C:\CAD\schema.cad")  
```  
  
 Wenn dieser Code ausgeführt wird, die Anwendung mit dem angegebenen `PathName` gestartet wird und das Objekt in der angegebenen Datei aktiviert ist.  
  
## <a name="default-cases"></a>Standard-Fällen  
 Wenn `PathName` ist eine leere Zeichenfolge (`""`), `GetObject` gibt eine neue Objektinstanz des angegebenen Klassentyps. Wenn die `PathName` Argument nicht angegeben wird, `GetObject` gibt ein derzeit aktives Objekt des Klassentyps im angegebenen `Class`. Wenn kein Objekt des angegebenen Typs vorhanden ist, tritt ein Fehler auf.  
  
## <a name="accessing-a-subobject"></a>Zugreifen auf ein Unterobjekt  
 Einige Anwendungen können Sie ein einer Datei zugeordnete Unterobjekt zu aktivieren. Fügen Sie zu diesem Zweck ein Ausrufezeichen (`!`) bis zum Ende des Dateinamens und führen Sie es mit der eine Zeichenfolge, die Teil der Datei identifiziert, Sie aktivieren möchten. Informationen zum Erstellen dieser Zeichenfolge finden in der Dokumentation für die Anwendung, die das Objekt erstellt.  
  
 Möglicherweise haben in einem Zeichenprogramm mehrere Ebenen einer Zeichnung in einer Datei gespeichert. Können Sie den folgenden Code zum Aktivieren einer Ebene innerhalb einer Zeichnung namens `schema.cad`.  
  
```vb  
layerObject = GetObject("C:\CAD\schema.cad!Layer3")  
```  
  
## <a name="specifying-a-class"></a>Eine Klasse angeben  
 Wenn Sie nicht des Objekts angeben `Class`, Automatisierung der Anwendung zu starten und das Objekt für die Aktivierung, basierend auf von Ihnen angegebene Dateiname bestimmt. Einige Dateien unterstützen jedoch mehr als eine Klasse des Objekts. Eine Zeichnung könnte z. B. drei verschiedene Typen von Objekten unterstützen: eine `Application` -Objekt, eine `Drawing` -Objekt, und ein `Toolbar` -Objekt, die Teil der gleichen Datei sind. Um anzugeben, welches Objekt in einer Datei, die Sie aktivieren möchten, verwenden Sie das optionale `Class` Argument. Dies wird anhand des folgenden Beispiels veranschaulicht.  
  
```vb  
Dim drawObj As Object  
drawObj = GetObject("C:\Drawings\sample.drw", "Figment.Drawing")  
```  
  
 Im vorherigen Beispiel `Figment` ist der Name des eine zeichenanwendung und `Drawing` ist eines der Objekttypen, die es unterstützt.  
  
## <a name="using-the-object"></a>Unter Verwendung des Objekts  
 Wenn ein Objekt aktiviert ist, verweisen Sie darauf, im Code mithilfe von Object-Variablen, in der Sie deklariert. Im vorherigen Beispiel aus, den Sie Eigenschaften und Methoden des neuen Objekts, wobei die Objektvariable zugreifen `drawObj`. Dies wird anhand des folgenden Beispiels veranschaulicht.  
  
```vb  
drawObj.Line(9, 90)  
drawObj.InsertText(9, 100, "Hello, world.")  
drawObj.SaveAs("C:\Drawings\sample.drw")  
```  
  
> [!NOTE]
>  Verwenden der `GetObject` funktionieren, wenn eine aktuelle Instanz des Objekts vorhanden ist oder wenn Sie zum Erstellen des Objekts mit einer Datei geladen werden soll. Wenn keine aktuelle Instanz vorhanden ist und nicht möchten, dass das Objekt mit eine Datei geladen wurde, verwenden Sie die <xref:Microsoft.VisualBasic.Interaction.CreateObject%2A> Funktion.  
>   
>  Wenn ein Objekt als ActiveX-Einzelinstanz-Objekt registriert wurde, nur eine Instanz des Objekts wird erstellt, unabhängig davon, wie oft `CreateObject` aufgerufen wird. Bei einem Einzelinstanz-Objekt `GetObject` immer die gleiche Instanz bei einem Aufruf mit der Zeichenfolge der Länge 0 (null) zurück (`""`)-Syntax, und es tritt einen Fehler auf, wenn die `PathName` Argument nicht angegeben wird. Sie können keine `GetObject` Abrufen eines Verweises auf eine Klasse, die mit Visual Basic erstellt.  
  
> [!IMPORTANT]
>  Die `GetObject` -Funktion erfordert die Berechtigung für nicht verwalteten Code, der die Ausführung in teilweise vertrauenswürdigen Umgebungen auswirken. Weitere Informationen finden Sie unter <xref:System.Security.Permissions.SecurityPermission> und [Codezugriffsberechtigungen](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
   
  
## Examples  
 Im folgenden Beispiel wird die `GetObject` Funktion zum Abrufen eines Verweises auf ein bestimmtes Microsoft Excel-Arbeitsblatt (`excelObj`). Er verwendet des Arbeitsblatts `Application` Eigenschaft, um Excel sichtbar ist, um es zu schließen und andere Aktionen ausführen. Mithilfe von zwei API-Aufrufe, die `detectExcel` Prozedur sucht nach Excel, und wenn er ausgeführt wird, erhält er den in der Tabelle ausgeführt wird. Der erste Aufruf von `GetObject` verursacht einen Fehler, wenn Excel nicht bereits ausgeführt, die in diesem Beispiel bewirkt, dass die `excelWasNotRunning` -Flag festgelegt werden, um `True`. Der zweite Aufruf von `GetObject` gibt eine Datei zu öffnen. Wenn Excel nicht bereits ausgeführt wird, wird der zweite Aufruf gestartet, und gibt einen Verweis auf das Arbeitsblatt, dargestellt durch die angegebene Datei `test.xls`. Die Datei muss sich am angegebenen Speicherort vorhanden sein; Andernfalls löst das Visual Basic eine <xref:System.IO.FileNotFoundException>. Als Nächstes wird der Beispielcode, Excel und das Fenster mit dem angegebenen Arbeitsblatt angezeigt.  
  
 Dieses Beispiel benötigen Sie `Option Strict Off` da späte Bindung verwendet wird, in denen Objekte Variablen des Typs zugewiesen `Object`. Können Sie angeben, `Option Strict On` und Objekte eines bestimmten Objekttyps deklarieren, wenn Sie einen Verweis auf die Excel-Typbibliothek aus hinzufügen der **COM** auf der Registerkarte die **Verweis hinzufügen** im Dialogfeld die ** Projekt** Menü in Visual Studio.  
  
 [!code-vb[VbVbalrExcelObject#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrExcelObject/VB/Class1.vb#2)]  
  
 [!code-vb[VbVbalrExcelObject#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrExcelObject/VB/Class1.vb#4)]  
  
 [!code-vb[VbVbalrExcelObject#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrExcelObject/VB/Class1.vb#5)]  
  
 Beim Aufrufen der `getExcel` -Funktion, wird überprüft, ob Excel bereits ausgeführt wird. Wenn sie nicht der Fall ist, wird eine Instanz erstellt.  
  
> [!IMPORTANT]
>  Der Einfachheit halber im vorangehende Beispiel wird davon ausgegangen, dass alle Fenster mit der Bezeichnung `XLMAIN` gehört zu einer Instanz von Microsoft Excel. Wenn ein anderes Objekt, das möglicherweise versehentlich gestartet wurde, ein Fenster mit diesem Namen erstellt haben, würde es alle Nachrichten empfangen, die Sie für Excel bestimmt sind. In einer Anwendung, die für die Produktion verwendet werden, sollten Sie einschließen, einige gründlichere Tests durchführen, um sicherzustellen, dass `XLMAIN` wirklich nach Excel gehört.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception">Es ist kein Objekt des angegebenen Klassentyps vorhanden.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Es ist kein Objekt mit dem angegebenen Pfad und Dateinamen vorhanden.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.CreateObject(System.String,System.String)" />
        <altmember cref="T:System.Exception" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <Member MemberName="GetSetting">
      <MemberSignature Language="C#" Value="public static string GetSetting (string AppName, string Section, string Key, string Default = &quot;&quot;);" />
      <MemberSignature Language="ILAsm" Value=".method public static string GetSetting(string AppName, string Section, string Key, string Default) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.GetSetting(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSetting (AppName As String, Section As String, Key As String, Optional Default As String = &quot;&quot;) As String" />
      <MemberSignature Language="F#" Value="static member GetSetting : string * string * string * string -&gt; string" Usage="Microsoft.VisualBasic.Interaction.GetSetting (AppName, Section, Key, Default)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AppName" Type="System.String" />
        <Parameter Name="Section" Type="System.String" />
        <Parameter Name="Key" Type="System.String" />
        <Parameter Name="Default" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AppName">Erforderlich. <see langword="String" />-Ausdruck mit dem Namen der Anwendung oder des Projekts, deren bzw. dessen Schlüsseleinstellung angefordert wird.</param>
        <param name="Section">Erforderlich. <see langword="String" />-Ausdruck mit dem Namen des Abschnitts, in dem die Schlüsseleinstellung gefunden wird.</param>
        <param name="Key">Erforderlich. <see langword="String" />-Ausdruck mit dem Namen der Schlüsseleinstellung, die zurückgegeben werden soll.</param>
        <param name="Default">Dies ist optional. Ausdruck mit dem Wert, der zurückgegeben werden soll, wenn in der <c>Key</c>-Einstellung kein Wert festgelegt wird. Wenn <c>Default</c> nicht angegeben wird, wird angenommen, dass es sich um eine Zeichenfolge der Länge 0 (null, "") handelt.</param>
        <summary>Gibt einen Schlüsseleinstellungswert eines Anwendungseintrags in der Windows-Registrierung zurück. Das <see langword="My" />-Feature bietet bei Registrierungsvorgängen höhere Produktivität und Leistung als <see langword="GetAllSettings" />. Weitere Informationen finden Sie unter <see cref="P:Microsoft.VisualBasic.Devices.ServerComputer.Registry" />.</summary>
        <returns>Gibt einen Schlüsseleinstellungswert eines Anwendungseintrags in der Windows-Registrierung zurück.  Das <see langword="My" />-Feature bietet bei Registrierungsvorgängen höhere Produktivität und Leistung als <see langword="GetAllSettings" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn keines der Elemente in den Namen der `GetSetting` Argumente sind nicht vorhanden, `GetSetting` gibt einen Wert von `Default`.  
  
 Da die Ausführung unter der `HKEY_LOCAL_USER` Registrierungsschlüssel, der nicht aktiv ist, bis ein Benutzer interaktiv anmeldet, `GetSetting` erfordert, dass ein Benutzer angemeldet sein.  
  
 Registrierungseinträge, die von einem nicht interaktiven Prozess (z. B. Mtx.exe) zugegriffen werden muss gespeichert werden sollen, unter einem der `HKEY_LOCAL_MACHINE\Software\` oder `HKEY_USER\DEFAULT\Software` Registrierungsschlüssel.  
  
 `GetSetting` erfordert `Read` <xref:System.Security.Permissions.RegistryPermission> .  
  
   
  
## Examples  
 Dieses Beispiel wird zunächst mit der `SaveSetting` Funktion, um Einträge in der Windows-Registrierung für die angegebene Anwendung `AppName`, und verwendet dann die `GetSetting` Funktion, um eine der Einstellungen anzuzeigen. Da die `Default` Argument angegeben wird, wird garantiert ein Wert zurückgegeben werden. Beachten Sie, dass `Section` Namen können nicht abgerufen werden, mit `GetSetting`. Schließlich die `DeleteSetting` -Funktion entfernt alle der Anwendung Einträge.  
  
 [!code-vb[VbVbalrCatRef#61](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#61)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Mindestens ein Argument ist kein <see langword="String" />-Ausdruck, oder der Benutzer ist nicht angemeldet.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.DeleteSetting(System.String,System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.GetAllSettings(System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.SaveSetting(System.String,System.String,System.String,System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.Security.Permissions.RegistryPermission" />
      </Docs>
    </Member>
    <Member MemberName="IIf">
      <MemberSignature Language="C#" Value="public static object IIf (bool Expression, object TruePart, object FalsePart);" />
      <MemberSignature Language="ILAsm" Value=".method public static object IIf(bool Expression, object TruePart, object FalsePart) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.IIf(System.Boolean,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function IIf (Expression As Boolean, TruePart As Object, FalsePart As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ IIf(bool Expression, System::Object ^ TruePart, System::Object ^ FalsePart);" />
      <MemberSignature Language="F#" Value="static member IIf : bool * obj * obj -&gt; obj" Usage="Microsoft.VisualBasic.Interaction.IIf (Expression, TruePart, FalsePart)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Expression" Type="System.Boolean" />
        <Parameter Name="TruePart" Type="System.Object" />
        <Parameter Name="FalsePart" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="Expression">Erforderlich. <see langword="Boolean" /> Der auszuwertende Ausdruck.</param>
        <param name="TruePart">Erforderlich. <see langword="Object" /> Wird zurückgegeben, wenn <c>Expression</c> zu <see langword="True" /> evaluiert.</param>
        <param name="FalsePart">Erforderlich. <see langword="Object" /> Wird zurückgegeben, wenn <c>Expression</c> zu <see langword="False" /> evaluiert.</param>
        <summary>Gibt eines von zwei Objekten zurück, abhängig von der Evaluierung eines Ausdrucks.</summary>
        <returns>Gibt eines von zwei Objekten zurück, abhängig von der Evaluierung eines Ausdrucks.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `IIf` -Funktion bietet eine Entsprechung für den ternären [Bedingungsoperator:?:](http://msdn.microsoft.com/library/88643ee8-7100-4f86-880a-705ec22b6271) in Visual C++.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `IIf` auszuwertende Funktion der `testMe` Parameter von der `checkIt` Prozedur und gibt "Large" If Word die Menge ist größer als 1000; andernfalls gibt es das Wort "Klein".  
  
 [!code-vb[VbVbalrFunctions#33](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#33)]  
  
 Beachten Sie, dass bei `Option Strict` ist `On`, verwenden Sie die `CStr` Schlüsselwort, um die Rückgabe von explizit konvertieren `Object` auf `String`.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.Choose(System.Double,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.Switch(System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="InputBox">
      <MemberSignature Language="C#" Value="public static string InputBox (string Prompt, string Title = &quot;&quot;, string DefaultResponse = &quot;&quot;, int XPos = -1, int YPos = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static string InputBox(string Prompt, string Title, string DefaultResponse, int32 XPos, int32 YPos) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.InputBox(System.String,System.String,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function InputBox (Prompt As String, Optional Title As String = &quot;&quot;, Optional DefaultResponse As String = &quot;&quot;, Optional XPos As Integer = -1, Optional YPos As Integer = -1) As String" />
      <MemberSignature Language="F#" Value="static member InputBox : string * string * string * int * int -&gt; string" Usage="Microsoft.VisualBasic.Interaction.InputBox (Prompt, Title, DefaultResponse, XPos, YPos)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Prompt" Type="System.String" />
        <Parameter Name="Title" Type="System.String" />
        <Parameter Name="DefaultResponse" Type="System.String" />
        <Parameter Name="XPos" Type="System.Int32" />
        <Parameter Name="YPos" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="Prompt">Erforderlich. Als Meldung im Dialogfeld angezeigter <see langword="String" />-Ausdruck. Die maximale Länge von <c>Prompt</c> beträgt ungefähr 1024 Zeichen, abhängig von der Breite der verwendeten Zeichen. Wenn <c>Prompt</c> aus mehr als einer Zeile besteht, können Sie die Zeilen mit einem Wagenrücklaufzeichen (<see langword="Chr(" />13<see langword=")" />), mit einem Zeilenvorschubzeichen (<see langword="Chr(" />10<see langword=")" />) oder mit einer Kombination aus beiden (<see langword="Chr(" />13<see langword=")" /> &amp; <see langword="Chr(" />10<see langword=")" />) voneinander trennen.</param>
        <param name="Title">Dies ist optional. Auf der Titelleiste des Dialogfelds angezeigter <see langword="String" />-Ausdruck. Wenn Sie <c>Title</c> nicht angeben, wird der Anwendungsname auf der Titelleiste platziert.</param>
        <param name="DefaultResponse">Dies ist optional. <see langword="String" />-Ausdruck, der im Textfeld standardmäßig angezeigt wird, wenn keine andere Eingabe erfolgt. Wenn Sie <c>DefaultResponse</c> nicht angeben, ist das angezeigte Textfeld leer.</param>
        <param name="XPos">Dies ist optional. Numerischer Ausdruck, der den Abstand des linken Randes des Dialogfelds vom linken Rand des Bildschirms in Twips angibt. Wenn Sie <c>XPos</c> nicht angeben, wird das Dialogfeld horizontal zentriert.</param>
        <param name="YPos">Dies ist optional. Numerischer Ausdruck, der den Abstand des oberen Randes des Dialogfelds vom oberen Rand des Bildschirms in Twips angibt. Wenn Sie <c>YPos</c> nicht angeben, wird das Dialogfeld vertikal um etwa ein Drittel der Bildschirmhöhe nach unten verschoben.</param>
        <summary>Zeigt eine Eingabeaufforderung in einem Dialogfeld an, wartet auf die Eingabe eines Textes oder auf das Klicken auf eine Schaltfläche durch den Benutzer und gibt eine Zeichenfolge zurück, die den Inhalt des Textfelds angibt.</summary>
        <returns>Zeigt eine Eingabeaufforderung in einem Dialogfeld an, wartet auf die Eingabe eines Textes oder auf das Klicken auf eine Schaltfläche durch den Benutzer und gibt eine Zeichenfolge zurück, die den Inhalt des Textfelds angibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Benutzer klickt **"Abbrechen"**, eine leere Zeichenfolge zurückgegeben.  
  
 Um mehr als das erste Argument anzugeben, verwenden Sie die `InputBox` Funktion in einem Ausdruck. Wenn Sie alle Positionsargumente weglassen, müssen Sie das entsprechende Kommatrennzeichen beibehalten.  
  
> [!NOTE]
>  Die `InputBox` -Funktion erfordert `UIPermission` an die <xref:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows> Ebene auf, die sich möglicherweise auf ihre Ausführung in teilweise vertrauenswürdigen Umgebungen auswirken. Weitere Informationen finden Sie unter und <xref:System.Security.Permissions.UIPermission> .  
  
   
  
## Examples  
 Dieses Beispiel zeigt verschiedene Verwendungsmöglichkeiten der `InputBox` Funktion, um den Benutzer auffordern, einen Wert eingeben. Wenn die x- und y Positionen werden ausgelassen, wird das Dialogfeld wird automatisch für die jeweiligen Achsen zentriert. Die Variable `MyValue` enthält den Wert, der vom Benutzer eingegeben werden, wenn der Benutzer auf OK klickt, oder die EINGABETASTE drückt.  
  
 [!code-vb[VbVbalrCatRef#67](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#67)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.MsgBox(System.Object,Microsoft.VisualBasic.MsgBoxStyle,System.Object)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Chr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.ChrW(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="MsgBox">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.MsgBoxResult MsgBox (object Prompt, Microsoft.VisualBasic.MsgBoxStyle Buttons = Microsoft.VisualBasic.MsgBoxStyle.ApplicationModal, object Title = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.MsgBoxResult MsgBox(object Prompt, valuetype Microsoft.VisualBasic.MsgBoxStyle Buttons, object Title) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.MsgBox(System.Object,Microsoft.VisualBasic.MsgBoxStyle,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function MsgBox (Prompt As Object, Optional Buttons As MsgBoxStyle = Microsoft.VisualBasic.MsgBoxStyle.ApplicationModal, Optional Title As Object = null) As MsgBoxResult" />
      <MemberSignature Language="F#" Value="static member MsgBox : obj * Microsoft.VisualBasic.MsgBoxStyle * obj -&gt; Microsoft.VisualBasic.MsgBoxResult" Usage="Microsoft.VisualBasic.Interaction.MsgBox (Prompt, Buttons, Title)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.MsgBoxResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Prompt" Type="System.Object" />
        <Parameter Name="Buttons" Type="Microsoft.VisualBasic.MsgBoxStyle" />
        <Parameter Name="Title" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="Prompt">Erforderlich. Als Meldung im Dialogfeld angezeigter <see langword="String" />-Ausdruck. Die maximale Länge von <c>Prompt</c> beträgt ungefähr 1024 Zeichen, abhängig von der Breite der verwendeten Zeichen. Wenn <c>Prompt</c> aus mehr als einer Zeile besteht, können Sie die Zeilen mit einem Wagenrücklaufzeichen (<see langword="Chr(" />13<see langword=")" />), mit einem Zeilenvorschubzeichen (<see langword="Chr(" />10<see langword=")" />) oder mit einer Kombination aus beiden Zeichen (<see langword="Chr(" />13<see langword=")" /> &amp; <see langword="Chr(" />10<see langword=")" />) voneinander trennen.</param>
        <param name="Buttons">Dies ist optional. Numerischer Ausdruck, der die Summe der Werte für folgende Angaben darstellt: Anzahl und Art der anzuzeigenden Schaltflächen, Art des zu verwendenden Symbols, Angabe der Standardschaltfläche und Verhalten des Meldungsfelds. Wenn Sie <c>Buttons</c> nicht angeben, ist der Standardwert 0 (null).</param>
        <param name="Title">Dies ist optional. Auf der Titelleiste des Dialogfelds angezeigter <see langword="String" />-Ausdruck. Wenn Sie <c>Title</c> nicht angeben, wird der Anwendungsname auf der Titelleiste platziert.</param>
        <summary>Zeigt eine Meldung in einem Dialogfeld an und wartet darauf, dass der Benutzer auf eine Schaltfläche klickt. Anschließend wird eine ganze Zahl zurückgegeben, die angibt, auf welche Schaltfläche geklickt wurde.</summary>
        <returns>
          <list type="table">
            <item>
              <term> Konstante  </term>
              <description> Wert  </description>
            </item>
            <item>
              <term>
                <see langword="OK" />
              </term>
              <description> 1  </description>
            </item>
            <item>
              <term>
                <see langword="Cancel" />
              </term>
              <description> 2  </description>
            </item>
            <item>
              <term>
                <see langword="Abort" />
              </term>
              <description> 3  </description>
            </item>
            <item>
              <term>
                <see langword="Retry" />
              </term>
              <description> 4  </description>
            </item>
            <item>
              <term>
                <see langword="Ignore" />
              </term>
              <description> 5  </description>
            </item>
            <item>
              <term>
                <see langword="Yes" />
              </term>
              <description> 6  </description>
            </item>
            <item>
              <term>
                <see langword="No" />
              </term>
              <description> 7  </description>
            </item>
          </list>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie alle Positionsargumente weglassen, müssen Sie das entsprechende Kommatrennzeichen beibehalten.  
  
 Wenn das Dialogfeld zeigt eine **"Abbrechen"** Schaltfläche, drücken die ESC-Taste hat dieselbe Wirkung wie das Klicken auf **"Abbrechen"**  
  
 Wenn das Dialogfeld enthält einen **Hilfe** Schaltfläche kontextbezogene Hilfe wird bereitgestellt, um das Dialogfeld. Allerdings wird kein Wert zurückgegeben, bis eine der anderen Schaltflächen ausgewählt wird. In Windows Forms-Anwendungen, die Auswahl der **Hilfe** Schaltfläche führt die <xref:System.Windows.Forms.Control.HelpRequested> Ereignis für das Formular.  
  
> [!NOTE]
>  Die `MsgBox` -Funktion erfordert `UIPermission` an die <xref:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows> Ebene auf, die sich möglicherweise auf ihre Ausführung in teilweise vertrauenswürdigen Umgebungen auswirken. Weitere Informationen finden Sie unter <xref:System.Security.Permissions.UIPermission>.  
  
 Die `MsgBoxStyle` Enumerationswerte sind in der folgenden Tabelle aufgeführt.  
  
|Member|Wert|Beschreibung |  
|-|-|-|  
|Member|Wert|Beschreibung |  
|`OKOnly`|0|Nur Schaltfläche zeigt OK.|  
|`OKCancel`|1|Zeigt OK und Schaltflächen "Abbrechen".|  
|`AbortRetryIgnore`|2|Zeigt die Schaltflächen Abbrechen, wiederholen Sie den Vorgang und ignorieren.|  
|`YesNoCancel`|3|Zeigt Ja, Nein und Abbrechen (Schaltflächen).|  
|`YesNo`|4|Zeigt Schaltflächen Ja und Nein.|  
|`RetryCancel`|5|Zeigt die Schaltflächen "Wiederholen" und "Abbrechen".|  
|`Critical`|16|Symbol "kritische Nachricht" angezeigt.|  
|`Question`|32|Symbol "Abfrage der Warnung" angezeigt.|  
|`Exclamation`|48|Symbol "Warnung" angezeigt.|  
|`Information`|64|Zeigt das Symbol Informationen an.|  
|`DefaultButton1`|0|Erste Schaltfläche ist Standard.|  
|`DefaultButton2`|256|Zweite Schaltfläche ist Standard.|  
|`DefaultButton3`|512|Dritte Schaltfläche ist Standard.|  
|`ApplicationModal`|0|Anwendung ist modal. Der Benutzer muss auf das Meldungsfeld reagieren, vor dem Fortsetzen der Arbeit in der aktuellen Anwendung.|  
|`SystemModal`|4096|System ist modal. Alle Anwendungen werden angehalten, bis der Benutzer in der MessageBox reagiert.|  
|`MsgBoxSetForeground`|65536|Gibt die Meldungsfeldfenster als Vordergrundfenster an.|  
|`MsgBoxRight`|524288|Text wird rechtsbündig ausgerichtet.|  
|`MsgBoxRtlReading`|1048576|Gibt an, dass Text in Hebräisch und Arabisch-Systemen von rechts nach links angezeigt werden soll.|  
  
 Die erste Gruppe von Werten (0 bis 5) beschreibt die Anzahl und Art der Schaltflächen im Dialogfeld angezeigt. Die zweite Gruppe (16, 32, 48, 64) beschreibt die Symbolart. Die dritte Gruppe (0, 256, 512) bestimmt, welche Schaltfläche die Standardschaltfläche ist. Die vierte Gruppe (0, 4096) bestimmt die Modalität des Meldungsfelds, und die fünfte Gruppe gibt an, ob das Meldungsfenster Vordergrundfenster zusammen mit der Ausrichtung und die Richtung des Texts wird. Beim Hinzufügen der Zahlen so erstellen Sie einen endgültigen Wert für die `Buttons` Argument verwenden nur eine Zahl aus jeder Gruppe.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `MsgBox` -Funktion zur Anzeige von kritische Fehlermeldung in ein Dialogfeld mit den Schaltflächen Ja und Nein. Die Schaltfläche "Nein" wird als die standardmäßige Antwort angegeben. Dies erfolgt durch Kombinieren der `MsgBox` Konstante Werte in einem numerischen Ausdruck. In diesem Fall ergibt 4 (die Ja/Nein) und 16 (die **kritische Meldung** Fenster) und 256 (die zweite Schaltfläche als Standardschaltfläche) bietet insgesamt 276. Der zurückgegebene Wert den `MsgBox` Funktion abhängig ist, auf die Schaltfläche vom Benutzer ausgewählten: Ja gibt den Wert 6; Nein gibt den Wert 7 zurück.  
  
 [!code-vb[VbVbalrCatRef#20](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Prompt" /> ist kein <see langword="String" />-Ausdruck, oder <paramref name="Title" /> ist ungültig.</exception>
        <exception cref="T:System.InvalidOperationException">Der Prozess wird nicht im interaktiven Modus ausgeführt.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Ein oder mehrere Parameter ist bzw. sind kein/e Member der <see langword="MsgBoxResult" />-Enumeration oder der <see langword="MsgBoxStyle" />-Enumeration.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.InputBox(System.String,System.String,System.String,System.Int32,System.Int32)" />
        <altmember cref="M:System.Windows.Forms.MessageBox.Show(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Partition">
      <MemberSignature Language="C#" Value="public static string Partition (long Number, long Start, long Stop, long Interval);" />
      <MemberSignature Language="ILAsm" Value=".method public static string Partition(int64 Number, int64 Start, int64 Stop, int64 Interval) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Partition(System.Int64,System.Int64,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Partition (Number As Long, Start As Long, Stop As Long, Interval As Long) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Partition(long Number, long Start, long Stop, long Interval);" />
      <MemberSignature Language="F#" Value="static member Partition : int64 * int64 * int64 * int64 -&gt; string" Usage="Microsoft.VisualBasic.Interaction.Partition (Number, Start, Stop, Interval)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Number" Type="System.Int64" />
        <Parameter Name="Start" Type="System.Int64" />
        <Parameter Name="Stop" Type="System.Int64" />
        <Parameter Name="Interval" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="Number">Erforderlich. <see langword="Long" /> Ganze Zahl, die Sie in einem der berechneten Bereiche suchen möchten.</param>
        <param name="Start">Erforderlich. <see langword="Long" /> Ganze Zahl, die den Anfang der Reihe berechneter Bereiche angibt. <c>Start</c> darf nicht kleiner als 0 sein.</param>
        <param name="Stop">Erforderlich. <see langword="Long" /> Ganze Zahl, die das Ende der Reihe berechneter Bereiche angibt. <c>Stop</c> darf nicht kleiner oder gleich <c>Start</c> sein.</param>
        <param name="Interval">Erforderlich. <see langword="Long" /> Ganze Zahl, die die Größe jedes berechneten Bereichs zwischen <c>Start</c> und <c>Stop</c> angibt. <c>Interval</c> darf nicht kleiner als 1 sein.</param>
        <summary>Gibt eine Zeichenfolge zurück, die den berechneten Bereich darstellt, der eine Zahl enthält.</summary>
        <returns>Gibt eine Zeichenfolge zurück, die den berechneten Bereich darstellt, der eine Zahl enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Partition` -Funktion berechnet einen Satz von numerischen Bereiche jeweils die Anzahl der angegebenen Werte von `Interval`. Der erste Bereich beginnt bei `Start`, und der letzte Bereich endet am `Stop`. Die `Partition` Funktion dann identifiziert der Bereich enthält `Number` und gibt eine Zeichenfolge, die diesen Bereich zurück. Der Bereich wird dargestellt, in der Zeichenfolge als "*Lowervalue*:*Uppervalue*", wobei die niedrigen Ende des Bereichs (*Lowervalue*) getrennt von high-End (* Uppervalue*) von einem Doppelpunkt (:).  
  
 Bei Bedarf die `Partition` -Funktion fügt ein Leerzeichen vor dem *Lowervalue* und *Uppervalue* , damit beide die gleiche Anzahl von Zeichen als die Zeichenfolgendarstellung der Wert (aufweisen `Stop` + 1). Dadurch wird sichergestellt, dass bei Verwendung die Ausgabe der `Partition` -Funktion mit mehreren Werten `Number`, wird der resultierende Text bei nachfolgenden Sortiervorgängen ordnungsgemäß behandelt werden.  
  
 Die folgende Tabelle zeigt einige Beispielzeichenfolgen für Bereiche, die mit drei Gruppen von berechnet `Start`, `Stop`, und `Interval`. "Zuerst im Bereich" und "Letzter Bereich" Spalten sehen Sie den niedrigsten und höchsten möglichen angegebenen Werte von `Start` und `Stop`. Die "vor dem ersten Bereich" und "nach den letzten Bereich" wird durch Spalten enthalten, die Zeichenfolgen, die für Werte der zurückgegebenen `Number` kleiner als `Start` und größer als `Stop`bzw.  
  
|`Start`|`Stop`|`Interval`|Vor dem ersten Bereich|Ersten Bereich|Letzte Bereich|Nach dem letzten Bereich|  
|-|-|-|-|-|-|-|  
|0|99|5|"   : -1"|"0: 4"|"95: 99"|"100:   "|  
|20|199|10|": 19"|"20:29"|"190:199"|"200:"|  
|100|1010|20|": 99"|"100: 119"|"1000:1010"|"1011:    "|  
  
 In der vorangegangenen Tabelle die dritte Zeile zeigt das Ergebnis bei `Start` und `Stop` definieren eine Menge von Zahlen, die durch gleichmäßig geteilt werden, können nicht `Interval`. Der letzte Bereich endet am `Stop`, sodass nur 11 Ziffern lang, obwohl `Interval` ist 20.  
  
 Wenn `Interval` 1 ist, wird der Bereich "`Number`:`Number`", unabhängig von der `Start` und `Stop` Argumente. Z. B. wenn `Number` ist 267, `Stop` ist 1000. und `Interval` beträgt 1, `Partition` "267: 267" zurückgegeben.  
  
 `Partition` kann nützlich sein, wenn Datenbankabfragen. Sie können eine SELECT-Abfrage erstellen, die zeigt, wie viele Bestellungen auftreten innerhalb der verschiedenen Wertbereiche, z. B. mit Rechnungswerte von 1 bis 1000, 1001, 2000 und so weiter.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Folge von Bereichen Jahrzehnten von 1950 bis 2049. Sucht den Wert der `year` innerhalb des entsprechenden Bereichs und gibt eine `String` Wert des Bereichs angezeigt. Wenn `year` hat den Wert 1984, z. B. `Partition` gibt "1980: 1989 zurück".  
  
 [!code-vb[VbVbalrFunctions#45](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#45)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Start" /> &lt; 0, <paramref name="Stop" /> &lt;= <paramref name="Start" />, oder <paramref name="Interval" /> &lt; 1.</exception>
      </Docs>
    </Member>
    <Member MemberName="SaveSetting">
      <MemberSignature Language="C#" Value="public static void SaveSetting (string AppName, string Section, string Key, string Setting);" />
      <MemberSignature Language="ILAsm" Value=".method public static void SaveSetting(string AppName, string Section, string Key, string Setting) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.SaveSetting(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SaveSetting (AppName As String, Section As String, Key As String, Setting As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SaveSetting(System::String ^ AppName, System::String ^ Section, System::String ^ Key, System::String ^ Setting);" />
      <MemberSignature Language="F#" Value="static member SaveSetting : string * string * string * string -&gt; unit" Usage="Microsoft.VisualBasic.Interaction.SaveSetting (AppName, Section, Key, Setting)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AppName" Type="System.String" />
        <Parameter Name="Section" Type="System.String" />
        <Parameter Name="Key" Type="System.String" />
        <Parameter Name="Setting" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AppName">Erforderlich. <see langword="String" />-Ausdruck mit dem Namen der Anwendung oder des Projekts, für die bzw. das die Einstellung gilt.</param>
        <param name="Section">Erforderlich. <see langword="String" />-Ausdruck mit dem Namen des Abschnitts, in dem die Schlüsseleinstellung gespeichert wird.</param>
        <param name="Key">Erforderlich. <see langword="String" />-Ausdruck mit dem Namen der Schlüsseleinstellung, die gespeichert wird.</param>
        <param name="Setting">Erforderlich. Ausdruck mit dem Wert, auf den <c>Key</c> festgelegt wird.</param>
        <summary>Speichert oder erstellt einen Anwendungseintrag in der Windows-Registrierung. Das <see langword="My" />-Feature bietet bei Registrierungsvorgängen höhere Produktivität und Leistung als <see langword="SaveSetting" />. Weitere Informationen finden Sie unter <see cref="P:Microsoft.VisualBasic.Devices.ServerComputer.Registry" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `SaveSetting` -Funktion fügt den Schlüssel zu `HKEY_CURRENT_USER\Software\VB and VBA Program Settings`.  
  
 Wenn die Einstellung aus irgendeinem Grund nicht gespeichert werden kann, tritt ein Fehler auf.  
  
 `SaveSetting` erfordert, dass ein Benutzer angemeldet sein, da die Ausführung unter der `HKEY_LOCAL_USER` Registrierungsschlüssel, der nicht aktiv ist, bis ein Benutzer interaktiv anmeldet.  
  
 Registrierungseinträge, die von einem nicht interaktiven Prozess (z. B. Mtx.exe) zugegriffen werden muss gespeichert werden sollen, unter einem der `HKEY_LOCAL_MACHINE\Software\` oder `HKEY_USER\DEFAULT\Software` Registrierungsschlüssel.  
  
 `SaveSetting` erfordert `Write` und `Create` <xref:System.Security.Permissions.RegistryPermission> .  
  
   
  
## Examples  
 Zuerst im folgenden Beispiel wird die `SaveSetting` Funktion, um Einträge in der Windows-Registrierung für die `MyApp` Anwendung und dann verwendet, die `DeleteSetting` Funktion, um sie zu entfernen.  
  
 [!code-vb[VbVbalrCatRef#56](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#56)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Schlüsselregistrierung konnte nicht erstellt werden, oder Benutzer ist nicht angemeldet.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.DeleteSetting(System.String,System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.GetAllSettings(System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.GetSetting(System.String,System.String,System.String,System.String)" />
        <altmember cref="T:System.Security.Permissions.RegistryPermission" />
      </Docs>
    </Member>
    <Member MemberName="Shell">
      <MemberSignature Language="C#" Value="public static int Shell (string PathName, Microsoft.VisualBasic.AppWinStyle Style = Microsoft.VisualBasic.AppWinStyle.MinimizedFocus, bool Wait = false, int Timeout = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 Shell(string PathName, valuetype Microsoft.VisualBasic.AppWinStyle Style, bool Wait, int32 Timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Shell(System.String,Microsoft.VisualBasic.AppWinStyle,System.Boolean,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Shell (PathName As String, Optional Style As AppWinStyle = Microsoft.VisualBasic.AppWinStyle.MinimizedFocus, Optional Wait As Boolean = false, Optional Timeout As Integer = -1) As Integer" />
      <MemberSignature Language="F#" Value="static member Shell : string * Microsoft.VisualBasic.AppWinStyle * bool * int -&gt; int" Usage="Microsoft.VisualBasic.Interaction.Shell (PathName, Style, Wait, Timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
        <Parameter Name="Style" Type="Microsoft.VisualBasic.AppWinStyle" />
        <Parameter Name="Wait" Type="System.Boolean" />
        <Parameter Name="Timeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="PathName">Erforderlich. <see langword="String" /> Name des auszuführenden Programms zusammen mit allen erforderlichen Argumenten und Befehlszeilenschaltern. <c>PathName</c> kann auch das Laufwerk und den Verzeichnispfad bzw. den Ordner beinhalten.  Wenn Sie den Pfad zum Programm nicht kennen, können Sie ihn mit <see cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.GetFiles" /> ermitteln. Sie können beispielsweise <c>My.Computer.FileSystem.GetFiles ("C:\", TRUE, "testFile.txt")</c> aufrufen, was den vollständigen Pfad jeder Datei mit dem Namen <c>testFile.txt</c> zurückgibt, die sich an beliebiger Stelle auf Laufwerk C:\\ befindet.</param>
        <param name="Style">Dies ist optional. <see langword="AppWinStyle" /> Ein aus dem <see cref="T:Microsoft.VisualBasic.AppWinStyle" /> ausgewählter Wert, der das Format des Fensters angibt, in dem das Programm ausgeführt werden soll. Wenn <c>Style</c> nicht angegeben wird, verwendet <see langword="Shell" /><see langword="AppWinStyle.MinimizedFocus" />, wodurch das Programm minimiert und mit dem Fokus gestartet wird.</param>
        <param name="Wait">Dies ist optional. <see langword="Boolean" /> Ein Wert, der angibt, ob die <see langword="Shell" />-Funktion auf den Abschluss des Programms warten soll. Wenn <c>Wait</c> nicht angegeben wird, verwendet <see langword="Shell" /><see langword="False" />.</param>
        <param name="Timeout">Dies ist optional. <see langword="Integer" /> Die Anzahl von Millisekunden, die auf den Abschluss gewartet werden soll, wenn <c>Wait</c> den Wert <see langword="True" /> hat. Wenn <c>Timeout</c> nicht angegeben wird, verwendet <see langword="Shell" /> den Wert – 1. Das bedeutet, dass es kein Timeout gibt und eine Rückgabe von <see langword="Shell" /> erst nach Beendigung des Programms erfolgt. Wenn Sie daher <c>Timeout</c> nicht angeben oder auf – 1 festlegen, ist es möglich, dass <see langword="Shell" /> die Steuerung niemals an Ihr Programm zurückgibt.</param>
        <summary>Führt ein ausführbares Programm aus und gibt eine ganze Zahl mit der Prozess-ID des Programms zurück, sofern es noch ausgeführt wird.</summary>
        <returns>Führt ein ausführbares Programm aus und gibt eine ganze Zahl mit der Prozess-ID des Programms zurück, sofern es noch ausgeführt wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Rückgabewert von der `Shell` Funktion, hängt davon ab, ob das Programm in den Namen `PathName` noch ausgeführt wird, wenn `Shell` zurückgibt. Wenn Sie festlegen, `Wait` auf `True` und das Programm abgeschlossen ist, bevor das Timeout abläuft, `Shell` gibt 0 (null) zurück. Wenn das Timeout abläuft, oder wenn Sie weglassen `Wait` oder legen sie den `False`, `Shell` gibt die Prozess-ID des Programms. Die Prozess-ID ist eine eindeutige Zahl, die die ausgeführte Anwendung identifiziert.  
  
## <a name="failure-to-start"></a>Fehler beim Start  
 Wenn die `Shell` Funktion das genannte Programm kann nicht gestartet werden eine <xref:System.IO.FileNotFoundException> Fehler auftritt. Dies kann beispielsweise vorkommen, wenn Sie versuchen, ein 16-Bit-Programm auszuführen, z. B. `command.com`, von einer Anwendung mittels <xref:System.Windows.Forms?displayProperty=nameWithType>. Für dieses Problem zu umgehen können Sie eine 32-Bit-Programm ausführen, die das gewünschte 16-Bit-Programm aufruft. Im Fall von `command.com`, Sie können ausführen `cmd.exe` als Alternative.  
  
## <a name="waiting-for-completion"></a>Warten auf Abschluss des Vorgangs  
 Wird standardmäßig die `Shell` Funktion wird das Programm asynchron ausgeführt. Dies bedeutet, dass ein Programm gestartet, mit der `Shell` Funktion kann nicht beendet werden ausgeführt, bevor Sie die folgenden Anweisungen die `Shell` Funktion ausgeführt werden. Wenn Sie warten möchten, für das Programm auf Fertig stellen, bevor Sie fortfahren, legen Sie `Wait` auf `True`.  
  
## <a name="determining-the-exit-code"></a>Festlegen des Exitcodes  
 Ein Prozess kann Zurückgeben einer *Exitcode* wenn er beendet wird. Allerdings können keine `Shell` zu dieser Exitcode abgerufen werden, da `Shell` gibt 0 (null), wenn es auf die Beendigung wartet sowie, da der Prozess ausgeführt wird, in einem anderen Objekt aus `Shell`.  
  
 Zum Abrufen des Exitcodes von einem Prozess müssen Sie Ihren eigenen Code zum veranlassen Sie die Bereitstellung und Beendigung warten schreiben. Im folgende Beispiel wird gezeigt, wie auf einen Prozess zu initiieren, warten Sie, bis es beendet und seine Exitcode abgerufen wird.  
  
```vb  
Dim procID As Integer  
Dim newProc As Diagnostics.Process  
newProc = Diagnostics.Process.Start("C:\WINDOWS\NOTEPAD.EXE")  
procID = newProc.Id  
newProc.WaitForExit()  
Dim procEC As Integer = -1  
If newProc.HasExited Then  
    procEC = newProc.ExitCode  
End If  
MsgBox("Process with ID " & CStr(ProcID) & _  
    " terminated with exit code " & CStr(procEC))  
```  
  
## <a name="protecting-the-file-specification"></a>Schützen der Dateispezifikation  
 Sie sollten immer den vollständige Pfad und Dateinamen-Spezifikation in Anführungszeichen ein, anzugeben, wie im folgenden Beispiel gezeigt.  
  
```vb  
ID = Shell("""C:\Program Files\display.exe"" -a -q", , True, 100000)  
```  
  
 Jedes Paar von aufeinander folgenden doppelten Anführungszeichen (`" "`) innerhalb der Zeichenfolge Literal als ein doppeltes Anführungszeichen in der Zeichenfolge interpretiert. Das obige Beispiel zeigt daher folgende Zeichenfolge an die `Shell` Funktion:  
  
```console  
"C:\Program Files\display.exe" -a -q  
```  
  
 Wenn Sie nicht den Pfad in Anführungszeichen eingeschlossen haben, sieht Windows für eine Datei namens `Program.exe` im Verzeichnis C:\ anstelle von `display.exe` im Verzeichnis C:\Program Files.  
  
> [!IMPORTANT]
>  Wenn Sie nicht die Spezifikation Pfad und Dateinamen in Anführungszeichen setzen, stellt ein Sicherheitsrisiko, wenn der Dateiname oder einem Pfadknoten Leerzeichen enthält. Im vorherigen Beispiel, das Pfadknoten `\Program Files` ein Leerzeichen enthält. Wenn die Spezifikation nicht in Anführungszeichen eingeschlossen und ein Programm mit dem Namen `Program.exe` in "c:" installiert worden\\, z. B. durch versehentlich, Windows würde führen Sie es anstelle von `display.exe`.  
  
> [!IMPORTANT]
>  Die `Shell` -Funktion erfordert die Berechtigung für nicht verwalteten Code, der die Ausführung in teilweise vertrauenswürdigen Umgebungen auswirken. Weitere Informationen finden Sie unter <xref:System.Security.Permissions.SecurityPermission> und [Codezugriffsberechtigungen](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
   
  
## Examples  
 Im folgenden Beispiel wird die `Shell` Funktion zum Ausführen einer Anwendung, die vom Benutzer angegeben wird. Angeben von <xref:Microsoft.VisualBasic.AppWinStyle.NormalFocus?displayProperty=nameWithType> als zweites Argument wird die Anwendung in Normalgröße geöffnet und der Fokus.  
  
 [!code-vb[VbVbalrFunctions#47](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#47)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Style" /> befindet sich nicht im Bereich von 0 bis einschließlich 9.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <see langword="Shell" /> kann die Datei <paramref name="PathName" /> nicht finden.</exception>
        <exception cref="T:System.NullReferenceException">
          <paramref name="PathName" /> ist <see langword="Nothing" />.</exception>
        <altmember cref="T:Microsoft.VisualBasic.AppWinStyle" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:System.NullReferenceException" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.GetFiles" />
        <altmember cref="Overload:Microsoft.VisualBasic.Interaction.AppActivate" />
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static object Switch (params object[] VarExpr);" />
      <MemberSignature Language="ILAsm" Value=".method public static object Switch(object[] VarExpr) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Switch(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Switch (ParamArray VarExpr As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Switch(... cli::array &lt;System::Object ^&gt; ^ VarExpr);" />
      <MemberSignature Language="F#" Value="static member Switch : obj[] -&gt; obj" Usage="Microsoft.VisualBasic.Interaction.Switch VarExpr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="VarExpr" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="VarExpr">Erforderlich. <see langword="Object" />-Parameterarray. Muss über eine gerade Anzahl von Elementen verfügen. Sie können eine durch Komma getrennte Liste von <see langword="Object" />-Variablen oder Ausdrücken oder ein eindimensionales Array von <see langword="Object" />-Elementen angeben.</param>
        <summary>Evaluiert eine Liste von Ausdrücken und gibt einen <see langword="Object" />-Wert zurück, der dem ersten Ausdruck in der Liste entspricht, der <see langword="True" /> ist.</summary>
        <returns>Evaluiert eine Liste von Ausdrücken und gibt einen <see langword="Object" />-Wert zurück, der dem ersten Ausdruck in der Liste entspricht, der <see langword="True" /> ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Argument bereitgestellt, um `VarExpr` paarweise zugeordneten Ausdrücken und Werten besteht. Die `Switch` -Funktion wertet die Ausdrücke ungerader vom niedrigsten zum höchsten Index in `VarExpr`, und gibt den gerader Wert mit dem ersten Ausdruck, der ergibt `True`. Z. B. wenn `VarExpr(0)` ist `True`, `Switch` gibt `VarExpr(1)`, und wenn `VarExpr(0)` ist `False` jedoch `VarExpr(2)` ist `True`, `Switch` gibt `VarExpr(3)`und so weiter.  
  
 Wenn Sie keinen angeben, die `VarExpr` Argument `Switch` gibt `Nothing`.  
  
> [!NOTE]
>  Die Ausdrücke in der Argumentliste können Funktionsaufrufe enthalten. Im Rahmen der Vorbereitung der Argumentliste für den Aufruf von `Switch`, Visual Basic-Compiler jede Funktion in jedem Ausdruck aufgerufen wird. Dies bedeutet, dass Sie nicht immer zuverlässig auf eine bestimmte Funktion nicht aufgerufen werden, wenn ein Ausdruck weiter oben in der Argumentliste ist `True`.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die `Switch` Funktion, um den Namen einer Sprache zurückzugeben, die den Namen einer Stadt entspricht. Es erfordert, dass `Option Strict` werden `Off`.  
  
 [!code-vb[VbVbalrFunctions#48](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#48)]  
  
 Da die <xref:System.Diagnostics> -Namespace enthält auch eine Klasse mit dem Namen <xref:System.Diagnostics.Switch>, einen Aufruf der `Switch` Funktion muss qualifiziert werden, mit der <xref:Microsoft.VisualBasic> Namespace.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ungerade Anzahl der Argumente</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.Choose(System.Double,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.IIf(System.Boolean,System.Object,System.Object)" />
      </Docs>
    </Member>
  </Members>
</Type>