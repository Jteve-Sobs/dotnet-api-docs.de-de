<Type Name="Interaction" FullName="Microsoft.VisualBasic.Interaction">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c5303414dd5cf14605ba7c6fd57c1737079d4fb5" />
    <Meta Name="ms.sourcegitcommit" Value="c0c07dbd19cd7017243f9ac36915755f79bc8da6" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="11/27/2018" />
    <Meta Name="ms.locfileid" Value="52351671" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Interaction" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Interaction extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.VisualBasic.Interaction" />
  <TypeSignature Language="VB.NET" Value="Public Module Interaction" />
  <TypeSignature Language="C++ CLI" Value="public ref class Interaction sealed" />
  <TypeSignature Language="F#" Value="type Interaction = class" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic</AssemblyName>
    <AssemblyVersion>7.0.5000.0</AssemblyVersion>
    <AssemblyVersion>8.0.0.0</AssemblyVersion>
    <AssemblyVersion>10.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>Microsoft.VisualBasic.CompilerServices.StandardModule</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Das <see langword="Interaction" />-Modul enthält Prozeduren für die Interaktion mit Objekten, Anwendungen und Systemen.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Modul unterstützt die Visual Basic-Schlüsselwörter und Laufzeit-Bibliothekscode-Member, die andere Programme auszuführen, rufen Sie eine Methode oder Eigenschaft, Ausgeben eines akustischen Signals auf dem Computer, eine Befehlszeile-Zeichenfolge bereitstellen, COM-Objekte bearbeiten und Steuern von Dialogfeldern.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die `Shell` Funktion zum Ausführen einer Anwendung, die vom Benutzer angegeben wird. Angeben von <xref:Microsoft.VisualBasic.AppWinStyle.NormalFocus?displayProperty=nameWithType> als das zweite Argument wird die Anwendung in Normalgröße und gibt ihm den Fokus.  
  
```vb  
Dim procID As Integer  
' Run calculator.  
procID = Shell("C:\Windows\system32\calc.exe", AppWinStyle.NormalFocus)  
' The preceding path is for Windows XP.  
' The Windows 2000 path is C:\WINNT\system32\calc.exe.  
```  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/visual-basic/language-reference/keywords/information-and-interaction-summary.md">Informationen und Interaktionen: Zusammenfassung</related>
    <related type="Article" href="~/docs/visual-basic/language-reference/keywords/index.md">Schlüsselwörter (Visual Basic)</related>
    <related type="Article" href="~/docs/visual-basic/language-reference/runtime-library-members.md">Member der Visual Basic-Laufzeitbibliothek</related>
  </Docs>
  <Members>
    <MemberGroup MemberName="AppActivate">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Aktiviert eine Anwendung, die bereits ausgeführt wird.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppActivate">
      <MemberSignature Language="C#" Value="public static void AppActivate (int ProcessId);" />
      <MemberSignature Language="ILAsm" Value=".method public static void AppActivate(int32 ProcessId) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.AppActivate(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppActivate (ProcessId As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AppActivate(int ProcessId);" />
      <MemberSignature Language="F#" Value="static member AppActivate : int -&gt; unit" Usage="Microsoft.VisualBasic.Interaction.AppActivate ProcessId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ProcessId" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ProcessId">
          <see langword="Integer" /> zum Angeben der diesem Prozess zugewiesene Win32-Prozess-ID. Sie können die von der <see cref="M:Microsoft.VisualBasic.Interaction.Shell(System.String,Microsoft.VisualBasic.AppWinStyle,System.Boolean,System.Int32)" /> zurückgegebene ID verwenden, sofern diese nicht 0 (null) ist.</param>
        <summary>Aktiviert eine Anwendung, die bereits ausgeführt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie `AppActivate` , das aktive Fenster einer Anwendung in den Fokus zu öffnen. Sie können kein Handle oder ein Verweis auf das aktive Fenster, oder auch wissen, welches Fenster zu einem bestimmten Zeitpunkt aktiv ist. In diesem Fall können keine der <xref:System.Windows.Forms.Control.Focus%2A> Methode.  
  
 Die `AppActivate` Funktion verschiebt den Fokus auf das benannte Anwendung oder das Fenster, jedoch wirkt sich nicht, ob es maximiert oder minimiert wird. Der Fokus nicht auf dem Fenster für die aktivierte Anwendung, wenn der Benutzer einige Aktionen führt zu ändern oder das Fenster schließen. Sie können die `Shell` Funktion, um eine Anwendung starten, und legen Sie den Fensterstil.  
  
 Bei Verwendung der `Title` Parameter `AppActivate` verwendet einen Vergleich Groß-/Kleinschreibung, aber eine genaue Übereinstimmung mit dem Inhalt der Titelleiste erforderlich. Es sucht zuerst über das Fenster der obersten Ebene und anschließend über die untergeordneten Fenster. Wenn es keine Übereinstimmung finden kann, löst eine <xref:System.ArgumentException>.  
  
 Sie können `AppActivate` nur mit Prozessen, die Windows besitzen. Die meisten konsolenanwendungen besitzen Windows, d. h., die sie nicht, in der Liste der angezeigt werden, die Prozesse keine `AppActivate` sucht. Wenn Sie über eine Konsolenanwendung ausführen, wird das System erstellt einen separaten Prozess zum Ausführen der Anwendung und gibt die Ausgabe an den Konsolenprozess zurück. Daher, wenn Sie die aktuellen Prozess-ID anfordern, erhalten Sie die Prozess-ID, der dieser getrennte Prozess, anstatt die Konsolenanwendung Prozess-ID.  
  
 Zur Laufzeit die `AppActivate` Funktion aktiviert, jede aktive Anwendung mit einem Titel, entspricht `Title` oder mit einer Prozess-ID, die entspricht `ProcessId`. Wenn keine genaue Übereinstimmung vorhanden ist, wird jede Anwendung, endet die Titelzeichenfolge, deren mit, aktiviert `Title`. Wenn mehr als eine Anwendung mit dem Namen `Title`, `AppActivate` Funktion wählt nach dem Zufallsprinzip eine aktivieren.  
  
> [!NOTE]
>  Die `AppActivate` -Funktion erfordert `UIPermission` an die <xref:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows> Ebene, die die Ausführung in teilweise vertrauenswürdigen Umgebungen beeinträchtigen können. Weitere Informationen finden Sie unter <xref:System.Security.Permissions.UIPermission>.  
  
   
  
## Examples  
 Dieses Beispiel veranschaulicht verschiedene Verwendungen der der `AppActivate` Funktion, um ein Anwendungsfenster aktivieren. Wenn kein Editor-Prozess nicht ausgeführt wird, löst das Beispiel einer <xref:System.ArgumentException>. Die `Shell` Verfahren wird davon ausgegangen, die Anwendungen, die in den Pfaden, die angegeben werden.  
  
 [!code-vb[VbVbalrCatRef#11](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.Shell(System.String,Microsoft.VisualBasic.AppWinStyle,System.Boolean,System.Int32)" />
        <altmember cref="M:System.Windows.Forms.Control.Focus" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <Member MemberName="AppActivate">
      <MemberSignature Language="C#" Value="public static void AppActivate (string Title);" />
      <MemberSignature Language="ILAsm" Value=".method public static void AppActivate(string Title) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.AppActivate(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppActivate (Title As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AppActivate(System::String ^ Title);" />
      <MemberSignature Language="F#" Value="static member AppActivate : string -&gt; unit" Usage="Microsoft.VisualBasic.Interaction.AppActivate Title" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Title" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Title">
          <see langword="String" />-Ausdruck, der den Titel auf der Titelleiste der Anwendung angibt, die Sie aktivieren möchten. Sie können den der Anwendung beim Start zugewiesenen Titel verwenden.</param>
        <summary>Aktiviert eine Anwendung, die bereits ausgeführt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie `AppActivate` , das aktive Fenster einer Anwendung in den Fokus zu öffnen. Sie können kein Handle oder ein Verweis auf das aktive Fenster, oder auch wissen, welches Fenster zu einem bestimmten Zeitpunkt aktiv ist. In diesem Fall können keine der <xref:System.Windows.Forms.Control.Focus%2A> Methode.  
  
 Die `AppActivate` Funktion verschiebt den Fokus auf das benannte Anwendung oder das Fenster, jedoch wirkt sich nicht, ob es maximiert oder minimiert wird. Der Fokus nicht auf dem Fenster für die aktivierte Anwendung, wenn der Benutzer einige Aktionen führt zu ändern oder das Fenster schließen. Sie können die `Shell` Funktion, um eine Anwendung starten, und legen Sie den Fensterstil.  
  
 Bei Verwendung der `Title` Parameter `AppActivate` verwendet einen Vergleich Groß-/Kleinschreibung, aber eine genaue Übereinstimmung mit dem Inhalt der Titelleiste erforderlich. Es sucht zuerst über das Fenster der obersten Ebene und anschließend über die untergeordneten Fenster. Wenn es keine Übereinstimmung finden kann, löst eine <xref:System.ArgumentException>.  
  
 Sie können `AppActivate` nur mit Prozessen, die Windows besitzen. Die meisten konsolenanwendungen besitzen Windows, d. h., die sie nicht, in der Liste der angezeigt werden, die Prozesse keine `AppActivate` sucht. Wenn Sie über eine Konsolenanwendung ausführen, wird das System erstellt einen separaten Prozess zum Ausführen der Anwendung und gibt die Ausgabe an den Konsolenprozess zurück. Daher, wenn Sie die aktuellen Prozess-ID anfordern, erhalten Sie die Prozess-ID, der dieser getrennte Prozess, anstatt die Konsolenanwendung Prozess-ID.  
  
 Zur Laufzeit die `AppActivate` Funktion aktiviert, jede aktive Anwendung mit einem Titel, entspricht `Title` oder mit einer Prozess-ID, die entspricht `ProcessId`. Wenn keine genaue Übereinstimmung vorhanden ist, wird jede Anwendung, endet die Titelzeichenfolge, deren mit, aktiviert `Title`. Wenn mehr als eine Anwendung mit dem Namen `Title`, `AppActivate` Funktion wählt nach dem Zufallsprinzip eine aktivieren.  
  
> [!NOTE]
>  Die `AppActivate` -Funktion erfordert `UIPermission` an die <xref:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows> Ebene, die die Ausführung in teilweise vertrauenswürdigen Umgebungen beeinträchtigen können. Weitere Informationen finden Sie unter <xref:System.Security.Permissions.UIPermission>.  
  
   
  
## Examples  
 Dieses Beispiel veranschaulicht verschiedene Verwendungen der der `AppActivate` Funktion, um ein Anwendungsfenster aktivieren. Wenn kein Editor-Prozess nicht ausgeführt wird, löst das Beispiel einer <xref:System.ArgumentException>. Die `Shell` Verfahren wird davon ausgegangen, die Anwendungen, die in den Pfaden, die angegeben werden.  
  
 [!code-vb[VbVbalrCatRef#11](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.Shell(System.String,Microsoft.VisualBasic.AppWinStyle,System.Boolean,System.Int32)" />
        <altmember cref="M:System.Windows.Forms.Control.Focus" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <Member MemberName="Beep">
      <MemberSignature Language="C#" Value="public static void Beep ();" />
      <MemberSignature Language="ILAsm" Value=".method public static void Beep() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Beep" />
      <MemberSignature Language="VB.NET" Value="Public Sub Beep ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Beep();" />
      <MemberSignature Language="F#" Value="static member Beep : unit -&gt; unit" Usage="Microsoft.VisualBasic.Interaction.Beep " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Spielt einen Signalton über den Lautsprecher des Computers ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Zeichenbreite und die Dauer des Signaltons hängen von Ihrer Hardware und Software, und daher auf Computern unterschiedlich sein.  
  
> [!NOTE]
>  Die `Beep` -Funktion erfordert `UIPermission` an die <xref:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows> Ebene, die die Ausführung in teilweise vertrauenswürdigen Umgebungen beeinträchtigen können. Weitere Informationen finden Sie unter <xref:System.Security.Permissions.UIPermission>.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `Beep` Funktion, um einen Signalton über den Lautsprecher des Computers klingen.  
  
 [!code-vb[VbVbalrCatRef#59](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#59)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/visual-basic/language-reference/runtime-library-members.md">Member der Visual Basic-Laufzeitbibliothek</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/computer-resources/playing-sounds.md">Wiedergabe von Sound</related>
      </Docs>
    </Member>
    <Member MemberName="CallByName">
      <MemberSignature Language="C#" Value="public static object CallByName (object ObjectRef, string ProcName, Microsoft.VisualBasic.CallType UseCallType, params object[] Args);" />
      <MemberSignature Language="ILAsm" Value=".method public static object CallByName(object ObjectRef, string ProcName, valuetype Microsoft.VisualBasic.CallType UseCallType, object[] Args) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.CallByName(System.Object,System.String,Microsoft.VisualBasic.CallType,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CallByName (ObjectRef As Object, ProcName As String, UseCallType As CallType, ParamArray Args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CallByName(System::Object ^ ObjectRef, System::String ^ ProcName, Microsoft::VisualBasic::CallType UseCallType, ... cli::array &lt;System::Object ^&gt; ^ Args);" />
      <MemberSignature Language="F#" Value="static member CallByName : obj * string * Microsoft.VisualBasic.CallType * obj[] -&gt; obj" Usage="Microsoft.VisualBasic.Interaction.CallByName (ObjectRef, ProcName, UseCallType, Args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ObjectRef" Type="System.Object" />
        <Parameter Name="ProcName" Type="System.String" />
        <Parameter Name="UseCallType" Type="Microsoft.VisualBasic.CallType" />
        <Parameter Name="Args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="ObjectRef">Erforderlich. <see langword="Object" />. Ein Zeiger auf das Objekt, das die Eigenschaft oder Methode verfügbar macht.</param>
        <param name="ProcName">Erforderlich. <see langword="String" />. Ein Zeichenfolgenausdruck, der den Namen der Eigenschaft oder der Methode für das Objekt enthält.</param>
        <param name="UseCallType">Erforderlich. Ein Enumerationsmember vom Typ <see cref="T:Microsoft.VisualBasic.CallType" />, der den Typ der aufgerufenen Prozedur darstellt. Der Wert von <see langword="CallType" /> kann <see langword="Method" />, <see langword="Get" /> oder <see langword="Set" /> sein.</param>
        <param name="Args">Dies ist optional. <see langword="ParamArray" />. Ein Parameterarray mit den Argumenten, die an die aufgerufene Eigenschaft oder Methode übergeben werden sollen.</param>
        <summary>Führt eine Methode für ein Objekt aus oder legt eine Eigenschaft für ein Objekt fest oder gibt diese zurück.</summary>
        <returns>Führt eine Methode für ein Objekt aus oder legt eine Eigenschaft für ein Objekt fest oder gibt diese zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `CallByName` Funktion wird zur Laufzeit verwendet, um eine Eigenschaft abrufen, Festlegen einer Eigenschaft oder Aufrufen einer Methode.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die erste Zeile `CallByName` Festlegen der `Text` Eigenschaft eines Textfelds, die zweite Zeile ruft den Wert des der `Text` Eigenschaft und die dritte Zeile ruft die `Move` Methode, um das Textfeld zu verschieben.  
  
 [!code-vb[VbVbalrFunctions#99](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#99)]  
  
 [!code-vb[VbVbalrFunctions#20](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#20)]  
  
 Im nächsten Beispiel wird die `CallByName` aufzurufende Funktion in der `Add` und `Item` Methoden eines Objekts der Auflistung.  
  
 [!code-vb[VbVbalrFunctions#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ungültiger <paramref name="UseCallType" />-Wert; muss <see langword="Method" />, <see langword="Get" /> oder <see langword="Set" /> sein.</exception>
        <altmember cref="T:Microsoft.VisualBasic.CallType" />
        <altmember cref="T:System.ArgumentException" />
        <related type="Article" href="~/docs/visual-basic/programming-guide/language-features/procedures/parameter-arrays.md">Parameterarrays</related>
        <related type="Article" href="~/docs/visual-basic/programming-guide/language-features/early-late-binding/calling-a-property-or-method-using-a-string-name.md">Aufrufen einer Eigenschaft oder Methode mit einem Zeichenfolgennamen</related>
      </Docs>
    </Member>
    <Member MemberName="Choose">
      <MemberSignature Language="C#" Value="public static object Choose (double Index, params object[] Choice);" />
      <MemberSignature Language="ILAsm" Value=".method public static object Choose(float64 Index, object[] Choice) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Choose(System.Double,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Choose (Index As Double, ParamArray Choice As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Choose(double Index, ... cli::array &lt;System::Object ^&gt; ^ Choice);" />
      <MemberSignature Language="F#" Value="static member Choose : double * obj[] -&gt; obj" Usage="Microsoft.VisualBasic.Interaction.Choose (Index, Choice)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Index" Type="System.Double" />
        <Parameter Name="Choice" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="Index">Erforderlich. <see langword="Double" />. Numerischer Ausdruck, der einen Wert zwischen 1 und der Anzahl der im <paramref name="Choice" />-Argument übergebenen Elemente ergibt.</param>
        <param name="Choice">Erforderlich. <see langword="Object" />-Parameterarray. Sie können eine einzelne Variable oder einen Ausdruck, der den <see langword="Object" />-Datentyp ergibt, für eine durch Komma getrennte Liste von <see langword="Object" />-Variablen oder Ausdrücken oder für ein eindimensionales Array von <see langword="Object" />-Elementen angeben.</param>
        <summary>Wählt einen Wert aus einer Liste von Argumenten aus und gibt diesen zurück.</summary>
        <returns>Wählt einen Wert aus einer Liste von Argumenten aus und gibt diesen zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Choose` Funktionsergebnis ist ein Mitglied der übergebenen Liste `Choice()`basierend auf den Wert der `Index`. Das erste Element der Liste ausgewählt ist beim `Index` ist 1. Das letzte Element der Liste ausgewählt ist beim `Index` ist `UBound`(`Choice()`). Wenn `Index` außerhalb dieses Bereichs liegt, `Choose` gibt `Nothing`.  
  
 Wenn `Index` ist keine ganze Zahl, es wird auf die nächste ganze Zahl gerundet, vor der Auswertung.  
  
 Sie können `Choose` , um einen Wert in einer Liste von Möglichkeiten zu suchen.  
  
> [!NOTE]
>  Die Ausdrücke in der Argumentliste können Funktionsaufrufe enthalten. Bei der Vorbereitung der Argumentliste für den Aufruf von `Choose`, Visual Basic-Compiler jede Funktion in jedem Ausdruck aufgerufen wird. Dies bedeutet, dass Sie sich verlassen können nicht auf eine bestimmte Funktion nicht aufgerufen wird, wenn Sie ein anderen Ausdruck vom ausgewählten `Index`.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `Choose` Funktion einen Namen als Reaktion auf einen Index, an die Prozedur im übergeben an die `Ind` Parameter.  
  
 [!code-vb[VbVbalrFunctions#22](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#22)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.IIf(System.Boolean,System.Object,System.Object)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.Switch(System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/select-case-statement.md">Select...Case-Anweisung (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Command">
      <MemberSignature Language="C#" Value="public static string Command ();" />
      <MemberSignature Language="ILAsm" Value=".method public static string Command() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Command" />
      <MemberSignature Language="VB.NET" Value="Public Function Command () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Command();" />
      <MemberSignature Language="F#" Value="static member Command : unit -&gt; string" Usage="Microsoft.VisualBasic.Interaction.Command " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt den Argumentabschnitt der Befehlszeile zurück, mit der Visual Basic oder ein ausführbares Programm gestartet wird das mit Visual Basic entwickelt wurde. Das <see langword="My" />-Feature bietet höhere Produktivität und Leistung als die <see langword="Command" />-Funktion. Weitere Informationen finden Sie unter <see cref="P:Microsoft.VisualBasic.ApplicationServices.ConsoleApplicationBase.CommandLineArgs" />.</summary>
        <returns>Gibt den Argumentabschnitt der Befehlszeile zurück, mit der Visual Basic oder ein ausführbares Programm gestartet wird das mit Visual Basic entwickelt wurde.  
  
Das <see langword="My" />-Feature bietet höhere Produktivität und Leistung als die <see langword="Command" />-Funktion. Weitere Informationen finden Sie unter <see cref="P:Microsoft.VisualBasic.ApplicationServices.ConsoleApplicationBase.CommandLineArgs" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nachdem die Argumente zurückgegeben werden, können Sie suchen für allgemeine Trennzeichen, z. B. Leerzeichen, nach oben oder unten Schrägstriche, Bindestriche oder Anführungszeichen Teilen oder die Suchzeichenfolge für einzelne Parameter fest.  
  
 Für Anwendungen mit Visual Basic entwickelt und in eine .exe-Datei kompiliert die `Command` Funktionsergebnis ist keine Argumente, die nach dem Namen der Anwendung in der Befehlszeile aus, in diesem Formular angezeigt werden: `MyApp(cmdlineargs)`.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `Command` Funktion, um die Befehlszeilenargumente in einem Objekt zurückzugeben, die ein Array enthält.  
  
 [!code-vb[VbVbalrCatRef#58](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#58)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Environment.GetCommandLineArgs" />
        <altmember cref="P:Microsoft.VisualBasic.ApplicationServices.ConsoleApplicationBase.CommandLineArgs" />
        <related type="Article" href="~/docs/visual-basic/language-reference/runtime-library-members.md">Member der Visual Basic-Laufzeitbibliothek</related>
        <related type="Article" href="~/docs/visual-basic/reference/command-line-compiler/index.md">Visual Basic-Befehlszeilencompiler</related>
        <related type="Article" href="~/docs/visual-basic/programming-guide/program-structure/structure-of-a-visual-basic-program.md">Struktur von Visual Basic-Programmen</related>
      </Docs>
    </Member>
    <Member MemberName="CreateObject">
      <MemberSignature Language="C#" Value="public static object CreateObject (string ProgId, string ServerName = &quot;&quot;);" />
      <MemberSignature Language="ILAsm" Value=".method public static object CreateObject(string ProgId, string ServerName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.CreateObject(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateObject (ProgId As String, Optional ServerName As String = &quot;&quot;) As Object" />
      <MemberSignature Language="F#" Value="static member CreateObject : string * string -&gt; obj" Usage="Microsoft.VisualBasic.Interaction.CreateObject (ProgId, ServerName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ProgId" Type="System.String" />
        <Parameter Name="ServerName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="ProgId">Erforderlich. <see langword="String" />. Die Programm-ID des zu erstellenden Objekts.</param>
        <param name="ServerName">Dies ist optional. <see langword="String" />. Der Name des Netzwerkservers, auf dem das Objekt erstellt wird. Wenn <paramref name="ServerName" /> eine leere Zeichenfolge ("") ist, wird der lokale Computer verwendet.</param>
        <summary>Erstellt und gibt einen Verweis auf ein COM-Objekt zurück. <see langword="CreateObject" /> kann in Visual Basic nur dann zur Erstellung von Klasseninstanzen verwendet werden, wenn diese explizit als COM-Komponenten verfügbar gemacht werden.</summary>
        <returns>Erstellt und gibt einen Verweis auf ein COM-Objekt zurück. <see langword="CreateObject" /> kann in Visual Basic nur dann zur Erstellung von Klasseninstanzen verwendet werden, wenn diese explizit als COM-Komponenten verfügbar gemacht werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um eine Instanz einer COM-Komponente zu erstellen, weisen Sie das von zurückgegebene Objekt `CreateObject` einer Objektvariablen:  
  
```vb  
Sub CreateADODB()  
   Dim adoApp As Object  
   adoApp = CreateObject("ADODB.Connection")  
End Sub  
```  
  
 Die Objektvariable, die Sie zum Speichern des zurückgegebenen Objekts verwenden können die Leistung Ihrer Anwendung auswirken. Deklarieren einer Objektvariablen mit dem `As Object` -Klausel erstellt eine Variable, die einen Verweis auf jede Art von Objekt enthalten kann. Allerdings ist der Zugriff auf das Objekt über die Variable *spät gebundene*, d. h. die Bindung erfolgt, wenn das Programm ausgeführt wird. Es gibt viele Gründe, dass späten Bindung, einschließlich langsamer Leistung der Anwendung sollten.  
  
 Sie können eine Objektvariable, die frühe Bindung führt erstellen, die Bindung erfolgt, wenn das Programm kompiliert wird. Zu diesem Zweck fügen Sie einen Verweis auf die Typbibliothek für das Objekt aus der **COM** Registerkarte die **Verweis hinzufügen** Dialogfeld auf die **Projekt** Menü. Klicken Sie dann deklarieren Sie und des angegebenen Typs des Objekts. In den meisten Fällen ist es effizienter, mithilfe der `Dim` -Anweisung und eine primäre interop-Assembly, um Objekte zu erstellen, als es ist die Verwendung der `CreateObject` Funktion.  
  
## <a name="interacting-with-unmanaged-code"></a>Interaktion mit nicht verwaltetem Code  
 Ein weiteres Problem ist, dass die COM-Objekte nicht verwalteten Code verwenden, Code ohne den Vorteil, dass die common Language Runtime. Es ist ein Recht hohes Maß an Komplexität beim Mischen von den verwalteten Code von Visual Basic mit nicht verwaltetem Code aus COM. Wenn Sie einen Verweis auf ein COM-Objekt, durchsucht Visual Basic für eine primäre Interopassembly (PIA) für diese Bibliothek hinzufügen; Wenn es gefunden wird, verwendet sie diese. Wenn sie eine PIA nicht gefunden wird, erstellt dann eine Interop-Assembly, die lokalen Interoperabilitätsklassen für jede Klasse in der COM-Bibliothek enthält. Weitere Informationen finden Sie unter [COM-Interoperabilität in .NET Framework-Anwendungen](~/docs/visual-basic/programming-guide/com-interop/com-interoperability-in-net-framework-applications.md).  
  
 Sie sollten in der Regel stark gebundene Objekte und die primären Interop-Assemblys nach Möglichkeit verwenden. Die Beispiele unter Verwendung der `CreateObject` -Funktion mit Microsoft Office-Objekte für die Demo nur zu Testzwecken. Diese Objekte sind jedoch einfacher zu verwenden und die Zuverlässigkeit bei der Verwendung mit der entsprechenden primären Interopassembly.  
  
## <a name="creating-an-object-on-a-remote-computer"></a>Erstellen eines Objekts auf einem Remotecomputer  
 Erstellen Sie ein Objekt auf einem Remotecomputer im Netzwerk, durch Übergeben des Namens des Computers, auf die `ServerName` Argument der `CreateObject` Funktion. Dieser Name entspricht der Name des Computers, der einen Freigabenamen Teil: für eine Freigabe mit dem Namen "\\\MyServer\Public," `ServerName` ist "MyServer".  
  
> [!NOTE]
>  In der COM-Dokumentation (Siehe Microsoft Developer Network) Weitere Informationen zum Bereitstellen einer Anwendung auf einem Remotecomputer im Netzwerk zugegriffen werden kann. Sie müssen möglicherweise einen Registrierungsschlüssel für die Anwendung hinzuzufügen.  
  
 Der folgende Code gibt die Versionsnummer einer Instanz von Excel auf einem Remotecomputer mit dem Namen `MyServer`:  
  
```vb  
Sub CreateRemoteExcelObj()  
    Dim xlApp As Object  
    ' Replace string "\\MyServer" with name of the remote computer.  
    xlApp = CreateObject("Excel.Application", "\\MyServer")  
    MsgBox(xlApp.Version)  
End Sub  
```  
  
 Wenn der Name des Remoteservers falsch ist oder nicht verfügbar ist, ein Laufzeitfehler tritt.  
  
> [!NOTE]
>  Verwendung `CreateObject` , wenn keine aktuelle Instanz des Objekts vorhanden ist. Wenn bereits eine Instanz des Objekts ausgeführt wird, wird eine neue Instanz gestartet wird, und ein Objekt des angegebenen Typs erstellt wird. Verwenden Sie die aktuelle Instanz, oder um die Anwendung zu starten und damit eine Datei zu laden, verwenden Sie die `GetObject` Funktion. Wenn ein Objekt als Einzelinstanz-Objekt registriert hat, nur eine Instanz des Objekts wird erstellt, unabhängig davon, wie viele Male `CreateObject` ausgeführt wird.  
  
## <a name="creating-framework-objects"></a>Erstellen von .NET Framework-Objekte  
 Sie können die `CreateObject` Funktion nur zum Erstellen eines COM-Objekts. Es gibt zwar keine exakte äquivalenten Mechanismus zum Erstellen von .NET Framework-Objekt, das <xref:System.Activator> in die <xref:System> -Namespace enthält Methoden, um Objekte lokal oder remote zu erstellen. Insbesondere die <xref:System.Activator.CreateInstance%2A> Methode oder der <xref:System.Activator.CreateInstanceFrom%2A> Methode kann nützlich sein.  
  
> [!IMPORTANT]
>  Die `CreateObject` Funktion erfordert eine Berechtigung nicht verwalteten Code die Ausführung in teilweise vertrauenswürdigen Umgebungen auswirken. Weitere Informationen finden Sie unter <xref:System.Security.Permissions.SecurityPermission> und [Codezugriffsberechtigungen](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
   
  
## Examples  
 Im folgenden Beispiel wird die `CreateObject` Funktion, um ein Microsoft Excel-Arbeitsblatt zu erstellen, und speichert das Arbeitsblatt in einer Datei. Um dieses Beispiel verwenden zu können, muss Excel auf dem Computer installiert sein, in denen das Programm ausgeführt wird. Darüber hinaus müssen Sie einen Verweis auf die Typbibliothek aus hinzufügen der **COM** Registerkarte die **Verweis hinzufügen** Dialogfeld auf die **Projekt** Menü. Der Name der Typbibliothek variiert abhängig von der Version von Excel auf Ihrem Computer installiert. Die Typbibliothek für Microsoft Excel 2002 lautet z. B. **Microsoft Excel 10.0-Objektbibliothek**.  
  
 [!code-vb[VbVbalrExcelObject#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrExcelObject/VB/Class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception">Server ist nicht verfügbar</exception>
        <exception cref="T:System.IO.FileNotFoundException">Es ist kein Objekt des angegebenen Typs vorhanden.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.GetObject(System.String,System.String)" />
        <altmember cref="T:System.Exception" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:System.Activator" />
        <altmember cref="Overload:System.Activator.CreateInstance" />
        <altmember cref="Overload:System.Activator.CreateInstanceFrom" />
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/dim-statement.md">Dim-Anweisung (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/declare-statement.md">Declare Statement</related>
        <related type="Article" href="~/docs/visual-basic/programming-guide/com-interop/com-interoperability-in-net-framework-applications.md">COM-Interoperabilität in .NET Framework-Anwendungen</related>
        <related type="Article" href="~/docs/framework/interop/index.md">Interoperation mit nicht verwaltetem Code</related>
      </Docs>
    </Member>
    <Member MemberName="DeleteSetting">
      <MemberSignature Language="C#" Value="public static void DeleteSetting (string AppName, string Section = null, string Key = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static void DeleteSetting(string AppName, string Section, string Key) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.DeleteSetting(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteSetting (AppName As String, Optional Section As String = null, Optional Key As String = null)" />
      <MemberSignature Language="F#" Value="static member DeleteSetting : string * string * string -&gt; unit" Usage="Microsoft.VisualBasic.Interaction.DeleteSetting (AppName, Section, Key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AppName" Type="System.String" />
        <Parameter Name="Section" Type="System.String" />
        <Parameter Name="Key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AppName">Erforderlich. <see langword="String" />-Ausdruck mit dem Namen der Anwendung oder des Projekts, für die bzw. das der Abschnitt oder die Schlüsseleinstellung gilt.</param>
        <param name="Section">Erforderlich. <see langword="String" />-Ausdruck mit dem Namen des Abschnitts, aus dem die Schlüsseleinstellung gelöscht wird. Wenn nur <paramref name="AppName" /> und <paramref name="Section" /> bereitgestellt werden, wird der angegebene Abschnitt mit allen zugehörigen Schlüsseleinstellungen gelöscht.</param>
        <param name="Key">Dies ist optional. <see langword="String" />-Ausdruck mit dem Namen der Schlüsseleinstellung, die gelöscht wird.</param>
        <summary>Löscht einen Abschnitt oder eine Schlüsseleinstellung aus einen Anwendungseintrag in der Windows-Registrierung. Das <see langword="My" />-Feature bietet bei Registrierungsvorgängen höhere Produktivität und Leistung, als die <see langword="DeleteSetting" />-Funktion. Weitere Informationen finden Sie unter <see cref="P:Microsoft.VisualBasic.Devices.ServerComputer.Registry" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn alle Argumente bereitgestellt werden, wird die angegebene Einstellung gelöscht. Ein Laufzeitfehler tritt auf, wenn Sie versuchen, `DeleteSetting` auf einen nicht vorhandenen Abschnitt oder eine schlüsseleinstellung.  
  
 `DeleteSetting` erfordert, dass ein Benutzer angemeldet sein, da die Ausführung unter der `HKEY_LOCAL_USER` Registrierungsschlüssel, der nicht aktiv ist, wenn ein Benutzer interaktiv anmeldet.  
  
 Registrierungseinstellungen, die von einem nicht interaktiven Prozess (z. B. Mtx.exe) zugegriffen werden soll gespeichert werden soll, entweder unter der `HKEY_LOCAL_MACHINE\Software\` oder `HKEY_USER\DEFAULT\Software` Registrierungsschlüssel.  
  
   
  
## Examples  
 Im folgenden Beispiel wird zuerst verwendet die `SaveSetting` Verfahren, um Einträge in der Windows-Registrierung für die `MyApp` -Anwendung und verwendet dann die `DeleteSetting` Funktion, um sie zu entfernen. Da keine `Key` Argument angegeben wird, die gesamte `Startup` Abschnitt gelöscht, einschließlich der Name des Abschnitts und aller zugehörigen Schlüssel.  
  
 [!code-vb[VbVbalrCatRef#45](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#45)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Benutzer ist nicht angemeldet.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.GetAllSettings(System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.GetSetting(System.String,System.String,System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.SaveSetting(System.String,System.String,System.String,System.String)" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Environ">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt die zu einer Betriebssystem-Umgebungsvariablen gehörige Zeichenfolge zurück.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Environ">
      <MemberSignature Language="C#" Value="public static string Environ (int Expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static string Environ(int32 Expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Environ(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Environ (Expression As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Environ(int Expression);" />
      <MemberSignature Language="F#" Value="static member Environ : int -&gt; string" Usage="Microsoft.VisualBasic.Interaction.Environ Expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Expression" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="Expression">Erforderlich. Ausdruck, der entweder eine Zeichenfolge mit dem Namen einer Umgebungsvariablen oder eine ganze Zahl auswertet, die der numerischen Position einer Umgebungszeichenfolge in der Tabelle mit Umgebungszeichenfolgen entspricht.</param>
        <summary>Gibt die zu einer Betriebssystem-Umgebungsvariablen gehörige Zeichenfolge zurück.</summary>
        <returns>Gibt die zu einer Betriebssystem-Umgebungsvariablen gehörige Zeichenfolge zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `Expression` enthält eine Zeichenfolge, die <xref:Microsoft.VisualBasic.Interaction.Environ%2A> Funktion gibt den Text für die angegebene Umgebung-Zeichenfolge zurück – d. h. die hinter dem Gleichheitszeichen (=) in der Tabelle für diese Umgebungsvariable Text. Wenn die Zeichenfolge in `Expression` kann nicht gefunden werden, in der Tabelle, eine Zeichenfolge der Länge 0 (null) ("") wird zurückgegeben.  
  
 Wenn `Expression` enthält eine ganze Zahl, die Zeichenfolge, die belegt, dass die numerische Position in der Tabelle zurückgegeben wird. In diesem Fall <xref:Microsoft.VisualBasic.Interaction.Environ%2A> gibt alle von den Text, einschließlich der Name der Umgebungsvariablen zurück. Wenn keine Umgebungszeichenfolge vorhanden, in der angegebenen Position ist, <xref:Microsoft.VisualBasic.Interaction.Environ%2A> gibt eine Zeichenfolge der Länge 0 (null) zurück.  
  
> [!IMPORTANT]
>  Die <xref:Microsoft.VisualBasic.Interaction.Environ%2A> Funktion erfordert eine Umgebungsberechtigung für die Ausführung in teilweise vertrauenswürdigen Umgebungen auswirken. Weitere Informationen finden Sie unter <xref:System.Security.Permissions.SecurityPermission> und [Codezugriffsberechtigungen](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
   
  
## Examples  
 Dieses Beispiel verwendet die <xref:Microsoft.VisualBasic.Interaction.Environ%2A> Funktion, um die laufende Nummer und die Länge des angeben der `PATH` -Anweisung aus der Tabelle.  
  
 [!code-vb[VbVbalrCatRef#28](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Expression" /> fehlt.</exception>
        <altmember cref="T:System.ArgumentException" />
        <related type="Article" href="~/docs/visual-basic/language-reference/runtime-library-members.md">Member der Visual Basic-Laufzeitbibliothek</related>
      </Docs>
    </Member>
    <Member MemberName="Environ">
      <MemberSignature Language="C#" Value="public static string Environ (string Expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static string Environ(string Expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Environ(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Environ (Expression As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Environ(System::String ^ Expression);" />
      <MemberSignature Language="F#" Value="static member Environ : string -&gt; string" Usage="Microsoft.VisualBasic.Interaction.Environ Expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Expression" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Expression">Erforderlich. Ausdruck, der entweder eine Zeichenfolge mit dem Namen einer Umgebungsvariablen oder eine ganze Zahl auswertet, die der numerischen Position einer Umgebungszeichenfolge in der Tabelle mit Umgebungszeichenfolgen entspricht.</param>
        <summary>Gibt die zu einer Betriebssystem-Umgebungsvariablen gehörige Zeichenfolge zurück.</summary>
        <returns>Gibt die zu einer Betriebssystem-Umgebungsvariablen gehörige Zeichenfolge zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `Expression` enthält eine Zeichenfolge, die <xref:Microsoft.VisualBasic.Interaction.Environ%2A> Funktion gibt den Text für die angegebene Umgebung-Zeichenfolge zurück – d. h. die hinter dem Gleichheitszeichen (=) in der Tabelle für diese Umgebungsvariable Text. Wenn die Zeichenfolge in `Expression` kann nicht gefunden werden, in der Tabelle, eine Zeichenfolge der Länge 0 (null) ("") wird zurückgegeben.  
  
 Wenn `Expression` enthält eine ganze Zahl, die Zeichenfolge, die belegt, dass die numerische Position in der Tabelle zurückgegeben wird. In diesem Fall <xref:Microsoft.VisualBasic.Interaction.Environ%2A> gibt alle von den Text, einschließlich der Name der Umgebungsvariablen zurück. Wenn keine Umgebungszeichenfolge vorhanden, in der angegebenen Position ist, <xref:Microsoft.VisualBasic.Interaction.Environ%2A> gibt eine Zeichenfolge der Länge 0 (null) zurück.  
  
> [!IMPORTANT]
>  Die <xref:Microsoft.VisualBasic.Interaction.Environ%2A> Funktion erfordert eine Umgebungsberechtigung für die Ausführung in teilweise vertrauenswürdigen Umgebungen auswirken. Weitere Informationen finden Sie unter <xref:System.Security.Permissions.SecurityPermission> und [Codezugriffsberechtigungen](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
   
  
## Examples  
 Dieses Beispiel verwendet die <xref:Microsoft.VisualBasic.Interaction.Environ%2A> Funktion, um die laufende Nummer und die Länge des angeben der `PATH` -Anweisung aus der Tabelle.  
  
 [!code-vb[VbVbalrCatRef#28](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Expression" /> fehlt.</exception>
        <altmember cref="T:System.ArgumentException" />
        <related type="Article" href="~/docs/visual-basic/language-reference/runtime-library-members.md">Member der Visual Basic-Laufzeitbibliothek</related>
      </Docs>
    </Member>
    <Member MemberName="GetAllSettings">
      <MemberSignature Language="C#" Value="public static string[,] GetAllSettings (string AppName, string Section);" />
      <MemberSignature Language="ILAsm" Value=".method public static string[,] GetAllSettings(string AppName, string Section) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.GetAllSettings(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAllSettings (AppName As String, Section As String) As String(,)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^, 2&gt; ^ GetAllSettings(System::String ^ AppName, System::String ^ Section);" />
      <MemberSignature Language="F#" Value="static member GetAllSettings : string * string -&gt; string[,]" Usage="Microsoft.VisualBasic.Interaction.GetAllSettings (AppName, Section)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[,]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AppName" Type="System.String" />
        <Parameter Name="Section" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AppName">Erforderlich. <see langword="String" />-Ausdruck mit dem Namen der Anwendung oder des Projekts, deren bzw. dessen Schlüsseleinstellungen angefordert werden.</param>
        <param name="Section">Erforderlich. <see langword="String" />-Ausdruck mit dem Namen des Abschnitts, dessen Schlüsseleinstellungen angefordert werden. <see langword="GetAllSettings" /> gibt ein Objekt zurück, das ein zweidimensionales Zeichenfolgenarray enthält. Die Zeichenfolgen enthalten alle Schlüsseleinstellungen im angegebenen Abschnitt zuzüglich ihrer entsprechenden Werte.</param>
        <summary>Gibt eine Liste der Schlüsseleinstellungen eines Anwendungseintrags in der Windows-Registrierung mit ihren jeweiligen Werten (ursprünglich mit <see langword="SaveSetting" /> erstellt) zurück. Die Verwendung des <see langword="My" />-Features ermöglicht bei Registrierungsvorgängen höhere Produktivität und Leistung als <see langword="GetAllSettings" />. Weitere Informationen finden Sie unter <see cref="P:Microsoft.VisualBasic.Devices.ServerComputer.Registry" />.</summary>
        <returns>Gibt eine Liste der Schlüsseleinstellungen eines Anwendungseintrags in der Windows-Registrierung mit ihren jeweiligen Werten (ursprünglich mit <see langword="SaveSetting" /> erstellt) zurück.  
  
Die Verwendung des <see langword="My" />-Features ermöglicht bei Registrierungsvorgängen höhere Produktivität und Leistung als <see langword="GetAllSettings" />. Weitere Informationen finden Sie unter <see cref="P:Microsoft.VisualBasic.Devices.ServerComputer.Registry" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetAllSettings` Gibt ein nicht initialisiertes `Object` Wenn `AppName` oder `Section` ist nicht vorhanden.  
  
 Da die Ausführung unter der `HKEY_LOCAL_USER` Registrierungsschlüssel, der nicht aktiv ist, wenn ein Benutzer interaktiv anmeldet, `GetAllSettings` erfordert, dass ein Benutzer angemeldet sein.  
  
 Registrierungseinstellungen, die von einem nicht interaktiven Prozess (z. B. Mtx.exe) zugegriffen werden soll gespeichert werden soll, entweder unter der `HKEY_LOCAL_MACHINE\Software\` oder `HKEY_USER\DEFAULT\Software` Registrierungsschlüssel.  
  
   
  
## Examples  
 In diesem Beispiel verwendet zuerst die `SaveSetting` Funktion, um Einträge in der Windows-Registrierung für die angegebene Anwendung `AppName`, verwendet dann die `GetAllSettings` Funktion, um die Einstellungen anzuzeigen. Beachten Sie die Anwendung Namen und `Section` Namen können nicht abgerufen werden, mit `GetAllSettings`. Zum Schluss die `DeleteSetting` -Funktion entfernt Einträge der Anwendung.  
  
 [!code-vb[VbVbalrCatRef#68](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Benutzer ist nicht angemeldet.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.DeleteSetting(System.String,System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.GetSetting(System.String,System.String,System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.SaveSetting(System.String,System.String,System.String,System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/computer-resources/reading-from-and-writing-to-the-registry.md">Lesen aus der und Schreiben in die Registrierung (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="GetObject">
      <MemberSignature Language="C#" Value="public static object GetObject (string PathName = null, string Class = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static object GetObject(string PathName, string Class) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.GetObject(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetObject (Optional PathName As String = null, Optional Class As String = null) As Object" />
      <MemberSignature Language="F#" Value="static member GetObject : string * string -&gt; obj" Usage="Microsoft.VisualBasic.Interaction.GetObject (PathName, Class)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
        <Parameter Name="Class" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">Dies ist optional. <see langword="String" />. Der vollständige Pfad und Name der Datei, die das abzurufende Objekt enthält. Wenn <paramref name="PathName" /> nicht angegeben wird, ist <paramref name="Class" /> erforderlich.</param>
        <param name="Class">Erforderlich, wenn <paramref name="PathName" /> nicht angegeben wird. <see langword="String" />. Eine Zeichenfolge, die die Klasse des Objekts darstellt. Das <paramref name="Class" />-Argument verfügt über folgende Syntax und Bestandteile: 
 <c>anwendungsname</c><c>.</c><c>objekttyp</c>  
  
[1|1] Parameter 
[1|2] Beschreibung 
[2|1] <c>anwendungsname</c>  
  
[2|2] Erforderlich. <see langword="String" />. Der Name der Anwendung, die das Objekt bereitstellt.  
  
[3|1] <c>objekttyp</c>  
  
[3|2] Erforderlich. <see langword="String" />. Der Typ oder die Klasse des zu erstellenden Objekts.</param>
        <summary>Gibt einen Verweis auf ein von einer COM-Komponente bereitgestelltes Objekt zurück.</summary>
        <returns>Gibt einen Verweis auf ein von einer COM-Komponente bereitgestelltes Objekt zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der `GetObject` Funktion, um eine Instanz einer COM-Komponente aus einer Datei zu laden. Dies wird anhand des folgenden Beispiels veranschaulicht.  
  
```vb  
Dim CADObject As Object  
CADObject = GetObject("C:\CAD\schema.cad")  
```  
  
 Wenn dieser Code ausgeführt wird, die Anwendung mit dem angegebenen `PathName` gestartet wird und das Objekt in der angegebenen Datei ist aktiviert.  
  
## <a name="default-cases"></a>Standard  
 Wenn `PathName` ist eine Zeichenfolge der Länge 0 (null) (`""`), `GetObject` gibt eine neue Objektinstanz des angegebenen Klassentyps. Wenn die `PathName` Argument weggelassen wird, `GetObject` gibt ein derzeit aktives Objekt des Klassentyps, die im angegebenen `Class`. Wenn kein Objekt des angegebenen Typs vorhanden ist, tritt ein Fehler auf.  
  
## <a name="accessing-a-subobject"></a>Zugreifen auf ein Unterobjekt  
 Einige Anwendungen ermöglichen Ihnen, ein einer Datei zugeordnete Unterobjekt zu aktivieren. Zu diesem Zweck fügen Sie ein Ausrufezeichen (`!`) bis zum Ende des Dateinamens und führen Sie sie mit der eine Zeichenfolge, die Teil der Datei identifiziert, Sie aktivieren möchten. Informationen zum Erstellen dieser Zeichenfolge finden Sie in der Dokumentation für die Anwendung, die das Objekt erstellt.  
  
 Möglicherweise haben in einem Zeichenprogramm mehrere Ebenen auf eine Zeichnung, die in einer Datei gespeichert. Können den folgenden Code auf eine Ebene in einer Zeichnung namens `schema.cad`.  
  
```vb  
layerObject = GetObject("C:\CAD\schema.cad!Layer3")  
```  
  
## <a name="specifying-a-class"></a>Eine Klasse angeben  
 Wenn Sie keine des-Objekts angeben `Class`, Automatisierung der Anwendung zu starten und das Objekt zu aktivieren, basierend auf von Ihnen angegebene Dateiname bestimmt. Einige Dateien können jedoch mehr als eine Klasse des Objekts unterstützen. Eine Zeichnung könnte z. B. drei verschiedene Typen von Objekten unterstützen: eine `Application` Objekt eine `Drawing` Objekt und ein `Toolbar` Objekt, die in der gleichen Datei. Um anzugeben, welches Objekt in einer Datei, die Sie aktivieren möchten, verwenden Sie das optionale `Class` Argument. Dies wird anhand des folgenden Beispiels veranschaulicht.  
  
```vb  
Dim drawObj As Object  
drawObj = GetObject("C:\Drawings\sample.drw", "Figment.Drawing")  
```  
  
 Im vorherigen Beispiel `Figment` ist der Name des eine zeichenanwendung und `Drawing` ist eines der Objekttypen unterstützt.  
  
## <a name="using-the-object"></a>Mithilfe des-Objekts  
 Sobald ein Objekt aktiviert ist, verweisen Sie darauf, im Code mithilfe der Objektvariable, die Sie deklariert. Im vorherigen Beispiel aus, den Sie Eigenschaften und Methoden des neuen Objekts verwenden die Objektvariable zugreifen `drawObj`. Dies wird anhand des folgenden Beispiels veranschaulicht.  
  
```vb  
drawObj.Line(9, 90)  
drawObj.InsertText(9, 100, "Hello, world.")  
drawObj.SaveAs("C:\Drawings\sample.drw")  
```  
  
> [!NOTE]
>  Verwenden der `GetObject` funktionieren, wenn eine aktuelle Instanz des Objekts vorhanden ist, oder wenn Sie das Objekt mit einer geladenen Datei erstellen möchten. Wenn keine aktuelle Instanz vorhanden ist und nicht möchten, dass das Objekt, das den Einstieg eine Datei zu laden, verwenden Sie die <xref:Microsoft.VisualBasic.Interaction.CreateObject%2A> Funktion.  
>   
>  Wenn ein Objekt als ein ActiveX-Einzelinstanz-Objekt registriert hat, nur eine Instanz des Objekts wird erstellt, unabhängig davon, wie viele Male `CreateObject` aufgerufen wird. Mit einem Einzelinstanz-Objekt `GetObject` immer die gleiche Instanz bei einem Aufruf mit der Zeichenfolge der Länge 0 (null) zurück (`""`)-Syntax, und es tritt einen Fehler auf, wenn die `PathName` Argument ausgelassen wird. Sie können keine `GetObject` Abrufen eines Verweises auf eine Klasse, die mit Visual Basic erstellt.  
  
> [!IMPORTANT]
>  Die `GetObject` Funktion erfordert eine Berechtigung nicht verwalteten Code die Ausführung in teilweise vertrauenswürdigen Umgebungen auswirken. Weitere Informationen finden Sie unter <xref:System.Security.Permissions.SecurityPermission> und [Codezugriffsberechtigungen](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
   
  
## Examples  
 Im folgenden Beispiel wird die `GetObject` Funktion, um einen Verweis auf ein bestimmtes Microsoft Excel-Arbeitsblatt zu erhalten (`excelObj`). Er verwendet des Arbeitsblatts die `Application` Eigenschaft, um Excel sichtbar ist, um es zu schließen, und andere Aktionen ausführen. Mit zwei API-aufrufen, die `detectExcel` Prozedur sucht nach Excel, und wenn er ausgeführt wird, erhält sie in der Tabelle der ausgeführten Objekte. Der erste Aufruf `GetObject` verursacht einen Fehler aus, wenn Excel nicht bereits ausgeführt, die in diesem Beispiel bewirkt, dass die `excelWasNotRunning` Flag festgelegt sein, um `True`. Der zweite Aufruf von `GetObject` gibt eine Datei zu öffnen. Wenn Excel nicht bereits ausgeführt wird, wird der zweite Aufruf gestartet, und gibt einen Verweis auf das Arbeitsblatt, dargestellt durch die angegebene Datei `test.xls`. Die Datei muss am angegebenen Speicherort vorhanden. Andernfalls löst das Visual Basic eine <xref:System.IO.FileNotFoundException>. Anschließend werden der Beispielcode, Excel und das Fenster mit dem angegebenen Arbeitsblatt angezeigt.  
  
 Dieses Beispiel erfordert `Option Strict Off` da späte Bindung verwendet wird, in denen Objekte in Variablen des Typs zugewiesen `Object`. Können Sie angeben, `Option Strict On` und Objekte eines bestimmten Objekttyps zu deklarieren, wenn Sie einen Verweis auf das Excel-Typbibliothek hinzufügen der **COM** Registerkarte die **Verweis hinzufügen** im Dialogfeld die  **Projekt** Menü in Visual Studio.  
  
 [!code-vb[VbVbalrExcelObject#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrExcelObject/VB/Class1.vb#2)]  
  
 [!code-vb[VbVbalrExcelObject#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrExcelObject/VB/Class1.vb#4)]  
  
 [!code-vb[VbVbalrExcelObject#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrExcelObject/VB/Class1.vb#5)]  
  
 Beim Aufrufen der `getExcel` -Funktion wird überprüft, um festzustellen, ob Excel bereits ausgeführt wird. Wenn sie nicht der Fall ist, wird eine Instanz erstellt.  
  
> [!IMPORTANT]
>  Der Einfachheit halber im vorherige Beispiel wird davon ausgegangen, dass alle Fenster mit der Bezeichnung `XLMAIN` gehört zu einer Instanz von Microsoft Excel. Wenn ein anderes Objekt möglicherweise versehentlich gestartet wurde, ein Fenster mit diesem Namen erstellt, würde es alle Nachrichten empfangen, die Sie für Excel bestimmt sind. In einer Anwendung, die für die Produktion verwendet werden, sollte Sie enthalten, um sicherzustellen, dass einige gründlichere Tests `XLMAIN` wirklich in Excel gehört.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception">Es ist kein Objekt des angegebenen Klassentyps vorhanden.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Es ist kein Objekt mit dem angegebenen Pfad und Dateinamen vorhanden.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.CreateObject(System.String,System.String)" />
        <altmember cref="T:System.Exception" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/declare-statement.md">Declare Statement</related>
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/option-strict-statement.md">Option Strict Statement</related>
      </Docs>
    </Member>
    <Member MemberName="GetSetting">
      <MemberSignature Language="C#" Value="public static string GetSetting (string AppName, string Section, string Key, string Default = &quot;&quot;);" />
      <MemberSignature Language="ILAsm" Value=".method public static string GetSetting(string AppName, string Section, string Key, string Default) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.GetSetting(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSetting (AppName As String, Section As String, Key As String, Optional Default As String = &quot;&quot;) As String" />
      <MemberSignature Language="F#" Value="static member GetSetting : string * string * string * string -&gt; string" Usage="Microsoft.VisualBasic.Interaction.GetSetting (AppName, Section, Key, Default)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AppName" Type="System.String" />
        <Parameter Name="Section" Type="System.String" />
        <Parameter Name="Key" Type="System.String" />
        <Parameter Name="Default" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AppName">Erforderlich. <see langword="String" />-Ausdruck mit dem Namen der Anwendung oder des Projekts, deren bzw. dessen Schlüsseleinstellung angefordert wird.</param>
        <param name="Section">Erforderlich. <see langword="String" />-Ausdruck mit dem Namen des Abschnitts, in dem die Schlüsseleinstellung gefunden wird.</param>
        <param name="Key">Erforderlich. <see langword="String" />-Ausdruck mit dem Namen der Schlüsseleinstellung, die zurückgegeben werden soll.</param>
        <param name="Default">Dies ist optional. Ausdruck mit dem Wert, der zurückgegeben werden soll, wenn in der <paramref name="Key" />-Einstellung kein Wert festgelegt wird. Wenn <paramref name="Default" /> nicht angegeben wird, wird angenommen, dass es sich um eine Zeichenfolge der Länge 0 (null, "") handelt.</param>
        <summary>Gibt einen Schlüsseleinstellungswert eines Anwendungseintrags in der Windows-Registrierung zurück. Das <see langword="My" />-Feature bietet bei Registrierungsvorgängen höhere Produktivität und Leistung als <see langword="GetAllSettings" />. Weitere Informationen finden Sie unter <see cref="P:Microsoft.VisualBasic.Devices.ServerComputer.Registry" />.</summary>
        <returns>Gibt einen Schlüsseleinstellungswert eines Anwendungseintrags in der Windows-Registrierung zurück.  
  
Das <see langword="My" />-Feature bietet bei Registrierungsvorgängen höhere Produktivität und Leistung als <see langword="GetAllSettings" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn keines der Elemente in den Namen der `GetSetting` Argumente sind nicht vorhanden, `GetSetting` Rückgabewert `Default`.  
  
 Da die Ausführung unter der `HKEY_LOCAL_USER` Registrierungsschlüssel, der nicht aktiv ist, wenn ein Benutzer interaktiv anmeldet, `GetSetting` erfordert, dass ein Benutzer angemeldet sein.  
  
 Registrierungseinstellungen, die von einem nicht interaktiven Prozess (z. B. Mtx.exe) zugegriffen werden soll gespeichert werden soll, entweder unter der `HKEY_LOCAL_MACHINE\Software\` oder `HKEY_USER\DEFAULT\Software` Registrierungsschlüssel.  
  
 `GetSetting` erfordert `Read` <xref:System.Security.Permissions.RegistryPermission> .  
  
   
  
## Examples  
 In diesem Beispiel verwendet zuerst die `SaveSetting` Funktion, um Einträge in der Windows-Registrierung für die angegebene Anwendung `AppName`, und verwendet dann die `GetSetting` Funktion, um eine der Einstellungen anzuzeigen. Da die `Default` Argument angegeben ist, wird garantiert ein Wert zurückgegeben werden soll. Beachten Sie, dass `Section` Namen können nicht abgerufen werden, mit `GetSetting`. Zum Schluss die `DeleteSetting` -Funktion entfernt alle der Anwendung Einträge.  
  
 [!code-vb[VbVbalrCatRef#61](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#61)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Mindestens ein Argument ist kein <see langword="String" />-Ausdruck, oder der Benutzer ist nicht angemeldet.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.DeleteSetting(System.String,System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.GetAllSettings(System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.SaveSetting(System.String,System.String,System.String,System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.Security.Permissions.RegistryPermission" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/computer-resources/reading-from-and-writing-to-the-registry.md">Lesen aus der und Schreiben in die Registrierung (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="IIf">
      <MemberSignature Language="C#" Value="public static object IIf (bool Expression, object TruePart, object FalsePart);" />
      <MemberSignature Language="ILAsm" Value=".method public static object IIf(bool Expression, object TruePart, object FalsePart) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.IIf(System.Boolean,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function IIf (Expression As Boolean, TruePart As Object, FalsePart As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ IIf(bool Expression, System::Object ^ TruePart, System::Object ^ FalsePart);" />
      <MemberSignature Language="F#" Value="static member IIf : bool * obj * obj -&gt; obj" Usage="Microsoft.VisualBasic.Interaction.IIf (Expression, TruePart, FalsePart)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Expression" Type="System.Boolean" />
        <Parameter Name="TruePart" Type="System.Object" />
        <Parameter Name="FalsePart" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="Expression">Erforderlich. <see langword="Boolean" />. Der auszuwertende Ausdruck.</param>
        <param name="TruePart">Erforderlich. <see langword="Object" />. Wird zurückgegeben, wenn <paramref name="Expression" /> den Wert <see langword="True" /> ergibt.</param>
        <param name="FalsePart">Erforderlich. <see langword="Object" />. Wird zurückgegeben, wenn <paramref name="Expression" /> den Wert <see langword="False" /> ergibt.</param>
        <summary>Gibt eines von zwei Objekten zurück, abhängig von der Evaluierung eines Ausdrucks.</summary>
        <returns>Gibt eines von zwei Objekten zurück, abhängig von der Evaluierung eines Ausdrucks.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `IIf` Funktion bietet eine Entsprechung für den ternären [Bedingter Operator:?:](https://msdn.microsoft.com/library/88643ee8-7100-4f86-880a-705ec22b6271) in Visual C++.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `IIf` auszuwertende Funktion der `testMe` Parameter, der die `checkIt` Prozedur und gibt "Groß" If Word die Menge ist größer als 1000; andernfalls wird das Wort "Klein".  
  
 [!code-vb[VbVbalrFunctions#33](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#33)]  
  
 Beachten Sie, dass bei `Option Strict` ist `On`, verwenden Sie die `CStr` Schlüsselwort, um die Rückgabe von explizit konvertieren `Object` zu `String`.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.Choose(System.Double,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.Switch(System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/option-strict-statement.md">Option Strict Statement</related>
        <related type="Article" href="~/docs/visual-basic/language-reference/functions/type-conversion-functions.md">Type Conversion Functions</related>
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/if-then-else-statement.md">If...Then...Else-Anweisung (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/select-case-statement.md">Select...Case-Anweisung (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="InputBox">
      <MemberSignature Language="C#" Value="public static string InputBox (string Prompt, string Title = &quot;&quot;, string DefaultResponse = &quot;&quot;, int XPos = -1, int YPos = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static string InputBox(string Prompt, string Title, string DefaultResponse, int32 XPos, int32 YPos) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.InputBox(System.String,System.String,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function InputBox (Prompt As String, Optional Title As String = &quot;&quot;, Optional DefaultResponse As String = &quot;&quot;, Optional XPos As Integer = -1, Optional YPos As Integer = -1) As String" />
      <MemberSignature Language="F#" Value="static member InputBox : string * string * string * int * int -&gt; string" Usage="Microsoft.VisualBasic.Interaction.InputBox (Prompt, Title, DefaultResponse, XPos, YPos)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Prompt" Type="System.String" />
        <Parameter Name="Title" Type="System.String" />
        <Parameter Name="DefaultResponse" Type="System.String" />
        <Parameter Name="XPos" Type="System.Int32" />
        <Parameter Name="YPos" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="Prompt">Erforderlich. Als Meldung im Dialogfeld angezeigter <see langword="String" />-Ausdruck. Die maximale Länge von <paramref name="Prompt" /> beträgt ungefähr 1024 Zeichen, abhängig von der Breite der verwendeten Zeichen. Wenn <paramref name="Prompt" /> aus mehr als einer Zeile besteht, können Sie die Zeilen mit einem Wagenrücklaufzeichen (<see langword="Chr(" />13<see langword=")" />), mit einem Zeilenvorschubzeichen (<see langword="Chr(" />10<see langword=")" />) oder mit einer Kombination aus beiden (<see langword="Chr(" />13<see langword=")" /> &amp; <see langword="Chr(" />10<see langword=")" />) voneinander trennen.</param>
        <param name="Title">Dies ist optional. Auf der Titelleiste des Dialogfelds angezeigter <see langword="String" />-Ausdruck. Wenn Sie <paramref name="Title" /> nicht angeben, wird der Anwendungsname auf der Titelleiste platziert.</param>
        <param name="DefaultResponse">Dies ist optional. <see langword="String" />-Ausdruck, der im Textfeld standardmäßig angezeigt wird, wenn keine andere Eingabe erfolgt. Wenn Sie <paramref name="DefaultResponse" /> nicht angeben, ist das angezeigte Textfeld leer.</param>
        <param name="XPos">Dies ist optional. Numerischer Ausdruck, der den Abstand des linken Randes des Dialogfelds vom linken Rand des Bildschirms in Twips angibt. Wenn Sie <paramref name="XPos" /> nicht angeben, wird das Dialogfeld horizontal zentriert.</param>
        <param name="YPos">Dies ist optional. Numerischer Ausdruck, der den Abstand des oberen Randes des Dialogfelds vom oberen Rand des Bildschirms in Twips angibt. Wenn Sie <paramref name="YPos" /> nicht angeben, wird das Dialogfeld vertikal um etwa ein Drittel der Bildschirmhöhe nach unten verschoben.</param>
        <summary>Zeigt eine Eingabeaufforderung in einem Dialogfeld an, wartet auf die Eingabe eines Textes oder auf das Klicken auf eine Schaltfläche durch den Benutzer und gibt eine Zeichenfolge zurück, die den Inhalt des Textfelds angibt.</summary>
        <returns>Zeigt eine Eingabeaufforderung in einem Dialogfeld an, wartet auf die Eingabe eines Textes oder auf das Klicken auf eine Schaltfläche durch den Benutzer und gibt eine Zeichenfolge zurück, die den Inhalt des Textfelds angibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Benutzer klickt **Abbrechen**, eine Zeichenfolge der Länge 0 (null) zurückgegeben.  
  
 Um mehr als das erste Argument angegeben werden, müssen Sie verwenden die `InputBox` Funktion in einem Ausdruck. Wenn Sie keine positionellen Argumente auslassen, müssen Sie das entsprechende Kommatrennzeichen beibehalten.  
  
> [!NOTE]
>  Die `InputBox` -Funktion erfordert `UIPermission` an die <xref:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows> Ebene, die die Ausführung in teilweise vertrauenswürdigen Umgebungen beeinträchtigen können. Weitere Informationen finden Sie unter und <xref:System.Security.Permissions.UIPermission> .  
  
   
  
## Examples  
 Dieses Beispiel zeigt verschiedene Möglichkeiten zum Verwenden der `InputBox` Funktion, um den Benutzer auffordern, einen Wert eingeben. Wenn die x- und y Positionen werden ausgelassen, wird das Dialogfeld wird automatisch für die jeweiligen Achsen zentriert. Die Variable `MyValue` enthält den Wert, der vom Benutzer eingegeben wird, wenn der Benutzer auf OK klickt, oder die EINGABETASTE drückt.  
  
 [!code-vb[VbVbalrCatRef#67](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#67)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.MsgBox(System.Object,Microsoft.VisualBasic.MsgBoxStyle,System.Object)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Chr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.ChrW(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="MsgBox">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.MsgBoxResult MsgBox (object Prompt, Microsoft.VisualBasic.MsgBoxStyle Buttons = Microsoft.VisualBasic.MsgBoxStyle.ApplicationModal, object Title = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.MsgBoxResult MsgBox(object Prompt, valuetype Microsoft.VisualBasic.MsgBoxStyle Buttons, object Title) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.MsgBox(System.Object,Microsoft.VisualBasic.MsgBoxStyle,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function MsgBox (Prompt As Object, Optional Buttons As MsgBoxStyle = Microsoft.VisualBasic.MsgBoxStyle.ApplicationModal, Optional Title As Object = null) As MsgBoxResult" />
      <MemberSignature Language="F#" Value="static member MsgBox : obj * Microsoft.VisualBasic.MsgBoxStyle * obj -&gt; Microsoft.VisualBasic.MsgBoxResult" Usage="Microsoft.VisualBasic.Interaction.MsgBox (Prompt, Buttons, Title)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.MsgBoxResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Prompt" Type="System.Object" />
        <Parameter Name="Buttons" Type="Microsoft.VisualBasic.MsgBoxStyle" />
        <Parameter Name="Title" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="Prompt">Erforderlich. Als Meldung im Dialogfeld angezeigter <see langword="String" />-Ausdruck. Die maximale Länge von <paramref name="Prompt" /> beträgt ungefähr 1024 Zeichen, abhängig von der Breite der verwendeten Zeichen. Wenn <paramref name="Prompt" /> aus mehr als einer Zeile besteht, können Sie die Zeilen mit einem Wagenrücklaufzeichen (<see langword="Chr(" />13<see langword=")" />), mit einem Zeilenvorschubzeichen (<see langword="Chr(" />10<see langword=")" />) oder mit einer Kombination aus beiden (<see langword="Chr(" />13<see langword=")" /> &amp; <see langword="Chr(" />10<see langword=")" />) voneinander trennen.</param>
        <param name="Buttons">Dies ist optional. Numerischer Ausdruck, der die Summe der Werte für folgende Angaben darstellt: Anzahl und Art der anzuzeigenden Schaltflächen, Art des zu verwendenden Symbols, Angabe der Standardschaltfläche und Verhalten des Meldungsfelds. Wenn Sie <paramref name="Buttons" /> nicht angeben, ist der Standardwert 0 (null).</param>
        <param name="Title">Dies ist optional. Auf der Titelleiste des Dialogfelds angezeigter <see langword="String" />-Ausdruck. Wenn Sie <paramref name="Title" /> nicht angeben, wird der Anwendungsname auf der Titelleiste platziert.</param>
        <summary>Zeigt eine Meldung in einem Dialogfeld an und wartet darauf, dass der Benutzer auf eine Schaltfläche klickt. Anschließend wird eine ganze Zahl zurückgegeben, die angibt, auf welche Schaltfläche geklickt wurde.</summary>
        <returns>
          <list type="table">
            <item>
              <term> Konstante 
 </term>
              <description> Wert 
 </description>
            </item>
            <item>
              <term>
                <see langword="OK" />
              </term>
              <description> 1 
 </description>
            </item>
            <item>
              <term>
                <see langword="Cancel" />
              </term>
              <description> 2 
 </description>
            </item>
            <item>
              <term>
                <see langword="Abort" />
              </term>
              <description> 3 
 </description>
            </item>
            <item>
              <term>
                <see langword="Retry" />
              </term>
              <description> 4 
 </description>
            </item>
            <item>
              <term>
                <see langword="Ignore" />
              </term>
              <description> 5 
 </description>
            </item>
            <item>
              <term>
                <see langword="Yes" />
              </term>
              <description> 6 
 </description>
            </item>
            <item>
              <term>
                <see langword="No" />
              </term>
              <description> 7 
 </description>
            </item>
          </list>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie keine positionellen Argumente auslassen, müssen Sie das entsprechende Kommatrennzeichen beibehalten.  
  
 Wenn das Dialogfeld zeigt eine **Abbrechen** Schaltfläche Drücken der ESC-Taste hat dieselbe Wirkung wie das Klicken auf **Abbrechen**  
  
 Wenn Sie das Dialogfeld enthält einen **Hilfe** Schaltfläche kontextbezogene Hilfe wird bereitgestellt, um das Dialogfeld. Jedoch wird kein Wert zurückgegeben, bis eine der anderen Schaltflächen ausgewählt wird. In Windows Forms-Anwendungen, Auswahl der **helfen** Schaltfläche führt die <xref:System.Windows.Forms.Control.HelpRequested> -Ereignis für das Formular.  
  
> [!NOTE]
>  Die `MsgBox` -Funktion erfordert `UIPermission` an die <xref:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows> Ebene, die die Ausführung in teilweise vertrauenswürdigen Umgebungen beeinträchtigen können. Weitere Informationen finden Sie unter <xref:System.Security.Permissions.UIPermission>.  
  
 Die `MsgBoxStyle` Enumerationswerte sind in der folgenden Tabelle aufgeführt.  
  
|Member|Wert|Beschreibung |  
|-|-|-|  
|Member|Wert|Beschreibung |  
|`OKOnly`|0|Nur zeigt OK-Schaltfläche.|  
|`OKCancel`|1|Werden OK und Abbrechen Schaltflächen angezeigt.|  
|`AbortRetryIgnore`|2|Zeigt Schaltflächen Abbrechen, wiederholen und ignorieren an.|  
|`YesNoCancel`|3|Zeigt Ja, Nein und Abbrechen (Schaltflächen).|  
|`YesNo`|4|Zeigt Schaltflächen Ja und Nein.|  
|`RetryCancel`|5|Zeigt die Schaltflächen wiederholen und Abbrechen.|  
|`Critical`|16|Symbol für wichtige Meldungen angezeigt.|  
|`Question`|32|Fragezeichen-Symbol angezeigt.|  
|`Exclamation`|48|Zeigt das Symbol Warnung an.|  
|`Information`|64|Zeigt das Symbol Informationen an.|  
|`DefaultButton1`|0|Erste Schaltfläche ist Standard.|  
|`DefaultButton2`|256|Zweite Schaltfläche ist Standard.|  
|`DefaultButton3`|512|Dritte Schaltfläche ist Standard.|  
|`ApplicationModal`|0|Anwendung ist modal. Der Benutzer muss in der MessageBox vor dem Fortsetzen der Arbeit in der aktuellen Anwendung reagieren.|  
|`SystemModal`|4096|Modal ist. Alle Anwendungen werden angehalten, bis der Benutzer in der MessageBox reagiert.|  
|`MsgBoxSetForeground`|65536|Gibt das Meldungsfenster als das Vordergrundfenster an.|  
|`MsgBoxRight`|524288|Text wird rechtsbündig ausgerichtet.|  
|`MsgBoxRtlReading`|1048576|Gibt an, dass Text wie rechts-nach-links für die hebräische und arabische Systeme lesen angezeigt werden soll.|  
  
 Die erste Gruppe von Werten (0-5) wird beschrieben, die Anzahl und Art von Schaltflächen, die Sie im Dialogfeld angezeigt. Die zweite Gruppe (16, 32, 48, 64) wird das Symbolformat beschrieben. Die dritte Gruppe (0, 256, 512) bestimmt, welche Schaltfläche die Standardschaltfläche ist. Die vierte Gruppe ("0", "4096") bestimmt die Modalität des Meldungsfelds aus, und die fünfte Gruppe gibt an, ob das Meldungsfenster das Vordergrundfenster, zusammen mit der Ausrichtung und die Richtung des Texts ist. Beim Hinzufügen von Zahlen zu einen endgültigen Wert für die `Buttons` Argument verwenden nur eine Zahl aus jeder Gruppe.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `MsgBox` Funktion, um einen schwerwiegenden Fehler Nachricht in einem Dialogfeld mit den Schaltflächen Ja und Nein anzuzeigen. Die Schaltfläche "Nein" wird als die standardmäßige Antwort angegeben. Dies erfolgt durch Kombinieren der `MsgBox` Konstante Werte, die in einem numerischen Ausdruck. In diesem Fall das Addieren von 4 (das Ja/Nein) und 16 (der **wichtige Meldung** Fenster) und 256 (die zweite Schaltfläche als Standardschaltfläche) ergibt eine Gesamtsumme von 276. Der Rückgabewert von der `MsgBox` Funktion abhängig ist, auf die Schaltfläche, die vom Benutzer ausgewählten: Ja gibt einen Wert von 6; Nein gibt den Wert 7 zurück.  
  
 [!code-vb[VbVbalrCatRef#20](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Prompt" /> ist kein <see langword="String" />-Ausdruck, oder <paramref name="Title" /> ist ungültig.</exception>
        <exception cref="T:System.InvalidOperationException">Der Prozess wird nicht im interaktiven Modus ausgeführt.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Ein oder mehrere Parameter ist bzw. sind kein/e Member der <see langword="MsgBoxResult" />-Enumeration oder der <see langword="MsgBoxStyle" />-Enumeration.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.InputBox(System.String,System.String,System.String,System.Int32,System.Int32)" />
        <altmember cref="M:System.Windows.Forms.MessageBox.Show(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Partition">
      <MemberSignature Language="C#" Value="public static string Partition (long Number, long Start, long Stop, long Interval);" />
      <MemberSignature Language="ILAsm" Value=".method public static string Partition(int64 Number, int64 Start, int64 Stop, int64 Interval) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Partition(System.Int64,System.Int64,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Partition (Number As Long, Start As Long, Stop As Long, Interval As Long) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Partition(long Number, long Start, long Stop, long Interval);" />
      <MemberSignature Language="F#" Value="static member Partition : int64 * int64 * int64 * int64 -&gt; string" Usage="Microsoft.VisualBasic.Interaction.Partition (Number, Start, Stop, Interval)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Number" Type="System.Int64" />
        <Parameter Name="Start" Type="System.Int64" />
        <Parameter Name="Stop" Type="System.Int64" />
        <Parameter Name="Interval" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="Number">Erforderlich. <see langword="Long" />. Ganze Zahl, die Sie in einem der berechneten Bereiche suchen möchten.</param>
        <param name="Start">Erforderlich. <see langword="Long" />. Ganze Zahl, die den Anfang der Reihe berechneter Bereiche angibt. <paramref name="Start" /> darf nicht kleiner als 0 sein.</param>
        <param name="Stop">Erforderlich. <see langword="Long" />. Ganze Zahl, die das Ende der Reihe berechneter Bereiche angibt. <paramref name="Stop" /> darf nicht kleiner oder gleich <paramref name="Start" /> sein.</param>
        <param name="Interval">Erforderlich. <see langword="Long" />. Ganze Zahl, die die Größe jedes berechneten Bereichs zwischen <paramref name="Start" /> und <paramref name="Stop" /> angibt. <paramref name="Interval" /> darf nicht kleiner als 1 sein.</param>
        <summary>Gibt eine Zeichenfolge zurück, die den berechneten Bereich darstellt, der eine Zahl enthält.</summary>
        <returns>Gibt eine Zeichenfolge zurück, die den berechneten Bereich darstellt, der eine Zahl enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Partition` -Funktion berechnet eine Reihe von numerischen Bereiche, jeweils die Anzahl der angegebenen Werte von `Interval`. Der erste Bereich beginnt bei `Start`, und der letzte Bereich endet am `Stop`. Die `Partition` Funktion anschließend identifiziert die Bereich enthält `Number` und gibt eine Zeichenfolge, die diesen Bereich zurück. Der Bereich wird dargestellt, in der Zeichenfolge als "*Lowervalue*:*Uppervalue*", wobei die niedrigen Ende des Bereichs (*Lowervalue*) von high-End getrennt ist ( *Uppervalue*) durch einen Doppelpunkt (:).  
  
 Bei Bedarf die `Partition` Funktion fügt führende Leerzeichen vor dem *Lowervalue* und *Uppervalue* , damit sie beide die gleiche Anzahl von Zeichen wie die Zeichenfolgendarstellung der () Wert haben `Stop` + 1). Dadurch wird sichergestellt, dass bei Verwendung die Ausgabe der `Partition` -Funktion mit mehreren Werten `Number`, der resultierende Text wird bei nachfolgenden Sortiervorgängen ordnungsgemäß behandelt werden.  
  
 Die folgende Tabelle zeigt einige Beispielzeichenfolgen für Bereiche, die mit drei berechnet `Start`, `Stop`, und `Interval`. Die "Zuerst den Bereich" und die Spalten "Letzter Bereich" der niedrigste und höchste mögliche angezeigt angegebenen Werte von `Start` und `Stop`. Die "vor dem ersten Bereich" und "nach den letzten Bereich" wird durch Spalten enthalten, die Zeichenfolgen, die für Werte der zurückgegebenen `Number` kleiner als `Start` und größer als `Stop`bzw.  
  
|`Start`|`Stop`|`Interval`|Vor dem ersten Bereich|Erste Bereich|Letzte Bereich|Nach den letzten Bereich|  
|-|-|-|-|-|-|-|  
|0|99|5|"   : -1"|"0: 4"|"95: 99"|"100:   "|  
|20|199|10|": 19-Zoll|"20:29"|"190:199"|"200:"|  
|100|1010|20|": 99"|"100: 119"|"1000:1010"|"1011:    "|  
  
 In der vorangegangenen Tabelle die dritte Zeile zeigt das Ergebnis beim `Start` und `Stop` definieren einen Satz von Zahlen, die durch Dividieren keine `Interval`. Der letzte Bereich endet am `Stop`, sodass nur 11 Zahlen lang sein, obwohl `Interval` ist 20.  
  
 Wenn `Interval` 1 ist, wird der Bereich "`Number`:`Number`", unabhängig von der `Start` und `Stop` Argumente. Z. B. wenn `Number` ist 267, `Stop` ist 1000. und `Interval` ist 1, `Partition` "267: 267" zurückgegeben.  
  
 `Partition` kann hilfreich sein, wenn Datenbankabfragen zu erstellen. Sie können eine SELECT-Abfrage erstellen, die zeigt, wie viele Bestellungen werden verschiedene Wertebereiche, z. B. mit der Rechnungswerte zwischen 1 und 1000, 1001 auf 2000 und so weiter.  
  
   
  
## Examples  
 Das folgende Beispiel richtet eine Reihe von Bereichen seit Jahrzehnten von 1950 bis 2049. Sucht den Wert der `year` im entsprechenden Bereich und gibt eine `String` Wert, der den Bereich angibt. Wenn `year` hat den Wert 1984, z. B. `Partition` "1980: 1989 zurück" zurückgegeben.  
  
 [!code-vb[VbVbalrFunctions#45](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#45)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Start" /> &lt; 0, <paramref name="Stop" /> &lt;= <paramref name="Start" />, oder <paramref name="Interval" /> &lt; 1.</exception>
      </Docs>
    </Member>
    <Member MemberName="SaveSetting">
      <MemberSignature Language="C#" Value="public static void SaveSetting (string AppName, string Section, string Key, string Setting);" />
      <MemberSignature Language="ILAsm" Value=".method public static void SaveSetting(string AppName, string Section, string Key, string Setting) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.SaveSetting(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SaveSetting (AppName As String, Section As String, Key As String, Setting As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SaveSetting(System::String ^ AppName, System::String ^ Section, System::String ^ Key, System::String ^ Setting);" />
      <MemberSignature Language="F#" Value="static member SaveSetting : string * string * string * string -&gt; unit" Usage="Microsoft.VisualBasic.Interaction.SaveSetting (AppName, Section, Key, Setting)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AppName" Type="System.String" />
        <Parameter Name="Section" Type="System.String" />
        <Parameter Name="Key" Type="System.String" />
        <Parameter Name="Setting" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AppName">Erforderlich. <see langword="String" />-Ausdruck mit dem Namen der Anwendung oder des Projekts, für die bzw. das die Einstellung gilt.</param>
        <param name="Section">Erforderlich. <see langword="String" />-Ausdruck mit dem Namen des Abschnitts, in dem die Schlüsseleinstellung gespeichert wird.</param>
        <param name="Key">Erforderlich. <see langword="String" />-Ausdruck mit dem Namen der Schlüsseleinstellung, die gespeichert wird.</param>
        <param name="Setting">Erforderlich. Ausdruck mit dem Wert, auf den <paramref name="Key" /> festgelegt wird.</param>
        <summary>Speichert oder erstellt einen Anwendungseintrag in der Windows-Registrierung. Das <see langword="My" />-Feature bietet bei Registrierungsvorgängen höhere Produktivität und Leistung als <see langword="SaveSetting" />. Weitere Informationen finden Sie unter <see cref="P:Microsoft.VisualBasic.Devices.ServerComputer.Registry" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `SaveSetting` Funktion fügt die Taste, um `HKEY_CURRENT_USER\Software\VB and VBA Program Settings`.  
  
 Wenn die schlüsseleinstellung aus irgendeinem Grund nicht gespeichert werden kann, tritt ein Fehler auf.  
  
 `SaveSetting` erfordert, dass ein Benutzer angemeldet sein, da die Ausführung unter der `HKEY_LOCAL_USER` Registrierungsschlüssel, der nicht aktiv ist, wenn ein Benutzer interaktiv anmeldet.  
  
 Registrierungseinstellungen, die von einem nicht interaktiven Prozess (z. B. Mtx.exe) zugegriffen werden soll gespeichert werden soll, entweder unter der `HKEY_LOCAL_MACHINE\Software\` oder `HKEY_USER\DEFAULT\Software` Registrierungsschlüssel.  
  
 `SaveSetting` erfordert `Write` und `Create` <xref:System.Security.Permissions.RegistryPermission> .  
  
   
  
## Examples  
 Im folgenden Beispiel wird zuerst verwendet die `SaveSetting` Funktion, um Einträge in der Windows-Registrierung für die `MyApp` -Anwendung und verwendet dann die `DeleteSetting` Funktion, um sie zu entfernen.  
  
 [!code-vb[VbVbalrCatRef#56](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#56)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Schlüsselregistrierung konnte nicht erstellt werden, oder Benutzer ist nicht angemeldet.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.DeleteSetting(System.String,System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.GetAllSettings(System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.GetSetting(System.String,System.String,System.String,System.String)" />
        <altmember cref="T:System.Security.Permissions.RegistryPermission" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/computer-resources/reading-from-and-writing-to-the-registry.md">Lesen aus der und Schreiben in die Registrierung (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Shell">
      <MemberSignature Language="C#" Value="public static int Shell (string Pathname, Microsoft.VisualBasic.AppWinStyle Style = Microsoft.VisualBasic.AppWinStyle.MinimizedFocus, bool Wait = false, int Timeout = -1);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 Shell(string Pathname, valuetype Microsoft.VisualBasic.AppWinStyle Style, bool Wait, int32 Timeout) cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Shell(System.String,Microsoft.VisualBasic.AppWinStyle,System.Boolean,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Shell (Pathname As String, Optional Style As AppWinStyle = Microsoft.VisualBasic.AppWinStyle.MinimizedFocus, Optional Wait As Boolean = false, Optional Timeout As Integer = -1) As Integer" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="F#" Value="static member Shell : string * Microsoft.VisualBasic.AppWinStyle * bool * int -&gt; int" Usage="Microsoft.VisualBasic.Interaction.Shell (Pathname, Style, Wait, Timeout)" FrameworkAlternate="netframework-1.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C#" Value="public static int Shell (string PathName, Microsoft.VisualBasic.AppWinStyle Style = Microsoft.VisualBasic.AppWinStyle.MinimizedFocus, bool Wait = false, int Timeout = -1);" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 Shell(string PathName, valuetype Microsoft.VisualBasic.AppWinStyle Style, bool Wait, int32 Timeout) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="VB.NET" Value="Public Function Shell (PathName As String, Optional Style As AppWinStyle = Microsoft.VisualBasic.AppWinStyle.MinimizedFocus, Optional Wait As Boolean = false, Optional Timeout As Integer = -1) As Integer" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="F#" Value="static member Shell : string * Microsoft.VisualBasic.AppWinStyle * bool * int -&gt; int" Usage="Microsoft.VisualBasic.Interaction.Shell (PathName, Style, Wait, Timeout)" FrameworkAlternate="netframework-2.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Pathname" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1" />
        <Parameter Name="PathName" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="Style" Type="Microsoft.VisualBasic.AppWinStyle" Index="1" />
        <Parameter Name="Wait" Type="System.Boolean" Index="2" />
        <Parameter Name="Timeout" Type="System.Int32" Index="3" />
      </Parameters>
      <Docs>
        <param name="PathName">Erforderlich. <see langword="String" />. Name des auszuführenden Programms zusammen mit allen erforderlichen Argumenten und Befehlszeilenschaltern. <paramref name="PathName" /> kann auch das Laufwerk und den Verzeichnispfad bzw. den Ordner beinhalten.  
  
Wenn Sie den Pfad zum Programm nicht kennen, können Sie ihn mit <see cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.GetFiles" /> ermitteln. Sie können beispielsweise <c>My.Computer.FileSystem.GetFiles ("C:\", TRUE, "testFile.txt")</c> aufrufen, was den vollständigen Pfad jeder Datei mit dem Namen <c>testFile.txt</c> zurückgibt, die sich an beliebiger Stelle auf Laufwerk C:\\ befindet.</param>
        <param name="Pathname">To be added.</param>
        <param name="Style">Dies ist optional. <see langword="AppWinStyle" />. Ein aus dem <see cref="T:Microsoft.VisualBasic.AppWinStyle" /> ausgewählter Wert, der das Format des Fensters angibt, in dem das Programm ausgeführt werden soll. Wenn <paramref name="Style" /> nicht angegeben wird, verwendet <see langword="Shell" /><see langword="AppWinStyle.MinimizedFocus" />, wodurch das Programm minimiert und mit dem Fokus gestartet wird.</param>
        <param name="Wait">Dies ist optional. <see langword="Boolean" />. Ein Wert, der angibt, ob die <see langword="Shell" />-Funktion auf den Abschluss des Programms warten soll. Wenn <paramref name="Wait" /> nicht angegeben wird, verwendet <see langword="Shell" /> den Wert <see langword="False" />.</param>
        <param name="Timeout">Dies ist optional. <see langword="Integer" />. Die Anzahl von Millisekunden, die auf den Abschluss gewartet werden soll, wenn <paramref name="Wait" /> den Wert <see langword="True" /> hat. Wenn <paramref name="Timeout" /> nicht angegeben wird, verwendet <see langword="Shell" /> den Wert -1. Das bedeutet, dass es kein Timeout gibt und eine Rückgabe von <see langword="Shell" /> erst nach Beendigung des Programms erfolgt. Wenn Sie daher <paramref name="Timeout" /> nicht angeben oder auf -1 festlegen, ist es möglich, dass <see langword="Shell" /> die Steuerung niemals an Ihr Programm zurückgibt.</param>
        <summary>Führt ein ausführbares Programm aus und gibt eine ganze Zahl mit der Prozess-ID des Programms zurück, sofern es noch ausgeführt wird.</summary>
        <returns>Führt ein ausführbares Programm aus und gibt eine ganze Zahl mit der Prozess-ID des Programms zurück, sofern es noch ausgeführt wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Rückgabewert von der `Shell` Funktion, hängt davon ab, ob das Programm in den Namen `PathName` noch ausgeführt wird, wenn `Shell` zurückgibt. Setzen Sie `Wait` zu `True` und das Programm, das abgeschlossen wird, bevor das Timeout abläuft, `Shell` gibt NULL zurück. Wenn das Timeout abläuft, oder wenn Sie weglassen `Wait` oder legen ihn auf `False`, `Shell` gibt die Prozess-ID des Programms. Die Prozess-ID ist eine eindeutige Zahl, die die programmausführung identifiziert.  
  
## <a name="failure-to-start"></a>Fehler beim Start  
 Wenn die `Shell` Funktion kann nicht gestartet werden das genannte Programm, eine <xref:System.IO.FileNotFoundException> Fehler auftritt. Dies kann z. B. der Fall, wenn Sie versuchen, eine 16-Bit-Programm ausgeführt, z. B. `command.com`, aus einer Anwendung mit <xref:System.Windows.Forms?displayProperty=nameWithType>. Für dieses Problem zu umgehen können Sie ein 32-Bit-Programm ausführen, die die gewünschte 16-Bit-Anwendung aufruft. Im Fall von `command.com`, können Sie ausführen, `cmd.exe` als Alternative.  
  
## <a name="waiting-for-completion"></a>Warten auf Abschluss  
 In der Standardeinstellung die `Shell` Funktion führt das Programm asynchron. Dies bedeutet, dass ein Programm gestartet, mit der `Shell` Funktion kann nicht beendet werden ausgeführt, bevor Sie die folgenden Anweisungen die `Shell` Funktion ausgeführt werden. Wenn Sie warten möchten, damit das Programm beendet werden, bevor Sie fortfahren, legen Sie `Wait` zu `True`.  
  
## <a name="determining-the-exit-code"></a>Festlegen des Exitcodes  
 Ein Prozess kann Zurückgeben einer *Exitcode* wenn er beendet wird. Allerdings können keine `Shell` zu diesem Code beenden abgerufen werden, da `Shell` gibt 0 (null), wenn es auf die Beendigung wartet und, da der Prozess ausgeführt wird, in einem anderen Objekt aus `Shell`.  
  
 Um den Exitcode aus einem Prozess abzurufen, müssen Sie Ihren eigenen Code, um den Prozess zu initiieren, und warten Sie, für die Beendigung schreiben. Das folgende Beispiel zeigt, wie Sie einen Prozess zu initiieren, warten Sie, bis es beendet und sein Exitcode abgerufen wird.  
  
```vb  
Dim procID As Integer  
Dim newProc As Diagnostics.Process  
newProc = Diagnostics.Process.Start("C:\WINDOWS\NOTEPAD.EXE")  
procID = newProc.Id  
newProc.WaitForExit()  
Dim procEC As Integer = -1  
If newProc.HasExited Then  
    procEC = newProc.ExitCode  
End If  
MsgBox("Process with ID " & CStr(ProcID) & _  
    " terminated with exit code " & CStr(procEC))  
```  
  
## <a name="protecting-the-file-specification"></a>Die Dateispezifikation schützen  
 Sie sollten immer die gesamte Spezifikation der Pfad und Dateinamen in Anführungszeichen ein, wie im folgenden Beispiel gezeigt einschließen.  
  
```vb  
ID = Shell("""C:\Program Files\display.exe"" -a -q", , True, 100000)  
```  
  
 Jedes Paar von aufeinander folgenden doppelten Anführungszeichen (`" "`) innerhalb der Zeichenfolge Literal als ein doppeltes Anführungszeichen in der Zeichenfolge interpretiert. Daher wird im vorherige Beispiel die folgende Zeichenfolge, die die `Shell` Funktion:  
  
```console  
"C:\Program Files\display.exe" -a -q  
```  
  
 Wenn Sie nicht den Pfad in Anführungszeichen eingeschlossen haben, sieht Windows für eine Datei namens `Program.exe` im Verzeichnis C:\ anstelle von `display.exe` im Verzeichnis C:\Program Files.  
  
> [!IMPORTANT]
>  Wenn Sie nicht die Spezifikation Pfad und Dateinamen in Anführungszeichen einschließen, ist ein Sicherheitsrisiko dar, wenn der Dateiname oder einem Pfadknoten Leerzeichen enthält. Im vorherigen Beispiel, das Pfadknoten `\Program Files` ein Leerzeichen enthält. Wenn die Spezifikation nicht in Anführungszeichen ein, und ein Programm namens `Program.exe` in "c:" installiert worden war\\, z. B. widerrechtlich Windows führt diesen anstelle von `display.exe`.  
  
> [!IMPORTANT]
>  Die `Shell` Funktion erfordert eine Berechtigung nicht verwalteten Code die Ausführung in teilweise vertrauenswürdigen Umgebungen auswirken. Weitere Informationen finden Sie unter <xref:System.Security.Permissions.SecurityPermission> und [Codezugriffsberechtigungen](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
   
  
## Examples  
 Im folgenden Beispiel wird die `Shell` Funktion zum Ausführen einer Anwendung, die vom Benutzer angegeben wird. Angeben von <xref:Microsoft.VisualBasic.AppWinStyle.NormalFocus?displayProperty=nameWithType> als das zweite Argument wird die Anwendung in Normalgröße und gibt ihm den Fokus.  
  
 [!code-vb[VbVbalrFunctions#47](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#47)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Style" /> befindet sich nicht im Bereich von 0 bis einschließlich 9.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <see langword="Shell" /> kann die Datei <paramref name="PathName" /> nicht finden.</exception>
        <exception cref="T:System.NullReferenceException">
          <paramref name="PathName" /> ist <see langword="Nothing" />.</exception>
        <altmember cref="T:Microsoft.VisualBasic.AppWinStyle" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:System.NullReferenceException" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.GetFiles" />
        <altmember cref="Overload:Microsoft.VisualBasic.Interaction.AppActivate" />
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static object Switch (params object[] VarExpr);" />
      <MemberSignature Language="ILAsm" Value=".method public static object Switch(object[] VarExpr) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Switch(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Switch (ParamArray VarExpr As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Switch(... cli::array &lt;System::Object ^&gt; ^ VarExpr);" />
      <MemberSignature Language="F#" Value="static member Switch : obj[] -&gt; obj" Usage="Microsoft.VisualBasic.Interaction.Switch VarExpr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="VarExpr" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="VarExpr">Erforderlich. <see langword="Object" />-Parameterarray. Muss über eine gerade Anzahl von Elementen verfügen. Sie können eine durch Komma getrennte Liste von <see langword="Object" />-Variablen oder Ausdrücken oder ein eindimensionales Array von <see langword="Object" />-Elementen angeben.</param>
        <summary>Evaluiert eine Liste von Ausdrücken und gibt einen <see langword="Object" />-Wert zurück, der dem ersten Ausdruck in der Liste entspricht, der <see langword="True" /> ist.</summary>
        <returns>Evaluiert eine Liste von Ausdrücken und gibt einen <see langword="Object" />-Wert zurück, der dem ersten Ausdruck in der Liste entspricht, der <see langword="True" /> ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Argument bereitgestellt werden, um `VarExpr` gekoppelten Ausdrucks-und besteht aus. Die `Switch` -Funktion wertet die Ausdrücke ungerade vom niedrigsten zum höchsten Index im `VarExpr`, und gibt den gerader Wert mit dem ersten Ausdruck, der ergibt `True`. Z. B. wenn `VarExpr(0)` ist `True`, `Switch` gibt `VarExpr(1)`, und wenn `VarExpr(0)` ist `False` aber `VarExpr(2)` ist `True`, `Switch` gibt `VarExpr(3)`und so weiter.  
  
 Wenn Sie keinen angeben der `VarExpr` Argument `Switch` gibt `Nothing`.  
  
> [!NOTE]
>  Die Ausdrücke in der Argumentliste können Funktionsaufrufe enthalten. Bei der Vorbereitung der Argumentliste für den Aufruf von `Switch`, Visual Basic-Compiler jede Funktion in jedem Ausdruck aufgerufen wird. Dies bedeutet, dass Sie sich verlassen können nicht auf eine bestimmte Funktion nicht aufgerufen wird, wenn ein Ausdruck weiter oben in der Argumentliste ist `True`.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die `Switch` Funktion, die den Namen der Sprache zurück, der den Namen einer Stadt entspricht. Es erfordert, dass `Option Strict` werden `Off`.  
  
 [!code-vb[VbVbalrFunctions#48](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#48)]  
  
 Da die <xref:System.Diagnostics> -Namespace enthält auch eine Klasse namens <xref:System.Diagnostics.Switch>, einen Aufruf der `Switch` Funktion muss qualifiziert werden, mit der <xref:Microsoft.VisualBasic> Namespace.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ungerade Anzahl der Argumente</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.Choose(System.Double,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.IIf(System.Boolean,System.Object,System.Object)" />
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/select-case-statement.md">Select...Case-Anweisung (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/programming-guide/language-features/procedures/parameter-arrays.md">Parameterarrays</related>
      </Docs>
    </Member>
  </Members>
</Type>