<Type Name="FileSystem" FullName="Microsoft.VisualBasic.FileSystem">
  <Metadata><Meta Name="ms.openlocfilehash" Value="1f940726ccb01e692538ad14f77890b52044c8de" /><Meta Name="ms.sourcegitcommit" Value="11d168140aa8fade0768c2a9dde3e3bcacfdfb7d" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="05/27/2020" /><Meta Name="ms.locfileid" Value="83954694" /></Metadata><TypeSignature Language="C#" Value="public sealed class FileSystem" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit FileSystem extends System.Object" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <TypeSignature Language="DocId" Value="T:Microsoft.VisualBasic.FileSystem" />
  <TypeSignature Language="VB.NET" Value="Public Module FileSystem" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileSystem sealed" />
  <TypeSignature Language="F#" Value="type FileSystem = class" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed FileSystem extends System.Object" FrameworkAlternate="netframework-1.1" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic</AssemblyName>
    <AssemblyVersion>7.0.5000.0</AssemblyVersion>
    <AssemblyVersion>8.0.0.0</AssemblyVersion>
    <AssemblyVersion>10.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
    <AssemblyVersion>10.0.4.0</AssemblyVersion>
    <AssemblyVersion>10.0.5.0</AssemblyVersion>
    <AssemblyVersion>10.0.6.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>Microsoft.VisualBasic.CompilerServices.StandardModule</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Security.SecurityCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Das <see langword="FileSystem" />-Modul enthält Prozeduren, mit denen Datei-, Verzeichnis- oder Ordner- und Systemoperationen ausgeführt werden. Das <see langword="My" />-Feature ermöglicht bei Datei-E/A-Vorgängen höhere Produktivität und Leistung als bei Verwendung des <see langword="FileSystem" />-Moduls. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Modul unterstützt die Visual Basic-sprach Schlüsselwörter und-Lauf Zeit Bibliothekselemente, die auf Dateien und Ordner zugreifen.  
  
   
  
## Examples  
 In diesem Beispiel wird die `GetAttr`-Funktion verwendet, um die Attribute einer Datei, eines Verzeichnisses oder eines Ordners zu bestimmen.  
  
 [!code-vb[VbVbalrCatRef#25](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#25)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="/dotnet/visual-basic/language-reference/keywords/directories-and-files-summary">Verzeichnisse und Dateien: Zusammenfassung</related>
    <related type="Article" href="/dotnet/visual-basic/language-reference/keywords/input-and-output-summary">Eingabe und Ausgabe: Zusammenfassung</related>
    <related type="Article" href="/dotnet/visual-basic/language-reference/keywords/">Schlüsselwörter (Visual Basic)</related>
    <related type="Article" href="/dotnet/visual-basic/language-reference/runtime-library-members">Visual Basic von Lauf Zeit Bibliotheks Membern</related>
  </Docs>
  <Members>
    <Member MemberName="ChDir">
      <MemberSignature Language="C#" Value="public static void ChDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ChDir(string Path) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDir(System::String ^ Path);" />
      <MemberSignature Language="F#" Value="static member ChDir : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.ChDir Path" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDir(string Path) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">Erforderlich. Ein Zeichenfolgenausdruck, der das Verzeichnis oder den Ordner bezeichnet, das bzw. der zum neuen Verzeichnis oder Ordner wird. <paramref name="Path" /> enthält möglicherweise das Laufwerk. Wenn kein Laufwerk angegeben wird, ändert <see langword="ChDir" /> das Standardverzeichnis oder den Ordner in das aktuelle Laufwerk.</param>
        <summary>Ändert das aktuelle Verzeichnis oder den aktuellen Ordner. Das <see langword="My" />-Feature ermöglicht bei Datei-E/A-Vorgängen eine höhere Produktivität und Leistung als die <see langword="ChDir" />-Funktion. Weitere Informationen finden Sie unter <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `ChDir`-Funktion ändert das Standardverzeichnis, jedoch nicht das Standard Laufwerk. Wenn das Standard Laufwerk z. b. C ist, wird die folgende Anweisung das Standardverzeichnis auf Laufwerk D ändern, aber C bleibt das Standard Laufwerk:  
  
 [!code-vb[VbVbalrCatRef#39](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#39)]  
  
 Sie können relative Verzeichnisänderungen vornehmen, indem Sie wie folgt zwei Zeiträume eingeben:  
  
 [!code-vb[VbVbalrCatRef#40](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#40)]  
  
> [!IMPORTANT]
>  Die `ChDir`-Funktion erfordert die Berechtigung "nicht verwalteter Code", die sich möglicherweise auf die Ausführung in teilweise vertrauenswürdigen Situationen auswirkt. Weitere Informationen finden Sie unter <xref:System.Security.Permissions.SecurityPermission> und.  
  
   
  
## Examples  
 In diesem Beispiel wird die `ChDir`-Funktion verwendet, um das aktuelle Verzeichnis oder den Ordner zu ändern.  
  
 [!code-vb[VbVbalrCatRef#41](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="Path" /> ist leer.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Angegebenes Laufwerk ungültig oder nicht verfügbar.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-parse-file-paths">Gewusst wie: Analysieren von Dateipfaden in Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/creating-deleting-and-moving-files-and-directories">Erstellen, Löschen und Verschieben von Dateien und Verzeichnissen in Visual Basic</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ChDrive">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ändert das aktuelle Laufwerk.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ChDrive">
      <MemberSignature Language="C#" Value="public static void ChDrive (char Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ChDrive(char Drive) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDrive (Drive As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDrive(char Drive);" />
      <MemberSignature Language="F#" Value="static member ChDrive : char -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.ChDrive Drive" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDrive(char Drive) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="Drive">Erforderlich. Zeichenfolgenausdruck, der ein vorhandenes Laufwerk angibt. Wenn Sie eine Zeichenfolge der Länge 0 (null) ("") angeben, ändert sich das aktuelle Laufwerk nicht. Wenn das <paramref name="Drive" />-Argument eine Zeichenfolge mit mehreren Zeichen ist, verwendet <see langword="ChDrive" /> nur den ersten Buchstaben.</param>
        <summary>Ändert das aktuelle Laufwerk.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `ChDrive`-Funktion erfordert die Berechtigung "nicht verwalteter Code", die sich möglicherweise auf die Ausführung in teilweise vertrauenswürdigen Situationen auswirkt. Weitere Informationen finden Sie unter <xref:System.Security.Permissions.SecurityPermission>-und [Code Zugriffsberechtigungen](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
   
  
## Examples  
 In diesem Beispiel wird die `ChDrive`-Funktion verwendet, um das aktuelle Laufwerk zu ändern. Die-Funktion löst eine Ausnahme aus, wenn das Laufwerk nicht vorhanden ist.  
  
 [!code-vb[VbVbalrCatRef#32](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Angegebenes Laufwerk ungültig oder nicht verfügbar.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access">Dateizugriff mit Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="ChDrive">
      <MemberSignature Language="C#" Value="public static void ChDrive (string Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ChDrive(string Drive) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDrive (Drive As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDrive(System::String ^ Drive);" />
      <MemberSignature Language="F#" Value="static member ChDrive : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.ChDrive Drive" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDrive(string Drive) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Drive">Erforderlich. Zeichenfolgenausdruck, der ein vorhandenes Laufwerk angibt. Wenn Sie eine Zeichenfolge der Länge 0 (null) ("") angeben, ändert sich das aktuelle Laufwerk nicht. Wenn das <paramref name="Drive" />-Argument eine Zeichenfolge mit mehreren Zeichen ist, verwendet <see langword="ChDrive" /> nur den ersten Buchstaben.</param>
        <summary>Ändert das aktuelle Laufwerk.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `ChDrive`-Funktion erfordert die Berechtigung "nicht verwalteter Code", die sich möglicherweise auf die Ausführung in teilweise vertrauenswürdigen Situationen auswirkt. Weitere Informationen finden Sie unter <xref:System.Security.Permissions.SecurityPermission>-und [Code Zugriffsberechtigungen](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
   
  
## Examples  
 In diesem Beispiel wird die `ChDrive`-Funktion verwendet, um das aktuelle Laufwerk zu ändern. Die-Funktion löst eine Ausnahme aus, wenn das Laufwerk nicht vorhanden ist.  
  
 [!code-vb[VbVbalrCatRef#32](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Angegebenes Laufwerk ungültig oder nicht verfügbar.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access">Dateizugriff mit Visual Basic</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CurDir">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt eine Zeichenfolge mit dem aktuellen Pfad zurück. Das <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> ermöglicht bei Datei-E/A-Vorgängen höhere Produktivität und Leistung als <see langword="CurDir" />. Weitere Informationen finden Sie unter <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CurDir">
      <MemberSignature Language="C#" Value="public static string CurDir ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string CurDir() cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.CurDir" />
      <MemberSignature Language="VB.NET" Value="Public Function CurDir () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CurDir();" />
      <MemberSignature Language="F#" Value="static member CurDir : unit -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.CurDir " />
      <MemberSignature Language="ILAsm" Value=".method public static string CurDir() cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine Zeichenfolge mit dem aktuellen Pfad zurück. Das <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> ermöglicht bei Datei-E/A-Vorgängen höhere Produktivität und Leistung als <see langword="CurDir" />. Weitere Informationen finden Sie unter <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</summary>
        <returns>Eine Zeichenfolge mit dem aktuellen Pfad.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 In diesem Beispiel wird die `CurDir`-Funktion verwendet, um den aktuellen Pfad zurückzugeben.  
  
 [!code-vb[VbVbalrCatRef#65](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#65)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <Member MemberName="CurDir">
      <MemberSignature Language="C#" Value="public static string CurDir (char Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string CurDir(char Drive) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.CurDir(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function CurDir (Drive As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CurDir(char Drive);" />
      <MemberSignature Language="F#" Value="static member CurDir : char -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.CurDir Drive" />
      <MemberSignature Language="ILAsm" Value=".method public static string CurDir(char Drive) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="Drive">Optional. Ein <see langword="Char" />-Ausdruck, der ein vorhandenes Laufwerk angibt. Wenn kein Laufwerk angegeben wird oder <paramref name="Drive" /> eine Zeichenfolgen der Länge 0 (null) ("") ist, gibt <see langword="CurDir" /> den Pfad für das aktuelle Laufwerk zurück.</param>
        <summary>Gibt eine Zeichenfolge mit dem aktuellen Pfad zurück. Das <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> ermöglicht bei Datei-E/A-Vorgängen höhere Produktivität und Leistung als <see langword="CurDir" />. Weitere Informationen finden Sie unter <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</summary>
        <returns>Eine Zeichenfolge mit dem aktuellen Pfad.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 In diesem Beispiel wird die `CurDir`-Funktion verwendet, um den aktuellen Pfad zurückzugeben.  
  
 [!code-vb[VbVbalrCatRef#65](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#65)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dir">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt eine Zeichenfolge zurück, die den Namen einer Datei, eines Verzeichnisses oder eines Ordners darstellt, der einem bestimmten Muster oder Dateiattribut oder der Volumebezeichnung eines Laufwerks entspricht. Das <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> ermöglicht bei Datei-E/A-Vorgängen höhere Produktivität und Leistung als die <see langword="Dir" />-Funktion. Weitere Informationen finden Sie unter <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dir">
      <MemberSignature Language="C#" Value="public static string Dir ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Dir() cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Dir" />
      <MemberSignature Language="VB.NET" Value="Public Function Dir () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Dir();" />
      <MemberSignature Language="F#" Value="static member Dir : unit -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.Dir " />
      <MemberSignature Language="ILAsm" Value=".method public static string Dir() cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine Zeichenfolge zurück, die den Namen einer Datei, eines Verzeichnisses oder eines Ordners darstellt, der einem bestimmten Muster oder Dateiattribut oder der Volumebezeichnung eines Laufwerks entspricht. Das <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> ermöglicht bei Datei-E/A-Vorgängen höhere Produktivität und Leistung als die <see langword="Dir" />-Funktion. Weitere Informationen finden Sie unter <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" />.</summary>
        <returns>Eine Zeichenfolge, die den Namen einer Datei, eines Verzeichnisses oder eines Ordners darstellt, der einem bestimmten Muster oder Dateiattribut oder der Volumebezeichnung eines Laufwerks entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Dir`-Funktion unterstützt die Verwendung von Platzhaltern mit mehreren Zeichen (`*`) und Einzelzeichen (`?`) zum Angeben mehrerer Dateien.  
  
 `VbVolume` gibt die Volumebezeichnung für das Laufwerk anstelle eines bestimmten Datei namens zurück.  
  
 Sie müssen einen `PathName` angeben, wenn Sie die `Dir`-Funktion zum ersten Mal aufzurufen. Zum Abrufen des nächsten Elements können Sie nachfolgende Aufrufe an die `Dir` Funktion ohne Parameter vornehmen.  
  
> [!IMPORTANT]
>  Um ordnungsgemäß auszuführen, muss für die `Dir`-Funktion dem ausführenden Code das <xref:System.Security.Permissions.FileIOPermissionAccess.Read> und <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery> Flags <xref:System.Security.Permissions.FileIOPermission> erteilt werden. Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermission>, <xref:System.Security.SecurityException>und [Code Zugriffsberechtigungen](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
 Die `Attributes` Argument-Enumerationswerte lauten wie folgt:  
  
|value|Dauerhaft|BESCHREIBUNG|  
|-|-|-|  
|`Normal`|`vbnormal`|Standard. Gibt Dateien ohne Attribute an.|  
|`ReadOnly`|`vbReadOnly`|Gibt schreibgeschützte Dateien und auch Dateien ohne Attribute an.|  
|`Hidden`|`vbHidden`|Gibt ausgeblendete Dateien und auch Dateien ohne Attribute an.|  
|`System`|`vbSystem`|Gibt Systemdateien und auch Dateien ohne Attribute an.|  
|`Volume`|`vbVolume`|Gibt die Volumebezeichnung an. Wenn ein anderes Attribut angegeben wird, wird `vbVolume` ignoriert.|  
|`Directory`|`vbDirectory`|Gibt Verzeichnisse oder Ordner und auch Dateien ohne Attribute an.|  
|`Archive`|`vbArchive`|Die Datei wurde nach der letzten Sicherung geändert.|  
|`Alias`|`vbAlias`|Die Datei hat einen anderen Namen.|  
  
> [!NOTE]
>  Diese Enumerationen werden von der Visual Basic Sprache angegeben und können an beliebiger Stelle im Code anstelle der tatsächlichen Werte verwendet werden.  
  
   
  
## Examples  
 In diesem Beispiel wird die `Dir`-Funktion verwendet, um zu prüfen, ob bestimmte Dateien und Verzeichnisse vorhanden sind.  
  
 [!code-vb[VbVbalrCatRef#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Dir">
      <MemberSignature Language="C#" Value="public static string Dir (string PathName, Microsoft.VisualBasic.FileAttribute Attributes = Microsoft.VisualBasic.FileAttribute.Normal);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Dir(string PathName, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)" />
      <MemberSignature Language="VB.NET" Value="Public Function Dir (PathName As String, Optional Attributes As FileAttribute = Microsoft.VisualBasic.FileAttribute.Normal) As String" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="F#" Value="static member Dir : string * Microsoft.VisualBasic.FileAttribute -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.Dir (PathName, Attributes)" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C#" Value="public static string Dir (string Pathname, Microsoft.VisualBasic.FileAttribute Attributes = Microsoft.VisualBasic.FileAttribute.Normal);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Dir(string Pathname, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Public Function Dir (Pathname As String, Optional Attributes As FileAttribute = Microsoft.VisualBasic.FileAttribute.Normal) As String" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="F#" Value="static member Dir : string * Microsoft.VisualBasic.FileAttribute -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.Dir (Pathname, Attributes)" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="ILAsm" Value=".method public static string Dir(string PathName, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="Pathname" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1" />
        <Parameter Name="Attributes" Type="Microsoft.VisualBasic.FileAttribute" Index="1" />
      </Parameters>
      <Docs>
        <param name="PathName">Optional. Ein Zeichenfolgenausdruck, der einen Dateinamen, ein Verzeichnis, einen Ordnernamen oder eine Volumebezeichnung des Laufwerks angibt. Eine Zeichenfolge der Länge 0 (null) (<see langword="&quot;&quot;" />) wird zurückgegeben, wenn <paramref name="PathName" /> nicht gefunden wird.</param>
        <param name="Pathname">Optional. Ein Zeichenfolgenausdruck, der einen Dateinamen, ein Verzeichnis, einen Ordnernamen oder eine Volumebezeichnung des Laufwerks angibt. Eine Zeichenfolge der Länge 0 (null) (<see langword="&quot;&quot;" />) wird zurückgegeben, wenn <paramref name="Pathname" /> nicht gefunden wird.</param>
        <param name="Attributes">Optional. Enumeration oder numerischer Ausdruck, dessen Wert Dateiattribute angibt. Wenn der Wert nicht angegeben wird, gibt <see langword="Dir" /> Dateien zurück, die mit <paramref name="Pathname" /> übereinstimmen, aber keine Attribute besitzen.</param>
        <summary>Gibt eine Zeichenfolge zurück, die den Namen einer Datei, eines Verzeichnisses oder eines Ordners darstellt, der einem bestimmten Muster oder Dateiattribut oder der Volumebezeichnung eines Laufwerks entspricht. Das <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> ermöglicht bei Datei-E/A-Vorgängen höhere Produktivität und Leistung als die <see langword="Dir" />-Funktion. Weitere Informationen finden Sie unter <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" />.</summary>
        <returns>Eine Zeichenfolge, die den Namen einer Datei, eines Verzeichnisses oder eines Ordners darstellt, der einem bestimmten Muster oder Dateiattribut oder der Volumebezeichnung eines Laufwerks entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Dir`-Funktion unterstützt die Verwendung von Platzhaltern mit mehreren Zeichen (`*`) und Einzelzeichen (`?`) zum Angeben mehrerer Dateien.  
 `VbVolume` gibt die Volumebezeichnung für das Laufwerk anstelle eines bestimmten Datei namens zurück.  
 Sie müssen einen `PathName` angeben, wenn Sie die `Dir`-Funktion zum ersten Mal aufzurufen. Zum Abrufen des nächsten Elements können Sie nachfolgende Aufrufe an die `Dir` Funktion ohne Parameter vornehmen.  
> [!IMPORTANT]
>  Um ordnungsgemäß auszuführen, muss für die `Dir`-Funktion dem ausführenden Code das <xref:System.Security.Permissions.FileIOPermissionAccess.Read> und <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery> Flags <xref:System.Security.Permissions.FileIOPermission> erteilt werden. Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermission>, <xref:System.Security.SecurityException>und [Code Zugriffsberechtigungen](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
 Die `Attributes` Argument-Enumerationswerte lauten wie folgt:  
|value|Dauerhaft|BESCHREIBUNG|  
|-|-|-|  
|`Normal`|`vbnormal`|Standard. Gibt Dateien an, die über keine Attribute verfügen.|  
|`ReadOnly`|`vbReadOnly`|Gibt die schreibgeschützten Dateien an, zusätzlich zu Dateien, die über keine Attribute verfügen.|  
|`Hidden`|`vbHidden`|Gibt ausgeblendete Dateien an, zusätzlich zu Dateien, die über keine Attribute verfügen.|  
|`System`|`vbSystem`|Gibt Systemdateien an, zusätzlich zu Dateien, die über keine Attribute verfügen.|  
|`Volume`|`vbVolume`|Gibt die Volumebezeichnung an. Wenn ein anderes Attribut angegeben wird, wird `vbVolume` ignoriert.|  
|`Directory`|`vbDirectory`|Gibt Verzeichnisse oder Ordner an, zusätzlich zu Dateien, die über keine Attribute verfügen.|  
|`Archive`|`vbArchive`|Die Datei wurde nach der letzten Sicherung geändert.|  
|`Alias`|`vbAlias`|Die Datei hat einen anderen Namen.|  
> [!NOTE]
>  Diese Enumerationen werden von der Visual Basic Sprache angegeben und können an beliebiger Stelle im Code anstelle der tatsächlichen Werte verwendet werden.  
## Examples  
 In diesem Beispiel wird die `Dir`-Funktion verwendet, um zu prüfen, ob bestimmte Dateien und Verzeichnisse vorhanden sind.  
 [!code-vb[VbVbalrCatRef#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#3)]  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
      </Docs>
    </Member>
    <Member MemberName="EOF">
      <MemberSignature Language="C#" Value="public static bool EOF (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool EOF(int32 FileNumber) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function EOF (FileNumber As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool EOF(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member EOF : int -&gt; bool" Usage="Microsoft.VisualBasic.FileSystem.EOF FileNumber" />
      <MemberSignature Language="ILAsm" Value=".method public static bool EOF(int32 FileNumber) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Ein <see langword="Integer" /> mit einer beliebigen gültigen Dateinummer.</param>
        <summary>Gibt den booleschen Wert <see langword="True" /> zurück, wenn das Ende einer für <see langword="Random" />- oder sequenziellen <see langword="Input" />-Zugriff geöffneten Datei erreicht wurde.</summary>
        <returns>Ein boolescher Wert <see langword="True" />, wenn das Ende einer für <see langword="Random" /> oder sequenzielle <see langword="Input" /> geöffneten Datei erreicht wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie `EOF`, um den Fehler zu vermeiden, der generiert wird, wenn Sie versuchen, Eingaben hinter das Ende einer Datei zu erhalten.  
  
 Die `EOF`-Funktion gibt `False` zurück, bis das Ende der Datei erreicht wurde. Wenn Dateien für `Random` oder `Binary` Zugriff geöffnet sind, gibt `EOF` `False` zurück, bis die letzte ausgeführte `FileGet` Funktion einen ganzen Datensatz nicht lesen kann.  
  
 Wenn Dateien für `Binary` Zugriff geöffnet wurden, wird versucht, die Datei mit der `Input`-Funktion zu lesen, bis `EOF` zurückgibt, `True` einen Fehler generiert. Verwenden Sie die Funktionen `LOF` und `Loc` anstelle von `EOF` beim Lesen von Binärdateien mit `Input`, oder verwenden Sie `Get`, wenn Sie die `EOF`-Funktion verwenden. Wenn Dateien für `Output`geöffnet sind, gibt `EOF` immer `True`zurück.  
  
   
  
## Examples  
 In diesem Beispiel wird die `EOF`-Funktion verwendet, um das Ende einer Datei zu erkennen. In diesem Beispiel wird davon ausgegangen, dass `Testfile` eine Textdatei ist, die mehrere Textzeilen enthält.  
  
 [!code-vb[VbVbalrCatRef#62](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#62)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FileAttr">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.OpenMode FileAttr (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.VisualBasic.OpenMode FileAttr(int32 FileNumber) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileAttr (FileNumber As Integer) As OpenMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::OpenMode FileAttr(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member FileAttr : int -&gt; Microsoft.VisualBasic.OpenMode" Usage="Microsoft.VisualBasic.FileSystem.FileAttr FileNumber" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.OpenMode FileAttr(int32 FileNumber) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.OpenMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. [https://login.microsoftonline.com/consumers/](<see langword="Integer" />). Eine beliebige gültige Dateinummer.</param>
        <summary>Gibt eine Enumeration zurück, die den Dateimodus für Dateien darstellt, die mit der <see langword="FileOpen" />-Funktion geöffnet wurden. Das <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> ermöglicht bei Datei-E/A-Vorgängen höhere Produktivität und Leistung als die <see langword="FileAttr" />-Funktion. Weitere Informationen finden Sie unter <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />.</summary>
        <returns>Die folgenden Enumerationswerte geben den Dateizugriffsmodus an: 
 <list type="table"><item><term> value 
 </term><description> Mode 
 </description></item><item><term> 1 
 </term><description><see langword="OpenMode.Input" /></description></item><item><term> 2 
 </term><description><see langword="OpenMode.Output" /></description></item><item><term> 4 
 </term><description><see langword="OpenMode.Random" /></description></item><item><term> 8 
 </term><description><see langword="OpenMode.Append" /></description></item><item><term> 32 
 </term><description><see langword="OpenMode.Binary" /></description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Funktion gibt eine Enumeration zurück, die den Dateimodus für Dateien darstellt, die mit der `FileOpen`-Funktion geöffnet wurden.  
  
   
  
## Examples  
 In diesem Beispiel wird die `FileAttr`-Funktion verwendet, um den Dateimodus einer geöffneten Datei zurückzugeben.  
  
 [!code-vb[VbVbalrCatRef#46](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#46)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access">Dateizugriff mit Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileClose">
      <MemberSignature Language="C#" Value="public static void FileClose (params int[] FileNumbers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FileClose(int32[] FileNumbers) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileClose (ParamArray FileNumbers As Integer())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileClose(... cli::array &lt;int&gt; ^ FileNumbers);" />
      <MemberSignature Language="F#" Value="static member FileClose : int[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileClose FileNumbers" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileClose(int32[] FileNumbers) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumbers" Type="System.Int32[]">
          <Attributes>
            <Attribute FrameworkAlternate="net-5.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumbers">Optional. Parameterarray von 0 oder mehr zu schließenden Channels.</param>
        <summary>Schließt die Eingabe/Ausgabe (E/A) für eine Datei, die mit der <see langword="FileOpen" />-Funktion geöffnet wird. <see langword="My" /> ermöglicht bei Datei-E/A-Vorgängen eine höhere Produktivität und Leistung. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `FileClose` Funktion wird aus Gründen der Abwärtskompatibilität bereitgestellt und kann sich auf die Leistung auswirken. Bei nicht Legacy Anwendungen bietet das `My.Computer.FileSystem`-Objekt eine bessere Leistung. Weitere Informationen finden Sie unter Gewusst [wie: Lesen von Text aus Dateien mit einem StreamReader](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader), Gewusst [wie: Schreiben von Text in Dateien mit einem StreamWriter](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter)und Exemplarische Vorgehensweise: Bearbeiten von [Dateien und Verzeichnissen in Visual Basic](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories).  
  
 Wenn Sie `FileNumbers`weglassen, werden alle aktiven Dateien, die von der `FileOpen`-Funktion geöffnet werden, geschlossen.  
  
 Wenn Sie Dateien schließen, die für `Output` oder `Append`geöffnet wurden, wird der endgültige Ausgabepuffer in den Betriebssystem Puffer für diese Datei geschrieben. Der gesamte Speicherplatz, der der geschlossenen Datei zugeordnet ist, wird freigegeben.  
  
 Wenn die `FileClose`-Funktion ausgeführt wird, endet die Zuordnung einer Datei mit der zugehörigen Dateinummer.  
  
   
  
## Examples  
 In diesem Beispiel wird die `FileClose`-Funktion verwendet, um eine für `Input`geöffnete Datei zu schließen.  
  
 [!code-vb[VbVbalrCatRef#69](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#69)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><paramref name="FileNumber" /> existiert nicht.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Reset" />
        <related type="Article" href="/dotnet/visual-basic/language-reference/statements/end-statement">End Statement</related>
        <related type="Article" href="/dotnet/visual-basic/language-reference/statements/stop-statement">Stop-Anweisung (Visual Basic)</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access">Dateizugriff mit Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileCopy">
      <MemberSignature Language="C#" Value="public static void FileCopy (string Source, string Destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FileCopy(string Source, string Destination) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileCopy(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileCopy (Source As String, Destination As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileCopy(System::String ^ Source, System::String ^ Destination);" />
      <MemberSignature Language="F#" Value="static member FileCopy : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileCopy (Source, Destination)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileCopy(string Source, string Destination) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Source" Type="System.String" />
        <Parameter Name="Destination" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Source">Erforderlich. Ein Zeichenfolgenausdruck, der den Namen der zu kopierenden Datei angibt. <paramref name="Source" /> kann das Verzeichnis oder den Ordner sowie das Laufwerk der Quelldatei beinhalten.</param>
        <param name="Destination">Erforderlich. Ein Zeichenfolgenausdruck, der den Zieldateinamen angibt. <paramref name="Destination" /> kann das Verzeichnis oder den Ordner sowie das Laufwerk der Zieldatei beinhalten.</param>
        <summary>Kopiert eine Datei Das <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> ermöglicht bei Datei-E/A-Vorgängen höhere Produktivität und Leistung als <see langword="FileCopy" />. Weitere Informationen finden Sie unter <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile(System.String,System.String)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie versuchen, die `FileCopy`-Funktion für eine aktuell geöffnete Datei zu verwenden, tritt ein Fehler auf.  
  
 `FileCopy` erfordert volle Vertrauenswürdigkeit, um auf dem lokalen Laufwerk arbeiten zu können.  
  
   
  
## Examples  
 In diesem Beispiel wird die `FileCopy`-Funktion verwendet, um eine Datei in eine andere zu kopieren. Nehmen Sie für die Zwecke dieses Beispiels an, dass `SrcFile` eine Datei mit Daten ist.  
  
 [!code-vb[VbVbalrCatRef#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="Source" /> oder <paramref name="Destination" /> ist ungültig oder nicht angegeben.</exception>
        <exception cref="T:System.IO.IOException">Datei ist bereits geöffnet.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Datei ist nicht vorhanden.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-a-different-directory">Gewusst wie: Erstellen einer Kopie einer Datei in einem anderen Verzeichnis in Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory">Gewusst wie: Erstellen einer Kopie einer Datei im gleichen Ordner in Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory">Gewusst wie: Kopieren eines Verzeichnisses in ein anderes Verzeichnis in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileDateTime">
      <MemberSignature Language="C#" Value="public static DateTime FileDateTime (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime FileDateTime(string PathName) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileDateTime (PathName As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime FileDateTime(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member FileDateTime : string -&gt; DateTime" Usage="Microsoft.VisualBasic.FileSystem.FileDateTime PathName" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype System.DateTime FileDateTime(string PathName) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">Erforderlich. Ein Zeichenfolgenausdruck, der einen Dateinamen angibt. <paramref name="PathName" /> kann das Verzeichnis bzw. den Ordner und das Laufwerk enthalten.</param>
        <summary>Gibt einen <see langword="Date" />-Wert zurück, der Datum und Uhrzeit des Schreibvorgangs in einer Datei angibt. Die <see langword="My" />-Funktion bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FileDateTime" />. Weitere Informationen finden Sie unter <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />.</summary>
        <returns>Ein <see langword="Date" />-Wert, der Datum und Uhrzeit der Erstellung oder letzten Änderung der Datei angibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 In diesem Beispiel wird die `FileDateTime`-Funktion verwendet, um das Datum und die Uhrzeit der Erstellung oder letzten Änderung einer Datei zu bestimmen. Das Format des angezeigten Datums und der Uhrzeit basiert auf den Gebiets Schema Einstellungen des Systems.  
  
 [!code-vb[VbVbalrCatRef#34](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#34)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="PathName" /> ist ungültig oder enthält Platzhalterzeichen.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Zieldatei ist nicht vorhanden.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access">Dateizugriff mit Visual Basic</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="FileGet">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Liest Daten aus einer offenen Datenträgerdatei in eine Variable. Die <see langword="My" />-Funktion bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FileGet" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref bool Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FileGet(int32 FileNumber, bool&amp; Value, int64 RecordNumber) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Boolean, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int * bool * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, bool&amp; Value, int64 RecordNumber) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="Value">Erforderlich. Der gültige Name einer Variablen, in die Daten gelesen werden.</param>
        <param name="RecordNumber">Optional. Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), bei der der Lesevorgang beginnt.</param>
        <summary>Liest Daten aus einer offenen Datenträgerdatei in eine Variable. Die <see langword="My" />-Funktion bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FileGet" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` ist nur im `Random`-und `Binary` Modus gültig.  
  
 Mit `FileGet` gelesene Daten werden in der Regel in eine Datei mit `FilePut`geschrieben.  
  
 Der erste Datensatz oder das Byte in einer Datei befindet sich an Position 1, der zweite Datensatz bzw. das zweite Byte befindet sich an Position 2 usw. Wenn Sie `RecordNumber`weglassen, wird der nächste Datensatz oder das nächste Byte, der auf den letzten `FileGet` oder die `FilePut` Funktion folgt (bzw. auf die letzte `Seek` Funktion verwiesen), gelesen.  
  
> [!IMPORTANT]
>  Treffen Sie beim Lesen aus Dateien keine Entscheidungen zum Inhalt einer Datei, die auf der Dateinamenerweiterung basiert. Beispielsweise ist eine Datei mit dem Namen Form1. vb möglicherweise keine Visual Basic Quelldatei.  
  
## <a name="random-mode"></a>Zufälliger Modus  
 Für Dateien, die im `Random` Modus geöffnet werden, gelten die folgenden Regeln:  
  
-   Wenn die Länge der gelesenen Daten kleiner ist als die Länge, die in der `RecordLength`-Klausel der `FileOpen`-Funktion angegeben ist, liest `FileGet` nachfolgende Datensätze über Grenzen der Daten Satz Länge. Der Leerraum zwischen dem Ende eines Datensatzes und dem Anfang des nächsten Datensatzes wird mit dem vorhandenen Inhalt des Datei Puffers aufgefüllt. Da die Menge der Auffüll Daten nicht mit Sicherheit bestimmt werden kann, empfiehlt es sich im Allgemeinen, die Daten Satz Länge mit der Länge der gelesenen Daten zu vergleichen.  
  
-   Wenn die Variable, die in gelesen wird, eine Zeichenfolge ist, liest `FileGet` standardmäßig einen zwei-Byte-Deskriptor, der die Zeichen folgen Länge enthält, und liest dann die Daten, die in die Variable fließen. Daher muss die von der `RecordLength`-Klausel der `FileOpen`-Funktion angegebene Daten Satz Länge mindestens zwei Bytes aufweisen, die größer als die tatsächliche Länge der Zeichenfolge ist. In Visual Basic 6,0 und früheren Versionen werden Zeichen folgen mit fester Länge unterstützt. beim Einfügen in eine Datei wird der Längen Deskriptor nicht geschrieben. Wenn Sie eine Zeichenfolge ohne den Deskriptor lesen möchten, sollten Sie `True` an den `StringIsFixedLength`-Parameter übergeben, und die Zeichenfolge, in die Sie eingelesen haben, sollte die richtige Länge aufweisen.  
  
-   Wenn die zu lesende Variable ein Array ist, können Sie auswählen, ob ein Deskriptor für die Größe und Dimension des Arrays gelesen werden soll. Legen Sie zum Schreiben des Deskriptors den `ArrayIsDynamic`-Parameter auf `True`fest. Beim Lesen des Arrays müssen Sie der Art und Weise entsprechen, wie das Array geschrieben wurde. Wenn Sie mit dem Deskriptor geschrieben wurde, müssen Sie den Deskriptor lesen. Wenn der Deskriptor nicht verwendet wird, bestimmen die Größe und die Begrenzungen des Arrays, das an `FileGet` übermittelt wird, was gelesen werden soll.  
  
     Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang an. Die Länge ist 2 plus das 8-fache der Anzahl der Dimensionen: (2 + 8 * anzahldimensionen). Die vom `RecordLength`-Parameter in der `FileOpen`-Funktion angegebene Daten Satz Länge muss größer oder gleich der Summe aller Bytes sein, die zum Schreiben der Array Daten und des Array Deskriptors erforderlich sind. Die folgende Array Deklaration benötigt z. b. 218 bytes, wenn das Array auf den Datenträger geschrieben wird.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     Die 218 Bytes werden wie folgt verteilt:  
  
    -   18 Bytes für den Deskriptor: (2 + 8 * 2)  
  
    -   200 Bytes für die Daten: (5 * 10 * 4).  
  
-   Wenn die Variable, die in gelesen wird, ein beliebiger anderer Typ von Variable ist (keine Zeichenfolge mit variabler Länge oder ein Objekt), liest `FileGet` nur die Variablen Daten. Die von der `RecordLength`-Klausel in der `FileOpen`-Funktion angegebene Daten Satz Länge muss größer oder gleich der Länge der gelesenen Daten sein.  
  
-   `FileGet` liest Elemente von Strukturen so, als ob jede einzeln gelesen würde, mit dem Unterschied, dass es keine Auffüll Zeichen zwischen Elementen gibt. Auf einem Datenträger wird einem dynamischen Array in einem benutzerdefinierten Typ (geschrieben mit `FilePut`) ein Deskriptor vorangestellt, dessen Länge 2 plus dem 8-fachen der Anzahl von Dimensionen entspricht: (2 + 8 * anzahlungsdimensionen). Die von der `RecordLength`-Klausel in der `FileOpen`-Funktion angegebene Daten Satz Länge muss größer oder gleich der Summe aller Bytes sein, die zum Lesen der einzelnen Elemente erforderlich sind. Dies schließt beliebige Arrays und deren Deskriptoren ein. Das `VBFixedString`-Attribut kann auf Zeichen folgen Felder in den Strukturen angewendet werden, um die Größe einer Zeichenfolge anzugeben, wenn Sie auf den Datenträger geschrieben wird.  
  
## <a name="binary-mode"></a>Binärmodus  
 Bei Dateien, die im `Binary` Modus geöffnet wurden, gelten die meisten `Random` Modusregeln mit einigen Ausnahmen. Die folgenden Regeln für Dateien, die im `Binary` Modus geöffnet werden, unterscheiden sich von den Regeln für `Random`-Modus:  
  
-   Die `RecordLength`-Klausel in der `FileOpen`-Funktion hat keine Auswirkungen. `FileGet` liest alle Variablen von einem Datenträger zusammenhängend. Das heißt, ohne Auffüll Zeichen zwischen Datensätzen.  
  
-   Bei einem anderen Array als einem Array in einer Struktur liest `FileGet` nur die Daten. Es wurde kein Deskriptor gelesen.  
  
-   `FileGet` liest Zeichen folgen variabler Länge, bei denen es sich nicht um Elemente von Strukturen handelt, ohne den zwei Byte langen Längen Deskriptor zu erwarten. Die Anzahl der gelesenen Bytes ist mit der Anzahl von Zeichen in der Zeichenfolge.  
  
    > [!IMPORTANT]
    >  Zum Lesen aus einer Datei mit der`FileGet`-Funktion ist `Read` Zugriff von der <xref:System.Security.Permissions.FileIOPermissionAccess>-Enumeration erforderlich.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</exception>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files">Lesen aus Dateien in Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files">Schreiben in Dateien in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref byte Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FileGet(int32 FileNumber, unsigned int8&amp; Value, int64 RecordNumber) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Byte, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int * byte * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, unsigned int8&amp; Value, int64 RecordNumber) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="Value">Erforderlich. Der gültige Name einer Variablen, in die Daten gelesen werden.</param>
        <param name="RecordNumber">Optional. Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), bei der der Lesevorgang beginnt.</param>
        <summary>Liest Daten aus einer offenen Datenträgerdatei in eine Variable. Die <see langword="My" />-Funktion bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FileGet" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` ist nur im `Random`-und `Binary` Modus gültig.  
  
 Mit `FileGet` gelesene Daten werden in der Regel in eine Datei mit `FilePut`geschrieben.  
  
 Der erste Datensatz oder das Byte in einer Datei befindet sich an Position 1, der zweite Datensatz bzw. das zweite Byte befindet sich an Position 2 usw. Wenn Sie `RecordNumber`weglassen, wird der nächste Datensatz oder das nächste Byte, der auf den letzten `FileGet` oder die `FilePut` Funktion folgt (bzw. auf die letzte `Seek` Funktion verwiesen), gelesen.  
  
> [!IMPORTANT]
>  Treffen Sie beim Lesen aus Dateien keine Entscheidungen zum Inhalt einer Datei, die auf der Dateinamenerweiterung basiert. Beispielsweise ist eine Datei mit dem Namen Form1. vb möglicherweise keine Visual Basic Quelldatei.  
  
## <a name="random-mode"></a>Zufälliger Modus  
 Für Dateien, die im `Random` Modus geöffnet werden, gelten die folgenden Regeln:  
  
-   Wenn die Länge der gelesenen Daten kleiner ist als die Länge, die in der `RecordLength`-Klausel der `FileOpen`-Funktion angegeben ist, liest `FileGet` nachfolgende Datensätze über Grenzen der Daten Satz Länge. Der Leerraum zwischen dem Ende eines Datensatzes und dem Anfang des nächsten Datensatzes wird mit dem vorhandenen Inhalt des Datei Puffers aufgefüllt. Da die Menge der Auffüll Daten nicht mit Sicherheit bestimmt werden kann, empfiehlt es sich im Allgemeinen, die Daten Satz Länge mit der Länge der gelesenen Daten zu vergleichen.  
  
-   Wenn die Variable, die in gelesen wird, eine Zeichenfolge ist, liest `FileGet` standardmäßig einen zwei-Byte-Deskriptor, der die Zeichen folgen Länge enthält, und liest dann die Daten, die in die Variable fließen. Daher muss die von der `RecordLength`-Klausel der `FileOpen`-Funktion angegebene Daten Satz Länge mindestens zwei Bytes aufweisen, die größer als die tatsächliche Länge der Zeichenfolge ist. In Visual Basic 6,0 und früheren Versionen werden Zeichen folgen mit fester Länge unterstützt. beim Einfügen in eine Datei wird der Längen Deskriptor nicht geschrieben. Wenn Sie eine Zeichenfolge ohne den Deskriptor lesen möchten, sollten Sie `True` an den `StringIsFixedLength`-Parameter übergeben, und die Zeichenfolge, in die Sie eingelesen haben, sollte die richtige Länge aufweisen.  
  
-   Wenn die zu lesende Variable ein Array ist, können Sie auswählen, ob ein Deskriptor für die Größe und Dimension des Arrays gelesen werden soll. Legen Sie zum Schreiben des Deskriptors den `ArrayIsDynamic`-Parameter auf `True`fest. Beim Lesen des Arrays müssen Sie der Art und Weise entsprechen, wie das Array geschrieben wurde. Wenn Sie mit dem Deskriptor geschrieben wurde, müssen Sie den Deskriptor lesen. , Wenn der Deskriptor nicht verwendet wird. Die Größe und die Begrenzungen des Arrays, das an `FileGet` übermittelt wird, bestimmen, was gelesen werden soll.  
  
     Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang an. Die Länge ist 2 plus das 8-fache der Anzahl der Dimensionen: (2 + 8 * anzahldimensionen). Die vom `RecordLength`-Parameter in der `FileOpen`-Funktion angegebene Daten Satz Länge muss größer oder gleich der Summe aller Bytes sein, die zum Schreiben der Array Daten und des Array Deskriptors erforderlich sind. Die folgende Array Deklaration benötigt z. b. 218 bytes, wenn das Array auf den Datenträger geschrieben wird.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     Die 218 Bytes werden wie folgt verteilt:  
  
    -   18 Bytes für den Deskriptor: (2 + 8 * 2)  
  
    -   200 Bytes für die Daten: (5 * 10 * 4).  
  
-   Wenn die Variable, die in gelesen wird, ein beliebiger anderer Typ von Variable ist (keine Zeichenfolge mit variabler Länge oder ein Objekt), liest `FileGet` nur die Variablen Daten. Die von der `RecordLength`-Klausel in der `FileOpen`-Funktion angegebene Daten Satz Länge muss größer oder gleich der Länge der gelesenen Daten sein.  
  
-   `FileGet` liest Elemente von Strukturen so, als ob jede einzeln gelesen würde, mit dem Unterschied, dass es keine Auffüll Zeichen zwischen Elementen gibt. Auf einem Datenträger wird einem dynamischen Array in einem benutzerdefinierten Typ (geschrieben mit `FilePut`) ein Deskriptor vorangestellt, dessen Länge 2 plus dem 8-fachen der Anzahl von Dimensionen entspricht: (2 + 8 * anzahlungsdimensionen). Die von der `RecordLength`-Klausel in der `FileOpen`-Funktion angegebene Daten Satz Länge muss größer oder gleich der Summe aller Bytes sein, die zum Lesen der einzelnen Elemente erforderlich sind. Dies schließt beliebige Arrays und deren Deskriptoren ein. Das `VBFixedString`-Attribut kann auf Zeichen folgen Felder in den Strukturen angewendet werden, um die Größe einer Zeichenfolge anzugeben, wenn Sie auf den Datenträger geschrieben wird.  
  
## <a name="binary-mode"></a>Binärmodus  
 Bei Dateien, die im `Binary` Modus geöffnet wurden, gelten die meisten `Random` Modusregeln mit einigen Ausnahmen. Die folgenden Regeln für Dateien, die im `Binary` Modus geöffnet werden, unterscheiden sich von den Regeln für `Random`-Modus:  
  
-   Die `RecordLength`-Klausel in der `FileOpen`-Funktion hat keine Auswirkungen. `FileGet` liest alle Variablen von einem Datenträger zusammenhängend. Das heißt, ohne Auffüll Zeichen zwischen Datensätzen.  
  
-   Bei einem anderen Array als einem Array in einer Struktur liest `FileGet` nur die Daten. Es wurde kein Deskriptor gelesen.  
  
-   `FileGet` liest Zeichen folgen variabler Länge, bei denen es sich nicht um Elemente von Strukturen handelt, ohne den zwei Byte langen Längen Deskriptor zu erwarten. Die Anzahl der gelesenen Bytes ist mit der Anzahl von Zeichen in der Zeichenfolge.  
  
    > [!IMPORTANT]
    >  Zum Lesen aus einer Datei mit der `FileGet`-Funktion ist `Read` Zugriff von der <xref:System.Security.Permissions.FileIOPermissionAccess>-Enumeration erforderlich.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</exception>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files">Lesen aus Dateien in Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files">Schreiben in Dateien in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref char Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FileGet(int32 FileNumber, char&amp; Value, int64 RecordNumber) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Char, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int * char * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, char&amp; Value, int64 RecordNumber) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="Value">Erforderlich. Der gültige Name einer Variablen, in die Daten gelesen werden.</param>
        <param name="RecordNumber">Optional. Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), bei der der Lesevorgang beginnt.</param>
        <summary>Liest Daten aus einer offenen Datenträgerdatei in eine Variable. Die <see langword="My" />-Funktion bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FileGet" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` ist nur im `Random`-und `Binary` Modus gültig.  
  
 Mit `FileGet` gelesene Daten werden in der Regel in eine Datei mit `FilePut`geschrieben.  
  
 Der erste Datensatz oder das Byte in einer Datei befindet sich an Position 1, der zweite Datensatz bzw. das zweite Byte befindet sich an Position 2 usw. Wenn Sie `RecordNumber`weglassen, wird der nächste Datensatz oder das nächste Byte, der auf den letzten `FileGet` oder die `FilePut` Funktion folgt (bzw. auf die letzte `Seek` Funktion verwiesen), gelesen.  
  
> [!IMPORTANT]
>  Treffen Sie beim Lesen aus Dateien keine Entscheidungen zum Inhalt einer Datei, die auf der Dateinamenerweiterung basiert. Beispielsweise ist eine Datei mit dem Namen Form1. vb möglicherweise keine Visual Basic Quelldatei.  
  
## <a name="random-mode"></a>Zufälliger Modus  
 Für Dateien, die im `Random` Modus geöffnet werden, gelten die folgenden Regeln:  
  
-   Wenn die Länge der gelesenen Daten kleiner ist als die Länge, die in der `RecordLength`-Klausel der `FileOpen`-Funktion angegeben ist, liest `FileGet` nachfolgende Datensätze über Grenzen der Daten Satz Länge. Der Leerraum zwischen dem Ende eines Datensatzes und dem Anfang des nächsten Datensatzes wird mit dem vorhandenen Inhalt des Datei Puffers aufgefüllt. Da die Menge der Auffüll Daten nicht mit Sicherheit bestimmt werden kann, empfiehlt es sich im Allgemeinen, die Daten Satz Länge mit der Länge der gelesenen Daten zu vergleichen.  
  
-   Wenn die Variable, die in gelesen wird, eine Zeichenfolge ist, liest `FileGet` standardmäßig einen zwei-Byte-Deskriptor, der die Zeichen folgen Länge enthält, und liest dann die Daten, die in die Variable fließen. Daher muss die von der `RecordLength`-Klausel der `FileOpen`-Funktion angegebene Daten Satz Länge mindestens zwei Bytes aufweisen, die größer als die tatsächliche Länge der Zeichenfolge ist. In Visual Basic 6,0 und früheren Versionen werden Zeichen folgen mit fester Länge unterstützt. beim Einfügen in eine Datei wird der Längen Deskriptor nicht geschrieben. Wenn Sie eine Zeichenfolge ohne den Deskriptor lesen möchten, sollten Sie `True` an den `StringIsFixedLength`-Parameter übergeben, und die Zeichenfolge, in die Sie eingelesen haben, sollte die richtige Länge aufweisen.  
  
-   Wenn die zu lesende Variable ein Array ist, können Sie auswählen, ob ein Deskriptor für die Größe und Dimension des Arrays gelesen werden soll. Legen Sie zum Schreiben des Deskriptors den `ArrayIsDynamic`-Parameter auf `True`fest. Beim Lesen des Arrays müssen Sie der Art und Weise entsprechen, wie das Array geschrieben wurde. Wenn Sie mit dem Deskriptor geschrieben wurde, müssen Sie den Deskriptor lesen. Wenn der Deskriptor nicht verwendet wird, bestimmen die Größe und die Begrenzungen des Arrays, das an `FileGet` übermittelt wird, was gelesen werden soll.  
  
     Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang an. Die Länge ist 2 plus das 8-fache der Anzahl der Dimensionen: (2 + 8 * anzahldimensionen). Die vom `RecordLength`-Parameter in der `FileOpen`-Funktion angegebene Daten Satz Länge muss größer oder gleich der Summe aller Bytes sein, die zum Schreiben der Array Daten und des Array Deskriptors erforderlich sind. Die folgende Array Deklaration benötigt z. b. 218 bytes, wenn das Array auf den Datenträger geschrieben wird.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     Die 218 Bytes werden wie folgt verteilt:  
  
    -   18 Bytes für den Deskriptor: (2 + 8 * 2)  
  
    -   200 Bytes für die Daten: (5 * 10 * 4).  
  
-   Wenn die Variable, die in gelesen wird, ein beliebiger anderer Typ von Variable ist (keine Zeichenfolge mit variabler Länge oder ein Objekt), liest `FileGet` nur die Variablen Daten. Die von der `RecordLength`-Klausel in der `FileOpen`-Funktion angegebene Daten Satz Länge muss größer oder gleich der Länge der gelesenen Daten sein.  
  
-   `FileGet` liest Elemente von Strukturen so, als ob jede einzeln gelesen würde, mit dem Unterschied, dass es keine Auffüll Zeichen zwischen Elementen gibt. Auf einem Datenträger wird einem dynamischen Array in einem benutzerdefinierten Typ (geschrieben mit `FilePut`) ein Deskriptor vorangestellt, dessen Länge 2 plus dem 8-fachen der Anzahl von Dimensionen entspricht: (2 + 8 * anzahlungsdimensionen). Die von der `RecordLength`-Klausel in der `FileOpen`-Funktion angegebene Daten Satz Länge muss größer oder gleich der Summe aller Bytes sein, die zum Lesen der einzelnen Elemente erforderlich sind. Dies schließt beliebige Arrays und deren Deskriptoren ein. Das `VBFixedString`-Attribut kann auf Zeichen folgen Felder in den Strukturen angewendet werden, um die Größe einer Zeichenfolge anzugeben, wenn Sie auf den Datenträger geschrieben wird.  
  
## <a name="binary-mode"></a>Binärmodus  
 Bei Dateien, die im `Binary` Modus geöffnet wurden, gelten die meisten `Random` Modusregeln mit einigen Ausnahmen. Die folgenden Regeln für Dateien, die im `Binary` Modus geöffnet werden, unterscheiden sich von den Regeln für `Random`-Modus:  
  
-   Die `RecordLength`-Klausel in der `FileOpen`-Funktion hat keine Auswirkungen. `FileGet` liest alle Variablen von einem Datenträger zusammenhängend. Das heißt, ohne Auffüll Zeichen zwischen Datensätzen.  
  
-   Bei einem anderen Array als einem Array in einer Struktur liest `FileGet` nur die Daten. Es wurde kein Deskriptor gelesen.  
  
-   `FileGet` liest Zeichen folgen variabler Länge, bei denen es sich nicht um Elemente von Strukturen handelt, ohne den zwei Byte langen Längen Deskriptor zu erwarten. Die Anzahl der gelesenen Bytes ist mit der Anzahl von Zeichen in der Zeichenfolge.  
  
    > [!IMPORTANT]
    >  Zum Lesen aus einer Datei mit der `FileGet`-Funktion ist `Read` Zugriff von der <xref:System.Security.Permissions.FileIOPermissionAccess>-Enumeration erforderlich.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</exception>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files">Lesen aus Dateien in Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files">Schreiben in Dateien in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref DateTime Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FileGet(int32 FileNumber, valuetype System.DateTime&amp; Value, int64 RecordNumber) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As DateTime, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int * DateTime * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, valuetype System.DateTime&amp; Value, int64 RecordNumber) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="Value">Erforderlich. Der gültige Name einer Variablen, in die Daten gelesen werden.</param>
        <param name="RecordNumber">Optional. Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), bei der der Lesevorgang beginnt.</param>
        <summary>Liest Daten aus einer offenen Datenträgerdatei in eine Variable. Die <see langword="My" />-Funktion bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FileGet" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` ist nur im `Random`-und `Binary` Modus gültig.  
  
 Mit `FileGet` gelesene Daten werden in der Regel in eine Datei mit `FilePut`geschrieben.  
  
 Der erste Datensatz oder das Byte in einer Datei befindet sich an Position 1, der zweite Datensatz bzw. das zweite Byte befindet sich an Position 2 usw. Wenn Sie `RecordNumber`weglassen, wird der nächste Datensatz oder das nächste Byte, der auf den letzten `FileGet` oder die `FilePut` Funktion folgt (bzw. auf die letzte `Seek` Funktion verwiesen), gelesen.  
  
> [!IMPORTANT]
>  Treffen Sie beim Lesen aus Dateien keine Entscheidungen zum Inhalt einer Datei, die auf der Dateinamenerweiterung basiert. Beispielsweise ist eine Datei mit dem Namen Form1. vb möglicherweise keine Visual Basic Quelldatei.  
  
## <a name="random-mode"></a>Zufälliger Modus  
 Für Dateien, die im `Random` Modus geöffnet werden, gelten die folgenden Regeln:  
  
-   Wenn die Länge der gelesenen Daten kleiner ist als die Länge, die in der `RecordLength`-Klausel der `FileOpen`-Funktion angegeben ist, liest`FileGet` nachfolgende Datensätze über Grenzen der Daten Satz Länge. Der Leerraum zwischen dem Ende eines Datensatzes und dem Anfang des nächsten Datensatzes wird mit dem vorhandenen Inhalt des Datei Puffers aufgefüllt. Da die Menge der Auffüll Daten nicht mit Sicherheit bestimmt werden kann, empfiehlt es sich im Allgemeinen, die Daten Satz Länge mit der Länge der gelesenen Daten zu vergleichen.  
  
-   Wenn die Variable, die in gelesen wird, eine Zeichenfolge ist, liest `FileGet` standardmäßig einen zwei-Byte-Deskriptor, der die Zeichen folgen Länge enthält, und liest dann die Daten, die in die Variable fließen. Daher muss die von der `RecordLength`-Klausel der `FileOpen`-Funktion angegebene Daten Satz Länge mindestens zwei Bytes aufweisen, die größer als die tatsächliche Länge der Zeichenfolge ist. In Visual Basic 6,0 und früheren Versionen werden Zeichen folgen mit fester Länge unterstützt. beim Einfügen in eine Datei wird der Längen Deskriptor nicht geschrieben. Wenn Sie eine Zeichenfolge ohne den Deskriptor lesen möchten, sollten Sie `True` an den `StringIsFixedLength`-Parameter übergeben, und die Zeichenfolge, in die Sie eingelesen haben, sollte die richtige Länge aufweisen.  
  
-   Wenn die zu lesende Variable ein Array ist, können Sie auswählen, ob ein Deskriptor für die Größe und Dimension des Arrays gelesen werden soll. Legen Sie zum Schreiben des Deskriptors den `ArrayIsDynamic`-Parameter auf `True`fest. Beim Lesen des Arrays müssen Sie der Art und Weise entsprechen, wie das Array geschrieben wurde. Wenn Sie mit dem Deskriptor geschrieben wurde, müssen Sie den Deskriptor lesen. Wenn der Deskriptor nicht verwendet wird, bestimmen die Größe und die Begrenzungen des Arrays, das an `FileGet` übermittelt wird, was gelesen werden soll.  
  
     Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang an. Die Länge ist 2 plus das 8-fache der Anzahl der Dimensionen: (2 + 8 * anzahldimensionen). Die vom `RecordLength`-Parameter in der `FileOpen`-Funktion angegebene Daten Satz Länge muss größer oder gleich der Summe aller Bytes sein, die zum Schreiben der Array Daten und des Array Deskriptors erforderlich sind. Die folgende Array Deklaration benötigt z. b. 218 bytes, wenn das Array auf den Datenträger geschrieben wird.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     Die 218 Bytes werden wie folgt verteilt:  
  
    -   18 Bytes für den Deskriptor: (2 + 8 * 2)  
  
    -   200 Bytes für die Daten: (5 * 10 * 4).  
  
-   Wenn die Variable, die in gelesen wird, ein beliebiger anderer Typ von Variable ist (keine Zeichenfolge mit variabler Länge oder ein Objekt), liest `FileGet` nur die Variablen Daten. Die von der `RecordLength`-Klausel in der `FileOpen`-Funktion angegebene Daten Satz Länge muss größer oder gleich der Länge der gelesenen Daten sein.  
  
-   `FileGet` liest Elemente von Strukturen so, als ob jede einzeln gelesen würde, mit dem Unterschied, dass es keine Auffüll Zeichen zwischen Elementen gibt. Auf einem Datenträger wird einem dynamischen Array in einem benutzerdefinierten Typ (geschrieben mit `FilePut`) ein Deskriptor vorangestellt, dessen Länge 2 plus dem 8-fachen der Anzahl von Dimensionen entspricht: (2 + 8 * anzahlungsdimensionen). Die von der `RecordLength`-Klausel in der `FileOpen`-Funktion angegebene Daten Satz Länge muss größer oder gleich der Summe aller Bytes sein, die zum Lesen der einzelnen Elemente erforderlich sind. Dies schließt beliebige Arrays und deren Deskriptoren ein. Das `VBFixedString`-Attribut kann auf Zeichen folgen Felder in den Strukturen angewendet werden, um die Größe einer Zeichenfolge anzugeben, wenn Sie auf den Datenträger geschrieben wird.  
  
## <a name="binary-mode"></a>Binärmodus  
 Bei Dateien, die im `Binary` Modus geöffnet wurden, gelten die meisten `Random` Modusregeln mit einigen Ausnahmen. Die folgenden Regeln für Dateien, die im `Binary` Modus geöffnet werden, unterscheiden sich von den Regeln für `Random`-Modus:  
  
-   Die `RecordLength`-Klausel in der `FileOpen`-Funktion hat keine Auswirkungen. `FileGet` liest alle Variablen von einem Datenträger zusammenhängend. Das heißt, ohne Auffüll Zeichen zwischen Datensätzen.  
  
-   Bei einem anderen Array als einem Array in einer Struktur liest `FileGet` nur die Daten. Es wurde kein Deskriptor gelesen.  
  
-   `FileGet` liest Zeichen folgen variabler Länge, bei denen es sich nicht um Elemente von Strukturen handelt, ohne den zwei Byte langen Längen Deskriptor zu erwarten. Die Anzahl der gelesenen Bytes ist mit der Anzahl von Zeichen in der Zeichenfolge.  
  
    > [!IMPORTANT]
    >  Zum Lesen aus einer Datei mit der `FileGet`-Funktion ist `Read` Zugriff von der <xref:System.Security.Permissions.FileIOPermissionAccess>-Enumeration erforderlich.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</exception>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files">Lesen aus Dateien in Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files">Schreiben in Dateien in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref decimal Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FileGet(int32 FileNumber, valuetype System.Decimal&amp; Value, int64 RecordNumber) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Decimal, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int * decimal * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, valuetype System.Decimal&amp; Value, int64 RecordNumber) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="Value">Erforderlich. Der gültige Name einer Variablen, in die Daten gelesen werden.</param>
        <param name="RecordNumber">Optional. Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), bei der der Lesevorgang beginnt.</param>
        <summary>Liest Daten aus einer offenen Datenträgerdatei in eine Variable. Die <see langword="My" />-Funktion bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FileGet" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` ist nur im `Random`-und `Binary` Modus gültig.  
  
 Mit `FileGet` gelesene Daten werden in der Regel mithilfe `FilePut`in eine Datei geschrieben.  
  
 Der erste Datensatz oder das Byte in einer Datei befindet sich an Position 1, der zweite Datensatz bzw. das zweite Byte befindet sich an Position 2 usw. Wenn Sie `RecordNumber`weglassen, wird der nächste Datensatz oder das nächste Byte, der auf den letzten `FileGet` oder die `FilePut` Funktion folgt (bzw. auf die letzte `Seek` Funktion verwiesen), gelesen.  
  
> [!IMPORTANT]
>  Treffen Sie beim Lesen aus Dateien keine Entscheidungen zum Inhalt einer Datei, die auf der Dateinamenerweiterung basiert. Beispielsweise ist eine Datei mit dem Namen Form1. vb möglicherweise keine Visual Basic Quelldatei.  
  
## <a name="random-mode"></a>Zufälliger Modus  
 Für Dateien, die im `Random` Modus geöffnet werden, gelten die folgenden Regeln:  
  
-   Wenn die Länge der gelesenen Daten kleiner ist als die Länge, die in der `RecordLength`-Klausel der `FileOpen`-Funktion angegeben ist, liest `FileGet` nachfolgende Datensätze über Grenzen der Daten Satz Länge. Der Leerraum zwischen dem Ende eines Datensatzes und dem Anfang des nächsten Datensatzes wird mit dem vorhandenen Inhalt des Datei Puffers aufgefüllt. Da die Menge der Auffüll Daten nicht mit Sicherheit bestimmt werden kann, empfiehlt es sich im Allgemeinen, die Daten Satz Länge mit der Länge der gelesenen Daten zu vergleichen.  
  
-   Wenn die Variable, die in gelesen wird, eine Zeichenfolge ist, liest `FileGet` standardmäßig einen zwei-Byte-Deskriptor, der die Zeichen folgen Länge enthält, und liest dann die Daten, die in die Variable fließen. Daher muss die von der `RecordLength`-Klausel der `FileOpen`-Funktion angegebene Daten Satz Länge mindestens zwei Bytes aufweisen, die größer als die tatsächliche Länge der Zeichenfolge ist. In Visual Basic 6,0 und früheren Versionen werden Zeichen folgen mit fester Länge unterstützt. beim Einfügen in eine Datei wird der Längen Deskriptor nicht geschrieben. Wenn Sie eine Zeichenfolge ohne den Deskriptor lesen möchten, sollten Sie `True` an den `StringIsFixedLength`-Parameter übergeben, und die Zeichenfolge, in die Sie eingelesen haben, sollte die richtige Länge aufweisen.  
  
-   Wenn die zu lesende Variable ein Array ist, können Sie auswählen, ob ein Deskriptor für die Größe und Dimension des Arrays gelesen werden soll. Legen Sie zum Schreiben des Deskriptors den `ArrayIsDynamic`-Parameter auf `True`fest. Beim Lesen des Arrays müssen Sie der Art und Weise entsprechen, wie das Array geschrieben wurde. Wenn Sie mit dem Deskriptor geschrieben wurde, müssen Sie den Deskriptor lesen. Wenn der Deskriptor nicht verwendet wird, bestimmen die Größe und die Begrenzungen des Arrays, das an `FileGet` übermittelt wird, was gelesen werden soll.  
  
     Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang an. Die Länge ist 2 plus das 8-fache der Anzahl der Dimensionen: (2 + 8 * anzahldimensionen). Die vom `RecordLength`-Parameter in der `FileOpen`-Funktion angegebene Daten Satz Länge muss größer oder gleich der Summe aller Bytes sein, die zum Schreiben der Array Daten und des Array Deskriptors erforderlich sind. Die folgende Array Deklaration benötigt z. b. 218 bytes, wenn das Array auf den Datenträger geschrieben wird.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     Die 218 Bytes werden wie folgt verteilt:  
  
    -   18 Bytes für den Deskriptor: (2 + 8 * 2)  
  
    -   200 Bytes für die Daten: (5 * 10 * 4).  
  
-   Wenn die Variable, die in gelesen wird, ein beliebiger anderer Typ von Variable ist (keine Zeichenfolge mit variabler Länge oder ein Objekt), liest `FileGet` nur die Variablen Daten. Die von der `RecordLength`-Klausel in der `FileOpen`-Funktion angegebene Daten Satz Länge muss größer oder gleich der Länge der gelesenen Daten sein.  
  
-   `FileGet` liest Elemente von Strukturen so, als ob jede einzeln gelesen würde, mit dem Unterschied, dass es keine Auffüll Zeichen zwischen Elementen gibt. Auf einem Datenträger wird einem dynamischen Array in einem benutzerdefinierten Typ (geschrieben mit `FilePut`) ein Deskriptor vorangestellt, dessen Länge 2 plus dem 8-fachen der Anzahl von Dimensionen entspricht: (2 + 8 * anzahlungsdimensionen). Die von der `RecordLength`-Klausel in der `FileOpen`-Funktion angegebene Daten Satz Länge muss größer oder gleich der Summe aller Bytes sein, die zum Lesen der einzelnen Elemente erforderlich sind. Dies schließt beliebige Arrays und deren Deskriptoren ein. Das `VBFixedString`-Attribut kann auf Zeichen folgen Felder in den Strukturen angewendet werden, um die Größe einer Zeichenfolge anzugeben, wenn Sie auf den Datenträger geschrieben wird.  
  
## <a name="binary-mode"></a>Binärmodus  
 Bei Dateien, die im `Binary` Modus geöffnet wurden, gelten die meisten `Random` Modusregeln mit einigen Ausnahmen. Die folgenden Regeln für Dateien, die im `Binary` Modus geöffnet werden, unterscheiden sich von den Regeln für `Random`-Modus:  
  
-   Die `RecordLength`-Klausel in der `FileOpen`-Funktion hat keine Auswirkungen. `FileGet` liest alle Variablen von einem Datenträger zusammenhängend. Das heißt, ohne Auffüll Zeichen zwischen Datensätzen.  
  
-   Bei einem anderen Array als einem Array in einer Struktur liest `FileGet` nur die Daten. Es wurde kein Deskriptor gelesen.  
  
-   `FileGet` liest Zeichen folgen variabler Länge, bei denen es sich nicht um Elemente von Strukturen handelt, ohne den zwei Byte langen Längen Deskriptor zu erwarten. Die Anzahl der gelesenen Bytes ist mit der Anzahl von Zeichen in der Zeichenfolge.  
  
    > [!IMPORTANT]
    >  Zum Lesen aus einer Datei mit der `FileGet`-Funktion ist `Read` Zugriff von der <xref:System.Security.Permissions.FileIOPermissionAccess>-Enumeration erforderlich.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</exception>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files">Lesen aus Dateien in Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files">Schreiben in Dateien in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref double Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FileGet(int32 FileNumber, float64&amp; Value, int64 RecordNumber) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Double, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int * double * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, float64&amp; Value, int64 RecordNumber) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="Value">Erforderlich. Der gültige Name einer Variablen, in die Daten gelesen werden.</param>
        <param name="RecordNumber">Optional. Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), bei der der Lesevorgang beginnt.</param>
        <summary>Liest Daten aus einer offenen Datenträgerdatei in eine Variable. Die <see langword="My" />-Funktion bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FileGet" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` ist nur im `Random`-und `Binary` Modus gültig.  
  
 Mit `FileGet` gelesene Daten werden in der Regel mithilfe `FilePut`in eine Datei geschrieben.  
  
 Der erste Datensatz oder das Byte in einer Datei befindet sich an Position 1, der zweite Datensatz bzw. das zweite Byte befindet sich an Position 2 usw. Wenn Sie `RecordNumber`weglassen, wird der nächste Datensatz oder das nächste Byte, der auf den letzten `FileGet` oder die `FilePut` Funktion folgt (bzw. auf die letzte `Seek` Funktion verwiesen), gelesen.  
  
> [!IMPORTANT]
>  Treffen Sie beim Lesen aus Dateien keine Entscheidungen zum Inhalt einer Datei, die auf der Dateinamenerweiterung basiert. Beispielsweise ist eine Datei mit dem Namen Form1. vb möglicherweise keine Visual Basic Quelldatei.  
  
## <a name="random-mode"></a>Zufälliger Modus  
 Für Dateien, die im `Random` Modus geöffnet werden, gelten die folgenden Regeln:  
  
-   Wenn die Länge der gelesenen Daten kleiner ist als die Länge, die in der `RecordLength`-Klausel der `FileOpen`-Funktion angegeben ist, liest `FileGet` nachfolgende Datensätze über Grenzen der Daten Satz Länge. Der Leerraum zwischen dem Ende eines Datensatzes und dem Anfang des nächsten Datensatzes wird mit dem vorhandenen Inhalt des Datei Puffers aufgefüllt. Da die Menge der Auffüll Daten nicht mit Sicherheit bestimmt werden kann, empfiehlt es sich im Allgemeinen, die Daten Satz Länge mit der Länge der gelesenen Daten zu vergleichen.  
  
-   Wenn die Variable, die in gelesen wird, eine Zeichenfolge ist, liest `FileGet` standardmäßig einen zwei-Byte-Deskriptor, der die Zeichen folgen Länge enthält, und liest dann die Daten, die in die Variable fließen. Daher muss die von der `RecordLength`-Klausel der `FileOpen`-Funktion angegebene Daten Satz Länge mindestens zwei Bytes aufweisen, die größer als die tatsächliche Länge der Zeichenfolge ist. In Visual Basic 6,0 und früheren Versionen werden Zeichen folgen mit fester Länge unterstützt. beim Einfügen in eine Datei wird der Längen Deskriptor nicht geschrieben. Wenn Sie eine Zeichenfolge ohne den Deskriptor lesen möchten, sollten Sie `True` an den `StringIsFixedLength`-Parameter übergeben, und die Zeichenfolge, in die Sie eingelesen haben, sollte die richtige Länge aufweisen.  
  
-   Wenn die zu lesende Variable ein Array ist, können Sie auswählen, ob ein Deskriptor für die Größe und Dimension des Arrays gelesen werden soll. Legen Sie zum Schreiben des Deskriptors den `ArrayIsDynamic`-Parameter auf `True`fest. Beim Lesen des Arrays müssen Sie der Art und Weise entsprechen, wie das Array geschrieben wurde. Wenn Sie mit dem Deskriptor geschrieben wurde, müssen Sie den Deskriptor lesen. Wenn der Deskriptor nicht verwendet wird, bestimmen die Größe und die Begrenzungen des Arrays, das an `FileGet` übermittelt wird, was gelesen werden soll.  
  
     Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang an. Die Länge ist 2 plus das 8-fache der Anzahl der Dimensionen: (2 + 8 * anzahldimensionen). Die vom `RecordLength`-Parameter in der `FileOpen`-Funktion angegebene Daten Satz Länge muss größer oder gleich der Summe aller Bytes sein, die zum Schreiben der Array Daten und des Array Deskriptors erforderlich sind. Die folgende Array Deklaration benötigt z. b. 218 bytes, wenn das Array auf den Datenträger geschrieben wird.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     Die 218 Bytes werden wie folgt verteilt:  
  
    -   18 Bytes für den Deskriptor: (2 + 8 * 2)  
  
    -   200 Bytes für die Daten: (5 * 10 * 4).  
  
-   Wenn die Variable, die in gelesen wird, ein beliebiger anderer Typ von Variable ist (keine Zeichenfolge mit variabler Länge oder ein Objekt), liest `FileGet` nur die Variablen Daten. Die von der `RecordLength`-Klausel in der `FileOpen`-Funktion angegebene Daten Satz Länge muss größer oder gleich der Länge der gelesenen Daten sein.  
  
-   `FileGet` liest Elemente von Strukturen so, als ob jede einzeln gelesen würde, mit dem Unterschied, dass es keine Auffüll Zeichen zwischen Elementen gibt. Auf einem Datenträger wird einem dynamischen Array in einem benutzerdefinierten Typ (geschrieben mit `FilePut`) ein Deskriptor vorangestellt, dessen Länge 2 plus dem 8-fachen der Anzahl von Dimensionen entspricht: (2 + 8 * anzahlungsdimensionen). Die von der `RecordLength`-Klausel in der `FileOpen`-Funktion angegebene Daten Satz Länge muss größer oder gleich der Summe aller Bytes sein, die zum Lesen der einzelnen Elemente erforderlich sind. Dies schließt beliebige Arrays und deren Deskriptoren ein. Das `VBFixedString`-Attribut kann auf Zeichen folgen Felder in den Strukturen angewendet werden, um die Größe einer Zeichenfolge anzugeben, wenn Sie auf den Datenträger geschrieben wird.  
  
## <a name="binary-mode"></a>Binärmodus  
 Bei Dateien, die im `Binary` Modus geöffnet wurden, gelten die meisten `Random` Modusregeln mit einigen Ausnahmen. Die folgenden Regeln für Dateien, die im `Binary` Modus geöffnet werden, unterscheiden sich von den Regeln für `Random`-Modus:  
  
-   Die `RecordLength`-Klausel in der `FileOpen`-Funktion hat keine Auswirkungen. `FileGet` liest alle Variablen von einem Datenträger zusammenhängend. Das heißt, ohne Auffüll Zeichen zwischen Datensätzen.  
  
-   Bei einem anderen Array als einem Array in einer Struktur liest `FileGet` nur die Daten. Es wurde kein Deskriptor gelesen.  
  
-   `FileGet` liest Zeichen folgen variabler Länge, bei denen es sich nicht um Elemente von Strukturen handelt, ohne den zwei Byte langen Längen Deskriptor zu erwarten. Die Anzahl der gelesenen Bytes ist mit der Anzahl von Zeichen in der Zeichenfolge.  
  
    > [!IMPORTANT]
    >  Zum Lesen aus einer Datei mit der`FileGet`-Funktion ist `Read` Zugriff von der <xref:System.Security.Permissions.FileIOPermissionAccess>-Enumeration erforderlich.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</exception>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files">Lesen aus Dateien in Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files">Schreiben in Dateien in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref short Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FileGet(int32 FileNumber, int16&amp; Value, int64 RecordNumber) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Short, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int * int16 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int16&amp; Value, int64 RecordNumber) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="Value">Erforderlich. Der gültige Name einer Variablen, in die Daten gelesen werden.</param>
        <param name="RecordNumber">Optional. Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), bei der der Lesevorgang beginnt.</param>
        <summary>Liest Daten aus einer offenen Datenträgerdatei in eine Variable. Die <see langword="My" />-Funktion bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FileGet" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` ist nur im `Random`-und `Binary` Modus gültig.  
  
 Mit `FileGet` gelesene Daten werden in der Regel mithilfe `FilePut`in eine Datei geschrieben.  
  
 Der erste Datensatz oder das Byte in einer Datei befindet sich an Position 1, der zweite Datensatz bzw. das zweite Byte befindet sich an Position 2 usw. Wenn Sie `RecordNumber`weglassen, wird der nächste Datensatz oder das nächste Byte, der auf den letzten `FileGet` oder die `FilePut` Funktion folgt (bzw. auf die letzte `Seek` Funktion verwiesen), gelesen.  
  
> [!IMPORTANT]
>  Treffen Sie beim Lesen aus Dateien keine Entscheidungen zum Inhalt einer Datei, die auf der Dateinamenerweiterung basiert. Beispielsweise ist eine Datei mit dem Namen Form1. vb möglicherweise keine Visual Basic Quelldatei.  
  
## <a name="random-mode"></a>Zufälliger Modus  
 Für Dateien, die im `Random` Modus geöffnet werden, gelten die folgenden Regeln:  
  
-   Wenn die Länge der gelesenen Daten kleiner ist als die Länge, die in der `RecordLength`-Klausel der `FileOpen`-Funktion angegeben ist, liest `FileGet` nachfolgende Datensätze über Grenzen der Daten Satz Länge. Der Leerraum zwischen dem Ende eines Datensatzes und dem Anfang des nächsten Datensatzes wird mit dem vorhandenen Inhalt des Datei Puffers aufgefüllt. Da die Menge der Auffüll Daten nicht mit Sicherheit bestimmt werden kann, empfiehlt es sich im Allgemeinen, die Daten Satz Länge mit der Länge der gelesenen Daten zu vergleichen.  
  
-   Wenn die Variable, die in gelesen wird, eine Zeichenfolge ist, liest `FileGet` standardmäßig einen zwei-Byte-Deskriptor, der die Zeichen folgen Länge enthält, und liest dann die Daten, die in die Variable fließen. Daher muss die von der `RecordLength`-Klausel der `FileOpen`-Funktion angegebene Daten Satz Länge mindestens zwei Bytes aufweisen, die größer als die tatsächliche Länge der Zeichenfolge ist. In Visual Basic 6,0 und früheren Versionen werden Zeichen folgen mit fester Länge unterstützt. beim Einfügen in eine Datei wird der Längen Deskriptor nicht geschrieben. Wenn Sie eine Zeichenfolge ohne den Deskriptor lesen möchten, sollten Sie `True` an den `StringIsFixedLength`-Parameter übergeben, und die Zeichenfolge, in die Sie eingelesen haben, sollte die richtige Länge aufweisen.  
  
-   Wenn die zu lesende Variable ein Array ist, können Sie auswählen, ob ein Deskriptor für die Größe und Dimension des Arrays gelesen werden soll. Legen Sie zum Schreiben des Deskriptors den `ArrayIsDynamic`-Parameter auf `True`fest. Beim Lesen des Arrays müssen Sie der Art und Weise entsprechen, wie das Array geschrieben wurde. Wenn Sie mit dem Deskriptor geschrieben wurde, müssen Sie den Deskriptor lesen. Wenn der Deskriptor nicht verwendet wird, bestimmen die Größe und die Begrenzungen des Arrays, das an `FileGet` übermittelt wird, was gelesen werden soll.  
  
     Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang an. Die Länge ist 2 plus das 8-fache der Anzahl der Dimensionen: (2 + 8 * anzahldimensionen). Die vom `RecordLength`-Parameter in der `FileOpen`-Funktion angegebene Daten Satz Länge muss größer oder gleich der Summe aller Bytes sein, die zum Schreiben der Array Daten und des Array Deskriptors erforderlich sind. Die folgende Array Deklaration benötigt z. b. 218 bytes, wenn das Array auf den Datenträger geschrieben wird.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     Die 218 Bytes werden wie folgt verteilt:  
  
    -   18 Bytes für den Deskriptor: (2 + 8 * 2)  
  
    -   200 Bytes für die Daten: (5 * 10 * 4).  
  
-   Wenn die Variable, die in gelesen wird, ein beliebiger anderer Typ von Variable ist (keine Zeichenfolge mit variabler Länge oder ein Objekt), liest `FileGet` nur die Variablen Daten. Die von der `RecordLength`-Klausel in der `FileOpen`-Funktion angegebene Daten Satz Länge muss größer oder gleich der Länge der gelesenen Daten sein.  
  
-   `FileGet` liest Elemente von Strukturen so, als ob jede einzeln gelesen würde, mit dem Unterschied, dass es keine Auffüll Zeichen zwischen Elementen gibt. Auf einem Datenträger wird einem dynamischen Array in einem benutzerdefinierten Typ (geschrieben mit `FilePut`) ein Deskriptor vorangestellt, dessen Länge 2 plus dem 8-fachen der Anzahl von Dimensionen entspricht: (2 + 8 * anzahlungsdimensionen). Die von der `RecordLength`-Klausel in der `FileOpen`-Funktion angegebene Daten Satz Länge muss größer oder gleich der Summe aller Bytes sein, die zum Lesen der einzelnen Elemente erforderlich sind. Dies schließt beliebige Arrays und deren Deskriptoren ein. Das `VBFixedString`-Attribut kann auf Zeichen folgen Felder in den Strukturen angewendet werden, um die Größe einer Zeichenfolge anzugeben, wenn Sie auf den Datenträger geschrieben wird.  
  
## <a name="binary-mode"></a>Binärmodus  
 Bei Dateien, die im `Binary` Modus geöffnet wurden, gelten die meisten `Random` Modusregeln mit einigen Ausnahmen. Die folgenden Regeln für Dateien, die im `Binary` Modus geöffnet werden, unterscheiden sich von den Regeln für `Random`-Modus:  
  
-   Die `RecordLength`-Klausel in der `FileOpen`-Funktion hat keine Auswirkungen. `FileGet` liest alle Variablen von einem Datenträger zusammenhängend. Das heißt, ohne Auffüll Zeichen zwischen Datensätzen.  
  
-   Bei einem anderen Array als einem Array in einer Struktur liest `FileGet` nur die Daten. Es wurde kein Deskriptor gelesen.  
  
-   `FileGet` liest Zeichen folgen variabler Länge, bei denen es sich nicht um Elemente von Strukturen handelt, ohne den zwei Byte langen Längen Deskriptor zu erwarten. Die Anzahl der gelesenen Bytes ist mit der Anzahl von Zeichen in der Zeichenfolge.  
  
    > [!IMPORTANT]
    >  Zum Lesen aus einer Datei mit der `FileGet`-Funktion ist `Read` Zugriff von der <xref:System.Security.Permissions.FileIOPermissionAccess>-Enumeration erforderlich.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</exception>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files">Lesen aus Dateien in Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files">Schreiben in Dateien in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref int Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FileGet(int32 FileNumber, int32&amp; Value, int64 RecordNumber) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Integer, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int * int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int32&amp; Value, int64 RecordNumber) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="Value">Erforderlich. Der gültige Name einer Variablen, in die Daten gelesen werden.</param>
        <param name="RecordNumber">Optional. Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), bei der der Lesevorgang beginnt.</param>
        <summary>Liest Daten aus einer offenen Datenträgerdatei in eine Variable. Die <see langword="My" />-Funktion bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FileGet" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` ist nur im `Random`-und `Binary` Modus gültig.  
  
 Mit `FileGet` gelesene Daten werden in der Regel mithilfe `FilePut`in eine Datei geschrieben.  
  
 Der erste Datensatz oder das Byte in einer Datei befindet sich an Position 1, der zweite Datensatz bzw. das zweite Byte befindet sich an Position 2 usw. Wenn Sie `RecordNumber`weglassen, wird der nächste Datensatz oder das nächste Byte, der auf den letzten `FileGet` oder die `FilePut` Funktion folgt (bzw. auf die letzte `Seek` Funktion verwiesen), gelesen.  
  
> [!IMPORTANT]
>  Treffen Sie beim Lesen aus Dateien keine Entscheidungen zum Inhalt einer Datei, die auf der Dateinamenerweiterung basiert. Beispielsweise ist eine Datei mit dem Namen Form1. vb möglicherweise keine Visual Basic Quelldatei.  
  
## <a name="random-mode"></a>Zufälliger Modus  
 Für Dateien, die im `Random` Modus geöffnet werden, gelten die folgenden Regeln:  
  
-   Wenn die Länge der gelesenen Daten kleiner ist als die Länge, die in der `RecordLength`-Klausel der `FileOpen`-Funktion angegeben ist, liest `FileGet` nachfolgende Datensätze über Grenzen der Daten Satz Länge. Der Leerraum zwischen dem Ende eines Datensatzes und dem Anfang des nächsten Datensatzes wird mit dem vorhandenen Inhalt des Datei Puffers aufgefüllt. Da die Menge der Auffüll Daten nicht mit Sicherheit bestimmt werden kann, empfiehlt es sich im Allgemeinen, die Daten Satz Länge mit der Länge der gelesenen Daten zu vergleichen.  
  
-   Wenn die Variable, die in gelesen wird, eine Zeichenfolge ist, liest `FileGet` standardmäßig einen zwei-Byte-Deskriptor, der die Zeichen folgen Länge enthält, und liest dann die Daten, die in die Variable fließen. Daher muss die von der `RecordLength`-Klausel der `FileOpen`-Funktion angegebene Daten Satz Länge mindestens zwei Bytes aufweisen, die größer als die tatsächliche Länge der Zeichenfolge ist. In Visual Basic 6,0 und früheren Versionen werden Zeichen folgen mit fester Länge unterstützt. beim Einfügen in eine Datei wird der Längen Deskriptor nicht geschrieben. Wenn Sie eine Zeichenfolge ohne den Deskriptor lesen möchten, sollten Sie `True` an den `StringIsFixedLength`-Parameter übergeben, und die Zeichenfolge, in die Sie eingelesen haben, sollte die richtige Länge aufweisen.  
  
-   Wenn die zu lesende Variable ein Array ist, können Sie auswählen, ob ein Deskriptor für die Größe und Dimension des Arrays gelesen werden soll. Legen Sie zum Schreiben des Deskriptors den `ArrayIsDynamic`-Parameter auf `True`fest. Beim Lesen des Arrays müssen Sie der Art und Weise entsprechen, wie das Array geschrieben wurde. Wenn Sie mit dem Deskriptor geschrieben wurde, müssen Sie den Deskriptor lesen. Wenn der Deskriptor nicht verwendet wird, bestimmen die Größe und die Begrenzungen des Arrays, das an `FileGet` übermittelt wird, was gelesen werden soll.  
  
     Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang an. Die Länge ist 2 plus das 8-fache der Anzahl der Dimensionen: (2 + 8 * anzahldimensionen). Die vom `RecordLength`-Parameter in der `FileOpen`-Funktion angegebene Daten Satz Länge muss größer oder gleich der Summe aller Bytes sein, die zum Schreiben der Array Daten und des Array Deskriptors erforderlich sind. Die folgende Array Deklaration benötigt z. b. 218 bytes, wenn das Array auf den Datenträger geschrieben wird.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     Die 218 Bytes werden wie folgt verteilt:  
  
    -   18 Bytes für den Deskriptor: (2 + 8 * 2)  
  
    -   200 Bytes für die Daten: (5 * 10 * 4).  
  
-   Wenn die Variable, die in gelesen wird, ein beliebiger anderer Typ von Variable ist (keine Zeichenfolge mit variabler Länge oder ein Objekt), liest `FileGet` nur die Variablen Daten. Die von der `RecordLength`-Klausel in der `FileOpen`-Funktion angegebene Daten Satz Länge muss größer oder gleich der Länge der gelesenen Daten sein.  
  
-   `FileGet` liest Elemente von Strukturen so, als ob jede einzeln gelesen würde, mit dem Unterschied, dass es keine Auffüll Zeichen zwischen Elementen gibt. Auf einem Datenträger wird einem dynamischen Array in einem benutzerdefinierten Typ (geschrieben mit `FilePut`) ein Deskriptor vorangestellt, dessen Länge 2 plus dem 8-fachen der Anzahl von Dimensionen entspricht: (2 + 8 * anzahlungsdimensionen). Die von der `RecordLength`-Klausel in der `FileOpen`-Funktion angegebene Daten Satz Länge muss größer oder gleich der Summe aller Bytes sein, die zum Lesen der einzelnen Elemente erforderlich sind. Dies schließt beliebige Arrays und deren Deskriptoren ein. Das `VBFixedString`-Attribut kann auf Zeichen folgen Felder in den Strukturen angewendet werden, um die Größe einer Zeichenfolge anzugeben, wenn Sie auf den Datenträger geschrieben wird.  
  
## <a name="binary-mode"></a>Binärmodus  
 Bei Dateien, die im `Binary` Modus geöffnet wurden, gelten die meisten `Random` Modusregeln mit einigen Ausnahmen. Die folgenden Regeln für Dateien, die im `Binary` Modus geöffnet werden, unterscheiden sich von den Regeln für `Random`-Modus:  
  
-   Die `RecordLength`-Klausel in der `FileOpen`-Funktion hat keine Auswirkungen. `FileGet` liest alle Variablen von einem Datenträger zusammenhängend. Das heißt, ohne Auffüll Zeichen zwischen Datensätzen.  
  
-   Bei einem anderen Array als einem Array in einer Struktur liest `FileGet` nur die Daten. Es wurde kein Deskriptor gelesen.  
  
-   `FileGet` liest Zeichen folgen variabler Länge, bei denen es sich nicht um Elemente von Strukturen handelt, ohne den zwei Byte langen Längen Deskriptor zu erwarten. Die Anzahl der gelesenen Bytes ist mit der Anzahl von Zeichen in der Zeichenfolge.  
  
    > [!IMPORTANT]
    >  Zum Lesen aus einer Datei mit der `FileGet`-Funktion ist `Read` Zugriff von der <xref:System.Security.Permissions.FileIOPermissionAccess>-Enumeration erforderlich.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</exception>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files">Lesen aus Dateien in Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files">Schreiben in Dateien in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref long Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FileGet(int32 FileNumber, int64&amp; Value, int64 RecordNumber) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Long, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int * int64 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int64&amp; Value, int64 RecordNumber) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="Value">Erforderlich. Der gültige Name einer Variablen, in die Daten gelesen werden.</param>
        <param name="RecordNumber">Optional. Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), bei der der Lesevorgang beginnt.</param>
        <summary>Liest Daten aus einer offenen Datenträgerdatei in eine Variable. Die <see langword="My" />-Funktion bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FileGet" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` ist nur im `Random`-und `Binary` Modus gültig.  
  
 Mit `FileGet` gelesene Daten werden in der Regel mithilfe `FilePut`in eine Datei geschrieben.  
  
 Der erste Datensatz oder das Byte in einer Datei befindet sich an Position 1, der zweite Datensatz bzw. das zweite Byte befindet sich an Position 2 usw. Wenn Sie `RecordNumber`weglassen, wird der nächste Datensatz oder das nächste Byte, der auf den letzten `FileGet` oder die `FilePut` Funktion folgt (bzw. auf die letzte `Seek` Funktion verwiesen), gelesen.  
  
> [!IMPORTANT]
>  Treffen Sie beim Lesen aus Dateien keine Entscheidungen zum Inhalt einer Datei, die auf der Dateinamenerweiterung basiert. Beispielsweise ist eine Datei mit dem Namen Form1. vb möglicherweise keine Visual Basic Quelldatei.  
  
## <a name="random-mode"></a>Zufälliger Modus  
 Für Dateien, die im `Random` Modus geöffnet werden, gelten die folgenden Regeln:  
  
-   Wenn die Länge der gelesenen Daten kleiner ist als die Länge, die in der `RecordLength`-Klausel der `FileOpen`-Funktion angegeben ist, liest `FileGet` nachfolgende Datensätze über Grenzen der Daten Satz Länge. Der Leerraum zwischen dem Ende eines Datensatzes und dem Anfang des nächsten Datensatzes wird mit dem vorhandenen Inhalt des Datei Puffers aufgefüllt. Da die Menge der Auffüll Daten nicht mit Sicherheit bestimmt werden kann, empfiehlt es sich im Allgemeinen, die Daten Satz Länge mit der Länge der gelesenen Daten zu vergleichen.  
  
-   Wenn die Variable, die in gelesen wird, eine Zeichenfolge ist, liest `FileGet` standardmäßig einen zwei-Byte-Deskriptor, der die Zeichen folgen Länge enthält, und liest dann die Daten, die in die Variable fließen. Daher muss die von der `RecordLength`-Klausel der `FileOpen`-Funktion angegebene Daten Satz Länge mindestens zwei Bytes aufweisen, die größer als die tatsächliche Länge der Zeichenfolge ist. In Visual Basic 6,0 und früheren Versionen werden Zeichen folgen mit fester Länge unterstützt. beim Einfügen in eine Datei wird der Längen Deskriptor nicht geschrieben. Wenn Sie eine Zeichenfolge ohne den Deskriptor lesen möchten, sollten Sie `True` an den `StringIsFixedLength`-Parameter übergeben, und die Zeichenfolge, in die Sie eingelesen haben, sollte die richtige Länge aufweisen.  
  
-   Wenn die zu lesende Variable ein Array ist, können Sie auswählen, ob ein Deskriptor für die Größe und Dimension des Arrays gelesen werden soll. Legen Sie zum Schreiben des Deskriptors den `ArrayIsDynamic`-Parameter auf `True`fest. Beim Lesen des Arrays müssen Sie der Art und Weise entsprechen, wie das Array geschrieben wurde. Wenn Sie mit dem Deskriptor geschrieben wurde, müssen Sie den Deskriptor lesen. Wenn der Deskriptor nicht verwendet wird, bestimmen die Größe und die Begrenzungen des Arrays, das an `FileGet` übermittelt wird, was gelesen werden soll.  
  
     Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang an. Die Länge ist 2 plus das 8-fache der Anzahl der Dimensionen: (2 + 8 * anzahldimensionen). Die vom `RecordLength`-Parameter in der `FileOpen`-Funktion angegebene Daten Satz Länge muss größer oder gleich der Summe aller Bytes sein, die zum Schreiben der Array Daten und des Array Deskriptors erforderlich sind. Die folgende Array Deklaration benötigt z. b. 218 bytes, wenn das Array auf den Datenträger geschrieben wird.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     Die 218 Bytes werden wie folgt verteilt:  
  
    -   18 Bytes für den Deskriptor: (2 + 8 * 2)  
  
    -   200 Bytes für die Daten: (5 * 10 * 4).  
  
-   Wenn die Variable, die in gelesen wird, ein beliebiger anderer Typ von Variable ist (keine Zeichenfolge mit variabler Länge oder ein Objekt), liest `FileGet` nur die Variablen Daten. Die von der `RecordLength`-Klausel in der `FileOpen`-Funktion angegebene Daten Satz Länge muss größer oder gleich der Länge der gelesenen Daten sein.  
  
-   `FileGet` liest Elemente von Strukturen so, als ob jede einzeln gelesen würde, mit dem Unterschied, dass es keine Auffüll Zeichen zwischen Elementen gibt. Auf einem Datenträger wird einem dynamischen Array in einem benutzerdefinierten Typ (geschrieben mit `FilePut`) ein Deskriptor vorangestellt, dessen Länge 2 plus dem 8-fachen der Anzahl von Dimensionen entspricht: (2 + 8 * anzahlungsdimensionen). Die von der `RecordLength`-Klausel in der `FileOpen`-Funktion angegebene Daten Satz Länge muss größer oder gleich der Summe aller Bytes sein, die zum Lesen der einzelnen Elemente erforderlich sind. Dies schließt beliebige Arrays und deren Deskriptoren ein. Das `VBFixedString`-Attribut kann auf Zeichen folgen Felder in den Strukturen angewendet werden, um die Größe einer Zeichenfolge anzugeben, wenn Sie auf den Datenträger geschrieben wird.  
  
## <a name="binary-mode"></a>Binärmodus  
 Bei Dateien, die im `Binary` Modus geöffnet wurden, gelten die meisten `Random` Modusregeln mit einigen Ausnahmen. Die folgenden Regeln für Dateien, die im `Binary` Modus geöffnet werden, unterscheiden sich von den Regeln für `Random`-Modus:  
  
-   Die `RecordLength`-Klausel in der `FileOpen`-Funktion hat keine Auswirkungen. `FileGet` liest alle Variablen von einem Datenträger zusammenhängend. Das heißt, ohne Auffüll Zeichen zwischen Datensätzen.  
  
-   Bei einem anderen Array als einem Array in einer Struktur liest `FileGet` nur die Daten. Es wurde kein Deskriptor gelesen.  
  
-   `FileGet` liest Zeichen folgen variabler Länge, bei denen es sich nicht um Elemente von Strukturen handelt, ohne den zwei Byte langen Längen Deskriptor zu erwarten. Die Anzahl der gelesenen Bytes ist mit der Anzahl von Zeichen in der Zeichenfolge.  
  
    > [!IMPORTANT]
    >  Zum Lesen aus einer Datei mit der `FileGet`-Funktion ist `Read` Zugriff von der <xref:System.Security.Permissions.FileIOPermissionAccess>-Enumeration erforderlich.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</exception>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files">Lesen aus Dateien in Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files">Schreiben in Dateien in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref float Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FileGet(int32 FileNumber, float32&amp; Value, int64 RecordNumber) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Single, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int * single * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, float32&amp; Value, int64 RecordNumber) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="Value">Erforderlich. Der gültige Name einer Variablen, in die Daten gelesen werden.</param>
        <param name="RecordNumber">Optional. Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), bei der der Lesevorgang beginnt.</param>
        <summary>Liest Daten aus einer offenen Datenträgerdatei in eine Variable. Die <see langword="My" />-Funktion bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FileGet" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` ist nur im `Random`-und `Binary` Modus gültig.  
  
 Mit `FileGet` gelesene Daten werden in der Regel mithilfe `FilePut`in eine Datei geschrieben.  
  
 Der erste Datensatz oder das Byte in einer Datei befindet sich an Position 1, der zweite Datensatz bzw. das zweite Byte befindet sich an Position 2 usw. Wenn Sie `RecordNumber`weglassen, wird der nächste Datensatz oder das nächste Byte, der auf den letzten `FileGet` oder die `FilePut` Funktion folgt (bzw. auf die letzte `Seek` Funktion verwiesen), gelesen.  
  
> [!IMPORTANT]
>  Treffen Sie beim Lesen aus Dateien keine Entscheidungen zum Inhalt einer Datei, die auf der Dateinamenerweiterung basiert. Beispielsweise ist eine Datei mit dem Namen Form1. vb möglicherweise keine Visual Basic Quelldatei.  
  
## <a name="random-mode"></a>Zufälliger Modus  
 Für Dateien, die im `Random` Modus geöffnet werden, gelten die folgenden Regeln:  
  
-   Wenn die Länge der gelesenen Daten kleiner ist als die Länge, die in der `RecordLength`-Klausel der `FileOpen`-Funktion angegeben ist, liest `FileGet` nachfolgende Datensätze über Grenzen der Daten Satz Länge. Der Leerraum zwischen dem Ende eines Datensatzes und dem Anfang des nächsten Datensatzes wird mit dem vorhandenen Inhalt des Datei Puffers aufgefüllt. Da die Menge der Auffüll Daten nicht mit Sicherheit bestimmt werden kann, empfiehlt es sich im Allgemeinen, die Daten Satz Länge mit der Länge der gelesenen Daten zu vergleichen.  
  
-   Wenn die Variable, die in gelesen wird, eine Zeichenfolge ist, liest `FileGet` standardmäßig einen zwei-Byte-Deskriptor, der die Zeichen folgen Länge enthält, und liest dann die Daten, die in die Variable fließen. Daher muss die von der `RecordLength`-Klausel der `FileOpen`-Funktion angegebene Daten Satz Länge mindestens zwei Bytes aufweisen, die größer als die tatsächliche Länge der Zeichenfolge ist. In Visual Basic 6,0 und früheren Versionen werden Zeichen folgen mit fester Länge unterstützt. beim Einfügen in eine Datei wird der Längen Deskriptor nicht geschrieben. Wenn Sie eine Zeichenfolge ohne den Deskriptor lesen möchten, sollten Sie `True` an den `StringIsFixedLength`-Parameter übergeben, und die Zeichenfolge, in die Sie eingelesen haben, sollte die richtige Länge aufweisen.  
  
-   Wenn die zu lesende Variable ein Array ist, können Sie auswählen, ob ein Deskriptor für die Größe und Dimension des Arrays gelesen werden soll. Legen Sie zum Schreiben des Deskriptors den `ArrayIsDynamic`-Parameter auf `True`fest. Beim Lesen des Arrays müssen Sie der Art und Weise entsprechen, wie das Array geschrieben wurde. Wenn Sie mit dem Deskriptor geschrieben wurde, müssen Sie den Deskriptor lesen. Wenn der Deskriptor nicht verwendet wird, bestimmen die Größe und die Begrenzungen des Arrays, das an `FileGet` übermittelt wird, was gelesen werden soll.  
  
     Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang an. Die Länge ist 2 plus das 8-fache der Anzahl der Dimensionen: (2 + 8 * anzahldimensionen). Die vom `RecordLength`-Parameter in der `FileOpen`-Funktion angegebene Daten Satz Länge muss größer oder gleich der Summe aller Bytes sein, die zum Schreiben der Array Daten und des Array Deskriptors erforderlich sind. Die folgende Array Deklaration benötigt z. b. 218 bytes, wenn das Array auf den Datenträger geschrieben wird.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     Die 218 Bytes werden wie folgt verteilt:  
  
    -   18 Bytes für den Deskriptor: (2 + 8 * 2)  
  
    -   200 Bytes für die Daten: (5 * 10 * 4).  
  
-   Wenn die Variable, die in gelesen wird, ein beliebiger anderer Typ von Variable ist (keine Zeichenfolge mit variabler Länge oder ein Objekt), liest `FileGet` nur die Variablen Daten. Die von der `RecordLength`-Klausel in der `FileOpen`-Funktion angegebene Daten Satz Länge muss größer oder gleich der Länge der gelesenen Daten sein.  
  
-   `FileGet` liest Elemente von Strukturen so, als ob jede einzeln gelesen würde, mit dem Unterschied, dass es keine Auffüll Zeichen zwischen Elementen gibt. Auf einem Datenträger wird einem dynamischen Array in einem benutzerdefinierten Typ (geschrieben mit `FilePut`) ein Deskriptor vorangestellt, dessen Länge 2 plus dem 8-fachen der Anzahl von Dimensionen entspricht: (2 + 8 * anzahlungsdimensionen). Die von der `RecordLength`-Klausel in der `FileOpen`-Funktion angegebene Daten Satz Länge muss größer oder gleich der Summe aller Bytes sein, die zum Lesen der einzelnen Elemente erforderlich sind. Dies schließt beliebige Arrays und deren Deskriptoren ein. Das `VBFixedString`-Attribut kann auf Zeichen folgen Felder in den Strukturen angewendet werden, um die Größe einer Zeichenfolge anzugeben, wenn Sie auf den Datenträger geschrieben wird.  
  
## <a name="binary-mode"></a>Binärmodus  
 Bei Dateien, die im `Binary` Modus geöffnet wurden, gelten die meisten `Random` Modusregeln mit einigen Ausnahmen. Die folgenden Regeln für Dateien, die im `Binary` Modus geöffnet werden, unterscheiden sich von den Regeln für `Random`-Modus:  
  
-   Die `RecordLength`-Klausel in der `FileOpen`-Funktion hat keine Auswirkungen. `FileGet` liest alle Variablen von einem Datenträger zusammenhängend. Das heißt, ohne Auffüll Zeichen zwischen Datensätzen.  
  
-   Bei einem anderen Array als einem Array in einer Struktur liest `FileGet` nur die Daten. Es wurde kein Deskriptor gelesen.  
  
-   `FileGet` liest Zeichen folgen variabler Länge, bei denen es sich nicht um Elemente von Strukturen handelt, ohne den zwei Byte langen Längen Deskriptor zu erwarten. Die Anzahl der gelesenen Bytes ist mit der Anzahl von Zeichen in der Zeichenfolge.  
  
    > [!IMPORTANT]
    >  Zum Lesen aus einer Datei mit der `FileGet`-Funktion ist `Read` Zugriff von der <xref:System.Security.Permissions.FileIOPermissionAccess>-Enumeration erforderlich.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</exception>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files">Lesen aus Dateien in Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files">Schreiben in Dateien in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref ValueType Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FileGet(int32 FileNumber, class System.ValueType&amp; Value, int64 RecordNumber) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As ValueType, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int * ValueType * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, class System.ValueType&amp; Value, int64 RecordNumber) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.ValueType" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="Value">Erforderlich. Der gültige Name einer Variablen, in die Daten gelesen werden.</param>
        <param name="RecordNumber">Optional. Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), bei der der Lesevorgang beginnt.</param>
        <summary>Liest Daten aus einer offenen Datenträgerdatei in eine Variable. Die <see langword="My" />-Funktion bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FileGet" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` ist nur im `Random`-und `Binary` Modus gültig.  
  
 Mit `FileGet` gelesene Daten werden in der Regel mithilfe `FilePut`in eine Datei geschrieben.  
  
 Der erste Datensatz oder das Byte in einer Datei befindet sich an Position 1, der zweite Datensatz bzw. das zweite Byte befindet sich an Position 2 usw. Wenn Sie `RecordNumber`weglassen, wird der nächste Datensatz oder das nächste Byte, der auf den letzten `FileGet` oder die `FilePut` Funktion folgt (bzw. auf die letzte `Seek` Funktion verwiesen), gelesen.  
  
> [!IMPORTANT]
>  Treffen Sie beim Lesen aus Dateien keine Entscheidungen zum Inhalt einer Datei, die auf der Dateinamenerweiterung basiert. Beispielsweise ist eine Datei mit dem Namen Form1. vb möglicherweise keine Visual Basic Quelldatei.  
  
## <a name="random-mode"></a>Zufälliger Modus  
 Für Dateien, die im `Random` Modus geöffnet werden, gelten die folgenden Regeln:  
  
-   Wenn die Länge der gelesenen Daten kleiner ist als die Länge, die in der `RecordLength`-Klausel der `FileOpen`-Funktion angegeben ist, liest `FileGet` nachfolgende Datensätze über Grenzen der Daten Satz Länge. Der Leerraum zwischen dem Ende eines Datensatzes und dem Anfang des nächsten Datensatzes wird mit dem vorhandenen Inhalt des Datei Puffers aufgefüllt. Da die Menge der Auffüll Daten nicht mit Sicherheit bestimmt werden kann, empfiehlt es sich im Allgemeinen, die Daten Satz Länge mit der Länge der gelesenen Daten zu vergleichen.  
  
-   Wenn die Variable, die in gelesen wird, eine Zeichenfolge ist, liest `FileGet` standardmäßig einen zwei-Byte-Deskriptor, der die Zeichen folgen Länge enthält, und liest dann die Daten, die in die Variable fließen. Daher muss die von der `RecordLength`-Klausel der `FileOpen`-Funktion angegebene Daten Satz Länge mindestens zwei Bytes aufweisen, die größer als die tatsächliche Länge der Zeichenfolge ist. In Visual Basic 6,0 und früheren Versionen werden Zeichen folgen mit fester Länge unterstützt. beim Einfügen in eine Datei wird der Längen Deskriptor nicht geschrieben. Wenn Sie eine Zeichenfolge ohne den Deskriptor lesen möchten, sollten Sie `True` an den `StringIsFixedLength`-Parameter übergeben, und die Zeichenfolge, in die Sie eingelesen haben, sollte die richtige Länge aufweisen.  
  
-   Wenn die zu lesende Variable ein Array ist, können Sie auswählen, ob ein Deskriptor für die Größe und Dimension des Arrays gelesen werden soll. Legen Sie zum Schreiben des Deskriptors den `ArrayIsDynamic`-Parameter auf `True`fest. Beim Lesen des Arrays müssen Sie der Art und Weise entsprechen, wie das Array geschrieben wurde. Wenn Sie mit dem Deskriptor geschrieben wurde, müssen Sie den Deskriptor lesen. Wenn der Deskriptor nicht verwendet wird, bestimmen die Größe und die Begrenzungen des Arrays, das an `FileGet` übermittelt wird, was gelesen werden soll.  
  
     Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang an. Die Länge ist 2 plus das 8-fache der Anzahl der Dimensionen: (2 + 8 * anzahldimensionen). Die vom `RecordLength`-Parameter in der `FileOpen`-Funktion angegebene Daten Satz Länge muss größer oder gleich der Summe aller Bytes sein, die zum Schreiben der Array Daten und des Array Deskriptors erforderlich sind. Die folgende Array Deklaration benötigt z. b. 218 bytes, wenn das Array auf den Datenträger geschrieben wird.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     Die 218 Bytes werden wie folgt verteilt:  
  
    -   18 Bytes für den Deskriptor: (2 + 8 * 2)  
  
    -   200 Bytes für die Daten: (5 * 10 * 4).  
  
-   Wenn die Variable, die in gelesen wird, ein beliebiger anderer Typ von Variable ist (keine Zeichenfolge mit variabler Länge oder ein Objekt), liest `FileGet` nur die Variablen Daten. Die von der `RecordLength`-Klausel in der `FileOpen`-Funktion angegebene Daten Satz Länge muss größer oder gleich der Länge der gelesenen Daten sein.  
  
-   `FileGet` liest Elemente von Strukturen so, als ob jede einzeln gelesen würde, mit dem Unterschied, dass es keine Auffüll Zeichen zwischen Elementen gibt. Auf einem Datenträger wird einem dynamischen Array in einem benutzerdefinierten Typ (geschrieben mit `FilePut`) ein Deskriptor vorangestellt, dessen Länge 2 plus dem 8-fachen der Anzahl von Dimensionen entspricht: (2 + 8 * anzahlungsdimensionen). Die von der `RecordLength`-Klausel in der `FileOpen`-Funktion angegebene Daten Satz Länge muss größer oder gleich der Summe aller Bytes sein, die zum Lesen der einzelnen Elemente erforderlich sind. Dies schließt beliebige Arrays und deren Deskriptoren ein. Das `VBFixedString`-Attribut kann auf Zeichen folgen Felder in den Strukturen angewendet werden, um die Größe einer Zeichenfolge anzugeben, wenn Sie auf den Datenträger geschrieben wird.  
  
## <a name="binary-mode"></a>Binärmodus  
 Bei Dateien, die im `Binary` Modus geöffnet wurden, gelten die meisten `Random` Modusregeln mit einigen Ausnahmen. Die folgenden Regeln für Dateien, die im `Binary` Modus geöffnet werden, unterscheiden sich von den Regeln für `Random`-Modus:  
  
-   Die `RecordLength`-Klausel in der `FileOpen`-Funktion hat keine Auswirkungen. `FileGet` liest alle Variablen von einem Datenträger zusammenhängend. Das heißt, ohne Auffüll Zeichen zwischen Datensätzen.  
  
-   Bei einem anderen Array als einem Array in einer Struktur liest `FileGet` nur die Daten. Es wurde kein Deskriptor gelesen.  
  
-   `FileGet` liest Zeichen folgen variabler Länge, bei denen es sich nicht um Elemente von Strukturen handelt, ohne den zwei Byte langen Längen Deskriptor zu erwarten. Die Anzahl der gelesenen Bytes ist mit der Anzahl von Zeichen in der Zeichenfolge.  
  
    > [!IMPORTANT]
    >  Zum Lesen aus einer Datei mit der `FileGet`-Funktion ist `Read` Zugriff von der <xref:System.Security.Permissions.FileIOPermissionAccess>-Enumeration erforderlich.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</exception>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files">Lesen aus Dateien in Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files">Schreiben in Dateien in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref string Value, long RecordNumber = -1, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FileGet(int32 FileNumber, string&amp; Value, int64 RecordNumber, bool StringIsFixedLength) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As String, Optional RecordNumber As Long = -1, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FileGet : int * string * int64 * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber, StringIsFixedLength)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, string&amp; Value, int64 RecordNumber, bool StringIsFixedLength) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="Value">Erforderlich. Der gültige Name einer Variablen, in die Daten gelesen werden.</param>
        <param name="RecordNumber">Optional. Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), bei der der Lesevorgang beginnt.</param>
        <param name="StringIsFixedLength">Optional. Betrifft nur das Schreiben einer Zeichenfolge. Gibt an, ob ein 2-Byte-Deskriptor für die Zeichenfolge geschrieben werden soll, der die Länge beschreibt. Der Standardwert lautet <see langword="False" />.</param>
        <summary>Liest Daten aus einer offenen Datenträgerdatei in eine Variable. Die <see langword="My" />-Funktion bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FileGet" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` ist nur im `Random`-und `Binary` Modus gültig.  
  
 Mit `FileGet` gelesene Daten werden in der Regel mithilfe `FilePut`in eine Datei geschrieben.  
  
 Der erste Datensatz oder das Byte in einer Datei befindet sich an Position 1, der zweite Datensatz bzw. das zweite Byte befindet sich an Position 2 usw. Wenn Sie `RecordNumber`weglassen, wird der nächste Datensatz oder das nächste Byte, der auf den letzten `FileGet` oder die `FilePut` Funktion folgt (bzw. auf die letzte `Seek` Funktion verwiesen), gelesen.  
  
> [!IMPORTANT]
>  Treffen Sie beim Lesen aus Dateien keine Entscheidungen zum Inhalt einer Datei, die auf der Dateinamenerweiterung basiert. Beispielsweise ist eine Datei mit dem Namen Form1. vb möglicherweise keine Visual Basic Quelldatei.  
  
## <a name="random-mode"></a>Zufälliger Modus  
 Für Dateien, die im `Random` Modus geöffnet werden, gelten die folgenden Regeln:  
  
-   Wenn die Länge der gelesenen Daten kleiner ist als die Länge, die in der `RecordLength`-Klausel der `FileOpen`-Funktion angegeben ist, liest `FileGet` nachfolgende Datensätze über Grenzen der Daten Satz Länge. Der Leerraum zwischen dem Ende eines Datensatzes und dem Anfang des nächsten Datensatzes wird mit dem vorhandenen Inhalt des Datei Puffers aufgefüllt. Da die Menge der Auffüll Daten nicht mit Sicherheit bestimmt werden kann, empfiehlt es sich im Allgemeinen, die Daten Satz Länge mit der Länge der gelesenen Daten zu vergleichen.  
  
-   Wenn die Variable, die in gelesen wird, eine Zeichenfolge ist, liest `FileGet` standardmäßig einen zwei-Byte-Deskriptor, der die Zeichen folgen Länge enthält, und liest dann die Daten, die in die Variable fließen. Daher muss die von der `RecordLength`-Klausel der `FileOpen`-Funktion angegebene Daten Satz Länge mindestens zwei Bytes aufweisen, die größer als die tatsächliche Länge der Zeichenfolge ist. In Visual Basic 6,0 und früheren Versionen werden Zeichen folgen mit fester Länge unterstützt. beim Einfügen in eine Datei wird der Längen Deskriptor nicht geschrieben. Wenn Sie eine Zeichenfolge ohne den Deskriptor lesen möchten, sollten Sie `True` an den `StringIsFixedLength`-Parameter übergeben, und die Zeichenfolge, in die Sie eingelesen haben, sollte die richtige Länge aufweisen.  
  
-   Wenn die zu lesende Variable ein Array ist, können Sie auswählen, ob ein Deskriptor für die Größe und Dimension des Arrays gelesen werden soll. Legen Sie zum Schreiben des Deskriptors den `ArrayIsDynamic`-Parameter auf `True`fest. Beim Lesen des Arrays müssen Sie der Art und Weise entsprechen, wie das Array geschrieben wurde. Wenn Sie mit dem Deskriptor geschrieben wurde, müssen Sie den Deskriptor lesen. Wenn der Deskriptor nicht verwendet wird, bestimmen die Größe und die Begrenzungen des Arrays, das an `FileGet` übermittelt wird, was gelesen werden soll.  
  
     Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang an. Die Länge ist 2 plus das 8-fache der Anzahl der Dimensionen: (2 + 8 * anzahldimensionen). Die vom `RecordLength`-Parameter in der `FileOpen`-Funktion angegebene Daten Satz Länge muss größer oder gleich der Summe aller Bytes sein, die zum Schreiben der Array Daten und des Array Deskriptors erforderlich sind. Die folgende Array Deklaration benötigt z. b. 218 bytes, wenn das Array auf den Datenträger geschrieben wird.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     Die 218 Bytes werden wie folgt verteilt:  
  
    -   18 Bytes für den Deskriptor: (2 + 8 * 2)  
  
    -   200 Bytes für die Daten: (5 * 10 * 4).  
  
-   Wenn die Variable, die in gelesen wird, ein beliebiger anderer Typ von Variable ist (keine Zeichenfolge mit variabler Länge oder ein Objekt), liest `FileGet` nur die Variablen Daten. Die von der `RecordLength`-Klausel in der `FileOpen`-Funktion angegebene Daten Satz Länge muss größer oder gleich der Länge der gelesenen Daten sein.  
  
-   `FileGet` liest Elemente von Strukturen so, als ob jede einzeln gelesen würde, mit dem Unterschied, dass es keine Auffüll Zeichen zwischen Elementen gibt. Auf einem Datenträger wird einem dynamischen Array in einem benutzerdefinierten Typ (geschrieben mit `FilePut`) ein Deskriptor vorangestellt, dessen Länge 2 plus dem 8-fachen der Anzahl von Dimensionen entspricht: (2 + 8 * anzahlungsdimensionen). Die von der `RecordLength`-Klausel in der `FileOpen`-Funktion angegebene Daten Satz Länge muss größer oder gleich der Summe aller Bytes sein, die zum Lesen der einzelnen Elemente erforderlich sind. Dies schließt beliebige Arrays und deren Deskriptoren ein. Das `VBFixedString`-Attribut kann auf Zeichen folgen Felder in den Strukturen angewendet werden, um die Größe einer Zeichenfolge anzugeben, wenn Sie auf den Datenträger geschrieben wird.  
  
## <a name="binary-mode"></a>Binärmodus  
 Bei Dateien, die im `Binary` Modus geöffnet wurden, gelten die meisten `Random` Modusregeln mit einigen Ausnahmen. Die folgenden Regeln für Dateien, die im `Binary` Modus geöffnet werden, unterscheiden sich von den Regeln für `Random`-Modus:  
  
-   Die `RecordLength`-Klausel in der `FileOpen`-Funktion hat keine Auswirkungen. `FileGet` liest alle Variablen von einem Datenträger zusammenhängend. Das heißt, ohne Auffüll Zeichen zwischen Datensätzen.  
  
-   Bei einem anderen Array als einem Array in einer Struktur liest `FileGet` nur die Daten. Es wurde kein Deskriptor gelesen.  
  
-   `FileGet` liest Zeichen folgen variabler Länge, bei denen es sich nicht um Elemente von Strukturen handelt, ohne den zwei Byte langen Längen Deskriptor zu erwarten. Die Anzahl der gelesenen Bytes ist mit der Anzahl von Zeichen in der Zeichenfolge.  
  
    > [!IMPORTANT]
    >  Zum Lesen aus einer Datei mit der `FileGet`-Funktion ist `Read` Zugriff von der <xref:System.Security.Permissions.FileIOPermissionAccess>-Enumeration erforderlich.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</exception>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files">Lesen aus Dateien in Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files">Schreiben in Dateien in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FileGet(int32 FileNumber, class System.Array&amp; Value, int64 RecordNumber, bool ArrayIsDynamic, bool StringIsFixedLength) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Array, Optional RecordNumber As Long = -1, Optional ArrayIsDynamic As Boolean = false, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FileGet : int * Array * int64 * bool * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber, ArrayIsDynamic, StringIsFixedLength)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, class System.Array&amp; Value, int64 RecordNumber, bool ArrayIsDynamic, bool StringIsFixedLength) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Array" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="ArrayIsDynamic" Type="System.Boolean" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="Value">Erforderlich. Der gültige Name einer Variablen, in die Daten gelesen werden.</param>
        <param name="RecordNumber">Optional. Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), bei der der Lesevorgang beginnt.</param>
        <param name="ArrayIsDynamic">Optional. Betrifft nur das Schreiben eines Arrays. Gibt an, ob das Array als dynamisches Array behandelt werden soll und ein Arraydeskriptor erforderlich ist, der die Größe und die Begrenzungen des Arrays beschreibt.</param>
        <param name="StringIsFixedLength">Optional. Betrifft nur das Schreiben einer Zeichenfolge. Gibt an, ob ein 2-Byte-Deskriptor für die Zeichenfolge geschrieben werden soll, der die Länge beschreibt. Der Standardwert lautet <see langword="False" />.</param>
        <summary>Liest Daten aus einer offenen Datenträgerdatei in eine Variable. Die <see langword="My" />-Funktion bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FileGet" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` ist nur im `Random`-und `Binary` Modus gültig.  
  
 Mit `FileGet` gelesene Daten werden in der Regel mithilfe `FilePut`in eine Datei geschrieben.  
  
 Der erste Datensatz oder das Byte in einer Datei befindet sich an Position 1, der zweite Datensatz bzw. das zweite Byte befindet sich an Position 2 usw. Wenn Sie `RecordNumber`weglassen, wird der nächste Datensatz oder das nächste Byte, der auf den letzten `FileGet` oder die `FilePut` Funktion folgt (bzw. auf die letzte `Seek` Funktion verwiesen), gelesen.  
  
> [!IMPORTANT]
>  Treffen Sie beim Lesen aus Dateien keine Entscheidungen zum Inhalt einer Datei, die auf der Dateinamenerweiterung basiert. Beispielsweise ist eine Datei mit dem Namen Form1. vb möglicherweise keine Visual Basic Quelldatei.  
  
## <a name="random-mode"></a>Zufälliger Modus  
 Für Dateien, die im `Random` Modus geöffnet werden, gelten die folgenden Regeln:  
  
-   Wenn die Länge der gelesenen Daten kleiner ist als die Länge, die in der `RecordLength`-Klausel der `FileOpen`-Funktion angegeben ist, liest `FileGet` nachfolgende Datensätze über Grenzen der Daten Satz Länge. Der Leerraum zwischen dem Ende eines Datensatzes und dem Anfang des nächsten Datensatzes wird mit dem vorhandenen Inhalt des Datei Puffers aufgefüllt. Da die Menge der Auffüll Daten nicht mit Sicherheit bestimmt werden kann, empfiehlt es sich im Allgemeinen, die Daten Satz Länge mit der Länge der gelesenen Daten zu vergleichen.  
  
-   Wenn die Variable, die in gelesen wird, eine Zeichenfolge ist, liest `FileGet` standardmäßig einen zwei-Byte-Deskriptor, der die Zeichen folgen Länge enthält, und liest dann die Daten, die in die Variable fließen. Daher muss die von der `RecordLength`-Klausel der `FileOpen`-Funktion angegebene Daten Satz Länge mindestens zwei Bytes aufweisen, die größer als die tatsächliche Länge der Zeichenfolge ist. In Visual Basic 6,0 und früheren Versionen werden Zeichen folgen mit fester Länge unterstützt. beim Einfügen in eine Datei wird der Längen Deskriptor nicht geschrieben. Wenn Sie eine Zeichenfolge ohne den Deskriptor lesen möchten, sollten Sie `True` an den `StringIsFixedLength`-Parameter übergeben, und die Zeichenfolge, in die Sie eingelesen haben, sollte die richtige Länge aufweisen.  
  
-   Wenn die zu lesende Variable ein Array ist, können Sie auswählen, ob ein Deskriptor für die Größe und Dimension des Arrays gelesen werden soll. Legen Sie zum Schreiben des Deskriptors den `ArrayIsDynamic`-Parameter auf `True`fest. Beim Lesen des Arrays müssen Sie der Art und Weise entsprechen, wie das Array geschrieben wurde. Wenn Sie mit dem Deskriptor geschrieben wurde, müssen Sie den Deskriptor lesen. Wenn der Deskriptor nicht verwendet wird, bestimmen die Größe und die Begrenzungen des Arrays, das an `FileGet` übermittelt wird, was gelesen werden soll.  
  
     Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang an. Die Länge ist 2 plus das 8-fache der Anzahl der Dimensionen: (2 + 8 * anzahldimensionen). Die vom `RecordLength`-Parameter in der `FileOpen`-Funktion angegebene Daten Satz Länge muss größer oder gleich der Summe aller Bytes sein, die zum Schreiben der Array Daten und des Array Deskriptors erforderlich sind. Die folgende Array Deklaration benötigt z. b. 218 bytes, wenn das Array auf den Datenträger geschrieben wird.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     Die 218 Bytes werden wie folgt verteilt:  
  
    -   18 Bytes für den Deskriptor: (2 + 8 * 2)  
  
    -   200 Bytes für die Daten: (5 * 10 * 4).  
  
-   Wenn die Variable, die in gelesen wird, ein beliebiger anderer Typ von Variable ist (keine Zeichenfolge mit variabler Länge oder ein Objekt), liest `FileGet` nur die Variablen Daten. Die von der `RecordLength`-Klausel in der `FileOpen`-Funktion angegebene Daten Satz Länge muss größer oder gleich der Länge der gelesenen Daten sein.  
  
-   `FileGet` liest Elemente von Strukturen so, als ob jede einzeln gelesen würde, mit dem Unterschied, dass es keine Auffüll Zeichen zwischen Elementen gibt. Auf einem Datenträger wird einem dynamischen Array in einem benutzerdefinierten Typ (geschrieben mit `FilePut`) ein Deskriptor vorangestellt, dessen Länge 2 plus dem 8-fachen der Anzahl von Dimensionen entspricht: (2 + 8 * anzahlungsdimensionen). Die von der `RecordLength`-Klausel in der `FileOpen`-Funktion angegebene Daten Satz Länge muss größer oder gleich der Summe aller Bytes sein, die zum Lesen der einzelnen Elemente erforderlich sind. Dies schließt beliebige Arrays und deren Deskriptoren ein. Das `VBFixedString`-Attribut kann auf Zeichen folgen Felder in den Strukturen angewendet werden, um die Größe einer Zeichenfolge anzugeben, wenn Sie auf den Datenträger geschrieben wird.  
  
## <a name="binary-mode"></a>Binärmodus  
 Bei Dateien, die im `Binary` Modus geöffnet wurden, gelten die meisten `Random` Modusregeln mit einigen Ausnahmen. Die folgenden Regeln für Dateien, die im `Binary` Modus geöffnet werden, unterscheiden sich von den Regeln für `Random`-Modus:  
  
-   Die `RecordLength`-Klausel in der `FileOpen`-Funktion hat keine Auswirkungen. `FileGet` liest alle Variablen von einem Datenträger zusammenhängend. Das heißt, ohne Auffüll Zeichen zwischen Datensätzen.  
  
-   Bei einem anderen Array als einem Array in einer Struktur liest `FileGet` nur die Daten. Es wurde kein Deskriptor gelesen.  
  
-   `FileGet` liest Zeichen folgen variabler Länge, bei denen es sich nicht um Elemente von Strukturen handelt, ohne den zwei Byte langen Längen Deskriptor zu erwarten. Die Anzahl der gelesenen Bytes ist mit der Anzahl von Zeichen in der Zeichenfolge.  
  
    > [!IMPORTANT]
    >  Zum Lesen aus einer Datei mit der `FileGet`-Funktion ist `Read` Zugriff von der <xref:System.Security.Permissions.FileIOPermissionAccess>-Enumeration erforderlich.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</exception>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files">Lesen aus Dateien in Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files">Schreiben in Dateien in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGetObject">
      <MemberSignature Language="C#" Value="public static void FileGetObject (int FileNumber, ref object Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FileGetObject(int32 FileNumber, object&amp; Value, int64 RecordNumber) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGetObject (FileNumber As Integer, ByRef Value As Object, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGetObject : int * obj * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGetObject (FileNumber, Value, RecordNumber)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGetObject(int32 FileNumber, object&amp; Value, int64 RecordNumber) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="Value">Erforderlich. Der gültige Name einer Variablen, in die Daten gelesen werden.</param>
        <param name="RecordNumber">Optional. Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), bei der der Lesevorgang beginnt.</param>
        <summary>Liest Daten aus einer offenen Datenträgerdatei in eine Variable.  Die <see langword="My" />-Funktion bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FileGetObject" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `FileGetObject`-Funktion wird anstelle von `FileGet` verwendet, um Mehrdeutigkeiten zur Kompilierzeit zu vermeiden, wenn Type `Object` anstelle eines anderen Typs zurückgegeben wird, z. b. `Integer`, `Long`, `Short`usw.  
  
 Wenn Sie beabsichtigen, den `Variant`-Typ zu schreiben, ist `FileGetObject` erforderlich. Wenn Sie im Zweifelsfall ein Objekt für den zweiten Parameter verwenden, wird immer die Verwendung von `FilePutObject` und `FileGetObject`empfohlen.  
  
 `FileGetObject` ist nur im `Random`-und `Binary` Modus gültig.  
  
 Mit `FileGetObject` gelesene Daten werden in der Regel mit `FilePutObject`geschrieben.  
  
 Der erste Datensatz oder das Byte in einer Datei befindet sich an Position 1, der zweite Datensatz bzw. das zweite Byte befindet sich an Position 2 usw. Wenn Sie `RecordNumber`weglassen, liest `FileGetObject` den Datensatz oder das Byte nach der letzten `FileGetObject` oder `FilePutObject` Funktion (bzw. auf die letzte `Seek` Funktion).  
  
## <a name="random-mode"></a>Zufälliger Modus  
 Für Dateien, die im `Random` Modus geöffnet werden, gelten die folgenden Regeln:  
  
-   Wenn die Länge der gelesenen Daten kleiner ist als die Länge, die in der `RecordLength`-Klausel der `FileOpen`-Funktion angegeben ist, liest `FileGetObject` nachfolgende Datensätze über Grenzen der Daten Satz Länge. Der Leerraum zwischen dem Ende eines Datensatzes und dem Anfang des nächsten Datensatzes wird mit dem vorhandenen Inhalt des Datei Puffers aufgefüllt. Da die Menge der Auffüll Daten nicht genau bestimmt werden kann, empfiehlt es sich, die Daten Satz Länge mit der Länge der gelesenen Daten zu vergleichen.  
  
-   Wenn die Variable, die gelesen wird, eine Zeichenfolge ist, liest `FileGetObject` standardmäßig einen 2-Byte-Deskriptor, der die Zeichen folgen Länge enthält, und liest dann die Daten, die in die Variable fließen. Daher muss die von der `RecordLength`-Klausel der `FileOpen`-Funktion angegebene Daten Satz Länge mindestens zwei Bytes aufweisen, die größer als die tatsächliche Länge der Zeichenfolge ist. In Visual Basic 6,0 und früheren Versionen werden Zeichen folgen mit fester Länge unterstützt. beim Lesen einer Datei wird der Längen Deskriptor nicht geschrieben. Wenn Sie eine Zeichenfolge ohne den Deskriptor lesen möchten, sollten Sie `True` an den `StringIsFixedLength`-Parameter übergeben, und die Zeichenfolge, in die Sie eingelesen haben, sollte die richtige Länge aufweisen.  
  
-   Wenn die zu lesende Variable ein Array ist, muss die vom `RecordLength`-Parameter in der `FileOpen`-Funktion angegebene Daten Satz Länge größer oder gleich der Summe aller Bytes sein, die zum Schreiben der Array Daten und des Array Deskriptors erforderlich sind. Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang an. Die Länge ist 2 plus das 8-fache der Anzahl der Dimensionen: 2 + 8 * nummeritätsdimensionen.  
  
     Die folgende Array Deklaration benötigt z. b. 218 bytes, wenn das Array auf den Datenträger geschrieben wird:  
  
     [!code-vb[VbVbalrCatRef#27](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#27)]  
  
     Die 218 Bytes werden wie folgt verteilt: 18 Bytes für den Deskriptor (2 + 8 * 2) und 100 Byte für die Daten (5 * 10 * 4).  
  
-   `FileGetObject` liest Elemente von Strukturen so, als ob jede einzeln gelesen würde, mit dem Unterschied, dass es keine Auffüll Zeichen zwischen Elementen gibt. Auf einem Datenträger wird einem dynamischen Array in einem benutzerdefinierten Typ (geschrieben mit `FilePutObject`) ein Deskriptor vorangestellt, dessen Länge 2 plus 8 mal der Anzahl der Dimensionen entspricht: 2 + 8 * anzahlungsdimensionen. Die von der `RecordLength`-Klausel in der `FileOpen`-Funktion angegebene Daten Satz Länge muss größer oder gleich der Summe aller Bytes sein, die zum Lesen der einzelnen Elemente erforderlich sind, einschließlich der Arrays und ihrer Deskriptoren. Die <xref:Microsoft.VisualBasic.VBFixedStringAttribute>-Klasse kann auf Zeichen folgen Felder in den-Strukturen angewendet werden, um die Größe der Zeichenfolge beim Schreiben auf den Datenträger anzugeben.  
  
## <a name="binary-mode"></a>Binärmodus  
 Für Dateien, die im `Binary` Modus geöffnet wurden, gelten alle `Random` Regeln mit folgenden Ausnahmen:  
  
-   Die `RecordLength`-Klausel in der `FileOpen`-Funktion hat keine Auswirkungen. `FileGetObject` liest alle Variablen von einem Datenträger zusammenhängend, d. h. ohne Auffüll Zeichen zwischen Datensätzen.  
  
-   Bei einem anderen Array als einem Array in einer Struktur liest `FileGetObject` nur die Daten. Es wurde kein Deskriptor gelesen.  
  
 `FileGetObject` liest Zeichen folgen variabler Länge, bei denen es sich nicht um Elemente von Strukturen handelt, ohne den zwei Byte langen Längen Deskriptor zu erwarten. Die Anzahl der gelesenen Bytes ist mit der Anzahl von Zeichen in der Zeichenfolge.  
  
> [!IMPORTANT]
>  Treffen Sie beim Lesen aus Dateien keine Entscheidungen zum Inhalt einer Datei, die auf der Dateinamenerweiterung basiert. Beispielsweise ist eine Datei mit dem Namen Form1. vb möglicherweise keine Visual Basic Quelldatei.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Datensatz in eine Testdatei gelesen und dann abgerufen.  
  
 [!code-vb[VbVbalrCatRef#26](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#26)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files">Lesen aus Dateien in Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files">Schreiben in Dateien in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileLen">
      <MemberSignature Language="C#" Value="public static long FileLen (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 FileLen(string PathName) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileLen (PathName As String) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long FileLen(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member FileLen : string -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.FileLen PathName" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 FileLen(string PathName) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">Erforderlich. Ein Zeichenfolgenausdruck, der eine Datei angibt. <paramref name="PathName" /> kann das Verzeichnis bzw. den Ordner und das Laufwerk enthalten.</param>
        <summary>Gibt einen Wert zurück, der die Länge einer Datei in Byte angibt. Die <see langword="My" />-Funktion bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FileLen" />. Weitere Informationen finden Sie unter <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />.</summary>
        <returns>Die Länge einer Datei in Byte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die angegebene Datei geöffnet ist, wenn die `FileLen`-Funktion aufgerufen wird, stellt der zurückgegebene Wert die Größe der Datei zum Zeitpunkt des Öffnens dar.  
  
> [!NOTE]
>  Verwenden Sie die `LOF`-Funktion, um die aktuelle Länge einer geöffneten Datei abzurufen.  
  
   
  
## Examples  
 In diesem Beispiel wird die `FileLen`-Funktion verwendet, um die Länge einer Datei in Bytes zurückzugeben. Nehmen Sie für die Zwecke dieses Beispiels an, dass `TestFile` eine Datei mit einigen Daten ist.  
  
 [!code-vb[VbVbalrCatRef#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Die Datei ist nicht vorhanden.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access">Dateizugriff mit Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileOpen">
      <MemberSignature Language="C#" Value="public static void FileOpen (int FileNumber, string FileName, Microsoft.VisualBasic.OpenMode Mode, Microsoft.VisualBasic.OpenAccess Access = Microsoft.VisualBasic.OpenAccess.Default, Microsoft.VisualBasic.OpenShare Share = Microsoft.VisualBasic.OpenShare.Default, int RecordLength = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FileOpen(int32 FileNumber, string FileName, valuetype Microsoft.VisualBasic.OpenMode Mode, valuetype Microsoft.VisualBasic.OpenAccess Access, valuetype Microsoft.VisualBasic.OpenShare Share, int32 RecordLength) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileOpen (FileNumber As Integer, FileName As String, Mode As OpenMode, Optional Access As OpenAccess = Microsoft.VisualBasic.OpenAccess.Default, Optional Share As OpenShare = Microsoft.VisualBasic.OpenShare.Default, Optional RecordLength As Integer = -1)" />
      <MemberSignature Language="F#" Value="static member FileOpen : int * string * Microsoft.VisualBasic.OpenMode * Microsoft.VisualBasic.OpenAccess * Microsoft.VisualBasic.OpenShare * int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileOpen (FileNumber, FileName, Mode, Access, Share, RecordLength)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileOpen(int32 FileNumber, string FileName, valuetype Microsoft.VisualBasic.OpenMode Mode, valuetype Microsoft.VisualBasic.OpenAccess Access, valuetype Microsoft.VisualBasic.OpenShare Share, int32 RecordLength) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FileName" Type="System.String" />
        <Parameter Name="Mode" Type="Microsoft.VisualBasic.OpenMode" />
        <Parameter Name="Access" Type="Microsoft.VisualBasic.OpenAccess" />
        <Parameter Name="Share" Type="Microsoft.VisualBasic.OpenShare" />
        <Parameter Name="RecordLength" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer. Verwenden Sie die <see langword="FreeFile" />-Funktion, um die nächste verfügbare Dateinummer zu erhalten.</param>
        <param name="FileName">Erforderlich. Ein Zeichenfolgenausdruck, der einen Dateinamen angibt. Kann das Verzeichnis oder den Ordner und das Laufwerk enthalten.</param>
        <param name="Mode">Erforderlich. Eine Enumeration, die den Dateimodus angibt: <see langword="Append" />, <see langword="Binary" />, <see langword="Input" />, <see langword="Output" /> oder <see langword="Random" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.OpenMode" />.</param>
        <param name="Access">Optional. Eine Enumeration, die die für eine offene Datei erlaubten Operationen angibt: <see langword="Read" />, <see langword="Write" /> oder <see langword="ReadWrite" />. Der Standardwert lautet <see langword="ReadWrite" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.OpenAccess" />.</param>
        <param name="Share">Optional. Eine Enumeration, die für eine offene Datei aus anderen Prozessen nicht erlaubten Operationen angibt: <see langword="Shared" />, <see langword="Lock Read" />, <see langword="Lock Write" /> und <see langword="Lock Read Write" />. Der Standardwert lautet <see langword="Lock Read Write" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.OpenShare" />.</param>
        <param name="RecordLength">Optional. Eine Zahl kleiner oder gleich 32.767 (Bytes). Bei Dateien, die mit Random-Zugriff geöffnet wurden, ist dieser Wert die Datensatzlänge. Bei sequenziellen Dateien ist dieser Wert die Anzahl von gepufferten Zeichen.</param>
        <summary>Öffnet eine Datei für Eingabe oder Ausgabe. Die <see langword="My" />-Funktion bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FileOpen" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `FileOpen` Funktion wird aus Gründen der Abwärtskompatibilität bereitgestellt und kann sich auf die Leistung auswirken. Bei nicht Legacy Anwendungen bietet das `My.Computer.FileSystem`-Objekt eine bessere Leistung. Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access).  
  
 Sie müssen eine Datei öffnen, bevor ein e/a-Vorgang für Sie ausgeführt werden kann. `FileOpen` ordnet der Datei einen Puffer für e/a zu und bestimmt den Zugriffsmodus, der mit dem Puffer verwendet werden soll.  
  
> [!IMPORTANT]
>  Wenn Sie in eine Datei schreiben, muss eine Anwendung möglicherweise eine Datei erstellen, wenn die Datei, zu der Sie schreiben möchten, nicht vorhanden ist. Zu diesem Zweck benötigt er die Berechtigung für das Verzeichnis, in dem die Datei erstellt werden soll. Wenn jedoch die durch `FileName` angegebene Datei vorhanden ist, benötigt die Anwendung `Write` Berechtigung nur für die Datei selbst. Wenn möglich, sollten Sie zur Verbesserung der Sicherheit die Datei während der Bereitstellung erstellen und `Write` Berechtigung nur für diese Datei erteilen, anstelle des gesamten Verzeichnisses. Um die Sicherheit zu verbessern, schreiben Sie Daten in Benutzerverzeichnisse anstatt in das Stammverzeichnis oder das Verzeichnis "Programme".  
  
 Der zu öffnende Kanal kann mithilfe der `FreeFile()`-Funktion gefunden werden.  
  
> [!IMPORTANT]
>  Die `FileOpen`-Funktion erfordert `Read` Zugriff von der `FileIOPermissionAccess`-Enumeration, die sich möglicherweise auf die Ausführung in teilweise vertrauenswürdigen Situationen auswirkt. Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermissionAccess>-Enumeration.  
  
   
  
## Examples  
 In diesem Beispiel werden verschiedene Verwendungsmöglichkeiten der `FileOpen`-Funktion veranschaulicht, um die Eingabe und Ausgabe in einer Datei zu aktivieren.  
  
 Mit dem folgenden Code wird die Datei `TestFile` im `Input` Modus geöffnet.  
  
 [!code-vb[VbVbalrCatRef#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#5)]  
  
 In diesem Beispiel wird die Datei nur für Schreibvorgänge im `Binary` Modus geöffnet.  
  
 [!code-vb[VbVbalrCatRef#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#6)]  
  
 Im folgenden Beispiel wird die Datei im `Random` Modus geöffnet. Die Datei enthält Datensätze der Struktur `Person`.  
  
 [!code-vb[VbVbalrCatRef#7](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#7)]  
  
 In diesem Codebeispiel wird die Datei im `Output` Modus geöffnet. Jeder Prozess kann die Datei lesen oder in diese schreiben.  
  
 [!code-vb[VbVbalrCatRef#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#8)]  
  
 In diesem Codebeispiel wird die Datei im `Binary` Modus zum Lesen geöffnet. andere Prozesse können die Datei nicht lesen.  
  
 [!code-vb[VbVbalrCatRef#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Datensatzlänge ist negativ (und nicht gleich -1).</exception>
        <exception cref="T:System.IO.IOException"><paramref name="FileName" /> ist bereits geöffnet, oder <paramref name="FileName" /> ist ungültig.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FreeFile" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files">Lesen aus Dateien in Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files">Schreiben in Dateien in Visual Basic</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="FilePut">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Schreibt Daten aus einer Variablen in eine Datei auf einem Datenträger. Die <see langword="My" />-Funktion bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FilePut" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, bool Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FilePut(int32 FileNumber, bool Value, int64 RecordNumber) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Boolean, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * bool * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, bool Value, int64 RecordNumber) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="Value">Erforderlich. Gültiger Variablenname, der auf den Datenträger geschriebene Daten enthält.</param>
        <param name="RecordNumber">Optional. Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), an der der Schreibvorgang beginnt.</param>
        <summary>Schreibt Daten aus einer Variablen in eine Datei auf einem Datenträger. Die <see langword="My" />-Funktion bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FilePut" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` ist nur im `Random`-und `Binary` Modus gültig.  
  
 Mit `FilePut` geschriebene Daten werden in der Regel mit `FileGet` aus einer Datei gelesen.  
  
 Der erste Datensatz oder das Byte in einer Datei befindet sich an Position 1, der zweite Datensatz bzw. das zweite Byte befindet sich an Position 2 usw. Wenn Sie `RecordNumber`weglassen, wird der nächste Datensatz oder das nächste Byte nach dem letzten `FileGet` oder der `FilePut` Funktion geschrieben, oder es wird auf die letzte `Seek` Funktion verwiesen.  
  
 Das `StringIsFixedLength`-Argument steuert, ob die Funktion Zeichen folgen als Variable oder eine Länge mit fester Länge interpretiert. `FilePut` schreibt den Längen Deskriptor nicht, wenn das Argument `True`ist. Wenn Sie `StringIsFixedLength` = `True` mit `FilePut`verwenden, müssen Sie mit `FileGet`identisch Vorgehen, und Sie müssen sicherstellen, dass die Zeichenfolge mit der erwarteten Länge initialisiert wird.  
  
## <a name="random-mode"></a>Zufälliger Modus  
 Für Dateien, die im `Random` Modus geöffnet werden, gelten die folgenden Regeln:  
  
-   Wenn die Länge der geschriebenen Daten kleiner ist als die Länge, die in der `RecordLength`-Klausel der `FileOpen`-Funktion angegeben ist, schreibt `FilePut` nachfolgende Datensätze an Grenzen der Daten Satz Länge. Der Leerraum zwischen dem Ende eines Datensatzes und dem Anfang des nächsten Datensatzes wird mit dem vorhandenen Inhalt des Datei Puffers aufgefüllt. Da die Menge der Auffüll Daten nicht mit Sicherheit bestimmt werden kann, empfiehlt es sich im Allgemeinen, die Daten Satz Länge mit der Länge der geschriebenen Daten zu vergleichen. Wenn die Länge der geschriebenen Daten größer ist als die Länge, die in der `RecordLength`-Klausel der `FileOpen`-Funktion angegeben ist, wird eine Ausnahme ausgelöst.  
  
-   Wenn die Variable, die geschrieben wird, eine Zeichenfolge ist, schreibt `FilePut` einen 2-Byte-Deskriptor, der die Zeichen folgen Länge enthält, und schreibt dann die Daten, die in die Variable aufgenommen werden. Daher muss die von der `RecordLength`-Klausel in der `FileOpen`-Funktion angegebene Daten Satz Länge mindestens zwei Bytes aufweisen, die größer als die tatsächliche Länge der Zeichenfolge ist.  
  
-   Wenn die Variable, die geschrieben wird, ein Objekt ist, das einen numerischen Typ enthält, `FilePut` schreibt zwei Bytes, die die `VarType` des Objekts identifizieren, und schreibt dann die Variable. Wenn Sie z. b. ein Objekt schreiben, das eine ganze Zahl enthält, werden `FilePut` sechs Bytes schreiben: zwei Bytes, die das Objekt als `VarType(3)` (`Integer`) und vier Bytes, die die Daten enthalten, identifizieren. Die vom `RecordLength`-Parameter in der `FileOpen`-Funktion angegebene Daten Satz Länge muss mindestens zwei Byte betragen, die größer ist als die tatsächliche Anzahl von Bytes, die zum Speichern der Variablen erforderlich sind.  
  
-   Wenn die Variable, die geschrieben wird, ein Objekt ist, das eine Zeichenfolge enthält, schreibt `FilePut` einen zwei-Byte-Deskriptor, der die `VarType(8)` des Objekts identifiziert, einen 2-Byte-Deskriptor, der die Länge der Zeichenfolge angibt, und schreibt dann die Zeichen folgen Daten. Die vom `RecordLength`-Parameter in der `FileOpen`-Funktion angegebene Daten Satz Länge muss mindestens vier Byte betragen, die größer als die tatsächliche Länge der Zeichenfolge ist. Wenn Sie eine Zeichenfolge ohne den Deskriptor platzieren möchten, sollten Sie `True` an den `StringIsFixedLength`-Parameter übergeben, und die Zeichenfolge, in die Sie eingelesen haben, sollte die richtige Länge aufweisen.  
  
-   Wenn die Variable, die geschrieben wird, ein Array ist, können Sie entscheiden, ob ein Deskriptor für die Größe und die Dimensionen des Arrays geschrieben werden soll. In Visual Basic 6,0 und früheren Versionen wird der Dateideskriptor für ein dynamisches Array geschrieben, jedoch nicht für ein Array mit fester Größe. Visual Basic 2005 wird der Deskriptor standardmäßig nicht geschrieben. Legen Sie zum Schreiben des Deskriptors den `ArrayIsDynamic`-Parameter auf `True`fest. Beim Schreiben des Arrays müssen Sie der Art und Weise entsprechen, in der das Array gelesen wird. Wenn Sie mit dem Deskriptor gelesen wird, müssen Sie den Deskriptor schreiben. Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang an. Die Länge ist 2 plus das 8-fache der Anzahl der Dimensionen: (2 + 8 * anzahldimensionen). Die von der `RecordLength`-Klausel in der `FileOpen`-Funktion angegebene Daten Satz Länge muss größer oder gleich der Summe aller Bytes sein, die zum Schreiben der Array Daten und des Array Deskriptors erforderlich sind. Die folgende Array Deklaration benötigt z. b. 218 bytes, wenn das Array auf den Datenträger geschrieben wird.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Wenn die Variable, die geschrieben wird, ein beliebiger anderer Typ der Variablen ist (keine Zeichenfolge mit variabler Länge oder ein Objekt), werden `FilePut` nur die Variablen Daten schreiben. Die von der `RecordLength`-Klausel in der `FileOpen`-Funktion angegebene Daten Satz Länge muss größer oder gleich der Länge der geschriebenen Daten sein.  
  
-   `FilePut` schreibt Elemente von Strukturen so, als wären Sie einzeln geschrieben worden, mit dem Unterschied, dass keine Auffüll Zeichen zwischen Elementen vorhanden sind. Das `VBFixedString`-Attribut kann auf Zeichen folgen Felder in den Strukturen angewendet werden, um die Größe der Zeichenfolge beim Schreiben auf den Datenträger anzugeben.  
  
    > [!NOTE]
    >  Zeichen folgen Felder, die mehr Bytes aufweisen, als durch das `VBFixedString`-Attribut angegeben werden, werden beim Schreiben auf den Datenträger abgeschnitten.  
  
## <a name="binary-mode"></a>Binärmodus  
 Bei Dateien, die im `Binary` Modus geöffnet wurden, gelten die meisten `Random` Modusregeln mit einigen Ausnahmen. Die folgenden Regeln für Dateien, die im `Binary` Modus geöffnet werden, unterscheiden sich von den Regeln für `Random`-Modus:  
  
-   Die `RecordLength`-Klausel in der `FileOpen`-Funktion hat keine Auswirkungen. `FilePut` alle Variablen zusammenhängend auf den Datenträger schreibt, d. h. ohne Auffüll Zeichen zwischen Datensätzen.  
  
-   Für ein beliebiges Array, das kein Array in einer Struktur ist, schreibt `FilePut` nur die Daten. Es wurde kein Deskriptor geschrieben.  
  
-   `FilePut` schreibt Zeichen folgen variabler Länge, die keine Elemente von Strukturen sind, ohne den zwei Byte langen Längen Deskriptor. Die Anzahl der geschriebenen Bytes ist mit der Anzahl der Zeichen in der Zeichenfolge. Beispielsweise schreiben die folgenden Anweisungen 11 Bytes in die Dateinummer 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Zum Schreiben in eine Datei mit der `FilePut`-Funktion ist `Write` Zugriff von der <xref:System.Security.Permissions.FileIOPermissionAccess>-Enumeration erforderlich.  
  
   
  
## Examples  
 In diesem Beispiel wird die `FilePut`-Funktion verwendet, um Daten in eine Datei zu schreiben. Fünf Datensätze der Struktur `Person` werden in die Datei geschrieben.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</exception>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files">Schreiben in Dateien in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, byte Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FilePut(int32 FileNumber, unsigned int8 Value, int64 RecordNumber) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Byte, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * byte * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, unsigned int8 Value, int64 RecordNumber) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="Value">Erforderlich. Gültiger Variablenname, der auf den Datenträger geschriebene Daten enthält.</param>
        <param name="RecordNumber">Optional. Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), an der der Schreibvorgang beginnt.</param>
        <summary>Schreibt Daten aus einer Variablen in eine Datei auf einem Datenträger. Die <see langword="My" />-Funktion bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FilePut" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` ist nur im `Random`-und `Binary` Modus gültig.  
  
 Mit `FilePut` geschriebene Daten werden in der Regel mit `FileGet` aus einer Datei gelesen.  
  
 Der erste Datensatz oder das Byte in einer Datei befindet sich an Position 1, der zweite Datensatz bzw. das zweite Byte befindet sich an Position 2 usw. Wenn Sie `RecordNumber`weglassen, wird der nächste Datensatz oder das nächste Byte nach dem letzten `FileGet` oder der `FilePut` Funktion geschrieben, oder es wird auf die letzte `Seek` Funktion verwiesen.  
  
 Das `StringIsFixedLength`-Argument steuert, ob die Funktion Zeichen folgen als Variable oder eine Länge mit fester Länge interpretiert. `FilePut` schreibt den Längen Deskriptor nicht, wenn das Argument `True`ist. Wenn Sie `StringIsFixedLength` = `True` mit `FilePut`verwenden, müssen Sie mit `FileGet`identisch Vorgehen, und Sie müssen sicherstellen, dass die Zeichenfolge mit der erwarteten Länge initialisiert wird.  
  
## <a name="random-mode"></a>Zufälliger Modus  
 Für Dateien, die im `Random` Modus geöffnet werden, gelten die folgenden Regeln:  
  
-   Wenn die Länge der geschriebenen Daten kleiner ist als die Länge, die in der `RecordLength`-Klausel der `FileOpen`-Funktion angegeben ist, schreibt `FilePut` nachfolgende Datensätze an Grenzen der Daten Satz Länge. Der Leerraum zwischen dem Ende eines Datensatzes und dem Anfang des nächsten Datensatzes wird mit dem vorhandenen Inhalt des Datei Puffers aufgefüllt. Da die Menge der Auffüll Daten nicht mit Sicherheit bestimmt werden kann, empfiehlt es sich im Allgemeinen, die Daten Satz Länge mit der Länge der geschriebenen Daten zu vergleichen. Wenn die Länge der geschriebenen Daten größer ist als die Länge, die in der `RecordLength`-Klausel der `FileOpen`-Funktion angegeben ist, wird eine Ausnahme ausgelöst.  
  
-   Wenn die Variable, die geschrieben wird, eine Zeichenfolge ist, schreibt `FilePut` einen 2-Byte-Deskriptor, der die Zeichen folgen Länge enthält, und schreibt dann die Daten, die in die Variable aufgenommen werden. Daher muss die von der `RecordLength`-Klausel in der `FileOpen`-Funktion angegebene Daten Satz Länge mindestens zwei Bytes aufweisen, die größer als die tatsächliche Länge der Zeichenfolge ist.  
  
-   Wenn die Variable, die geschrieben wird, ein Objekt ist, das einen numerischen Typ enthält, `FilePut` schreibt zwei Bytes, die die `VarType` des Objekts identifizieren, und schreibt dann die Variable. Wenn Sie z. b. ein Objekt schreiben, das eine ganze Zahl enthält, werden `FilePut` sechs Bytes schreiben: zwei Bytes, die das Objekt als `VarType(3)` (`Integer`) und vier Bytes, die die Daten enthalten, identifizieren. Die vom `RecordLength`-Parameter in der `FileOpen`-Funktion angegebene Daten Satz Länge muss mindestens zwei Byte betragen, die größer ist als die tatsächliche Anzahl von Bytes, die zum Speichern der Variablen erforderlich sind.  
  
-   Wenn die Variable, die geschrieben wird, ein Objekt ist, das eine Zeichenfolge enthält, schreibt `FilePut` einen zwei-Byte-Deskriptor, der die `VarType(8)` des Objekts identifiziert, einen 2-Byte-Deskriptor, der die Länge der Zeichenfolge angibt, und schreibt dann die Zeichen folgen Daten. Die vom `RecordLength`-Parameter in der `FileOpen`-Funktion angegebene Daten Satz Länge muss mindestens vier Byte betragen, die größer als die tatsächliche Länge der Zeichenfolge ist. Wenn Sie eine Zeichenfolge ohne den Deskriptor platzieren möchten, sollten Sie `True` an den `StringIsFixedLength`-Parameter übergeben, und die Zeichenfolge, in die Sie eingelesen haben, sollte die richtige Länge aufweisen.  
  
-   Wenn die Variable, die geschrieben wird, ein Array ist, können Sie entscheiden, ob ein Deskriptor für die Größe und die Dimensionen des Arrays geschrieben werden soll. In Visual Basic 6,0 und früheren Versionen wird der Dateideskriptor für ein dynamisches Array geschrieben, jedoch nicht für ein Array mit fester Größe. Visual Basic 2005 wird der Deskriptor standardmäßig nicht geschrieben. Legen Sie zum Schreiben des Deskriptors den `ArrayIsDynamic`-Parameter auf `True`fest. Beim Schreiben des Arrays müssen Sie der Art und Weise entsprechen, in der das Array gelesen wird. Wenn Sie mit dem Deskriptor gelesen wird, müssen Sie den Deskriptor schreiben. Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang an. Die Länge ist 2 plus das 8-fache der Anzahl der Dimensionen: (2 + 8 * anzahldimensionen). Die von der `RecordLength`-Klausel in der `FileOpen`-Funktion angegebene Daten Satz Länge muss größer oder gleich der Summe aller Bytes sein, die zum Schreiben der Array Daten und des Array Deskriptors erforderlich sind. Die folgende Array Deklaration benötigt z. b. 218 bytes, wenn das Array auf den Datenträger geschrieben wird.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Wenn die Variable, die geschrieben wird, ein beliebiger anderer Typ der Variablen ist (keine Zeichenfolge mit variabler Länge oder ein Objekt), werden `FilePut` nur die Variablen Daten schreiben. Die von der `RecordLength`-Klausel in der `FileOpen`-Funktion angegebene Daten Satz Länge muss größer oder gleich der Länge der geschriebenen Daten sein.  
  
-   `FilePut` schreibt Elemente von Strukturen so, als wären Sie einzeln geschrieben worden, mit dem Unterschied, dass keine Auffüll Zeichen zwischen Elementen vorhanden sind. Das `VBFixedString`-Attribut kann auf Zeichen folgen Felder in den Strukturen angewendet werden, um die Größe der Zeichenfolge beim Schreiben auf den Datenträger anzugeben.  
  
    > [!NOTE]
    >  Zeichen folgen Felder, die mehr Bytes aufweisen, als durch das `VBFixedString`-Attribut angegeben werden, werden beim Schreiben auf den Datenträger abgeschnitten.  
  
## <a name="binary-mode"></a>Binärmodus  
 Bei Dateien, die im `Binary` Modus geöffnet wurden, gelten die meisten `Random` Modusregeln mit einigen Ausnahmen. Die folgenden Regeln für Dateien, die im `Binary` Modus geöffnet werden, unterscheiden sich von den Regeln für `Random`-Modus:  
  
-   Die `RecordLength`-Klausel in der `FileOpen`-Funktion hat keine Auswirkungen. `FilePut` alle Variablen zusammenhängend auf den Datenträger schreibt, d. h. ohne Auffüll Zeichen zwischen Datensätzen.  
  
-   Für ein beliebiges Array, das kein Array in einer Struktur ist, schreibt `FilePut` nur die Daten. Es wurde kein Deskriptor geschrieben.  
  
-   `FilePut` schreibt Zeichen folgen variabler Länge, die keine Elemente von Strukturen sind, ohne den zwei Byte langen Längen Deskriptor. Die Anzahl der geschriebenen Bytes ist mit der Anzahl der Zeichen in der Zeichenfolge. Beispielsweise schreiben die folgenden Anweisungen 11 Bytes in die Dateinummer 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Zum Schreiben in eine Datei mit der `FilePut`-Funktion ist `Write` Zugriff von der <xref:System.Security.Permissions.FileIOPermissionAccess>-Enumeration erforderlich.  
  
   
  
## Examples  
 In diesem Beispiel wird die `FilePut`-Funktion verwendet, um Daten in eine Datei zu schreiben. Fünf Datensätze der Struktur `Person` werden in die Datei geschrieben.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</exception>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files">Schreiben in Dateien in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, char Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FilePut(int32 FileNumber, char Value, int64 RecordNumber) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Char, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * char * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, char Value, int64 RecordNumber) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="Value">Erforderlich. Gültiger Variablenname, der auf den Datenträger geschriebene Daten enthält.</param>
        <param name="RecordNumber">Optional. Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), an der der Schreibvorgang beginnt.</param>
        <summary>Schreibt Daten aus einer Variablen in eine Datei auf einem Datenträger. Die <see langword="My" />-Funktion bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FilePut" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` ist nur im `Random`-und `Binary` Modus gültig.  
  
 Mit `FilePut` geschriebene Daten werden in der Regel mit `FileGet` aus einer Datei gelesen.  
  
 Der erste Datensatz oder das Byte in einer Datei befindet sich an Position 1, der zweite Datensatz bzw. das zweite Byte befindet sich an Position 2 usw. Wenn Sie `RecordNumber`weglassen, wird der nächste Datensatz oder das nächste Byte nach dem letzten `FileGet` oder der `FilePut` Funktion geschrieben, oder es wird auf die letzte `Seek` Funktion verwiesen.  
  
 Das `StringIsFixedLength`-Argument steuert, ob die Funktion Zeichen folgen als Variable oder eine Länge mit fester Länge interpretiert. `FilePut` schreibt den Längen Deskriptor nicht, wenn das Argument `True`ist. Wenn Sie `StringIsFixedLength` = `True` mit `FilePut`verwenden, müssen Sie mit `FileGet`identisch Vorgehen, und Sie müssen sicherstellen, dass die Zeichenfolge mit der erwarteten Länge initialisiert wird.  
  
## <a name="random-mode"></a>Zufälliger Modus  
 Für Dateien, die im `Random` Modus geöffnet werden, gelten die folgenden Regeln:  
  
-   Wenn die Länge der geschriebenen Daten kleiner ist als die Länge, die in der `RecordLength`-Klausel der `FileOpen`-Funktion angegeben ist, schreibt `FilePut` nachfolgende Datensätze an Grenzen der Daten Satz Länge. Der Leerraum zwischen dem Ende eines Datensatzes und dem Anfang des nächsten Datensatzes wird mit dem vorhandenen Inhalt des Datei Puffers aufgefüllt. Da die Menge der Auffüll Daten nicht mit Sicherheit bestimmt werden kann, empfiehlt es sich im Allgemeinen, die Daten Satz Länge mit der Länge der geschriebenen Daten zu vergleichen. Wenn die Länge der geschriebenen Daten größer ist als die Länge, die in der `RecordLength`-Klausel der `FileOpen`-Funktion angegeben ist, wird eine Ausnahme ausgelöst.  
  
-   Wenn die Variable, die geschrieben wird, eine Zeichenfolge ist, schreibt `FilePut` einen 2-Byte-Deskriptor, der die Zeichen folgen Länge enthält, und schreibt dann die Daten, die in die Variable aufgenommen werden. Daher muss die von der `RecordLength`-Klausel in der `FileOpen`-Funktion angegebene Daten Satz Länge mindestens zwei Bytes aufweisen, die größer als die tatsächliche Länge der Zeichenfolge ist.  
  
-   Wenn die Variable, die geschrieben wird, ein Objekt ist, das einen numerischen Typ enthält, `FilePut` schreibt zwei Bytes, die die `VarType` des Objekts identifizieren, und schreibt dann die Variable. Wenn Sie z. b. ein Objekt schreiben, das eine ganze Zahl enthält, werden `FilePut` sechs Bytes schreiben: zwei Bytes, die das Objekt als `VarType(3)` (`Integer`) und vier Bytes, die die Daten enthalten, identifizieren. Die vom `RecordLength`-Parameter in der `FileOpen`-Funktion angegebene Daten Satz Länge muss mindestens zwei Byte betragen, die größer ist als die tatsächliche Anzahl von Bytes, die zum Speichern der Variablen erforderlich sind.  
  
-   Wenn die Variable, die geschrieben wird, ein Objekt ist, das eine Zeichenfolge enthält, schreibt `FilePut` einen zwei-Byte-Deskriptor, der die `VarType(8)` des Objekts identifiziert, einen 2-Byte-Deskriptor, der die Länge der Zeichenfolge angibt, und schreibt dann die Zeichen folgen Daten. Die vom `RecordLength`-Parameter in der `FileOpen`-Funktion angegebene Daten Satz Länge muss mindestens vier Byte betragen, die größer als die tatsächliche Länge der Zeichenfolge ist. Wenn Sie eine Zeichenfolge ohne den Deskriptor platzieren möchten, sollten Sie `True` an den `StringIsFixedLength`-Parameter übergeben, und die Zeichenfolge, in die Sie eingelesen haben, sollte die richtige Länge aufweisen.  
  
-   Wenn die Variable, die geschrieben wird, ein Array ist, können Sie entscheiden, ob ein Deskriptor für die Größe und die Dimensionen des Arrays geschrieben werden soll. In Visual Basic 6,0 und früheren Versionen wird der Dateideskriptor für ein dynamisches Array geschrieben, jedoch nicht für ein Array mit fester Größe. Visual Basic 2005 wird der Deskriptor standardmäßig nicht geschrieben. Legen Sie zum Schreiben des Deskriptors den `ArrayIsDynamic`-Parameter auf `True`fest. Beim Schreiben des Arrays müssen Sie der Art und Weise entsprechen, in der das Array gelesen wird. Wenn Sie mit dem Deskriptor gelesen wird, müssen Sie den Deskriptor schreiben. Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang an. Die Länge ist 2 plus das 8-fache der Anzahl der Dimensionen: (2 + 8 * anzahldimensionen). Die von der `RecordLength`-Klausel in der `FileOpen`-Funktion angegebene Daten Satz Länge muss größer oder gleich der Summe aller Bytes sein, die zum Schreiben der Array Daten und des Array Deskriptors erforderlich sind. Die folgende Array Deklaration benötigt z. b. 218 bytes, wenn das Array auf den Datenträger geschrieben wird.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Wenn die Variable, die geschrieben wird, ein beliebiger anderer Typ der Variablen ist (keine Zeichenfolge mit variabler Länge oder ein Objekt), werden `FilePut` nur die Variablen Daten schreiben. Die von der `RecordLength`-Klausel in der `FileOpen`-Funktion angegebene Daten Satz Länge muss größer oder gleich der Länge der geschriebenen Daten sein.  
  
-   `FilePut` schreibt Elemente von Strukturen so, als wären Sie einzeln geschrieben worden, mit dem Unterschied, dass keine Auffüll Zeichen zwischen Elementen vorhanden sind. Das `VBFixedString`-Attribut kann auf Zeichen folgen Felder in den Strukturen angewendet werden, um die Größe der Zeichenfolge beim Schreiben auf den Datenträger anzugeben.  
  
    > [!NOTE]
    >  Zeichen folgen Felder, die mehr Bytes aufweisen, als durch das `VBFixedString`-Attribut angegeben werden, werden beim Schreiben auf den Datenträger abgeschnitten.  
  
## <a name="binary-mode"></a>Binärmodus  
 Bei Dateien, die im `Binary` Modus geöffnet wurden, gelten die meisten `Random` Modusregeln mit einigen Ausnahmen. Die folgenden Regeln für Dateien, die im `Binary` Modus geöffnet werden, unterscheiden sich von den Regeln für `Random`-Modus:  
  
-   Die `RecordLength`-Klausel in der `FileOpen`-Funktion hat keine Auswirkungen. `FilePut` alle Variablen zusammenhängend auf den Datenträger schreibt, d. h. ohne Auffüll Zeichen zwischen Datensätzen.  
  
-   Für ein beliebiges Array, das kein Array in einer Struktur ist, schreibt `FilePut` nur die Daten. Es wurde kein Deskriptor geschrieben.  
  
-   `FilePut` schreibt Zeichen folgen variabler Länge, die keine Elemente von Strukturen sind, ohne den zwei Byte langen Längen Deskriptor. Die Anzahl der geschriebenen Bytes ist mit der Anzahl der Zeichen in der Zeichenfolge. Beispielsweise schreiben die folgenden Anweisungen 11 Bytes in die Dateinummer 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Zum Schreiben in eine Datei mit der `FilePut`-Funktion ist `Write` Zugriff von der <xref:System.Security.Permissions.FileIOPermissionAccess>-Enumeration erforderlich.  
  
   
  
## Examples  
 In diesem Beispiel wird die `FilePut`-Funktion verwendet, um Daten in eine Datei zu schreiben. Fünf Datensätze der Struktur `Person` werden in die Datei geschrieben.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</exception>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files">Schreiben in Dateien in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, DateTime Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FilePut(int32 FileNumber, valuetype System.DateTime Value, int64 RecordNumber) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As DateTime, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * DateTime * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, valuetype System.DateTime Value, int64 RecordNumber) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="Value">Erforderlich. Gültiger Variablenname, der auf den Datenträger geschriebene Daten enthält.</param>
        <param name="RecordNumber">Optional. Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), an der der Schreibvorgang beginnt.</param>
        <summary>Schreibt Daten aus einer Variablen in eine Datei auf einem Datenträger. Die <see langword="My" />-Funktion bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FilePut" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` ist nur im `Random`-und `Binary` Modus gültig.  
  
 Mit `FilePut` geschriebene Daten werden in der Regel mit `FileGet` aus einer Datei gelesen.  
  
 Der erste Datensatz oder das Byte in einer Datei befindet sich an Position 1, der zweite Datensatz bzw. das zweite Byte befindet sich an Position 2 usw. Wenn Sie `RecordNumber`weglassen, wird der nächste Datensatz oder das nächste Byte nach dem letzten `FileGet` oder der `FilePut` Funktion geschrieben, oder es wird auf die letzte `Seek` Funktion verwiesen.  
  
 Das `StringIsFixedLength`-Argument steuert, ob die Funktion Zeichen folgen als Variable oder eine Länge mit fester Länge interpretiert. `FilePut` schreibt den Längen Deskriptor nicht, wenn das Argument `True`ist. Wenn Sie `StringIsFixedLength` = `True` mit `FilePut`verwenden, müssen Sie mit `FileGet`identisch Vorgehen, und Sie müssen sicherstellen, dass die Zeichenfolge mit der erwarteten Länge initialisiert wird.  
  
## <a name="random-mode"></a>Zufälliger Modus  
 Für Dateien, die im `Random` Modus geöffnet werden, gelten die folgenden Regeln:  
  
-   Wenn die Länge der geschriebenen Daten kleiner ist als die Länge, die in der `RecordLength`-Klausel der `FileOpen`-Funktion angegeben ist, schreibt `FilePut` nachfolgende Datensätze an Grenzen der Daten Satz Länge. Der Leerraum zwischen dem Ende eines Datensatzes und dem Anfang des nächsten Datensatzes wird mit dem vorhandenen Inhalt des Datei Puffers aufgefüllt. Da die Menge der Auffüll Daten nicht mit Sicherheit bestimmt werden kann, empfiehlt es sich im Allgemeinen, die Daten Satz Länge mit der Länge der geschriebenen Daten zu vergleichen. Wenn die Länge der geschriebenen Daten größer ist als die Länge, die in der `RecordLength`-Klausel der `FileOpen`-Funktion angegeben ist, wird eine Ausnahme ausgelöst.  
  
-   Wenn die Variable, die geschrieben wird, eine Zeichenfolge ist, schreibt `FilePut` einen 2-Byte-Deskriptor, der die Zeichen folgen Länge enthält, und schreibt dann die Daten, die in die Variable aufgenommen werden. Daher muss die von der `RecordLength`-Klausel in der `FileOpen`-Funktion angegebene Daten Satz Länge mindestens zwei Bytes aufweisen, die größer als die tatsächliche Länge der Zeichenfolge ist.  
  
-   Wenn die Variable, die geschrieben wird, ein Objekt ist, das einen numerischen Typ enthält, `FilePut` schreibt zwei Bytes, die die `VarType` des Objekts identifizieren, und schreibt dann die Variable. Wenn Sie z. b. ein Objekt schreiben, das eine ganze Zahl enthält, werden `FilePut` sechs Bytes schreiben: zwei Bytes, die das Objekt als `VarType(3)` (`Integer`) und vier Bytes, die die Daten enthalten, identifizieren. Die vom `RecordLength`-Parameter in der `FileOpen`-Funktion angegebene Daten Satz Länge muss mindestens zwei Byte betragen, die größer ist als die tatsächliche Anzahl von Bytes, die zum Speichern der Variablen erforderlich sind.  
  
-   Wenn die Variable, die geschrieben wird, ein Objekt ist, das eine Zeichenfolge enthält, schreibt `FilePut` einen zwei-Byte-Deskriptor, der die `VarType(8)` des Objekts identifiziert, einen 2-Byte-Deskriptor, der die Länge der Zeichenfolge angibt, und schreibt dann die Zeichen folgen Daten. Die vom `RecordLength`-Parameter in der `FileOpen`-Funktion angegebene Daten Satz Länge muss mindestens vier Byte betragen, die größer als die tatsächliche Länge der Zeichenfolge ist. Wenn Sie eine Zeichenfolge ohne den Deskriptor platzieren möchten, sollten Sie `True` an den `StringIsFixedLength`-Parameter übergeben, und die Zeichenfolge, in die Sie eingelesen haben, sollte die richtige Länge aufweisen.  
  
-   Wenn die Variable, die geschrieben wird, ein Array ist, können Sie entscheiden, ob ein Deskriptor für die Größe und die Dimensionen des Arrays geschrieben werden soll. In Visual Basic 6,0 und früheren Versionen wird der Dateideskriptor für ein dynamisches Array geschrieben, jedoch nicht für ein Array mit fester Größe. Visual Basic 2005 wird der Deskriptor standardmäßig nicht geschrieben. Legen Sie zum Schreiben des Deskriptors den `ArrayIsDynamic`-Parameter auf `True`fest. Beim Schreiben des Arrays müssen Sie der Art und Weise entsprechen, in der das Array gelesen wird. Wenn Sie mit dem Deskriptor gelesen wird, müssen Sie den Deskriptor schreiben. Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang an. Die Länge ist 2 plus das 8-fache der Anzahl der Dimensionen: (2 + 8 * anzahldimensionen). Die von der `RecordLength`-Klausel in der `FileOpen`-Funktion angegebene Daten Satz Länge muss größer oder gleich der Summe aller Bytes sein, die zum Schreiben der Array Daten und des Array Deskriptors erforderlich sind. Die folgende Array Deklaration benötigt z. b. 218 bytes, wenn das Array auf den Datenträger geschrieben wird.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Wenn die Variable, die geschrieben wird, ein beliebiger anderer Typ der Variablen ist (keine Zeichenfolge mit variabler Länge oder ein Objekt), werden `FilePut` nur die Variablen Daten schreiben. Die von der `RecordLength`-Klausel in der `FileOpen`-Funktion angegebene Daten Satz Länge muss größer oder gleich der Länge der geschriebenen Daten sein.  
  
-   `FilePut` schreibt Elemente von Strukturen so, als wären Sie einzeln geschrieben worden, mit dem Unterschied, dass keine Auffüll Zeichen zwischen Elementen vorhanden sind. Das `VBFixedString`-Attribut kann auf Zeichen folgen Felder in den Strukturen angewendet werden, um die Größe der Zeichenfolge beim Schreiben auf den Datenträger anzugeben.  
  
    > [!NOTE]
    >  Zeichen folgen Felder, die mehr Bytes aufweisen, als durch das `VBFixedString`-Attribut angegeben werden, werden beim Schreiben auf den Datenträger abgeschnitten.  
  
## <a name="binary-mode"></a>Binärmodus  
 Bei Dateien, die im `Binary` Modus geöffnet wurden, gelten die meisten `Random` Modusregeln mit einigen Ausnahmen. Die folgenden Regeln für Dateien, die im `Binary` Modus geöffnet werden, unterscheiden sich von den Regeln für `Random`-Modus:  
  
-   Die `RecordLength`-Klausel in der `FileOpen`-Funktion hat keine Auswirkungen. `FilePut` alle Variablen zusammenhängend auf den Datenträger schreibt, d. h. ohne Auffüll Zeichen zwischen Datensätzen.  
  
-   Für ein beliebiges Array, das kein Array in einer Struktur ist, schreibt `FilePut` nur die Daten. Es wurde kein Deskriptor geschrieben.  
  
-   `FilePut` schreibt Zeichen folgen variabler Länge, die keine Elemente von Strukturen sind, ohne den zwei Byte langen Längen Deskriptor. Die Anzahl der geschriebenen Bytes ist mit der Anzahl der Zeichen in der Zeichenfolge. Beispielsweise schreiben die folgenden Anweisungen 11 Bytes in die Dateinummer 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Zum Schreiben in eine Datei mit der `FilePut`-Funktion ist `Write` Zugriff von der <xref:System.Security.Permissions.FileIOPermissionAccess>-Enumeration erforderlich.  
  
   
  
## Examples  
 In diesem Beispiel wird die `FilePut`-Funktion verwendet, um Daten in eine Datei zu schreiben. Fünf Datensätze der Struktur `Person` werden in die Datei geschrieben.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</exception>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files">Schreiben in Dateien in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, decimal Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FilePut(int32 FileNumber, valuetype System.Decimal Value, int64 RecordNumber) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Decimal, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * decimal * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, valuetype System.Decimal Value, int64 RecordNumber) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="Value">Erforderlich. Gültiger Variablenname, der auf den Datenträger geschriebene Daten enthält.</param>
        <param name="RecordNumber">Optional. Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), an der der Schreibvorgang beginnt.</param>
        <summary>Schreibt Daten aus einer Variablen in eine Datei auf einem Datenträger. Die <see langword="My" />-Funktion bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FilePut" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` ist nur im `Random`-und `Binary` Modus gültig.  
  
 Mit `FilePut` geschriebene Daten werden in der Regel mit `FileGet` aus einer Datei gelesen.  
  
 Der erste Datensatz oder das Byte in einer Datei befindet sich an Position 1, der zweite Datensatz bzw. das zweite Byte befindet sich an Position 2 usw. Wenn Sie `RecordNumber`weglassen, wird der nächste Datensatz oder das nächste Byte nach dem letzten `FileGet` oder der `FilePut` Funktion geschrieben, oder es wird auf die letzte `Seek` Funktion verwiesen.  
  
 Das `StringIsFixedLength`-Argument steuert, ob die Funktion Zeichen folgen als Variable oder eine Länge mit fester Länge interpretiert. `FilePut` schreibt den Längen Deskriptor nicht, wenn das Argument `True`ist. Wenn Sie `StringIsFixedLength` = `True` mit `FilePut`verwenden, müssen Sie mit `FileGet`identisch Vorgehen, und Sie müssen sicherstellen, dass die Zeichenfolge mit der erwarteten Länge initialisiert wird.  
  
## <a name="random-mode"></a>Zufälliger Modus  
 Für Dateien, die im `Random` Modus geöffnet werden, gelten die folgenden Regeln:  
  
-   Wenn die Länge der geschriebenen Daten kleiner ist als die Länge, die in der `RecordLength`-Klausel der `FileOpen`-Funktion angegeben ist, schreibt `FilePut` nachfolgende Datensätze an Grenzen der Daten Satz Länge. Der Leerraum zwischen dem Ende eines Datensatzes und dem Anfang des nächsten Datensatzes wird mit dem vorhandenen Inhalt des Datei Puffers aufgefüllt. Da die Menge der Auffüll Daten nicht mit Sicherheit bestimmt werden kann, empfiehlt es sich im Allgemeinen, die Daten Satz Länge mit der Länge der geschriebenen Daten zu vergleichen. Wenn die Länge der geschriebenen Daten größer ist als die Länge, die in der `RecordLength`-Klausel der `FileOpen`-Funktion angegeben ist, wird eine Ausnahme ausgelöst.  
  
-   Wenn die Variable, die geschrieben wird, eine Zeichenfolge ist, schreibt `FilePut` einen 2-Byte-Deskriptor, der die Zeichen folgen Länge enthält, und schreibt dann die Daten, die in die Variable aufgenommen werden. Daher muss die von der `RecordLength`-Klausel in der `FileOpen`-Funktion angegebene Daten Satz Länge mindestens zwei Bytes aufweisen, die größer als die tatsächliche Länge der Zeichenfolge ist.  
  
-   Wenn die Variable, die geschrieben wird, ein Objekt ist, das einen numerischen Typ enthält, `FilePut` schreibt zwei Bytes, die die `VarType` des Objekts identifizieren, und schreibt dann die Variable. Wenn Sie z. b. ein Objekt schreiben, das eine ganze Zahl enthält, werden `FilePut` sechs Bytes schreiben: zwei Bytes, die das Objekt als `VarType(3)` (`Integer`) und vier Bytes, die die Daten enthalten, identifizieren. Die vom `RecordLength`-Parameter in der `FileOpen`-Funktion angegebene Daten Satz Länge muss mindestens zwei Byte betragen, die größer ist als die tatsächliche Anzahl von Bytes, die zum Speichern der Variablen erforderlich sind.  
  
-   Wenn die Variable, die geschrieben wird, ein Objekt ist, das eine Zeichenfolge enthält, schreibt `FilePut` einen zwei-Byte-Deskriptor, der die `VarType(8)` des Objekts identifiziert, einen 2-Byte-Deskriptor, der die Länge der Zeichenfolge angibt, und schreibt dann die Zeichen folgen Daten. Die vom `RecordLength`-Parameter in der `FileOpen`-Funktion angegebene Daten Satz Länge muss mindestens vier Byte betragen, die größer als die tatsächliche Länge der Zeichenfolge ist. Wenn Sie eine Zeichenfolge ohne den Deskriptor platzieren möchten, sollten Sie `True` an den `StringIsFixedLength`-Parameter übergeben, und die Zeichenfolge, in die Sie eingelesen haben, sollte die richtige Länge aufweisen.  
  
-   Wenn die Variable, die geschrieben wird, ein Array ist, können Sie entscheiden, ob ein Deskriptor für die Größe und die Dimensionen des Arrays geschrieben werden soll. In Visual Basic 6,0 und früheren Versionen wird der Dateideskriptor für ein dynamisches Array geschrieben, jedoch nicht für ein Array mit fester Größe. Visual Basic 2005 wird der Deskriptor standardmäßig nicht geschrieben. Legen Sie zum Schreiben des Deskriptors den `ArrayIsDynamic`-Parameter auf `True`fest. Beim Schreiben des Arrays müssen Sie der Art und Weise entsprechen, in der das Array gelesen wird. Wenn Sie mit dem Deskriptor gelesen wird, müssen Sie den Deskriptor schreiben. Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang an. Die Länge ist 2 plus das 8-fache der Anzahl der Dimensionen: (2 + 8 * anzahldimensionen). Die von der `RecordLength`-Klausel in der `FileOpen`-Funktion angegebene Daten Satz Länge muss größer oder gleich der Summe aller Bytes sein, die zum Schreiben der Array Daten und des Array Deskriptors erforderlich sind. Die folgende Array Deklaration benötigt z. b. 218 bytes, wenn das Array auf den Datenträger geschrieben wird.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Wenn die Variable, die geschrieben wird, ein beliebiger anderer Typ der Variablen ist (keine Zeichenfolge mit variabler Länge oder ein Objekt), werden `FilePut` nur die Variablen Daten schreiben. Die von der `RecordLength`-Klausel in der `FileOpen`-Funktion angegebene Daten Satz Länge muss größer oder gleich der Länge der geschriebenen Daten sein.  
  
-   `FilePut` schreibt Elemente von Strukturen so, als wären Sie einzeln geschrieben worden, mit dem Unterschied, dass keine Auffüll Zeichen zwischen Elementen vorhanden sind. Das `VBFixedString`-Attribut kann auf Zeichen folgen Felder in den Strukturen angewendet werden, um die Größe der Zeichenfolge beim Schreiben auf den Datenträger anzugeben.  
  
    > [!NOTE]
    >  Zeichen folgen Felder, die mehr Bytes aufweisen, als durch das `VBFixedString`-Attribut angegeben werden, werden beim Schreiben auf den Datenträger abgeschnitten.  
  
## <a name="binary-mode"></a>Binärmodus  
 Bei Dateien, die im `Binary` Modus geöffnet wurden, gelten die meisten `Random` Modusregeln mit einigen Ausnahmen. Die folgenden Regeln für Dateien, die im `Binary` Modus geöffnet werden, unterscheiden sich von den Regeln für `Random`-Modus:  
  
-   Die `RecordLength`-Klausel in der `FileOpen`-Funktion hat keine Auswirkungen. `FilePut` alle Variablen zusammenhängend auf den Datenträger schreibt, d. h. ohne Auffüll Zeichen zwischen Datensätzen.  
  
-   Für ein beliebiges Array, das kein Array in einer Struktur ist, schreibt `FilePut` nur die Daten. Es wurde kein Deskriptor geschrieben.  
  
-   `FilePut` schreibt Zeichen folgen variabler Länge, die keine Elemente von Strukturen sind, ohne den zwei Byte langen Längen Deskriptor. Die Anzahl der geschriebenen Bytes ist mit der Anzahl der Zeichen in der Zeichenfolge. Beispielsweise schreiben die folgenden Anweisungen 11 Bytes in die Dateinummer 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Zum Schreiben in eine Datei mit der `FilePut`-Funktion ist `Write` Zugriff von der <xref:System.Security.Permissions.FileIOPermissionAccess>-Enumeration erforderlich.  
  
   
  
## Examples  
 In diesem Beispiel wird die `FilePut`-Funktion verwendet, um Daten in eine Datei zu schreiben. Fünf Datensätze der Struktur `Person` werden in die Datei geschrieben.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</exception>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files">Schreiben in Dateien in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, double Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FilePut(int32 FileNumber, float64 Value, int64 RecordNumber) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Double, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * double * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, float64 Value, int64 RecordNumber) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="Value">Erforderlich. Gültiger Variablenname, der auf den Datenträger geschriebene Daten enthält.</param>
        <param name="RecordNumber">Optional. Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), an der der Schreibvorgang beginnt.</param>
        <summary>Schreibt Daten aus einer Variablen in eine Datei auf einem Datenträger. Die <see langword="My" />-Funktion bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FilePut" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` ist nur im `Random`-und `Binary` Modus gültig.  
  
 Mit `FilePut` geschriebene Daten werden in der Regel mit `FileGet` aus einer Datei gelesen.  
  
 Der erste Datensatz oder das Byte in einer Datei befindet sich an Position 1, der zweite Datensatz bzw. das zweite Byte befindet sich an Position 2 usw. Wenn Sie `RecordNumber`weglassen, wird der nächste Datensatz oder das nächste Byte nach dem letzten `FileGet` oder der `FilePut` Funktion geschrieben, oder es wird auf die letzte `Seek` Funktion verwiesen.  
  
 Das `StringIsFixedLength`-Argument steuert, ob die Funktion Zeichen folgen als Variable oder eine Länge mit fester Länge interpretiert. `FilePut` schreibt den Längen Deskriptor nicht, wenn das Argument `True`ist. Wenn Sie `StringIsFixedLength` = `True` mit `FilePut`verwenden, müssen Sie mit `FileGet`identisch Vorgehen, und Sie müssen sicherstellen, dass die Zeichenfolge mit der erwarteten Länge initialisiert wird.  
  
## <a name="random-mode"></a>Zufälliger Modus  
 Für Dateien, die im `Random` Modus geöffnet werden, gelten die folgenden Regeln:  
  
-   Wenn die Länge der geschriebenen Daten kleiner ist als die Länge, die in der `RecordLength`-Klausel der `FileOpen`-Funktion angegeben ist, schreibt `FilePut` nachfolgende Datensätze an Grenzen der Daten Satz Länge. Der Leerraum zwischen dem Ende eines Datensatzes und dem Anfang des nächsten Datensatzes wird mit dem vorhandenen Inhalt des Datei Puffers aufgefüllt. Da die Menge der Auffüll Daten nicht mit Sicherheit bestimmt werden kann, empfiehlt es sich im Allgemeinen, die Daten Satz Länge mit der Länge der geschriebenen Daten zu vergleichen. Wenn die Länge der geschriebenen Daten größer ist als die Länge, die in der `RecordLength`-Klausel der `FileOpen`-Funktion angegeben ist, wird eine Ausnahme ausgelöst.  
  
-   Wenn die Variable, die geschrieben wird, eine Zeichenfolge ist, schreibt `FilePut` einen 2-Byte-Deskriptor, der die Zeichen folgen Länge enthält, und schreibt dann die Daten, die in die Variable aufgenommen werden. Daher muss die von der `RecordLength`-Klausel in der `FileOpen`-Funktion angegebene Daten Satz Länge mindestens zwei Bytes aufweisen, die größer als die tatsächliche Länge der Zeichenfolge ist.  
  
-   Wenn die Variable, die geschrieben wird, ein Objekt ist, das einen numerischen Typ enthält, `FilePut` schreibt zwei Bytes, die die `VarType` des Objekts identifizieren, und schreibt dann die Variable. Wenn Sie z. b. ein Objekt schreiben, das eine ganze Zahl enthält, werden `FilePut` sechs Bytes schreiben: zwei Bytes, die das Objekt als `VarType(3)` (`Integer`) und vier Bytes, die die Daten enthalten, identifizieren. Die vom `RecordLength`-Parameter in der `FileOpen`-Funktion angegebene Daten Satz Länge muss mindestens zwei Byte betragen, die größer ist als die tatsächliche Anzahl von Bytes, die zum Speichern der Variablen erforderlich sind.  
  
-   Wenn die Variable, die geschrieben wird, ein Objekt ist, das eine Zeichenfolge enthält, schreibt `FilePut` einen zwei-Byte-Deskriptor, der die `VarType(8)` des Objekts identifiziert, einen 2-Byte-Deskriptor, der die Länge der Zeichenfolge angibt, und schreibt dann die Zeichen folgen Daten. Die vom `RecordLength`-Parameter in der `FileOpen`-Funktion angegebene Daten Satz Länge muss mindestens vier Byte betragen, die größer als die tatsächliche Länge der Zeichenfolge ist. Wenn Sie eine Zeichenfolge ohne den Deskriptor platzieren möchten, sollten Sie `True` an den `StringIsFixedLength`-Parameter übergeben, und die Zeichenfolge, in die Sie eingelesen haben, sollte die richtige Länge aufweisen.  
  
-   Wenn die Variable, die geschrieben wird, ein Array ist, können Sie entscheiden, ob ein Deskriptor für die Größe und die Dimensionen des Arrays geschrieben werden soll. In Visual Basic 6,0 und früheren Versionen wird der Dateideskriptor für ein dynamisches Array geschrieben, jedoch nicht für ein Array mit fester Größe. Visual Basic 2005 wird der Deskriptor standardmäßig nicht geschrieben. Legen Sie zum Schreiben des Deskriptors den `ArrayIsDynamic`-Parameter auf `True`fest. Beim Schreiben des Arrays müssen Sie der Art und Weise entsprechen, in der das Array gelesen wird. Wenn Sie mit dem Deskriptor gelesen wird, müssen Sie den Deskriptor schreiben. Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang an. Die Länge ist 2 plus das 8-fache der Anzahl der Dimensionen: (2 + 8 * anzahldimensionen). Die von der `RecordLength`-Klausel in der `FileOpen`-Funktion angegebene Daten Satz Länge muss größer oder gleich der Summe aller Bytes sein, die zum Schreiben der Array Daten und des Array Deskriptors erforderlich sind. Die folgende Array Deklaration benötigt z. b. 218 bytes, wenn das Array auf den Datenträger geschrieben wird.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Wenn die Variable, die geschrieben wird, ein beliebiger anderer Typ der Variablen ist (keine Zeichenfolge mit variabler Länge oder ein Objekt), werden `FilePut` nur die Variablen Daten schreiben. Die von der `RecordLength`-Klausel in der `FileOpen`-Funktion angegebene Daten Satz Länge muss größer oder gleich der Länge der geschriebenen Daten sein.  
  
-   `FilePut` schreibt Elemente von Strukturen so, als wären Sie einzeln geschrieben worden, mit dem Unterschied, dass keine Auffüll Zeichen zwischen Elementen vorhanden sind. Das `VBFixedString`-Attribut kann auf Zeichen folgen Felder in den Strukturen angewendet werden, um die Größe der Zeichenfolge beim Schreiben auf den Datenträger anzugeben.  
  
    > [!NOTE]
    >  Zeichen folgen Felder, die mehr Bytes aufweisen, als durch das `VBFixedString`-Attribut angegeben werden, werden beim Schreiben auf den Datenträger abgeschnitten.  
  
## <a name="binary-mode"></a>Binärmodus  
 Bei Dateien, die im `Binary` Modus geöffnet wurden, gelten die meisten `Random` Modusregeln mit einigen Ausnahmen. Die folgenden Regeln für Dateien, die im `Binary` Modus geöffnet werden, unterscheiden sich von den Regeln für `Random`-Modus:  
  
-   Die `RecordLength`-Klausel in der `FileOpen`-Funktion hat keine Auswirkungen. `FilePut` alle Variablen zusammenhängend auf den Datenträger schreibt, d. h. ohne Auffüll Zeichen zwischen Datensätzen.  
  
-   Für ein beliebiges Array, das kein Array in einer Struktur ist, schreibt `FilePut` nur die Daten. Es wurde kein Deskriptor geschrieben.  
  
-   `FilePut` schreibt Zeichen folgen variabler Länge, die keine Elemente von Strukturen sind, ohne den zwei Byte langen Längen Deskriptor. Die Anzahl der geschriebenen Bytes ist mit der Anzahl der Zeichen in der Zeichenfolge. Beispielsweise schreiben die folgenden Anweisungen 11 Bytes in die Dateinummer 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Zum Schreiben in eine Datei mit der `FilePut`-Funktion ist `Write` Zugriff von der <xref:System.Security.Permissions.FileIOPermissionAccess>-Enumeration erforderlich.  
  
   
  
## Examples  
 In diesem Beispiel wird die `FilePut`-Funktion verwendet, um Daten in eine Datei zu schreiben. Fünf Datensätze der Struktur `Person` werden in die Datei geschrieben.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</exception>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files">Schreiben in Dateien in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, short Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FilePut(int32 FileNumber, int16 Value, int64 RecordNumber) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Short, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * int16 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int16 Value, int64 RecordNumber) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="Value">Erforderlich. Gültiger Variablenname, der auf den Datenträger geschriebene Daten enthält.</param>
        <param name="RecordNumber">Optional. Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), an der der Schreibvorgang beginnt.</param>
        <summary>Schreibt Daten aus einer Variablen in eine Datei auf einem Datenträger. Die <see langword="My" />-Funktion bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FilePut" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` ist nur im `Random`-und `Binary` Modus gültig.  
  
 Mit `FilePut` geschriebene Daten werden in der Regel mit `FileGet` aus einer Datei gelesen.  
  
 Der erste Datensatz oder das Byte in einer Datei befindet sich an Position 1, der zweite Datensatz bzw. das zweite Byte befindet sich an Position 2 usw. Wenn Sie `RecordNumber`weglassen, wird der nächste Datensatz oder das nächste Byte nach dem letzten `FileGet` oder der `FilePut` Funktion geschrieben, oder es wird auf die letzte `Seek` Funktion verwiesen.  
  
 Das `StringIsFixedLength`-Argument steuert, ob die Funktion Zeichen folgen als Variable oder eine Länge mit fester Länge interpretiert. `FilePut` schreibt den Längen Deskriptor nicht, wenn das Argument `True`ist. Wenn Sie `StringIsFixedLength` = `True` mit `FilePut`verwenden, müssen Sie mit `FileGet`identisch Vorgehen, und Sie müssen sicherstellen, dass die Zeichenfolge mit der erwarteten Länge initialisiert wird.  
  
## <a name="random-mode"></a>Zufälliger Modus  
 Für Dateien, die im `Random` Modus geöffnet werden, gelten die folgenden Regeln:  
  
-   Wenn die Länge der geschriebenen Daten kleiner ist als die Länge, die in der `RecordLength`-Klausel der `FileOpen`-Funktion angegeben ist, schreibt `FilePut` nachfolgende Datensätze an Grenzen der Daten Satz Länge. Der Leerraum zwischen dem Ende eines Datensatzes und dem Anfang des nächsten Datensatzes wird mit dem vorhandenen Inhalt des Datei Puffers aufgefüllt. Da die Menge der Auffüll Daten nicht mit Sicherheit bestimmt werden kann, empfiehlt es sich im Allgemeinen, die Daten Satz Länge mit der Länge der geschriebenen Daten zu vergleichen. Wenn die Länge der geschriebenen Daten größer ist als die Länge, die in der `RecordLength`-Klausel der `FileOpen`-Funktion angegeben ist, wird eine Ausnahme ausgelöst.  
  
-   Wenn die Variable, die geschrieben wird, eine Zeichenfolge ist, schreibt `FilePut` einen 2-Byte-Deskriptor, der die Zeichen folgen Länge enthält, und schreibt dann die Daten, die in die Variable aufgenommen werden. Daher muss die von der `RecordLength`-Klausel in der `FileOpen`-Funktion angegebene Daten Satz Länge mindestens zwei Bytes aufweisen, die größer als die tatsächliche Länge der Zeichenfolge ist.  
  
-   Wenn die Variable, die geschrieben wird, ein Objekt ist, das einen numerischen Typ enthält, `FilePut` schreibt zwei Bytes, die die `VarType` des Objekts identifizieren, und schreibt dann die Variable. Wenn Sie z. b. ein Objekt schreiben, das eine ganze Zahl enthält, werden `FilePut` sechs Bytes schreiben: zwei Bytes, die das Objekt als `VarType(3)` (`Integer`) und vier Bytes, die die Daten enthalten, identifizieren. Die vom `RecordLength`-Parameter in der `FileOpen`-Funktion angegebene Daten Satz Länge muss mindestens zwei Byte betragen, die größer ist als die tatsächliche Anzahl von Bytes, die zum Speichern der Variablen erforderlich sind.  
  
-   Wenn die Variable, die geschrieben wird, ein Objekt ist, das eine Zeichenfolge enthält, schreibt `FilePut` einen zwei-Byte-Deskriptor, der die`VarType(8)` des Objekts identifiziert, einen 2-Byte-Deskriptor, der die Länge der Zeichenfolge angibt, und schreibt dann die Zeichen folgen Daten. Die vom `RecordLength`-Parameter in der `FileOpen`-Funktion angegebene Daten Satz Länge muss mindestens vier Byte betragen, die größer als die tatsächliche Länge der Zeichenfolge ist. Wenn Sie eine Zeichenfolge ohne den Deskriptor platzieren möchten, sollten Sie `True` an den `StringIsFixedLength`-Parameter übergeben, und die Zeichenfolge, in die Sie eingelesen haben, sollte die richtige Länge aufweisen.  
  
-   Wenn die Variable, die geschrieben wird, ein Array ist, können Sie entscheiden, ob ein Deskriptor für die Größe und die Dimensionen des Arrays geschrieben werden soll. In Visual Basic 6,0 und früheren Versionen wird der Dateideskriptor für ein dynamisches Array geschrieben, jedoch nicht für ein Array mit fester Größe. Visual Basic 2005 wird der Deskriptor standardmäßig nicht geschrieben. Legen Sie zum Schreiben des Deskriptors den `ArrayIsDynamic`-Parameter auf `True`fest. Beim Schreiben des Arrays müssen Sie der Art und Weise entsprechen, in der das Array gelesen wird. Wenn Sie mit dem Deskriptor gelesen wird, müssen Sie den Deskriptor schreiben. Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang an. Die Länge ist 2 plus das 8-fache der Anzahl der Dimensionen: (2 + 8 * anzahldimensionen). Die von der `RecordLength`-Klausel in der `FileOpen`-Funktion angegebene Daten Satz Länge muss größer oder gleich der Summe aller Bytes sein, die zum Schreiben der Array Daten und des Array Deskriptors erforderlich sind. Die folgende Array Deklaration benötigt z. b. 218 bytes, wenn das Array auf den Datenträger geschrieben wird.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Wenn die Variable, die geschrieben wird, ein beliebiger anderer Typ der Variablen ist (keine Zeichenfolge mit variabler Länge oder ein Objekt), werden `FilePut` nur die Variablen Daten schreiben. Die von der `RecordLength`-Klausel in der `FileOpen`-Funktion angegebene Daten Satz Länge muss größer oder gleich der Länge der geschriebenen Daten sein.  
  
-   `FilePut` schreibt Elemente von Strukturen so, als wären Sie einzeln geschrieben worden, mit dem Unterschied, dass keine Auffüll Zeichen zwischen Elementen vorhanden sind. Das `VBFixedString`-Attribut kann auf Zeichen folgen Felder in den Strukturen angewendet werden, um die Größe der Zeichenfolge beim Schreiben auf den Datenträger anzugeben.  
  
    > [!NOTE]
    >  Zeichen folgen Felder, die mehr Bytes aufweisen, als durch das `VBFixedString`-Attribut angegeben werden, werden beim Schreiben auf den Datenträger abgeschnitten.  
  
## <a name="binary-mode"></a>Binärmodus  
 Bei Dateien, die im `Binary` Modus geöffnet wurden, gelten die meisten `Random` Modusregeln mit einigen Ausnahmen. Die folgenden Regeln für Dateien, die im `Binary` Modus geöffnet werden, unterscheiden sich von den Regeln für `Random`-Modus:  
  
-   Die `RecordLength`-Klausel in der `FileOpen`-Funktion hat keine Auswirkungen. `FilePut` alle Variablen zusammenhängend auf den Datenträger schreibt, d. h. ohne Auffüll Zeichen zwischen Datensätzen.  
  
-   Für ein beliebiges Array, das kein Array in einer Struktur ist, schreibt `FilePut` nur die Daten. Es wurde kein Deskriptor geschrieben.  
  
-   `FilePut` schreibt Zeichen folgen variabler Länge, die keine Elemente von Strukturen sind, ohne den zwei Byte langen Längen Deskriptor. Die Anzahl der geschriebenen Bytes ist mit der Anzahl der Zeichen in der Zeichenfolge. Beispielsweise schreiben die folgenden Anweisungen 11 Bytes in die Dateinummer 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Zum Schreiben in eine Datei mit der `FilePut`-Funktion ist `Write` Zugriff von der <xref:System.Security.Permissions.FileIOPermissionAccess>-Enumeration erforderlich.  
  
   
  
## Examples  
 In diesem Beispiel wird die `FilePut`-Funktion verwendet, um Daten in eine Datei zu schreiben. Fünf Datensätze der Struktur `Person` werden in die Datei geschrieben.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</exception>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files">Schreiben in Dateien in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, int Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FilePut(int32 FileNumber, int32 Value, int64 RecordNumber) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Integer, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int32 Value, int64 RecordNumber) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="Value">Erforderlich. Gültiger Variablenname, der auf den Datenträger geschriebene Daten enthält.</param>
        <param name="RecordNumber">Optional. Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), an der der Schreibvorgang beginnt.</param>
        <summary>Schreibt Daten aus einer Variablen in eine Datei auf einem Datenträger. Die <see langword="My" />-Funktion bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FilePut" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` ist nur im `Random`-und `Binary` Modus gültig.  
  
 Mit `FilePut` geschriebene Daten werden in der Regel mit `FileGet` aus einer Datei gelesen.  
  
 Der erste Datensatz oder das Byte in einer Datei befindet sich an Position 1, der zweite Datensatz bzw. das zweite Byte befindet sich an Position 2 usw. Wenn Sie `RecordNumber`weglassen, wird der nächste Datensatz oder das nächste Byte nach dem letzten `FileGet` oder der `FilePut` Funktion geschrieben, oder es wird auf die letzte `Seek` Funktion verwiesen.  
  
 Das `StringIsFixedLength`-Argument steuert, ob die Funktion Zeichen folgen als Variable oder eine Länge mit fester Länge interpretiert. `FilePut` schreibt den Längen Deskriptor nicht, wenn das Argument `True`ist. Wenn Sie `StringIsFixedLength` = `True` mit `FilePut`verwenden, müssen Sie mit `FileGet`identisch Vorgehen, und Sie müssen sicherstellen, dass die Zeichenfolge mit der erwarteten Länge initialisiert wird.  
  
## <a name="random-mode"></a>Zufälliger Modus  
 Für Dateien, die im `Random` Modus geöffnet werden, gelten die folgenden Regeln:  
  
-   Wenn die Länge der geschriebenen Daten kleiner ist als die Länge, die in der `RecordLength`-Klausel der `FileOpen`-Funktion angegeben ist, schreibt `FilePut` nachfolgende Datensätze an Grenzen der Daten Satz Länge. Der Leerraum zwischen dem Ende eines Datensatzes und dem Anfang des nächsten Datensatzes wird mit dem vorhandenen Inhalt des Datei Puffers aufgefüllt. Da die Menge der Auffüll Daten nicht mit Sicherheit bestimmt werden kann, empfiehlt es sich im Allgemeinen, die Daten Satz Länge mit der Länge der geschriebenen Daten zu vergleichen. Wenn die Länge der geschriebenen Daten größer ist als die Länge, die in der `RecordLength`-Klausel der `FileOpen`-Funktion angegeben ist, wird eine Ausnahme ausgelöst.  
  
-   Wenn die Variable, die geschrieben wird, eine Zeichenfolge ist, schreibt `FilePut` einen 2-Byte-Deskriptor, der die Zeichen folgen Länge enthält, und schreibt dann die Daten, die in die Variable aufgenommen werden. Daher muss die von der `RecordLength`-Klausel in der `FileOpen`-Funktion angegebene Daten Satz Länge mindestens zwei Bytes aufweisen, die größer als die tatsächliche Länge der Zeichenfolge ist.  
  
-   Wenn die Variable, die geschrieben wird, ein Objekt ist, das einen numerischen Typ enthält, `FilePut` schreibt zwei Bytes, die die `VarType` des Objekts identifizieren, und schreibt dann die Variable. Wenn Sie z. b. ein Objekt schreiben, das eine ganze Zahl enthält, werden `FilePut` sechs Bytes schreiben: zwei Bytes, die das Objekt als `VarType(3)` (`Integer`) und vier Bytes, die die Daten enthalten, identifizieren. Die vom `RecordLength`-Parameter in der `FileOpen`-Funktion angegebene Daten Satz Länge muss mindestens zwei Byte betragen, die größer ist als die tatsächliche Anzahl von Bytes, die zum Speichern der Variablen erforderlich sind.  
  
-   Wenn die Variable, die geschrieben wird, ein Objekt ist, das eine Zeichenfolge enthält, schreibt `FilePut` einen zwei-Byte-Deskriptor, der die `VarType(8)` des Objekts identifiziert, einen 2-Byte-Deskriptor, der die Länge der Zeichenfolge angibt, und schreibt dann die Zeichen folgen Daten. Die vom `RecordLength`-Parameter in der `FileOpen`-Funktion angegebene Daten Satz Länge muss mindestens vier Byte betragen, die größer als die tatsächliche Länge der Zeichenfolge ist. Wenn Sie eine Zeichenfolge ohne den Deskriptor platzieren möchten, sollten Sie `True` an den `StringIsFixedLength`-Parameter übergeben, und die Zeichenfolge, in die Sie eingelesen haben, sollte die richtige Länge aufweisen.  
  
-   Wenn die Variable, die geschrieben wird, ein Array ist, können Sie entscheiden, ob ein Deskriptor für die Größe und die Dimensionen des Arrays geschrieben werden soll. In Visual Basic 6,0 und früheren Versionen wird der Dateideskriptor für ein dynamisches Array geschrieben, jedoch nicht für ein Array mit fester Größe. Visual Basic 2005 wird der Deskriptor standardmäßig nicht geschrieben. Legen Sie zum Schreiben des Deskriptors den `ArrayIsDynamic`-Parameter auf `True`fest. Beim Schreiben des Arrays müssen Sie der Art und Weise entsprechen, in der das Array gelesen wird. Wenn Sie mit dem Deskriptor gelesen wird, müssen Sie den Deskriptor schreiben. Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang an. Die Länge ist 2 plus das 8-fache der Anzahl der Dimensionen: (2 + 8 * anzahldimensionen). Die von der `RecordLength`-Klausel in der `FileOpen`-Funktion angegebene Daten Satz Länge muss größer oder gleich der Summe aller Bytes sein, die zum Schreiben der Array Daten und des Array Deskriptors erforderlich sind. Die folgende Array Deklaration benötigt z. b. 218 bytes, wenn das Array auf den Datenträger geschrieben wird.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Wenn die Variable, die geschrieben wird, ein beliebiger anderer Typ der Variablen ist (keine Zeichenfolge mit variabler Länge oder ein Objekt), werden `FilePut` nur die Variablen Daten schreiben. Die von der `RecordLength`-Klausel in der `FileOpen`-Funktion angegebene Daten Satz Länge muss größer oder gleich der Länge der geschriebenen Daten sein.  
  
-   `FilePut` schreibt Elemente von Strukturen so, als wären Sie einzeln geschrieben worden, mit dem Unterschied, dass keine Auffüll Zeichen zwischen Elementen vorhanden sind. Das `VBFixedString`-Attribut kann auf Zeichen folgen Felder in den Strukturen angewendet werden, um die Größe der Zeichenfolge beim Schreiben auf den Datenträger anzugeben.  
  
    > [!NOTE]
    >  Zeichen folgen Felder, die mehr Bytes aufweisen, als durch das `VBFixedString`-Attribut angegeben werden, werden beim Schreiben auf den Datenträger abgeschnitten.  
  
## <a name="binary-mode"></a>Binärmodus  
 Bei Dateien, die im `Binary` Modus geöffnet wurden, gelten die meisten `Random` Modusregeln mit einigen Ausnahmen. Die folgenden Regeln für Dateien, die im `Binary` Modus geöffnet werden, unterscheiden sich von den Regeln für `Random`-Modus:  
  
-   Die `RecordLength`-Klausel in der `FileOpen`-Funktion hat keine Auswirkungen. `FilePut` alle Variablen zusammenhängend auf den Datenträger schreibt, d. h. ohne Auffüll Zeichen zwischen Datensätzen.  
  
-   Für ein beliebiges Array, das kein Array in einer Struktur ist, schreibt `FilePut` nur die Daten. Es wurde kein Deskriptor geschrieben.  
  
-   `FilePut` schreibt Zeichen folgen variabler Länge, die keine Elemente von Strukturen sind, ohne den zwei Byte langen Längen Deskriptor. Die Anzahl der geschriebenen Bytes ist mit der Anzahl der Zeichen in der Zeichenfolge. Beispielsweise schreiben die folgenden Anweisungen 11 Bytes in die Dateinummer 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Zum Schreiben in eine Datei mit der `FilePut`-Funktion ist `Write` Zugriff von der <xref:System.Security.Permissions.FileIOPermissionAccess>-Enumeration erforderlich.  
  
   
  
## Examples  
 In diesem Beispiel wird die `FilePut`-Funktion verwendet, um Daten in eine Datei zu schreiben. Fünf Datensätze der Struktur `Person` werden in die Datei geschrieben.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</exception>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files">Schreiben in Dateien in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, long Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FilePut(int32 FileNumber, int64 Value, int64 RecordNumber) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Long, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * int64 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int64 Value, int64 RecordNumber) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="Value">Erforderlich. Gültiger Variablenname, der auf den Datenträger geschriebene Daten enthält.</param>
        <param name="RecordNumber">Optional. Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), an der der Schreibvorgang beginnt.</param>
        <summary>Schreibt Daten aus einer Variablen in eine Datei auf einem Datenträger. Die <see langword="My" />-Funktion bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FilePut" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` ist nur im `Random`-und `Binary` Modus gültig.  
  
 Mit `FilePut` geschriebene Daten werden in der Regel mit `FileGet` aus einer Datei gelesen.  
  
 Der erste Datensatz oder das Byte in einer Datei befindet sich an Position 1, der zweite Datensatz bzw. das zweite Byte befindet sich an Position 2 usw. Wenn Sie `RecordNumber`weglassen, wird der nächste Datensatz oder das nächste Byte nach dem letzten `FileGet` oder der `FilePut` Funktion geschrieben, oder es wird auf die letzte `Seek` Funktion verwiesen.  
  
 Das `StringIsFixedLength`-Argument steuert, ob die Funktion Zeichen folgen als Variable oder eine Länge mit fester Länge interpretiert. `FilePut` schreibt den Längen Deskriptor nicht, wenn das Argument `True`ist. Wenn Sie `StringIsFixedLength` = `True` mit `FilePut`verwenden, müssen Sie mit `FileGet`identisch Vorgehen, und Sie müssen sicherstellen, dass die Zeichenfolge mit der erwarteten Länge initialisiert wird.  
  
## <a name="random-mode"></a>Zufälliger Modus  
 Für Dateien, die im `Random` Modus geöffnet werden, gelten die folgenden Regeln:  
  
-   Wenn die Länge der geschriebenen Daten kleiner ist als die Länge, die in der `RecordLength`-Klausel der `FileOpen`-Funktion angegeben ist, schreibt `FilePut` nachfolgende Datensätze an Grenzen der Daten Satz Länge. Der Leerraum zwischen dem Ende eines Datensatzes und dem Anfang des nächsten Datensatzes wird mit dem vorhandenen Inhalt des Datei Puffers aufgefüllt. Da die Menge der Auffüll Daten nicht mit Sicherheit bestimmt werden kann, empfiehlt es sich im Allgemeinen, die Daten Satz Länge mit der Länge der geschriebenen Daten zu vergleichen. Wenn die Länge der geschriebenen Daten größer ist als die Länge, die in der `RecordLength`-Klausel der `FileOpen`-Funktion angegeben ist, wird eine Ausnahme ausgelöst.  
  
-   Wenn die Variable, die geschrieben wird, eine Zeichenfolge ist, schreibt `FilePut` einen 2-Byte-Deskriptor, der die Zeichen folgen Länge enthält, und schreibt dann die Daten, die in die Variable aufgenommen werden. Daher muss die von der `RecordLength`-Klausel in der `FileOpen`-Funktion angegebene Daten Satz Länge mindestens zwei Bytes aufweisen, die größer als die tatsächliche Länge der Zeichenfolge ist.  
  
-   Wenn die Variable, die geschrieben wird, ein Objekt ist, das einen numerischen Typ enthält, `FilePut` schreibt zwei Bytes, die die `VarType` des Objekts identifizieren, und schreibt dann die Variable. Wenn Sie z. b. ein Objekt schreiben, das eine ganze Zahl enthält, werden `FilePut` sechs Bytes schreiben: zwei Bytes, die das Objekt als `VarType(3)` (`Integer`) und vier Bytes, die die Daten enthalten, identifizieren. Die vom `RecordLength`-Parameter in der `FileOpen`-Funktion angegebene Daten Satz Länge muss mindestens zwei Byte betragen, die größer ist als die tatsächliche Anzahl von Bytes, die zum Speichern der Variablen erforderlich sind.  
  
-   Wenn die Variable, die geschrieben wird, ein Objekt ist, das eine Zeichenfolge enthält, schreibt `FilePut` einen zwei-Byte-Deskriptor, der die `VarType(8)` des Objekts identifiziert, einen 2-Byte-Deskriptor, der die Länge der Zeichenfolge angibt, und schreibt dann die Zeichen folgen Daten. Die vom `RecordLength`-Parameter in der `FileOpen`-Funktion angegebene Daten Satz Länge muss mindestens vier Byte betragen, die größer als die tatsächliche Länge der Zeichenfolge ist. Wenn Sie eine Zeichenfolge ohne den Deskriptor platzieren möchten, sollten Sie `True` an den `StringIsFixedLength`-Parameter übergeben, und die Zeichenfolge, in die Sie eingelesen haben, sollte die richtige Länge aufweisen.  
  
-   Wenn die Variable, die geschrieben wird, ein Array ist, können Sie entscheiden, ob ein Deskriptor für die Größe und die Dimensionen des Arrays geschrieben werden soll. In Visual Basic 6,0 und früheren Versionen wird der Dateideskriptor für ein dynamisches Array geschrieben, jedoch nicht für ein Array mit fester Größe. Visual Basic 2005 wird der Deskriptor standardmäßig nicht geschrieben. Legen Sie zum Schreiben des Deskriptors den `ArrayIsDynamic`-Parameter auf `True`fest. Beim Schreiben des Arrays müssen Sie der Art und Weise entsprechen, in der das Array gelesen wird. Wenn Sie mit dem Deskriptor gelesen wird, müssen Sie den Deskriptor schreiben. Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang an. Die Länge ist 2 plus das 8-fache der Anzahl der Dimensionen: (2 + 8 * anzahldimensionen). Die von der `RecordLength`-Klausel in der `FileOpen`-Funktion angegebene Daten Satz Länge muss größer oder gleich der Summe aller Bytes sein, die zum Schreiben der Array Daten und des Array Deskriptors erforderlich sind. Die folgende Array Deklaration benötigt z. b. 218 bytes, wenn das Array auf den Datenträger geschrieben wird.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Wenn die Variable, die geschrieben wird, ein beliebiger anderer Typ der Variablen ist (keine Zeichenfolge mit variabler Länge oder ein Objekt), werden `FilePut` nur die Variablen Daten schreiben. Die von der `RecordLength`-Klausel in der `FileOpen`-Funktion angegebene Daten Satz Länge muss größer oder gleich der Länge der geschriebenen Daten sein.  
  
-   `FilePut` schreibt Elemente von Strukturen so, als wären Sie einzeln geschrieben worden, mit dem Unterschied, dass keine Auffüll Zeichen zwischen Elementen vorhanden sind. Das `VBFixedString`-Attribut kann auf Zeichen folgen Felder in den Strukturen angewendet werden, um die Größe der Zeichenfolge beim Schreiben auf den Datenträger anzugeben.  
  
    > [!NOTE]
    >  Zeichen folgen Felder, die mehr Bytes aufweisen, als durch das `VBFixedString`-Attribut angegeben werden, werden beim Schreiben auf den Datenträger abgeschnitten.  
  
## <a name="binary-mode"></a>Binärmodus  
 Bei Dateien, die im `Binary` Modus geöffnet wurden, gelten die meisten `Random` Modusregeln mit einigen Ausnahmen. Die folgenden Regeln für Dateien, die im `Binary` Modus geöffnet werden, unterscheiden sich von den Regeln für `Random`-Modus:  
  
-   Die `RecordLength`-Klausel in der `FileOpen`-Funktion hat keine Auswirkungen. `FilePut` alle Variablen zusammenhängend auf den Datenträger schreibt, d. h. ohne Auffüll Zeichen zwischen Datensätzen.  
  
-   Für ein beliebiges Array, das kein Array in einer Struktur ist, schreibt `FilePut` nur die Daten. Es wurde kein Deskriptor geschrieben.  
  
-   `FilePut` schreibt Zeichen folgen variabler Länge, die keine Elemente von Strukturen sind, ohne den zwei Byte langen Längen Deskriptor. Die Anzahl der geschriebenen Bytes ist mit der Anzahl der Zeichen in der Zeichenfolge. Beispielsweise schreiben die folgenden Anweisungen 11 Bytes in die Dateinummer 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Zum Schreiben in eine Datei mit der `FilePut`-Funktion ist `Write` Zugriff von der <xref:System.Security.Permissions.FileIOPermissionAccess>-Enumeration erforderlich.  
  
   
  
## Examples  
 In diesem Beispiel wird die `FilePut`-Funktion verwendet, um Daten in eine Datei zu schreiben. Fünf Datensätze der Struktur `Person` werden in die Datei geschrieben.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</exception>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files">Schreiben in Dateien in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, float Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FilePut(int32 FileNumber, float32 Value, int64 RecordNumber) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Single, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * single * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, float32 Value, int64 RecordNumber) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="Value">Erforderlich. Gültiger Variablenname, der auf den Datenträger geschriebene Daten enthält.</param>
        <param name="RecordNumber">Optional. Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), an der der Schreibvorgang beginnt.</param>
        <summary>Schreibt Daten aus einer Variablen in eine Datei auf einem Datenträger. Die <see langword="My" />-Funktion bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FilePut" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` ist nur im `Random`-und `Binary` Modus gültig.  
  
 Mit `FilePut` geschriebene Daten werden in der Regel mit `FileGet` aus einer Datei gelesen.  
  
 Der erste Datensatz oder das Byte in einer Datei befindet sich an Position 1, der zweite Datensatz bzw. das zweite Byte befindet sich an Position 2 usw. Wenn Sie `RecordNumber`weglassen, wird der nächste Datensatz oder das nächste Byte nach dem letzten `FileGet` oder der `FilePut` Funktion geschrieben, oder es wird auf die letzte `Seek` Funktion verwiesen.  
  
 Das `StringIsFixedLength`-Argument steuert, ob die Funktion Zeichen folgen als Variable oder eine Länge mit fester Länge interpretiert. `FilePut` schreibt den Längen Deskriptor nicht, wenn das Argument `True`ist. Wenn Sie `StringIsFixedLength` = `True` mit `FilePut`verwenden, müssen Sie mit `FileGet`identisch Vorgehen, und Sie müssen sicherstellen, dass die Zeichenfolge mit der erwarteten Länge initialisiert wird.  
  
## <a name="random-mode"></a>Zufälliger Modus  
 Für Dateien, die im `Random` Modus geöffnet werden, gelten die folgenden Regeln:  
  
-   Wenn die Länge der geschriebenen Daten kleiner ist als die Länge, die in der `RecordLength`-Klausel der `FileOpen`-Funktion angegeben ist, schreibt `FilePut` nachfolgende Datensätze an Grenzen der Daten Satz Länge. Der Leerraum zwischen dem Ende eines Datensatzes und dem Anfang des nächsten Datensatzes wird mit dem vorhandenen Inhalt des Datei Puffers aufgefüllt. Da die Menge der Auffüll Daten nicht mit Sicherheit bestimmt werden kann, empfiehlt es sich im Allgemeinen, die Daten Satz Länge mit der Länge der geschriebenen Daten zu vergleichen. Wenn die Länge der geschriebenen Daten größer ist als die Länge, die in der `RecordLength`-Klausel der `FileOpen`-Funktion angegeben ist, wird eine Ausnahme ausgelöst.  
  
-   Wenn die Variable, die geschrieben wird, eine Zeichenfolge ist, schreibt `FilePut` einen 2-Byte-Deskriptor, der die Zeichen folgen Länge enthält, und schreibt dann die Daten, die in die Variable aufgenommen werden. Daher muss die von der `RecordLength`-Klausel in der `FileOpen`-Funktion angegebene Daten Satz Länge mindestens zwei Bytes aufweisen, die größer als die tatsächliche Länge der Zeichenfolge ist.  
  
-   Wenn die Variable, die geschrieben wird, ein Objekt ist, das einen numerischen Typ enthält, `FilePut` schreibt zwei Bytes, die die `VarType` des Objekts identifizieren, und schreibt dann die Variable. Wenn Sie z. b. ein Objekt schreiben, das eine ganze Zahl enthält, werden `FilePut` sechs Bytes schreiben: zwei Bytes, die das Objekt als `VarType(3)` (`Integer`) und vier Bytes, die die Daten enthalten, identifizieren. Die vom `RecordLength`-Parameter in der `FileOpen`-Funktion angegebene Daten Satz Länge muss mindestens zwei Byte betragen, die größer ist als die tatsächliche Anzahl von Bytes, die zum Speichern der Variablen erforderlich sind.  
  
-   Wenn die Variable, die geschrieben wird, ein Objekt ist, das eine Zeichenfolge enthält, schreibt `FilePut` einen zwei-Byte-Deskriptor, der die `VarType(8)` des Objekts identifiziert, einen 2-Byte-Deskriptor, der die Länge der Zeichenfolge angibt, und schreibt dann die Zeichen folgen Daten. Die vom `RecordLength`-Parameter in der `FileOpen`-Funktion angegebene Daten Satz Länge muss mindestens vier Byte betragen, die größer als die tatsächliche Länge der Zeichenfolge ist. Wenn Sie eine Zeichenfolge ohne den Deskriptor platzieren möchten, sollten Sie `True` an den `StringIsFixedLength`-Parameter übergeben, und die Zeichenfolge, in die Sie eingelesen haben, sollte die richtige Länge aufweisen.  
  
-   Wenn die Variable, die geschrieben wird, ein Array ist, können Sie entscheiden, ob ein Deskriptor für die Größe und die Dimensionen des Arrays geschrieben werden soll. In Visual Basic 6,0 und früheren Versionen wird der Dateideskriptor für ein dynamisches Array geschrieben, jedoch nicht für ein Array mit fester Größe. Visual Basic 2005 wird der Deskriptor standardmäßig nicht geschrieben. Legen Sie zum Schreiben des Deskriptors den `ArrayIsDynamic`-Parameter auf `True`fest. Beim Schreiben des Arrays müssen Sie der Art und Weise entsprechen, in der das Array gelesen wird. Wenn Sie mit dem Deskriptor gelesen wird, müssen Sie den Deskriptor schreiben. Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang an. Die Länge ist 2 plus das 8-fache der Anzahl der Dimensionen: (2 + 8 * anzahldimensionen). Die von der `RecordLength`-Klausel in der `FileOpen`-Funktion angegebene Daten Satz Länge muss größer oder gleich der Summe aller Bytes sein, die zum Schreiben der Array Daten und des Array Deskriptors erforderlich sind. Die folgende Array Deklaration benötigt z. b. 218 bytes, wenn das Array auf den Datenträger geschrieben wird.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Wenn die Variable, die geschrieben wird, ein beliebiger anderer Typ der Variablen ist (keine Zeichenfolge mit variabler Länge oder ein Objekt), werden `FilePut` nur die Variablen Daten schreiben. Die von der `RecordLength`-Klausel in der `FileOpen`-Funktion angegebene Daten Satz Länge muss größer oder gleich der Länge der geschriebenen Daten sein.  
  
-   `FilePut` schreibt Elemente von Strukturen so, als wären Sie einzeln geschrieben worden, mit dem Unterschied, dass keine Auffüll Zeichen zwischen Elementen vorhanden sind. Das `VBFixedString`-Attribut kann auf Zeichen folgen Felder in den Strukturen angewendet werden, um die Größe der Zeichenfolge beim Schreiben auf den Datenträger anzugeben.  
  
    > [!NOTE]
    >  Zeichen folgen Felder, die mehr Bytes aufweisen, als durch das `VBFixedString`-Attribut angegeben werden, werden beim Schreiben auf den Datenträger abgeschnitten.  
  
## <a name="binary-mode"></a>Binärmodus  
 Bei Dateien, die im `Binary` Modus geöffnet wurden, gelten die meisten `Random` Modusregeln mit einigen Ausnahmen. Die folgenden Regeln für Dateien, die im `Binary` Modus geöffnet werden, unterscheiden sich von den Regeln für `Random`-Modus:  
  
-   Die `RecordLength`-Klausel in der `FileOpen`-Funktion hat keine Auswirkungen. `FilePut` alle Variablen zusammenhängend auf den Datenträger schreibt, d. h. ohne Auffüll Zeichen zwischen Datensätzen.  
  
-   Für ein beliebiges Array, das kein Array in einer Struktur ist, schreibt `FilePut` nur die Daten. Es wurde kein Deskriptor geschrieben.  
  
-   `FilePut` schreibt Zeichen folgen variabler Länge, die keine Elemente von Strukturen sind, ohne den zwei Byte langen Längen Deskriptor. Die Anzahl der geschriebenen Bytes ist mit der Anzahl der Zeichen in der Zeichenfolge. Beispielsweise schreiben die folgenden Anweisungen 11 Bytes in die Dateinummer 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Zum Schreiben in eine Datei mit der `FilePut`-Funktion ist `Write` Zugriff von der <xref:System.Security.Permissions.FileIOPermissionAccess>-Enumeration erforderlich.  
  
   
  
## Examples  
 In diesem Beispiel wird die `FilePut`-Funktion verwendet, um Daten in eine Datei zu schreiben. Fünf Datensätze der Struktur `Person` werden in die Datei geschrieben.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</exception>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files">Schreiben in Dateien in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, ValueType Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FilePut(int32 FileNumber, class System.ValueType Value, int64 RecordNumber) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As ValueType, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * ValueType * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, class System.ValueType Value, int64 RecordNumber) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.ValueType" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="Value">Erforderlich. Gültiger Variablenname, der auf den Datenträger geschriebene Daten enthält.</param>
        <param name="RecordNumber">Optional. Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), an der der Schreibvorgang beginnt.</param>
        <summary>Schreibt Daten aus einer Variablen in eine Datei auf einem Datenträger. Die <see langword="My" />-Funktion bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FilePut" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` ist nur im `Random`-und `Binary` Modus gültig.  
  
 Mit `FilePut` geschriebene Daten werden in der Regel mit `FileGet` aus einer Datei gelesen.  
  
 Der erste Datensatz oder das Byte in einer Datei befindet sich an Position 1, der zweite Datensatz bzw. das zweite Byte befindet sich an Position 2 usw. Wenn Sie `RecordNumber`weglassen, wird der nächste Datensatz oder das nächste Byte nach dem letzten `FileGet` oder der `FilePut` Funktion geschrieben, oder es wird auf die letzte `Seek` Funktion verwiesen.  
  
 Das `StringIsFixedLength`-Argument steuert, ob die Funktion Zeichen folgen als Variable oder eine Länge mit fester Länge interpretiert. `FilePut` schreibt den Längen Deskriptor nicht, wenn das Argument `True`ist. Wenn Sie `StringIsFixedLength` = `True` mit `FilePut`verwenden, müssen Sie mit `FileGet`identisch Vorgehen, und Sie müssen sicherstellen, dass die Zeichenfolge mit der erwarteten Länge initialisiert wird.  
  
## <a name="random-mode"></a>Zufälliger Modus  
 Für Dateien, die im `Random` Modus geöffnet werden, gelten die folgenden Regeln:  
  
-   Wenn die Länge der geschriebenen Daten kleiner ist als die Länge, die in der`RecordLength`-Klausel der `FileOpen`-Funktion angegeben ist, schreibt `FilePut` nachfolgende Datensätze an Grenzen der Daten Satz Länge. Der Leerraum zwischen dem Ende eines Datensatzes und dem Anfang des nächsten Datensatzes wird mit dem vorhandenen Inhalt des Datei Puffers aufgefüllt. Da die Menge der Auffüll Daten nicht mit Sicherheit bestimmt werden kann, empfiehlt es sich im Allgemeinen, die Daten Satz Länge mit der Länge der geschriebenen Daten zu vergleichen. Wenn die Länge der geschriebenen Daten größer ist als die Länge, die in der `RecordLength`-Klausel der `FileOpen`-Funktion angegeben ist, wird eine Ausnahme ausgelöst.  
  
-   Wenn die Variable, die geschrieben wird, eine Zeichenfolge ist, schreibt `FilePut` einen 2-Byte-Deskriptor, der die Zeichen folgen Länge enthält, und schreibt dann die Daten, die in die Variable aufgenommen werden. Daher muss die von der `RecordLength`-Klausel in der `FileOpen`-Funktion angegebene Daten Satz Länge mindestens zwei Bytes aufweisen, die größer als die tatsächliche Länge der Zeichenfolge ist.  
  
-   Wenn die Variable, die geschrieben wird, ein Objekt ist, das einen numerischen Typ enthält, `FilePut` schreibt zwei Bytes, die die `VarType` des Objekts identifizieren, und schreibt dann die Variable. Wenn Sie z. b. ein Objekt schreiben, das eine ganze Zahl enthält, werden `FilePut` sechs Bytes schreiben: zwei Bytes, die das Objekt als `VarType(3)` (`Integer`) und vier Bytes, die die Daten enthalten, identifizieren. Die vom `RecordLength`-Parameter in der `FileOpen`-Funktion angegebene Daten Satz Länge muss mindestens zwei Byte betragen, die größer ist als die tatsächliche Anzahl von Bytes, die zum Speichern der Variablen erforderlich sind.  
  
-   Wenn die Variable, die geschrieben wird, ein Objekt ist, das eine Zeichenfolge enthält, schreibt `FilePut` einen zwei-Byte-Deskriptor, der die `VarType(8)` des Objekts identifiziert, einen 2-Byte-Deskriptor, der die Länge der Zeichenfolge angibt, und schreibt dann die Zeichen folgen Daten. Die vom `RecordLength`-Parameter in der `FileOpen`-Funktion angegebene Daten Satz Länge muss mindestens vier Byte betragen, die größer als die tatsächliche Länge der Zeichenfolge ist. Wenn Sie eine Zeichenfolge ohne den Deskriptor platzieren möchten, sollten Sie `True` an den `StringIsFixedLength`-Parameter übergeben, und die Zeichenfolge, in die Sie eingelesen haben, sollte die richtige Länge aufweisen.  
  
-   Wenn die Variable, die geschrieben wird, ein Array ist, können Sie entscheiden, ob ein Deskriptor für die Größe und die Dimensionen des Arrays geschrieben werden soll. In Visual Basic 6,0 und früheren Versionen wird der Dateideskriptor für ein dynamisches Array geschrieben, jedoch nicht für ein Array mit fester Größe. Visual Basic 2005 wird der Deskriptor standardmäßig nicht geschrieben. Legen Sie zum Schreiben des Deskriptors den `ArrayIsDynamic`-Parameter auf `True`fest. Beim Schreiben des Arrays müssen Sie der Art und Weise entsprechen, in der das Array gelesen wird. Wenn Sie mit dem Deskriptor gelesen wird, müssen Sie den Deskriptor schreiben. Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang an. Die Länge ist 2 plus das 8-fache der Anzahl der Dimensionen: (2 + 8 * anzahldimensionen). Die von der `RecordLength`-Klausel in der `FileOpen`-Funktion angegebene Daten Satz Länge muss größer oder gleich der Summe aller Bytes sein, die zum Schreiben der Array Daten und des Array Deskriptors erforderlich sind. Die folgende Array Deklaration benötigt z. b. 218 bytes, wenn das Array auf den Datenträger geschrieben wird.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Wenn die Variable, die geschrieben wird, ein beliebiger anderer Typ der Variablen ist (keine Zeichenfolge mit variabler Länge oder ein Objekt), werden `FilePut` nur die Variablen Daten schreiben. Die von der `RecordLength`-Klausel in der `FileOpen`-Funktion angegebene Daten Satz Länge muss größer oder gleich der Länge der geschriebenen Daten sein.  
  
-   `FilePut` schreibt Elemente von Strukturen so, als wären Sie einzeln geschrieben worden, mit dem Unterschied, dass keine Auffüll Zeichen zwischen Elementen vorhanden sind. Das `VBFixedString`-Attribut kann auf Zeichen folgen Felder in den Strukturen angewendet werden, um die Größe der Zeichenfolge beim Schreiben auf den Datenträger anzugeben.  
  
    > [!NOTE]
    >  Zeichen folgen Felder, die mehr Bytes aufweisen, als durch das `VBFixedString`-Attribut angegeben werden, werden beim Schreiben auf den Datenträger abgeschnitten.  
  
## <a name="binary-mode"></a>Binärmodus  
 Bei Dateien, die im `Binary` Modus geöffnet wurden, gelten die meisten `Random` Modusregeln mit einigen Ausnahmen. Die folgenden Regeln für Dateien, die im `Binary` Modus geöffnet werden, unterscheiden sich von den Regeln für `Random`-Modus:  
  
-   Die `RecordLength`-Klausel in der `FileOpen`-Funktion hat keine Auswirkungen. `FilePut` alle Variablen zusammenhängend auf den Datenträger schreibt, d. h. ohne Auffüll Zeichen zwischen Datensätzen.  
  
-   Für ein beliebiges Array, das kein Array in einer Struktur ist, schreibt `FilePut` nur die Daten. Es wurde kein Deskriptor geschrieben.  
  
-   `FilePut` schreibt Zeichen folgen variabler Länge, die keine Elemente von Strukturen sind, ohne den zwei Byte langen Längen Deskriptor. Die Anzahl der geschriebenen Bytes ist mit der Anzahl der Zeichen in der Zeichenfolge. Beispielsweise schreiben die folgenden Anweisungen 11 Bytes in die Dateinummer 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Zum Schreiben in eine Datei mit der `FilePut`-Funktion ist `Write` Zugriff von der <xref:System.Security.Permissions.FileIOPermissionAccess>-Enumeration erforderlich.  
  
   
  
## Examples  
 In diesem Beispiel wird die `FilePut`-Funktion verwendet, um Daten in eine Datei zu schreiben. Fünf Datensätze der Struktur `Person` werden in die Datei geschrieben.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</exception>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files">Schreiben in Dateien in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (object FileNumber, object Value, object RecordNumber);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FilePut(object FileNumber, object Value, object RecordNumber) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Object, Value As Object, RecordNumber As Object)" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FilePut(System::Object ^ FileNumber, System::Object ^ Value, System::Object ^ RecordNumber);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="F#" Value="static member FilePut : obj * obj * obj -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberSignature Language="C#" Value="public static void FilePut (object FileNumber, object Value, object RecordNumber = -1);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Object, Value As Object, Optional RecordNumber As Object = -1)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(object FileNumber, object Value, object RecordNumber) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Obsolete("Use FilePutObject to write Object types, or coerce FileNumber and RecordNumber to Integer for writing non-Object types")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.1;net-5.0">
          <AttributeName>System.Obsolete("This member has been deprecated. Please use FilePutObject to write Object types, or coerce FileNumber and RecordNumber to Integer for writing non-Object types. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Object" />
        <Parameter Name="Value" Type="System.Object" />
        <Parameter Name="RecordNumber" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="Value">Erforderlich. Gültiger Variablenname, der auf den Datenträger geschriebene Daten enthält.</param>
        <param name="RecordNumber">Optional. Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), an der der Schreibvorgang beginnt.</param>
        <summary>Schreibt Daten aus einer Variablen in eine Datei auf einem Datenträger. Die <see langword="My" />-Funktion bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FilePut" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` ist nur im `Random`-und `Binary` Modus gültig.  
  
 Mit `FilePut` geschriebene Daten werden in der Regel mit `FileGet` aus einer Datei gelesen.  
  
 Der erste Datensatz oder das Byte in einer Datei befindet sich an Position 1, der zweite Datensatz bzw. das zweite Byte befindet sich an Position 2 usw. Wenn Sie `RecordNumber`weglassen, wird der nächste Datensatz oder das nächste Byte nach dem letzten `FileGet` oder der `FilePut` Funktion geschrieben, oder es wird auf die letzte `Seek` Funktion verwiesen.  
  
 Das `StringIsFixedLength`-Argument steuert, ob die Funktion Zeichen folgen als Variable oder eine Länge mit fester Länge interpretiert. `FilePut` schreibt den Längen Deskriptor nicht, wenn das Argument `True`ist. Wenn Sie `StringIsFixedLength` = `True` mit `FilePut`verwenden, müssen Sie mit `FileGet`identisch Vorgehen, und Sie müssen sicherstellen, dass die Zeichenfolge mit der erwarteten Länge initialisiert wird.  
  
## <a name="random-mode"></a>Zufälliger Modus  
 Für Dateien, die im `Random` Modus geöffnet werden, gelten die folgenden Regeln:  
  
-   Wenn die Länge der geschriebenen Daten kleiner ist als die Länge, die in der `RecordLength`-Klausel der `FileOpen`-Funktion angegeben ist, schreibt `FilePut` nachfolgende Datensätze an Grenzen der Daten Satz Länge. Der Leerraum zwischen dem Ende eines Datensatzes und dem Anfang des nächsten Datensatzes wird mit dem vorhandenen Inhalt des Datei Puffers aufgefüllt. Da die Menge der Auffüll Daten nicht mit Sicherheit bestimmt werden kann, empfiehlt es sich im Allgemeinen, die Daten Satz Länge mit der Länge der geschriebenen Daten zu vergleichen. Wenn die Länge der geschriebenen Daten größer ist als die Länge, die in der `RecordLength`-Klausel der `FileOpen`-Funktion angegeben ist, wird eine Ausnahme ausgelöst.  
  
-   Wenn die Variable, die geschrieben wird, eine Zeichenfolge ist, schreibt `FilePut` einen 2-Byte-Deskriptor, der die Zeichen folgen Länge enthält, und schreibt dann die Daten, die in die Variable aufgenommen werden. Daher muss die von der `RecordLength`-Klausel in der `FileOpen`-Funktion angegebene Daten Satz Länge mindestens zwei Bytes aufweisen, die größer als die tatsächliche Länge der Zeichenfolge ist.  
  
-   Wenn die Variable, die geschrieben wird, ein Objekt ist, das einen numerischen Typ enthält, `FilePut` schreibt zwei Bytes, die die `VarType` des Objekts identifizieren, und schreibt dann die Variable. Wenn Sie z. b. ein Objekt schreiben, das eine ganze Zahl enthält, werden `FilePut` sechs Bytes schreiben: zwei Bytes, die das Objekt als `VarType(3)` (`Integer`) und vier Bytes, die die Daten enthalten, identifizieren. Die vom `RecordLength`-Parameter in der `FileOpen`-Funktion angegebene Daten Satz Länge muss mindestens zwei Byte betragen, die größer ist als die tatsächliche Anzahl von Bytes, die zum Speichern der Variablen erforderlich sind.  
  
-   Wenn die Variable, die geschrieben wird, ein Objekt ist, das eine Zeichenfolge enthält, schreibt `FilePut` einen zwei-Byte-Deskriptor, der die `VarType(8)` des Objekts identifiziert, einen 2-Byte-Deskriptor, der die Länge der Zeichenfolge angibt, und schreibt dann die Zeichen folgen Daten. Die vom `RecordLength`-Parameter in der `FileOpen`-Funktion angegebene Daten Satz Länge muss mindestens vier Byte betragen, die größer als die tatsächliche Länge der Zeichenfolge ist. Wenn Sie eine Zeichenfolge ohne den Deskriptor platzieren möchten, sollten Sie `True` an den `StringIsFixedLength`-Parameter übergeben, und die Zeichenfolge, in die Sie eingelesen haben, sollte die richtige Länge aufweisen.  
  
-   Wenn die Variable, die geschrieben wird, ein Array ist, können Sie entscheiden, ob ein Deskriptor für die Größe und die Dimensionen des Arrays geschrieben werden soll. In Visual Basic 6,0 und früheren Versionen wird der Dateideskriptor für ein dynamisches Array geschrieben, jedoch nicht für ein Array mit fester Größe. Visual Basic 2005 wird der Deskriptor standardmäßig nicht geschrieben. Legen Sie zum Schreiben des Deskriptors den `ArrayIsDynamic`-Parameter auf `True`fest. Beim Schreiben des Arrays müssen Sie der Art und Weise entsprechen, in der das Array gelesen wird. Wenn Sie mit dem Deskriptor gelesen wird, müssen Sie den Deskriptor schreiben. Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang an. Die Länge ist 2 plus das 8-fache der Anzahl der Dimensionen: (2 + 8 * anzahldimensionen). Die von der `RecordLength`-Klausel in der `FileOpen`-Funktion angegebene Daten Satz Länge muss größer oder gleich der Summe aller Bytes sein, die zum Schreiben der Array Daten und des Array Deskriptors erforderlich sind. Die folgende Array Deklaration benötigt z. b. 218 bytes, wenn das Array auf den Datenträger geschrieben wird.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Wenn die Variable, die geschrieben wird, ein beliebiger anderer Typ der Variablen ist (keine Zeichenfolge mit variabler Länge oder ein Objekt), werden `FilePut` nur die Variablen Daten schreiben. Die von der `RecordLength`-Klausel in der `FileOpen`-Funktion angegebene Daten Satz Länge muss größer oder gleich der Länge der geschriebenen Daten sein.  
  
-   `FilePut` schreibt Elemente von Strukturen so, als wären Sie einzeln geschrieben worden, mit dem Unterschied, dass keine Auffüll Zeichen zwischen Elementen vorhanden sind. Das `VBFixedString`-Attribut kann auf Zeichen folgen Felder in den Strukturen angewendet werden, um die Größe der Zeichenfolge beim Schreiben auf den Datenträger anzugeben.  
  
    > [!NOTE]
    >  Zeichen folgen Felder, die mehr Bytes aufweisen, als durch das `VBFixedString`-Attribut angegeben werden, werden beim Schreiben auf den Datenträger abgeschnitten.  
  
## <a name="binary-mode"></a>Binärmodus  
 Bei Dateien, die im `Binary` Modus geöffnet wurden, gelten die meisten `Random` Modusregeln mit einigen Ausnahmen. Die folgenden Regeln für Dateien, die im `Binary` Modus geöffnet werden, unterscheiden sich von den Regeln für `Random`-Modus:  
  
-   Die `RecordLength`-Klausel in der `FileOpen`-Funktion hat keine Auswirkungen. `FilePut` alle Variablen zusammenhängend auf den Datenträger schreibt, d. h. ohne Auffüll Zeichen zwischen Datensätzen.  
  
-   Für ein beliebiges Array, das kein Array in einer Struktur ist, schreibt `FilePut` nur die Daten. Es wurde kein Deskriptor geschrieben.  
  
-   `FilePut` schreibt Zeichen folgen variabler Länge, die keine Elemente von Strukturen sind, ohne den zwei Byte langen Längen Deskriptor. Die Anzahl der geschriebenen Bytes ist mit der Anzahl der Zeichen in der Zeichenfolge. Beispielsweise schreiben die folgenden Anweisungen 11 Bytes in die Dateinummer 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Zum Schreiben in eine Datei mit der `FilePut`-Funktion ist `Write` Zugriff von der <xref:System.Security.Permissions.FileIOPermissionAccess>-Enumeration erforderlich.  
  
   
  
## Examples  
 In diesem Beispiel wird die `FilePut`-Funktion verwendet, um Daten in eine Datei zu schreiben. Fünf Datensätze der Struktur `Person` werden in die Datei geschrieben.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</exception>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files">Schreiben in Dateien in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, string Value, long RecordNumber = -1, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FilePut(int32 FileNumber, string Value, int64 RecordNumber, bool StringIsFixedLength) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As String, Optional RecordNumber As Long = -1, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * string * int64 * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber, StringIsFixedLength)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, string Value, int64 RecordNumber, bool StringIsFixedLength) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="Value">Erforderlich. Gültiger Variablenname, der auf den Datenträger geschriebene Daten enthält.</param>
        <param name="RecordNumber">Optional. Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), an der der Schreibvorgang beginnt.</param>
        <param name="StringIsFixedLength">Optional. Betrifft nur das Schreiben einer Zeichenfolge. Gibt an, ob ein 2-Byte-Zeichenfolgenlängendeskriptor in die Datei für die Zeichenfolge geschrieben werden soll. Der Standardwert lautet <see langword="False" />.</param>
        <summary>Schreibt Daten aus einer Variablen in eine Datei auf einem Datenträger. Die <see langword="My" />-Funktion bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FilePut" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` ist nur im `Random`-und `Binary` Modus gültig.  
  
 Mit `FilePut` geschriebene Daten werden in der Regel mit `FileGet` aus einer Datei gelesen.  
  
 Der erste Datensatz oder das Byte in einer Datei befindet sich an Position 1, der zweite Datensatz bzw. das zweite Byte befindet sich an Position 2 usw. Wenn Sie `RecordNumber`weglassen, wird der nächste Datensatz oder das nächste Byte nach dem letzten `FileGet` oder der `FilePut` Funktion geschrieben, oder es wird auf die letzte `Seek` Funktion verwiesen.  
  
 Das `StringIsFixedLength`-Argument steuert, ob die Funktion Zeichen folgen als Variable oder eine Länge mit fester Länge interpretiert. `FilePut` schreibt den Längen Deskriptor nicht, wenn das Argument `True`ist. Wenn Sie `StringIsFixedLength` = `True` mit `FilePut`verwenden, müssen Sie mit `FileGet`identisch Vorgehen, und Sie müssen sicherstellen, dass die Zeichenfolge mit der erwarteten Länge initialisiert wird.  
  
## <a name="random-mode"></a>Zufälliger Modus  
 Für Dateien, die im `Random` Modus geöffnet werden, gelten die folgenden Regeln:  
  
-   Wenn die Länge der geschriebenen Daten kleiner ist als die Länge, die in der `RecordLength`-Klausel der `FileOpen`-Funktion angegeben ist, schreibt `FilePut` nachfolgende Datensätze an Grenzen der Daten Satz Länge. Der Leerraum zwischen dem Ende eines Datensatzes und dem Anfang des nächsten Datensatzes wird mit dem vorhandenen Inhalt des Datei Puffers aufgefüllt. Da die Menge der Auffüll Daten nicht mit Sicherheit bestimmt werden kann, empfiehlt es sich im Allgemeinen, die Daten Satz Länge mit der Länge der geschriebenen Daten zu vergleichen. Wenn die Länge der geschriebenen Daten größer ist als die Länge, die in der `RecordLength`-Klausel der `FileOpen`-Funktion angegeben ist, wird eine Ausnahme ausgelöst.  
  
-   Wenn die Variable, die geschrieben wird, eine Zeichenfolge ist, schreibt `FilePut` einen 2-Byte-Deskriptor, der die Zeichen folgen Länge enthält, und schreibt dann die Daten, die in die Variable aufgenommen werden. Daher muss die von der `RecordLength`-Klausel in der `FileOpen`-Funktion angegebene Daten Satz Länge mindestens zwei Bytes aufweisen, die größer als die tatsächliche Länge der Zeichenfolge ist.  
  
-   Wenn die Variable, die geschrieben wird, ein Objekt ist, das einen numerischen Typ enthält, `FilePut` schreibt zwei Bytes, die die `VarType` des Objekts identifizieren, und schreibt dann die Variable. Wenn Sie z. b. ein Objekt schreiben, das eine ganze Zahl enthält, werden `FilePut` sechs Bytes schreiben: zwei Bytes, die das Objekt als `VarType(3)` (`Integer`) und vier Bytes, die die Daten enthalten, identifizieren. Die vom `RecordLength`-Parameter in der `FileOpen`-Funktion angegebene Daten Satz Länge muss mindestens zwei Byte betragen, die größer ist als die tatsächliche Anzahl von Bytes, die zum Speichern der Variablen erforderlich sind.  
  
-   Wenn die Variable, die geschrieben wird, ein Objekt ist, das eine Zeichenfolge enthält, schreibt `FilePut` einen zwei-Byte-Deskriptor, der die `VarType(8)` des Objekts identifiziert, einen 2-Byte-Deskriptor, der die Länge der Zeichenfolge angibt, und schreibt dann die Zeichen folgen Daten. Die vom `RecordLength`-Parameter in der `FileOpen`-Funktion angegebene Daten Satz Länge muss mindestens vier Byte betragen, die größer als die tatsächliche Länge der Zeichenfolge ist. Wenn Sie eine Zeichenfolge ohne den Deskriptor platzieren möchten, sollten Sie `True` an den `StringIsFixedLength`-Parameter übergeben, und die Zeichenfolge, in die Sie eingelesen haben, sollte die richtige Länge aufweisen.  
  
-   Wenn die Variable, die geschrieben wird, ein Array ist, können Sie entscheiden, ob ein Deskriptor für die Größe und die Dimensionen des Arrays geschrieben werden soll. In Visual Basic 6,0 und früheren Versionen wird der Dateideskriptor für ein dynamisches Array geschrieben, jedoch nicht für ein Array mit fester Größe. Visual Basic 2005 wird der Deskriptor standardmäßig nicht geschrieben. Legen Sie zum Schreiben des Deskriptors den `ArrayIsDynamic`-Parameter auf `True`fest. Beim Schreiben des Arrays müssen Sie der Art und Weise entsprechen, in der das Array gelesen wird. Wenn Sie mit dem Deskriptor gelesen wird, müssen Sie den Deskriptor schreiben. Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang an. Die Länge ist 2 plus das 8-fache der Anzahl der Dimensionen: (2 + 8 * anzahldimensionen). Die von der `RecordLength`-Klausel in der `FileOpen`-Funktion angegebene Daten Satz Länge muss größer oder gleich der Summe aller Bytes sein, die zum Schreiben der Array Daten und des Array Deskriptors erforderlich sind. Die folgende Array Deklaration benötigt z. b. 218 bytes, wenn das Array auf den Datenträger geschrieben wird.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Wenn die Variable, die geschrieben wird, ein beliebiger anderer Typ der Variablen ist (keine Zeichenfolge mit variabler Länge oder ein Objekt), werden `FilePut` nur die Variablen Daten schreiben. Die von der `RecordLength`-Klausel in der `FileOpen`-Funktion angegebene Daten Satz Länge muss größer oder gleich der Länge der geschriebenen Daten sein.  
  
-   `FilePut` schreibt Elemente von Strukturen so, als wären Sie einzeln geschrieben worden, mit dem Unterschied, dass keine Auffüll Zeichen zwischen Elementen vorhanden sind. Das `VBFixedString`-Attribut kann auf Zeichen folgen Felder in den Strukturen angewendet werden, um die Größe der Zeichenfolge beim Schreiben auf den Datenträger anzugeben.  
  
    > [!NOTE]
    >  Zeichen folgen Felder, die mehr Bytes aufweisen, als durch das `VBFixedString`-Attribut angegeben werden, werden beim Schreiben auf den Datenträger abgeschnitten.  
  
## <a name="binary-mode"></a>Binärmodus  
 Bei Dateien, die im `Binary` Modus geöffnet wurden, gelten die meisten `Random` Modusregeln mit einigen Ausnahmen. Die folgenden Regeln für Dateien, die im `Binary` Modus geöffnet werden, unterscheiden sich von den Regeln für `Random`-Modus:  
  
-   Die `RecordLength`-Klausel in der `FileOpen`-Funktion hat keine Auswirkungen. `FilePut` alle Variablen zusammenhängend auf den Datenträger schreibt, d. h. ohne Auffüll Zeichen zwischen Datensätzen.  
  
-   Für ein beliebiges Array, das kein Array in einer Struktur ist, schreibt `FilePut` nur die Daten. Es wurde kein Deskriptor geschrieben.  
  
-   `FilePut` schreibt Zeichen folgen variabler Länge, die keine Elemente von Strukturen sind, ohne den zwei Byte langen Längen Deskriptor. Die Anzahl der geschriebenen Bytes ist mit der Anzahl der Zeichen in der Zeichenfolge. Beispielsweise schreiben die folgenden Anweisungen 11 Bytes in die Dateinummer 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Zum Schreiben in eine Datei mit der `FilePut`-Funktion ist `Write` Zugriff von der <xref:System.Security.Permissions.FileIOPermissionAccess>-Enumeration erforderlich.  
  
   
  
## Examples  
 In diesem Beispiel wird die `FilePut`-Funktion verwendet, um Daten in eine Datei zu schreiben. Fünf Datensätze der Struktur `Person` werden in die Datei geschrieben.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</exception>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files">Schreiben in Dateien in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FilePut(int32 FileNumber, class System.Array Value, int64 RecordNumber, bool ArrayIsDynamic, bool StringIsFixedLength) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Array, Optional RecordNumber As Long = -1, Optional ArrayIsDynamic As Boolean = false, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * Array * int64 * bool * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber, ArrayIsDynamic, StringIsFixedLength)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, class System.Array Value, int64 RecordNumber, bool ArrayIsDynamic, bool StringIsFixedLength) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Array" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="ArrayIsDynamic" Type="System.Boolean" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="Value">Erforderlich. Gültiger Variablenname, der auf den Datenträger geschriebene Daten enthält.</param>
        <param name="RecordNumber">Optional. Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), an der der Schreibvorgang beginnt.</param>
        <param name="ArrayIsDynamic">Optional. Betrifft nur das Schreiben eines Arrays. Gibt an, ob das Array als dynamisches Array behandelt werden soll und ein Arraydeskriptor für die Zeichenfolge erforderlich ist, der die Länge beschreibt.</param>
        <param name="StringIsFixedLength">Optional. Betrifft nur das Schreiben einer Zeichenfolge. Gibt an, ob ein 2-Byte-Zeichenfolgenlängendeskriptor in die Datei für die Zeichenfolge geschrieben werden soll. Der Standardwert lautet <see langword="False" />.</param>
        <summary>Schreibt Daten aus einer Variablen in eine Datei auf einem Datenträger. Die <see langword="My" />-Funktion bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FilePut" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` ist nur im `Random`-und `Binary` Modus gültig.  
  
 Mit `FilePut` geschriebene Daten werden in der Regel mit `FileGet` aus einer Datei gelesen.  
  
 Der erste Datensatz oder das Byte in einer Datei befindet sich an Position 1, der zweite Datensatz bzw. das zweite Byte befindet sich an Position 2 usw. Wenn Sie `RecordNumber`weglassen, wird der nächste Datensatz oder das nächste Byte nach dem letzten `FileGet` oder der `FilePut` Funktion geschrieben, oder es wird auf die letzte `Seek` Funktion verwiesen.  
  
 Das `StringIsFixedLength`-Argument steuert, ob die Funktion Zeichen folgen als Variable oder eine Länge mit fester Länge interpretiert. `FilePut` schreibt den Längen Deskriptor nicht, wenn das Argument `True`ist. Wenn Sie `StringIsFixedLength` = `True` mit `FilePut`verwenden, müssen Sie mit `FileGet`identisch Vorgehen, und Sie müssen sicherstellen, dass die Zeichenfolge mit der erwarteten Länge initialisiert wird.  
  
## <a name="random-mode"></a>Zufälliger Modus  
 Für Dateien, die im `Random` Modus geöffnet werden, gelten die folgenden Regeln:  
  
-   Wenn die Länge der geschriebenen Daten kleiner ist als die Länge, die in der `RecordLength`-Klausel der `FileOpen`-Funktion angegeben ist, schreibt `FilePut` nachfolgende Datensätze an Grenzen der Daten Satz Länge. Der Leerraum zwischen dem Ende eines Datensatzes und dem Anfang des nächsten Datensatzes wird mit dem vorhandenen Inhalt des Datei Puffers aufgefüllt. Da die Menge der Auffüll Daten nicht mit Sicherheit bestimmt werden kann, empfiehlt es sich im Allgemeinen, die Daten Satz Länge mit der Länge der geschriebenen Daten zu vergleichen. Wenn die Länge der geschriebenen Daten größer ist als die Länge, die in der `RecordLength`-Klausel der `FileOpen`-Funktion angegeben ist, wird eine Ausnahme ausgelöst.  
  
-   Wenn die Variable, die geschrieben wird, eine Zeichenfolge ist, schreibt `FilePut` einen 2-Byte-Deskriptor, der die Zeichen folgen Länge enthält, und schreibt dann die Daten, die in die Variable aufgenommen werden. Daher muss die von der `RecordLength`-Klausel in der `FileOpen`-Funktion angegebene Daten Satz Länge mindestens zwei Bytes aufweisen, die größer als die tatsächliche Länge der Zeichenfolge ist.  
  
-   Wenn die Variable, die geschrieben wird, ein Objekt ist, das einen numerischen Typ enthält, `FilePut` schreibt zwei Bytes, die die `VarType` des Objekts identifizieren, und schreibt dann die Variable. Wenn Sie z. b. ein Objekt schreiben, das eine ganze Zahl enthält, werden `FilePut` sechs Bytes schreiben: zwei Bytes, die das Objekt als `VarType(3)` (`Integer`) und vier Bytes, die die Daten enthalten, identifizieren. Die vom `RecordLength`-Parameter in der `FileOpen`-Funktion angegebene Daten Satz Länge muss mindestens zwei Byte betragen, die größer ist als die tatsächliche Anzahl von Bytes, die zum Speichern der Variablen erforderlich sind.  
  
-   Wenn die Variable, die geschrieben wird, ein Objekt ist, das eine Zeichenfolge enthält, schreibt `FilePut` einen zwei-Byte-Deskriptor, der die `VarType(8)` des Objekts identifiziert, einen 2-Byte-Deskriptor, der die Länge der Zeichenfolge angibt, und schreibt dann die Zeichen folgen Daten. Die vom `RecordLength`-Parameter in der `FileOpen`-Funktion angegebene Daten Satz Länge muss mindestens vier Byte betragen, die größer als die tatsächliche Länge der Zeichenfolge ist. Wenn Sie eine Zeichenfolge ohne den Deskriptor platzieren möchten, sollten Sie `True` an den `StringIsFixedLength`-Parameter übergeben, und die Zeichenfolge, in die Sie eingelesen haben, sollte die richtige Länge aufweisen.  
  
-   Wenn die Variable, die geschrieben wird, ein Array ist, können Sie entscheiden, ob ein Deskriptor für die Größe und die Dimensionen des Arrays geschrieben werden soll. In Visual Basic 6,0 und früheren Versionen wird der Dateideskriptor für ein dynamisches Array geschrieben, jedoch nicht für ein Array mit fester Größe. Visual Basic 2005 wird der Deskriptor standardmäßig nicht geschrieben. Legen Sie zum Schreiben des Deskriptors den `ArrayIsDynamic`-Parameter auf `True`fest. Beim Schreiben des Arrays müssen Sie der Art und Weise entsprechen, in der das Array gelesen wird. Wenn Sie mit dem Deskriptor gelesen wird, müssen Sie den Deskriptor schreiben. Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang an. Die Länge ist 2 plus das 8-fache der Anzahl der Dimensionen: (2 + 8 * anzahldimensionen). Die von der `RecordLength`-Klausel in der `FileOpen`-Funktion angegebene Daten Satz Länge muss größer oder gleich der Summe aller Bytes sein, die zum Schreiben der Array Daten und des Array Deskriptors erforderlich sind. Die folgende Array Deklaration benötigt z. b. 218 bytes, wenn das Array auf den Datenträger geschrieben wird.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Wenn die Variable, die geschrieben wird, ein beliebiger anderer Typ der Variablen ist (keine Zeichenfolge mit variabler Länge oder ein Objekt), werden `FilePut` nur die Variablen Daten schreiben. Die von der `RecordLength`-Klausel in der `FileOpen`-Funktion angegebene Daten Satz Länge muss größer oder gleich der Länge der geschriebenen Daten sein.  
  
-   `FilePut` schreibt Elemente von Strukturen so, als wären Sie einzeln geschrieben worden, mit dem Unterschied, dass keine Auffüll Zeichen zwischen Elementen vorhanden sind. Das `VBFixedString`-Attribut kann auf Zeichen folgen Felder in den Strukturen angewendet werden, um die Größe der Zeichenfolge beim Schreiben auf den Datenträger anzugeben.  
  
    > [!NOTE]
    >  Zeichen folgen Felder, die mehr Bytes aufweisen, als durch das `VBFixedString`-Attribut angegeben werden, werden beim Schreiben auf den Datenträger abgeschnitten.  
  
## <a name="binary-mode"></a>Binärmodus  
 Bei Dateien, die im `Binary` Modus geöffnet wurden, gelten die meisten `Random` Modusregeln mit einigen Ausnahmen. Die folgenden Regeln für Dateien, die im `Binary` Modus geöffnet werden, unterscheiden sich von den Regeln für `Random`-Modus:  
  
-   Die `RecordLength`-Klausel in der `FileOpen`-Funktion hat keine Auswirkungen. `FilePut` alle Variablen zusammenhängend auf den Datenträger schreibt, d. h. ohne Auffüll Zeichen zwischen Datensätzen.  
  
-   Für ein beliebiges Array, das kein Array in einer Struktur ist, schreibt `FilePut` nur die Daten. Es wurde kein Deskriptor geschrieben.  
  
-   `FilePut` schreibt Zeichen folgen variabler Länge, die keine Elemente von Strukturen sind, ohne den zwei Byte langen Längen Deskriptor. Die Anzahl der geschriebenen Bytes ist mit der Anzahl der Zeichen in der Zeichenfolge. Beispielsweise schreiben die folgenden Anweisungen 11 Bytes in die Dateinummer 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Zum Schreiben in eine Datei mit der `FilePut`-Funktion ist `Write` Zugriff von der <xref:System.Security.Permissions.FileIOPermissionAccess>-Enumeration erforderlich.  
  
   
  
## Examples  
 In diesem Beispiel wird die `FilePut`-Funktion verwendet, um Daten in eine Datei zu schreiben. Fünf Datensätze der Struktur `Person` werden in die Datei geschrieben.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</exception>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files">Schreiben in Dateien in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePutObject">
      <MemberSignature Language="C#" Value="public static void FilePutObject (int FileNumber, object Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FilePutObject(int32 FileNumber, object Value, int64 RecordNumber) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePutObject (FileNumber As Integer, Value As Object, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePutObject : int * obj * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePutObject (FileNumber, Value, RecordNumber)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePutObject(int32 FileNumber, object Value, int64 RecordNumber) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="Value">Erforderlich. Gültiger Variablenname, der auf den Datenträger geschriebene Daten enthält.</param>
        <param name="RecordNumber">Optional. Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), an der der Schreibvorgang beginnt.</param>
        <summary>Schreibt Daten aus einer Variablen in eine Datei auf einem Datenträger.  Die <see langword="My" />-Funktion bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FilePutObject" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `FilePutObject` Funktion dient anstelle von `FilePut` um Mehrdeutigkeiten zum Zeitpunkt der Kompilierung zu vermeiden, wenn Typ `Object` wird z. B. anstelle eines anderen Typs übergeben `Integer`, `Long`, `Short`usw.  
  
 `FilePutObject` schreiben und liest Deskriptoren, die das-Objekt beschreiben. Wenn Sie beabsichtigen, den `Variant`-Typ zu schreiben, ist `FilePutObject` erforderlich. Wenn Sie im Zweifelsfall ein Objekt für den zweiten Parameter verwenden, empfiehlt es sich, immer `FilePutObject` und `FileGetObject`zu verwenden.  
  
 `FilePutObject` ist nur im `Random`-und `Binary` Modus gültig.  
  
 Mit `FilePutObject` geschriebene Daten werden in der Regel mit `FileGetObject` aus einer Datei gelesen.  
  
 Der erste Datensatz oder das Byte in einer Datei befindet sich an Position 1, der zweite Datensatz bzw. das zweite Byte befindet sich an Position 2 usw. Wenn Sie `RecordNumber`weglassen, schreibt `FilePutObject` den nächsten Datensatz oder das nächste Byte nach dem letzten `FileGetObject` oder `FilePutObject` Funktion (oder dem Datensatz oder Byte, auf den die letzte `Seek` Funktion zeigt).  
  
 Das `StringIsFixedLength`-Argument steuert, ob die Funktion Zeichen folgen als Variable oder eine Länge mit fester Länge interpretiert. `FilePutObject` schreibt den Längen Deskriptor nicht, wenn das Argument `True`ist. Wenn Sie `StringIsFixedLength` = `True` mit `FilePutObject`verwenden, müssen Sie mit `FileGetObject`identisch Vorgehen. Außerdem müssen Sie sicherstellen, dass die Zeichenfolge mit der erwarteten Länge initialisiert wird.  
  
## <a name="random-mode"></a>Zufälliger Modus  
 Für Dateien, die im `Random` Modus geöffnet werden, gelten die folgenden Regeln:  
  
-   Wenn die Länge der geschriebenen Daten kleiner ist als die Länge, die in der `RecordLength`-Klausel der `FileOpen`-Funktion angegeben ist, schreibt `FilePutObject` nachfolgende Datensätze an Grenzen der Daten Satz Länge. Der Leerraum zwischen dem Ende eines Datensatzes und dem Anfang des nächsten Datensatzes wird mit dem vorhandenen Inhalt des Datei Puffers aufgefüllt. Da die Menge der Auffüll Daten nicht genau bestimmt werden kann, empfiehlt es sich im Allgemeinen, die Daten Satz Länge mit der Länge der geschriebenen Daten zu vergleichen. Wenn die Länge der geschriebenen Daten größer ist als die Länge, die in der `RecordLength`-Klausel der `FileOpen`-Funktion angegeben ist, wird eine Ausnahme ausgelöst.  
  
-   Wenn die Variable, die geschrieben wird, ein Objekt ist, das einen numerischen Typ enthält, `FilePutObject` schreibt zwei Bytes, die die `VarType` des Objekts identifizieren, und schreibt dann die Variable. Wenn Sie z. b. ein Objekt schreiben, das eine ganze Zahl enthält, werden `FilePutObject` sechs Bytes schreiben: zwei Bytes, die das Objekt als `VarType(3)` (`Integer`) und vier Bytes, die die Daten enthalten, identifizieren. Die vom `RecordLength`-Parameter in der `FileOpen`-Funktion angegebene Daten Satz Länge muss mindestens zwei Byte betragen, die größer ist als die tatsächliche Anzahl von Bytes, die zum Speichern der Variablen erforderlich sind.  
  
-   Wenn die Variable, die geschrieben wird, ein Objekt ist, das eine Zeichenfolge enthält, schreibt `FilePutObject` einen zwei-Byte-Deskriptor, der die `VarType(8)` des Objekts identifiziert, einen 2-Byte-Deskriptor, der die Länge der Zeichenfolge angibt, und schreibt dann die Zeichen folgen Daten. Die vom `RecordLength`-Parameter in der `FileOpen`-Funktion angegebene Daten Satz Länge muss mindestens vier Byte betragen, die größer als die tatsächliche Länge der Zeichenfolge ist. Wenn Sie eine Zeichenfolge ohne den Deskriptor platzieren möchten, sollten Sie `True` an den `StringIsFixedLength`-Parameter übergeben, und die Zeichenfolge, in die Sie eingelesen haben, sollte die richtige Länge aufweisen.  
  
-   Wenn die Variable, die geschrieben wird, ein Array ist, muss die von der `RecordLength`-Klausel in der `FileOpen`-Funktion angegebene Daten Satz Länge größer oder gleich der Summe aller Bytes sein, die zum Schreiben der Array Daten und des Array Deskriptors erforderlich sind. Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang an. Die Länge ist 2 plus das 8-fache der Anzahl der Dimensionen: (2 + 8 * anzahldimensionen).  
  
## <a name="binary-mode"></a>Binärmodus  
 Für Dateien, die im `Binary` Modus geöffnet wurden, gelten alle Regeln im `Random` Modus, ausgenommen:  
  
-   Die `RecordLength`-Klausel in der `FileOpen`-Funktion hat keine Auswirkungen. `FilePutObject` alle Variablen zusammenhängend auf den Datenträger schreibt, d. h. ohne Auffüll Zeichen zwischen Datensätzen.  
  
   
  
## Examples  
 In diesem Beispiel wird die `FilePutObject`-Funktion verwendet, um eine Zeichenfolge in eine Datei zu schreiben.  
  
 [!code-vb[VbVbalrCatRef#54](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#54)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files">Schreiben in Dateien in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileWidth">
      <MemberSignature Language="C#" Value="public static void FileWidth (int FileNumber, int RecordWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FileWidth(int32 FileNumber, int32 RecordWidth) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileWidth (FileNumber As Integer, RecordWidth As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileWidth(int FileNumber, int RecordWidth);" />
      <MemberSignature Language="F#" Value="static member FileWidth : int * int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileWidth (FileNumber, RecordWidth)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileWidth(int32 FileNumber, int32 RecordWidth) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="RecordWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="RecordWidth">Erforderlich. Ein numerischer Ausdruck im Bereich 0–255 einschließlich, der angibt, wie viele Zeichen auf einer Zeile stehen, bevor eine neue Zeile beginnt. Wenn <paramref name="RecordWidth" /> gleich 0 ist, ist die Länge einer Zeile unbegrenzt. Der Standardwert für <paramref name="RecordWidth" /> ist 0.</param>
        <summary>Weist einer Datei, die mit der <see langword="FileOpen" />-Funktion geöffnet wurde, eine Ausgabezeilenbreite zu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 In diesem Beispiel wird die `FileWidth`-Funktion verwendet, um die Ausgabe Linienbreite für eine Datei festzulegen.  
  
 [!code-vb[VbVbalrCatRef#10](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access">Dateizugriff mit Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FreeFile">
      <MemberSignature Language="C#" Value="public static int FreeFile ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FreeFile() cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FreeFile" />
      <MemberSignature Language="VB.NET" Value="Public Function FreeFile () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int FreeFile();" />
      <MemberSignature Language="F#" Value="static member FreeFile : unit -&gt; int" Usage="Microsoft.VisualBasic.FileSystem.FreeFile " />
      <MemberSignature Language="ILAsm" Value=".method public static int32 FreeFile() cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen <see langword="Integer" />-Wert zurück, der die nächste zur Verwendung durch die <see langword="FileOpen" />-Funktion verfügbare Dateinummer darstellt.</summary>
        <returns>Ein ganzzahliger Wert, der die nächste für die Funktion <see langword="FileOpen" /> verfügbare Dateinummer angibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie `FreeFile`, um eine Dateinummer anzugeben, die nicht bereits verwendet wird.  
  
   
  
## Examples  
 In diesem Beispiel wird die `FreeFile`-Funktion verwendet, um die nächste verfügbare Dateinummer zurückzugeben. Fünf Dateien werden für die Ausgabe innerhalb der Schleife geöffnet, und es werden einige Beispiel Daten in jede Datei geschrieben.  
  
 [!code-vb[VbVbalrCatRef#55](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#55)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Mehr als 255 Dateien verwendet.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files">Schreiben in Dateien in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="GetAttr">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.FileAttribute GetAttr (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.VisualBasic.FileAttribute GetAttr(string PathName) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAttr (PathName As String) As FileAttribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::FileAttribute GetAttr(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member GetAttr : string -&gt; Microsoft.VisualBasic.FileAttribute" Usage="Microsoft.VisualBasic.FileSystem.GetAttr PathName" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.FileAttribute GetAttr(string PathName) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.FileAttribute</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">Erforderlich. Ein Zeichenfolgenausdruck, der einen Datei-, Verzeichnis- oder Ordnernamen angibt. <paramref name="PathName" /> kann auch das Verzeichnis oder den Ordner sowie das Laufwerk beinhalten.</param>
        <summary>Gibt einen <see langword="FileAttribute" />-Wert zurück, der die Attribute einer Datei, eines Verzeichnisses oder eines Ordners darstellt. Die <see langword="My" />-Funktion bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FileAttribute" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <returns>Eine bitweise Kombination der Enumerationswerte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um zu ermitteln, welche Attribute festgelegt sind, verwenden Sie den `And`-Operator, um einen bitweisen Vergleich des Werts auszuführen, der von der `GetAttr`-Funktion zurückgegeben wird, und dem Wert des gewünschten individuellen Datei Attributs. Wenn das Ergebnis nicht 0 (null) ist, wird dieses Attribut für die benannte Datei festgelegt. Der Rückgabewert des folgenden `And` Ausdrucks lautet z. b. 0 (null), wenn das `Archive`-Attribut nicht festgelegt ist:  
  
```vb  
Result = GetAttr(FName) And vbArchive  
```  
  
 Ein Wert ungleich NULL wird zurückgegeben, wenn das `Archive`-Attribut festgelegt ist.  
  
   
  
## Examples  
 In diesem Beispiel wird die `GetAttr`-Funktion verwendet, um die Attribute einer Datei, eines Verzeichnisses oder eines Ordners zu bestimmen.  
  
 [!code-vb[VbVbalrCatRef#25](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><paramref name="Pathname" /> ist ungültig oder enthält Platzhalterzeichen.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Zieldatei ist nicht vorhanden.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
        <related type="Article" href="/dotnet/visual-basic/language-reference/operators/and-operator">And-Operator (Visual Basic)</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access">Dateizugriff mit Visual Basic</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Input">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Liest Daten aus einer geöffneten sequenziellen Datei und weist diese Variablen zu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref bool Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Input(int32 FileNumber, bool&amp; Value) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, bool % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, bool&amp; Value) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="Value">Erforderlich. Eine Variable, der die aus der Datei gelesenen Werte zugewiesen werden, kann kein Array und keine Objektvariable sein.</param>
        <summary>Liest Daten aus einer geöffneten sequenziellen Datei und weist diese Variablen zu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Input` Funktion wird aus Gründen der Abwärtskompatibilität bereitgestellt und kann sich auf die Leistung auswirken. Bei nicht Legacy Anwendungen bietet das `My.Computer.FileSystem`-Objekt eine bessere Leistung. Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access).  
  
 Mit `Input` gelesene Daten werden in der Regel mithilfe `Write`in eine Datei geschrieben. Verwenden Sie diese Funktion nur mit Dateien, die im `Input` oder `Binary` Modus geöffnet wurden.  
  
> [!IMPORTANT]
>  Treffen Sie beim Lesen aus Dateien keine Entscheidungen zum Inhalt der Datei, die auf der Dateinamenerweiterung basiert. Beispielsweise ist eine Datei mit dem Namen Form1. vb möglicherweise keine Visual Basic 2005-Quelldatei.  
  
 Beim Lesen werden Standard Zeichen folgen-oder numerische Daten Variablen ohne Änderungen zugewiesen. In der folgenden Tabelle wird veranschaulicht, wie andere Eingabedaten behandelt werden.  
  
|Data|Der Variablen zugewiesener Wert|  
|-|-|  
|Trennzeichen für Komma oder Leerzeile|Leer|  
|#NULL #|`DBNull`|  
|#TRUE # oder #false #|`True` oder `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Das Datum und/oder die Uhrzeit, die durch den Ausdruck dargestellt werden.|  
|#Error `errornumber`#|`errornumber` (Variable ist ein Objekt, das als Fehler markiert ist)|  
  
 Wenn Sie das Ende der Datei erreichen, während Sie ein Datenelement einfügen, wird die Eingabe angehalten, und es tritt ein Fehler auf.  
  
> [!NOTE]
>  Die `Input`-Funktion ist nicht lokalisiert. Wenn Sie z. b. in der deutschen Version 3, 14159 eingeben, wird nur der Wert 3 zurückgegeben, da das Komma als Variablen Trennzeichen und nicht als Dezimaltrennzeichen behandelt wird.  
  
> [!IMPORTANT]
>  Zum Lesen aus einer Datei mit der `Input`-Funktion ist `Read` Zugriff von der `FileIOPermissionAccess`-Enumeration erforderlich. Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 In diesem Beispiel wird die `Input`-Funktion verwendet, um Daten aus einer Datei in zwei Variablen zu lesen. In diesem Beispiel wird davon ausgegangen, dass es sich bei `TestFile` um eine Datei handelt, bei der einige Daten Zeilen mithilfe der `Write`-Funktion geschrieben werden, wobei jede Zeile eine Zeichenfolge in Anführungszeichen und eine durch Kommas getrennte Zahl enthält, z. b. ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files">Gewusst wie: Schreiben von Text in Dateien in Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access">Dateizugriff mit Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter">Gewusst wie: Schreiben von Text in eine Datei mit einem StreamWriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref byte Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Input(int32 FileNumber, unsigned int8&amp; Value) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Byte % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int * byte -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, unsigned int8&amp; Value) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="Value">Erforderlich. Eine Variable, der die aus der Datei gelesenen Werte zugewiesen werden, kann kein Array und keine Objektvariable sein.</param>
        <summary>Liest Daten aus einer geöffneten sequenziellen Datei und weist diese Variablen zu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Input` Funktion wird aus Gründen der Abwärtskompatibilität bereitgestellt und kann sich auf die Leistung auswirken. Bei nicht Legacy Anwendungen bietet das `My.Computer.FileSystem`-Objekt eine bessere Leistung. Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access).  
  
 Mit `Input` gelesene Daten werden in der Regel mithilfe `Write`in eine Datei geschrieben. Verwenden Sie diese Funktion nur mit Dateien, die im `Input` oder `Binary` Modus geöffnet wurden.  
  
> [!IMPORTANT]
>  Treffen Sie beim Lesen aus Dateien keine Entscheidungen zum Inhalt der Datei, die auf der Dateinamenerweiterung basiert. Beispielsweise ist eine Datei mit dem Namen Form1. vb möglicherweise keine Visual Basic 2005-Quelldatei.  
  
 Beim Lesen werden Standard Zeichen folgen-oder numerische Daten Variablen ohne Änderungen zugewiesen. In der folgenden Tabelle wird veranschaulicht, wie andere Eingabedaten behandelt werden.  
  
|Data|Der Variablen zugewiesener Wert|  
|-|-|  
|Trennzeichen für Komma oder Leerzeile|Leer|  
|#NULL #|`DBNull`|  
|#TRUE # oder #false #|`True` oder `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Das Datum und/oder die Uhrzeit, die durch den Ausdruck dargestellt werden.|  
|#Error `errornumber`#|`errornumber` (Variable ist ein Objekt, das als Fehler markiert ist)|  
  
 Wenn Sie das Ende der Datei erreichen, während Sie ein Datenelement einfügen, wird die Eingabe angehalten, und es tritt ein Fehler auf.  
  
> [!NOTE]
>  Die `Input`-Funktion ist nicht lokalisiert. Wenn Sie z. b. in der deutschen Version 3, 14159 eingeben, wird nur der Wert 3 zurückgegeben, da das Komma als Variablen Trennzeichen und nicht als Dezimaltrennzeichen behandelt wird.  
  
> [!IMPORTANT]
>  Zum Lesen aus einer Datei mit der `Input`-Funktion ist `Read` Zugriff von der `FileIOPermissionAccess`-Enumeration erforderlich. Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 In diesem Beispiel wird die `Input`-Funktion verwendet, um Daten aus einer Datei in zwei Variablen zu lesen. In diesem Beispiel wird davon ausgegangen, dass es sich bei `TestFile` um eine Datei handelt, bei der einige Daten Zeilen mithilfe der `Write`-Funktion geschrieben werden, wobei jede Zeile eine Zeichenfolge in Anführungszeichen und eine durch Kommas getrennte Zahl enthält, z. b. ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files">Gewusst wie: Schreiben von Text in Dateien in Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access">Dateizugriff mit Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter">Gewusst wie: Schreiben von Text in eine Datei mit einem StreamWriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref char Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Input(int32 FileNumber, char&amp; Value) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, char % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int * char -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, char&amp; Value) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="Value">Erforderlich. Eine Variable, der die aus der Datei gelesenen Werte zugewiesen werden, kann kein Array und keine Objektvariable sein.</param>
        <summary>Liest Daten aus einer geöffneten sequenziellen Datei und weist diese Variablen zu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Input` Funktion wird aus Gründen der Abwärtskompatibilität bereitgestellt und kann sich auf die Leistung auswirken. Bei nicht Legacy Anwendungen bietet das `My.Computer.FileSystem`-Objekt eine bessere Leistung. Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access).  
  
 Mit `Input` gelesene Daten werden in der Regel mithilfe `Write`in eine Datei geschrieben. Verwenden Sie diese Funktion nur mit Dateien, die im `Input` oder `Binary` Modus geöffnet wurden.  
  
> [!IMPORTANT]
>  Treffen Sie beim Lesen aus Dateien keine Entscheidungen zum Inhalt der Datei, die auf der Dateinamenerweiterung basiert. Beispielsweise ist eine Datei mit dem Namen Form1. vb möglicherweise keine Visual Basic 2005-Quelldatei.  
  
 Beim Lesen werden Standard Zeichen folgen-oder numerische Daten Variablen ohne Änderungen zugewiesen. In der folgenden Tabelle wird veranschaulicht, wie andere Eingabedaten behandelt werden.  
  
|Data|Der Variablen zugewiesener Wert|  
|-|-|  
|Trennzeichen für Komma oder Leerzeile|Leer|  
|#NULL #|`DBNull`|  
|#TRUE # oder #false #|`True` oder `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Das Datum und/oder die Uhrzeit, die durch den Ausdruck dargestellt werden.|  
|#Error `errornumber`#|`errornumber` (Variable ist ein Objekt, das als Fehler markiert ist)|  
  
 Wenn Sie das Ende der Datei erreichen, während Sie ein Datenelement einfügen, wird die Eingabe angehalten, und es tritt ein Fehler auf.  
  
> [!NOTE]
>  Die `Input`-Funktion ist nicht lokalisiert. Wenn Sie z. b. in der deutschen Version 3, 14159 eingeben, wird nur der Wert 3 zurückgegeben, da das Komma als Variablen Trennzeichen und nicht als Dezimaltrennzeichen behandelt wird.  
  
> [!IMPORTANT]
>  Zum Lesen aus einer Datei mit der `Input`-Funktion ist `Read` Zugriff von der `FileIOPermissionAccess`-Enumeration erforderlich. Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 In diesem Beispiel wird die `Input`-Funktion verwendet, um Daten aus einer Datei in zwei Variablen zu lesen. In diesem Beispiel wird davon ausgegangen, dass es sich bei `TestFile` um eine Datei handelt, bei der mehrere Daten Zeilen mit der `Write`-Funktion geschrieben werden, wobei jede Zeile eine Zeichenfolge in Anführungszeichen und eine durch Kommas getrennte Zahl enthält, z. b. ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files">Gewusst wie: Schreiben von Text in Dateien in Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access">Dateizugriff mit Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter">Gewusst wie: Schreiben von Text in eine Datei mit einem StreamWriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref DateTime Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Input(int32 FileNumber, valuetype System.DateTime&amp; Value) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, DateTime % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int * DateTime -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, valuetype System.DateTime&amp; Value) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="Value">Erforderlich. Eine Variable, der die aus der Datei gelesenen Werte zugewiesen werden, kann kein Array und keine Objektvariable sein.</param>
        <summary>Liest Daten aus einer geöffneten sequenziellen Datei und weist diese Variablen zu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Input` Funktion wird aus Gründen der Abwärtskompatibilität bereitgestellt und kann sich auf die Leistung auswirken. Bei nicht Legacy Anwendungen bietet das `My.Computer.FileSystem`-Objekt eine bessere Leistung. Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access).  
  
 Mit `Input` gelesene Daten werden in der Regel mithilfe `Write`in eine Datei geschrieben. Verwenden Sie diese Funktion nur mit Dateien, die im `Input` oder `Binary` Modus geöffnet wurden.  
  
> [!IMPORTANT]
>  Treffen Sie beim Lesen aus Dateien keine Entscheidungen zum Inhalt der Datei, die auf der Dateinamenerweiterung basiert. Beispielsweise ist eine Datei mit dem Namen Form1. vb möglicherweise keine Visual Basic 2005-Quelldatei.  
  
 Beim Lesen werden Standard Zeichen folgen-oder numerische Daten Variablen ohne Änderungen zugewiesen. In der folgenden Tabelle wird veranschaulicht, wie andere Eingabedaten behandelt werden.  
  
|Data|Der Variablen zugewiesener Wert|  
|-|-|  
|Trennzeichen für Komma oder Leerzeile|Leer|  
|#NULL #|`DBNull`|  
|#TRUE # oder #false #|`True` oder `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Das Datum und/oder die Uhrzeit, die durch den Ausdruck dargestellt werden.|  
|#Error `errornumber`#|`errornumber` (Variable ist ein Objekt, das als Fehler markiert ist)|  
  
 Wenn Sie das Ende der Datei erreichen, während Sie ein Datenelement einfügen, wird die Eingabe angehalten, und es tritt ein Fehler auf.  
  
> [!NOTE]
>  Die `Input`-Funktion ist nicht lokalisiert. Wenn Sie z. b. in der deutschen Version 3, 14159 eingeben, wird nur der Wert 3 zurückgegeben, da das Komma als Variablen Trennzeichen und nicht als Dezimaltrennzeichen behandelt wird.  
  
> [!IMPORTANT]
>  Zum Lesen aus einer Datei mit der `Input`-Funktion ist `Read` Zugriff von der `FileIOPermissionAccess`-Enumeration erforderlich. Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 In diesem Beispiel wird die `Input`-Funktion verwendet, um Daten aus einer Datei in zwei Variablen zu lesen. In diesem Beispiel wird davon ausgegangen, dass es sich bei `TestFile` um eine Datei handelt, bei der mehrere Daten Zeilen mit der `Write`-Funktion geschrieben werden, wobei jede Zeile eine Zeichenfolge in Anführungszeichen und eine durch Kommas getrennte Zahl enthält, z. b. ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files">Gewusst wie: Schreiben von Text in Dateien in Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access">Dateizugriff mit Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter">Gewusst wie: Schreiben von Text in eine Datei mit einem StreamWriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref decimal Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Input(int32 FileNumber, valuetype System.Decimal&amp; Value) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Decimal % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int * decimal -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, valuetype System.Decimal&amp; Value) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="Value">Erforderlich. Eine Variable, der die aus der Datei gelesenen Werte zugewiesen werden, kann kein Array und keine Objektvariable sein.</param>
        <summary>Liest Daten aus einer geöffneten sequenziellen Datei und weist diese Variablen zu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Input` Funktion wird aus Gründen der Abwärtskompatibilität bereitgestellt und kann sich auf die Leistung auswirken. Bei nicht Legacy Anwendungen bietet das `My.Computer.FileSystem`-Objekt eine bessere Leistung. Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access).  
  
 Mit `Input` gelesene Daten werden in der Regel mithilfe `Write`in eine Datei geschrieben. Verwenden Sie diese Funktion nur mit Dateien, die im `Input` oder `Binary` Modus geöffnet wurden.  
  
> [!IMPORTANT]
>  Treffen Sie beim Lesen aus Dateien keine Entscheidungen zum Inhalt der Datei, die auf der Dateinamenerweiterung basiert. Beispielsweise ist eine Datei mit dem Namen Form1. vb möglicherweise keine Visual Basic 2005-Quelldatei.  
  
 Beim Lesen werden Standard Zeichen folgen-oder numerische Daten Variablen ohne Änderungen zugewiesen. In der folgenden Tabelle wird veranschaulicht, wie andere Eingabedaten behandelt werden.  
  
|Data|Der Variablen zugewiesener Wert|  
|-|-|  
|Trennzeichen für Komma oder Leerzeile|Leer|  
|#NULL #|`DBNull`|  
|#TRUE # oder #false #|`True` oder `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Das Datum und/oder die Uhrzeit, die durch den Ausdruck dargestellt werden.|  
|#Error `errornumber`#|`errornumber` (Variable ist ein Objekt, das als Fehler markiert ist)|  
  
 Wenn Sie das Ende der Datei erreichen, während Sie ein Datenelement einfügen, wird die Eingabe angehalten, und es tritt ein Fehler auf.  
  
> [!NOTE]
>  Die `Input`-Funktion ist nicht lokalisiert. Wenn Sie z. b. in der deutschen Version 3, 14159 eingeben, wird nur der Wert 3 zurückgegeben, da das Komma als Variablen Trennzeichen und nicht als Dezimaltrennzeichen behandelt wird.  
  
> [!IMPORTANT]
>  Zum Lesen aus einer Datei mit der `Input`-Funktion ist `Read` Zugriff von der `FileIOPermissionAccess`-Enumeration erforderlich. Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 In diesem Beispiel wird die `Input`-Funktion verwendet, um Daten aus einer Datei in zwei Variablen zu lesen. In diesem Beispiel wird davon ausgegangen, dass es sich bei `TestFile` um eine Datei handelt, bei der mehrere Daten Zeilen mit der `Write`-Funktion geschrieben werden, wobei jede Zeile eine Zeichenfolge in Anführungszeichen und eine durch Kommas getrennte Zahl enthält, z. b. ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files">Gewusst wie: Schreiben von Text in Dateien in Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access">Dateizugriff mit Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter">Gewusst wie: Schreiben von Text in eine Datei mit einem StreamWriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref double Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Input(int32 FileNumber, float64&amp; Value) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, double % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int * double -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, float64&amp; Value) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="Value">Erforderlich. Eine Variable, der die aus der Datei gelesenen Werte zugewiesen werden, kann kein Array und keine Objektvariable sein.</param>
        <summary>Liest Daten aus einer geöffneten sequenziellen Datei und weist diese Variablen zu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Input` Funktion wird aus Gründen der Abwärtskompatibilität bereitgestellt und kann sich auf die Leistung auswirken. Bei nicht Legacy Anwendungen bietet das `My.Computer.FileSystem`-Objekt eine bessere Leistung. Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access).  
  
 Mit `Input` gelesene Daten werden in der Regel mithilfe `Write`in eine Datei geschrieben. Verwenden Sie diese Funktion nur mit Dateien, die im `Input` oder `Binary` Modus geöffnet wurden.  
  
> [!IMPORTANT]
>  Treffen Sie beim Lesen aus Dateien keine Entscheidungen zum Inhalt der Datei, die auf der Dateinamenerweiterung basiert. Beispielsweise ist eine Datei mit dem Namen Form1. vb möglicherweise keine Visual Basic 2005-Quelldatei.  
  
 Beim Lesen werden Standard Zeichen folgen-oder numerische Daten Variablen ohne Änderungen zugewiesen. In der folgenden Tabelle wird veranschaulicht, wie andere Eingabedaten behandelt werden.  
  
|Data|Der Variablen zugewiesener Wert|  
|-|-|  
|Trennzeichen für Komma oder Leerzeile|Leer|  
|#NULL #|`DBNull`|  
|#TRUE # oder #false #|`True` oder `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Das Datum und/oder die Uhrzeit, die durch den Ausdruck dargestellt werden.|  
|#Error `errornumber`#|`errornumber` (Variable ist ein Objekt, das als Fehler markiert ist)|  
  
 Wenn Sie das Ende der Datei erreichen, während Sie ein Datenelement einfügen, wird die Eingabe angehalten, und es tritt ein Fehler auf.  
  
> [!NOTE]
>  Die `Input`-Funktion ist nicht lokalisiert. Wenn Sie z. b. in der deutschen Version 3, 14159 eingeben, wird nur der Wert 3 zurückgegeben, da das Komma als Variablen Trennzeichen und nicht als Dezimaltrennzeichen behandelt wird.  
  
> [!IMPORTANT]
>  Zum Lesen aus einer Datei mit der `Input`-Funktion ist `Read` Zugriff von der `FileIOPermissionAccess`-Enumeration erforderlich. Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 In diesem Beispiel wird die `Input`-Funktion verwendet, um Daten aus einer Datei in zwei Variablen zu lesen. In diesem Beispiel wird davon ausgegangen, dass es sich bei `TestFile` um eine Datei handelt, bei der mehrere Daten Zeilen mit der `Write`-Funktion geschrieben werden, wobei jede Zeile eine Zeichenfolge in Anführungszeichen und eine durch Kommas getrennte Zahl enthält, z. b. ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files">Gewusst wie: Schreiben von Text in Dateien in Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access">Dateizugriff mit Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter">Gewusst wie: Schreiben von Text in eine Datei mit einem StreamWriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref short Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Input(int32 FileNumber, int16&amp; Value) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, short % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int * int16 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int16&amp; Value) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="Value">Erforderlich. Eine Variable, der die aus der Datei gelesenen Werte zugewiesen werden, kann kein Array und keine Objektvariable sein.</param>
        <summary>Liest Daten aus einer geöffneten sequenziellen Datei und weist diese Variablen zu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Input` Funktion wird aus Gründen der Abwärtskompatibilität bereitgestellt und kann sich auf die Leistung auswirken. Bei nicht Legacy Anwendungen bietet das `My.Computer.FileSystem`-Objekt eine bessere Leistung. Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access).  
  
 Mit `Input` gelesene Daten werden in der Regel mithilfe `Write`in eine Datei geschrieben. Verwenden Sie diese Funktion nur mit Dateien, die im `Input` oder `Binary` Modus geöffnet wurden.  
  
> [!IMPORTANT]
>  Treffen Sie beim Lesen aus Dateien keine Entscheidungen zum Inhalt der Datei, die auf der Dateinamenerweiterung basiert. Beispielsweise ist eine Datei mit dem Namen Form1. vb möglicherweise keine Visual Basic 2005-Quelldatei.  
  
 Beim Lesen werden Standard Zeichen folgen-oder numerische Daten Variablen ohne Änderungen zugewiesen. In der folgenden Tabelle wird veranschaulicht, wie andere Eingabedaten behandelt werden.  
  
|Data|Der Variablen zugewiesener Wert|  
|-|-|  
|Trennzeichen für Komma oder Leerzeile|Leer|  
|#NULL #|`DBNull`|  
|#TRUE # oder #false #|`True` oder `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Das Datum und/oder die Uhrzeit, die durch den Ausdruck dargestellt werden.|  
|#Error `errornumber`#|`errornumber` (Variable ist ein Objekt, das als Fehler markiert ist)|  
  
 Wenn Sie das Ende der Datei erreichen, während Sie ein Datenelement einfügen, wird die Eingabe angehalten, und es tritt ein Fehler auf.  
  
> [!NOTE]
>  Die `Input`-Funktion ist nicht lokalisiert. Wenn Sie z. b. in der deutschen Version 3, 14159 eingeben, wird nur der Wert 3 zurückgegeben, da das Komma als Variablen Trennzeichen und nicht als Dezimaltrennzeichen behandelt wird.  
  
> [!IMPORTANT]
>  Zum Lesen aus einer Datei mit der `Input`-Funktion ist `Read` Zugriff von der `FileIOPermissionAccess`-Enumeration erforderlich. Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 In diesem Beispiel wird die `Input`-Funktion verwendet, um Daten aus einer Datei in zwei Variablen zu lesen. In diesem Beispiel wird davon ausgegangen, dass es sich bei `TestFile` um eine Datei handelt, bei der mehrere Daten Zeilen mit der `Write`-Funktion geschrieben werden, wobei jede Zeile eine Zeichenfolge in Anführungszeichen und eine durch Kommas getrennte Zahl enthält, z. b. ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files">Gewusst wie: Schreiben von Text in Dateien in Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access">Dateizugriff mit Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter">Gewusst wie: Schreiben von Text in eine Datei mit einem StreamWriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref int Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Input(int32 FileNumber, int32&amp; Value) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, int % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int * int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int32&amp; Value) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="Value">Erforderlich. Eine Variable, der die aus der Datei gelesenen Werte zugewiesen werden, kann kein Array und keine Objektvariable sein.</param>
        <summary>Liest Daten aus einer geöffneten sequenziellen Datei und weist diese Variablen zu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Input` Funktion wird aus Gründen der Abwärtskompatibilität bereitgestellt und kann sich auf die Leistung auswirken. Bei nicht Legacy Anwendungen bietet das `My.Computer.FileSystem`-Objekt eine bessere Leistung. Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access).  
  
 Mit `Input` gelesene Daten werden in der Regel mithilfe `Write`in eine Datei geschrieben. Verwenden Sie diese Funktion nur mit Dateien, die im `Input` oder `Binary` Modus geöffnet wurden.  
  
> [!IMPORTANT]
>  Treffen Sie beim Lesen aus Dateien keine Entscheidungen zum Inhalt der Datei, die auf der Dateinamenerweiterung basiert. Beispielsweise ist eine Datei mit dem Namen Form1. vb möglicherweise keine Visual Basic 2005-Quelldatei.  
  
 Beim Lesen werden Standard Zeichen folgen-oder numerische Daten Variablen ohne Änderungen zugewiesen. In der folgenden Tabelle wird veranschaulicht, wie andere Eingabedaten behandelt werden.  
  
|Data|Der Variablen zugewiesener Wert|  
|-|-|  
|Trennzeichen für Komma oder Leerzeile|Leer|  
|#NULL #|`DBNull`|  
|#TRUE # oder #false #|`True` oder `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Das Datum und/oder die Uhrzeit, die durch den Ausdruck dargestellt werden.|  
|#Error `errornumber`#|`errornumber` (Variable ist ein Objekt, das als Fehler markiert ist)|  
  
 Wenn Sie das Ende der Datei erreichen, während Sie ein Datenelement einfügen, wird die Eingabe angehalten, und es tritt ein Fehler auf.  
  
> [!NOTE]
>  Die `Input`-Funktion ist nicht lokalisiert. Wenn Sie z. b. in der deutschen Version 3, 14159 eingeben, wird nur der Wert 3 zurückgegeben, da das Komma als Variablen Trennzeichen und nicht als Dezimaltrennzeichen behandelt wird.  
  
> [!IMPORTANT]
>  Zum Lesen aus einer Datei mit der `Input`-Funktion ist `Read` Zugriff von der `FileIOPermissionAccess`-Enumeration erforderlich. Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 In diesem Beispiel wird die `Input`-Funktion verwendet, um Daten aus einer Datei in zwei Variablen zu lesen. In diesem Beispiel wird davon ausgegangen, dass es sich bei `TestFile` um eine Datei handelt, bei der mehrere Daten Zeilen mit der `Write`-Funktion geschrieben werden, wobei jede Zeile eine Zeichenfolge in Anführungszeichen und eine durch Kommas getrennte Zahl enthält, z. b. ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files">Gewusst wie: Schreiben von Text in Dateien in Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access">Dateizugriff mit Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter">Gewusst wie: Schreiben von Text in eine Datei mit einem StreamWriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref long Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Input(int32 FileNumber, int64&amp; Value) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, long % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int64&amp; Value) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="Value">Erforderlich. Eine Variable, der die aus der Datei gelesenen Werte zugewiesen werden, kann kein Array und keine Objektvariable sein.</param>
        <summary>Liest Daten aus einer geöffneten sequenziellen Datei und weist diese Variablen zu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Input` Funktion wird aus Gründen der Abwärtskompatibilität bereitgestellt und kann sich auf die Leistung auswirken. Bei nicht Legacy Anwendungen bietet das `My.Computer.FileSystem`-Objekt eine bessere Leistung. Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access).  
  
 Mit `Input` gelesene Daten werden in der Regel mithilfe `Write`in eine Datei geschrieben. Verwenden Sie diese Funktion nur mit Dateien, die im `Input` oder `Binary` Modus geöffnet wurden.  
  
> [!IMPORTANT]
>  Treffen Sie beim Lesen aus Dateien keine Entscheidungen zum Inhalt der Datei, die auf der Dateinamenerweiterung basiert. Beispielsweise ist eine Datei mit dem Namen Form1. vb möglicherweise keine Visual Basic 2005-Quelldatei.  
  
 Beim Lesen werden Standard Zeichen folgen-oder numerische Daten Variablen ohne Änderungen zugewiesen. In der folgenden Tabelle wird veranschaulicht, wie andere Eingabedaten behandelt werden.  
  
|Data|Der Variablen zugewiesener Wert|  
|-|-|  
|Trennzeichen für Komma oder Leerzeile|Leer|  
|#NULL #|`DBNull`|  
|#TRUE # oder #false #|`True` oder `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Das Datum und/oder die Uhrzeit, die durch den Ausdruck dargestellt werden.|  
|#Error `errornumber`#|`errornumber` (Variable ist ein Objekt, das als Fehler markiert ist)|  
  
 Wenn Sie das Ende der Datei erreichen, während Sie ein Datenelement einfügen, wird die Eingabe angehalten, und es tritt ein Fehler auf.  
  
> [!NOTE]
>  Die `Input`-Funktion ist nicht lokalisiert. Wenn Sie z. b. in der deutschen Version 3, 14159 eingeben, wird nur der Wert 3 zurückgegeben, da das Komma als Variablen Trennzeichen und nicht als Dezimaltrennzeichen behandelt wird.  
  
> [!IMPORTANT]
>  Zum Lesen aus einer Datei mit der `Input`-Funktion ist `Read` Zugriff von der `FileIOPermissionAccess`-Enumeration erforderlich. Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 In diesem Beispiel wird die `Input`-Funktion verwendet, um Daten aus einer Datei in zwei Variablen zu lesen. In diesem Beispiel wird davon ausgegangen, dass es sich bei `TestFile` um eine Datei handelt, bei der mehrere Daten Zeilen mit der `Write`-Funktion geschrieben werden, wobei jede Zeile eine Zeichenfolge in Anführungszeichen und eine durch Kommas getrennte Zahl enthält, z. b. ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files">Gewusst wie: Schreiben von Text in Dateien in Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access">Dateizugriff mit Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter">Gewusst wie: Schreiben von Text in eine Datei mit einem StreamWriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref object Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Input(int32 FileNumber, object&amp; Value) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Object ^ % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int * obj -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, object&amp; Value) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="Value">Erforderlich. Eine Variable, der die aus der Datei gelesenen Werte zugewiesen werden, kann kein Array und keine Objektvariable sein.</param>
        <summary>Liest Daten aus einer geöffneten sequenziellen Datei und weist diese Variablen zu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Input` Funktion wird aus Gründen der Abwärtskompatibilität bereitgestellt und kann sich auf die Leistung auswirken. Bei nicht Legacy Anwendungen bietet das `My.Computer.FileSystem`-Objekt eine bessere Leistung. Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access).  
  
 Mit `Input` gelesene Daten werden in der Regel mithilfe `Write`in eine Datei geschrieben. Verwenden Sie diese Funktion nur mit Dateien, die im `Input` oder `Binary` Modus geöffnet wurden.  
  
> [!IMPORTANT]
>  Treffen Sie beim Lesen aus Dateien keine Entscheidungen zum Inhalt der Datei, die auf der Dateinamenerweiterung basiert. Beispielsweise ist eine Datei mit dem Namen Form1. vb möglicherweise keine Visual Basic 2005-Quelldatei.  
  
 Beim Lesen werden Standard Zeichen folgen-oder numerische Daten Variablen ohne Änderungen zugewiesen. In der folgenden Tabelle wird veranschaulicht, wie andere Eingabedaten behandelt werden.  
  
|Data|Der Variablen zugewiesener Wert|  
|-|-|  
|Trennzeichen für Komma oder Leerzeile|Leer|  
|#NULL #|`DBNull`|  
|#TRUE # oder #false #|`True` oder `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Das Datum und/oder die Uhrzeit, die durch den Ausdruck dargestellt werden.|  
|#Error `errornumber`#|`errornumber` (Variable ist ein Objekt, das als Fehler markiert ist)|  
  
 Wenn Sie das Ende der Datei erreichen, während Sie ein Datenelement einfügen, wird die Eingabe angehalten, und es tritt ein Fehler auf.  
  
> [!NOTE]
>  Die `Input`-Funktion ist nicht lokalisiert. Wenn Sie z. b. in der deutschen Version 3, 14159 eingeben, wird nur der Wert 3 zurückgegeben, da das Komma als Variablen Trennzeichen und nicht als Dezimaltrennzeichen behandelt wird.  
  
> [!IMPORTANT]
>  Zum Lesen aus einer Datei mit der `Input`-Funktion ist `Read` Zugriff von der `FileIOPermissionAccess`-Enumeration erforderlich. Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 In diesem Beispiel wird die `Input`-Funktion verwendet, um Daten aus einer Datei in zwei Variablen zu lesen. In diesem Beispiel wird davon ausgegangen, dass es sich bei `TestFile` um eine Datei handelt, bei der mehrere Daten Zeilen mit der `Write`-Funktion geschrieben werden, wobei jede Zeile eine Zeichenfolge in Anführungszeichen und eine durch Kommas getrennte Zahl enthält, z. b. ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files">Gewusst wie: Schreiben von Text in Dateien in Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access">Dateizugriff mit Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter">Gewusst wie: Schreiben von Text in eine Datei mit einem StreamWriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref float Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Input(int32 FileNumber, float32&amp; Value) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, float % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int * single -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, float32&amp; Value) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="Value">Erforderlich. Eine Variable, der die aus der Datei gelesenen Werte zugewiesen werden, kann kein Array und keine Objektvariable sein.</param>
        <summary>Liest Daten aus einer geöffneten sequenziellen Datei und weist diese Variablen zu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Input` Funktion wird aus Gründen der Abwärtskompatibilität bereitgestellt und kann sich auf die Leistung auswirken. Bei nicht Legacy Anwendungen bietet das `My.Computer.FileSystem`-Objekt eine bessere Leistung. Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access).  
  
 Mit `Input` gelesene Daten werden in der Regel mithilfe `Write`in eine Datei geschrieben. Verwenden Sie diese Funktion nur mit Dateien, die im `Input` oder `Binary` Modus geöffnet wurden.  
  
> [!IMPORTANT]
>  Treffen Sie beim Lesen aus Dateien keine Entscheidungen zum Inhalt der Datei, die auf der Dateinamenerweiterung basiert. Beispielsweise ist eine Datei mit dem Namen Form1. vb möglicherweise keine Visual Basic 2005-Quelldatei.  
  
 Beim Lesen werden Standard Zeichen folgen-oder numerische Daten Variablen ohne Änderungen zugewiesen. In der folgenden Tabelle wird veranschaulicht, wie andere Eingabedaten behandelt werden.  
  
|Data|Der Variablen zugewiesener Wert|  
|-|-|  
|Trennzeichen für Komma oder Leerzeile|Leer|  
|#NULL #|`DBNull`|  
|#TRUE # oder #false #|`True` oder `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Das Datum und/oder die Uhrzeit, die durch den Ausdruck dargestellt werden.|  
|#Error `errornumber`#|`errornumber` (Variable ist ein Objekt, das als Fehler markiert ist)|  
  
 Wenn Sie das Ende der Datei erreichen, während Sie ein Datenelement einfügen, wird die Eingabe angehalten, und es tritt ein Fehler auf.  
  
> [!NOTE]
>  Die `Input`-Funktion ist nicht lokalisiert. Wenn Sie z. b. in der deutschen Version 3, 14159 eingeben, wird nur der Wert 3 zurückgegeben, da das Komma als Variablen Trennzeichen und nicht als Dezimaltrennzeichen behandelt wird.  
  
> [!IMPORTANT]
>  Zum Lesen aus einer Datei mit der `Input`-Funktion ist `Read` Zugriff von der `FileIOPermissionAccess`-Enumeration erforderlich. Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 In diesem Beispiel wird die `Input`-Funktion verwendet, um Daten aus einer Datei in zwei Variablen zu lesen. In diesem Beispiel wird davon ausgegangen, dass es sich bei `TestFile` um eine Datei handelt, bei der mehrere Daten Zeilen mit der `Write`-Funktion geschrieben werden, wobei jede Zeile eine Zeichenfolge in Anführungszeichen und eine durch Kommas getrennte Zahl enthält, z. b. ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files">Gewusst wie: Schreiben von Text in Dateien in Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access">Dateizugriff mit Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter">Gewusst wie: Schreiben von Text in eine Datei mit einem StreamWriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref string Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Input(int32 FileNumber, string&amp; Value) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::String ^ % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int * string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, string&amp; Value) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="Value">Erforderlich. Eine Variable, der die aus der Datei gelesenen Werte zugewiesen werden, kann kein Array und keine Objektvariable sein.</param>
        <summary>Liest Daten aus einer geöffneten sequenziellen Datei und weist diese Variablen zu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Input` Funktion wird aus Gründen der Abwärtskompatibilität bereitgestellt und kann sich auf die Leistung auswirken. Bei nicht Legacy Anwendungen bietet das `My.Computer.FileSystem`-Objekt eine bessere Leistung. Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access).  
  
 Mit `Input` gelesene Daten werden in der Regel mithilfe `Write`in eine Datei geschrieben. Verwenden Sie diese Funktion nur mit Dateien, die im `Input` oder `Binary` Modus geöffnet wurden.  
  
> [!IMPORTANT]
>  Treffen Sie beim Lesen aus Dateien keine Entscheidungen zum Inhalt der Datei, die auf der Dateinamenerweiterung basiert. Beispielsweise ist eine Datei mit dem Namen Form1. vb möglicherweise keine Visual Basic 2005-Quelldatei.  
  
 Beim Lesen werden Standard Zeichen folgen-oder numerische Daten Variablen ohne Änderungen zugewiesen. In der folgenden Tabelle wird veranschaulicht, wie andere Eingabedaten behandelt werden.  
  
|Data|Der Variablen zugewiesener Wert|  
|-|-|  
|Trennzeichen für Komma oder Leerzeile|Leer|  
|#NULL #|`DBNull`|  
|#TRUE # oder #false #|`True` oder `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Das Datum und/oder die Uhrzeit, die durch den Ausdruck dargestellt werden.|  
|#Error `errornumber`#|`errornumber` (Variable ist ein Objekt, das als Fehler markiert ist)|  
  
 Wenn Sie das Ende der Datei erreichen, während Sie ein Datenelement einfügen, wird die Eingabe angehalten, und es tritt ein Fehler auf.  
  
> [!NOTE]
>  Die `Input`-Funktion ist nicht lokalisiert. Wenn Sie z. b. in der deutschen Version 3, 14159 eingeben, wird nur der Wert 3 zurückgegeben, da das Komma als Variablen Trennzeichen und nicht als Dezimaltrennzeichen behandelt wird.  
  
> [!IMPORTANT]
>  Zum Lesen aus einer Datei mit der `Input`-Funktion ist `Read` Zugriff von der `FileIOPermissionAccess`-Enumeration erforderlich. Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 In diesem Beispiel wird die `Input`-Funktion verwendet, um Daten aus einer Datei in zwei Variablen zu lesen. In diesem Beispiel wird davon ausgegangen, dass es sich bei `TestFile` um eine Datei handelt, bei der mehrere Daten Zeilen mit der `Write`-Funktion geschrieben werden, wobei jede Zeile eine Zeichenfolge in Anführungszeichen und eine durch Kommas getrennte Zahl enthält, z. b. ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files">Gewusst wie: Schreiben von Text in Dateien in Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access">Dateizugriff mit Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter">Gewusst wie: Schreiben von Text in eine Datei mit einem StreamWriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="InputString">
      <MemberSignature Language="C#" Value="public static string InputString (int FileNumber, int CharCount);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string InputString(int32 FileNumber, int32 CharCount) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function InputString (FileNumber As Integer, CharCount As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ InputString(int FileNumber, int CharCount);" />
      <MemberSignature Language="F#" Value="static member InputString : int * int -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.InputString (FileNumber, CharCount)" />
      <MemberSignature Language="ILAsm" Value=".method public static string InputString(int32 FileNumber, int32 CharCount) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="CharCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="CharCount">Erforderlich. Ein beliebiger gültiger numerischer Ausdruck, der die Anzahl der zu lesenden Zeichen angibt.</param>
        <summary>Gibt einen <see langword="String" />-Wert zurück, der Zeichen aus einer im Modus <see langword="Input" /> oder <see langword="Binary" /> geöffneten Datei enthält. Die <see langword="My" />-Funktion bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="InputString" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <returns>Eine Zeichenfolge, die Zeichen aus einer im <see langword="Input" />- oder <see langword="Binary" />-Modus geöffneten Datei enthält. Die <see langword="My" />-Funktion bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="InputString" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `InputString` Funktion wird aus Gründen der Abwärtskompatibilität bereitgestellt und kann sich auf die Leistung auswirken. Bei nicht Legacy Anwendungen bietet das `My.Computer.FileSystem`-Objekt eine bessere Leistung. Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access).  
  
 Mit der `InputString`-Funktion gelesene Daten werden in der Regel mithilfe von `Print` oder `FilePut`in eine Datei geschrieben. Verwenden Sie diese Funktion nur mit Dateien, die im `Input` oder `Binary` Modus geöffnet wurden.  
  
 Anders als die `Input`-Funktion gibt die `InputString`-Funktion alle gelesenen Zeichen zurück. Dies schließt Kommas, Wagen Rückläufe, Zeilen Feeds, Anführungszeichen und führende Leerzeichen ein.  
  
 Wenn Dateien für `Binary` Zugriff geöffnet wurden, wird versucht, die Datei mit der `InputString`-Funktion zu lesen, bis `EOF` zurückgibt, `True` einen Fehler generiert. Verwenden Sie die Funktionen `LOF` und `Loc` anstelle von `EOF`, wenn Sie Binärdateien mit `InputString`lesen, oder verwenden Sie `FileGet`, wenn Sie die `EOF`-Funktion verwenden.  
  
> [!NOTE]
>  Treffen Sie beim Lesen aus Dateien keine Sicherheitsentscheidungen zum Inhalt der Datei, die auf der Dateinamenerweiterung basiert. Beispielsweise ist eine Datei mit dem Namen Form1. vb möglicherweise keine Visual Basic Quelldatei.  
  
   
  
## Examples  
 In diesem Beispiel wird die `InputString`-Funktion verwendet, um ein Zeichen gleichzeitig aus einer Datei zu lesen und in das `Output` Fenster zu drucken. In diesem Beispiel wird davon ausgegangen, dass `MyFile` eine Textdatei mit mehreren Zeilen von Beispiel Daten ist.  
  
 [!code-vb[VbVbalrCatRef#33](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#33)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><paramref name="FileNumber" /> existiert nicht.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="CharCount" /> &lt; 0 oder &gt; 214.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access">Dateizugriff mit Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter">Gewusst wie: Schreiben von Text in eine Datei mit einem StreamWriter (Visual Basic)</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files">Gewusst wie: Schreiben von Text in Dateien in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Kill">
      <MemberSignature Language="C#" Value="public static void Kill (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Kill(string PathName) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Kill (PathName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Kill(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member Kill : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Kill PathName" />
      <MemberSignature Language="ILAsm" Value=".method public static void Kill(string PathName) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">Erforderlich. Ein Zeichenfolgenausdruck, der einen oder mehrere Namen von zu löschenden Dateien angibt. <paramref name="PathName" /> kann auch das Verzeichnis oder den Ordner sowie das Laufwerk beinhalten.</param>
        <summary>Löscht Dateien von einem Datenträger. Die <see langword="My" />-Funktion bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="Kill" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Kill` unterstützt die Verwendung von Platzhaltern mit mehreren Zeichen (`*`) und Einzelzeichen (`?`) zum Angeben mehrerer Dateien.  
  
 **Sicherheitshinweis** Zum Ausführen von muss für die `Kill`-Funktion dem ausführenden Code `Read` und `PathDiscovery` Flags <xref:System.Security.Permissions.FileIOPermission> erteilt werden. Weitere Informationen finden Sie unter <xref:System.Security.SecurityException>[Code Zugriffsberechtigungen](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675) .  
  
   
  
## Examples  
 In diesem Beispiel wird die `Kill`-Funktion verwendet, um eine Datei von einem Datenträger zu löschen.  
  
 [!code-vb[VbVbalrCatRef#60](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#60)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Zieldatei(en) geöffnet.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Zieldatei(en) nicht gefunden.</exception>
        <exception cref="T:System.Security.SecurityException">Berechtigung verweigert.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <Member MemberName="LineInput">
      <MemberSignature Language="C#" Value="public static string LineInput (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string LineInput(int32 FileNumber) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.LineInput(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LineInput (FileNumber As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ LineInput(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member LineInput : int -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.LineInput FileNumber" />
      <MemberSignature Language="ILAsm" Value=".method public static string LineInput(int32 FileNumber) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <summary>Liest eine einzelne Zeile aus einer offenen sequenziellen Datei und weist diese einer <see langword="String" />-Variablen zu.</summary>
        <returns>Liest eine einzelne Zeile aus einer offenen sequenziellen Datei und weist diese einer <see langword="String" />-Variablen zu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `LineInput` Funktion wird aus Gründen der Abwärtskompatibilität bereitgestellt und kann sich auf die Leistung auswirken. Bei nicht Legacy Anwendungen bietet das `My.Computer.FileSystem`-Objekt eine bessere Leistung. Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access).  
  
 Mit `LineInput` gelesene Daten werden in der Regel mithilfe `Print`in eine Datei geschrieben.  
  
> [!IMPORTANT]
>  Treffen Sie beim Lesen aus Dateien keine Entscheidungen zum Inhalt einer Datei, die auf der Dateinamenerweiterung basiert. Beispielsweise ist eine Datei mit dem Namen Form1. vb möglicherweise keine Visual Basic Quelldatei.  
  
 Die `LineInput`-Funktion liest ein Zeichen gleichzeitig aus einer Datei, bis ein Wagen Rücklauf Zeichen (`Chr(13)`) oder ein Wagen Rücklauf/Zeilenvorschub (`Chr(13) + Chr(10)`) auftritt. Wagen Rücklauf/Zeilenvorschub Sequenzen werden übersprungen, anstatt an die Zeichenfolge angefügt zu werden.  
  
> [!IMPORTANT]
>  Zum Lesen aus einer Datei mit der `LineInput`-Funktion ist `Read` Zugriff von der <xref:System.Security.Permissions.FileIOPermissionAccess>-Enumeration erforderlich.  
  
   
  
## Examples  
 In diesem Beispiel wird die `LineInput`-Funktion verwendet, um eine Zeile aus einer sequenziellen Datei zu lesen und Sie einer Variablen zuzuweisen. In diesem Beispiel wird davon ausgegangen, dass `TestFile` eine Textdatei mit mehreren Zeilen von Beispiel Daten ist.  
  
 [!code-vb[VbVbalrCatRef#19](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.EndOfStreamException">Dateiende erreicht.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="FileNumber" /> existiert nicht.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Strings.Chr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.ChrW(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access">Dateizugriff mit Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter">Gewusst wie: Schreiben von Text in eine Datei mit einem StreamWriter (Visual Basic)</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files">Gewusst wie: Schreiben von Text in Dateien in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Loc">
      <MemberSignature Language="C#" Value="public static long Loc (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Loc(int32 FileNumber) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Loc (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Loc(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Loc : int -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.Loc FileNumber" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 Loc(int32 FileNumber) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige <see langword="Integer" />-Dateinummer.</param>
        <summary>Gibt einen Wert zurück, der die aktuelle Lese-/Schreibposition in einer geöffneten Datei angibt.</summary>
        <returns>Die aktuelle Lese- oder Schreibposition in einer geöffneten Datei.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Loc` Funktion ist NULL basiert. Wenn Sie das erste Byte in einer Datei verwenden, wird 0 zurückgegeben.  
  
 Die `Loc` Funktion wird aus Gründen der Abwärtskompatibilität bereitgestellt und kann sich auf die Leistung auswirken. Bei nicht Legacy Anwendungen bietet das `My.Computer.FileSystem`-Objekt eine bessere Leistung. Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access).  
  
 Im folgenden wird der Rückgabewert für jeden Datei Zugriffsmodus beschrieben:  
  
|Mode|Rückgabewert|  
|-|-|  
|`Random`|Nummer des letzten aus der Datei gelesenen oder geschriebenen Datensatzes.|  
|`Sequential`|Aktuelle Byte Position in der Datei dividiert durch 128. Informationen, die von `Loc` für sequenzielle Dateien zurückgegeben werden, werden jedoch weder verwendet noch benötigt.|  
|`Binary`|Position des letzten gelesenen oder geschriebenen Bytes.|  
  
   
  
## Examples  
 In diesem Beispiel wird die `Loc`-Funktion verwendet, um die aktuelle Lese-/Schreibposition in einer geöffneten Datei zurückzugeben. In diesem Beispiel wird davon ausgegangen, dass `MyFile` eine Textdatei mit mehreren Zeilen von Beispiel Daten ist.  
  
 [!code-vb[VbVbalrCatRef#17](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Lock">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Steuert den Zugriff durch andere Prozesse auf die gesamte mithilfe der <see langword="Open" />-Funktion geöffnete Datei oder einen Teil davon. Das <see langword="My" />-Feature ermöglicht bei Datei-E/A-Vorgängen höhere Produktivität und Leistung als <see langword="Lock" /> und <see langword="Unlock" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Lock(int32 FileNumber) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Lock : int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Lock FileNumber" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <summary>Steuert den Zugriff durch andere Prozesse auf die gesamte mithilfe der <see langword="Open" />-Funktion geöffnete Datei oder einen Teil davon. Das <see langword="My" />-Feature ermöglicht bei Datei-E/A-Vorgängen höhere Produktivität und Leistung als <see langword="Lock" /> und <see langword="Unlock" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Funktionen `Lock` und `Unlock` werden in Umgebungen verwendet, in denen mehrere Prozesse möglicherweise auf dieselbe Datei zugreifen müssen.  
  
 die Funktionen `Lock` und `Unlock` werden immer paarweise verwendet. Die Argumente für `Lock` und `Unlock` müssen identisch sein.  
  
 Wenn `Record`oder `FromRecord` und `ToRecord` nicht bereitgestellt werden, wird die Sperre für die gesamte Datei verwendet. Wenn `Record` allein angegeben ist, wird der einzelne Datensatz gesperrt/entsperrt.  
  
 Wenn die Datei für die sequenzielle Eingabe oder Ausgabe geöffnet wurde, `Lock` und `Unlock` sich auf die gesamte Datei auswirken, unabhängig von dem durch `FromRecord` und`ToRecord`angegebenen Bereich.  
  
   
  
## Examples  
 Dieses Beispiel veranschaulicht die Verwendung der Funktionen `Lock` und `Unlock`. In diesem Beispiel wird davon ausgegangen, dass `People.txt` eine Datei ist, die Datensätze der Struktur `Person`enthält.  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access">Dateizugriff mit Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber, long Record);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Lock(int32 FileNumber, int64 Record) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer, Record As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber, long Record);" />
      <MemberSignature Language="F#" Value="static member Lock : int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Lock (FileNumber, Record)" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber, int64 Record) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Record" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="Record">Optional. Die Nummer des einzigen zu sperrenden oder zu entsperrenden Datensatzes.</param>
        <summary>Steuert den Zugriff durch andere Prozesse auf die gesamte mithilfe der <see langword="Open" />-Funktion geöffnete Datei oder einen Teil davon. Das <see langword="My" />-Feature ermöglicht bei Datei-E/A-Vorgängen höhere Produktivität und Leistung als <see langword="Lock" /> und <see langword="Unlock" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Funktionen `Lock` und `Unlock` werden in Umgebungen verwendet, in denen mehrere Prozesse möglicherweise auf dieselbe Datei zugreifen müssen.  
  
 die Funktionen `Lock` und `Unlock` werden immer paarweise verwendet. Die Argumente für `Lock` und `Unlock` müssen identisch sein.  
  
 Wenn `Record`oder `FromRecord` und `ToRecord` nicht bereitgestellt werden, wird die Sperre für die gesamte Datei verwendet. Wenn `Record` allein angegeben ist, wird der einzelne Datensatz gesperrt/entsperrt.  
  
 Wenn die Datei für die sequenzielle Eingabe oder Ausgabe geöffnet wurde, `Lock` und `Unlock` sich auf die gesamte Datei auswirken, unabhängig von dem durch `FromRecord` und`ToRecord`angegebenen Bereich.  
  
   
  
## Examples  
 Dieses Beispiel veranschaulicht die Verwendung der Funktionen `Lock` und `Unlock`. In diesem Beispiel wird davon ausgegangen, dass `People.txt` eine Datei ist, die Datensätze der Struktur `Person`enthält.  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access">Dateizugriff mit Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Lock(int32 FileNumber, int64 FromRecord, int64 ToRecord) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer, FromRecord As Long, ToRecord As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="F#" Value="static member Lock : int * int64 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Lock (FileNumber, FromRecord, ToRecord)" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber, int64 FromRecord, int64 ToRecord) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FromRecord" Type="System.Int64" />
        <Parameter Name="ToRecord" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="FromRecord">Optional. Die Nummer des ersten zu sperrenden oder zu entsperrenden Datensatzes.</param>
        <param name="ToRecord">Optional. Die Nummer des letzten zu sperrenden oder zu entsperrenden Datensatzes.</param>
        <summary>Steuert den Zugriff durch andere Prozesse auf die gesamte mithilfe der <see langword="Open" />-Funktion geöffnete Datei oder einen Teil davon. Das <see langword="My" />-Feature ermöglicht bei Datei-E/A-Vorgängen höhere Produktivität und Leistung als <see langword="Lock" /> und <see langword="Unlock" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Funktionen `Lock` und `Unlock` werden in Umgebungen verwendet, in denen mehrere Prozesse möglicherweise auf dieselbe Datei zugreifen müssen.  
  
 die Funktionen `Lock` und `Unlock` werden immer paarweise verwendet. Die Argumente für `Lock` und `Unlock` müssen identisch sein.  
  
 Wenn `Record`oder `FromRecord` und `ToRecord` nicht bereitgestellt werden, wird die Sperre für die gesamte Datei verwendet. Wenn `Record` allein angegeben ist, wird der einzelne Datensatz gesperrt/entsperrt.  
  
 Wenn die Datei für die sequenzielle Eingabe oder Ausgabe geöffnet wurde, `Lock` und `Unlock` sich auf die gesamte Datei auswirken, unabhängig von dem durch `FromRecord` und`ToRecord`angegebenen Bereich.  
  
   
  
## Examples  
 Dieses Beispiel veranschaulicht die Verwendung der Funktionen `Lock` und `Unlock`. In diesem Beispiel wird davon ausgegangen, dass `People.txt` eine Datei ist, die Datensätze der Struktur `Person`enthält.  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access">Dateizugriff mit Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="LOF">
      <MemberSignature Language="C#" Value="public static long LOF (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 LOF(int32 FileNumber) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LOF (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long LOF(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member LOF : int -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.LOF FileNumber" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 LOF(int32 FileNumber) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Ein ganzzahliger Wert, der eine gültige Dateinummer enthält.</param>
        <summary>Gibt die Größe in Byte einer mithilfe der <see langword="FileOpen" />-Funktion geöffneten Datei zurück. Die <see langword="My" />-Funktion bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="LOF" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <returns>Gibt die Größe in Byte einer mithilfe der <see langword="FileOpen" />-Funktion geöffneten Datei zurück. Die <see langword="My" />-Funktion bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="LOF" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie die `FileLen`-Funktion, um die Länge einer Datei abzurufen, die nicht geöffnet ist.  
  
   
  
## Examples  
 In diesem Beispiel wird die `LOF`-Funktion verwendet, um die Größe einer geöffneten Datei zu bestimmen. In diesem Beispiel wird davon ausgegangen, dass `TestFile` eine Textdatei ist, die Beispiel Daten enthält.  
  
 [!code-vb[VbVbalrCatRef#23](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files">Lesen aus Dateien in Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files">Schreiben in Dateien in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="MkDir">
      <MemberSignature Language="C#" Value="public static void MkDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MkDir(string Path) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MkDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MkDir(System::String ^ Path);" />
      <MemberSignature Language="F#" Value="static member MkDir : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.MkDir Path" />
      <MemberSignature Language="ILAsm" Value=".method public static void MkDir(string Path) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">Erforderlich. Ein Zeichenfolgenausdruck, der das zu erstellende Verzeichnis angibt. <paramref name="Path" /> enthält möglicherweise das Laufwerk. Wenn kein Laufwerk angegeben wird, erstellt <see langword="MkDir" /> das neue Verzeichnis auf dem aktuellen Laufwerk.</param>
        <summary>Erstellt ein neues Verzeichnis. Die <see langword="My" />-Funktion bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="MkDir" />. Weitere Informationen finden Sie unter <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CreateDirectory(System.String)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Funktion erstellt ein neues Verzeichnis.  
  
   
  
## Examples  
 In diesem Beispiel wird die `MkDir`-Funktion verwendet, um ein Verzeichnis zu erstellen. Wenn das Laufwerk nicht angegeben ist, wird das neue Verzeichnis auf dem aktuellen Laufwerk erstellt.  
  
 [!code-vb[VbVbalrCatRef#38](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#38)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="Path" /> ist nicht angegeben oder leer.</exception>
        <exception cref="T:System.Security.SecurityException">Berechtigung verweigert.</exception>
        <exception cref="T:System.IO.IOException">Verzeichnis ist bereits vorhanden.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-directory">Gewusst wie: Erstellen eines Verzeichnisses in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Print">
      <MemberSignature Language="C#" Value="public static void Print (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Print(int32 FileNumber, object[] Output) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Print (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Print(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member Print : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Print (FileNumber, Output)" />
      <MemberSignature Language="ILAsm" Value=".method public static void Print(int32 FileNumber, object[] Output) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="net-5.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="Output">Optional. 0 (null) oder mehrere durch Trennzeichen getrennte Ausdrücke, die in eine Datei geschrieben werden sollen.  
  
Die <paramref name="Output" />-Argumenteinstellungen lauten: 
 <see langword="T:System.IO.IOException" />: Dateimodus ist ungültig.  
  
 <see langword="T:System.IO.IOException" />: <paramref name="FileNumber" /> existiert nicht.</param>
        <summary>Schreibt für die Anzeige formatierte Daten in eine sequenzielle Datei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Funktionen `Print` und `PrintLine` werden aus Gründen der Abwärtskompatibilität bereitgestellt und können sich auf die Leistung auswirken. Bei nicht Legacy Anwendungen bietet das `My.Computer.FileSystem`-Objekt eine bessere Leistung. Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access).  
  
 `Print` enthält keinen Zeilenvorschub am Ende einer Zeile. `PrintLine` enthält jedoch einen Zeilenvorschub.  
  
 Mit `Print` geschriebene Daten werden in der Regel mithilfe von `LineInput` oder `Input`aus einer Datei gelesen.  
  
 Wenn Sie `Output` für `PrintLine`weglassen, wird eine leere Zeile in die Datei ausgegeben. für `Print`wird nichts ausgegeben. Mehrere durch ein Komma getrennte Ausdrücke werden an den Registerkarten Grenzen ausgerichtet, aber das Mischen von Kommas und `TAB` kann zu inkonsistenten Ergebnissen führen.  
  
 Bei `Boolean` Daten werden entweder `True` oder `False` gedruckt. Die Schlüsselwörter "`True`" und "`False`" werden nicht übersetzt, unabhängig vom Gebiets Schema.  
  
 Datumsdaten werden in die Datei geschrieben, indem das standardmäßige kurze Datumsformat verwendet wird, das von Ihrem System erkannt wird. Wenn entweder das Datum oder die Uhrzeit Komponente fehlt oder 0 (null) ist, wird nur der angegebene Teil in die Datei geschrieben.  
  
 Wenn `Output` Daten leer sind, werden keine Daten in die Datei geschrieben. Wenn `Output` Listen Daten jedoch `DBNull`werden, wird `Null` in die Datei geschrieben.  
  
 Bei `Error` Daten wird die Ausgabe als `Error errorcode`angezeigt. Das `Error`-Schlüsselwort wird unabhängig vom Gebiets Schema nicht übersetzt.  
  
 Alle Daten, die mit `Print` in die Datei geschrieben werden, sind International. Das heißt, die Daten werden ordnungsgemäß mit dem entsprechenden Dezimaltrennzeichen formatiert. Wenn der Benutzerdaten für die Verwendung durch mehrere Gebiets Schemas ausgeben möchte, sollten `Write` verwendet werden.  
  
 Zum Schreiben in eine Datei mithilfe der Funktionen `Print` oder `PrintLine` ist `Write` Zugriff von der `FileIOPermissionAccess`-Enumeration erforderlich. Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 In diesem Beispiel werden die Funktionen `Print` und `PrintLine` verwendet, um Daten in eine Datei zu schreiben.  
  
 [!code-vb[VbVbalrCatRef#53](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#53)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access">Dateizugriff mit Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files">Gewusst wie: Schreiben von Text in Dateien in Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter">Gewusst wie: Schreiben von Text in eine Datei mit einem StreamWriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="PrintLine">
      <MemberSignature Language="C#" Value="public static void PrintLine (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PrintLine(int32 FileNumber, object[] Output) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub PrintLine (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PrintLine(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member PrintLine : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.PrintLine (FileNumber, Output)" />
      <MemberSignature Language="ILAsm" Value=".method public static void PrintLine(int32 FileNumber, object[] Output) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="net-5.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="Output">Optional. 0 (null) oder mehrere durch Trennzeichen getrennte Ausdrücke, die in eine Datei geschrieben werden sollen.  
  
Die <paramref name="Output" />-Argumenteinstellungen lauten: 
 <see langword="T:System.IO.IOException" />: Dateimodus ist ungültig.  
  
 <see langword="T:System.IO.IOException" />: <paramref name="FileNumber" /> existiert nicht.</param>
        <summary>Schreibt für die Anzeige formatierte Daten in eine sequenzielle Datei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Funktionen `Print` und `PrintLine` werden aus Gründen der Abwärtskompatibilität bereitgestellt und können sich auf die Leistung auswirken. Bei nicht Legacy Anwendungen bietet das `My.Computer.FileSystem`-Objekt eine bessere Leistung. Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access).  
  
 `Print` enthält keinen Zeilenvorschub am Ende einer Zeile.`PrintLine` enthält jedoch einen Zeilenvorschub.  
  
 Mit `Print` geschriebene Daten werden in der Regel mithilfe von `LineInput` oder `Input`aus einer Datei gelesen.  
  
 Wenn Sie `Output` für `PrintLine`weglassen, wird eine leere Zeile in die Datei ausgegeben. für `Print`wird nichts ausgegeben. Mehrere durch ein Komma getrennte Ausdrücke werden an den Registerkarten Grenzen ausgerichtet, aber das Mischen von Kommas und `TAB` kann zu inkonsistenten Ergebnissen führen.  
  
 Bei `Boolean` Daten werden entweder `True` oder `False` gedruckt. Die Schlüsselwörter "`True`" und "`False`" werden nicht übersetzt, unabhängig vom Gebiets Schema.  
  
 Datumsdaten werden in die Datei geschrieben, indem das standardmäßige kurze Datumsformat verwendet wird, das vom System erkannt wird. Wenn entweder das Datum oder die Uhrzeit Komponente fehlt oder 0 (null) ist, wird nur der angegebene Teil in die Datei geschrieben.  
  
 Wenn `Output` Daten leer sind, werden keine Daten in die Datei geschrieben. Wenn `Output` Listen Daten jedoch `DBNull`werden, wird `Null` in die Datei geschrieben.  
  
 Bei `Error` Daten wird die Ausgabe als `Error errorcode`angezeigt. Das `Error`-Schlüsselwort wird unabhängig vom Gebiets Schema nicht übersetzt.  
  
 Alle Daten, die mit `Print` in die Datei geschrieben werden, sind International. Das heißt, die Daten werden ordnungsgemäß mit dem entsprechenden Dezimaltrennzeichen formatiert. Wenn der Benutzerdaten für die Verwendung durch mehrere Gebiets Schemas ausgeben möchte, sollten `Write` verwendet werden.  
  
 Zum Schreiben in eine Datei mithilfe der Funktionen `Print` oder `PrintLine` ist `Write` Zugriff von der `FileIOPermissionAccess`-Enumeration erforderlich. Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 In diesem Beispiel werden die Funktionen `Print` und `PrintLine` verwendet, um Daten in eine Datei zu schreiben.  
  
 [!code-vb[VbVbalrCatRef#53](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#53)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access">Dateizugriff mit Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files">Gewusst wie: Schreiben von Text in Dateien in Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter">Gewusst wie: Schreiben von Text in eine Datei mit einem StreamWriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Rename">
      <MemberSignature Language="C#" Value="public static void Rename (string OldPath, string NewPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Rename(string OldPath, string NewPath) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Rename (OldPath As String, NewPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Rename(System::String ^ OldPath, System::String ^ NewPath);" />
      <MemberSignature Language="F#" Value="static member Rename : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Rename (OldPath, NewPath)" />
      <MemberSignature Language="ILAsm" Value=".method public static void Rename(string OldPath, string NewPath) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="OldPath" Type="System.String" />
        <Parameter Name="NewPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="OldPath">Erforderlich. Ein Zeichenfolgenausdruck, der den Namen und den Speicherort der vorhandenen Datei angibt. <paramref name="OldPath" /> kann das Verzeichnis und das Laufwerk der Datei beinhalten.</param>
        <param name="NewPath">Erforderlich. Ein Zeichenfolgenausdruck, der den Namen und den Speicherort der neuen Datei angibt. <paramref name="NewPath" /> kann das Verzeichnis und das Laufwerk des Zielspeicherorts beinhalten. Der durch <paramref name="NewPath" /> angegebene Dateiname darf noch nicht vorhanden sein.</param>
        <summary>Benennt eine Datenträgerdatei oder ein Verzeichnis um. Die <see langword="My" />-Funktion bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="Rename" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die`Rename`-Funktion benennt eine Datei um und verschiebt Sie in ein anderes Verzeichnis, falls dies erforderlich ist. Die `Rename`-Funktion kann eine Datei über Laufwerke hinweg verschieben, aber Sie kann nur ein vorhandenes Verzeichnis umbenennen, wenn sich sowohl `NewPath` als auch `OldPath` auf demselben Laufwerk befinden. `Rename` kann keine neue Datei oder ein neues Verzeichnis erstellen.  
  
 Wenn die `Rename`-Funktion für eine geöffnete Datei verwendet wird, tritt ein Fehler auf. Sie müssen eine geöffnete Datei schließen, bevor Sie Sie umbenennen. `Rename` Argumente dürfen nicht mehr als Platzhalter (*) und Einzelzeichen (?) enthalten.  
  
> [!IMPORTANT]
>  Wenn Sie `Rename` verwenden, um eine Datei von einem ungeschützten Speicherort an einen geschützten Speicherort zu kopieren, behält die Datei die weniger eingeschränkten Rechte bei. Stellen Sie sicher, dass Sie kein mögliches Sicherheitsrisiko einführen.  
  
   
  
## Examples  
 In diesem Beispiel wird die `Rename`-Funktion verwendet, um eine Datei umzubenennen. Nehmen Sie für die Zwecke dieses Beispiels an, dass die angegebenen Verzeichnisse bereits vorhanden sind.  
  
 [!code-vb[VbVbalrCatRef#30](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#30)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist ungültig.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die <paramref name="OldPath" />-Datei ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Kann nicht auf anderes Gerät umbenannt werden.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-rename-a-file">Gewusst wie: Umbenennen einer Datei in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public static void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reset() cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Reset();" />
      <MemberSignature Language="F#" Value="static member Reset : unit -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Reset " />
      <MemberSignature Language="ILAsm" Value=".method public static void Reset() cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Schließt alle mit der <see langword="FileOpen" />-Funktion geöffneten Datenträgerdateien. Die <see langword="My" />-Funktion bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="Reset" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Reset`-Funktion schließt alle aktiven Dateien, die von der `FileOpen`-Funktion geöffnet wurden, und hat dieselbe Funktion wie `FileClose()` ohne Parameter.  
  
   
  
## Examples  
 In diesem Beispiel werden die `Reset`-Funktion verwendet, um alle geöffneten Dateien zu schließen und den Inhalt aller Datei Puffer auf den Datenträger zu schreiben. Beachten Sie die Verwendung der `Object` Variablen `FileNumber` sowohl als Zeichenfolge als auch als Zahl.  
  
 [!code-vb[VbVbalrCatRef#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#12)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <related type="Article" href="/dotnet/visual-basic/language-reference/statements/end-statement">End Statement</related>
      </Docs>
    </Member>
    <Member MemberName="RmDir">
      <MemberSignature Language="C#" Value="public static void RmDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RmDir(string Path) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RmDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RmDir(System::String ^ Path);" />
      <MemberSignature Language="F#" Value="static member RmDir : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.RmDir Path" />
      <MemberSignature Language="ILAsm" Value=".method public static void RmDir(string Path) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">Erforderlich. Ein Zeichenfolgenausdruck, der das zu entfernende Verzeichnis oder den zu entfernenden Ordner angibt. <paramref name="Path" /> kann das Laufwerk enthalten. Wenn kein Laufwerk angegeben wird, entfernt <see langword="RmDir" /> das Verzeichnis vom aktuellen Laufwerk.</param>
        <summary>Entfernt ein vorhandenes Verzeichnis. Die <see langword="My" />-Funktion bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="RmDir" />. Weitere Informationen finden Sie unter <see cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie versuchen, `RmDir` in einem Verzeichnis zu verwenden, das Dateien enthält, tritt ein Fehler auf. Verwenden Sie die `Kill`-Funktion, um alle Dateien zu löschen, bevor Sie versuchen, ein Verzeichnis zu entfernen.  
  
   
  
## Examples  
 In diesem Beispiel wird die `RmDir`-Funktion verwendet, um ein vorhandenes Verzeichnis zu entfernen.  
  
 [!code-vb[VbVbalrCatRef#31](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#31)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="Path" /> ist nicht angegeben oder leer.</exception>
        <exception cref="T:System.IO.IOException">Zielverzeichnis enthält Dateien.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Verzeichnis ist nicht vorhanden.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Seek">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt einen <see langword="Long" />-Wert zurück, der die aktuelle Lese-/Schreibposition innerhalb einer mithilfe der <see langword="FileOpen" />-Funktion geöffneten Datei angibt, oder legt die Position des nächsten Lese-/Schreibvorgangs innerhalb einer mithilfe der <see langword="FileOpen" />-Funktion geöffneten Datei fest. Die <see langword="My" />-Funktion bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="Seek" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public static long Seek (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Seek(int32 FileNumber) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Seek (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Seek(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Seek : int -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.Seek FileNumber" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 Seek(int32 FileNumber) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Ein <see langword="Integer" /> mit einer gültigen Dateinummer.</param>
        <summary>Gibt einen <see langword="Long" />-Wert zurück, der die aktuelle Lese-/Schreibposition innerhalb einer mithilfe der <see langword="FileOpen" />-Funktion geöffneten Datei angibt, oder legt die Position des nächsten Lese-/Schreibvorgangs innerhalb einer mithilfe der <see langword="FileOpen" />-Funktion geöffneten Datei fest. Die <see langword="My" />-Funktion bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="Seek" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <returns>Ein <see langword="Long" />-Wert, der die aktuelle Lese-/Schreibposition innerhalb einer mithilfe der <see langword="FileOpen" />-Funktion geöffneten Datei angibt oder die Position des nächsten Lese-/Schreibvorgangs innerhalb einer mithilfe der <see langword="FileOpen" />-Funktion geöffneten Datei festlegt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Seek` gibt einen Wert zwischen 1 und 2.147.483.647 (äquivalent zu 2 ^ 31-1) (einschließlich) zurück.  
  
 Im folgenden werden die Rückgabewerte für die einzelnen Datei Zugriffs Modi beschrieben:  
  
|Mode|Rückgabewert|  
|-|-|  
|`Random`|Nummer des nächsten gelesenen oder geschriebenen Datensatzes|  
|`Binary`, `Input`, `Output`, `Append`|Die Byte Position, an der der nächste Vorgang auftritt. Das erste Byte in einer Datei befindet sich an Position 1, das zweite Byte an Position 2 usw.|  
  
   
  
## Examples  
 In diesem Beispiel wird die `Seek`-Funktion verwendet, um die aktuelle Dateiposition zurückzugeben. Im Beispiel wird davon ausgegangen, `TestFile` eine Datei ist, die Datensätze der Struktur `Record`enthält.  
  
 [!code-vb[VbVbalrCatRef#47](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#47)]  
  
 Bei Dateien, die im `Random` Modus geöffnet werden, gibt `Seek` die Anzahl der nächsten Datensätze zurück.  
  
 [!code-vb[VbVbalrCatRef#48](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#48)]  
  
 Bei Dateien, die in anderen Modi als `Random` Modus geöffnet sind, gibt `Seek` die Byte Position zurück, an der der nächste Vorgang auftritt. Angenommen, `TestFile` eine Datei ist, die mehrere Textzeilen enthält.  
  
 [!code-vb[VbVbalrCatRef#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#49)]  
  
 In diesem Beispiel wird die-`Seek` Funktion verwendet, um die Position für den nächsten Lese-oder Schreibvorgang in einer Datei festzulegen.  
  
 Bei Dateien, die in anderen Modi als `Random` Modus geöffnet sind, legt `Seek` die Byte Position fest, an der der nächste Vorgang auftritt. Angenommen, `TestFile` eine Datei ist, die mehrere Textzeilen enthält.  
  
 [!code-vb[VbVbalrCatRef#52](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files">Lesen aus Dateien in Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files">Schreiben in Dateien in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public static void Seek (int FileNumber, long Position);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Seek(int32 FileNumber, int64 Position) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Seek (FileNumber As Integer, Position As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Seek(int FileNumber, long Position);" />
      <MemberSignature Language="F#" Value="static member Seek : int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Seek (FileNumber, Position)" />
      <MemberSignature Language="ILAsm" Value=".method public static void Seek(int32 FileNumber, int64 Position) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Position" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Ein <see langword="Integer" /> mit einer gültigen Dateinummer.</param>
        <param name="Position">Erforderlich. Eine Zahl im Bereich 1–2.147.483.647 einschließlich, die angibt, wo die nächste Lese-/Schreiboperation erfolgen soll.</param>
        <summary>Gibt einen <see langword="Long" />-Wert zurück, der die aktuelle Lese-/Schreibposition innerhalb einer mithilfe der <see langword="FileOpen" />-Funktion geöffneten Datei angibt, oder legt die Position des nächsten Lese-/Schreibvorgangs innerhalb einer mithilfe der <see langword="FileOpen" />-Funktion geöffneten Datei fest. Die <see langword="My" />-Funktion bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="Seek" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Seek` gibt einen Wert zwischen 1 und 2.147.483.647 (äquivalent zu 2 ^ 31-1) (einschließlich) zurück.  
  
 Im folgenden werden die Rückgabewerte für die einzelnen Datei Zugriffs Modi beschrieben:  
  
|Mode|Rückgabewert|  
|-|-|  
|`Random`|Nummer des nächsten gelesenen oder geschriebenen Datensatzes|  
|`Binary`, `Input`, `Output`, `Append`|Die Byte Position, an der der nächste Vorgang auftritt. Das erste Byte in einer Datei befindet sich an Position 1, das zweite Byte an Position 2 usw.|  
  
   
  
## Examples  
 In diesem Beispiel wird die `Seek`-Funktion verwendet, um die aktuelle Dateiposition zurückzugeben. Im Beispiel wird davon ausgegangen, `TestFile` eine Datei ist, die Datensätze der Struktur `Record`enthält.  
  
 [!code-vb[VbVbalrCatRef#47](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#47)]  
  
 Bei Dateien, die im `Random` Modus geöffnet werden, gibt `Seek` die Anzahl der nächsten Datensätze zurück.  
  
 [!code-vb[VbVbalrCatRef#48](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#48)]  
  
 Bei Dateien, die in anderen Modi als `Random` Modus geöffnet sind, gibt `Seek` die Byte Position zurück, an der der nächste Vorgang auftritt. Angenommen, `TestFile` eine Datei ist, die mehrere Textzeilen enthält.  
  
 [!code-vb[VbVbalrCatRef#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#49)]  
  
 In diesem Beispiel wird die-`Seek` Funktion verwendet, um die Position für den nächsten Lese-oder Schreibvorgang in einer Datei festzulegen.  
  
 Bei Dateien, die in anderen Modi als `Random` Modus geöffnet sind, legt `Seek` die Byte Position fest, an der der nächste Vorgang auftritt. Angenommen, `TestFile` eine Datei ist, die mehrere Textzeilen enthält.  
  
 [!code-vb[VbVbalrCatRef#52](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files">Lesen aus Dateien in Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files">Schreiben in Dateien in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="SetAttr">
      <MemberSignature Language="C#" Value="public static void SetAttr (string PathName, Microsoft.VisualBasic.FileAttribute Attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetAttr(string PathName, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAttr (PathName As String, Attributes As FileAttribute)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetAttr(System::String ^ PathName, Microsoft::VisualBasic::FileAttribute Attributes);" />
      <MemberSignature Language="F#" Value="static member SetAttr : string * Microsoft.VisualBasic.FileAttribute -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.SetAttr (PathName, Attributes)" />
      <MemberSignature Language="ILAsm" Value=".method public static void SetAttr(string PathName, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
        <Parameter Name="Attributes" Type="Microsoft.VisualBasic.FileAttribute" />
      </Parameters>
      <Docs>
        <param name="PathName">Erforderlich. Ein Zeichenfolgenausdruck, der einen Dateinamen angibt. <paramref name="PathName" /> kann auch das Verzeichnis oder den Ordner sowie das Laufwerk beinhalten.</param>
        <param name="Attributes">Erforderlich. Konstanter oder numerischer Ausdruck, dessen Summe Dateiattribute angibt.</param>
        <summary>Legt Attributinformationen für eine Datei fest. Die <see langword="My" />-Funktion bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="SetAttr" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Laufzeitfehler tritt auf, wenn Sie versuchen, die Attribute einer geöffneten Datei festzulegen.  
  
 Die `Attributes` Argument-Enumerationswerte lauten wie folgt:  
  
|value|Dauerhaft|BESCHREIBUNG|  
|-|-|-|  
|`Normal`|`vbNormal`|Normal (Standard).|  
|`ReadOnly`|`vbReadOnly`|Schreibgeschützt.|  
|`Hidden`|`vbHidden`|Hidden.|  
|`System`|`vbSystem`|Systemdatei.|  
|`Volume`|`vbVolume`|Volumebezeichnung|  
|`Directory`|`vbDirectory`|Verzeichnis oder Ordner.|  
|`Archive`|`vbArchive`|Die Datei wurde nach der letzten Sicherung geändert.|  
|`Alias`|`vbAlias`|Die Datei hat einen anderen Namen.|  
  
> [!NOTE]
>  Diese Enumerationen werden von der Programmiersprache Visual Basic angegeben. Die Namen können an beliebiger Stelle im Code anstelle der tatsächlichen Werte verwendet werden.  
  
   
  
## Examples  
 In diesem Beispiel wird die `SetAttr`-Funktion verwendet, um Attribute für eine Datei festzulegen.  
  
 [!code-vb[VbVbalrCatRef#14](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="Attribute" />-Typ ist ungültig.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />
      </Docs>
    </Member>
    <Member MemberName="SPC">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.SpcInfo SPC (short Count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.VisualBasic.SpcInfo SPC(int16 Count) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function SPC (Count As Short) As SpcInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::SpcInfo SPC(short Count);" />
      <MemberSignature Language="F#" Value="static member SPC : int16 -&gt; Microsoft.VisualBasic.SpcInfo" Usage="Microsoft.VisualBasic.FileSystem.SPC Count" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.SpcInfo SPC(int16 Count) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.SpcInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Count" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="Count">Erforderlich. Die Anzahl von Leerzeichen, die vor dem Anzeigen oder Ausgeben des nächsten Ausdrucks in einer Liste eingefügt werden sollen.</param>
        <summary>Wird mit der <see langword="Print" />-Funktion oder der <see langword="PrintLine" />-Funktion zum Positionieren der Ausgabe verwendet.</summary>
        <returns>Wird mit der <see langword="Print" />-Funktion oder der <see langword="PrintLine" />-Funktion zum Positionieren der Ausgabe verwendet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `Count` kleiner als die Ausgabe Linienbreite ist, folgt die nächste Druckposition direkt der Anzahl der gedruckten Leerzeichen. Wenn`Count` größer als die Ausgabe Linienbreite ist, berechnet `SPC` die nächste Druckposition mithilfe der Formel:  
  
 `currentprintposition`(+ (`Count``Mod``width`))  
  
 Wenn die aktuelle Druckposition z. b. 24 ist, wird die Ausgabe Linienbreite 80, und Sie geben `SPC(90)`an, der nächste Druck beginnt an der Position 34 (aktuelle Druckposition + Restwert 90/80). Wenn der Unterschied zwischen der aktuellen Druckposition und der Ausgabe Linienbreite kleiner als `Count` (oder `Count` `Mod` *Width*) ist, springt die `SPC` Funktion bis zum Anfang der nächsten Zeile und generiert Leerzeichen, die `Count`-(*Width* - *currentprintposition*) liegen.  
  
> [!NOTE]
>  Stellen Sie sicher, dass die tabellarischen Spalten breit genug sind, um große Buchstaben zuzulassen.  
  
   
  
## Examples  
 In diesem Beispiel wird die `SPC`-Funktion verwendet, um die Ausgabe in einer Datei und im **Ausgabe** Fenster zu positionieren.  
  
 [!code-vb[VbVbalrCatRef#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
        <related type="Article" href="/dotnet/visual-basic/language-reference/operators/mod-operator">Operator Mod(Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TAB">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wird mit der <see langword="Print" />-Funktion oder der <see langword="PrintLine" />-Funktion zum Positionieren der Ausgabe verwendet.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TAB">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.TabInfo TAB ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.VisualBasic.TabInfo TAB() cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.TAB" />
      <MemberSignature Language="VB.NET" Value="Public Function TAB () As TabInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::TabInfo TAB();" />
      <MemberSignature Language="F#" Value="static member TAB : unit -&gt; Microsoft.VisualBasic.TabInfo" Usage="Microsoft.VisualBasic.FileSystem.TAB " />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.TabInfo TAB() cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.TabInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wird mit der <see langword="Print" />-Funktion oder der <see langword="PrintLine" />-Funktion zum Positionieren der Ausgabe verwendet.</summary>
        <returns>Wird mit der <see langword="Print" />-Funktion oder der <see langword="PrintLine" />-Funktion zum Positionieren der Ausgabe verwendet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die aktuelle Druckposition in der aktuellen Zeile größer als `Column`ist, überspringt `TAB` den Spaltenwert, der `Column` in der nächsten Ausgabezeile entspricht. Wenn `Column` kleiner als 1 ist, verschiebt `TAB` die Druckposition in die Spalte 1. Wenn `Column` größer als die Ausgabe Linienbreite ist, berechnet `TAB` die nächste Druckposition mithilfe der Formel:  
  
 Breite der Spalten-mod  
  
 Wenn die *Breite* beispielsweise 80 lautet und Sie `TAB(90)`angeben, beginnt der nächste Druck bei der Spalte 10 (der Rest 90/80). Wenn `Column` kleiner als die aktuelle Druckposition ist, wird der Druckvorgang in der nächsten Zeile an der berechneten Druckposition gestartet. Wenn die berechnete Druckposition größer als die aktuelle Druckposition ist, beginnt der Druckvorgang an der berechneten Druckposition in derselben Zeile.  
  
 Die linke Druckposition in einer Ausgabezeile ist immer 1. Wenn Sie die `Print`-oder `PrintLine`-Funktionen zum Drucken in Dateien verwenden, ist die äußteste Druckposition die aktuelle Breite der Ausgabedatei, die Sie mit der `FileWidth`-Funktion festlegen können.  
  
 Die `TAB`-Funktion kann auch mit der `WriteLine`-Funktion verwendet werden. Sie kann nicht mit <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType> oder <xref:System.Console.WriteLine%2A?displayProperty=nameWithType>verwendet werden.  
  
> [!NOTE]
>  Stellen Sie sicher, dass die tabellarischen Spalten breit genug sind, um große Buchstaben aufzunehmen.  
  
   
  
## Examples  
 In diesem Beispiel wird die `TAB`-Funktion verwendet, um die Ausgabe in einer Datei und im **Ausgabe** Fenster zu positionieren.  
  
 [!code-vb[VbVbalrCatRef#37](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#37)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
        <related type="Article" href="/dotnet/visual-basic/language-reference/operators/mod-operator">Operator Mod(Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="TAB">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.TabInfo TAB (short Column);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.VisualBasic.TabInfo TAB(int16 Column) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.TAB(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function TAB (Column As Short) As TabInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::TabInfo TAB(short Column);" />
      <MemberSignature Language="F#" Value="static member TAB : int16 -&gt; Microsoft.VisualBasic.TabInfo" Usage="Microsoft.VisualBasic.FileSystem.TAB Column" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.TabInfo TAB(int16 Column) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.TabInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Column" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="Column">Optional. Die Spaltennummer, zu der vor dem Anzeigen oder Drucken des nächsten Ausdrucks in einer Liste gewechselt wird. Wenn der Wert nicht angegeben wird, verschiebt <see langword="TAB" /> die Einfügemarke an den Anfang der nächsten Ausgabezone.</param>
        <summary>Wird mit der <see langword="Print" />-Funktion oder der <see langword="PrintLine" />-Funktion zum Positionieren der Ausgabe verwendet.</summary>
        <returns>Wird mit der <see langword="Print" />-Funktion oder der <see langword="PrintLine" />-Funktion zum Positionieren der Ausgabe verwendet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die aktuelle Druckposition in der aktuellen Zeile größer als `Column`ist, überspringt `TAB` den Spaltenwert, der `Column` in der nächsten Ausgabezeile entspricht. Wenn `Column` kleiner als 1 ist, verschiebt `TAB` die Druckposition in die Spalte 1. Wenn `Column` größer als die Ausgabe Linienbreite ist, berechnet `TAB` die nächste Druckposition mithilfe der Formel:  
  
 Breite der Spalten-mod  
  
 Wenn die *Breite* beispielsweise 80 lautet und Sie `TAB(90)`angeben, beginnt der nächste Druck bei der Spalte 10 (der Rest 90/80). Wenn `Column` kleiner als die aktuelle Druckposition ist, wird der Druckvorgang in der nächsten Zeile an der berechneten Druckposition gestartet. Wenn die berechnete Druckposition größer als die aktuelle Druckposition ist, beginnt der Druckvorgang an der berechneten Druckposition in derselben Zeile.  
  
 Die linke Druckposition in einer Ausgabezeile ist immer 1. Wenn Sie die `Print`-oder `PrintLine`-Funktionen zum Drucken in Dateien verwenden, ist die äußteste Druckposition die aktuelle Breite der Ausgabedatei, die Sie mit der `FileWidth`-Funktion festlegen können.  
  
 Die `TAB`-Funktion kann auch mit der `WriteLine`-Funktion verwendet werden. Sie kann nicht mit <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType> oder <xref:System.Console.WriteLine%2A?displayProperty=nameWithType>verwendet werden.  
  
> [!NOTE]
>  Stellen Sie sicher, dass die tabellarischen Spalten breit genug sind, um große Buchstaben aufzunehmen.  
  
   
  
## Examples  
 In diesem Beispiel wird die `TAB`-Funktion verwendet, um die Ausgabe in einer Datei und im **Ausgabe** Fenster zu positionieren.  
  
 [!code-vb[VbVbalrCatRef#37](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#37)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
        <related type="Article" href="/dotnet/visual-basic/language-reference/operators/mod-operator">Operator Mod(Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Unlock">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Steuert den Zugriff durch andere Prozesse auf die gesamte mithilfe der <see langword="Open" />-Funktion geöffnete Datei oder einen Teil davon. Das <see langword="My" />-Feature ermöglicht bei Datei-E/A-Vorgängen höhere Produktivität und Leistung als <see langword="Lock" /> und <see langword="Unlock" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Unlock(int32 FileNumber) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Unlock : int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Unlock FileNumber" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <summary>Steuert den Zugriff durch andere Prozesse auf die gesamte mithilfe der <see langword="Open" />-Funktion geöffnete Datei oder einen Teil davon. Das <see langword="My" />-Feature ermöglicht bei Datei-E/A-Vorgängen höhere Produktivität und Leistung als <see langword="Lock" /> und <see langword="Unlock" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Funktionen `Lock` und `Unlock` werden in Umgebungen verwendet, in denen mehrere Prozesse möglicherweise auf dieselbe Datei zugreifen müssen.  
  
 die Funktionen `Lock` und `Unlock` werden immer paarweise verwendet. Die Argumente für `Lock` und `Unlock` müssen identisch sein.  
  
 Wenn `Record`oder `FromRecord` und `ToRecord` nicht bereitgestellt werden, wird die Sperre für die gesamte Datei verwendet. Wenn `Record` allein angegeben ist, wird der einzelne Datensatz gesperrt/entsperrt.  
  
 Wenn die Datei für die sequenzielle Eingabe oder Ausgabe geöffnet wurde, `Lock` und `Unlock` sich auf die gesamte Datei auswirken, unabhängig von dem durch `FromRecord` und`ToRecord`angegebenen Bereich.  
  
   
  
## Examples  
 Dieses Beispiel veranschaulicht die Verwendung der Funktionen `Lock` und `Unlock`. In diesem Beispiel wird davon ausgegangen, dass `People.txt` eine Datei ist, die Datensätze der Struktur `Person`enthält.  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access">Dateizugriff mit Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber, long Record);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Unlock(int32 FileNumber, int64 Record) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer, Record As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber, long Record);" />
      <MemberSignature Language="F#" Value="static member Unlock : int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Unlock (FileNumber, Record)" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber, int64 Record) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Record" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="Record">Optional. Die Nummer des einzigen zu sperrenden oder zu entsperrenden Datensatzes.</param>
        <summary>Steuert den Zugriff durch andere Prozesse auf die gesamte mithilfe der <see langword="Open" />-Funktion geöffnete Datei oder einen Teil davon. Das <see langword="My" />-Feature ermöglicht bei Datei-E/A-Vorgängen höhere Produktivität und Leistung als <see langword="Lock" /> und <see langword="Unlock" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Funktionen `Lock` und `Unlock` werden in Umgebungen verwendet, in denen mehrere Prozesse möglicherweise auf dieselbe Datei zugreifen müssen.  
  
 die Funktionen `Lock` und `Unlock` werden immer paarweise verwendet. Die Argumente für `Lock` und `Unlock` müssen identisch sein.  
  
 Wenn `Record`oder `FromRecord` und `ToRecord` nicht bereitgestellt werden, wird die Sperre für die gesamte Datei verwendet. Wenn `Record` allein angegeben ist, wird der einzelne Datensatz gesperrt/entsperrt.  
  
 Wenn die Datei für die sequenzielle Eingabe oder Ausgabe geöffnet wurde, `Lock` und `Unlock` sich auf die gesamte Datei auswirken, unabhängig von dem durch `FromRecord` und`ToRecord`angegebenen Bereich.  
  
   
  
## Examples  
 Dieses Beispiel veranschaulicht die Verwendung der Funktionen `Lock` und `Unlock`. In diesem Beispiel wird davon ausgegangen, dass `People.txt` eine Datei ist, die Datensätze der Struktur `Person`enthält.  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access">Dateizugriff mit Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Unlock(int32 FileNumber, int64 FromRecord, int64 ToRecord) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer, FromRecord As Long, ToRecord As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="F#" Value="static member Unlock : int * int64 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Unlock (FileNumber, FromRecord, ToRecord)" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber, int64 FromRecord, int64 ToRecord) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FromRecord" Type="System.Int64" />
        <Parameter Name="ToRecord" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="FromRecord">Optional. Die Nummer des ersten zu sperrenden oder zu entsperrenden Datensatzes.</param>
        <param name="ToRecord">Optional. Die Nummer des letzten zu sperrenden oder zu entsperrenden Datensatzes.</param>
        <summary>Steuert den Zugriff durch andere Prozesse auf die gesamte mithilfe der <see langword="Open" />-Funktion geöffnete Datei oder einen Teil davon. Das <see langword="My" />-Feature ermöglicht bei Datei-E/A-Vorgängen höhere Produktivität und Leistung als <see langword="Lock" /> und <see langword="Unlock" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Funktionen `Lock` und `Unlock` werden in Umgebungen verwendet, in denen mehrere Prozesse möglicherweise auf dieselbe Datei zugreifen müssen.  
  
 die Funktionen `Lock` und `Unlock` werden immer paarweise verwendet. Die Argumente für `Lock` und `Unlock` müssen identisch sein.  
  
 Wenn `Record`oder `FromRecord` und `ToRecord` nicht bereitgestellt werden, wird die Sperre für die gesamte Datei verwendet. Wenn `Record` allein angegeben ist, wird der einzelne Datensatz gesperrt/entsperrt.  
  
 Wenn die Datei für die sequenzielle Eingabe oder Ausgabe geöffnet wurde, `Lock` und `Unlock` sich auf die gesamte Datei auswirken, unabhängig von dem durch `FromRecord` und`ToRecord`angegebenen Bereich.  
  
   
  
## Examples  
 Dieses Beispiel veranschaulicht die Verwendung der Funktionen `Lock` und `Unlock`. In diesem Beispiel wird davon ausgegangen, dass `People.txt` eine Datei ist, die Datensätze der Struktur `Person`enthält.  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access">Dateizugriff mit Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(int32 FileNumber, object[] Output) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member Write : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Write (FileNumber, Output)" />
      <MemberSignature Language="ILAsm" Value=".method public static void Write(int32 FileNumber, object[] Output) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="net-5.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Ein <see langword="Integer" />-Ausdruck, der eine beliebige gültige Dateinummer enthält.</param>
        <param name="Output">Optional. Ein Ausdruck oder mehrere, durch Trennzeichen getrennte Ausdrücke, die in eine Datei geschrieben werden sollen.</param>
        <summary>Schreibt Daten in eine sequenzielle Datei. Mit <see langword="Write" /> geschriebene Daten werden in der Regel mit <see langword="Input" /> aus einer Datei gelesen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Funktionen `Write` und `WriteLine` werden aus Gründen der Abwärtskompatibilität bereitgestellt und können sich auf die Leistung auswirken. Bei nicht Legacy Anwendungen bietet das `My.Computer.FileSystem`-Objekt eine bessere Leistung. Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access).  
  
 Wenn Sie `Output`weglassen, wird eine leere Zeile in die Datei ausgegeben. Mehrere Ausdrücke können durch ein Komma getrennt werden.  
  
 Anders als die `Print`-Funktion fügt die `Write`-Funktion Kommas zwischen Elementen und Anführungszeichen ein, wenn Sie in die Datei geschrieben werden. Sie müssen keine expliziten Trennzeichen in der Liste platzieren. Wenn `Write` zum Schreiben von Daten in eine Datei verwendet wird, werden nur die Datenformate numeric, `Boolean`, Date, NULL und `Error` unterstützt. Die folgenden universellen Annahmen sind befolgt, damit die Daten unabhängig vom Gebiets Schema stets mithilfe von `Input`gelesen und ordnungsgemäß interpretiert werden können:  
  
-   Numerische Daten werden immer mit dem Punkt als Dezimaltrennzeichen geschrieben.  
  
-   Bei `Boolean` Daten werden entweder `#TRUE#` oder `#FALSE#` gedruckt. Die Schlüsselwörter "`True`" und "`False`" werden nicht übersetzt, unabhängig vom Gebiets Schema.  
  
-   Datumsdaten werden mithilfe des universellen Datums Formats in die Datei geschrieben. Wenn entweder das Datum oder die Uhrzeit Komponente fehlt oder 0 (null) ist, wird nur der angegebene Teil in die Datei geschrieben.  
  
-   Wenn `Output` Daten leer sind, werden keine Daten in die Datei geschrieben. Bei NULL-Daten werden jedoch `#NULL#` geschrieben.  
  
-   Bei `Error` Daten wird die Ausgabe als `#ERROR errorcode#`angezeigt. Das `Error`-Schlüsselwort wird unabhängig vom Gebiets Schema nicht übersetzt.  
  
 `WriteLine` fügt ein Zeilenumbruch Zeichen (d. h. einen Wagen Rücklauf/Zeilenvorschub oder `Chr(13) + Chr(10)`) ein, nachdem das endgültige Zeichen in `Output` in die Datei geschrieben wurde.  
  
 Sie können Anführungszeichen in eine Zeichenfolge einbetten, indem Sie doppelte Anführungszeichen (oder "") verwenden. Beispiel:  
  
 [!code-vb[VbVbalrCatRef#63](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#63)]  
  
 gibt eine Zeichenfolge mit dem Wert `Double quotation marks aren't "difficult" to handle`zurück.  
  
 Zum Schreiben in eine Datei mithilfe der Funktionen `Write` oder `WriteLine` ist `Append` Zugriff von der `FileIOPermissionAccess`-Enumeration erforderlich. Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 In diesem Beispiel wird die `Write`-Funktion verwendet, um Rohdaten in eine sequenzielle Datei zu schreiben.  
  
 [!code-vb[VbVbalrCatRef#64](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#64)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access">Dateizugriff mit Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files">Gewusst wie: Schreiben von Text in Dateien in Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter">Gewusst wie: Schreiben von Text in eine Datei mit einem StreamWriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(int32 FileNumber, object[] Output) cil managed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteLine (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member WriteLine : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.WriteLine (FileNumber, Output)" />
      <MemberSignature Language="ILAsm" Value=".method public static void WriteLine(int32 FileNumber, object[] Output) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
        <AssemblyVersion>10.0.5.0</AssemblyVersion>
        <AssemblyVersion>10.0.6.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="net-5.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Ein <see langword="Integer" />-Ausdruck, der eine beliebige gültige Dateinummer enthält.</param>
        <param name="Output">Optional. Ein Ausdruck oder mehrere, durch Trennzeichen getrennte Ausdrücke, die in eine Datei geschrieben werden sollen.</param>
        <summary>Schreibt Daten in eine sequenzielle Datei. Mit <see langword="Write" /> geschriebene Daten werden in der Regel mit <see langword="Input" /> aus einer Datei gelesen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Funktionen `Write` und `WriteLine` werden aus Gründen der Abwärtskompatibilität bereitgestellt und können sich auf die Leistung auswirken. Bei nicht Legacy Anwendungen bietet das `My.Computer.FileSystem`-Objekt eine bessere Leistung. Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access).  
  
 Wenn Sie `Output`weglassen, wird eine leere Zeile in die Datei ausgegeben. Mehrere Ausdrücke können durch ein Komma getrennt werden.  
  
 Anders als die `Print`-Funktion fügt die `Write`-Funktion Kommas zwischen Elementen und Anführungszeichen ein, wenn Sie in die Datei geschrieben werden. Sie müssen keine expliziten Trennzeichen in der Liste platzieren. Wenn `Write` zum Schreiben von Daten in eine Datei verwendet wird, werden nur die Datenformate numeric, `Boolean`, Date, NULL und `Error` unterstützt. Die folgenden universellen Annahmen sind befolgt, damit die Daten unabhängig vom Gebiets Schema stets mithilfe von `Input`gelesen und ordnungsgemäß interpretiert werden können:  
  
-   Numerische Daten werden immer mit dem Punkt als Dezimaltrennzeichen geschrieben.  
  
-   Bei `Boolean` Daten werden entweder `#TRUE#` oder `#FALSE#` gedruckt. Die Schlüsselwörter "`True`" und "`False`" werden nicht übersetzt, unabhängig vom Gebiets Schema.  
  
-   Datumsdaten werden mithilfe des universellen Datums Formats in die Datei geschrieben. Wenn entweder das Datum oder die Uhrzeit Komponente fehlt oder 0 (null) ist, wird nur der angegebene Teil in die Datei geschrieben.  
  
-   Wenn `Output` Daten leer sind, werden keine Daten in die Datei geschrieben. Bei NULL-Daten werden jedoch `#NULL#` geschrieben.  
  
-   Bei `Error` Daten wird die Ausgabe als `#ERROR errorcode#`angezeigt. Das `Error`-Schlüsselwort wird unabhängig vom Gebiets Schema nicht übersetzt.  
  
 `WriteLine` fügt ein Zeilenumbruch Zeichen (d. h. einen Wagen Rücklauf/Zeilenvorschub oder `Chr(13) + Chr(10)`) ein, nachdem das endgültige Zeichen in `Output` in die Datei geschrieben wurde.  
  
 Sie können Anführungszeichen in eine Zeichenfolge einbetten, indem Sie doppelte Anführungszeichen (oder "") verwenden. Beispiel:  
  
 [!code-vb[VbVbalrCatRef#63](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#63)]  
  
 gibt eine Zeichenfolge mit dem Wert `Double quotation marks aren't "difficult" to handle`zurück.  
  
 Zum Schreiben in eine Datei mithilfe der Funktionen `Write` oder `WriteLine` ist `Append` Zugriff von der `FileIOPermissionAccess`-Enumeration erforderlich. Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 In diesem Beispiel wird die `Write`-Funktion verwendet, um Rohdaten in eine sequenzielle Datei zu schreiben.  
  
 [!code-vb[VbVbalrCatRef#64](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#64)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-access">Dateizugriff mit Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files">Gewusst wie: Schreiben von Text in Dateien in Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter">Gewusst wie: Schreiben von Text in eine Datei mit einem StreamWriter (Visual Basic)</related>
      </Docs>
    </Member>
  </Members>
</Type>
