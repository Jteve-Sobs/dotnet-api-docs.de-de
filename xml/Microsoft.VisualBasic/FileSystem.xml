<Type Name="FileSystem" FullName="Microsoft.VisualBasic.FileSystem">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="757b138ad08a57ad8a16b1f7210ead2e45005193" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36728095" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class FileSystem" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit FileSystem extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.VisualBasic.FileSystem" />
  <TypeSignature Language="VB.NET" Value="Public Module FileSystem" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileSystem sealed" />
  <TypeSignature Language="F#" Value="type FileSystem = class" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic</AssemblyName>
    <AssemblyVersion>10.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>Microsoft.VisualBasic.CompilerServices.StandardModule</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Security.SecurityCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>The <see langword="FileSystem" /> module contains the procedures that are used to perform file, directory or folder, and system operations. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than using the <see langword="FileSystem" /> module. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Modul unterstützt die Visual Basic-Schlüsselwörter und Laufzeit-Bibliothekscode-Elemente, die Zugriff auf Dateien und Ordner.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `GetAttr` -Funktion können Sie die Attribute einer Datei und das Verzeichnis oder die Ordner zu ermitteln.  
  
 [!code-vb[VbVbalrCatRef#25](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#25)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="ChDir">
      <MemberSignature Language="C#" Value="public static void ChDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDir(System::String ^ Path);" />
      <MemberSignature Language="F#" Value="static member ChDir : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.ChDir Path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">Required. A <see langword="String" /> expression that identifies which directory or folder becomes the new default directory or folder. <c>Path</c> may include the drive. If no drive is specified, <see langword="ChDir" /> changes the default directory or folder on the current drive.</param>
        <summary>Changes the current directory or folder. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than the <see langword="ChDir" /> function. For more information, see <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" /> .</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `ChDir` -Funktion ändert das Standardverzeichnis, aber nicht das Standardlaufwerk. Beispielsweise ist das Standard-Laufwerk C, die folgende Anweisung ändert das Standardverzeichnis auf Laufwerk D, C, bleibt das Standardlaufwerk jedoch:  
  
 [!code-vb[VbVbalrCatRef#39](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#39)]  
  
 Lassen Sie relative verzeichnisänderungen wird durch zwei Punkte wie folgt eingeben:  
  
 [!code-vb[VbVbalrCatRef#40](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#40)]  
  
> [!IMPORTANT]
>  Die `ChDir` -Funktion erfordert die Berechtigung für nicht verwalteten Code, die die Ausführung in teilweise vertrauenswürdigen Umgebungen beeinträchtigen können. Weitere Informationen finden Sie unter <xref:System.Security.Permissions.SecurityPermission> und.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `ChDir` Funktion, um das aktuelle Verzeichnis oder einen Ordner zu ändern.  
  
 [!code-vb[VbVbalrCatRef#41](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Path" /> is empty.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Invalid drive is specified, or drive is unavailable.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ChDrive">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Changes the current drive.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ChDrive">
      <MemberSignature Language="C#" Value="public static void ChDrive (char Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDrive(char Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDrive (Drive As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDrive(char Drive);" />
      <MemberSignature Language="F#" Value="static member ChDrive : char -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.ChDrive Drive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="Drive">Required. String expression that specifies an existing drive. If you supply a zero-length string (""), the current drive does not change. If the <c>Drive</c> argument is a multiple-character string, <see langword="ChDrive" /> uses only the first letter.</param>
        <summary>Changes the current drive.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `ChDrive` -Funktion erfordert die Berechtigung nicht verwaltete Code sich möglicherweise auf ihre Ausführung in teilweise vertrauenswürdigen Umgebungen auswirken. Weitere Informationen finden Sie unter <xref:System.Security.Permissions.SecurityPermission> und [Codezugriffsberechtigungen](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `ChDrive` Funktion, um das aktuelle Laufwerk zu ändern. Die Funktion löst eine Ausnahme aus, wenn das Laufwerk nicht vorhanden ist.  
  
 [!code-vb[VbVbalrCatRef#32](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Invalid drive is specified, or drive is unavailable.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="ChDrive">
      <MemberSignature Language="C#" Value="public static void ChDrive (string Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDrive(string Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDrive (Drive As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDrive(System::String ^ Drive);" />
      <MemberSignature Language="F#" Value="static member ChDrive : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.ChDrive Drive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Drive">Required. String expression that specifies an existing drive. If you supply a zero-length string (""), the current drive does not change. If the <c>Drive</c> argument is a multiple-character string, <see langword="ChDrive" /> uses only the first letter.</param>
        <summary>Changes the current drive.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `ChDrive` -Funktion erfordert die Berechtigung nicht verwaltete Code sich möglicherweise auf ihre Ausführung in teilweise vertrauenswürdigen Umgebungen auswirken. Weitere Informationen finden Sie unter <xref:System.Security.Permissions.SecurityPermission> und [Codezugriffsberechtigungen](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `ChDrive` Funktion, um das aktuelle Laufwerk zu ändern. Die Funktion löst eine Ausnahme aus, wenn das Laufwerk nicht vorhanden ist.  
  
 [!code-vb[VbVbalrCatRef#32](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Invalid drive is specified, or drive is unavailable.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CurDir">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns a string representing the current path. The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than <see langword="CurDir" />. For more information, see <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CurDir">
      <MemberSignature Language="C#" Value="public static string CurDir ();" />
      <MemberSignature Language="ILAsm" Value=".method public static string CurDir() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.CurDir" />
      <MemberSignature Language="VB.NET" Value="Public Function CurDir () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CurDir();" />
      <MemberSignature Language="F#" Value="static member CurDir : unit -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.CurDir " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns a string representing the current path. The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than <see langword="CurDir" />. For more information, see <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</summary>
        <returns>A string representing the current path.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Dieses Beispiel verwendet die `CurDir` Funktion, um den aktuellen Pfad zurückzugeben.  
  
 [!code-vb[VbVbalrCatRef#65](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#65)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <Member MemberName="CurDir">
      <MemberSignature Language="C#" Value="public static string CurDir (char Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static string CurDir(char Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.CurDir(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function CurDir (Drive As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CurDir(char Drive);" />
      <MemberSignature Language="F#" Value="static member CurDir : char -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.CurDir Drive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="Drive">Optional. <see langword="Char" /> expression that specifies an existing drive. If no drive is specified, or if <c>Drive</c> is a zero-length string (""), <see langword="CurDir" /> returns the path for the current drive.</param>
        <summary>Returns a string representing the current path. The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than <see langword="CurDir" />. For more information, see <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</summary>
        <returns>A string representing the current path.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Dieses Beispiel verwendet die `CurDir` Funktion, um den aktuellen Pfad zurückzugeben.  
  
 [!code-vb[VbVbalrCatRef#65](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#65)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dir">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns a string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive. The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than the <see langword="Dir" /> function. See <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" /> for more information.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dir">
      <MemberSignature Language="C#" Value="public static string Dir ();" />
      <MemberSignature Language="ILAsm" Value=".method public static string Dir() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Dir" />
      <MemberSignature Language="VB.NET" Value="Public Function Dir () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Dir();" />
      <MemberSignature Language="F#" Value="static member Dir : unit -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.Dir " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns a string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive. The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than the <see langword="Dir" /> function. See <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" /> for more information.</summary>
        <returns>A string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Dir` Funktion unterstützt die Verwendung von mehreren Zeichen (`*`) und ein einzelnes Zeichen (`?`) mit Platzhaltern für mehrere Dateien anzugeben.  
  
 `VbVolume` Gibt die Volumebezeichnung für das Laufwerk anstelle von einem bestimmten Dateinamen zurück.  
  
 Geben Sie an einer `PathName` erstmalig, die Sie Aufrufen der `Dir` Funktion. Um das nächste Element abzurufen, können Sie aufeinander folgende Aufrufe vorzunehmen die `Dir` Funktion ohne Parameter.  
  
> [!IMPORTANT]
>  Ordnungsgemäß ausgeführt. die `Dir` -Funktion erfordert die <xref:System.Security.Permissions.FileIOPermissionAccess.Read> und <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery> des flags <xref:System.Security.Permissions.FileIOPermission> , die den Ausführungscode gewährt werden. Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermission>, <xref:System.Security.SecurityException>, und [Codezugriffsberechtigungen](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
 Die `Attributes` Argument Enumerationswerte sind wie folgt:  
  
|Wert|Konstante|Beschreibung|  
|-|-|-|  
|`Normal`|`vbnormal`|Standard. Gibt Dateien ohne Attribute an.|  
|`ReadOnly`|`vbReadOnly`|Gibt an, schreibgeschützte Dateien sowie Dateien ohne Attribute.|  
|`Hidden`|`vbHidden`|Gibt an, ausgeblendete Dateien sowie Dateien ohne Attribute.|  
|`System`|`vbSystem`|Gibt an, das Systemdateien und auch Dateien ohne Attribute.|  
|`Volume`|`vbVolume`|Gibt die Volumebezeichnung. Wenn andere Attribute angegeben wird, `vbVolume` wird ignoriert.|  
|`Directory`|`vbDirectory`|Gibt an, Verzeichnissen oder Ordnern sowie Dateien ohne Attribute.|  
|`Archive`|`vbArchive`|Datei wurde seit der letzten Sicherung geändert.|  
|`Alias`|`vbAlias`|Datei weist einen anderen Namen an.|  
  
> [!NOTE]
>  Diese Enumerationen werden von der Visual Basic-Sprache angegeben und können überall im Code anstelle der eigentlichen Werte verwendet werden.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `Dir` Funktion zum Überprüfen, ob bestimmte Dateien und Verzeichnisse vorhanden sind.  
  
 [!code-vb[VbVbalrCatRef#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Dir">
      <MemberSignature Language="C#" Value="public static string Dir (string PathName, Microsoft.VisualBasic.FileAttribute Attributes = Microsoft.VisualBasic.FileAttribute.Normal);" />
      <MemberSignature Language="ILAsm" Value=".method public static string Dir(string PathName, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)" />
      <MemberSignature Language="VB.NET" Value="Public Function Dir (PathName As String, Optional Attributes As FileAttribute = Microsoft.VisualBasic.FileAttribute.Normal) As String" />
      <MemberSignature Language="F#" Value="static member Dir : string * Microsoft.VisualBasic.FileAttribute -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.Dir (PathName, Attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
        <Parameter Name="Attributes" Type="Microsoft.VisualBasic.FileAttribute" />
      </Parameters>
      <Docs>
        <param name="PathName">Optional. <see langword="String" /> expression that specifies a file name, directory or folder name, or drive volume label. A zero-length string (<see langword="&quot;&quot;" />) is returned if <c>PathName</c> is not found.</param>
        <param name="Attributes">Optional. Enumeration or numeric expression whose value specifies file attributes. If omitted, <see langword="Dir" /> returns files that match <c>PathName</c> but have no attributes.</param>
        <summary>Returns a string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive. The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than the <see langword="Dir" /> function. See <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" /> for more information.</summary>
        <returns>A string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Dir` Funktion unterstützt die Verwendung von mehreren Zeichen (`*`) und ein einzelnes Zeichen (`?`) mit Platzhaltern für mehrere Dateien anzugeben.  
  
 `VbVolume` Gibt die Volumebezeichnung für das Laufwerk anstelle von einem bestimmten Dateinamen zurück.  
  
 Geben Sie an einer `PathName` erstmalig, die Sie Aufrufen der `Dir` Funktion. Um das nächste Element abzurufen, können Sie aufeinander folgende Aufrufe vorzunehmen die `Dir` Funktion ohne Parameter.  
  
> [!IMPORTANT]
>  Ordnungsgemäß ausgeführt. die `Dir` -Funktion erfordert die <xref:System.Security.Permissions.FileIOPermissionAccess.Read> und <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery> des flags <xref:System.Security.Permissions.FileIOPermission> , die den Ausführungscode gewährt werden. Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermission>, <xref:System.Security.SecurityException>, und [Codezugriffsberechtigungen](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
 Die `Attributes` Argument Enumerationswerte sind wie folgt:  
  
|Wert|Konstante|Beschreibung|  
|-|-|-|  
|`Normal`|`vbnormal`|Standard. Gibt die Dateien, die keine Attribute aufweisen.|  
|`ReadOnly`|`vbReadOnly`|Gibt schreibgeschützte Dateien zusätzlich zu Dateien, die keine Attribute aufweisen.|  
|`Hidden`|`vbHidden`|Gibt versteckte Dateien zusätzlich zu Dateien, die keine Attribute aufweisen.|  
|`System`|`vbSystem`|Gibt die Systemdateien, zusätzlich zu Dateien, die keine Attribute aufweisen.|  
|`Volume`|`vbVolume`|Gibt die Volumebezeichnung. Wenn andere Attribute angegeben wird, `vbVolume` wird ignoriert.|  
|`Directory`|`vbDirectory`|Gibt an, Verzeichnissen oder Ordnern, zusätzlich zu Dateien, die keine Attribute aufweisen.|  
|`Archive`|`vbArchive`|Datei wurde seit der letzten Sicherung geändert.|  
|`Alias`|`vbAlias`|Datei weist einen anderen Namen an.|  
  
> [!NOTE]
>  Diese Enumerationen werden von der Visual Basic-Sprache angegeben und können überall im Code anstelle der eigentlichen Werte verwendet werden.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `Dir` Funktion zum Überprüfen, ob bestimmte Dateien und Verzeichnisse vorhanden sind.  
  
 [!code-vb[VbVbalrCatRef#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
      </Docs>
    </Member>
    <Member MemberName="EOF">
      <MemberSignature Language="C#" Value="public static bool EOF (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static bool EOF(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function EOF (FileNumber As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool EOF(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member EOF : int -&gt; bool" Usage="Microsoft.VisualBasic.FileSystem.EOF FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. An <see langword="Integer" /> that contains any valid file number.</param>
        <summary>Returns a Boolean value <see langword="True" /> when the end of a file opened for <see langword="Random" /> or sequential <see langword="Input" /> has been reached.</summary>
        <returns>Returns a Boolean value <see langword="True" /> when the end of a file opened for <see langword="Random" /> or sequential <see langword="Input" /> has been reached.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwendung `EOF` vermeiden Sie den Fehler generiert, wird versucht, die nach dem Ende einer Datei Eingabe abzurufen.  
  
 Die `EOF` -Funktion gibt `False` fort, bis das Ende der Datei erreicht wurde. Dateien für geöffnet `Random` oder `Binary` Zugriff `EOF` gibt `False` erst nach der Ausführung der letzten `FileGet` Funktion kann nicht zum Lesen der vollständigen Datensatzes.  
  
 Dateien für geöffnet `Binary` zugreifen, beim Lesen der Datei mithilfe der `Input` Funktion bis `EOF` gibt `True` wird ein Fehler generiert. Verwenden Sie die `LOF` und `Loc` anstelle von Funktionen `EOF` beim Lesen von Binärdateien mit `Input`, oder verwenden Sie `Get` bei Verwendung der `EOF` Funktion. Dateien für geöffnet `Output`, `EOF` gibt immer `True`.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `EOF` Funktion, um das Ende einer Datei zu erkennen. In diesem Beispiel wird vorausgesetzt, dass `Testfile` ist eine Textdatei, die mehrere Textzeilen enthält.  
  
 [!code-vb[VbVbalrCatRef#62](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#62)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FileAttr">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.OpenMode FileAttr (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.OpenMode FileAttr(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileAttr (FileNumber As Integer) As OpenMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::OpenMode FileAttr(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member FileAttr : int -&gt; Microsoft.VisualBasic.OpenMode" Usage="Microsoft.VisualBasic.FileSystem.FileAttr FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.OpenMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. <see langword="Integer" />. Any valid file number.</param>
        <summary>Returns an enumeration representing the file mode for files opened using the <see langword="FileOpen" /> function. The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than the <see langword="FileAttr" /> function. See <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" /> for more information.</summary>
        <returns>The following enumeration values indicate the file access mode:  <list type="table"><item><term> Value  </term><description> Mode  </description></item><item><term> 1  </term><description><see langword="OpenMode.Input" /></description></item><item><term> 2  </term><description><see langword="OpenMode.Output" /></description></item><item><term> 4  </term><description><see langword="OpenMode.Random" /></description></item><item><term> 8  </term><description><see langword="OpenMode.Append" /></description></item><item><term> 32  </term><description><see langword="OpenMode.Binary" /></description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Funktion gibt eine Enumeration, die den Dateimodus mit geöffneten Dateien darstellt. die `FileOpen` Funktion.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `FileAttr` Funktion, um den Dateimodus einer geöffneten Datei zurückzugeben.  
  
 [!code-vb[VbVbalrCatRef#46](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#46)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FileClose">
      <MemberSignature Language="C#" Value="public static void FileClose (params int[] FileNumbers);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileClose(int32[] FileNumbers) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileClose (ParamArray FileNumbers As Integer())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileClose(... cli::array &lt;int&gt; ^ FileNumbers);" />
      <MemberSignature Language="F#" Value="static member FileClose : int[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileClose FileNumbers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumbers" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumbers">Optional. Parameter array of 0 or more channels to be closed.</param>
        <summary>Concludes input/output (I/O) to a file opened using the <see langword="FileOpen" /> function. <see langword="My" /> gives you better productivity and performance in file I/O operations. See <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> for more information.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `FileClose` Funktion wird für Abwärtskompatibilität angeboten und die Leistung beeinträchtigen. Für nicht-Legacyanwendungen der `My.Computer.FileSystem` Objekt bietet eine bessere Leistung. Weitere Informationen finden Sie unter [wie: Lesen von Text aus Dateien mit einem StreamReader](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md),[wie: Schreiben von Text in Dateien mit einem StreamWriter](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md), und [Exemplarische Vorgehensweise: Bearbeiten von Dateien und Verzeichnissen in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories.md).  
  
 Wenn Sie weglassen `FileNumbers`, allen aktive Dateien geöffnet werden, indem Sie die `FileOpen` Funktion geschlossen werden.  
  
 Beim Schließen von Dateien, die für geöffnet waren `Output` oder `Append`, wird der endgültige Puffer der Ausgabe in die Betriebssystempuffer für diese Datei geschrieben. Alle geschlossenen zugeordnete Pufferspeicher Datei freigegeben ist.  
  
 Wenn die `FileClose` Funktion ausgeführt wird, wird die Zuordnung einer Datei mit der Datei Zahl enden.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `FileClose` Funktion zum Schließen einer Datei geöffnet wird, für `Input`.  
  
 [!code-vb[VbVbalrCatRef#69](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#69)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <paramref name="FileNumber" /> does not exist.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Reset" />
      </Docs>
    </Member>
    <Member MemberName="FileCopy">
      <MemberSignature Language="C#" Value="public static void FileCopy (string Source, string Destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileCopy(string Source, string Destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileCopy(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileCopy (Source As String, Destination As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileCopy(System::String ^ Source, System::String ^ Destination);" />
      <MemberSignature Language="F#" Value="static member FileCopy : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileCopy (Source, Destination)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Source" Type="System.String" />
        <Parameter Name="Destination" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Source">Required. <see langword="String" /> expression that specifies the name of the file to be copied. <c>Source</c> may include the directory or folder, and drive, of the source file.</param>
        <param name="Destination">Required. <see langword="String" /> expression that specifies the destination file name. <c>Destination</c> may include the directory or folder, and drive, of the destination file.</param>
        <summary>Copies a file. The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than <see langword="FileCopy" />. See <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile(System.String,System.String)" /> for more information.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie versuchen, verwenden Sie die `FileCopy` -Funktion auf eine aktuell geöffnete Datei ein Fehler auftritt.  
  
 `FileCopy` erfordert volle Vertrauenswürdigkeit auf dem lokalen Laufwerk funktioniert.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `FileCopy` Funktion, um eine Datei auf einen anderen kopieren. Für dieses Beispiel wird davon ausgegangen, die `SrcFile` ist eine Datei, die Daten enthält.  
  
 [!code-vb[VbVbalrCatRef#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Source" /> or <paramref name="Destination" /> is invalid or not specified.</exception>
        <exception cref="T:System.IO.IOException">File is already open.</exception>
        <exception cref="T:System.IO.FileNotFoundException">File does not exist.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <Member MemberName="FileDateTime">
      <MemberSignature Language="C#" Value="public static DateTime FileDateTime (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype System.DateTime FileDateTime(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileDateTime (PathName As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime FileDateTime(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member FileDateTime : string -&gt; DateTime" Usage="Microsoft.VisualBasic.FileSystem.FileDateTime PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">Required. <see langword="String" /> expression that specifies a file name. <c>PathName</c> may include the directory or folder, and the drive.</param>
        <summary>Returns a <see langword="Date" /> value that indicates the date and time a file was written to. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileDateTime" />. For more information, see <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" /></summary>
        <returns>
          <see langword="Date" /> value that indicates the date and time a file was created or last modified.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Dieses Beispiel verwendet die `FileDateTime` Funktion, um das Datum zu bestimmen und die Uhrzeit einer Datei erstellt oder zuletzt geändert wurde. Das Format von Datum und Uhrzeit angezeigt, basiert auf dem Gebietsschema des Systems.  
  
 [!code-vb[VbVbalrCatRef#34](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#34)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="PathName" /> is invalid or contains wildcards.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Target file does not exist.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FileGet">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Reads data from an open disk file into a variable. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref bool Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, bool&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Boolean, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name into which data is read.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</param>
        <summary>Reads data from an open disk file into a variable. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` gilt nur in `Random` und `Binary` Modus.  
  
 Datenlesevorgänge mit `FileGet` bezieht sich normalerweise in eine Datei mit `FilePut`.  
  
 Der erste Datensatz oder Byte in einer Datei befindet sich an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 usw. ist. Wenn Sie weglassen `RecordNumber`, den nächsten Datensatz bzw. Byte nach dem letzten `FileGet` oder `FilePut` Funktion (oder verweist, zu dem letzten `Seek` Funktion) gelesen wird.  
  
> [!IMPORTANT]
>  Beim Lesen aus Dateien nicht Beurteilen der Inhalt einer Datei, die anhand der Dateinamenerweiterung. Eine Datei mit dem Namen "Form1.vb" möglicherweise z. B. nicht über ein Visual Basic-Quelldatei.  
  
## <a name="random-mode"></a>Zufällige Modus  
 Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:  
  
-   Wenn die Länge des zu lesenden Daten kleiner als die Länge ist, angegeben der `RecordLength` -Klausel der `FileOpen` -Funktion, `FileGet` liest nachfolgende Datensätze Datensatzlänge. Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt. Da die Menge der Leerstellen Daten nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen empfiehlt sich, die Datensatzlänge der Länge der zu lesenden Daten überein.  
  
-   Die Zielvariable eine Zeichenfolge ist, standardmäßig `FileGet` liest einen 2-Byte-Deskriptor, die Länge der Zeichenfolge enthält, und liest dann die Daten, die in die Variable aufgenommen wird. Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge. Visual Basic 6.0 und früheren Versionen unterstützen Zeichenfolgen mit fester Länge. Wenn in einer Datei zu speichern, wird der Längendeskriptor nicht geschrieben werden. Wenn Sie eine Zeichenfolge ohne Deskriptor lesen möchten, übergeben Sie `True` auf die `StringIsFixedLength` Parameter, und die Zeichenfolge, die Sie einlesen, sollte die richtige Länge.  
  
-   Wenn die Zielvariable ein Array ist, können Sie auswählen, ob einen Deskriptor für die Größe und die Dimension des Arrays zu lesen. Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`. Beim Lesen des Arrays müssen Sie die Möglichkeit zu entsprechen, die das Array geschrieben wurde. Wenn sie mit dem Deskriptor geschrieben wurde, müssen Sie den Deskriptor lesen. Der Deskriptor nicht verwendet wird, die Größe und die Grenzen des Arrays übergebenen `FileGet` ermittelt das weitere Vorgehen zu lesen.  
  
     Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang. Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl von Dimensionen: (2 + 8 * NumberOfDimensions). Die Länge des Datensatzes gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Arraydeskriptor zu schreiben. Die folgende Arraydeklaration erfordert z. B. 218 Bytes, wenn das Array geschrieben wird auf den Datenträger.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     Die 218 Bytes werden wie folgt verteilt:  
  
    -   18 Bytes für den Deskriptor: (2 + 8 * 2)  
  
    -   200 Bytes für die Daten: (10 * 5 * 4).  
  
-   Wenn die Variable in gelesen werden, andere Typen von Variablen (keine Zeichenfolge variabler Länge oder ein Objekt), `FileGet` liest nur die Daten die Variablen. Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge der Daten, die gelesen werden können.  
  
-   `FileGet` liest Sie Elemente von Strukturen, als ob einzeln gelesen wurden, mit dem Unterschied, dass keine Auffüllung zwischen Elementen vorhanden ist. Auf dem Datenträger ein dynamisches array, in einem benutzerdefinierten Typ (mit geschriebene `FilePut`) ein Deskriptor, dessen Länge 2 plus 8 Mal der Anzahl der Dimensionen gleich, vorangestellt ist: (2 + 8 * NumberOfDimensions). Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes, die zum Lesen der einzelnen Elemente erforderlich. Dies schließt alle Arrays und ihrer Deskriptoren. Die `VBFixedString` Attribut angewendet werden kann, zu Zeichenfolgenfeldern in den Strukturen an, dass die Größe der Zeichenfolge beim Schreiben auf den Datenträger.  
  
## <a name="binary-mode"></a>Binärmodus  
 Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` -Modus-Regeln gelten, bis auf einige Ausnahmen. Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:  
  
-   Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen. `FileGet` Liest alle Variablen zusammenhängend vom Datenträger. d. h. ohne Auffüllung zwischen Datensätzen.  
  
-   Für ein beliebiges Array als ein Array in einer Struktur `FileGet` liest nur die Daten. Es wird kein Deskriptor gelesen.  
  
-   `FileGet` liest die Zeichenfolgen mit variabler Länge, die keine Elemente von Strukturen ohne erwartet den Längendeskriptor 2-Byte-sind. Die Anzahl der gelesenen Bytes entspricht die Anzahl der Zeichen, die bereits in der Zeichenfolge.  
  
    > [!IMPORTANT]
    >  Lesen aus einer Datei mithilfe der`FileGet` -Funktion erfordert `Read` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref byte Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, unsigned int8&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Byte, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name into which data is read.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</param>
        <summary>Reads data from an open disk file into a variable. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` gilt nur in `Random` und `Binary` Modus.  
  
 Datenlesevorgänge mit `FileGet` bezieht sich normalerweise in eine Datei mit `FilePut`.  
  
 Der erste Datensatz oder Byte in einer Datei befindet sich an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 usw. ist. Wenn Sie weglassen `RecordNumber`, den nächsten Datensatz bzw. Byte nach dem letzten `FileGet` oder `FilePut` Funktion (oder verweist, zu dem letzten `Seek` Funktion) gelesen wird.  
  
> [!IMPORTANT]
>  Beim Lesen aus Dateien nicht Beurteilen der Inhalt einer Datei, die anhand der Dateinamenerweiterung. Eine Datei mit dem Namen "Form1.vb" möglicherweise z. B. nicht über ein Visual Basic-Quelldatei.  
  
## <a name="random-mode"></a>Zufällige Modus  
 Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:  
  
-   Wenn die Länge des zu lesenden Daten kleiner als die Länge ist, angegeben der `RecordLength` -Klausel der `FileOpen` -Funktion, `FileGet` liest nachfolgende Datensätze Datensatzlänge. Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt. Da die Menge der Leerstellen Daten nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen empfiehlt sich, die Datensatzlänge der Länge der zu lesenden Daten überein.  
  
-   Die Zielvariable eine Zeichenfolge ist, standardmäßig `FileGet` liest einen 2-Byte-Deskriptor, die Länge der Zeichenfolge enthält, und liest dann die Daten, die in die Variable aufgenommen wird. Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge. Visual Basic 6.0 und früheren Versionen unterstützen Zeichenfolgen mit fester Länge. Wenn in einer Datei zu speichern, wird der Längendeskriptor nicht geschrieben werden. Wenn Sie eine Zeichenfolge ohne Deskriptor lesen möchten, übergeben Sie `True` auf die `StringIsFixedLength` Parameter, und die Zeichenfolge, die Sie einlesen, sollte die richtige Länge.  
  
-   Wenn die Zielvariable ein Array ist, können Sie auswählen, ob einen Deskriptor für die Größe und die Dimension des Arrays zu lesen. Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`. Beim Lesen des Arrays müssen Sie die Möglichkeit zu entsprechen, die das Array geschrieben wurde. Wenn sie mit dem Deskriptor geschrieben wurde, müssen Sie den Deskriptor lesen. Wenn der Deskriptor nicht verwendet wird. Übergeben Sie die Größe und die Grenzen des Arrays in `FileGet` ermittelt das weitere Vorgehen zu lesen.  
  
     Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang. Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl von Dimensionen: (2 + 8 * NumberOfDimensions). Die Länge des Datensatzes gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Arraydeskriptor zu schreiben. Die folgende Arraydeklaration erfordert z. B. 218 Bytes, wenn das Array geschrieben wird auf den Datenträger.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     Die 218 Bytes werden wie folgt verteilt:  
  
    -   18 Bytes für den Deskriptor: (2 + 8 * 2)  
  
    -   200 Bytes für die Daten: (10 * 5 * 4).  
  
-   Wenn die Variable in gelesen werden, andere Typen von Variablen (keine Zeichenfolge variabler Länge oder ein Objekt), `FileGet` liest nur die Daten die Variablen. Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge der Daten, die gelesen werden können.  
  
-   `FileGet` liest Sie Elemente von Strukturen, als ob einzeln gelesen wurden, mit dem Unterschied, dass keine Auffüllung zwischen Elementen vorhanden ist. Auf dem Datenträger ein dynamisches array, in einem benutzerdefinierten Typ (mit geschriebene `FilePut`) ein Deskriptor, dessen Länge 2 plus 8 Mal der Anzahl der Dimensionen gleich, vorangestellt ist: (2 + 8 * NumberOfDimensions). Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes, die zum Lesen der einzelnen Elemente erforderlich. Dies schließt alle Arrays und ihrer Deskriptoren. Die `VBFixedString` Attribut angewendet werden kann, zu Zeichenfolgenfeldern in den Strukturen an, dass die Größe der Zeichenfolge beim Schreiben auf den Datenträger.  
  
## <a name="binary-mode"></a>Binärmodus  
 Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` -Modus-Regeln gelten, bis auf einige Ausnahmen. Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:  
  
-   Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen. `FileGet` Liest alle Variablen zusammenhängend vom Datenträger. d. h. ohne Auffüllung zwischen Datensätzen.  
  
-   Für ein beliebiges Array als ein Array in einer Struktur `FileGet` liest nur die Daten. Es wird kein Deskriptor gelesen.  
  
-   `FileGet` liest die Zeichenfolgen mit variabler Länge, die keine Elemente von Strukturen ohne erwartet den Längendeskriptor 2-Byte-sind. Die Anzahl der gelesenen Bytes entspricht die Anzahl der Zeichen, die bereits in der Zeichenfolge.  
  
    > [!IMPORTANT]
    >  Lesen aus einer Datei mithilfe der `FileGet` -Funktion erfordert `Read` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref char Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, char&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Char, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name into which data is read.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</param>
        <summary>Reads data from an open disk file into a variable. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` gilt nur in `Random` und `Binary` Modus.  
  
 Datenlesevorgänge mit `FileGet` bezieht sich normalerweise in eine Datei mit `FilePut`.  
  
 Der erste Datensatz oder Byte in einer Datei befindet sich an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 usw. ist. Wenn Sie weglassen `RecordNumber`, den nächsten Datensatz bzw. Byte nach dem letzten `FileGet` oder `FilePut` Funktion (oder verweist, zu dem letzten `Seek` Funktion) gelesen wird.  
  
> [!IMPORTANT]
>  Beim Lesen aus Dateien nicht Beurteilen der Inhalt einer Datei, die anhand der Dateinamenerweiterung. Eine Datei mit dem Namen "Form1.vb" möglicherweise z. B. nicht über ein Visual Basic-Quelldatei.  
  
## <a name="random-mode"></a>Zufällige Modus  
 Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:  
  
-   Wenn die Länge des zu lesenden Daten kleiner als die Länge ist, angegeben der `RecordLength` -Klausel der `FileOpen` -Funktion, `FileGet` liest nachfolgende Datensätze Datensatzlänge. Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt. Da die Menge der Leerstellen Daten nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen empfiehlt sich, die Datensatzlänge der Länge der zu lesenden Daten überein.  
  
-   Die Zielvariable eine Zeichenfolge ist, standardmäßig `FileGet` liest einen 2-Byte-Deskriptor, die Länge der Zeichenfolge enthält, und liest dann die Daten, die in die Variable aufgenommen wird. Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge. Visual Basic 6.0 und früheren Versionen unterstützen Zeichenfolgen mit fester Länge. Wenn in einer Datei zu speichern, wird der Längendeskriptor nicht geschrieben werden. Wenn Sie eine Zeichenfolge ohne Deskriptor lesen möchten, übergeben Sie `True` auf die `StringIsFixedLength` Parameter, und die Zeichenfolge, die Sie einlesen, sollte die richtige Länge.  
  
-   Wenn die Zielvariable ein Array ist, können Sie auswählen, ob einen Deskriptor für die Größe und die Dimension des Arrays zu lesen. Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`. Beim Lesen des Arrays müssen Sie die Möglichkeit zu entsprechen, die das Array geschrieben wurde. Wenn sie mit dem Deskriptor geschrieben wurde, müssen Sie den Deskriptor lesen. Der Deskriptor nicht verwendet wird, die Größe und die Grenzen des Arrays übergebenen `FileGet` ermittelt das weitere Vorgehen zu lesen.  
  
     Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang. Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl von Dimensionen: (2 + 8 * NumberOfDimensions). Die Länge des Datensatzes gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Arraydeskriptor zu schreiben. Die folgende Arraydeklaration erfordert z. B. 218 Bytes, wenn das Array geschrieben wird auf den Datenträger.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     Die 218 Bytes werden wie folgt verteilt:  
  
    -   18 Bytes für den Deskriptor: (2 + 8 * 2)  
  
    -   200 Bytes für die Daten: (10 * 5 * 4).  
  
-   Wenn die Variable in gelesen werden, andere Typen von Variablen (keine Zeichenfolge variabler Länge oder ein Objekt), `FileGet` liest nur die Daten die Variablen. Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge der Daten, die gelesen werden können.  
  
-   `FileGet` liest Sie Elemente von Strukturen, als ob einzeln gelesen wurden, mit dem Unterschied, dass keine Auffüllung zwischen Elementen vorhanden ist. Auf dem Datenträger ein dynamisches array, in einem benutzerdefinierten Typ (mit geschriebene `FilePut`) ein Deskriptor, dessen Länge 2 plus 8 Mal der Anzahl der Dimensionen gleich, vorangestellt ist: (2 + 8 * NumberOfDimensions). Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes, die zum Lesen der einzelnen Elemente erforderlich. Dies schließt alle Arrays und ihrer Deskriptoren. Die `VBFixedString` Attribut angewendet werden kann, zu Zeichenfolgenfeldern in den Strukturen an, dass die Größe der Zeichenfolge beim Schreiben auf den Datenträger.  
  
## <a name="binary-mode"></a>Binärmodus  
 Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` -Modus-Regeln gelten, bis auf einige Ausnahmen. Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:  
  
-   Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen. `FileGet` Liest alle Variablen zusammenhängend vom Datenträger. d. h. ohne Auffüllung zwischen Datensätzen.  
  
-   Für ein beliebiges Array als ein Array in einer Struktur `FileGet` liest nur die Daten. Es wird kein Deskriptor gelesen.  
  
-   `FileGet` liest die Zeichenfolgen mit variabler Länge, die keine Elemente von Strukturen ohne erwartet den Längendeskriptor 2-Byte-sind. Die Anzahl der gelesenen Bytes entspricht die Anzahl der Zeichen, die bereits in der Zeichenfolge.  
  
    > [!IMPORTANT]
    >  Lesen aus einer Datei mithilfe der `FileGet` -Funktion erfordert `Read` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref DateTime Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, valuetype System.DateTime&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As DateTime, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name into which data is read.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</param>
        <summary>Reads data from an open disk file into a variable. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` gilt nur in `Random` und `Binary` Modus.  
  
 Datenlesevorgänge mit `FileGet` bezieht sich normalerweise in eine Datei mit `FilePut`.  
  
 Der erste Datensatz oder Byte in einer Datei befindet sich an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 usw. ist. Wenn Sie weglassen `RecordNumber`, den nächsten Datensatz bzw. Byte nach dem letzten `FileGet` oder `FilePut` Funktion (oder verweist, zu dem letzten `Seek` Funktion) gelesen wird.  
  
> [!IMPORTANT]
>  Beim Lesen aus Dateien nicht Beurteilen der Inhalt einer Datei, die anhand der Dateinamenerweiterung. Eine Datei mit dem Namen "Form1.vb" möglicherweise z. B. nicht über ein Visual Basic-Quelldatei.  
  
## <a name="random-mode"></a>Zufällige Modus  
 Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:  
  
-   Wenn die Länge des zu lesenden Daten kleiner als die Länge ist, angegeben der `RecordLength` -Klausel der `FileOpen` -Funktion,`FileGet` liest nachfolgende Datensätze Datensatzlänge. Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt. Da die Menge der Leerstellen Daten nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen empfiehlt sich, die Datensatzlänge der Länge der zu lesenden Daten überein.  
  
-   Die Zielvariable eine Zeichenfolge ist, standardmäßig `FileGet` liest einen 2-Byte-Deskriptor, die Länge der Zeichenfolge enthält, und liest dann die Daten, die in die Variable aufgenommen wird. Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge. Visual Basic 6.0 und früheren Versionen unterstützen Zeichenfolgen mit fester Länge. Wenn in einer Datei zu speichern, wird der Längendeskriptor nicht geschrieben werden. Wenn Sie eine Zeichenfolge ohne Deskriptor lesen möchten, übergeben Sie `True` auf die `StringIsFixedLength` Parameter, und die Zeichenfolge, die Sie einlesen, sollte die richtige Länge.  
  
-   Wenn die Zielvariable ein Array ist, können Sie auswählen, ob einen Deskriptor für die Größe und die Dimension des Arrays zu lesen. Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`. Beim Lesen des Arrays müssen Sie die Möglichkeit zu entsprechen, die das Array geschrieben wurde. Wenn sie mit dem Deskriptor geschrieben wurde, müssen Sie den Deskriptor lesen. Der Deskriptor nicht verwendet wird, die Größe und die Grenzen des Arrays übergebenen `FileGet` ermittelt das weitere Vorgehen zu lesen.  
  
     Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang. Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl von Dimensionen: (2 + 8 * NumberOfDimensions). Die Länge des Datensatzes gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Arraydeskriptor zu schreiben. Die folgende Arraydeklaration erfordert z. B. 218 Bytes, wenn das Array geschrieben wird auf den Datenträger.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     Die 218 Bytes werden wie folgt verteilt:  
  
    -   18 Bytes für den Deskriptor: (2 + 8 * 2)  
  
    -   200 Bytes für die Daten: (10 * 5 * 4).  
  
-   Wenn die Variable in gelesen werden, andere Typen von Variablen (keine Zeichenfolge variabler Länge oder ein Objekt), `FileGet` liest nur die Daten die Variablen. Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge der Daten, die gelesen werden können.  
  
-   `FileGet` liest Sie Elemente von Strukturen, als ob einzeln gelesen wurden, mit dem Unterschied, dass keine Auffüllung zwischen Elementen vorhanden ist. Auf dem Datenträger ein dynamisches array, in einem benutzerdefinierten Typ (mit geschriebene `FilePut`) ein Deskriptor, dessen Länge 2 plus 8 Mal der Anzahl der Dimensionen gleich, vorangestellt ist: (2 + 8 * NumberOfDimensions). Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes, die zum Lesen der einzelnen Elemente erforderlich. Dies schließt alle Arrays und ihrer Deskriptoren. Die `VBFixedString` Attribut angewendet werden kann, zu Zeichenfolgenfeldern in den Strukturen an, dass die Größe der Zeichenfolge beim Schreiben auf den Datenträger.  
  
## <a name="binary-mode"></a>Binärmodus  
 Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` -Modus-Regeln gelten, bis auf einige Ausnahmen. Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:  
  
-   Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen. `FileGet` Liest alle Variablen zusammenhängend vom Datenträger. d. h. ohne Auffüllung zwischen Datensätzen.  
  
-   Für ein beliebiges Array als ein Array in einer Struktur `FileGet` liest nur die Daten. Es wird kein Deskriptor gelesen.  
  
-   `FileGet` liest die Zeichenfolgen mit variabler Länge, die keine Elemente von Strukturen ohne erwartet den Längendeskriptor 2-Byte-sind. Die Anzahl der gelesenen Bytes entspricht die Anzahl der Zeichen, die bereits in der Zeichenfolge.  
  
    > [!IMPORTANT]
    >  Lesen aus einer Datei mithilfe der `FileGet` -Funktion erfordert `Read` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref decimal Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, valuetype System.Decimal&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Decimal, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name into which data is read.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</param>
        <summary>Reads data from an open disk file into a variable. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` gilt nur in `Random` und `Binary` Modus.  
  
 Datenlesevorgänge mit `FileGet` in der Regel in eine Datei geschrieben wird, mithilfe von `FilePut`.  
  
 Der erste Datensatz oder Byte in einer Datei befindet sich an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 usw. ist. Wenn Sie weglassen `RecordNumber`, den nächsten Datensatz bzw. Byte nach dem letzten `FileGet` oder `FilePut` Funktion (oder verweist, zu dem letzten `Seek` Funktion) gelesen wird.  
  
> [!IMPORTANT]
>  Beim Lesen aus Dateien nicht Beurteilen der Inhalt einer Datei, die anhand der Dateinamenerweiterung. Eine Datei mit dem Namen "Form1.vb" möglicherweise z. B. nicht über ein Visual Basic-Quelldatei.  
  
## <a name="random-mode"></a>Zufällige Modus  
 Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:  
  
-   Wenn die Länge des zu lesenden Daten kleiner als die Länge ist, angegeben der `RecordLength` -Klausel der `FileOpen` -Funktion, `FileGet` liest nachfolgende Datensätze Datensatzlänge. Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt. Da die Menge der Leerstellen Daten nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen empfiehlt sich, die Datensatzlänge der Länge der zu lesenden Daten überein.  
  
-   Die Zielvariable eine Zeichenfolge ist, standardmäßig `FileGet` liest einen 2-Byte-Deskriptor, die Länge der Zeichenfolge enthält, und liest dann die Daten, die in die Variable aufgenommen wird. Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge. Visual Basic 6.0 und früheren Versionen unterstützen Zeichenfolgen mit fester Länge. Wenn in einer Datei zu speichern, wird der Längendeskriptor nicht geschrieben werden. Wenn Sie eine Zeichenfolge ohne Deskriptor lesen möchten, übergeben Sie `True` auf die `StringIsFixedLength` Parameter, und die Zeichenfolge, die Sie einlesen, sollte die richtige Länge.  
  
-   Wenn die Zielvariable ein Array ist, können Sie auswählen, ob einen Deskriptor für die Größe und die Dimension des Arrays zu lesen. Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`. Beim Lesen des Arrays müssen Sie die Möglichkeit zu entsprechen, die das Array geschrieben wurde. Wenn sie mit dem Deskriptor geschrieben wurde, müssen Sie den Deskriptor lesen. Der Deskriptor nicht verwendet wird, die Größe und die Grenzen des Arrays übergebenen `FileGet` ermittelt das weitere Vorgehen zu lesen.  
  
     Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang. Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl von Dimensionen: (2 + 8 * NumberOfDimensions). Die Länge des Datensatzes gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Arraydeskriptor zu schreiben. Die folgende Arraydeklaration erfordert z. B. 218 Bytes, wenn das Array geschrieben wird auf den Datenträger.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     Die 218 Bytes werden wie folgt verteilt:  
  
    -   18 Bytes für den Deskriptor: (2 + 8 * 2)  
  
    -   200 Bytes für die Daten: (10 * 5 * 4).  
  
-   Wenn die Variable in gelesen werden, andere Typen von Variablen (keine Zeichenfolge variabler Länge oder ein Objekt), `FileGet` liest nur die Daten die Variablen. Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge der Daten, die gelesen werden können.  
  
-   `FileGet` liest Sie Elemente von Strukturen, als ob einzeln gelesen wurden, mit dem Unterschied, dass keine Auffüllung zwischen Elementen vorhanden ist. Auf dem Datenträger ein dynamisches array, in einem benutzerdefinierten Typ (mit geschriebene `FilePut`) ein Deskriptor, dessen Länge 2 plus 8 Mal der Anzahl der Dimensionen gleich, vorangestellt ist: (2 + 8 * NumberOfDimensions). Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes, die zum Lesen der einzelnen Elemente erforderlich. Dies schließt alle Arrays und ihrer Deskriptoren. Die `VBFixedString` Attribut angewendet werden kann, zu Zeichenfolgenfeldern in den Strukturen an, dass die Größe der Zeichenfolge beim Schreiben auf den Datenträger.  
  
## <a name="binary-mode"></a>Binärmodus  
 Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` -Modus-Regeln gelten, bis auf einige Ausnahmen. Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:  
  
-   Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen. `FileGet` Liest alle Variablen zusammenhängend vom Datenträger. d. h. ohne Auffüllung zwischen Datensätzen.  
  
-   Für ein beliebiges Array als ein Array in einer Struktur `FileGet` liest nur die Daten. Es wird kein Deskriptor gelesen.  
  
-   `FileGet` liest die Zeichenfolgen mit variabler Länge, die keine Elemente von Strukturen ohne erwartet den Längendeskriptor 2-Byte-sind. Die Anzahl der gelesenen Bytes entspricht die Anzahl der Zeichen, die bereits in der Zeichenfolge.  
  
    > [!IMPORTANT]
    >  Lesen aus einer Datei mithilfe der `FileGet` -Funktion erfordert `Read` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref double Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, float64&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Double, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name into which data is read.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</param>
        <summary>Reads data from an open disk file into a variable. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` gilt nur in `Random` und `Binary` Modus.  
  
 Datenlesevorgänge mit `FileGet` in der Regel in eine Datei geschrieben wird, mithilfe von `FilePut`.  
  
 Der erste Datensatz oder Byte in einer Datei befindet sich an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 usw. ist. Wenn Sie weglassen `RecordNumber`, den nächsten Datensatz bzw. Byte nach dem letzten `FileGet` oder `FilePut` Funktion (oder verweist, zu dem letzten `Seek` Funktion) gelesen wird.  
  
> [!IMPORTANT]
>  Beim Lesen aus Dateien nicht Beurteilen der Inhalt einer Datei, die anhand der Dateinamenerweiterung. Eine Datei mit dem Namen "Form1.vb" möglicherweise z. B. nicht über ein Visual Basic-Quelldatei.  
  
## <a name="random-mode"></a>Zufällige Modus  
 Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:  
  
-   Wenn die Länge des zu lesenden Daten kleiner als die Länge ist, angegeben der `RecordLength` -Klausel der `FileOpen` -Funktion, `FileGet` liest nachfolgende Datensätze Datensatzlänge. Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt. Da die Menge der Leerstellen Daten nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen empfiehlt sich, die Datensatzlänge der Länge der zu lesenden Daten überein.  
  
-   Die Zielvariable eine Zeichenfolge ist, standardmäßig `FileGet` liest einen 2-Byte-Deskriptor, die Länge der Zeichenfolge enthält, und liest dann die Daten, die in die Variable aufgenommen wird. Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge. Visual Basic 6.0 und früheren Versionen unterstützen Zeichenfolgen mit fester Länge. Wenn in einer Datei zu speichern, wird der Längendeskriptor nicht geschrieben werden. Wenn Sie eine Zeichenfolge ohne Deskriptor lesen möchten, übergeben Sie `True` auf die `StringIsFixedLength` Parameter, und die Zeichenfolge, die Sie einlesen, sollte die richtige Länge.  
  
-   Wenn die Zielvariable ein Array ist, können Sie auswählen, ob einen Deskriptor für die Größe und die Dimension des Arrays zu lesen. Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`. Beim Lesen des Arrays müssen Sie die Möglichkeit zu entsprechen, die das Array geschrieben wurde. Wenn sie mit dem Deskriptor geschrieben wurde, müssen Sie den Deskriptor lesen. Der Deskriptor nicht verwendet wird, die Größe und die Grenzen des Arrays übergebenen `FileGet` ermittelt das weitere Vorgehen zu lesen.  
  
     Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang. Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl von Dimensionen: (2 + 8 * NumberOfDimensions). Die Länge des Datensatzes gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Arraydeskriptor zu schreiben. Die folgende Arraydeklaration erfordert z. B. 218 Bytes, wenn das Array geschrieben wird auf den Datenträger.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     Die 218 Bytes werden wie folgt verteilt:  
  
    -   18 Bytes für den Deskriptor: (2 + 8 * 2)  
  
    -   200 Bytes für die Daten: (10 * 5 * 4).  
  
-   Wenn die Variable in gelesen werden, andere Typen von Variablen (keine Zeichenfolge variabler Länge oder ein Objekt), `FileGet` liest nur die Daten die Variablen. Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge der Daten, die gelesen werden können.  
  
-   `FileGet` liest Sie Elemente von Strukturen, als ob einzeln gelesen wurden, mit dem Unterschied, dass keine Auffüllung zwischen Elementen vorhanden ist. Auf dem Datenträger ein dynamisches array, in einem benutzerdefinierten Typ (mit geschriebene `FilePut`) ein Deskriptor, dessen Länge 2 plus 8 Mal der Anzahl der Dimensionen gleich, vorangestellt ist: (2 + 8 * NumberOfDimensions). Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes, die zum Lesen der einzelnen Elemente erforderlich. Dies schließt alle Arrays und ihrer Deskriptoren. Die `VBFixedString` Attribut angewendet werden kann, zu Zeichenfolgenfeldern in den Strukturen an, dass die Größe der Zeichenfolge beim Schreiben auf den Datenträger.  
  
## <a name="binary-mode"></a>Binärmodus  
 Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` -Modus-Regeln gelten, bis auf einige Ausnahmen. Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:  
  
-   Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen. `FileGet` Liest alle Variablen zusammenhängend vom Datenträger. d. h. ohne Auffüllung zwischen Datensätzen.  
  
-   Für ein beliebiges Array als ein Array in einer Struktur `FileGet` liest nur die Daten. Es wird kein Deskriptor gelesen.  
  
-   `FileGet` liest die Zeichenfolgen mit variabler Länge, die keine Elemente von Strukturen ohne erwartet den Längendeskriptor 2-Byte-sind. Die Anzahl der gelesenen Bytes entspricht die Anzahl der Zeichen, die bereits in der Zeichenfolge.  
  
    > [!IMPORTANT]
    >  Lesen aus einer Datei mithilfe der`FileGet` -Funktion erfordert `Read` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref short Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int16&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Short, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name into which data is read.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</param>
        <summary>Reads data from an open disk file into a variable. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` gilt nur in `Random` und `Binary` Modus.  
  
 Datenlesevorgänge mit `FileGet` in der Regel in eine Datei geschrieben wird, mithilfe von `FilePut`.  
  
 Der erste Datensatz oder Byte in einer Datei befindet sich an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 usw. ist. Wenn Sie weglassen `RecordNumber`, den nächsten Datensatz bzw. Byte nach dem letzten `FileGet` oder `FilePut` Funktion (oder verweist, zu dem letzten `Seek` Funktion) gelesen wird.  
  
> [!IMPORTANT]
>  Beim Lesen aus Dateien nicht Beurteilen der Inhalt einer Datei, die anhand der Dateinamenerweiterung. Eine Datei mit dem Namen "Form1.vb" möglicherweise z. B. nicht über ein Visual Basic-Quelldatei.  
  
## <a name="random-mode"></a>Zufällige Modus  
 Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:  
  
-   Wenn die Länge des zu lesenden Daten kleiner als die Länge ist, angegeben der `RecordLength` -Klausel der `FileOpen` -Funktion, `FileGet` liest nachfolgende Datensätze Datensatzlänge. Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt. Da die Menge der Leerstellen Daten nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen empfiehlt sich, die Datensatzlänge der Länge der zu lesenden Daten überein.  
  
-   Die Zielvariable eine Zeichenfolge ist, standardmäßig `FileGet` liest einen 2-Byte-Deskriptor, die Länge der Zeichenfolge enthält, und liest dann die Daten, die in die Variable aufgenommen wird. Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge. Visual Basic 6.0 und früheren Versionen unterstützen Zeichenfolgen mit fester Länge. Wenn in einer Datei zu speichern, wird der Längendeskriptor nicht geschrieben werden. Wenn Sie eine Zeichenfolge ohne Deskriptor lesen möchten, übergeben Sie `True` auf die `StringIsFixedLength` Parameter, und die Zeichenfolge, die Sie einlesen, sollte die richtige Länge.  
  
-   Wenn die Zielvariable ein Array ist, können Sie auswählen, ob einen Deskriptor für die Größe und die Dimension des Arrays zu lesen. Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`. Beim Lesen des Arrays müssen Sie die Möglichkeit zu entsprechen, die das Array geschrieben wurde. Wenn sie mit dem Deskriptor geschrieben wurde, müssen Sie den Deskriptor lesen. Der Deskriptor nicht verwendet wird, die Größe und die Grenzen des Arrays übergebenen `FileGet` ermittelt das weitere Vorgehen zu lesen.  
  
     Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang. Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl von Dimensionen: (2 + 8 * NumberOfDimensions). Die Länge des Datensatzes gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Arraydeskriptor zu schreiben. Die folgende Arraydeklaration erfordert z. B. 218 Bytes, wenn das Array geschrieben wird auf den Datenträger.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     Die 218 Bytes werden wie folgt verteilt:  
  
    -   18 Bytes für den Deskriptor: (2 + 8 * 2)  
  
    -   200 Bytes für die Daten: (10 * 5 * 4).  
  
-   Wenn die Variable in gelesen werden, andere Typen von Variablen (keine Zeichenfolge variabler Länge oder ein Objekt), `FileGet` liest nur die Daten die Variablen. Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge der Daten, die gelesen werden können.  
  
-   `FileGet` liest Sie Elemente von Strukturen, als ob einzeln gelesen wurden, mit dem Unterschied, dass keine Auffüllung zwischen Elementen vorhanden ist. Auf dem Datenträger ein dynamisches array, in einem benutzerdefinierten Typ (mit geschriebene `FilePut`) ein Deskriptor, dessen Länge 2 plus 8 Mal der Anzahl der Dimensionen gleich, vorangestellt ist: (2 + 8 * NumberOfDimensions). Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes, die zum Lesen der einzelnen Elemente erforderlich. Dies schließt alle Arrays und ihrer Deskriptoren. Die `VBFixedString` Attribut angewendet werden kann, zu Zeichenfolgenfeldern in den Strukturen an, dass die Größe der Zeichenfolge beim Schreiben auf den Datenträger.  
  
## <a name="binary-mode"></a>Binärmodus  
 Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` -Modus-Regeln gelten, bis auf einige Ausnahmen. Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:  
  
-   Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen. `FileGet` Liest alle Variablen zusammenhängend vom Datenträger. d. h. ohne Auffüllung zwischen Datensätzen.  
  
-   Für ein beliebiges Array als ein Array in einer Struktur `FileGet` liest nur die Daten. Es wird kein Deskriptor gelesen.  
  
-   `FileGet` liest die Zeichenfolgen mit variabler Länge, die keine Elemente von Strukturen ohne erwartet den Längendeskriptor 2-Byte-sind. Die Anzahl der gelesenen Bytes entspricht die Anzahl der Zeichen, die bereits in der Zeichenfolge.  
  
    > [!IMPORTANT]
    >  Lesen aus einer Datei mithilfe der `FileGet` -Funktion erfordert `Read` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref int Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int32&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Integer, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name into which data is read.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</param>
        <summary>Reads data from an open disk file into a variable. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` gilt nur in `Random` und `Binary` Modus.  
  
 Datenlesevorgänge mit `FileGet` in der Regel in eine Datei geschrieben wird, mithilfe von `FilePut`.  
  
 Der erste Datensatz oder Byte in einer Datei befindet sich an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 usw. ist. Wenn Sie weglassen `RecordNumber`, den nächsten Datensatz bzw. Byte nach dem letzten `FileGet` oder `FilePut` Funktion (oder verweist, zu dem letzten `Seek` Funktion) gelesen wird.  
  
> [!IMPORTANT]
>  Beim Lesen aus Dateien nicht Beurteilen der Inhalt einer Datei, die anhand der Dateinamenerweiterung. Eine Datei mit dem Namen "Form1.vb" möglicherweise z. B. nicht über ein Visual Basic-Quelldatei.  
  
## <a name="random-mode"></a>Zufällige Modus  
 Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:  
  
-   Wenn die Länge des zu lesenden Daten kleiner als die Länge ist, angegeben der `RecordLength` -Klausel der `FileOpen` -Funktion, `FileGet` liest nachfolgende Datensätze Datensatzlänge. Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt. Da die Menge der Leerstellen Daten nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen empfiehlt sich, die Datensatzlänge der Länge der zu lesenden Daten überein.  
  
-   Die Zielvariable eine Zeichenfolge ist, standardmäßig `FileGet` liest einen 2-Byte-Deskriptor, die Länge der Zeichenfolge enthält, und liest dann die Daten, die in die Variable aufgenommen wird. Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge. Visual Basic 6.0 und früheren Versionen unterstützen Zeichenfolgen mit fester Länge. Wenn in einer Datei zu speichern, wird der Längendeskriptor nicht geschrieben werden. Wenn Sie eine Zeichenfolge ohne Deskriptor lesen möchten, übergeben Sie `True` auf die `StringIsFixedLength` Parameter, und die Zeichenfolge, die Sie einlesen, sollte die richtige Länge.  
  
-   Wenn die Zielvariable ein Array ist, können Sie auswählen, ob einen Deskriptor für die Größe und die Dimension des Arrays zu lesen. Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`. Beim Lesen des Arrays müssen Sie die Möglichkeit zu entsprechen, die das Array geschrieben wurde. Wenn sie mit dem Deskriptor geschrieben wurde, müssen Sie den Deskriptor lesen. Der Deskriptor nicht verwendet wird, die Größe und die Grenzen des Arrays übergebenen `FileGet` ermittelt das weitere Vorgehen zu lesen.  
  
     Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang. Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl von Dimensionen: (2 + 8 * NumberOfDimensions). Die Länge des Datensatzes gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Arraydeskriptor zu schreiben. Die folgende Arraydeklaration erfordert z. B. 218 Bytes, wenn das Array geschrieben wird auf den Datenträger.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     Die 218 Bytes werden wie folgt verteilt:  
  
    -   18 Bytes für den Deskriptor: (2 + 8 * 2)  
  
    -   200 Bytes für die Daten: (10 * 5 * 4).  
  
-   Wenn die Variable in gelesen werden, andere Typen von Variablen (keine Zeichenfolge variabler Länge oder ein Objekt), `FileGet` liest nur die Daten die Variablen. Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge der Daten, die gelesen werden können.  
  
-   `FileGet` liest Sie Elemente von Strukturen, als ob einzeln gelesen wurden, mit dem Unterschied, dass keine Auffüllung zwischen Elementen vorhanden ist. Auf dem Datenträger ein dynamisches array, in einem benutzerdefinierten Typ (mit geschriebene `FilePut`) ein Deskriptor, dessen Länge 2 plus 8 Mal der Anzahl der Dimensionen gleich, vorangestellt ist: (2 + 8 * NumberOfDimensions). Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes, die zum Lesen der einzelnen Elemente erforderlich. Dies schließt alle Arrays und ihrer Deskriptoren. Die `VBFixedString` Attribut angewendet werden kann, zu Zeichenfolgenfeldern in den Strukturen an, dass die Größe der Zeichenfolge beim Schreiben auf den Datenträger.  
  
## <a name="binary-mode"></a>Binärmodus  
 Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` -Modus-Regeln gelten, bis auf einige Ausnahmen. Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:  
  
-   Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen. `FileGet` Liest alle Variablen zusammenhängend vom Datenträger. d. h. ohne Auffüllung zwischen Datensätzen.  
  
-   Für ein beliebiges Array als ein Array in einer Struktur `FileGet` liest nur die Daten. Es wird kein Deskriptor gelesen.  
  
-   `FileGet` liest die Zeichenfolgen mit variabler Länge, die keine Elemente von Strukturen ohne erwartet den Längendeskriptor 2-Byte-sind. Die Anzahl der gelesenen Bytes entspricht die Anzahl der Zeichen, die bereits in der Zeichenfolge.  
  
    > [!IMPORTANT]
    >  Lesen aus einer Datei mithilfe der `FileGet` -Funktion erfordert `Read` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref long Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int64&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Long, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name into which data is read.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</param>
        <summary>Reads data from an open disk file into a variable. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` gilt nur in `Random` und `Binary` Modus.  
  
 Datenlesevorgänge mit `FileGet` in der Regel in eine Datei geschrieben wird, mithilfe von `FilePut`.  
  
 Der erste Datensatz oder Byte in einer Datei befindet sich an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 usw. ist. Wenn Sie weglassen `RecordNumber`, den nächsten Datensatz bzw. Byte nach dem letzten `FileGet` oder `FilePut` Funktion (oder verweist, zu dem letzten `Seek` Funktion) gelesen wird.  
  
> [!IMPORTANT]
>  Beim Lesen aus Dateien nicht Beurteilen der Inhalt einer Datei, die anhand der Dateinamenerweiterung. Eine Datei mit dem Namen "Form1.vb" möglicherweise z. B. nicht über ein Visual Basic-Quelldatei.  
  
## <a name="random-mode"></a>Zufällige Modus  
 Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:  
  
-   Wenn die Länge des zu lesenden Daten kleiner als die Länge ist, angegeben der `RecordLength` -Klausel der `FileOpen` -Funktion, `FileGet` liest nachfolgende Datensätze Datensatzlänge. Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt. Da die Menge der Leerstellen Daten nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen empfiehlt sich, die Datensatzlänge der Länge der zu lesenden Daten überein.  
  
-   Die Zielvariable eine Zeichenfolge ist, standardmäßig `FileGet` liest einen 2-Byte-Deskriptor, die Länge der Zeichenfolge enthält, und liest dann die Daten, die in die Variable aufgenommen wird. Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge. Visual Basic 6.0 und früheren Versionen unterstützen Zeichenfolgen mit fester Länge. Wenn in einer Datei zu speichern, wird der Längendeskriptor nicht geschrieben werden. Wenn Sie eine Zeichenfolge ohne Deskriptor lesen möchten, übergeben Sie `True` auf die `StringIsFixedLength` Parameter, und die Zeichenfolge, die Sie einlesen, sollte die richtige Länge.  
  
-   Wenn die Zielvariable ein Array ist, können Sie auswählen, ob einen Deskriptor für die Größe und die Dimension des Arrays zu lesen. Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`. Beim Lesen des Arrays müssen Sie die Möglichkeit zu entsprechen, die das Array geschrieben wurde. Wenn sie mit dem Deskriptor geschrieben wurde, müssen Sie den Deskriptor lesen. Der Deskriptor nicht verwendet wird, die Größe und die Grenzen des Arrays übergebenen `FileGet` ermittelt das weitere Vorgehen zu lesen.  
  
     Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang. Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl von Dimensionen: (2 + 8 * NumberOfDimensions). Die Länge des Datensatzes gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Arraydeskriptor zu schreiben. Die folgende Arraydeklaration erfordert z. B. 218 Bytes, wenn das Array geschrieben wird auf den Datenträger.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     Die 218 Bytes werden wie folgt verteilt:  
  
    -   18 Bytes für den Deskriptor: (2 + 8 * 2)  
  
    -   200 Bytes für die Daten: (10 * 5 * 4).  
  
-   Wenn die Variable in gelesen werden, andere Typen von Variablen (keine Zeichenfolge variabler Länge oder ein Objekt), `FileGet` liest nur die Daten die Variablen. Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge der Daten, die gelesen werden können.  
  
-   `FileGet` liest Sie Elemente von Strukturen, als ob einzeln gelesen wurden, mit dem Unterschied, dass keine Auffüllung zwischen Elementen vorhanden ist. Auf dem Datenträger ein dynamisches array, in einem benutzerdefinierten Typ (mit geschriebene `FilePut`) ein Deskriptor, dessen Länge 2 plus 8 Mal der Anzahl der Dimensionen gleich, vorangestellt ist: (2 + 8 * NumberOfDimensions). Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes, die zum Lesen der einzelnen Elemente erforderlich. Dies schließt alle Arrays und ihrer Deskriptoren. Die `VBFixedString` Attribut angewendet werden kann, zu Zeichenfolgenfeldern in den Strukturen an, dass die Größe der Zeichenfolge beim Schreiben auf den Datenträger.  
  
## <a name="binary-mode"></a>Binärmodus  
 Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` -Modus-Regeln gelten, bis auf einige Ausnahmen. Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:  
  
-   Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen. `FileGet` Liest alle Variablen zusammenhängend vom Datenträger. d. h. ohne Auffüllung zwischen Datensätzen.  
  
-   Für ein beliebiges Array als ein Array in einer Struktur `FileGet` liest nur die Daten. Es wird kein Deskriptor gelesen.  
  
-   `FileGet` liest die Zeichenfolgen mit variabler Länge, die keine Elemente von Strukturen ohne erwartet den Längendeskriptor 2-Byte-sind. Die Anzahl der gelesenen Bytes entspricht die Anzahl der Zeichen, die bereits in der Zeichenfolge.  
  
    > [!IMPORTANT]
    >  Lesen aus einer Datei mithilfe der `FileGet` -Funktion erfordert `Read` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref float Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, float32&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Single, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name into which data is read.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</param>
        <summary>Reads data from an open disk file into a variable. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` gilt nur in `Random` und `Binary` Modus.  
  
 Datenlesevorgänge mit `FileGet` in der Regel in eine Datei geschrieben wird, mithilfe von `FilePut`.  
  
 Der erste Datensatz oder Byte in einer Datei befindet sich an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 usw. ist. Wenn Sie weglassen `RecordNumber`, den nächsten Datensatz bzw. Byte nach dem letzten `FileGet` oder `FilePut` Funktion (oder verweist, zu dem letzten `Seek` Funktion) gelesen wird.  
  
> [!IMPORTANT]
>  Beim Lesen aus Dateien nicht Beurteilen der Inhalt einer Datei, die anhand der Dateinamenerweiterung. Eine Datei mit dem Namen "Form1.vb" möglicherweise z. B. nicht über ein Visual Basic-Quelldatei.  
  
## <a name="random-mode"></a>Zufällige Modus  
 Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:  
  
-   Wenn die Länge des zu lesenden Daten kleiner als die Länge ist, angegeben der `RecordLength` -Klausel der `FileOpen` -Funktion, `FileGet` liest nachfolgende Datensätze Datensatzlänge. Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt. Da die Menge der Leerstellen Daten nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen empfiehlt sich, die Datensatzlänge der Länge der zu lesenden Daten überein.  
  
-   Die Zielvariable eine Zeichenfolge ist, standardmäßig `FileGet` liest einen 2-Byte-Deskriptor, die Länge der Zeichenfolge enthält, und liest dann die Daten, die in die Variable aufgenommen wird. Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge. Visual Basic 6.0 und früheren Versionen unterstützen Zeichenfolgen mit fester Länge. Wenn in einer Datei zu speichern, wird der Längendeskriptor nicht geschrieben werden. Wenn Sie eine Zeichenfolge ohne Deskriptor lesen möchten, übergeben Sie `True` auf die `StringIsFixedLength` Parameter, und die Zeichenfolge, die Sie einlesen, sollte die richtige Länge.  
  
-   Wenn die Zielvariable ein Array ist, können Sie auswählen, ob einen Deskriptor für die Größe und die Dimension des Arrays zu lesen. Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`. Beim Lesen des Arrays müssen Sie die Möglichkeit zu entsprechen, die das Array geschrieben wurde. Wenn sie mit dem Deskriptor geschrieben wurde, müssen Sie den Deskriptor lesen. Der Deskriptor nicht verwendet wird, die Größe und die Grenzen des Arrays übergebenen `FileGet` ermittelt das weitere Vorgehen zu lesen.  
  
     Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang. Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl von Dimensionen: (2 + 8 * NumberOfDimensions). Die Länge des Datensatzes gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Arraydeskriptor zu schreiben. Die folgende Arraydeklaration erfordert z. B. 218 Bytes, wenn das Array geschrieben wird auf den Datenträger.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     Die 218 Bytes werden wie folgt verteilt:  
  
    -   18 Bytes für den Deskriptor: (2 + 8 * 2)  
  
    -   200 Bytes für die Daten: (10 * 5 * 4).  
  
-   Wenn die Variable in gelesen werden, andere Typen von Variablen (keine Zeichenfolge variabler Länge oder ein Objekt), `FileGet` liest nur die Daten die Variablen. Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge der Daten, die gelesen werden können.  
  
-   `FileGet` liest Sie Elemente von Strukturen, als ob einzeln gelesen wurden, mit dem Unterschied, dass keine Auffüllung zwischen Elementen vorhanden ist. Auf dem Datenträger ein dynamisches array, in einem benutzerdefinierten Typ (mit geschriebene `FilePut`) ein Deskriptor, dessen Länge 2 plus 8 Mal der Anzahl der Dimensionen gleich, vorangestellt ist: (2 + 8 * NumberOfDimensions). Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes, die zum Lesen der einzelnen Elemente erforderlich. Dies schließt alle Arrays und ihrer Deskriptoren. Die `VBFixedString` Attribut angewendet werden kann, zu Zeichenfolgenfeldern in den Strukturen an, dass die Größe der Zeichenfolge beim Schreiben auf den Datenträger.  
  
## <a name="binary-mode"></a>Binärmodus  
 Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` -Modus-Regeln gelten, bis auf einige Ausnahmen. Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:  
  
-   Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen. `FileGet` Liest alle Variablen zusammenhängend vom Datenträger. d. h. ohne Auffüllung zwischen Datensätzen.  
  
-   Für ein beliebiges Array als ein Array in einer Struktur `FileGet` liest nur die Daten. Es wird kein Deskriptor gelesen.  
  
-   `FileGet` liest die Zeichenfolgen mit variabler Länge, die keine Elemente von Strukturen ohne erwartet den Längendeskriptor 2-Byte-sind. Die Anzahl der gelesenen Bytes entspricht die Anzahl der Zeichen, die bereits in der Zeichenfolge.  
  
    > [!IMPORTANT]
    >  Lesen aus einer Datei mithilfe der `FileGet` -Funktion erfordert `Read` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref ValueType Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, class System.ValueType&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As ValueType, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.ValueType&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name into which data is read.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</param>
        <summary>Reads data from an open disk file into a variable. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` gilt nur in `Random` und `Binary` Modus.  
  
 Datenlesevorgänge mit `FileGet` in der Regel in eine Datei geschrieben wird, mithilfe von `FilePut`.  
  
 Der erste Datensatz oder Byte in einer Datei befindet sich an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 usw. ist. Wenn Sie weglassen `RecordNumber`, den nächsten Datensatz bzw. Byte nach dem letzten `FileGet` oder `FilePut` Funktion (oder verweist, zu dem letzten `Seek` Funktion) gelesen wird.  
  
> [!IMPORTANT]
>  Beim Lesen aus Dateien nicht Beurteilen der Inhalt einer Datei, die anhand der Dateinamenerweiterung. Eine Datei mit dem Namen "Form1.vb" möglicherweise z. B. nicht über ein Visual Basic-Quelldatei.  
  
## <a name="random-mode"></a>Zufällige Modus  
 Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:  
  
-   Wenn die Länge des zu lesenden Daten kleiner als die Länge ist, angegeben der `RecordLength` -Klausel der `FileOpen` -Funktion, `FileGet` liest nachfolgende Datensätze Datensatzlänge. Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt. Da die Menge der Leerstellen Daten nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen empfiehlt sich, die Datensatzlänge der Länge der zu lesenden Daten überein.  
  
-   Die Zielvariable eine Zeichenfolge ist, standardmäßig `FileGet` liest einen 2-Byte-Deskriptor, die Länge der Zeichenfolge enthält, und liest dann die Daten, die in die Variable aufgenommen wird. Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge. Visual Basic 6.0 und früheren Versionen unterstützen Zeichenfolgen mit fester Länge. Wenn in einer Datei zu speichern, wird der Längendeskriptor nicht geschrieben werden. Wenn Sie eine Zeichenfolge ohne Deskriptor lesen möchten, übergeben Sie `True` auf die `StringIsFixedLength` Parameter, und die Zeichenfolge, die Sie einlesen, sollte die richtige Länge.  
  
-   Wenn die Zielvariable ein Array ist, können Sie auswählen, ob einen Deskriptor für die Größe und die Dimension des Arrays zu lesen. Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`. Beim Lesen des Arrays müssen Sie die Möglichkeit zu entsprechen, die das Array geschrieben wurde. Wenn sie mit dem Deskriptor geschrieben wurde, müssen Sie den Deskriptor lesen. Der Deskriptor nicht verwendet wird, die Größe und die Grenzen des Arrays übergebenen `FileGet` ermittelt das weitere Vorgehen zu lesen.  
  
     Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang. Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl von Dimensionen: (2 + 8 * NumberOfDimensions). Die Länge des Datensatzes gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Arraydeskriptor zu schreiben. Die folgende Arraydeklaration erfordert z. B. 218 Bytes, wenn das Array geschrieben wird auf den Datenträger.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     Die 218 Bytes werden wie folgt verteilt:  
  
    -   18 Bytes für den Deskriptor: (2 + 8 * 2)  
  
    -   200 Bytes für die Daten: (10 * 5 * 4).  
  
-   Wenn die Variable in gelesen werden, andere Typen von Variablen (keine Zeichenfolge variabler Länge oder ein Objekt), `FileGet` liest nur die Daten die Variablen. Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge der Daten, die gelesen werden können.  
  
-   `FileGet` liest Sie Elemente von Strukturen, als ob einzeln gelesen wurden, mit dem Unterschied, dass keine Auffüllung zwischen Elementen vorhanden ist. Auf dem Datenträger ein dynamisches array, in einem benutzerdefinierten Typ (mit geschriebene `FilePut`) ein Deskriptor, dessen Länge 2 plus 8 Mal der Anzahl der Dimensionen gleich, vorangestellt ist: (2 + 8 * NumberOfDimensions). Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes, die zum Lesen der einzelnen Elemente erforderlich. Dies schließt alle Arrays und ihrer Deskriptoren. Die `VBFixedString` Attribut angewendet werden kann, zu Zeichenfolgenfeldern in den Strukturen an, dass die Größe der Zeichenfolge beim Schreiben auf den Datenträger.  
  
## <a name="binary-mode"></a>Binärmodus  
 Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` -Modus-Regeln gelten, bis auf einige Ausnahmen. Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:  
  
-   Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen. `FileGet` Liest alle Variablen zusammenhängend vom Datenträger. d. h. ohne Auffüllung zwischen Datensätzen.  
  
-   Für ein beliebiges Array als ein Array in einer Struktur `FileGet` liest nur die Daten. Es wird kein Deskriptor gelesen.  
  
-   `FileGet` liest die Zeichenfolgen mit variabler Länge, die keine Elemente von Strukturen ohne erwartet den Längendeskriptor 2-Byte-sind. Die Anzahl der gelesenen Bytes entspricht die Anzahl der Zeichen, die bereits in der Zeichenfolge.  
  
    > [!IMPORTANT]
    >  Lesen aus einer Datei mithilfe der `FileGet` -Funktion erfordert `Read` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref string Value, long RecordNumber = -1, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, string&amp; Value, int64 RecordNumber, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As String, Optional RecordNumber As Long = -1, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name into which data is read.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</param>
        <param name="StringIsFixedLength">Optional. Applies only when writing a string. Specifies whether to write a two-byte descriptor for the string that describes the length. The default is <see langword="False" />.</param>
        <summary>Reads data from an open disk file into a variable. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` gilt nur in `Random` und `Binary` Modus.  
  
 Datenlesevorgänge mit `FileGet` in der Regel in eine Datei geschrieben wird, mithilfe von `FilePut`.  
  
 Der erste Datensatz oder Byte in einer Datei befindet sich an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 usw. ist. Wenn Sie weglassen `RecordNumber`, den nächsten Datensatz bzw. Byte nach dem letzten `FileGet` oder `FilePut` Funktion (oder verweist, zu dem letzten `Seek` Funktion) gelesen wird.  
  
> [!IMPORTANT]
>  Beim Lesen aus Dateien nicht Beurteilen der Inhalt einer Datei, die anhand der Dateinamenerweiterung. Eine Datei mit dem Namen "Form1.vb" möglicherweise z. B. nicht über ein Visual Basic-Quelldatei.  
  
## <a name="random-mode"></a>Zufällige Modus  
 Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:  
  
-   Wenn die Länge des zu lesenden Daten kleiner als die Länge ist, angegeben der `RecordLength` -Klausel der `FileOpen` -Funktion, `FileGet` liest nachfolgende Datensätze Datensatzlänge. Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt. Da die Menge der Leerstellen Daten nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen empfiehlt sich, die Datensatzlänge der Länge der zu lesenden Daten überein.  
  
-   Die Zielvariable eine Zeichenfolge ist, standardmäßig `FileGet` liest einen 2-Byte-Deskriptor, die Länge der Zeichenfolge enthält, und liest dann die Daten, die in die Variable aufgenommen wird. Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge. Visual Basic 6.0 und früheren Versionen unterstützen Zeichenfolgen mit fester Länge. Wenn in einer Datei zu speichern, wird der Längendeskriptor nicht geschrieben werden. Wenn Sie eine Zeichenfolge ohne Deskriptor lesen möchten, übergeben Sie `True` auf die `StringIsFixedLength` Parameter, und die Zeichenfolge, die Sie einlesen, sollte die richtige Länge.  
  
-   Wenn die Zielvariable ein Array ist, können Sie auswählen, ob einen Deskriptor für die Größe und die Dimension des Arrays zu lesen. Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`. Beim Lesen des Arrays müssen Sie die Möglichkeit zu entsprechen, die das Array geschrieben wurde. Wenn sie mit dem Deskriptor geschrieben wurde, müssen Sie den Deskriptor lesen. Der Deskriptor nicht verwendet wird, die Größe und die Grenzen des Arrays übergebenen `FileGet` ermittelt das weitere Vorgehen zu lesen.  
  
     Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang. Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl von Dimensionen: (2 + 8 * NumberOfDimensions). Die Länge des Datensatzes gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Arraydeskriptor zu schreiben. Die folgende Arraydeklaration erfordert z. B. 218 Bytes, wenn das Array geschrieben wird auf den Datenträger.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     Die 218 Bytes werden wie folgt verteilt:  
  
    -   18 Bytes für den Deskriptor: (2 + 8 * 2)  
  
    -   200 Bytes für die Daten: (10 * 5 * 4).  
  
-   Wenn die Variable in gelesen werden, andere Typen von Variablen (keine Zeichenfolge variabler Länge oder ein Objekt), `FileGet` liest nur die Daten die Variablen. Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge der Daten, die gelesen werden können.  
  
-   `FileGet` liest Sie Elemente von Strukturen, als ob einzeln gelesen wurden, mit dem Unterschied, dass keine Auffüllung zwischen Elementen vorhanden ist. Auf dem Datenträger ein dynamisches array, in einem benutzerdefinierten Typ (mit geschriebene `FilePut`) ein Deskriptor, dessen Länge 2 plus 8 Mal der Anzahl der Dimensionen gleich, vorangestellt ist: (2 + 8 * NumberOfDimensions). Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes, die zum Lesen der einzelnen Elemente erforderlich. Dies schließt alle Arrays und ihrer Deskriptoren. Die `VBFixedString` Attribut angewendet werden kann, zu Zeichenfolgenfeldern in den Strukturen an, dass die Größe der Zeichenfolge beim Schreiben auf den Datenträger.  
  
## <a name="binary-mode"></a>Binärmodus  
 Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` -Modus-Regeln gelten, bis auf einige Ausnahmen. Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:  
  
-   Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen. `FileGet` Liest alle Variablen zusammenhängend vom Datenträger. d. h. ohne Auffüllung zwischen Datensätzen.  
  
-   Für ein beliebiges Array als ein Array in einer Struktur `FileGet` liest nur die Daten. Es wird kein Deskriptor gelesen.  
  
-   `FileGet` liest die Zeichenfolgen mit variabler Länge, die keine Elemente von Strukturen ohne erwartet den Längendeskriptor 2-Byte-sind. Die Anzahl der gelesenen Bytes entspricht die Anzahl der Zeichen, die bereits in der Zeichenfolge.  
  
    > [!IMPORTANT]
    >  Lesen aus einer Datei mithilfe der `FileGet` -Funktion erfordert `Read` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, class System.Array&amp; Value, int64 RecordNumber, bool ArrayIsDynamic, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Array, Optional RecordNumber As Long = -1, Optional ArrayIsDynamic As Boolean = false, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 * bool * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber, ArrayIsDynamic, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Array&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="ArrayIsDynamic" Type="System.Boolean" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name into which data is read.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</param>
        <param name="ArrayIsDynamic">Optional. Applies only when writing an array. Specifies whether the array is to be treated as dynamic and whether an array descriptor describing the size and bounds of the array is necessary.</param>
        <param name="StringIsFixedLength">Optional. Applies only when writing a string. Specifies whether to write a two-byte descriptor for the string that describes the length. The default is <see langword="False" />.</param>
        <summary>Reads data from an open disk file into a variable. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` gilt nur in `Random` und `Binary` Modus.  
  
 Datenlesevorgänge mit `FileGet` in der Regel in eine Datei geschrieben wird, mithilfe von `FilePut`.  
  
 Der erste Datensatz oder Byte in einer Datei befindet sich an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 usw. ist. Wenn Sie weglassen `RecordNumber`, den nächsten Datensatz bzw. Byte nach dem letzten `FileGet` oder `FilePut` Funktion (oder verweist, zu dem letzten `Seek` Funktion) gelesen wird.  
  
> [!IMPORTANT]
>  Beim Lesen aus Dateien nicht Beurteilen der Inhalt einer Datei, die anhand der Dateinamenerweiterung. Eine Datei mit dem Namen "Form1.vb" möglicherweise z. B. nicht über ein Visual Basic-Quelldatei.  
  
## <a name="random-mode"></a>Zufällige Modus  
 Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:  
  
-   Wenn die Länge des zu lesenden Daten kleiner als die Länge ist, angegeben der `RecordLength` -Klausel der `FileOpen` -Funktion, `FileGet` liest nachfolgende Datensätze Datensatzlänge. Der Abstand zwischen dem Ende eines Datensatzes und das Starten des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt. Da die Menge der Leerstellen Daten nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen empfiehlt sich, die Datensatzlänge der Länge der zu lesenden Daten überein.  
  
-   Die Zielvariable eine Zeichenfolge ist, standardmäßig `FileGet` liest einen 2-Byte-Deskriptor, die Länge der Zeichenfolge enthält, und liest dann die Daten, die in die Variable aufgenommen wird. Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge. Visual Basic 6.0 und früheren Versionen unterstützen Zeichenfolgen mit fester Länge. Wenn in einer Datei zu speichern, wird der Längendeskriptor nicht geschrieben werden. Wenn Sie eine Zeichenfolge ohne Deskriptor lesen möchten, übergeben Sie `True` auf die `StringIsFixedLength` Parameter, und die Zeichenfolge, die Sie einlesen, sollte die richtige Länge.  
  
-   Wenn die Zielvariable ein Array ist, können Sie auswählen, ob einen Deskriptor für die Größe und die Dimension des Arrays zu lesen. Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`. Beim Lesen des Arrays müssen Sie die Möglichkeit zu entsprechen, die das Array geschrieben wurde. Wenn sie mit dem Deskriptor geschrieben wurde, müssen Sie den Deskriptor lesen. Der Deskriptor nicht verwendet wird, die Größe und die Grenzen des Arrays übergebenen `FileGet` ermittelt das weitere Vorgehen zu lesen.  
  
     Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang. Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl von Dimensionen: (2 + 8 * NumberOfDimensions). Die Länge des Datensatzes gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Arraydeskriptor zu schreiben. Die folgende Arraydeklaration erfordert z. B. 218 Bytes, wenn das Array geschrieben wird auf den Datenträger.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     Die 218 Bytes werden wie folgt verteilt:  
  
    -   18 Bytes für den Deskriptor: (2 + 8 * 2)  
  
    -   200 Bytes für die Daten: (10 * 5 * 4).  
  
-   Wenn die Variable in gelesen werden, andere Typen von Variablen (keine Zeichenfolge variabler Länge oder ein Objekt), `FileGet` liest nur die Daten die Variablen. Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge der Daten, die gelesen werden können.  
  
-   `FileGet` liest Sie Elemente von Strukturen, als ob einzeln gelesen wurden, mit dem Unterschied, dass keine Auffüllung zwischen Elementen vorhanden ist. Auf dem Datenträger ein dynamisches array, in einem benutzerdefinierten Typ (mit geschriebene `FilePut`) ein Deskriptor, dessen Länge 2 plus 8 Mal der Anzahl der Dimensionen gleich, vorangestellt ist: (2 + 8 * NumberOfDimensions). Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes, die zum Lesen der einzelnen Elemente erforderlich. Dies schließt alle Arrays und ihrer Deskriptoren. Die `VBFixedString` Attribut angewendet werden kann, zu Zeichenfolgenfeldern in den Strukturen an, dass die Größe der Zeichenfolge beim Schreiben auf den Datenträger.  
  
## <a name="binary-mode"></a>Binärmodus  
 Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` -Modus-Regeln gelten, bis auf einige Ausnahmen. Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:  
  
-   Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen. `FileGet` Liest alle Variablen zusammenhängend vom Datenträger. d. h. ohne Auffüllung zwischen Datensätzen.  
  
-   Für ein beliebiges Array als ein Array in einer Struktur `FileGet` liest nur die Daten. Es wird kein Deskriptor gelesen.  
  
-   `FileGet` liest die Zeichenfolgen mit variabler Länge, die keine Elemente von Strukturen ohne erwartet den Längendeskriptor 2-Byte-sind. Die Anzahl der gelesenen Bytes entspricht die Anzahl der Zeichen, die bereits in der Zeichenfolge.  
  
    > [!IMPORTANT]
    >  Lesen aus einer Datei mithilfe der `FileGet` -Funktion erfordert `Read` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGetObject">
      <MemberSignature Language="C#" Value="public static void FileGetObject (int FileNumber, ref object Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGetObject(int32 FileNumber, object&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGetObject (FileNumber As Integer, ByRef Value As Object, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGetObject : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGetObject (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name into which data is read.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</param>
        <summary>Reads data from an open disk file into a variable.  The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGetObject" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `FileGetObject` -Funktion wird verwendet, statt `FileGet` um Mehrdeutigkeiten zum Zeitpunkt der Kompilierung zu vermeiden, wenn Typ `Object` wird z. B. anstelle eines anderen Typs zurückgegeben `Integer`, `Long`, `Short`usw. lauten.  
  
 Wenn Sie beabsichtigen, schreiben die `Variant` Typ `FileGetObject` ist erforderlich. Im Zweifelsfall, wenn Sie ein Objekt für den zweiten Parameter verwenden, wird immer empfohlen, dass Sie verwenden `FilePutObject` und `FileGetObject`.  
  
 `FileGetObject` gilt nur in `Random` und `Binary` Modus.  
  
 Datenlesevorgänge mit `FileGetObject` wird in der Regel mit geschrieben `FilePutObject`.  
  
 Der erste Datensatz oder Byte in einer Datei befindet sich an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 usw. ist. Wenn Sie weglassen `RecordNumber`, `FileGetObject` liest den Datensatz oder ein Byte nach dem letzten `FileGetObject` oder `FilePutObject` Funktion (oder verweist, zu dem letzten `Seek` Funktion).  
  
## <a name="random-mode"></a>Zufällige Modus  
 Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:  
  
-   Wenn die Länge des zu lesenden Daten kleiner als die Länge ist, angegeben der `RecordLength` -Klausel der `FileOpen` -Funktion, `FileGetObject` liest nachfolgende Datensätze Datensatzlänge. Der Abstand zwischen dem Ende eines Datensatzes und den Anfang des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt. Da die Menge der Leerstellen Daten genau ermittelt werden kann, ist es sinnvoll, die Datensatzlänge der Länge der zu lesenden Daten überein.  
  
-   Wenn die Zielvariable eine Zeichenfolge, in der Standardeinstellung ist `FileGetObject` liest einen 2-Byte-Deskriptor mit der Zeichenfolgenlänge und liest dann die Daten, die in die Variable aufgenommen wird. Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge. Visual Basic 6.0 und früheren Versionen unterstützen Zeichenfolgen mit fester Länge und in eine Datei beim Lesen der Längendeskriptor nicht geschrieben werden. Wenn Sie eine Zeichenfolge ohne Deskriptor lesen möchten, übergeben Sie `True` auf die `StringIsFixedLength` Parameter, und die Zeichenfolge, die Sie einlesen, sollte die richtige Länge.  
  
-   Wenn die Zielvariable ein Array, und klicken Sie dann auf die angegebene Datensatzlänge ist die `RecordLength` Parameter in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Arraydeskriptor zu schreiben. Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang. Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl von Dimensionen: 2 + 8 * NumberOfDimensions.  
  
     Die folgende Arraydeklaration erfordert z. B. 218 Bytes, wenn das Array geschrieben wird auf den Datenträger:  
  
     [!code-vb[VbVbalrCatRef#27](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#27)]  
  
     Die 218 Bytes werden wie folgt verteilt: 18 Bytes für den Deskriptor (2 + 8 * 2) und 100 Bytes für die Daten (10 * 5 * 4).  
  
-   `FileGetObject` liest Sie Elemente von Strukturen, als ob einzeln gelesen wurden, mit dem Unterschied, dass keine Auffüllung zwischen Elementen vorhanden ist. Auf dem Datenträger ein dynamisches array, in einem benutzerdefinierten Typ (mit geschriebene `FilePutObject`) ein Deskriptor, dessen Länge 2 plus 8 Mal der Anzahl der Dimensionen gleich, vorangestellt ist: 2 + 8 * NumberOfDimensions. Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes, die zum Lesen der einzelnen Elemente, einschließlich aller Arrays und ihrer Deskriptoren erforderlich. Die <xref:Microsoft.VisualBasic.VBFixedStringAttribute> Klasse angewendet werden kann, zu Zeichenfolgenfeldern in den Strukturen an, dass die Größe der Zeichenfolge beim Schreiben auf den Datenträger.  
  
## <a name="binary-mode"></a>Binärmodus  
 Für Dateien in geöffnet `Binary` aller-Modus die `Random` Regeln anwenden, mit den folgenden Ausnahmen:  
  
-   Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen. `FileGetObject` Liest alle Variablen vom Datenträger zusammenhängend, d. h. ohne Abstand zwischen den Datensätzen.  
  
-   Für ein beliebiges Array als ein Array in einer Struktur `FileGetObject` liest nur die Daten. Es wird kein Deskriptor gelesen.  
  
 `FileGetObject` liest die Zeichenfolgen mit variabler Länge, die keine Elemente von Strukturen ohne erwartet den Längendeskriptor 2-Byte-sind. Die Anzahl der gelesenen Bytes entspricht die Anzahl der Zeichen, die bereits in der Zeichenfolge.  
  
> [!IMPORTANT]
>  Beim Lesen aus Dateien nicht Beurteilen der Inhalt einer Datei, die anhand der Dateinamenerweiterung. Eine Datei namens "Form1.vb" möglicherweise z. B. keine Visual Basic-Quelldatei.  
  
   
  
## Examples  
 Im folgenden Beispiel liest, einen Datensatz in einer Testdatei und ruft dann ab.  
  
 [!code-vb[VbVbalrCatRef#26](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#26)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
      </Docs>
    </Member>
    <Member MemberName="FileLen">
      <MemberSignature Language="C#" Value="public static long FileLen (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 FileLen(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileLen (PathName As String) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long FileLen(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member FileLen : string -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.FileLen PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">Required. <see langword="String" /> expression that specifies a file. <c>PathName</c> may include the directory or folder, and the drive.</param>
        <summary>Returns a <see langword="Long" /> value that specifies the length of a file in bytes. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileLen" />. For more information, see <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />.</summary>
        <returns>
          <see langword="Long" /> value that specifies the length of a file in bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die angegebene Datei geöffnet wann ist die `FileLen` Funktion aufgerufen wird, wird der zurückgegebene Wert stellt die Größe der Datei zu dem Zeitpunkt, der sie geöffnet wurde.  
  
> [!NOTE]
>  Um die aktuelle Länge einer geöffneten Datei abzurufen, verwenden die `LOF` Funktion.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `FileLen` Funktion, um die Länge einer Datei in Bytes zurück. Für dieses Beispiel wird davon ausgegangen, die `TestFile` ist eine Datei, die einige Daten enthält.  
  
 [!code-vb[VbVbalrCatRef#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">File does not exist.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <Member MemberName="FileOpen">
      <MemberSignature Language="C#" Value="public static void FileOpen (int FileNumber, string FileName, Microsoft.VisualBasic.OpenMode Mode, Microsoft.VisualBasic.OpenAccess Access = Microsoft.VisualBasic.OpenAccess.Default, Microsoft.VisualBasic.OpenShare Share = Microsoft.VisualBasic.OpenShare.Default, int RecordLength = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileOpen(int32 FileNumber, string FileName, valuetype Microsoft.VisualBasic.OpenMode Mode, valuetype Microsoft.VisualBasic.OpenAccess Access, valuetype Microsoft.VisualBasic.OpenShare Share, int32 RecordLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileOpen (FileNumber As Integer, FileName As String, Mode As OpenMode, Optional Access As OpenAccess = Microsoft.VisualBasic.OpenAccess.Default, Optional Share As OpenShare = Microsoft.VisualBasic.OpenShare.Default, Optional RecordLength As Integer = -1)" />
      <MemberSignature Language="F#" Value="static member FileOpen : int * string * Microsoft.VisualBasic.OpenMode * Microsoft.VisualBasic.OpenAccess * Microsoft.VisualBasic.OpenShare * int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileOpen (FileNumber, FileName, Mode, Access, Share, RecordLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FileName" Type="System.String" />
        <Parameter Name="Mode" Type="Microsoft.VisualBasic.OpenMode" />
        <Parameter Name="Access" Type="Microsoft.VisualBasic.OpenAccess" />
        <Parameter Name="Share" Type="Microsoft.VisualBasic.OpenShare" />
        <Parameter Name="RecordLength" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number. Use the <see langword="FreeFile" /> function to obtain the next available file number.</param>
        <param name="FileName">Required. <see langword="String" /> expression that specifies a file name—may include directory or folder, and drive.</param>
        <param name="Mode">Required. Enumeration specifying the file mode: <see langword="Append" />, <see langword="Binary" />, <see langword="Input" />, <see langword="Output" />, or <see langword="Random" />. For more information, see <see cref="T:Microsoft.VisualBasic.OpenMode" /> .</param>
        <param name="Access">Optional. Enumeration specifying the operations permitted on the open file: <see langword="Read" />, <see langword="Write" />, or <see langword="ReadWrite" />. Defaults to <see langword="ReadWrite" />. For more information, see <see cref="T:Microsoft.VisualBasic.OpenAccess" /> .</param>
        <param name="Share">Optional. Enumeration specifying the operations not permitted on the open file by other processes: <see langword="Shared" />, <see langword="Lock Read" />, <see langword="Lock Write" />, and <see langword="Lock Read Write" />. Defaults to <see langword="Lock Read Write" />. For more information, see <see cref="T:Microsoft.VisualBasic.OpenShare" /> .</param>
        <param name="RecordLength">Optional. Number less than or equal to 32,767 (bytes). For files opened for random access, this value is the record length. For sequential files, this value is the number of characters buffered.</param>
        <summary>Opens a file for input or output. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileOpen" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `FileOpen` Funktion wird für Abwärtskompatibilität angeboten und die Leistung beeinträchtigen. Für nicht-Legacyanwendungen der `My.Computer.FileSystem` Objekt bietet eine bessere Leistung. Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Sie müssen eine Datei öffnen, bevor alle e/a-Vorgang darauf ausgeführt werden kann. `FileOpen` reserviert einen Puffer für e/a auf die Datei, und bestimmt den Modus des Zugriffs für die Verwendung mit dem Puffer.  
  
> [!IMPORTANT]
>  Beim Schreiben in eine Datei eine Anwendung möglicherweise eine Datei erstellen, wenn die Datei mit der er schreiben möchte nicht vorhanden ist. Zu diesem Zweck benötigt er die Berechtigung für das Verzeichnis, in dem die Datei erstellt werden. Jedoch, wenn die Datei durch angegeben `FileName` vorhanden ist, muss die Anwendung `Write` Berechtigungen nur für die Datei selbst. Immer, wenn möglich, zur Verbesserung der Sicherheit erstellen Sie die Datei während der Bereitstellung und gewähren Sie `Write` Berechtigungen für diese Datei nur, anstatt das gesamte Verzeichnis. Schreiben Sie Daten in Verzeichnissen nach Benutzer statt auf das Stammverzeichnis oder das Verzeichnis für Programmdateien, um Sicherheit zu verbessern.  
  
 Der Kanal geöffnet verwendbaren mithilfe der `FreeFile()` Funktion.  
  
> [!IMPORTANT]
>  Die `FileOpen` -Funktion erfordert `Read` aus Zugriff auf die `FileIOPermissionAccess` -Enumeration, die sich möglicherweise auf ihre Ausführung in teilweise vertrauenswürdigen Umgebungen auswirken. Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.  
  
   
  
## Examples  
 Dieses Beispiel zeigt verschiedene Verwendungsmöglichkeiten der der `FileOpen` Funktion, um ein- und Ausgabe in eine Datei zu ermöglichen.  
  
 Der folgende Code öffnet die Datei `TestFile` in `Input` Modus.  
  
 [!code-vb[VbVbalrCatRef#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#5)]  
  
 In diesem Beispiel öffnet die Datei im `Binary` Modus ausschließlich für Schreibvorgänge.  
  
 [!code-vb[VbVbalrCatRef#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#6)]  
  
 Das folgende Beispiel öffnet die Datei im `Random` Modus. Die Datei enthält die Datensätze mit der Struktur `Person`.  
  
 [!code-vb[VbVbalrCatRef#7](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#7)]  
  
 Dieses Codebeispiel öffnet die Datei im `Output` Modus; jeder Prozess kann lesen oder Schreiben in die Datei.  
  
 [!code-vb[VbVbalrCatRef#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#8)]  
  
 Dieses Codebeispiel öffnet die Datei im `Binary` Modus zum Lesen; andere Prozesse die Datei können nicht gelesen werden.  
  
 [!code-vb[VbVbalrCatRef#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Record length is negative (and not equal to -1).</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="FileName" /> is already open, or <paramref name="FileName" /> is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FreeFile" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FilePut">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Writes data from a variable to a disk file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />. F For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, bool Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, bool Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Boolean, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * bool * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name that contains data written to disk.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</param>
        <summary>Writes data from a variable to a disk file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` gilt nur in `Random` und `Binary` Modus.  
  
 Mit `FilePut` geschriebene Daten werden in der Regel mit `FileGet` aus einer Datei gelesen.  
  
 Der erste Datensatz oder Byte in einer Datei befindet sich an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 usw. ist. Wenn Sie weglassen `RecordNumber`, den nächsten Datensatz bzw. Byte nach dem letzten `FileGet` oder `FilePut` Funktion oder verweist, zu dem letzten `Seek` Funktion geschrieben wird.  
  
 Die `StringIsFixedLength` -Argument steuert, ob die Funktion Zeichenfolgen als Variable oder feste Länge interpretiert. `FilePut` den Längendeskriptor wird nicht geschrieben werden, wenn das Argument ist `True`. Bei Verwendung von `StringIsFixedLength`  =  `True` mit `FilePut`, was identisch mit `FileGet`, und Sie müssen sicherstellen, dass die Zeichenfolge mit der erwarteten Länge initialisiert wird.  
  
## <a name="random-mode"></a>Zufällige Modus  
 Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:  
  
-   Wenn die Länge des zu schreibenden Daten kleiner als die Länge ist, angegeben der `RecordLength` -Klausel der `FileOpen` -Funktion, `FilePut` nachfolgende Datensätze auf Datensatzlänge schreibt. Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt. Da die Menge der Leerstellen Daten nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen empfiehlt sich, die Datensatzlänge der Länge der zu schreibenden Daten überein. Ist die Länge des zu schreibenden Daten größer als die Länge, angegeben der `RecordLength` -Klausel der `FileOpen` -Funktion eine Ausnahme ausgelöst.  
  
-   Eine Zeichenfolge ist, die Zielvariable `FilePut` schreibt einen 2-Byte-Deskriptor, der die Länge der Zeichenfolge enthält, und schreibt dann die Daten, die in die Variable aufgenommen wird. Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge sein.  
  
-   Wenn die Zielvariable ein Objekt ist, die einen numerischen Typ enthält `FilePut` zwei Bytes, identifizieren den `VarType` des Objekts und schreibt dann die Variable. Enthält z. B. wenn ein Objekt zu schreiben, die eine ganze Zahl `FilePut` schreibt sechs Bytes: 2 Bytes, die Identifizierung des Objekts als `VarType(3)` (`Integer`) und vier Bytes, die Daten enthalten. Die angegebene Datensatzlänge der `RecordLength` Parameter in der `FileOpen` Funktion muss mindestens zwei Bytes größer als die tatsächliche Anzahl von Bytes, die zum Speichern von Variablen erforderlich sein.  
  
-   Ist die Zielvariable ein Objekt, das eine Zeichenfolge enthält `FilePut` schreibt eine 2-Byte-Deskriptor, identifiziert die `VarType(8)` des Objekts, ein 2-Byte-Deskriptor, der angibt, der Länge der Zeichenfolge und anschließend die Zeichenfolgendaten. Die angegebene Datensatzlänge der `RecordLength` Parameter in der `FileOpen` Funktion muss mindestens vier Bytes größer als die tatsächliche Länge der Zeichenfolge sein. Wenn Sie eine Zeichenfolge ohne Deskriptor ablegen möchten, sollten Sie übergeben `True` auf die `StringIsFixedLength` Parameter, und die Zeichenfolge, die Sie einlesen, sollte die richtige Länge.  
  
-   Wenn die Zielvariable ein Array ist, müssen Sie eine Auswahl, ob einen Deskriptor für die Größe und die Dimensionen des Arrays zu schreiben. Visual Basic 6.0 und früheren Versionen Dateideskriptor für dynamische Arrays und nicht für Arrays mit fester Größe zu schreiben. Visual Basic 2005 standardmäßig kein Deskriptor geschrieben. Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`. Wenn das Array zu schreiben, müssen Sie entsprechend der Weise wird das Array gelesen werden; Wenn mit dem Deskriptor gelesen werden, müssen Sie den Deskriptor schreiben. Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang. Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl von Dimensionen: (2 + 8 * NumberOfDimensions). Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Arraydeskriptor zu schreiben. Die folgende Arraydeklaration erfordert z. B. 218 Bytes, wenn das Array geschrieben wird auf den Datenträger.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Wenn die Zielvariable einen anderen Typ der Variable (keine Zeichenfolge variabler Länge oder ein Objekt), ist `FilePut` schreibt nur die Daten der Variablen. Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge der zu schreibenden Daten.  
  
-   `FilePut` Schreibt die Elemente von Strukturen, als ob jeder einzeln geschrieben wurden jedoch keine Auffüllung zwischen Elementen. Die `VBFixedString` Attribut angewendet werden kann, zu Zeichenfolgenfeldern in den Strukturen an, dass die Größe der Zeichenfolge beim Schreiben auf den Datenträger.  
  
    > [!NOTE]
    >  String-Felder, die mehr als Bytes angegeben die `VBFixedString` Attribut werden abgeschnitten, beim Schreiben auf den Datenträger  
  
## <a name="binary-mode"></a>Binärmodus  
 Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` -Modus-Regeln gelten, bis auf einige Ausnahmen. Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:  
  
-   Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen. `FilePut` Schreibt alle Variablen zusammenhängend, d. h. ohne Leerraum zwischen Datensätzen Datenträger an.  
  
-   Für ein beliebiges Array als ein Array in einer Struktur `FilePut` schreibt nur die Daten. Es wird kein Deskriptor geschrieben.  
  
-   `FilePut` schreibt Zeichenfolgen variabler Länge, die keine Elemente von Strukturen ohne Längendeskriptor 2-Byte-sind. Die Anzahl der geschriebenen Bytes entspricht die Anzahl der Zeichen in der Zeichenfolge. Die folgenden Anweisungen wird z. B. 11 Bytes Datei Zahl 1 schreiben:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Schreiben in eine Datei mithilfe der `FilePut` -Funktion erfordert `Write` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `FilePut` Funktion, um Daten in eine Datei schreiben. Fünf Datensätze der Struktur `Person` in die Datei geschrieben werden.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, byte Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, unsigned int8 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Byte, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * byte * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name that contains data written to disk.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</param>
        <summary>Writes data from a variable to a disk file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` gilt nur in `Random` und `Binary` Modus.  
  
 Mit `FilePut` geschriebene Daten werden in der Regel mit `FileGet` aus einer Datei gelesen.  
  
 Der erste Datensatz oder Byte in einer Datei befindet sich an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 usw. ist. Wenn Sie weglassen `RecordNumber`, den nächsten Datensatz bzw. Byte nach dem letzten `FileGet` oder `FilePut` Funktion oder verweist, zu dem letzten `Seek` Funktion geschrieben wird.  
  
 Die `StringIsFixedLength` -Argument steuert, ob die Funktion Zeichenfolgen als Variable oder feste Länge interpretiert. `FilePut` den Längendeskriptor wird nicht geschrieben werden, wenn das Argument ist `True`. Bei Verwendung von `StringIsFixedLength`  =  `True` mit `FilePut`, was identisch mit `FileGet`, und Sie müssen sicherstellen, dass die Zeichenfolge mit der erwarteten Länge initialisiert wird.  
  
## <a name="random-mode"></a>Zufällige Modus  
 Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:  
  
-   Wenn die Länge des zu schreibenden Daten kleiner als die Länge ist, angegeben der `RecordLength` -Klausel der `FileOpen` -Funktion, `FilePut` nachfolgende Datensätze auf Datensatzlänge schreibt. Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt. Da die Menge der Leerstellen Daten nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen empfiehlt sich, die Datensatzlänge der Länge der zu schreibenden Daten überein. Ist die Länge des zu schreibenden Daten größer als die Länge, angegeben der `RecordLength` -Klausel der `FileOpen` -Funktion eine Ausnahme ausgelöst.  
  
-   Eine Zeichenfolge ist, die Zielvariable `FilePut` schreibt einen 2-Byte-Deskriptor, der die Länge der Zeichenfolge enthält, und schreibt dann die Daten, die in die Variable aufgenommen wird. Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge sein.  
  
-   Wenn die Zielvariable ein Objekt ist, die einen numerischen Typ enthält `FilePut` zwei Bytes, identifizieren den `VarType` des Objekts und schreibt dann die Variable. Enthält z. B. wenn ein Objekt zu schreiben, die eine ganze Zahl `FilePut` schreibt sechs Bytes: 2 Bytes, die Identifizierung des Objekts als `VarType(3)` (`Integer`) und vier Bytes, die Daten enthalten. Die angegebene Datensatzlänge der `RecordLength` Parameter in der `FileOpen` Funktion muss mindestens zwei Bytes größer als die tatsächliche Anzahl von Bytes, die zum Speichern von Variablen erforderlich sein.  
  
-   Ist die Zielvariable ein Objekt, das eine Zeichenfolge enthält `FilePut` schreibt eine 2-Byte-Deskriptor, identifiziert die `VarType(8)` des Objekts, ein 2-Byte-Deskriptor, der angibt, der Länge der Zeichenfolge und anschließend die Zeichenfolgendaten. Die angegebene Datensatzlänge der `RecordLength` Parameter in der `FileOpen` Funktion muss mindestens vier Bytes größer als die tatsächliche Länge der Zeichenfolge sein. Wenn Sie eine Zeichenfolge ohne Deskriptor ablegen möchten, sollten Sie übergeben `True` auf die `StringIsFixedLength` Parameter, und die Zeichenfolge, die Sie einlesen, sollte die richtige Länge.  
  
-   Wenn die Zielvariable ein Array ist, müssen Sie eine Auswahl, ob einen Deskriptor für die Größe und die Dimensionen des Arrays zu schreiben. Visual Basic 6.0 und früheren Versionen Dateideskriptor für dynamische Arrays und nicht für Arrays mit fester Größe zu schreiben. Visual Basic 2005 standardmäßig kein Deskriptor geschrieben. Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`. Wenn das Array zu schreiben, müssen Sie entsprechend der Weise wird das Array gelesen werden; Wenn mit dem Deskriptor gelesen werden, müssen Sie den Deskriptor schreiben. Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang. Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl von Dimensionen: (2 + 8 * NumberOfDimensions). Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Arraydeskriptor zu schreiben. Die folgende Arraydeklaration erfordert z. B. 218 Bytes, wenn das Array geschrieben wird auf den Datenträger.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Wenn die Zielvariable einen anderen Typ der Variable (keine Zeichenfolge variabler Länge oder ein Objekt), ist `FilePut` schreibt nur die Daten der Variablen. Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge der zu schreibenden Daten.  
  
-   `FilePut` Schreibt die Elemente von Strukturen, als ob jeder einzeln geschrieben wurden jedoch keine Auffüllung zwischen Elementen. Die `VBFixedString` Attribut angewendet werden kann, zu Zeichenfolgenfeldern in den Strukturen an, dass die Größe der Zeichenfolge beim Schreiben auf den Datenträger.  
  
    > [!NOTE]
    >  String-Felder, die mehr als Bytes angegeben die `VBFixedString` Attribut werden abgeschnitten, beim Schreiben auf den Datenträger  
  
## <a name="binary-mode"></a>Binärmodus  
 Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` -Modus-Regeln gelten, bis auf einige Ausnahmen. Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:  
  
-   Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen. `FilePut` Schreibt alle Variablen zusammenhängend, d. h. ohne Leerraum zwischen Datensätzen Datenträger an.  
  
-   Für ein beliebiges Array als ein Array in einer Struktur `FilePut` schreibt nur die Daten. Es wird kein Deskriptor geschrieben.  
  
-   `FilePut` schreibt Zeichenfolgen variabler Länge, die keine Elemente von Strukturen ohne Längendeskriptor 2-Byte-sind. Die Anzahl der geschriebenen Bytes entspricht die Anzahl der Zeichen in der Zeichenfolge. Die folgenden Anweisungen wird z. B. 11 Bytes Datei Zahl 1 schreiben:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Schreiben in eine Datei mithilfe der `FilePut` -Funktion erfordert `Write` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `FilePut` Funktion, um Daten in eine Datei schreiben. Fünf Datensätze der Struktur `Person` in die Datei geschrieben werden.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, char Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, char Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Char, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * char * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name that contains data written to disk.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</param>
        <summary>Writes data from a variable to a disk file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` gilt nur in `Random` und `Binary` Modus.  
  
 Mit `FilePut` geschriebene Daten werden in der Regel mit `FileGet` aus einer Datei gelesen.  
  
 Der erste Datensatz oder Byte in einer Datei befindet sich an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 usw. ist. Wenn Sie weglassen `RecordNumber`, den nächsten Datensatz bzw. Byte nach dem letzten `FileGet` oder `FilePut` Funktion oder verweist, zu dem letzten `Seek` Funktion geschrieben wird.  
  
 Die `StringIsFixedLength` -Argument steuert, ob die Funktion Zeichenfolgen als Variable oder feste Länge interpretiert. `FilePut` den Längendeskriptor wird nicht geschrieben werden, wenn das Argument ist `True`. Bei Verwendung von `StringIsFixedLength`  =  `True` mit `FilePut`, was identisch mit `FileGet`, und Sie müssen sicherstellen, dass die Zeichenfolge mit der erwarteten Länge initialisiert wird.  
  
## <a name="random-mode"></a>Zufällige Modus  
 Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:  
  
-   Wenn die Länge des zu schreibenden Daten kleiner als die Länge ist, angegeben der `RecordLength` -Klausel der `FileOpen` -Funktion, `FilePut` nachfolgende Datensätze auf Datensatzlänge schreibt. Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt. Da die Menge der Leerstellen Daten nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen empfiehlt sich, die Datensatzlänge der Länge der zu schreibenden Daten überein. Ist die Länge des zu schreibenden Daten größer als die Länge, angegeben der `RecordLength` -Klausel der `FileOpen` -Funktion eine Ausnahme ausgelöst.  
  
-   Eine Zeichenfolge ist, die Zielvariable `FilePut` schreibt einen 2-Byte-Deskriptor, der die Länge der Zeichenfolge enthält, und schreibt dann die Daten, die in die Variable aufgenommen wird. Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge sein.  
  
-   Wenn die Zielvariable ein Objekt ist, die einen numerischen Typ enthält `FilePut` zwei Bytes, identifizieren den `VarType` des Objekts und schreibt dann die Variable. Enthält z. B. wenn ein Objekt zu schreiben, die eine ganze Zahl `FilePut` schreibt sechs Bytes: 2 Bytes, die Identifizierung des Objekts als `VarType(3)` (`Integer`) und vier Bytes, die Daten enthalten. Die angegebene Datensatzlänge der `RecordLength` Parameter in der `FileOpen` Funktion muss mindestens zwei Bytes größer als die tatsächliche Anzahl von Bytes, die zum Speichern von Variablen erforderlich sein.  
  
-   Ist die Zielvariable ein Objekt, das eine Zeichenfolge enthält `FilePut` schreibt eine 2-Byte-Deskriptor, identifiziert die `VarType(8)` des Objekts, ein 2-Byte-Deskriptor, der angibt, der Länge der Zeichenfolge und anschließend die Zeichenfolgendaten. Die angegebene Datensatzlänge der `RecordLength` Parameter in der `FileOpen` Funktion muss mindestens vier Bytes größer als die tatsächliche Länge der Zeichenfolge sein. Wenn Sie eine Zeichenfolge ohne Deskriptor ablegen möchten, sollten Sie übergeben `True` auf die `StringIsFixedLength` Parameter, und die Zeichenfolge, die Sie einlesen, sollte die richtige Länge.  
  
-   Wenn die Zielvariable ein Array ist, müssen Sie eine Auswahl, ob einen Deskriptor für die Größe und die Dimensionen des Arrays zu schreiben. Visual Basic 6.0 und früheren Versionen Dateideskriptor für dynamische Arrays und nicht für Arrays mit fester Größe zu schreiben. Visual Basic 2005 standardmäßig kein Deskriptor geschrieben. Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`. Wenn das Array zu schreiben, müssen Sie entsprechend der Weise wird das Array gelesen werden; Wenn mit dem Deskriptor gelesen werden, müssen Sie den Deskriptor schreiben. Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang. Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl von Dimensionen: (2 + 8 * NumberOfDimensions). Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Arraydeskriptor zu schreiben. Die folgende Arraydeklaration erfordert z. B. 218 Bytes, wenn das Array geschrieben wird auf den Datenträger.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Wenn die Zielvariable einen anderen Typ der Variable (keine Zeichenfolge variabler Länge oder ein Objekt), ist `FilePut` schreibt nur die Daten der Variablen. Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge der zu schreibenden Daten.  
  
-   `FilePut` Schreibt die Elemente von Strukturen, als ob jeder einzeln geschrieben wurden jedoch keine Auffüllung zwischen Elementen. Die `VBFixedString` Attribut angewendet werden kann, zu Zeichenfolgenfeldern in den Strukturen an, dass die Größe der Zeichenfolge beim Schreiben auf den Datenträger.  
  
    > [!NOTE]
    >  String-Felder, die mehr als Bytes angegeben die `VBFixedString` Attribut werden abgeschnitten, beim Schreiben auf den Datenträger  
  
## <a name="binary-mode"></a>Binärmodus  
 Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` -Modus-Regeln gelten, bis auf einige Ausnahmen. Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:  
  
-   Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen. `FilePut` Schreibt alle Variablen zusammenhängend, d. h. ohne Leerraum zwischen Datensätzen Datenträger an.  
  
-   Für ein beliebiges Array als ein Array in einer Struktur `FilePut` schreibt nur die Daten. Es wird kein Deskriptor geschrieben.  
  
-   `FilePut` schreibt Zeichenfolgen variabler Länge, die keine Elemente von Strukturen ohne Längendeskriptor 2-Byte-sind. Die Anzahl der geschriebenen Bytes entspricht die Anzahl der Zeichen in der Zeichenfolge. Die folgenden Anweisungen wird z. B. 11 Bytes Datei Zahl 1 schreiben:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Schreiben in eine Datei mithilfe der `FilePut` -Funktion erfordert `Write` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `FilePut` Funktion, um Daten in eine Datei schreiben. Fünf Datensätze der Struktur `Person` in die Datei geschrieben werden.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, DateTime Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, valuetype System.DateTime Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As DateTime, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * DateTime * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name that contains data written to disk.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</param>
        <summary>Writes data from a variable to a disk file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` gilt nur in `Random` und `Binary` Modus.  
  
 Mit `FilePut` geschriebene Daten werden in der Regel mit `FileGet` aus einer Datei gelesen.  
  
 Der erste Datensatz oder Byte in einer Datei befindet sich an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 usw. ist. Wenn Sie weglassen `RecordNumber`, den nächsten Datensatz bzw. Byte nach dem letzten `FileGet` oder `FilePut` Funktion oder verweist, zu dem letzten `Seek` Funktion geschrieben wird.  
  
 Die `StringIsFixedLength` -Argument steuert, ob die Funktion Zeichenfolgen als Variable oder feste Länge interpretiert. `FilePut` den Längendeskriptor wird nicht geschrieben werden, wenn das Argument ist `True`. Bei Verwendung von `StringIsFixedLength`  =  `True` mit `FilePut`, was identisch mit `FileGet`, und Sie müssen sicherstellen, dass die Zeichenfolge mit der erwarteten Länge initialisiert wird.  
  
## <a name="random-mode"></a>Zufällige Modus  
 Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:  
  
-   Wenn die Länge des zu schreibenden Daten kleiner als die Länge ist, angegeben der `RecordLength` -Klausel der `FileOpen` -Funktion, `FilePut` nachfolgende Datensätze auf Datensatzlänge schreibt. Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt. Da die Menge der Leerstellen Daten nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen empfiehlt sich, die Datensatzlänge der Länge der zu schreibenden Daten überein. Ist die Länge des zu schreibenden Daten größer als die Länge, angegeben der `RecordLength` -Klausel der `FileOpen` -Funktion eine Ausnahme ausgelöst.  
  
-   Eine Zeichenfolge ist, die Zielvariable `FilePut` schreibt einen 2-Byte-Deskriptor, der die Länge der Zeichenfolge enthält, und schreibt dann die Daten, die in die Variable aufgenommen wird. Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge sein.  
  
-   Wenn die Zielvariable ein Objekt ist, die einen numerischen Typ enthält `FilePut` zwei Bytes, identifizieren den `VarType` des Objekts und schreibt dann die Variable. Enthält z. B. wenn ein Objekt zu schreiben, die eine ganze Zahl `FilePut` schreibt sechs Bytes: 2 Bytes, die Identifizierung des Objekts als `VarType(3)` (`Integer`) und vier Bytes, die Daten enthalten. Die angegebene Datensatzlänge der `RecordLength` Parameter in der `FileOpen` Funktion muss mindestens zwei Bytes größer als die tatsächliche Anzahl von Bytes, die zum Speichern von Variablen erforderlich sein.  
  
-   Ist die Zielvariable ein Objekt, das eine Zeichenfolge enthält `FilePut` schreibt eine 2-Byte-Deskriptor, identifiziert die `VarType(8)` des Objekts, ein 2-Byte-Deskriptor, der angibt, der Länge der Zeichenfolge und anschließend die Zeichenfolgendaten. Die angegebene Datensatzlänge der `RecordLength` Parameter in der `FileOpen` Funktion muss mindestens vier Bytes größer als die tatsächliche Länge der Zeichenfolge sein. Wenn Sie eine Zeichenfolge ohne Deskriptor ablegen möchten, sollten Sie übergeben `True` auf die `StringIsFixedLength` Parameter, und die Zeichenfolge, die Sie einlesen, sollte die richtige Länge.  
  
-   Wenn die Zielvariable ein Array ist, müssen Sie eine Auswahl, ob einen Deskriptor für die Größe und die Dimensionen des Arrays zu schreiben. Visual Basic 6.0 und früheren Versionen Dateideskriptor für dynamische Arrays und nicht für Arrays mit fester Größe zu schreiben. Visual Basic 2005 standardmäßig kein Deskriptor geschrieben. Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`. Wenn das Array zu schreiben, müssen Sie entsprechend der Weise wird das Array gelesen werden; Wenn mit dem Deskriptor gelesen werden, müssen Sie den Deskriptor schreiben. Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang. Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl von Dimensionen: (2 + 8 * NumberOfDimensions). Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Arraydeskriptor zu schreiben. Die folgende Arraydeklaration erfordert z. B. 218 Bytes, wenn das Array geschrieben wird auf den Datenträger.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Wenn die Zielvariable einen anderen Typ der Variable (keine Zeichenfolge variabler Länge oder ein Objekt), ist `FilePut` schreibt nur die Daten der Variablen. Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge der zu schreibenden Daten.  
  
-   `FilePut` Schreibt die Elemente von Strukturen, als ob jeder einzeln geschrieben wurden jedoch keine Auffüllung zwischen Elementen. Die `VBFixedString` Attribut angewendet werden kann, zu Zeichenfolgenfeldern in den Strukturen an, dass die Größe der Zeichenfolge beim Schreiben auf den Datenträger.  
  
    > [!NOTE]
    >  String-Felder, die mehr als Bytes angegeben die `VBFixedString` Attribut werden abgeschnitten, beim Schreiben auf den Datenträger  
  
## <a name="binary-mode"></a>Binärmodus  
 Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` -Modus-Regeln gelten, bis auf einige Ausnahmen. Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:  
  
-   Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen. `FilePut` Schreibt alle Variablen zusammenhängend, d. h. ohne Leerraum zwischen Datensätzen Datenträger an.  
  
-   Für ein beliebiges Array als ein Array in einer Struktur `FilePut` schreibt nur die Daten. Es wird kein Deskriptor geschrieben.  
  
-   `FilePut` schreibt Zeichenfolgen variabler Länge, die keine Elemente von Strukturen ohne Längendeskriptor 2-Byte-sind. Die Anzahl der geschriebenen Bytes entspricht die Anzahl der Zeichen in der Zeichenfolge. Die folgenden Anweisungen wird z. B. 11 Bytes Datei Zahl 1 schreiben:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Schreiben in eine Datei mithilfe der `FilePut` -Funktion erfordert `Write` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `FilePut` Funktion, um Daten in eine Datei schreiben. Fünf Datensätze der Struktur `Person` in die Datei geschrieben werden.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, decimal Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, valuetype System.Decimal Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Decimal, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * decimal * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name that contains data written to disk.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</param>
        <summary>Writes data from a variable to a disk file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` gilt nur in `Random` und `Binary` Modus.  
  
 Mit `FilePut` geschriebene Daten werden in der Regel mit `FileGet` aus einer Datei gelesen.  
  
 Der erste Datensatz oder Byte in einer Datei befindet sich an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 usw. ist. Wenn Sie weglassen `RecordNumber`, den nächsten Datensatz bzw. Byte nach dem letzten `FileGet` oder `FilePut` Funktion oder verweist, zu dem letzten `Seek` Funktion geschrieben wird.  
  
 Die `StringIsFixedLength` -Argument steuert, ob die Funktion Zeichenfolgen als Variable oder feste Länge interpretiert. `FilePut` den Längendeskriptor wird nicht geschrieben werden, wenn das Argument ist `True`. Bei Verwendung von `StringIsFixedLength`  =  `True` mit `FilePut`, was identisch mit `FileGet`, und Sie müssen sicherstellen, dass die Zeichenfolge mit der erwarteten Länge initialisiert wird.  
  
## <a name="random-mode"></a>Zufällige Modus  
 Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:  
  
-   Wenn die Länge des zu schreibenden Daten kleiner als die Länge ist, angegeben der `RecordLength` -Klausel der `FileOpen` -Funktion, `FilePut` nachfolgende Datensätze auf Datensatzlänge schreibt. Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt. Da die Menge der Leerstellen Daten nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen empfiehlt sich, die Datensatzlänge der Länge der zu schreibenden Daten überein. Ist die Länge des zu schreibenden Daten größer als die Länge, angegeben der `RecordLength` -Klausel der `FileOpen` -Funktion eine Ausnahme ausgelöst.  
  
-   Eine Zeichenfolge ist, die Zielvariable `FilePut` schreibt einen 2-Byte-Deskriptor, der die Länge der Zeichenfolge enthält, und schreibt dann die Daten, die in die Variable aufgenommen wird. Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge sein.  
  
-   Wenn die Zielvariable ein Objekt ist, die einen numerischen Typ enthält `FilePut` zwei Bytes, identifizieren den `VarType` des Objekts und schreibt dann die Variable. Enthält z. B. wenn ein Objekt zu schreiben, die eine ganze Zahl `FilePut` schreibt sechs Bytes: 2 Bytes, die Identifizierung des Objekts als `VarType(3)` (`Integer`) und vier Bytes, die Daten enthalten. Die angegebene Datensatzlänge der `RecordLength` Parameter in der `FileOpen` Funktion muss mindestens zwei Bytes größer als die tatsächliche Anzahl von Bytes, die zum Speichern von Variablen erforderlich sein.  
  
-   Ist die Zielvariable ein Objekt, das eine Zeichenfolge enthält `FilePut` schreibt eine 2-Byte-Deskriptor, identifiziert die `VarType(8)` des Objekts, ein 2-Byte-Deskriptor, der angibt, der Länge der Zeichenfolge und anschließend die Zeichenfolgendaten. Die angegebene Datensatzlänge der `RecordLength` Parameter in der `FileOpen` Funktion muss mindestens vier Bytes größer als die tatsächliche Länge der Zeichenfolge sein. Wenn Sie eine Zeichenfolge ohne Deskriptor ablegen möchten, sollten Sie übergeben `True` auf die `StringIsFixedLength` Parameter, und die Zeichenfolge, die Sie einlesen, sollte die richtige Länge.  
  
-   Wenn die Zielvariable ein Array ist, müssen Sie eine Auswahl, ob einen Deskriptor für die Größe und die Dimensionen des Arrays zu schreiben. Visual Basic 6.0 und früheren Versionen Dateideskriptor für dynamische Arrays und nicht für Arrays mit fester Größe zu schreiben. Visual Basic 2005 standardmäßig kein Deskriptor geschrieben. Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`. Wenn das Array zu schreiben, müssen Sie entsprechend der Weise wird das Array gelesen werden; Wenn mit dem Deskriptor gelesen werden, müssen Sie den Deskriptor schreiben. Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang. Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl von Dimensionen: (2 + 8 * NumberOfDimensions). Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Arraydeskriptor zu schreiben. Die folgende Arraydeklaration erfordert z. B. 218 Bytes, wenn das Array geschrieben wird auf den Datenträger.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Wenn die Zielvariable einen anderen Typ der Variable (keine Zeichenfolge variabler Länge oder ein Objekt), ist `FilePut` schreibt nur die Daten der Variablen. Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge der zu schreibenden Daten.  
  
-   `FilePut` Schreibt die Elemente von Strukturen, als ob jeder einzeln geschrieben wurden jedoch keine Auffüllung zwischen Elementen. Die `VBFixedString` Attribut angewendet werden kann, zu Zeichenfolgenfeldern in den Strukturen an, dass die Größe der Zeichenfolge beim Schreiben auf den Datenträger.  
  
    > [!NOTE]
    >  String-Felder, die mehr als Bytes angegeben die `VBFixedString` Attribut werden abgeschnitten, beim Schreiben auf den Datenträger  
  
## <a name="binary-mode"></a>Binärmodus  
 Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` -Modus-Regeln gelten, bis auf einige Ausnahmen. Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:  
  
-   Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen. `FilePut` Schreibt alle Variablen zusammenhängend, d. h. ohne Leerraum zwischen Datensätzen Datenträger an.  
  
-   Für ein beliebiges Array als ein Array in einer Struktur `FilePut` schreibt nur die Daten. Es wird kein Deskriptor geschrieben.  
  
-   `FilePut` schreibt Zeichenfolgen variabler Länge, die keine Elemente von Strukturen ohne Längendeskriptor 2-Byte-sind. Die Anzahl der geschriebenen Bytes entspricht die Anzahl der Zeichen in der Zeichenfolge. Die folgenden Anweisungen wird z. B. 11 Bytes Datei Zahl 1 schreiben:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Schreiben in eine Datei mithilfe der `FilePut` -Funktion erfordert `Write` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `FilePut` Funktion, um Daten in eine Datei schreiben. Fünf Datensätze der Struktur `Person` in die Datei geschrieben werden.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, double Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, float64 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Double, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * double * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name that contains data written to disk.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</param>
        <summary>Writes data from a variable to a disk file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` gilt nur in `Random` und `Binary` Modus.  
  
 Mit `FilePut` geschriebene Daten werden in der Regel mit `FileGet` aus einer Datei gelesen.  
  
 Der erste Datensatz oder Byte in einer Datei befindet sich an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 usw. ist. Wenn Sie weglassen `RecordNumber`, den nächsten Datensatz bzw. Byte nach dem letzten `FileGet` oder `FilePut` Funktion oder verweist, zu dem letzten `Seek` Funktion geschrieben wird.  
  
 Die `StringIsFixedLength` -Argument steuert, ob die Funktion Zeichenfolgen als Variable oder feste Länge interpretiert. `FilePut` den Längendeskriptor wird nicht geschrieben werden, wenn das Argument ist `True`. Bei Verwendung von `StringIsFixedLength`  =  `True` mit `FilePut`, was identisch mit `FileGet`, und Sie müssen sicherstellen, dass die Zeichenfolge mit der erwarteten Länge initialisiert wird.  
  
## <a name="random-mode"></a>Zufällige Modus  
 Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:  
  
-   Wenn die Länge des zu schreibenden Daten kleiner als die Länge ist, angegeben der `RecordLength` -Klausel der `FileOpen` -Funktion, `FilePut` nachfolgende Datensätze auf Datensatzlänge schreibt. Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt. Da die Menge der Leerstellen Daten nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen empfiehlt sich, die Datensatzlänge der Länge der zu schreibenden Daten überein. Ist die Länge des zu schreibenden Daten größer als die Länge, angegeben der `RecordLength` -Klausel der `FileOpen` -Funktion eine Ausnahme ausgelöst.  
  
-   Eine Zeichenfolge ist, die Zielvariable `FilePut` schreibt einen 2-Byte-Deskriptor, der die Länge der Zeichenfolge enthält, und schreibt dann die Daten, die in die Variable aufgenommen wird. Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge sein.  
  
-   Wenn die Zielvariable ein Objekt ist, die einen numerischen Typ enthält `FilePut` zwei Bytes, identifizieren den `VarType` des Objekts und schreibt dann die Variable. Enthält z. B. wenn ein Objekt zu schreiben, die eine ganze Zahl `FilePut` schreibt sechs Bytes: 2 Bytes, die Identifizierung des Objekts als `VarType(3)` (`Integer`) und vier Bytes, die Daten enthalten. Die angegebene Datensatzlänge der `RecordLength` Parameter in der `FileOpen` Funktion muss mindestens zwei Bytes größer als die tatsächliche Anzahl von Bytes, die zum Speichern von Variablen erforderlich sein.  
  
-   Ist die Zielvariable ein Objekt, das eine Zeichenfolge enthält `FilePut` schreibt eine 2-Byte-Deskriptor, identifiziert die `VarType(8)` des Objekts, ein 2-Byte-Deskriptor, der angibt, der Länge der Zeichenfolge und anschließend die Zeichenfolgendaten. Die angegebene Datensatzlänge der `RecordLength` Parameter in der `FileOpen` Funktion muss mindestens vier Bytes größer als die tatsächliche Länge der Zeichenfolge sein. Wenn Sie eine Zeichenfolge ohne Deskriptor ablegen möchten, sollten Sie übergeben `True` auf die `StringIsFixedLength` Parameter, und die Zeichenfolge, die Sie einlesen, sollte die richtige Länge.  
  
-   Wenn die Zielvariable ein Array ist, müssen Sie eine Auswahl, ob einen Deskriptor für die Größe und die Dimensionen des Arrays zu schreiben. Visual Basic 6.0 und früheren Versionen Dateideskriptor für dynamische Arrays und nicht für Arrays mit fester Größe zu schreiben. Visual Basic 2005 standardmäßig kein Deskriptor geschrieben. Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`. Wenn das Array zu schreiben, müssen Sie entsprechend der Weise wird das Array gelesen werden; Wenn mit dem Deskriptor gelesen werden, müssen Sie den Deskriptor schreiben. Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang. Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl von Dimensionen: (2 + 8 * NumberOfDimensions). Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Arraydeskriptor zu schreiben. Die folgende Arraydeklaration erfordert z. B. 218 Bytes, wenn das Array geschrieben wird auf den Datenträger.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Wenn die Zielvariable einen anderen Typ der Variable (keine Zeichenfolge variabler Länge oder ein Objekt), ist `FilePut` schreibt nur die Daten der Variablen. Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge der zu schreibenden Daten.  
  
-   `FilePut` Schreibt die Elemente von Strukturen, als ob jeder einzeln geschrieben wurden jedoch keine Auffüllung zwischen Elementen. Die `VBFixedString` Attribut angewendet werden kann, zu Zeichenfolgenfeldern in den Strukturen an, dass die Größe der Zeichenfolge beim Schreiben auf den Datenträger.  
  
    > [!NOTE]
    >  String-Felder, die mehr als Bytes angegeben die `VBFixedString` Attribut werden abgeschnitten, beim Schreiben auf den Datenträger  
  
## <a name="binary-mode"></a>Binärmodus  
 Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` -Modus-Regeln gelten, bis auf einige Ausnahmen. Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:  
  
-   Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen. `FilePut` Schreibt alle Variablen zusammenhängend, d. h. ohne Leerraum zwischen Datensätzen Datenträger an.  
  
-   Für ein beliebiges Array als ein Array in einer Struktur `FilePut` schreibt nur die Daten. Es wird kein Deskriptor geschrieben.  
  
-   `FilePut` schreibt Zeichenfolgen variabler Länge, die keine Elemente von Strukturen ohne Längendeskriptor 2-Byte-sind. Die Anzahl der geschriebenen Bytes entspricht die Anzahl der Zeichen in der Zeichenfolge. Die folgenden Anweisungen wird z. B. 11 Bytes Datei Zahl 1 schreiben:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Schreiben in eine Datei mithilfe der `FilePut` -Funktion erfordert `Write` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `FilePut` Funktion, um Daten in eine Datei schreiben. Fünf Datensätze der Struktur `Person` in die Datei geschrieben werden.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, short Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int16 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Short, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * int16 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name that contains data written to disk.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</param>
        <summary>Writes data from a variable to a disk file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` gilt nur in `Random` und `Binary` Modus.  
  
 Mit `FilePut` geschriebene Daten werden in der Regel mit `FileGet` aus einer Datei gelesen.  
  
 Der erste Datensatz oder Byte in einer Datei befindet sich an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 usw. ist. Wenn Sie weglassen `RecordNumber`, den nächsten Datensatz bzw. Byte nach dem letzten `FileGet` oder `FilePut` Funktion oder verweist, zu dem letzten `Seek` Funktion geschrieben wird.  
  
 Die `StringIsFixedLength` -Argument steuert, ob die Funktion Zeichenfolgen als Variable oder feste Länge interpretiert. `FilePut` den Längendeskriptor wird nicht geschrieben werden, wenn das Argument ist `True`. Bei Verwendung von `StringIsFixedLength`  =  `True` mit `FilePut`, was identisch mit `FileGet`, und Sie müssen sicherstellen, dass die Zeichenfolge mit der erwarteten Länge initialisiert wird.  
  
## <a name="random-mode"></a>Zufällige Modus  
 Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:  
  
-   Wenn die Länge des zu schreibenden Daten kleiner als die Länge ist, angegeben der `RecordLength` -Klausel der `FileOpen` -Funktion, `FilePut` nachfolgende Datensätze auf Datensatzlänge schreibt. Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt. Da die Menge der Leerstellen Daten nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen empfiehlt sich, die Datensatzlänge der Länge der zu schreibenden Daten überein. Ist die Länge des zu schreibenden Daten größer als die Länge, angegeben der `RecordLength` -Klausel der `FileOpen` -Funktion eine Ausnahme ausgelöst.  
  
-   Eine Zeichenfolge ist, die Zielvariable `FilePut` schreibt einen 2-Byte-Deskriptor, der die Länge der Zeichenfolge enthält, und schreibt dann die Daten, die in die Variable aufgenommen wird. Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge sein.  
  
-   Wenn die Zielvariable ein Objekt ist, die einen numerischen Typ enthält `FilePut` zwei Bytes, identifizieren den `VarType` des Objekts und schreibt dann die Variable. Enthält z. B. wenn ein Objekt zu schreiben, die eine ganze Zahl `FilePut` schreibt sechs Bytes: 2 Bytes, die Identifizierung des Objekts als `VarType(3)` (`Integer`) und vier Bytes, die Daten enthalten. Die angegebene Datensatzlänge der `RecordLength` Parameter in der `FileOpen` Funktion muss mindestens zwei Bytes größer als die tatsächliche Anzahl von Bytes, die zum Speichern von Variablen erforderlich sein.  
  
-   Ist die Zielvariable ein Objekt, das eine Zeichenfolge enthält `FilePut` schreibt eine 2-Byte-Deskriptor, identifiziert die`VarType(8)` des Objekts, ein 2-Byte-Deskriptor, der angibt, der Länge der Zeichenfolge und anschließend die Zeichenfolgendaten. Die angegebene Datensatzlänge der `RecordLength` Parameter in der `FileOpen` Funktion muss mindestens vier Bytes größer als die tatsächliche Länge der Zeichenfolge sein. Wenn Sie eine Zeichenfolge ohne Deskriptor ablegen möchten, sollten Sie übergeben `True` auf die `StringIsFixedLength` Parameter, und die Zeichenfolge, die Sie einlesen, sollte die richtige Länge.  
  
-   Wenn die Zielvariable ein Array ist, müssen Sie eine Auswahl, ob einen Deskriptor für die Größe und die Dimensionen des Arrays zu schreiben. Visual Basic 6.0 und früheren Versionen Dateideskriptor für dynamische Arrays und nicht für Arrays mit fester Größe zu schreiben. Visual Basic 2005 standardmäßig kein Deskriptor geschrieben. Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`. Wenn das Array zu schreiben, müssen Sie entsprechend der Weise wird das Array gelesen werden; Wenn mit dem Deskriptor gelesen werden, müssen Sie den Deskriptor schreiben. Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang. Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl von Dimensionen: (2 + 8 * NumberOfDimensions). Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Arraydeskriptor zu schreiben. Die folgende Arraydeklaration erfordert z. B. 218 Bytes, wenn das Array geschrieben wird auf den Datenträger.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Wenn die Zielvariable einen anderen Typ der Variable (keine Zeichenfolge variabler Länge oder ein Objekt), ist `FilePut` schreibt nur die Daten der Variablen. Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge der zu schreibenden Daten.  
  
-   `FilePut` Schreibt die Elemente von Strukturen, als ob jeder einzeln geschrieben wurden jedoch keine Auffüllung zwischen Elementen. Die `VBFixedString` Attribut angewendet werden kann, zu Zeichenfolgenfeldern in den Strukturen an, dass die Größe der Zeichenfolge beim Schreiben auf den Datenträger.  
  
    > [!NOTE]
    >  String-Felder, die mehr als Bytes angegeben die `VBFixedString` Attribut werden abgeschnitten, beim Schreiben auf den Datenträger  
  
## <a name="binary-mode"></a>Binärmodus  
 Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` -Modus-Regeln gelten, bis auf einige Ausnahmen. Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:  
  
-   Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen. `FilePut` Schreibt alle Variablen zusammenhängend, d. h. ohne Leerraum zwischen Datensätzen Datenträger an.  
  
-   Für ein beliebiges Array als ein Array in einer Struktur `FilePut` schreibt nur die Daten. Es wird kein Deskriptor geschrieben.  
  
-   `FilePut` schreibt Zeichenfolgen variabler Länge, die keine Elemente von Strukturen ohne Längendeskriptor 2-Byte-sind. Die Anzahl der geschriebenen Bytes entspricht die Anzahl der Zeichen in der Zeichenfolge. Die folgenden Anweisungen wird z. B. 11 Bytes Datei Zahl 1 schreiben:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Schreiben in eine Datei mithilfe der `FilePut` -Funktion erfordert `Write` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `FilePut` Funktion, um Daten in eine Datei schreiben. Fünf Datensätze der Struktur `Person` in die Datei geschrieben werden.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, int Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int32 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Integer, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name that contains data written to disk.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</param>
        <summary>Writes data from a variable to a disk file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` gilt nur in `Random` und `Binary` Modus.  
  
 Mit `FilePut` geschriebene Daten werden in der Regel mit `FileGet` aus einer Datei gelesen.  
  
 Der erste Datensatz oder Byte in einer Datei befindet sich an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 usw. ist. Wenn Sie weglassen `RecordNumber`, den nächsten Datensatz bzw. Byte nach dem letzten `FileGet` oder `FilePut` Funktion oder verweist, zu dem letzten `Seek` Funktion geschrieben wird.  
  
 Die `StringIsFixedLength` -Argument steuert, ob die Funktion Zeichenfolgen als Variable oder feste Länge interpretiert. `FilePut` den Längendeskriptor wird nicht geschrieben werden, wenn das Argument ist `True`. Bei Verwendung von `StringIsFixedLength`  =  `True` mit `FilePut`, was identisch mit `FileGet`, und Sie müssen sicherstellen, dass die Zeichenfolge mit der erwarteten Länge initialisiert wird.  
  
## <a name="random-mode"></a>Zufällige Modus  
 Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:  
  
-   Wenn die Länge des zu schreibenden Daten kleiner als die Länge ist, angegeben der `RecordLength` -Klausel der `FileOpen` -Funktion, `FilePut` nachfolgende Datensätze auf Datensatzlänge schreibt. Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt. Da die Menge der Leerstellen Daten nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen empfiehlt sich, die Datensatzlänge der Länge der zu schreibenden Daten überein. Ist die Länge des zu schreibenden Daten größer als die Länge, angegeben der `RecordLength` -Klausel der `FileOpen` -Funktion eine Ausnahme ausgelöst.  
  
-   Eine Zeichenfolge ist, die Zielvariable `FilePut` schreibt einen 2-Byte-Deskriptor, der die Länge der Zeichenfolge enthält, und schreibt dann die Daten, die in die Variable aufgenommen wird. Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge sein.  
  
-   Wenn die Zielvariable ein Objekt ist, die einen numerischen Typ enthält `FilePut` zwei Bytes, identifizieren den `VarType` des Objekts und schreibt dann die Variable. Enthält z. B. wenn ein Objekt zu schreiben, die eine ganze Zahl `FilePut` schreibt sechs Bytes: 2 Bytes, die Identifizierung des Objekts als `VarType(3)` (`Integer`) und vier Bytes, die Daten enthalten. Die angegebene Datensatzlänge der `RecordLength` Parameter in der `FileOpen` Funktion muss mindestens zwei Bytes größer als die tatsächliche Anzahl von Bytes, die zum Speichern von Variablen erforderlich sein.  
  
-   Ist die Zielvariable ein Objekt, das eine Zeichenfolge enthält `FilePut` schreibt eine 2-Byte-Deskriptor, identifiziert die `VarType(8)` des Objekts, ein 2-Byte-Deskriptor, der angibt, der Länge der Zeichenfolge und anschließend die Zeichenfolgendaten. Die angegebene Datensatzlänge der `RecordLength` Parameter in der `FileOpen` Funktion muss mindestens vier Bytes größer als die tatsächliche Länge der Zeichenfolge sein. Wenn Sie eine Zeichenfolge ohne Deskriptor ablegen möchten, sollten Sie übergeben `True` auf die `StringIsFixedLength` Parameter, und die Zeichenfolge, die Sie einlesen, sollte die richtige Länge.  
  
-   Wenn die Zielvariable ein Array ist, müssen Sie eine Auswahl, ob einen Deskriptor für die Größe und die Dimensionen des Arrays zu schreiben. Visual Basic 6.0 und früheren Versionen Dateideskriptor für dynamische Arrays und nicht für Arrays mit fester Größe zu schreiben. Visual Basic 2005 standardmäßig kein Deskriptor geschrieben. Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`. Wenn das Array zu schreiben, müssen Sie entsprechend der Weise wird das Array gelesen werden; Wenn mit dem Deskriptor gelesen werden, müssen Sie den Deskriptor schreiben. Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang. Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl von Dimensionen: (2 + 8 * NumberOfDimensions). Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Arraydeskriptor zu schreiben. Die folgende Arraydeklaration erfordert z. B. 218 Bytes, wenn das Array geschrieben wird auf den Datenträger.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Wenn die Zielvariable einen anderen Typ der Variable (keine Zeichenfolge variabler Länge oder ein Objekt), ist `FilePut` schreibt nur die Daten der Variablen. Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge der zu schreibenden Daten.  
  
-   `FilePut` Schreibt die Elemente von Strukturen, als ob jeder einzeln geschrieben wurden jedoch keine Auffüllung zwischen Elementen. Die `VBFixedString` Attribut angewendet werden kann, zu Zeichenfolgenfeldern in den Strukturen an, dass die Größe der Zeichenfolge beim Schreiben auf den Datenträger.  
  
    > [!NOTE]
    >  String-Felder, die mehr als Bytes angegeben die `VBFixedString` Attribut werden abgeschnitten, beim Schreiben auf den Datenträger  
  
## <a name="binary-mode"></a>Binärmodus  
 Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` -Modus-Regeln gelten, bis auf einige Ausnahmen. Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:  
  
-   Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen. `FilePut` Schreibt alle Variablen zusammenhängend, d. h. ohne Leerraum zwischen Datensätzen Datenträger an.  
  
-   Für ein beliebiges Array als ein Array in einer Struktur `FilePut` schreibt nur die Daten. Es wird kein Deskriptor geschrieben.  
  
-   `FilePut` schreibt Zeichenfolgen variabler Länge, die keine Elemente von Strukturen ohne Längendeskriptor 2-Byte-sind. Die Anzahl der geschriebenen Bytes entspricht die Anzahl der Zeichen in der Zeichenfolge. Die folgenden Anweisungen wird z. B. 11 Bytes Datei Zahl 1 schreiben:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Schreiben in eine Datei mithilfe der `FilePut` -Funktion erfordert `Write` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `FilePut` Funktion, um Daten in eine Datei schreiben. Fünf Datensätze der Struktur `Person` in die Datei geschrieben werden.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, long Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int64 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Long, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * int64 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name that contains data written to disk.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</param>
        <summary>Writes data from a variable to a disk file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` gilt nur in `Random` und `Binary` Modus.  
  
 Mit `FilePut` geschriebene Daten werden in der Regel mit `FileGet` aus einer Datei gelesen.  
  
 Der erste Datensatz oder Byte in einer Datei befindet sich an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 usw. ist. Wenn Sie weglassen `RecordNumber`, den nächsten Datensatz bzw. Byte nach dem letzten `FileGet` oder `FilePut` Funktion oder verweist, zu dem letzten `Seek` Funktion geschrieben wird.  
  
 Die `StringIsFixedLength` -Argument steuert, ob die Funktion Zeichenfolgen als Variable oder feste Länge interpretiert. `FilePut` den Längendeskriptor wird nicht geschrieben werden, wenn das Argument ist `True`. Bei Verwendung von `StringIsFixedLength`  =  `True` mit `FilePut`, was identisch mit `FileGet`, und Sie müssen sicherstellen, dass die Zeichenfolge mit der erwarteten Länge initialisiert wird.  
  
## <a name="random-mode"></a>Zufällige Modus  
 Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:  
  
-   Wenn die Länge des zu schreibenden Daten kleiner als die Länge ist, angegeben der `RecordLength` -Klausel der `FileOpen` -Funktion, `FilePut` nachfolgende Datensätze auf Datensatzlänge schreibt. Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt. Da die Menge der Leerstellen Daten nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen empfiehlt sich, die Datensatzlänge der Länge der zu schreibenden Daten überein. Ist die Länge des zu schreibenden Daten größer als die Länge, angegeben der `RecordLength` -Klausel der `FileOpen` -Funktion eine Ausnahme ausgelöst.  
  
-   Eine Zeichenfolge ist, die Zielvariable `FilePut` schreibt einen 2-Byte-Deskriptor, der die Länge der Zeichenfolge enthält, und schreibt dann die Daten, die in die Variable aufgenommen wird. Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge sein.  
  
-   Wenn die Zielvariable ein Objekt ist, die einen numerischen Typ enthält `FilePut` zwei Bytes, identifizieren den `VarType` des Objekts und schreibt dann die Variable. Enthält z. B. wenn ein Objekt zu schreiben, die eine ganze Zahl `FilePut` schreibt sechs Bytes: 2 Bytes, die Identifizierung des Objekts als `VarType(3)` (`Integer`) und vier Bytes, die Daten enthalten. Die angegebene Datensatzlänge der `RecordLength` Parameter in der `FileOpen` Funktion muss mindestens zwei Bytes größer als die tatsächliche Anzahl von Bytes, die zum Speichern von Variablen erforderlich sein.  
  
-   Ist die Zielvariable ein Objekt, das eine Zeichenfolge enthält `FilePut` schreibt eine 2-Byte-Deskriptor, identifiziert die `VarType(8)` des Objekts, ein 2-Byte-Deskriptor, der angibt, der Länge der Zeichenfolge und anschließend die Zeichenfolgendaten. Die angegebene Datensatzlänge der `RecordLength` Parameter in der `FileOpen` Funktion muss mindestens vier Bytes größer als die tatsächliche Länge der Zeichenfolge sein. Wenn Sie eine Zeichenfolge ohne Deskriptor ablegen möchten, sollten Sie übergeben `True` auf die `StringIsFixedLength` Parameter, und die Zeichenfolge, die Sie einlesen, sollte die richtige Länge.  
  
-   Wenn die Zielvariable ein Array ist, müssen Sie eine Auswahl, ob einen Deskriptor für die Größe und die Dimensionen des Arrays zu schreiben. Visual Basic 6.0 und früheren Versionen Dateideskriptor für dynamische Arrays und nicht für Arrays mit fester Größe zu schreiben. Visual Basic 2005 standardmäßig kein Deskriptor geschrieben. Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`. Wenn das Array zu schreiben, müssen Sie entsprechend der Weise wird das Array gelesen werden; Wenn mit dem Deskriptor gelesen werden, müssen Sie den Deskriptor schreiben. Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang. Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl von Dimensionen: (2 + 8 * NumberOfDimensions). Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Arraydeskriptor zu schreiben. Die folgende Arraydeklaration erfordert z. B. 218 Bytes, wenn das Array geschrieben wird auf den Datenträger.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Wenn die Zielvariable einen anderen Typ der Variable (keine Zeichenfolge variabler Länge oder ein Objekt), ist `FilePut` schreibt nur die Daten der Variablen. Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge der zu schreibenden Daten.  
  
-   `FilePut` Schreibt die Elemente von Strukturen, als ob jeder einzeln geschrieben wurden jedoch keine Auffüllung zwischen Elementen. Die `VBFixedString` Attribut angewendet werden kann, zu Zeichenfolgenfeldern in den Strukturen an, dass die Größe der Zeichenfolge beim Schreiben auf den Datenträger.  
  
    > [!NOTE]
    >  String-Felder, die mehr als Bytes angegeben die `VBFixedString` Attribut werden abgeschnitten, beim Schreiben auf den Datenträger  
  
## <a name="binary-mode"></a>Binärmodus  
 Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` -Modus-Regeln gelten, bis auf einige Ausnahmen. Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:  
  
-   Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen. `FilePut` Schreibt alle Variablen zusammenhängend, d. h. ohne Leerraum zwischen Datensätzen Datenträger an.  
  
-   Für ein beliebiges Array als ein Array in einer Struktur `FilePut` schreibt nur die Daten. Es wird kein Deskriptor geschrieben.  
  
-   `FilePut` schreibt Zeichenfolgen variabler Länge, die keine Elemente von Strukturen ohne Längendeskriptor 2-Byte-sind. Die Anzahl der geschriebenen Bytes entspricht die Anzahl der Zeichen in der Zeichenfolge. Die folgenden Anweisungen wird z. B. 11 Bytes Datei Zahl 1 schreiben:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Schreiben in eine Datei mithilfe der `FilePut` -Funktion erfordert `Write` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `FilePut` Funktion, um Daten in eine Datei schreiben. Fünf Datensätze der Struktur `Person` in die Datei geschrieben werden.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, float Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, float32 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Single, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * single * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name that contains data written to disk.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</param>
        <summary>Writes data from a variable to a disk file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` gilt nur in `Random` und `Binary` Modus.  
  
 Mit `FilePut` geschriebene Daten werden in der Regel mit `FileGet` aus einer Datei gelesen.  
  
 Der erste Datensatz oder Byte in einer Datei befindet sich an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 usw. ist. Wenn Sie weglassen `RecordNumber`, den nächsten Datensatz bzw. Byte nach dem letzten `FileGet` oder `FilePut` Funktion oder verweist, zu dem letzten `Seek` Funktion geschrieben wird.  
  
 Die `StringIsFixedLength` -Argument steuert, ob die Funktion Zeichenfolgen als Variable oder feste Länge interpretiert. `FilePut` den Längendeskriptor wird nicht geschrieben werden, wenn das Argument ist `True`. Bei Verwendung von `StringIsFixedLength`  =  `True` mit `FilePut`, was identisch mit `FileGet`, und Sie müssen sicherstellen, dass die Zeichenfolge mit der erwarteten Länge initialisiert wird.  
  
## <a name="random-mode"></a>Zufällige Modus  
 Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:  
  
-   Wenn die Länge des zu schreibenden Daten kleiner als die Länge ist, angegeben der `RecordLength` -Klausel der `FileOpen` -Funktion, `FilePut` nachfolgende Datensätze auf Datensatzlänge schreibt. Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt. Da die Menge der Leerstellen Daten nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen empfiehlt sich, die Datensatzlänge der Länge der zu schreibenden Daten überein. Ist die Länge des zu schreibenden Daten größer als die Länge, angegeben der `RecordLength` -Klausel der `FileOpen` -Funktion eine Ausnahme ausgelöst.  
  
-   Eine Zeichenfolge ist, die Zielvariable `FilePut` schreibt einen 2-Byte-Deskriptor, der die Länge der Zeichenfolge enthält, und schreibt dann die Daten, die in die Variable aufgenommen wird. Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge sein.  
  
-   Wenn die Zielvariable ein Objekt ist, die einen numerischen Typ enthält `FilePut` zwei Bytes, identifizieren den `VarType` des Objekts und schreibt dann die Variable. Enthält z. B. wenn ein Objekt zu schreiben, die eine ganze Zahl `FilePut` schreibt sechs Bytes: 2 Bytes, die Identifizierung des Objekts als `VarType(3)` (`Integer`) und vier Bytes, die Daten enthalten. Die angegebene Datensatzlänge der `RecordLength` Parameter in der `FileOpen` Funktion muss mindestens zwei Bytes größer als die tatsächliche Anzahl von Bytes, die zum Speichern von Variablen erforderlich sein.  
  
-   Ist die Zielvariable ein Objekt, das eine Zeichenfolge enthält `FilePut` schreibt eine 2-Byte-Deskriptor, identifiziert die `VarType(8)` des Objekts, ein 2-Byte-Deskriptor, der angibt, der Länge der Zeichenfolge und anschließend die Zeichenfolgendaten. Die angegebene Datensatzlänge der `RecordLength` Parameter in der `FileOpen` Funktion muss mindestens vier Bytes größer als die tatsächliche Länge der Zeichenfolge sein. Wenn Sie eine Zeichenfolge ohne Deskriptor ablegen möchten, sollten Sie übergeben `True` auf die `StringIsFixedLength` Parameter, und die Zeichenfolge, die Sie einlesen, sollte die richtige Länge.  
  
-   Wenn die Zielvariable ein Array ist, müssen Sie eine Auswahl, ob einen Deskriptor für die Größe und die Dimensionen des Arrays zu schreiben. Visual Basic 6.0 und früheren Versionen Dateideskriptor für dynamische Arrays und nicht für Arrays mit fester Größe zu schreiben. Visual Basic 2005 standardmäßig kein Deskriptor geschrieben. Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`. Wenn das Array zu schreiben, müssen Sie entsprechend der Weise wird das Array gelesen werden; Wenn mit dem Deskriptor gelesen werden, müssen Sie den Deskriptor schreiben. Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang. Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl von Dimensionen: (2 + 8 * NumberOfDimensions). Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Arraydeskriptor zu schreiben. Die folgende Arraydeklaration erfordert z. B. 218 Bytes, wenn das Array geschrieben wird auf den Datenträger.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Wenn die Zielvariable einen anderen Typ der Variable (keine Zeichenfolge variabler Länge oder ein Objekt), ist `FilePut` schreibt nur die Daten der Variablen. Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge der zu schreibenden Daten.  
  
-   `FilePut` Schreibt die Elemente von Strukturen, als ob jeder einzeln geschrieben wurden jedoch keine Auffüllung zwischen Elementen. Die `VBFixedString` Attribut angewendet werden kann, zu Zeichenfolgenfeldern in den Strukturen an, dass die Größe der Zeichenfolge beim Schreiben auf den Datenträger.  
  
    > [!NOTE]
    >  String-Felder, die mehr als Bytes angegeben die `VBFixedString` Attribut werden abgeschnitten, beim Schreiben auf den Datenträger  
  
## <a name="binary-mode"></a>Binärmodus  
 Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` -Modus-Regeln gelten, bis auf einige Ausnahmen. Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:  
  
-   Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen. `FilePut` Schreibt alle Variablen zusammenhängend, d. h. ohne Leerraum zwischen Datensätzen Datenträger an.  
  
-   Für ein beliebiges Array als ein Array in einer Struktur `FilePut` schreibt nur die Daten. Es wird kein Deskriptor geschrieben.  
  
-   `FilePut` schreibt Zeichenfolgen variabler Länge, die keine Elemente von Strukturen ohne Längendeskriptor 2-Byte-sind. Die Anzahl der geschriebenen Bytes entspricht die Anzahl der Zeichen in der Zeichenfolge. Die folgenden Anweisungen wird z. B. 11 Bytes Datei Zahl 1 schreiben:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Schreiben in eine Datei mithilfe der `FilePut` -Funktion erfordert `Write` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `FilePut` Funktion, um Daten in eine Datei schreiben. Fünf Datensätze der Struktur `Person` in die Datei geschrieben werden.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, ValueType Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, class System.ValueType Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As ValueType, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * ValueType * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.ValueType" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name that contains data written to disk.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</param>
        <summary>Writes data from a variable to a disk file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` gilt nur in `Random` und `Binary` Modus.  
  
 Mit `FilePut` geschriebene Daten werden in der Regel mit `FileGet` aus einer Datei gelesen.  
  
 Der erste Datensatz oder Byte in einer Datei befindet sich an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 usw. ist. Wenn Sie weglassen `RecordNumber`, den nächsten Datensatz bzw. Byte nach dem letzten `FileGet` oder `FilePut` Funktion oder verweist, zu dem letzten `Seek` Funktion geschrieben wird.  
  
 Die `StringIsFixedLength` -Argument steuert, ob die Funktion Zeichenfolgen als Variable oder feste Länge interpretiert. `FilePut` den Längendeskriptor wird nicht geschrieben werden, wenn das Argument ist `True`. Bei Verwendung von `StringIsFixedLength`  =  `True` mit `FilePut`, was identisch mit `FileGet`, und Sie müssen sicherstellen, dass die Zeichenfolge mit der erwarteten Länge initialisiert wird.  
  
## <a name="random-mode"></a>Zufällige Modus  
 Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:  
  
-   Wenn die Länge des zu schreibenden Daten kleiner als die Länge ist, angegeben der`RecordLength` -Klausel der `FileOpen` -Funktion, `FilePut` nachfolgende Datensätze auf Datensatzlänge schreibt. Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt. Da die Menge der Leerstellen Daten nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen empfiehlt sich, die Datensatzlänge der Länge der zu schreibenden Daten überein. Ist die Länge des zu schreibenden Daten größer als die Länge, angegeben der `RecordLength` -Klausel der `FileOpen` -Funktion eine Ausnahme ausgelöst.  
  
-   Eine Zeichenfolge ist, die Zielvariable `FilePut` schreibt einen 2-Byte-Deskriptor, der die Länge der Zeichenfolge enthält, und schreibt dann die Daten, die in die Variable aufgenommen wird. Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge sein.  
  
-   Wenn die Zielvariable ein Objekt ist, die einen numerischen Typ enthält `FilePut` zwei Bytes, identifizieren den `VarType` des Objekts und schreibt dann die Variable. Enthält z. B. wenn ein Objekt zu schreiben, die eine ganze Zahl `FilePut` schreibt sechs Bytes: 2 Bytes, die Identifizierung des Objekts als `VarType(3)` (`Integer`) und vier Bytes, die Daten enthalten. Die angegebene Datensatzlänge der `RecordLength` Parameter in der `FileOpen` Funktion muss mindestens zwei Bytes größer als die tatsächliche Anzahl von Bytes, die zum Speichern von Variablen erforderlich sein.  
  
-   Ist die Zielvariable ein Objekt, das eine Zeichenfolge enthält `FilePut` schreibt eine 2-Byte-Deskriptor, identifiziert die `VarType(8)` des Objekts, ein 2-Byte-Deskriptor, der angibt, der Länge der Zeichenfolge und anschließend die Zeichenfolgendaten. Die angegebene Datensatzlänge der `RecordLength` Parameter in der `FileOpen` Funktion muss mindestens vier Bytes größer als die tatsächliche Länge der Zeichenfolge sein. Wenn Sie eine Zeichenfolge ohne Deskriptor ablegen möchten, sollten Sie übergeben `True` auf die `StringIsFixedLength` Parameter, und die Zeichenfolge, die Sie einlesen, sollte die richtige Länge.  
  
-   Wenn die Zielvariable ein Array ist, müssen Sie eine Auswahl, ob einen Deskriptor für die Größe und die Dimensionen des Arrays zu schreiben. Visual Basic 6.0 und früheren Versionen Dateideskriptor für dynamische Arrays und nicht für Arrays mit fester Größe zu schreiben. Visual Basic 2005 standardmäßig kein Deskriptor geschrieben. Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`. Wenn das Array zu schreiben, müssen Sie entsprechend der Weise wird das Array gelesen werden; Wenn mit dem Deskriptor gelesen werden, müssen Sie den Deskriptor schreiben. Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang. Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl von Dimensionen: (2 + 8 * NumberOfDimensions). Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Arraydeskriptor zu schreiben. Die folgende Arraydeklaration erfordert z. B. 218 Bytes, wenn das Array geschrieben wird auf den Datenträger.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Wenn die Zielvariable einen anderen Typ der Variable (keine Zeichenfolge variabler Länge oder ein Objekt), ist `FilePut` schreibt nur die Daten der Variablen. Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge der zu schreibenden Daten.  
  
-   `FilePut` Schreibt die Elemente von Strukturen, als ob jeder einzeln geschrieben wurden jedoch keine Auffüllung zwischen Elementen. Die `VBFixedString` Attribut angewendet werden kann, zu Zeichenfolgenfeldern in den Strukturen an, dass die Größe der Zeichenfolge beim Schreiben auf den Datenträger.  
  
    > [!NOTE]
    >  String-Felder, die mehr als Bytes angegeben die `VBFixedString` Attribut werden abgeschnitten, beim Schreiben auf den Datenträger  
  
## <a name="binary-mode"></a>Binärmodus  
 Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` -Modus-Regeln gelten, bis auf einige Ausnahmen. Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:  
  
-   Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen. `FilePut` Schreibt alle Variablen zusammenhängend, d. h. ohne Leerraum zwischen Datensätzen Datenträger an.  
  
-   Für ein beliebiges Array als ein Array in einer Struktur `FilePut` schreibt nur die Daten. Es wird kein Deskriptor geschrieben.  
  
-   `FilePut` schreibt Zeichenfolgen variabler Länge, die keine Elemente von Strukturen ohne Längendeskriptor 2-Byte-sind. Die Anzahl der geschriebenen Bytes entspricht die Anzahl der Zeichen in der Zeichenfolge. Die folgenden Anweisungen wird z. B. 11 Bytes Datei Zahl 1 schreiben:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Schreiben in eine Datei mithilfe der `FilePut` -Funktion erfordert `Write` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `FilePut` Funktion, um Daten in eine Datei schreiben. Fünf Datensätze der Struktur `Person` in die Datei geschrieben werden.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (object FileNumber, object Value, object RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(object FileNumber, object Value, object RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Object, Value As Object, Optional RecordNumber As Object = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : obj * obj * obj -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("This member has been deprecated. Please use FilePutObject to write Object types, or coerce FileNumber and RecordNumber to Integer for writing non-Object types. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Object" />
        <Parameter Name="Value" Type="System.Object" />
        <Parameter Name="RecordNumber" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name that contains data written to disk.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</param>
        <summary>Writes data from a variable to a disk file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` gilt nur in `Random` und `Binary` Modus.  
  
 Mit `FilePut` geschriebene Daten werden in der Regel mit `FileGet` aus einer Datei gelesen.  
  
 Der erste Datensatz oder Byte in einer Datei befindet sich an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 usw. ist. Wenn Sie weglassen `RecordNumber`, den nächsten Datensatz bzw. Byte nach dem letzten `FileGet` oder `FilePut` Funktion oder verweist, zu dem letzten `Seek` Funktion geschrieben wird.  
  
 Die `StringIsFixedLength` -Argument steuert, ob die Funktion Zeichenfolgen als Variable oder feste Länge interpretiert. `FilePut` den Längendeskriptor wird nicht geschrieben werden, wenn das Argument ist `True`. Bei Verwendung von `StringIsFixedLength`  =  `True` mit `FilePut`, was identisch mit `FileGet`, und Sie müssen sicherstellen, dass die Zeichenfolge mit der erwarteten Länge initialisiert wird.  
  
## <a name="random-mode"></a>Zufällige Modus  
 Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:  
  
-   Wenn die Länge des zu schreibenden Daten kleiner als die Länge ist, angegeben der `RecordLength` -Klausel der `FileOpen` -Funktion, `FilePut` nachfolgende Datensätze auf Datensatzlänge schreibt. Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt. Da die Menge der Leerstellen Daten nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen empfiehlt sich, die Datensatzlänge der Länge der zu schreibenden Daten überein. Ist die Länge des zu schreibenden Daten größer als die Länge, angegeben der `RecordLength` -Klausel der `FileOpen` -Funktion eine Ausnahme ausgelöst.  
  
-   Eine Zeichenfolge ist, die Zielvariable `FilePut` schreibt einen 2-Byte-Deskriptor, der die Länge der Zeichenfolge enthält, und schreibt dann die Daten, die in die Variable aufgenommen wird. Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge sein.  
  
-   Wenn die Zielvariable ein Objekt ist, die einen numerischen Typ enthält `FilePut` zwei Bytes, identifizieren den `VarType` des Objekts und schreibt dann die Variable. Enthält z. B. wenn ein Objekt zu schreiben, die eine ganze Zahl `FilePut` schreibt sechs Bytes: 2 Bytes, die Identifizierung des Objekts als `VarType(3)` (`Integer`) und vier Bytes, die Daten enthalten. Die angegebene Datensatzlänge der `RecordLength` Parameter in der `FileOpen` Funktion muss mindestens zwei Bytes größer als die tatsächliche Anzahl von Bytes, die zum Speichern von Variablen erforderlich sein.  
  
-   Ist die Zielvariable ein Objekt, das eine Zeichenfolge enthält `FilePut` schreibt eine 2-Byte-Deskriptor, identifiziert die `VarType(8)` des Objekts, ein 2-Byte-Deskriptor, der angibt, der Länge der Zeichenfolge und anschließend die Zeichenfolgendaten. Die angegebene Datensatzlänge der `RecordLength` Parameter in der `FileOpen` Funktion muss mindestens vier Bytes größer als die tatsächliche Länge der Zeichenfolge sein. Wenn Sie eine Zeichenfolge ohne Deskriptor ablegen möchten, sollten Sie übergeben `True` auf die `StringIsFixedLength` Parameter, und die Zeichenfolge, die Sie einlesen, sollte die richtige Länge.  
  
-   Wenn die Zielvariable ein Array ist, müssen Sie eine Auswahl, ob einen Deskriptor für die Größe und die Dimensionen des Arrays zu schreiben. Visual Basic 6.0 und früheren Versionen Dateideskriptor für dynamische Arrays und nicht für Arrays mit fester Größe zu schreiben. Visual Basic 2005 standardmäßig kein Deskriptor geschrieben. Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`. Wenn das Array zu schreiben, müssen Sie entsprechend der Weise wird das Array gelesen werden; Wenn mit dem Deskriptor gelesen werden, müssen Sie den Deskriptor schreiben. Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang. Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl von Dimensionen: (2 + 8 * NumberOfDimensions). Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Arraydeskriptor zu schreiben. Die folgende Arraydeklaration erfordert z. B. 218 Bytes, wenn das Array geschrieben wird auf den Datenträger.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Wenn die Zielvariable einen anderen Typ der Variable (keine Zeichenfolge variabler Länge oder ein Objekt), ist `FilePut` schreibt nur die Daten der Variablen. Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge der zu schreibenden Daten.  
  
-   `FilePut` Schreibt die Elemente von Strukturen, als ob jeder einzeln geschrieben wurden jedoch keine Auffüllung zwischen Elementen. Die `VBFixedString` Attribut angewendet werden kann, zu Zeichenfolgenfeldern in den Strukturen an, dass die Größe der Zeichenfolge beim Schreiben auf den Datenträger.  
  
    > [!NOTE]
    >  String-Felder, die mehr als Bytes angegeben die `VBFixedString` Attribut werden abgeschnitten, beim Schreiben auf den Datenträger  
  
## <a name="binary-mode"></a>Binärmodus  
 Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` -Modus-Regeln gelten, bis auf einige Ausnahmen. Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:  
  
-   Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen. `FilePut` Schreibt alle Variablen zusammenhängend, d. h. ohne Leerraum zwischen Datensätzen Datenträger an.  
  
-   Für ein beliebiges Array als ein Array in einer Struktur `FilePut` schreibt nur die Daten. Es wird kein Deskriptor geschrieben.  
  
-   `FilePut` schreibt Zeichenfolgen variabler Länge, die keine Elemente von Strukturen ohne Längendeskriptor 2-Byte-sind. Die Anzahl der geschriebenen Bytes entspricht die Anzahl der Zeichen in der Zeichenfolge. Die folgenden Anweisungen wird z. B. 11 Bytes Datei Zahl 1 schreiben:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Schreiben in eine Datei mithilfe der `FilePut` -Funktion erfordert `Write` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `FilePut` Funktion, um Daten in eine Datei schreiben. Fünf Datensätze der Struktur `Person` in die Datei geschrieben werden.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, string Value, long RecordNumber = -1, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, string Value, int64 RecordNumber, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As String, Optional RecordNumber As Long = -1, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * string * int64 * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name that contains data written to disk.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</param>
        <param name="StringIsFixedLength">Optional. Applies only when writing a string. Specifies whether to write a two-byte string length descriptor for the string to the file. The default is <see langword="False" />.</param>
        <summary>Writes data from a variable to a disk file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />..</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` gilt nur in `Random` und `Binary` Modus.  
  
 Mit `FilePut` geschriebene Daten werden in der Regel mit `FileGet` aus einer Datei gelesen.  
  
 Der erste Datensatz oder Byte in einer Datei befindet sich an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 usw. ist. Wenn Sie weglassen `RecordNumber`, den nächsten Datensatz bzw. Byte nach dem letzten `FileGet` oder `FilePut` Funktion oder verweist, zu dem letzten `Seek` Funktion geschrieben wird.  
  
 Die `StringIsFixedLength` -Argument steuert, ob die Funktion Zeichenfolgen als Variable oder feste Länge interpretiert. `FilePut` den Längendeskriptor wird nicht geschrieben werden, wenn das Argument ist `True`. Bei Verwendung von `StringIsFixedLength`  =  `True` mit `FilePut`, was identisch mit `FileGet`, und Sie müssen sicherstellen, dass die Zeichenfolge mit der erwarteten Länge initialisiert wird.  
  
## <a name="random-mode"></a>Zufällige Modus  
 Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:  
  
-   Wenn die Länge des zu schreibenden Daten kleiner als die Länge ist, angegeben der `RecordLength` -Klausel der `FileOpen` -Funktion, `FilePut` nachfolgende Datensätze auf Datensatzlänge schreibt. Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt. Da die Menge der Leerstellen Daten nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen empfiehlt sich, die Datensatzlänge der Länge der zu schreibenden Daten überein. Ist die Länge des zu schreibenden Daten größer als die Länge, angegeben der `RecordLength` -Klausel der `FileOpen` -Funktion eine Ausnahme ausgelöst.  
  
-   Eine Zeichenfolge ist, die Zielvariable `FilePut` schreibt einen 2-Byte-Deskriptor, der die Länge der Zeichenfolge enthält, und schreibt dann die Daten, die in die Variable aufgenommen wird. Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge sein.  
  
-   Wenn die Zielvariable ein Objekt ist, die einen numerischen Typ enthält `FilePut` zwei Bytes, identifizieren den `VarType` des Objekts und schreibt dann die Variable. Enthält z. B. wenn ein Objekt zu schreiben, die eine ganze Zahl `FilePut` schreibt sechs Bytes: 2 Bytes, die Identifizierung des Objekts als `VarType(3)` (`Integer`) und vier Bytes, die Daten enthalten. Die angegebene Datensatzlänge der `RecordLength` Parameter in der `FileOpen` Funktion muss mindestens zwei Bytes größer als die tatsächliche Anzahl von Bytes, die zum Speichern von Variablen erforderlich sein.  
  
-   Ist die Zielvariable ein Objekt, das eine Zeichenfolge enthält `FilePut` schreibt eine 2-Byte-Deskriptor, identifiziert die `VarType(8)` des Objekts, ein 2-Byte-Deskriptor, der angibt, der Länge der Zeichenfolge und anschließend die Zeichenfolgendaten. Die angegebene Datensatzlänge der `RecordLength` Parameter in der `FileOpen` Funktion muss mindestens vier Bytes größer als die tatsächliche Länge der Zeichenfolge sein. Wenn Sie eine Zeichenfolge ohne Deskriptor ablegen möchten, sollten Sie übergeben `True` auf die `StringIsFixedLength` Parameter, und die Zeichenfolge, die Sie einlesen, sollte die richtige Länge.  
  
-   Wenn die Zielvariable ein Array ist, müssen Sie eine Auswahl, ob einen Deskriptor für die Größe und die Dimensionen des Arrays zu schreiben. Visual Basic 6.0 und früheren Versionen Dateideskriptor für dynamische Arrays und nicht für Arrays mit fester Größe zu schreiben. Visual Basic 2005 standardmäßig kein Deskriptor geschrieben. Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`. Wenn das Array zu schreiben, müssen Sie entsprechend der Weise wird das Array gelesen werden; Wenn mit dem Deskriptor gelesen werden, müssen Sie den Deskriptor schreiben. Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang. Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl von Dimensionen: (2 + 8 * NumberOfDimensions). Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Arraydeskriptor zu schreiben. Die folgende Arraydeklaration erfordert z. B. 218 Bytes, wenn das Array geschrieben wird auf den Datenträger.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Wenn die Zielvariable einen anderen Typ der Variable (keine Zeichenfolge variabler Länge oder ein Objekt), ist `FilePut` schreibt nur die Daten der Variablen. Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge der zu schreibenden Daten.  
  
-   `FilePut` Schreibt die Elemente von Strukturen, als ob jeder einzeln geschrieben wurden jedoch keine Auffüllung zwischen Elementen. Die `VBFixedString` Attribut angewendet werden kann, zu Zeichenfolgenfeldern in den Strukturen an, dass die Größe der Zeichenfolge beim Schreiben auf den Datenträger.  
  
    > [!NOTE]
    >  String-Felder, die mehr als Bytes angegeben die `VBFixedString` Attribut werden abgeschnitten, beim Schreiben auf den Datenträger  
  
## <a name="binary-mode"></a>Binärmodus  
 Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` -Modus-Regeln gelten, bis auf einige Ausnahmen. Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:  
  
-   Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen. `FilePut` Schreibt alle Variablen zusammenhängend, d. h. ohne Leerraum zwischen Datensätzen Datenträger an.  
  
-   Für ein beliebiges Array als ein Array in einer Struktur `FilePut` schreibt nur die Daten. Es wird kein Deskriptor geschrieben.  
  
-   `FilePut` schreibt Zeichenfolgen variabler Länge, die keine Elemente von Strukturen ohne Längendeskriptor 2-Byte-sind. Die Anzahl der geschriebenen Bytes entspricht die Anzahl der Zeichen in der Zeichenfolge. Die folgenden Anweisungen wird z. B. 11 Bytes Datei Zahl 1 schreiben:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Schreiben in eine Datei mithilfe der `FilePut` -Funktion erfordert `Write` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `FilePut` Funktion, um Daten in eine Datei schreiben. Fünf Datensätze der Struktur `Person` in die Datei geschrieben werden.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, class System.Array Value, int64 RecordNumber, bool ArrayIsDynamic, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Array, Optional RecordNumber As Long = -1, Optional ArrayIsDynamic As Boolean = false, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * Array * int64 * bool * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber, ArrayIsDynamic, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Array" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="ArrayIsDynamic" Type="System.Boolean" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name that contains data written to disk.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</param>
        <param name="ArrayIsDynamic">Optional. Applies only when writing an array. Specifies whether the array is to be treated as dynamic, and whether to write an array descriptor for the string that describes the length.</param>
        <param name="StringIsFixedLength">Optional. Applies only when writing a string. Specifies whether to write a two-byte string length descriptor for the string to the file. The default is <see langword="False" />.</param>
        <summary>Writes data from a variable to a disk file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` gilt nur in `Random` und `Binary` Modus.  
  
 Mit `FilePut` geschriebene Daten werden in der Regel mit `FileGet` aus einer Datei gelesen.  
  
 Der erste Datensatz oder Byte in einer Datei befindet sich an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 usw. ist. Wenn Sie weglassen `RecordNumber`, den nächsten Datensatz bzw. Byte nach dem letzten `FileGet` oder `FilePut` Funktion oder verweist, zu dem letzten `Seek` Funktion geschrieben wird.  
  
 Die `StringIsFixedLength` -Argument steuert, ob die Funktion Zeichenfolgen als Variable oder feste Länge interpretiert. `FilePut` den Längendeskriptor wird nicht geschrieben werden, wenn das Argument ist `True`. Bei Verwendung von `StringIsFixedLength`  =  `True` mit `FilePut`, was identisch mit `FileGet`, und Sie müssen sicherstellen, dass die Zeichenfolge mit der erwarteten Länge initialisiert wird.  
  
## <a name="random-mode"></a>Zufällige Modus  
 Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:  
  
-   Wenn die Länge des zu schreibenden Daten kleiner als die Länge ist, angegeben der `RecordLength` -Klausel der `FileOpen` -Funktion, `FilePut` nachfolgende Datensätze auf Datensatzlänge schreibt. Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt. Da die Menge der Leerstellen Daten nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen empfiehlt sich, die Datensatzlänge der Länge der zu schreibenden Daten überein. Ist die Länge des zu schreibenden Daten größer als die Länge, angegeben der `RecordLength` -Klausel der `FileOpen` -Funktion eine Ausnahme ausgelöst.  
  
-   Eine Zeichenfolge ist, die Zielvariable `FilePut` schreibt einen 2-Byte-Deskriptor, der die Länge der Zeichenfolge enthält, und schreibt dann die Daten, die in die Variable aufgenommen wird. Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge sein.  
  
-   Wenn die Zielvariable ein Objekt ist, die einen numerischen Typ enthält `FilePut` zwei Bytes, identifizieren den `VarType` des Objekts und schreibt dann die Variable. Enthält z. B. wenn ein Objekt zu schreiben, die eine ganze Zahl `FilePut` schreibt sechs Bytes: 2 Bytes, die Identifizierung des Objekts als `VarType(3)` (`Integer`) und vier Bytes, die Daten enthalten. Die angegebene Datensatzlänge der `RecordLength` Parameter in der `FileOpen` Funktion muss mindestens zwei Bytes größer als die tatsächliche Anzahl von Bytes, die zum Speichern von Variablen erforderlich sein.  
  
-   Ist die Zielvariable ein Objekt, das eine Zeichenfolge enthält `FilePut` schreibt eine 2-Byte-Deskriptor, identifiziert die `VarType(8)` des Objekts, ein 2-Byte-Deskriptor, der angibt, der Länge der Zeichenfolge und anschließend die Zeichenfolgendaten. Die angegebene Datensatzlänge der `RecordLength` Parameter in der `FileOpen` Funktion muss mindestens vier Bytes größer als die tatsächliche Länge der Zeichenfolge sein. Wenn Sie eine Zeichenfolge ohne Deskriptor ablegen möchten, sollten Sie übergeben `True` auf die `StringIsFixedLength` Parameter, und die Zeichenfolge, die Sie einlesen, sollte die richtige Länge.  
  
-   Wenn die Zielvariable ein Array ist, müssen Sie eine Auswahl, ob einen Deskriptor für die Größe und die Dimensionen des Arrays zu schreiben. Visual Basic 6.0 und früheren Versionen Dateideskriptor für dynamische Arrays und nicht für Arrays mit fester Größe zu schreiben. Visual Basic 2005 standardmäßig kein Deskriptor geschrieben. Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`. Wenn das Array zu schreiben, müssen Sie entsprechend der Weise wird das Array gelesen werden; Wenn mit dem Deskriptor gelesen werden, müssen Sie den Deskriptor schreiben. Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang. Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl von Dimensionen: (2 + 8 * NumberOfDimensions). Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Arraydeskriptor zu schreiben. Die folgende Arraydeklaration erfordert z. B. 218 Bytes, wenn das Array geschrieben wird auf den Datenträger.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Wenn die Zielvariable einen anderen Typ der Variable (keine Zeichenfolge variabler Länge oder ein Objekt), ist `FilePut` schreibt nur die Daten der Variablen. Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge der zu schreibenden Daten.  
  
-   `FilePut` Schreibt die Elemente von Strukturen, als ob jeder einzeln geschrieben wurden jedoch keine Auffüllung zwischen Elementen. Die `VBFixedString` Attribut angewendet werden kann, zu Zeichenfolgenfeldern in den Strukturen an, dass die Größe der Zeichenfolge beim Schreiben auf den Datenträger.  
  
    > [!NOTE]
    >  String-Felder, die mehr als Bytes angegeben die `VBFixedString` Attribut werden abgeschnitten, beim Schreiben auf den Datenträger  
  
## <a name="binary-mode"></a>Binärmodus  
 Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` -Modus-Regeln gelten, bis auf einige Ausnahmen. Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:  
  
-   Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen. `FilePut` Schreibt alle Variablen zusammenhängend, d. h. ohne Leerraum zwischen Datensätzen Datenträger an.  
  
-   Für ein beliebiges Array als ein Array in einer Struktur `FilePut` schreibt nur die Daten. Es wird kein Deskriptor geschrieben.  
  
-   `FilePut` schreibt Zeichenfolgen variabler Länge, die keine Elemente von Strukturen ohne Längendeskriptor 2-Byte-sind. Die Anzahl der geschriebenen Bytes entspricht die Anzahl der Zeichen in der Zeichenfolge. Die folgenden Anweisungen wird z. B. 11 Bytes Datei Zahl 1 schreiben:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Schreiben in eine Datei mithilfe der `FilePut` -Funktion erfordert `Write` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `FilePut` Funktion, um Daten in eine Datei schreiben. Fünf Datensätze der Struktur `Person` in die Datei geschrieben werden.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePutObject">
      <MemberSignature Language="C#" Value="public static void FilePutObject (int FileNumber, object Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePutObject(int32 FileNumber, object Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePutObject (FileNumber As Integer, Value As Object, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePutObject : int * obj * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePutObject (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name that contains data written to disk.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</param>
        <summary>Writes data from a variable to a disk file.  The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePutObject" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `FilePutObject` Funktion dient anstelle von `FilePut` um Mehrdeutigkeiten zum Zeitpunkt der Kompilierung zu vermeiden, wenn Typ `Object` wird z. B. anstelle eines anderen Typs übergeben `Integer`, `Long`, `Short`usw.  
  
 `FilePutObject` schreibt und liest Deskriptoren, die das Objekt zu beschreiben. Wenn Sie beabsichtigen, schreiben die `Variant` Typ `FilePutObject` ist erforderlich. Im Zweifelsfall, wenn Sie ein Objekt für den zweiten Parameter verwenden, wird empfohlen, dass Sie immer verwenden `FilePutObject` und `FileGetObject`.  
  
 `FilePutObject` gilt nur in `Random` und `Binary` Modus.  
  
 Mit `FilePutObject` geschriebene Daten werden in der Regel mit `FileGetObject` aus einer Datei gelesen.  
  
 Der erste Datensatz oder Byte in einer Datei befindet sich an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 usw. ist. Wenn Sie weglassen `RecordNumber`, `FilePutObject` schreibt den nächsten Datensatz bzw. Byte nach dem letzten `FileGetObject` oder `FilePutObject` Funktion (oder den Datensatz bzw. das Byte verweist, zu dem letzten `Seek` Funktion).  
  
 Die `StringIsFixedLength` -Argument steuert, ob die Funktion Zeichenfolgen als Variable oder feste Länge interpretiert. `FilePutObject` den Längendeskriptor wird nicht geschrieben werden, wenn das Argument ist `True`. Bei Verwendung von `StringIsFixedLength`  =  `True` mit `FilePutObject`, was identisch mit `FileGetObject`, und Sie müssen auch sicherstellen, dass die Zeichenfolge mit der erwarteten Länge initialisiert wird.  
  
## <a name="random-mode"></a>Zufällige Modus  
 Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:  
  
-   Wenn die Länge des zu schreibenden Daten kleiner als die Länge ist, angegeben der `RecordLength` -Klausel der `FileOpen` -Funktion, `FilePutObject` nachfolgende Datensätze auf Datensatzlänge schreibt. Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt. Da die Menge der Leerstellen Daten genau ermittelt werden kann, ist es im Allgemeinen empfiehlt sich, die Datensatzlänge der Länge der zu schreibenden Daten überein. Ist die Länge des zu schreibenden Daten größer als die Länge, angegeben der `RecordLength` -Klausel der `FileOpen` -Funktion eine Ausnahme ausgelöst.  
  
-   Wenn die Zielvariable ein Objekt ist, die einen numerischen Typ enthält `FilePutObject` zwei Bytes, identifizieren den `VarType` des Objekts und schreibt dann die Variable. Enthält z. B. wenn ein Objekt zu schreiben, die eine ganze Zahl `FilePutObject` schreibt sechs Bytes: 2 Bytes, die Identifizierung des Objekts als `VarType(3)` (`Integer`) und vier Bytes, die Daten enthalten. Die angegebene Datensatzlänge der `RecordLength` Parameter in der `FileOpen` Funktion muss mindestens zwei Bytes größer als die tatsächliche Anzahl von Bytes, die zum Speichern von Variablen erforderlich sein.  
  
-   Ob die Zielvariable ein Objekt, das eine Zeichenfolge enthält `FilePutObject` schreibt eine 2-Byte-Deskriptor identifizieren die `VarType(8)` des Objekts, ein 2-Byte-Deskriptor, der angibt, der Länge der Zeichenfolge und anschließend die Zeichenfolgendaten. Die angegebene Datensatzlänge der `RecordLength` Parameter in der `FileOpen` Funktion muss mindestens vier Bytes größer als die tatsächliche Länge der Zeichenfolge sein. Wenn Sie eine Zeichenfolge ohne Deskriptor ablegen möchten, sollten Sie übergeben `True` auf die `StringIsFixedLength` Parameter, und die Zeichenfolge, die Sie einlesen, sollte die richtige Länge.  
  
-   Wenn die Zielvariable ein Array, und klicken Sie dann auf die angegebene Datensatzlänge ist die `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Arraydeskriptor zu schreiben. Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang. Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl von Dimensionen: (2 + 8 * NumberOfDimensions).  
  
## <a name="binary-mode"></a>Binärmodus  
 Für Dateien in geöffnet `Binary` Modus alle der `Random` -Modus-Regeln gelten, außer:  
  
-   Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen. `FilePutObject` Schreibt alle Variablen zusammenhängend, d. h. ohne Leerraum zwischen Datensätzen Datenträger an.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `FilePutObject` Funktion, um eine Zeichenfolge in eine Datei zu schreiben.  
  
 [!code-vb[VbVbalrCatRef#54](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#54)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />
      </Docs>
    </Member>
    <Member MemberName="FileWidth">
      <MemberSignature Language="C#" Value="public static void FileWidth (int FileNumber, int RecordWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileWidth(int32 FileNumber, int32 RecordWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileWidth (FileNumber As Integer, RecordWidth As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileWidth(int FileNumber, int RecordWidth);" />
      <MemberSignature Language="F#" Value="static member FileWidth : int * int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileWidth (FileNumber, RecordWidth)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="RecordWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="RecordWidth">Required. Numeric expression in the range 0–255, inclusive, which indicates how many characters appear on a line before a new line is started. If <c>RecordWidth</c> equals 0, there is no limit to the length of a line. The default value for <c>RecordWidth</c> is 0.</param>
        <summary>Assigns an output line width to a file opened by using the <see langword="FileOpen" /> function.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Dieses Beispiel verwendet die `FileWidth` Funktion, um die Ausgabezeilenbreite für eine Datei festzulegen.  
  
 [!code-vb[VbVbalrCatRef#10](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FreeFile">
      <MemberSignature Language="C#" Value="public static int FreeFile ();" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 FreeFile() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FreeFile" />
      <MemberSignature Language="VB.NET" Value="Public Function FreeFile () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int FreeFile();" />
      <MemberSignature Language="F#" Value="static member FreeFile : unit -&gt; int" Usage="Microsoft.VisualBasic.FileSystem.FreeFile " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns an <see langword="Integer" /> value that represents the next file number available for use by the <see langword="FileOpen" /> function.</summary>
        <returns>Returns an <see langword="Integer" /> value that represents the next file number available for use by the <see langword="FileOpen" /> function.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwendung `FreeFile` eine Dateinummer angeben, die nicht bereits verwendet wird.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `FreeFile` Funktion, um die nächste verfügbare Zahl zurückzugeben. Für die Ausgabe innerhalb der Schleife werden fünf Dateien geöffnet, und einige Beispieldaten werden an jede geschrieben.  
  
 [!code-vb[VbVbalrCatRef#55](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#55)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">More than 255 files are in use.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="GetAttr">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.FileAttribute GetAttr (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.FileAttribute GetAttr(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAttr (PathName As String) As FileAttribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::FileAttribute GetAttr(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member GetAttr : string -&gt; Microsoft.VisualBasic.FileAttribute" Usage="Microsoft.VisualBasic.FileSystem.GetAttr PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.FileAttribute</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">Required. <see langword="String" /> expression that specifies a file, directory, or folder name. <c>PathName</c> can include the directory or folder, and the drive.</param>
        <summary>Returns a <see langword="FileAttribute" /> value that represents the attributes of a file, directory, or folder. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileAttribute" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <returns>The value returned by <see langword="GetAttr" /> is the sum of the following enumeration values:  <list type="table"><item><term> Value  </term><description> Constant  </description><description> Description  </description></item><item><term><see langword="Normal" /></term><description><see langword="vbNormal" /></description><description> Normal.  </description></item><item><term><see langword="ReadOnly" /></term><description><see langword="vbReadOnly" /></description><description> Read-only.  </description></item><item><term><see langword="Hidden" /></term><description><see langword="vbHidden" /></description><description> Hidden.  </description></item><item><term><see langword="System" /></term><description><see langword="vbSystem" /></description><description> System file.  </description></item><item><term><see langword="Directory" /></term><description><see langword="vbDirectory" /></description><description> Directory or folder.  </description></item><item><term><see langword="Archive" /></term><description><see langword="vbArchive" /></description><description> File has changed since last backup.  </description></item><item><term><see langword="Alias" /></term><description><see langword="vbAlias" /></description><description> File has a different name.  </description></item></list><block subset="none" type="note"><para> These enumerations are specified by the Visual Basic language. The names can be used anywhere in your code in place of the actual values.  </para></block></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden, um zu bestimmen, welche Attribute festgelegt werden, die `And` Operator einen bitweisen Vergleich von den Rückgabewert von Durchführen der `GetAttr` -Funktion und den Wert des Attributs Einzeldatei werden sollen. Wenn das Ergebnis nicht 0 (null) ist, wird dieses Attribut für die benannte Datei festgelegt. Beispielsweise ist der Rückgabewert der folgenden `And` Ausdruck ist NULL, wenn die `Archive` -Attribut nicht festgelegt ist:  
  
```vb  
Result = GetAttr(FName) And vbArchive  
```  
  
 Ein Wert ungleich NULL wird zurückgegeben, wenn die `Archive` -Attribut festgelegt ist.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `GetAttr` -Funktion können Sie die Attribute einer Datei und das Verzeichnis oder die Ordner zu ermitteln.  
  
 [!code-vb[VbVbalrCatRef#25](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <paramref name="Pathname" /> is invalid or contains wildcards.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Target file does not exist.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Input">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Reads data from an open sequential file and assigns the data to variables.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref bool Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, bool&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, bool % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Variable that is assigned the values read from the file—cannot be an array or object variable.</param>
        <summary>Reads data from an open sequential file and assigns the data to variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Input` Funktion wird für Abwärtskompatibilität angeboten und die Leistung beeinträchtigen. Für nicht-Legacyanwendungen der `My.Computer.FileSystem` Objekt bietet eine bessere Leistung. Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Datenlesevorgänge mit `Input` in der Regel in eine Datei geschrieben wird, mithilfe von `Write`. Verwenden Sie diese Funktion nur mit geöffneten Dateien `Input` oder `Binary` Modus.  
  
> [!IMPORTANT]
>  Beim Lesen aus Dateien nicht Beurteilen der Inhalt der Datei anhand der Dateinamenerweiterung. Eine Datei mit dem Namen "Form1.vb" möglicherweise z. B. keine Visual Basic 2005-Quelldatei.  
  
 Beim Lesen standard Zeichenfolgen- oder numerische Daten ohne Änderung Variablen zugewiesen werden. Die folgende Tabelle verdeutlicht, wie die Eingabedaten behandelt werden.  
  
|Daten|Variablen zugewiesenen Wert|  
|-|-|  
|Komma oder Leerzeile begrenzen|Empty|  
|#NULL #|`DBNull`|  
|#TRUE # "oder" #FALSE #|`True` oder `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Das Datum und/oder eine Uhrzeit, die durch den Ausdruck dargestellt wird.|  
|#ERROR `errornumber`#|`errornumber` (Variable ist ein Objekt, das als Fehler gekennzeichnet)|  
  
 Wenn das Ende der Datei wird erreicht, während Sie eines Datenelements, die Eingabe wird beendet und ein Fehler auftritt.  
  
> [!NOTE]
>  Die `Input` Funktion ist nicht lokalisiert. Z. B. wenn eingegebene 3,14159, in der deutschen Version wird nur 3 zurückgegeben, da das Komma als Trennzeichen Variablen statt als Dezimaltrennzeichen behandelt wird.  
  
> [!IMPORTANT]
>  Lesen aus einer Datei mithilfe der `Input` -Funktion erfordert `Read` aus Zugriff auf die `FileIOPermissionAccess` Enumeration. Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `Input` Funktion zum Lesen von Daten aus einer Datei in zwei Variablen. In diesem Beispiel wird vorausgesetzt, dass `TestFile` ist eine Datei, die einige Zeilen der Daten, die Sie mithilfe von geschrieben hat die `Write` -Funktion, jede Zeile mit einer Zeichenfolge in Anführungszeichen und eine Zahl, die durch Kommas getrennt ein, z. B.: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref byte Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, unsigned int8&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Byte % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Variable that is assigned the values read from the file—cannot be an array or object variable.</param>
        <summary>Reads data from an open sequential file and assigns the data to variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Input` Funktion wird für Abwärtskompatibilität angeboten und die Leistung beeinträchtigen. Für nicht-Legacyanwendungen der `My.Computer.FileSystem` Objekt bietet eine bessere Leistung. Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Datenlesevorgänge mit `Input` in der Regel in eine Datei geschrieben wird, mithilfe von `Write`. Verwenden Sie diese Funktion nur mit geöffneten Dateien `Input` oder `Binary` Modus.  
  
> [!IMPORTANT]
>  Beim Lesen aus Dateien nicht Beurteilen der Inhalt der Datei anhand der Dateinamenerweiterung. Eine Datei mit dem Namen "Form1.vb" möglicherweise z. B. keine Visual Basic 2005-Quelldatei.  
  
 Beim Lesen standard Zeichenfolgen- oder numerische Daten ohne Änderung Variablen zugewiesen werden. Die folgende Tabelle verdeutlicht, wie die Eingabedaten behandelt werden.  
  
|Daten|Variablen zugewiesenen Wert|  
|-|-|  
|Komma oder Leerzeile begrenzen|Empty|  
|#NULL #|`DBNull`|  
|#TRUE # "oder" #FALSE #|`True` oder `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Das Datum und/oder eine Uhrzeit, die durch den Ausdruck dargestellt wird.|  
|#ERROR `errornumber`#|`errornumber` (Variable ist ein Objekt, das als Fehler gekennzeichnet)|  
  
 Wenn das Ende der Datei wird erreicht, während Sie eines Datenelements, die Eingabe wird beendet und ein Fehler auftritt.  
  
> [!NOTE]
>  Die `Input` Funktion ist nicht lokalisiert. Z. B. wenn eingegebene 3,14159, in der deutschen Version wird nur 3 zurückgegeben, da das Komma als Trennzeichen Variablen statt als Dezimaltrennzeichen behandelt wird.  
  
> [!IMPORTANT]
>  Lesen aus einer Datei mithilfe der `Input` -Funktion erfordert `Read` aus Zugriff auf die `FileIOPermissionAccess` Enumeration. Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `Input` Funktion zum Lesen von Daten aus einer Datei in zwei Variablen. In diesem Beispiel wird vorausgesetzt, dass `TestFile` ist eine Datei, die einige Zeilen der Daten, die Sie mithilfe von geschrieben hat die `Write` -Funktion, jede Zeile mit einer Zeichenfolge in Anführungszeichen und eine Zahl, die durch Kommas getrennt ein, z. B.: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref char Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, char&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, char % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Variable that is assigned the values read from the file—cannot be an array or object variable.</param>
        <summary>Reads data from an open sequential file and assigns the data to variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Input` Funktion wird für Abwärtskompatibilität angeboten und die Leistung beeinträchtigen. Für nicht-Legacyanwendungen der `My.Computer.FileSystem` Objekt bietet eine bessere Leistung. Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Datenlesevorgänge mit `Input` in der Regel in eine Datei geschrieben wird, mithilfe von `Write`. Verwenden Sie diese Funktion nur mit geöffneten Dateien `Input` oder `Binary` Modus.  
  
> [!IMPORTANT]
>  Beim Lesen aus Dateien nicht Beurteilen der Inhalt der Datei anhand der Dateinamenerweiterung. Eine Datei mit dem Namen "Form1.vb" möglicherweise z. B. keine Visual Basic 2005-Quelldatei.  
  
 Beim Lesen standard Zeichenfolgen- oder numerische Daten ohne Änderung Variablen zugewiesen werden. Die folgende Tabelle verdeutlicht, wie die Eingabedaten behandelt werden.  
  
|Daten|Variablen zugewiesenen Wert|  
|-|-|  
|Komma oder Leerzeile begrenzen|Empty|  
|#NULL #|`DBNull`|  
|#TRUE # "oder" #FALSE #|`True` oder `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Das Datum und/oder eine Uhrzeit, die durch den Ausdruck dargestellt wird.|  
|#ERROR `errornumber`#|`errornumber` (Variable ist ein Objekt, das als Fehler gekennzeichnet)|  
  
 Wenn das Ende der Datei wird erreicht, während Sie eines Datenelements, die Eingabe wird beendet und ein Fehler auftritt.  
  
> [!NOTE]
>  Die `Input` Funktion ist nicht lokalisiert. Z. B. wenn eingegebene 3,14159, in der deutschen Version wird nur 3 zurückgegeben, da das Komma als Trennzeichen Variablen statt als Dezimaltrennzeichen behandelt wird.  
  
> [!IMPORTANT]
>  Lesen aus einer Datei mithilfe der `Input` -Funktion erfordert `Read` aus Zugriff auf die `FileIOPermissionAccess` Enumeration. Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `Input` Funktion zum Lesen von Daten aus einer Datei in zwei Variablen. In diesem Beispiel wird vorausgesetzt, dass `TestFile` ist eine Datei, die mehrere Zeilen mit Daten, die Sie mithilfe von geschrieben hat die `Write` -Funktion, jede Zeile mit einer Zeichenfolge in Anführungszeichen und eine Zahl, die durch Kommas getrennt ein, z. B.: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref DateTime Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, valuetype System.DateTime&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, DateTime % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Variable that is assigned the values read from the file—cannot be an array or object variable.</param>
        <summary>Reads data from an open sequential file and assigns the data to variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Input` Funktion wird für Abwärtskompatibilität angeboten und die Leistung beeinträchtigen. Für nicht-Legacyanwendungen der `My.Computer.FileSystem` Objekt bietet eine bessere Leistung. Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Datenlesevorgänge mit `Input` in der Regel in eine Datei geschrieben wird, mithilfe von `Write`. Verwenden Sie diese Funktion nur mit geöffneten Dateien `Input` oder `Binary` Modus.  
  
> [!IMPORTANT]
>  Beim Lesen aus Dateien nicht Beurteilen der Inhalt der Datei anhand der Dateinamenerweiterung. Eine Datei mit dem Namen "Form1.vb" möglicherweise z. B. keine Visual Basic 2005-Quelldatei.  
  
 Beim Lesen standard Zeichenfolgen- oder numerische Daten ohne Änderung Variablen zugewiesen werden. Die folgende Tabelle verdeutlicht, wie die Eingabedaten behandelt werden.  
  
|Daten|Variablen zugewiesenen Wert|  
|-|-|  
|Komma oder Leerzeile begrenzen|Empty|  
|#NULL #|`DBNull`|  
|#TRUE # "oder" #FALSE #|`True` oder `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Das Datum und/oder eine Uhrzeit, die durch den Ausdruck dargestellt wird.|  
|#ERROR `errornumber`#|`errornumber` (Variable ist ein Objekt, das als Fehler gekennzeichnet)|  
  
 Wenn das Ende der Datei wird erreicht, während Sie eines Datenelements, die Eingabe wird beendet und ein Fehler auftritt.  
  
> [!NOTE]
>  Die `Input` Funktion ist nicht lokalisiert. Z. B. wenn eingegebene 3,14159, in der deutschen Version wird nur 3 zurückgegeben, da das Komma als Trennzeichen Variablen statt als Dezimaltrennzeichen behandelt wird.  
  
> [!IMPORTANT]
>  Lesen aus einer Datei mithilfe der `Input` -Funktion erfordert `Read` aus Zugriff auf die `FileIOPermissionAccess` Enumeration. Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `Input` Funktion zum Lesen von Daten aus einer Datei in zwei Variablen. In diesem Beispiel wird vorausgesetzt, dass `TestFile` ist eine Datei, die mehrere Zeilen mit Daten, die Sie mithilfe von geschrieben hat die `Write` -Funktion, jede Zeile mit einer Zeichenfolge in Anführungszeichen und eine Zahl, die durch Kommas getrennt ein, z. B.: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref decimal Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, valuetype System.Decimal&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Decimal % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Variable that is assigned the values read from the file—cannot be an array or object variable.</param>
        <summary>Reads data from an open sequential file and assigns the data to variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Input` Funktion wird für Abwärtskompatibilität angeboten und die Leistung beeinträchtigen. Für nicht-Legacyanwendungen der `My.Computer.FileSystem` Objekt bietet eine bessere Leistung. Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Datenlesevorgänge mit `Input` in der Regel in eine Datei geschrieben wird, mithilfe von `Write`. Verwenden Sie diese Funktion nur mit geöffneten Dateien `Input` oder `Binary` Modus.  
  
> [!IMPORTANT]
>  Beim Lesen aus Dateien nicht Beurteilen der Inhalt der Datei anhand der Dateinamenerweiterung. Eine Datei mit dem Namen "Form1.vb" möglicherweise z. B. keine Visual Basic 2005-Quelldatei.  
  
 Beim Lesen standard Zeichenfolgen- oder numerische Daten ohne Änderung Variablen zugewiesen werden. Die folgende Tabelle verdeutlicht, wie die Eingabedaten behandelt werden.  
  
|Daten|Variablen zugewiesenen Wert|  
|-|-|  
|Komma oder Leerzeile begrenzen|Empty|  
|#NULL #|`DBNull`|  
|#TRUE # "oder" #FALSE #|`True` oder `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Das Datum und/oder eine Uhrzeit, die durch den Ausdruck dargestellt wird.|  
|#ERROR `errornumber`#|`errornumber` (Variable ist ein Objekt, das als Fehler gekennzeichnet)|  
  
 Wenn das Ende der Datei wird erreicht, während Sie eines Datenelements, die Eingabe wird beendet und ein Fehler auftritt.  
  
> [!NOTE]
>  Die `Input` Funktion ist nicht lokalisiert. Z. B. wenn eingegebene 3,14159, in der deutschen Version wird nur 3 zurückgegeben, da das Komma als Trennzeichen Variablen statt als Dezimaltrennzeichen behandelt wird.  
  
> [!IMPORTANT]
>  Lesen aus einer Datei mithilfe der `Input` -Funktion erfordert `Read` aus Zugriff auf die `FileIOPermissionAccess` Enumeration. Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `Input` Funktion zum Lesen von Daten aus einer Datei in zwei Variablen. In diesem Beispiel wird vorausgesetzt, dass `TestFile` ist eine Datei, die mehrere Zeilen mit Daten, die Sie mithilfe von geschrieben hat die `Write` -Funktion, jede Zeile mit einer Zeichenfolge in Anführungszeichen und eine Zahl, die durch Kommas getrennt ein, z. B.: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref double Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, float64&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, double % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Variable that is assigned the values read from the file—cannot be an array or object variable.</param>
        <summary>Reads data from an open sequential file and assigns the data to variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Input` Funktion wird für Abwärtskompatibilität angeboten und die Leistung beeinträchtigen. Für nicht-Legacyanwendungen der `My.Computer.FileSystem` Objekt bietet eine bessere Leistung. Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Datenlesevorgänge mit `Input` in der Regel in eine Datei geschrieben wird, mithilfe von `Write`. Verwenden Sie diese Funktion nur mit geöffneten Dateien `Input` oder `Binary` Modus.  
  
> [!IMPORTANT]
>  Beim Lesen aus Dateien nicht Beurteilen der Inhalt der Datei anhand der Dateinamenerweiterung. Eine Datei mit dem Namen "Form1.vb" möglicherweise z. B. keine Visual Basic 2005-Quelldatei.  
  
 Beim Lesen standard Zeichenfolgen- oder numerische Daten ohne Änderung Variablen zugewiesen werden. Die folgende Tabelle verdeutlicht, wie die Eingabedaten behandelt werden.  
  
|Daten|Variablen zugewiesenen Wert|  
|-|-|  
|Komma oder Leerzeile begrenzen|Empty|  
|#NULL #|`DBNull`|  
|#TRUE # "oder" #FALSE #|`True` oder `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Das Datum und/oder eine Uhrzeit, die durch den Ausdruck dargestellt wird.|  
|#ERROR `errornumber`#|`errornumber` (Variable ist ein Objekt, das als Fehler gekennzeichnet)|  
  
 Wenn das Ende der Datei wird erreicht, während Sie eines Datenelements, die Eingabe wird beendet und ein Fehler auftritt.  
  
> [!NOTE]
>  Die `Input` Funktion ist nicht lokalisiert. Z. B. wenn eingegebene 3,14159, in der deutschen Version wird nur 3 zurückgegeben, da das Komma als Trennzeichen Variablen statt als Dezimaltrennzeichen behandelt wird.  
  
> [!IMPORTANT]
>  Lesen aus einer Datei mithilfe der `Input` -Funktion erfordert `Read` aus Zugriff auf die `FileIOPermissionAccess` Enumeration. Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `Input` Funktion zum Lesen von Daten aus einer Datei in zwei Variablen. In diesem Beispiel wird vorausgesetzt, dass `TestFile` ist eine Datei, die mehrere Zeilen mit Daten, die Sie mithilfe von geschrieben hat die `Write` -Funktion, jede Zeile mit einer Zeichenfolge in Anführungszeichen und eine Zahl, die durch Kommas getrennt ein, z. B.: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref short Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int16&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, short % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Variable that is assigned the values read from the file—cannot be an array or object variable.</param>
        <summary>Reads data from an open sequential file and assigns the data to variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Input` Funktion wird für Abwärtskompatibilität angeboten und die Leistung beeinträchtigen. Für nicht-Legacyanwendungen der `My.Computer.FileSystem` Objekt bietet eine bessere Leistung. Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Datenlesevorgänge mit `Input` in der Regel in eine Datei geschrieben wird, mithilfe von `Write`. Verwenden Sie diese Funktion nur mit geöffneten Dateien `Input` oder `Binary` Modus.  
  
> [!IMPORTANT]
>  Beim Lesen aus Dateien nicht Beurteilen der Inhalt der Datei anhand der Dateinamenerweiterung. Eine Datei mit dem Namen "Form1.vb" möglicherweise z. B. keine Visual Basic 2005-Quelldatei.  
  
 Beim Lesen standard Zeichenfolgen- oder numerische Daten ohne Änderung Variablen zugewiesen werden. Die folgende Tabelle verdeutlicht, wie die Eingabedaten behandelt werden.  
  
|Daten|Variablen zugewiesenen Wert|  
|-|-|  
|Komma oder Leerzeile begrenzen|Empty|  
|#NULL #|`DBNull`|  
|#TRUE # "oder" #FALSE #|`True` oder `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Das Datum und/oder eine Uhrzeit, die durch den Ausdruck dargestellt wird.|  
|#ERROR `errornumber`#|`errornumber` (Variable ist ein Objekt, das als Fehler gekennzeichnet)|  
  
 Wenn das Ende der Datei wird erreicht, während Sie eines Datenelements, die Eingabe wird beendet und ein Fehler auftritt.  
  
> [!NOTE]
>  Die `Input` Funktion ist nicht lokalisiert. Z. B. wenn eingegebene 3,14159, in der deutschen Version wird nur 3 zurückgegeben, da das Komma als Trennzeichen Variablen statt als Dezimaltrennzeichen behandelt wird.  
  
> [!IMPORTANT]
>  Lesen aus einer Datei mithilfe der `Input` -Funktion erfordert `Read` aus Zugriff auf die `FileIOPermissionAccess` Enumeration. Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `Input` Funktion zum Lesen von Daten aus einer Datei in zwei Variablen. In diesem Beispiel wird vorausgesetzt, dass `TestFile` ist eine Datei, die mehrere Zeilen mit Daten, die Sie mithilfe von geschrieben hat die `Write` -Funktion, jede Zeile mit einer Zeichenfolge in Anführungszeichen und eine Zahl, die durch Kommas getrennt ein, z. B.: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref int Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int32&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, int % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Variable that is assigned the values read from the file—cannot be an array or object variable.</param>
        <summary>Reads data from an open sequential file and assigns the data to variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Input` Funktion wird für Abwärtskompatibilität angeboten und die Leistung beeinträchtigen. Für nicht-Legacyanwendungen der `My.Computer.FileSystem` Objekt bietet eine bessere Leistung. Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Datenlesevorgänge mit `Input` in der Regel in eine Datei geschrieben wird, mithilfe von `Write`. Verwenden Sie diese Funktion nur mit geöffneten Dateien `Input` oder `Binary` Modus.  
  
> [!IMPORTANT]
>  Beim Lesen aus Dateien nicht Beurteilen der Inhalt der Datei anhand der Dateinamenerweiterung. Eine Datei mit dem Namen "Form1.vb" möglicherweise z. B. keine Visual Basic 2005-Quelldatei.  
  
 Beim Lesen standard Zeichenfolgen- oder numerische Daten ohne Änderung Variablen zugewiesen werden. Die folgende Tabelle verdeutlicht, wie die Eingabedaten behandelt werden.  
  
|Daten|Variablen zugewiesenen Wert|  
|-|-|  
|Komma oder Leerzeile begrenzen|Empty|  
|#NULL #|`DBNull`|  
|#TRUE # "oder" #FALSE #|`True` oder `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Das Datum und/oder eine Uhrzeit, die durch den Ausdruck dargestellt wird.|  
|#ERROR `errornumber`#|`errornumber` (Variable ist ein Objekt, das als Fehler gekennzeichnet)|  
  
 Wenn das Ende der Datei wird erreicht, während Sie eines Datenelements, die Eingabe wird beendet und ein Fehler auftritt.  
  
> [!NOTE]
>  Die `Input` Funktion ist nicht lokalisiert. Z. B. wenn eingegebene 3,14159, in der deutschen Version wird nur 3 zurückgegeben, da das Komma als Trennzeichen Variablen statt als Dezimaltrennzeichen behandelt wird.  
  
> [!IMPORTANT]
>  Lesen aus einer Datei mithilfe der `Input` -Funktion erfordert `Read` aus Zugriff auf die `FileIOPermissionAccess` Enumeration. Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `Input` Funktion zum Lesen von Daten aus einer Datei in zwei Variablen. In diesem Beispiel wird vorausgesetzt, dass `TestFile` ist eine Datei, die mehrere Zeilen mit Daten, die Sie mithilfe von geschrieben hat die `Write` -Funktion, jede Zeile mit einer Zeichenfolge in Anführungszeichen und eine Zahl, die durch Kommas getrennt ein, z. B.: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref long Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int64&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, long % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Variable that is assigned the values read from the file—cannot be an array or object variable.</param>
        <summary>Reads data from an open sequential file and assigns the data to variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Input` Funktion wird für Abwärtskompatibilität angeboten und die Leistung beeinträchtigen. Für nicht-Legacyanwendungen der `My.Computer.FileSystem` Objekt bietet eine bessere Leistung. Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Datenlesevorgänge mit `Input` in der Regel in eine Datei geschrieben wird, mithilfe von `Write`. Verwenden Sie diese Funktion nur mit geöffneten Dateien `Input` oder `Binary` Modus.  
  
> [!IMPORTANT]
>  Beim Lesen aus Dateien nicht Beurteilen der Inhalt der Datei anhand der Dateinamenerweiterung. Eine Datei mit dem Namen "Form1.vb" möglicherweise z. B. keine Visual Basic 2005-Quelldatei.  
  
 Beim Lesen standard Zeichenfolgen- oder numerische Daten ohne Änderung Variablen zugewiesen werden. Die folgende Tabelle verdeutlicht, wie die Eingabedaten behandelt werden.  
  
|Daten|Variablen zugewiesenen Wert|  
|-|-|  
|Komma oder Leerzeile begrenzen|Empty|  
|#NULL #|`DBNull`|  
|#TRUE # "oder" #FALSE #|`True` oder `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Das Datum und/oder eine Uhrzeit, die durch den Ausdruck dargestellt wird.|  
|#ERROR `errornumber`#|`errornumber` (Variable ist ein Objekt, das als Fehler gekennzeichnet)|  
  
 Wenn das Ende der Datei wird erreicht, während Sie eines Datenelements, die Eingabe wird beendet und ein Fehler auftritt.  
  
> [!NOTE]
>  Die `Input` Funktion ist nicht lokalisiert. Z. B. wenn eingegebene 3,14159, in der deutschen Version wird nur 3 zurückgegeben, da das Komma als Trennzeichen Variablen statt als Dezimaltrennzeichen behandelt wird.  
  
> [!IMPORTANT]
>  Lesen aus einer Datei mithilfe der `Input` -Funktion erfordert `Read` aus Zugriff auf die `FileIOPermissionAccess` Enumeration. Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `Input` Funktion zum Lesen von Daten aus einer Datei in zwei Variablen. In diesem Beispiel wird vorausgesetzt, dass `TestFile` ist eine Datei, die mehrere Zeilen mit Daten, die Sie mithilfe von geschrieben hat die `Write` -Funktion, jede Zeile mit einer Zeichenfolge in Anführungszeichen und eine Zahl, die durch Kommas getrennt ein, z. B.: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref object Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, object&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Object ^ % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Variable that is assigned the values read from the file—cannot be an array or object variable.</param>
        <summary>Reads data from an open sequential file and assigns the data to variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Input` Funktion wird für Abwärtskompatibilität angeboten und die Leistung beeinträchtigen. Für nicht-Legacyanwendungen der `My.Computer.FileSystem` Objekt bietet eine bessere Leistung. Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Datenlesevorgänge mit `Input` in der Regel in eine Datei geschrieben wird, mithilfe von `Write`. Verwenden Sie diese Funktion nur mit geöffneten Dateien `Input` oder `Binary` Modus.  
  
> [!IMPORTANT]
>  Beim Lesen aus Dateien nicht Beurteilen der Inhalt der Datei anhand der Dateinamenerweiterung. Eine Datei mit dem Namen "Form1.vb" möglicherweise z. B. keine Visual Basic 2005-Quelldatei.  
  
 Beim Lesen standard Zeichenfolgen- oder numerische Daten ohne Änderung Variablen zugewiesen werden. Die folgende Tabelle verdeutlicht, wie die Eingabedaten behandelt werden.  
  
|Daten|Variablen zugewiesenen Wert|  
|-|-|  
|Komma oder Leerzeile begrenzen|Empty|  
|#NULL #|`DBNull`|  
|#TRUE # "oder" #FALSE #|`True` oder `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Das Datum und/oder eine Uhrzeit, die durch den Ausdruck dargestellt wird.|  
|#ERROR `errornumber`#|`errornumber` (Variable ist ein Objekt, das als Fehler gekennzeichnet)|  
  
 Wenn das Ende der Datei wird erreicht, während Sie eines Datenelements, die Eingabe wird beendet und ein Fehler auftritt.  
  
> [!NOTE]
>  Die `Input` Funktion ist nicht lokalisiert. Z. B. wenn eingegebene 3,14159, in der deutschen Version wird nur 3 zurückgegeben, da das Komma als Trennzeichen Variablen statt als Dezimaltrennzeichen behandelt wird.  
  
> [!IMPORTANT]
>  Lesen aus einer Datei mithilfe der `Input` -Funktion erfordert `Read` aus Zugriff auf die `FileIOPermissionAccess` Enumeration. Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `Input` Funktion zum Lesen von Daten aus einer Datei in zwei Variablen. In diesem Beispiel wird vorausgesetzt, dass `TestFile` ist eine Datei, die mehrere Zeilen mit Daten, die Sie mithilfe von geschrieben hat die `Write` -Funktion, jede Zeile mit einer Zeichenfolge in Anführungszeichen und eine Zahl, die durch Kommas getrennt ein, z. B.: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref float Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, float32&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, float % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Variable that is assigned the values read from the file—cannot be an array or object variable.</param>
        <summary>Reads data from an open sequential file and assigns the data to variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Input` Funktion wird für Abwärtskompatibilität angeboten und die Leistung beeinträchtigen. Für nicht-Legacyanwendungen der `My.Computer.FileSystem` Objekt bietet eine bessere Leistung. Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Datenlesevorgänge mit `Input` in der Regel in eine Datei geschrieben wird, mithilfe von `Write`. Verwenden Sie diese Funktion nur mit geöffneten Dateien `Input` oder `Binary` Modus.  
  
> [!IMPORTANT]
>  Beim Lesen aus Dateien nicht Beurteilen der Inhalt der Datei anhand der Dateinamenerweiterung. Eine Datei mit dem Namen "Form1.vb" möglicherweise z. B. keine Visual Basic 2005-Quelldatei.  
  
 Beim Lesen standard Zeichenfolgen- oder numerische Daten ohne Änderung Variablen zugewiesen werden. Die folgende Tabelle verdeutlicht, wie die Eingabedaten behandelt werden.  
  
|Daten|Variablen zugewiesenen Wert|  
|-|-|  
|Komma oder Leerzeile begrenzen|Empty|  
|#NULL #|`DBNull`|  
|#TRUE # "oder" #FALSE #|`True` oder `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Das Datum und/oder eine Uhrzeit, die durch den Ausdruck dargestellt wird.|  
|#ERROR `errornumber`#|`errornumber` (Variable ist ein Objekt, das als Fehler gekennzeichnet)|  
  
 Wenn das Ende der Datei wird erreicht, während Sie eines Datenelements, die Eingabe wird beendet und ein Fehler auftritt.  
  
> [!NOTE]
>  Die `Input` Funktion ist nicht lokalisiert. Z. B. wenn eingegebene 3,14159, in der deutschen Version wird nur 3 zurückgegeben, da das Komma als Trennzeichen Variablen statt als Dezimaltrennzeichen behandelt wird.  
  
> [!IMPORTANT]
>  Lesen aus einer Datei mithilfe der `Input` -Funktion erfordert `Read` aus Zugriff auf die `FileIOPermissionAccess` Enumeration. Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `Input` Funktion zum Lesen von Daten aus einer Datei in zwei Variablen. In diesem Beispiel wird vorausgesetzt, dass `TestFile` ist eine Datei, die mehrere Zeilen mit Daten, die Sie mithilfe von geschrieben hat die `Write` -Funktion, jede Zeile mit einer Zeichenfolge in Anführungszeichen und eine Zahl, die durch Kommas getrennt ein, z. B.: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref string Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, string&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::String ^ % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Variable that is assigned the values read from the file—cannot be an array or object variable.</param>
        <summary>Reads data from an open sequential file and assigns the data to variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Input` Funktion wird für Abwärtskompatibilität angeboten und die Leistung beeinträchtigen. Für nicht-Legacyanwendungen der `My.Computer.FileSystem` Objekt bietet eine bessere Leistung. Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Datenlesevorgänge mit `Input` in der Regel in eine Datei geschrieben wird, mithilfe von `Write`. Verwenden Sie diese Funktion nur mit geöffneten Dateien `Input` oder `Binary` Modus.  
  
> [!IMPORTANT]
>  Beim Lesen aus Dateien nicht Beurteilen der Inhalt der Datei anhand der Dateinamenerweiterung. Eine Datei mit dem Namen "Form1.vb" möglicherweise z. B. keine Visual Basic 2005-Quelldatei.  
  
 Beim Lesen standard Zeichenfolgen- oder numerische Daten ohne Änderung Variablen zugewiesen werden. Die folgende Tabelle verdeutlicht, wie die Eingabedaten behandelt werden.  
  
|Daten|Variablen zugewiesenen Wert|  
|-|-|  
|Komma oder Leerzeile begrenzen|Empty|  
|#NULL #|`DBNull`|  
|#TRUE # "oder" #FALSE #|`True` oder `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Das Datum und/oder eine Uhrzeit, die durch den Ausdruck dargestellt wird.|  
|#ERROR `errornumber`#|`errornumber` (Variable ist ein Objekt, das als Fehler gekennzeichnet)|  
  
 Wenn das Ende der Datei wird erreicht, während Sie eines Datenelements, die Eingabe wird beendet und ein Fehler auftritt.  
  
> [!NOTE]
>  Die `Input` Funktion ist nicht lokalisiert. Z. B. wenn eingegebene 3,14159, in der deutschen Version wird nur 3 zurückgegeben, da das Komma als Trennzeichen Variablen statt als Dezimaltrennzeichen behandelt wird.  
  
> [!IMPORTANT]
>  Lesen aus einer Datei mithilfe der `Input` -Funktion erfordert `Read` aus Zugriff auf die `FileIOPermissionAccess` Enumeration. Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `Input` Funktion zum Lesen von Daten aus einer Datei in zwei Variablen. In diesem Beispiel wird vorausgesetzt, dass `TestFile` ist eine Datei, die mehrere Zeilen mit Daten, die Sie mithilfe von geschrieben hat die `Write` -Funktion, jede Zeile mit einer Zeichenfolge in Anführungszeichen und eine Zahl, die durch Kommas getrennt ein, z. B.: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="InputString">
      <MemberSignature Language="C#" Value="public static string InputString (int FileNumber, int CharCount);" />
      <MemberSignature Language="ILAsm" Value=".method public static string InputString(int32 FileNumber, int32 CharCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function InputString (FileNumber As Integer, CharCount As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ InputString(int FileNumber, int CharCount);" />
      <MemberSignature Language="F#" Value="static member InputString : int * int -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.InputString (FileNumber, CharCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="CharCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="CharCount">Required. Any valid numeric expression specifying the number of characters to read.</param>
        <summary>Returns <see langword="String" /> value that contains characters from a file opened in <see langword="Input" /> or <see langword="Binary" /> mode. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="InputString" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <returns>Returns <see langword="String" /> value that contains characters from a file opened in <see langword="Input" /> or <see langword="Binary" /> mode. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="InputString" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `InputString` Funktion wird für Abwärtskompatibilität angeboten und die Leistung beeinträchtigen. Für nicht-Legacyanwendungen der `My.Computer.FileSystem` Objekt bietet eine bessere Leistung. Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Mit gelesenen Daten der `InputString` Funktion ist in der Regel in eine Datei geschrieben, mit `Print` oder `FilePut`. Verwenden Sie diese Funktion nur mit geöffneten Dateien `Input` oder `Binary` Modus.  
  
 Im Gegensatz zu den `Input` -Funktion, die `InputString` Funktion gibt alle Zeichen gelesen. Dies schließt Kommas, Wagenrückläufen, Zeilenvorschüben, Anführungszeichen und führende Leerzeichen.  
  
 Dateien für geöffnet `Binary` zugreifen, beim Lesen der Datei mithilfe der `InputString` Funktion bis `EOF` gibt `True` wird ein Fehler generiert. Verwenden Sie die `LOF` und `Loc` anstelle von Funktionen `EOF` beim Lesen von Binärdateien mit `InputString`, oder verwenden Sie `FileGet` bei Verwendung der `EOF` Funktion.  
  
> [!NOTE]
>  Beim Lesen aus Dateien, nehmen Sie keine sicherheitsrelevanten Aspekten der Inhalt der Datei anhand der Dateinamenerweiterung. Eine Datei namens "Form1.vb" möglicherweise z. B. keine Visual Basic-Quelldatei.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `InputString` Funktion, um Zeichen zu einem Zeitpunkt aus einer Datei gelesen und zum Drucken der `Output` Fenster. In diesem Beispiel wird vorausgesetzt, dass `MyFile` ist eine Textdatei, die mehrere mit Beispieldaten Zeilen.  
  
 [!code-vb[VbVbalrCatRef#33](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#33)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <paramref name="FileNumber" /> does not exist.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="CharCount" /> &lt; 0 or &gt; 214.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
      </Docs>
    </Member>
    <Member MemberName="Kill">
      <MemberSignature Language="C#" Value="public static void Kill (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Kill(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Kill (PathName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Kill(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member Kill : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Kill PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">Required. <see langword="String" /> expression that specifies one or more file names to be deleted. <c>PathName</c> can include the directory or folder, and the drive.</param>
        <summary>Deletes files from a disk. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Kill" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> .</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Kill` unterstützt die Verwendung von mehreren Zeichen (`*`) und ein einzelnes Zeichen (`?`) mit Platzhaltern für mehrere Dateien anzugeben.  
  
 **Sicherheitshinweis** zum Ausführen der `Kill` -Funktion erfordert `Read` und `PathDiscovery` des flags <xref:System.Security.Permissions.FileIOPermission> , die den Ausführungscode gewährt werden. Weitere Informationen finden Sie unter <xref:System.Security.SecurityException> [Codezugriffsberechtigungen](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `Kill` Funktion, um eine Datei von einem Datenträger zu löschen.  
  
 [!code-vb[VbVbalrCatRef#60](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#60)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Target file(s) open.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Target file(s) not found.</exception>
        <exception cref="T:System.Security.SecurityException">Permission denied.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <Member MemberName="LineInput">
      <MemberSignature Language="C#" Value="public static string LineInput (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static string LineInput(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.LineInput(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LineInput (FileNumber As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ LineInput(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member LineInput : int -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.LineInput FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <summary>Reads a single line from an open sequential file and assigns it to a <see langword="String" /> variable.</summary>
        <returns>Reads a single line from an open sequential file and assigns it to a <see langword="String" /> variable.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `LineInput` Funktion wird für Abwärtskompatibilität angeboten und die Leistung beeinträchtigen. Für nicht-Legacyanwendungen der `My.Computer.FileSystem` Objekt bietet eine bessere Leistung. Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Datenlesevorgänge mit `LineInput` in der Regel in eine Datei geschrieben wird, mithilfe von `Print`.  
  
> [!IMPORTANT]
>  Beim Lesen aus Dateien nicht Beurteilen der Inhalt einer Datei, die anhand der Dateinamenerweiterung. Eine Datei mit dem Namen "Form1.vb" möglicherweise z. B. nicht über ein Visual Basic-Quelldatei.  
  
 Die `LineInput` Funktion liest Zeichen aus einer Datei eine schrittweise, bis er erkennt, dass einen Wagenrücklauf (`Chr(13)`) oder Wagenrücklauf/Zeilenvorschub (`Chr(13) + Chr(10)`) Sequenz. Carriage Return/Line feed Sequenzen werden übersprungen und nicht auf die Zeichenfolge angefügt.  
  
> [!IMPORTANT]
>  Lesen aus einer Datei mithilfe der `LineInput` -Funktion erfordert `Read` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `LineInput` Funktion, um eine Zeile aus einer sequenziellen Datei gelesen und einer Variablen zuweisen. In diesem Beispiel wird vorausgesetzt, dass `TestFile` ist eine Textdatei, die mehrere mit Beispieldaten Zeilen.  
  
 [!code-vb[VbVbalrCatRef#19](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.EndOfStreamException">End of file reached.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="FileNumber" /> does not exist.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Strings.Chr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.ChrW(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
      </Docs>
    </Member>
    <Member MemberName="Loc">
      <MemberSignature Language="C#" Value="public static long Loc (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 Loc(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Loc (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Loc(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Loc : int -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.Loc FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid <see langword="Integer" /> file number.</param>
        <summary>Returns a <see langword="Long" /> value that specifies the current read/write position in an open file.</summary>
        <returns>Returns a <see langword="Long" /> value that specifies the current read/write position in an open file.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Loc` Funktion ist nullbasiert; verwenden, um das erste Byte in einer Datei abrufen, wird 0 zurückgegeben.  
  
 Die `Loc` Funktion wird für Abwärtskompatibilität angeboten und die Leistung beeinträchtigen. Für nicht-Legacyanwendungen der `My.Computer.FileSystem` Objekt bietet eine bessere Leistung. Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Nachfolgend wird den Rückgabewert für jede Dateizugriffsmodus beschrieben:  
  
|Modus|Rückgabewert|  
|-|-|  
|`Random`|Die Nummer des letzten Datensatzes lesen oder in die Datei geschrieben.|  
|`Sequential`|Aktuelle Byteposition in der Datei, geteilt durch 128. Zurückgegebene Informationen werden jedoch von `Loc` für sequenzielle Dateien ist weder verwendet noch benötigt.|  
|`Binary`|Die Position des letzten Bytes gelesen bzw. geschrieben werden.|  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `Loc` Funktion, um die aktuelle Lese-/Schreibposition in einer geöffneten Datei zurückzugeben. In diesem Beispiel wird vorausgesetzt, dass `MyFile` ist eine Textdatei, die mehrere mit Beispieldaten Zeilen.  
  
 [!code-vb[VbVbalrCatRef#17](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Lock">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Lock : int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Lock FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <summary>Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Lock` und `Unlock` Funktionen in Umgebungen verwendet werden, in denen mehrere Prozesse benötigen möglicherweise Zugriff auf die gleiche Datei.  
  
 `Lock` und `Unlock` Funktionen werden immer paarweise verwendet. Die Argumente für `Lock` und `Unlock` müssen identisch sein.  
  
 Wenn `Record`, oder `FromRecord` und `ToRecord` sind nicht angegeben wird, wird die Sperre für die gesamte Datei sein. Wenn `Record` allein entspricht der einzelne Datensatz gesperrt/entsperrt werden.  
  
 Wenn die Datei, für die sequenzielle Eingabe oder Ausgabe geöffnet wurde, `Lock` und `Unlock` Auswirkungen auf die gesamte Datei und unabhängig vom angegebenen Bereich `FromRecord` und`ToRecord`.  
  
   
  
## Examples  
 Dieses Beispiel veranschaulicht die Verwendung der `Lock` und `Unlock` Funktionen. In diesem Beispiel wird vorausgesetzt, dass `People.txt` ist eine Datei, die Datensätze der Struktur enthält `Person`.  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber, long Record);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber, int64 Record) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer, Record As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber, long Record);" />
      <MemberSignature Language="F#" Value="static member Lock : int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Lock (FileNumber, Record)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Record" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Record">Optional. Number of the only record or byte to lock or unlock</param>
        <summary>Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Lock` und `Unlock` Funktionen in Umgebungen verwendet werden, in denen mehrere Prozesse benötigen möglicherweise Zugriff auf die gleiche Datei.  
  
 `Lock` und `Unlock` Funktionen werden immer paarweise verwendet. Die Argumente für `Lock` und `Unlock` müssen identisch sein.  
  
 Wenn `Record`, oder `FromRecord` und `ToRecord` sind nicht angegeben wird, wird die Sperre für die gesamte Datei sein. Wenn `Record` allein entspricht der einzelne Datensatz gesperrt/entsperrt werden.  
  
 Wenn die Datei, für die sequenzielle Eingabe oder Ausgabe geöffnet wurde, `Lock` und `Unlock` Auswirkungen auf die gesamte Datei und unabhängig vom angegebenen Bereich `FromRecord` und`ToRecord`.  
  
   
  
## Examples  
 Dieses Beispiel veranschaulicht die Verwendung der `Lock` und `Unlock` Funktionen. In diesem Beispiel wird vorausgesetzt, dass `People.txt` ist eine Datei, die Datensätze der Struktur enthält `Person`.  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber, int64 FromRecord, int64 ToRecord) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer, FromRecord As Long, ToRecord As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="F#" Value="static member Lock : int * int64 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Lock (FileNumber, FromRecord, ToRecord)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FromRecord" Type="System.Int64" />
        <Parameter Name="ToRecord" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="FromRecord">Optional. Number of the first record or byte to lock or unlock.</param>
        <param name="ToRecord">Optional. Number of the last record or byte to lock or unlock.</param>
        <summary>Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Lock` und `Unlock` Funktionen in Umgebungen verwendet werden, in denen mehrere Prozesse benötigen möglicherweise Zugriff auf die gleiche Datei.  
  
 `Lock` und `Unlock` Funktionen werden immer paarweise verwendet. Die Argumente für `Lock` und `Unlock` müssen identisch sein.  
  
 Wenn `Record`, oder `FromRecord` und `ToRecord` sind nicht angegeben wird, wird die Sperre für die gesamte Datei sein. Wenn `Record` allein entspricht der einzelne Datensatz gesperrt/entsperrt werden.  
  
 Wenn die Datei, für die sequenzielle Eingabe oder Ausgabe geöffnet wurde, `Lock` und `Unlock` Auswirkungen auf die gesamte Datei und unabhängig vom angegebenen Bereich `FromRecord` und`ToRecord`.  
  
   
  
## Examples  
 Dieses Beispiel veranschaulicht die Verwendung der `Lock` und `Unlock` Funktionen. In diesem Beispiel wird vorausgesetzt, dass `People.txt` ist eine Datei, die Datensätze der Struktur enthält `Person`.  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="LOF">
      <MemberSignature Language="C#" Value="public static long LOF (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 LOF(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LOF (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long LOF(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member LOF : int -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.LOF FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. An <see langword="Integer" /> that contains a valid file number.</param>
        <summary>Returns a <see langword="Long" /> representing the size, in bytes, of a file opened by using the <see langword="FileOpen" /> function. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="LOF" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <returns>Returns a <see langword="Long" /> representing the size, in bytes, of a file opened by using the <see langword="FileOpen" /> function. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="LOF" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der `FileLen` Funktion, um die Länge einer Datei zu erhalten, die nicht geöffnet ist.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `LOF` -Funktion können Sie die Größe einer geöffneten Datei zu ermitteln. In diesem Beispiel wird vorausgesetzt, dass `TestFile` ist eine Textdatei, die Beispieldaten enthält.  
  
 [!code-vb[VbVbalrCatRef#23](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="MkDir">
      <MemberSignature Language="C#" Value="public static void MkDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void MkDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MkDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MkDir(System::String ^ Path);" />
      <MemberSignature Language="F#" Value="static member MkDir : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.MkDir Path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">Required. <see langword="String" /> expression that identifies the directory to be created. The <c>Path</c> may include the drive. If no drive is specified, <see langword="MkDir" /> creates the new directory on the current drive.</param>
        <summary>Creates a new directory. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="MkDir" />. For more information, see <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CreateDirectory(System.String)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Funktion wird ein neues Verzeichnis erstellt.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `MkDir` Funktion zum Erstellen eines Verzeichnisses. Wenn das Laufwerk nicht angegeben wird, wird das neue Verzeichnis auf das aktuelle Laufwerk erstellt.  
  
 [!code-vb[VbVbalrCatRef#38](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#38)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Path" /> is not specified or is empty.</exception>
        <exception cref="T:System.Security.SecurityException">Permission denied.</exception>
        <exception cref="T:System.IO.IOException">Directory already exists.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Print">
      <MemberSignature Language="C#" Value="public static void Print (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Print(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Print (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Print(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member Print : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Print (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Output">Optional. Zero or more comma-delimited expressions to write to a file.  The <c>Output</c> argument settings are:  <see langword="T:System.IO.IOException" />: File mode is invalid.  
  
 <see langword="T:System.IO.IOException" />: <c>FileNumber</c> does not exist.</param>
        <summary>Writes display-formatted data to a sequential file.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Print` und `PrintLine` Funktionen für Abwärtskompatibilität angeboten werden und die Leistung beeinträchtigen. Für nicht-Legacyanwendungen der `My.Computer.FileSystem` Objekt bietet eine bessere Leistung. Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 `Print` Schließt einen Zeilenvorschub am Ende einer Zeile nicht; allerdings `PrintLine` umfasst einen Zeilenvorschub.  
  
 Mit geschriebenen Daten `Print` in der Regel aus einer Datei lesen, mit `LineInput` oder `Input`.  
  
 Wenn Sie weglassen `Output` für `PrintLine`, eine leere Zeile wird ausgegeben, in der Datei; für `Print`, nichts wird ausgegeben. Mehrere Ausdrücke, die durch ein Komma voneinander getrennt werden so ausgerichtet, Registerkarte Grenzen, sondern mischen Kommas und `TAB` kann zu inkonsistente Ergebnissen führen.  
  
 Für `Boolean` Daten, entweder `True` oder `False` gedruckt wird. Die `True` und `False` Schlüsselwörter sind unabhängig vom Gebietsschema nicht übersetzt.  
  
 Datumsdaten werden in die Datei geschrieben, mit das standardmäßige kurze Datumsformat, die vom System erkannt wird. Wenn das Datum oder die Zeitkomponente fehlen oder gleich NULL, so wird nur der Teil werden in die Datei geschrieben.  
  
 Nichts in die Datei geschrieben wird, wenn `Output` Daten ist leer. Jedoch wenn `Output` Listendaten ist `DBNull`, `Null` in die Datei geschrieben wird.  
  
 Für `Error` Daten, die Ausgabe angezeigt wird, als `Error errorcode`. Die `Error` Schlüsselwort wird unabhängig vom Gebietsschema nicht übersetzt.  
  
 Alle Daten, die in die Datei geschrieben wird, mit `Print` ist Dezimaltrennzeichen; d. h. die Daten ist richtig formatiert mit entsprechenden Dezimaltrennzeichen. Wenn der Benutzer möchte Ausgabedaten für die Verwendung in mehreren Gebietsschemas `Write` verwendet werden soll.  
  
 Schreiben in eine Datei mithilfe der `Print` oder `PrintLine` Funktionen erfordert `Write` aus Zugriff auf die `FileIOPermissionAccess` Enumeration. Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `Print` und `PrintLine` Funktionen, um Daten in eine Datei schreiben.  
  
 [!code-vb[VbVbalrCatRef#53](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#53)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="PrintLine">
      <MemberSignature Language="C#" Value="public static void PrintLine (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void PrintLine(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub PrintLine (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PrintLine(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member PrintLine : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.PrintLine (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Output">Optional. Zero or more comma-delimited expressions to write to a file.  The <c>Output</c> argument settings are:  <see langword="T:System.IO.IOException" />: File mode is invalid.  
  
 <see langword="T:System.IO.IOException" />: <c>FileNumber</c> does not exist.</param>
        <summary>Writes display-formatted data to a sequential file.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Print` und `PrintLine` Funktionen für Abwärtskompatibilität angeboten werden und die Leistung beeinträchtigen. Für nicht-Legacyanwendungen der `My.Computer.FileSystem` Objekt bietet eine bessere Leistung. Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 `Print` Schließt einen Zeilenvorschub am Ende einer Zeile nicht; allerdings`PrintLine` umfasst einen Zeilenvorschub.  
  
 Mit geschriebenen Daten `Print` in der Regel aus einer Datei lesen, mit `LineInput` oder `Input`.  
  
 Wenn Sie weglassen `Output` für `PrintLine`, eine leere Zeile wird ausgegeben, in der Datei; für `Print`, nichts wird ausgegeben. Mehrere Ausdrücke, die durch ein Komma voneinander getrennt werden so ausgerichtet, Registerkarte Grenzen, sondern mischen Kommas und `TAB` kann zu inkonsistente Ergebnissen führen.  
  
 Für `Boolean` Daten, entweder `True` oder `False` gedruckt wird. Die `True` und `False` Schlüsselwörter sind unabhängig vom Gebietsschema nicht übersetzt.  
  
 Datumsdaten werden in die Datei geschrieben, mit das standardmäßige kurze Datumsformat vom System erkannt. Wenn das Datum oder die Zeitkomponente fehlen oder gleich NULL, so wird nur der Teil werden in die Datei geschrieben.  
  
 Nichts in die Datei geschrieben wird, wenn `Output` Daten ist leer. Jedoch wenn `Output` Listendaten ist `DBNull`, `Null` in die Datei geschrieben wird.  
  
 Für `Error` Daten, die Ausgabe angezeigt wird, als `Error errorcode`. Die `Error` Schlüsselwort wird unabhängig vom Gebietsschema nicht übersetzt.  
  
 Alle Daten, die in die Datei geschrieben wird, mit `Print` ist Dezimaltrennzeichen; d. h. die Daten ist richtig formatiert mit entsprechenden Dezimaltrennzeichen. Wenn der Benutzer möchte Ausgabedaten für die Verwendung in mehreren Gebietsschemas `Write` verwendet werden soll.  
  
 Schreiben in eine Datei mithilfe der `Print` oder `PrintLine` Funktionen erfordert `Write` aus Zugriff auf die `FileIOPermissionAccess` Enumeration. Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `Print` und `PrintLine` Funktionen, um Daten in eine Datei schreiben.  
  
 [!code-vb[VbVbalrCatRef#53](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#53)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Rename">
      <MemberSignature Language="C#" Value="public static void Rename (string OldPath, string NewPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Rename(string OldPath, string NewPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Rename (OldPath As String, NewPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Rename(System::String ^ OldPath, System::String ^ NewPath);" />
      <MemberSignature Language="F#" Value="static member Rename : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Rename (OldPath, NewPath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="OldPath" Type="System.String" />
        <Parameter Name="NewPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="OldPath">Required. <see langword="String" /> expression that specifies the existing file name and location. <c>OldPath</c> may include the directory, and drive, of the file.</param>
        <param name="NewPath">Required. <see langword="String" /> expression that specifies the new file name and location. <c>NewPath</c> may include directory and drive of the destination location. The file name specified by <c>NewPath</c> cannot already exist.</param>
        <summary>Renames a disk file or directory. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Rename" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die`Rename` Funktion benennt eine Datei und in ein anderes Verzeichnis verschoben, wenn es erforderlich ist. Die `Rename` Funktion kann eine Datei auf Laufwerken verschoben, aber es kann nur ein vorhandenes Verzeichnis umbenennen Wenn beide `NewPath` und `OldPath` auf dem gleichen Laufwerk befinden. `Rename` eine neue Datei oder ein Verzeichnis kann nicht erstellt werden.  
  
 Mithilfe der `Rename` Funktion in einer geöffneten Datei erzeugt einen Fehler. Sie müssen eine geöffnete Datei schließen, bevor Sie es umbenennen. `Rename` Argumente können nicht mehrere Zeichen (*) und Platzhalter für einzelne Zeichen (?) enthalten.  
  
> [!IMPORTANT]
>  Bei Verwendung `Rename` um eine Datei aus einem ungeschützten Speicherort auf einem geschützten Speicherort zu kopieren, die Datei behält die weniger eingeschränkten Berechtigungen. Stellen Sie sicher, dass Sie nicht über ein mögliches Sicherheitsrisiko entstehen.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `Rename` Funktion zum Umbenennen einer Datei. Für den Rahmen dieses Beispiels wird davon ausgegangen Sie, dass die Verzeichnisse, die bereits vorhanden sind.  
  
 [!code-vb[VbVbalrCatRef#30](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#30)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Path is invalid.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="OldPath" /> file does not exist.</exception>
        <exception cref="T:System.IO.IOException">Cannot rename to different device.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public static void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public static void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Reset();" />
      <MemberSignature Language="F#" Value="static member Reset : unit -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Closes all disk files opened by using the <see langword="FileOpen" /> function. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Reset" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Reset` -Funktion schließt alle aktive Dateien geöffnet, indem die `FileOpen` Funktion, und hat die gleiche Funktion wie `FileClose()` ohne Parameter.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `Reset` Funktion, um alle geöffneten Dateien geschlossen und der Inhalt aller Dateipuffer auf dem Datenträger festgeschrieben. Beachten Sie die Verwendung der `Object` Variable `FileNumber` als eine Zeichenfolge und eine Zahl.  
  
 [!code-vb[VbVbalrCatRef#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#12)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="RmDir">
      <MemberSignature Language="C#" Value="public static void RmDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void RmDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RmDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RmDir(System::String ^ Path);" />
      <MemberSignature Language="F#" Value="static member RmDir : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.RmDir Path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">Required. <see langword="String" /> expression that identifies the directory or folder to be removed. <c>Path</c> can include the drive. If no drive is specified, <see langword="RmDir" /> removes the directory on the current drive.</param>
        <summary>Removes an existing directory. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="RmDir" />. For more information, see <see cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Fehler auftritt, wenn Sie versuchen, `RmDir` in einem Verzeichnis, das Dateien enthält. Verwenden der `Kill` Funktion, um alle Dateien zu löschen, bevor Sie versuchen, ein Verzeichnis zu entfernen.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `RmDir` Funktion, um ein vorhandenes Verzeichnis zu entfernen.  
  
 [!code-vb[VbVbalrCatRef#31](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#31)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Path" /> is not specified or is empty.</exception>
        <exception cref="T:System.IO.IOException">Target directory contains files.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Directory does not exist.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Seek">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns a <see langword="Long" /> specifying the current read/write position in a file opened by using the <see langword="FileOpen" /> function, or sets the position for the next read/write operation in a file opened by using the <see langword="FileOpen" /> function. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Seek" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public static long Seek (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 Seek(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Seek (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Seek(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Seek : int -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.Seek FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. An <see langword="Integer" /> that contains a valid file number.</param>
        <summary>Returns a <see langword="Long" /> specifying the current read/write position in a file opened by using the <see langword="FileOpen" /> function, or sets the position for the next read/write operation in a file opened by using the <see langword="FileOpen" /> function. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Seek" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <returns>Returns a <see langword="Long" /> specifying the current read/write position in a file opened by using the <see langword="FileOpen" /> function, or sets the position for the next read/write operation in a file opened by using the <see langword="FileOpen" /> function.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Seek` Gibt einen Wert zwischen 1 und 2.147.483.647 (entspricht 2 ^ 31-1), inklusive.  
  
 Im folgenden werden die Rückgabewerte für jede Dateizugriffsmodus beschrieben:  
  
|Modus|Rückgabewert|  
|-|-|  
|`Random`|Nummer des nächsten Datensatzes gelesen bzw. geschrieben werden|  
|`Binary`, `Input`, `Output`, `Append`|Die Byteposition mit der nächste Vorgang auftritt. Das erste Byte in einer Datei befindet sich an Position 1, das zweite Byte an Position 2 usw. ist.|  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `Seek` Funktion, um die aktuelle Dateiposition zurückzugeben. Das Beispiel setzt voraus `TestFile` ist eine Datei, die Datensätze der Struktur enthält `Record`.  
  
 [!code-vb[VbVbalrCatRef#47](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#47)]  
  
 Für Dateien in geöffnet `Random` Modus `Seek` gibt die Anzahl des nächsten Datensatzes zurück.  
  
 [!code-vb[VbVbalrCatRef#48](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#48)]  
  
 Für Dateien, die nicht in den Modi geöffnet `Random` Modus `Seek` gibt die Byteposition mit der nächste Vorgang auftritt. Angenommen `TestFile` ist eine Datei, die mehrere Textzeilen enthält.  
  
 [!code-vb[VbVbalrCatRef#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#49)]  
  
 Dieses Beispiel verwendet die `Seek` Funktion, positionieren Sie die für den nächsten Lese- oder Schreibvorgang in einer Datei.  
  
 Für Dateien, die nicht in den Modi geöffnet `Random` Modus `Seek` legt die Byteposition mit der nächste Vorgang auftritt. Angenommen `TestFile` ist eine Datei, die mehrere Textzeilen enthält.  
  
 [!code-vb[VbVbalrCatRef#52](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public static void Seek (int FileNumber, long Position);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Seek(int32 FileNumber, int64 Position) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Seek (FileNumber As Integer, Position As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Seek(int FileNumber, long Position);" />
      <MemberSignature Language="F#" Value="static member Seek : int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Seek (FileNumber, Position)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Position" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. An <see langword="Integer" /> that contains a valid file number.</param>
        <param name="Position">Required. Number in the range 1–2,147,483,647, inclusive, that indicates where the next read/write operation should occur.</param>
        <summary>Returns a <see langword="Long" /> specifying the current read/write position in a file opened by using the <see langword="FileOpen" /> function, or sets the position for the next read/write operation in a file opened by using the <see langword="FileOpen" /> function. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Seek" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Seek` Gibt einen Wert zwischen 1 und 2.147.483.647 (entspricht 2 ^ 31-1), inklusive.  
  
 Im folgenden werden die Rückgabewerte für jede Dateizugriffsmodus beschrieben:  
  
|Modus|Rückgabewert|  
|-|-|  
|`Random`|Nummer des nächsten Datensatzes gelesen bzw. geschrieben werden|  
|`Binary`, `Input`, `Output`, `Append`|Die Byteposition mit der nächste Vorgang auftritt. Das erste Byte in einer Datei befindet sich an Position 1, das zweite Byte an Position 2 usw. ist.|  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `Seek` Funktion, um die aktuelle Dateiposition zurückzugeben. Das Beispiel setzt voraus `TestFile` ist eine Datei, die Datensätze der Struktur enthält `Record`.  
  
 [!code-vb[VbVbalrCatRef#47](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#47)]  
  
 Für Dateien in geöffnet `Random` Modus `Seek` gibt die Anzahl des nächsten Datensatzes zurück.  
  
 [!code-vb[VbVbalrCatRef#48](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#48)]  
  
 Für Dateien, die nicht in den Modi geöffnet `Random` Modus `Seek` gibt die Byteposition mit der nächste Vorgang auftritt. Angenommen `TestFile` ist eine Datei, die mehrere Textzeilen enthält.  
  
 [!code-vb[VbVbalrCatRef#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#49)]  
  
 Dieses Beispiel verwendet die `Seek` Funktion, positionieren Sie die für den nächsten Lese- oder Schreibvorgang in einer Datei.  
  
 Für Dateien, die nicht in den Modi geöffnet `Random` Modus `Seek` legt die Byteposition mit der nächste Vorgang auftritt. Angenommen `TestFile` ist eine Datei, die mehrere Textzeilen enthält.  
  
 [!code-vb[VbVbalrCatRef#52](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="SetAttr">
      <MemberSignature Language="C#" Value="public static void SetAttr (string PathName, Microsoft.VisualBasic.FileAttribute Attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static void SetAttr(string PathName, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAttr (PathName As String, Attributes As FileAttribute)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetAttr(System::String ^ PathName, Microsoft::VisualBasic::FileAttribute Attributes);" />
      <MemberSignature Language="F#" Value="static member SetAttr : string * Microsoft.VisualBasic.FileAttribute -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.SetAttr (PathName, Attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
        <Parameter Name="Attributes" Type="Microsoft.VisualBasic.FileAttribute" />
      </Parameters>
      <Docs>
        <param name="PathName">Required. <see langword="String" /> expression that specifies a file name. <c>PathName</c> can include directory or folder, and drive.</param>
        <param name="Attributes">Required. Constant or numeric expression, whose sum specifies file attributes.</param>
        <summary>Sets attribute information for a file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="SetAttr" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Laufzeitfehler tritt auf, wenn Sie versuchen, die Attribute einer geöffneten Datei festzulegen.  
  
 Die `Attributes` Argument Enumerationswerte sind wie folgt:  
  
|Wert|Konstante|Beschreibung|  
|-|-|-|  
|`Normal`|`vbNormal`|Normal (Standard).|  
|`ReadOnly`|`vbReadOnly`|Schreibgeschützt.|  
|`Hidden`|`vbHidden`|Ausgeblendet.|  
|`System`|`vbSystem`|Systemdatei.|  
|`Volume`|`vbVolume`|Volumebezeichnung|  
|`Directory`|`vbDirectory`|Verzeichnissen oder Ordnern.|  
|`Archive`|`vbArchive`|Datei wurde seit der letzten Sicherung geändert.|  
|`Alias`|`vbAlias`|Datei weist einen anderen Namen an.|  
  
> [!NOTE]
>  Diese Enumerationen werden von der Visual Basic-Sprache angegeben. Die Namen können überall im Code anstelle der eigentlichen Werte verwendet werden.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `SetAttr` Funktion, um Attribute für eine Datei festzulegen.  
  
 [!code-vb[VbVbalrCatRef#14](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Attribute" /> type is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />
      </Docs>
    </Member>
    <Member MemberName="SPC">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.SpcInfo SPC (short Count);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.SpcInfo SPC(int16 Count) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function SPC (Count As Short) As SpcInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::SpcInfo SPC(short Count);" />
      <MemberSignature Language="F#" Value="static member SPC : int16 -&gt; Microsoft.VisualBasic.SpcInfo" Usage="Microsoft.VisualBasic.FileSystem.SPC Count" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.SpcInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Count" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="Count">Required. The number of spaces to insert before displaying or printing the next expression in a list.</param>
        <summary>Used with the <see langword="Print" /> or <see langword="PrintLine" /> function to position output.</summary>
        <returns>Used with the <see langword="Print" /> or <see langword="PrintLine" /> function to position output.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `Count` ist kleiner als die Breite der Ausgabezeile, sofort der nächste drucken Position die Anzahl von Leerzeichen gedruckter folgt. Wenn`Count` ist größer als die Breite einer Ausgabezeile `SPC` wird die nächste drucken Position anhand der Formel berechnet:  
  
 `currentprintposition`(+(`Count``Mod``width`))  
  
 Beispielsweise ist die aktuelle Position 24, die Breite der Ausgabe beträgt 80, und geben Sie `SPC(90)`, beginnt die nächste Ausgabe an Position 34 (aktuelle drucken Position + die restliche 90/80). Wenn unterscheiden sich die aktuelle Position und die Breite der Ausgabe ist kleiner als `Count` (oder `Count` `Mod` *Breite*), wird die `SPC` Funktion am Anfang der nächsten Zeile übersprungen und generiert Leerzeichen gleich `Count` – (*Breite* – *aktuelleAusgabeposition*).  
  
> [!NOTE]
>  Stellen Sie sicher, dass die tabellarischen Spalten breit genug, um die Breite Buchstaben zu ermöglichen.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `SPC` Funktion zum Positionieren der Ausgabe in eine Datei und die **Ausgabe** Fenster.  
  
 [!code-vb[VbVbalrCatRef#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="TAB">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Used with the <see langword="Print" /> or <see langword="PrintLine" /> functions to position output.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TAB">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.TabInfo TAB ();" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.TabInfo TAB() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.TAB" />
      <MemberSignature Language="VB.NET" Value="Public Function TAB () As TabInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::TabInfo TAB();" />
      <MemberSignature Language="F#" Value="static member TAB : unit -&gt; Microsoft.VisualBasic.TabInfo" Usage="Microsoft.VisualBasic.FileSystem.TAB " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.TabInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Used with the <see langword="Print" /> or <see langword="PrintLine" /> functions to position output.</summary>
        <returns>Used with the <see langword="Print" /> or <see langword="PrintLine" /> functions to position output.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die aktuelle drucken Position in der aktuellen Zeile überschreitet `Column`, `TAB` springt zu der Spaltenwert gleich `Column` in der nächsten Ausgabezeile. Wenn `Column` ist kleiner als 1, `TAB` verschiebt die Position in Spalte 1. Wenn `Column` ist größer als die Breite einer Ausgabezeile `TAB` wird die nächste drucken Position anhand der Formel berechnet:  
  
 Mod Spaltenbreite  
  
 Z. B. wenn *Breite* beträgt 80, und geben Sie `TAB(90)`, beginnt die nächste Ausgabe in Spalte 10 (der Rest von 90/80). Wenn `Column` ist kleiner als die aktuelle Position drucken, beginnt die Ausgabe in der nächsten Zeile an der berechneten. Wenn die berechnete Position größer als die aktuelle Position ist, Drucken beginnt die Ausgabe an den berechneten Position in der gleichen Zeile.  
  
 Die am weitesten links stehende Position in einer Ausgabezeile ist immer 1. Bei Verwendung der `Print` oder `PrintLine` Funktionen zum Drucken auf Dateien, die äußersten rechten Position ist die aktuelle Breite der Ausgabedatei, die Sie festlegen können, mit der `FileWidth` Funktion.  
  
 Die `TAB` Funktion kann auch verwendet werden, mit der `WriteLine` Funktion. Es kann nicht verwendet werden, mit <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType> oder <xref:System.Console.WriteLine%2A?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Stellen Sie sicher, dass die tabellarischen Spalten breit genug, um die Breite Buchstaben enthalten.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `TAB` Funktion zum Positionieren der Ausgabe in eine Datei und die **Ausgabe** Fenster.  
  
 [!code-vb[VbVbalrCatRef#37](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#37)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="TAB">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.TabInfo TAB (short Column);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.TabInfo TAB(int16 Column) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.TAB(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function TAB (Column As Short) As TabInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::TabInfo TAB(short Column);" />
      <MemberSignature Language="F#" Value="static member TAB : int16 -&gt; Microsoft.VisualBasic.TabInfo" Usage="Microsoft.VisualBasic.FileSystem.TAB Column" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.TabInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Column" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="Column">Optional. The column number moved to before displaying or printing the next expression in a list. If omitted, <see langword="TAB" /> moves the insertion point to the start of the next print zone.</param>
        <summary>Used with the <see langword="Print" /> or <see langword="PrintLine" /> functions to position output.</summary>
        <returns>Used with the <see langword="Print" /> or <see langword="PrintLine" /> functions to position output.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die aktuelle drucken Position in der aktuellen Zeile größer ist `Column`, `TAB` springt zu der Spaltenwert gleich `Column` in der nächsten Ausgabezeile. Wenn `Column` ist kleiner als 1, `TAB` verschiebt die Position in Spalte 1. Wenn `Column` ist größer als die Breite einer Ausgabezeile `TAB` wird die nächste drucken Position anhand der Formel berechnet:  
  
 Mod Spaltenbreite  
  
 Z. B. wenn *Breite* beträgt 80, und geben Sie `TAB(90)`, beginnt die nächste Ausgabe in Spalte 10 (der Rest von 90/80). Wenn `Column` ist kleiner als die aktuelle Position drucken, beginnt die Ausgabe in der nächsten Zeile an der berechneten. Ist die berechnete Position größer als die aktuelle Position, Drucken beginnt die Ausgabe an den berechneten Position in der gleichen Zeile ein.  
  
 Die am weitesten links stehende Position in einer Ausgabezeile ist immer 1. Bei Verwendung der `Print` oder `PrintLine` Funktionen zum Drucken auf Dateien, die äußersten rechten Position ist die aktuelle Breite der Ausgabedatei, die Sie festlegen können, mit der `FileWidth` Funktion.  
  
 Die `TAB` Funktion kann auch verwendet werden, mit der `WriteLine` Funktion. Es kann nicht verwendet werden, mit <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType> oder <xref:System.Console.WriteLine%2A?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Stellen Sie sicher, dass die tabellarischen Spalten breit genug, um die Breite Buchstaben enthalten.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `TAB` Funktion zum Positionieren der Ausgabe in eine Datei und die **Ausgabe** Fenster.  
  
 [!code-vb[VbVbalrCatRef#37](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#37)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Unlock">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Unlock : int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Unlock FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <summary>Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Lock` und `Unlock` Funktionen in Umgebungen verwendet werden, in denen mehrere Prozesse benötigen möglicherweise Zugriff auf die gleiche Datei.  
  
 `Lock` und `Unlock` Funktionen werden immer paarweise verwendet. Die Argumente für `Lock` und `Unlock` müssen identisch sein.  
  
 Wenn `Record`, oder `FromRecord` und `ToRecord` sind nicht angegeben wird, wird die Sperre für die gesamte Datei sein. Wenn `Record` allein entspricht der einzelne Datensatz gesperrt/entsperrt werden.  
  
 Wenn die Datei, für die sequenzielle Eingabe oder Ausgabe geöffnet wurde, `Lock` und `Unlock` Auswirkungen auf die gesamte Datei und unabhängig vom angegebenen Bereich `FromRecord` und`ToRecord`.  
  
   
  
## Examples  
 Dieses Beispiel veranschaulicht die Verwendung der `Lock` und `Unlock` Funktionen. In diesem Beispiel wird vorausgesetzt, dass `People.txt` ist eine Datei, die Datensätze der Struktur enthält `Person`.  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber, long Record);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber, int64 Record) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer, Record As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber, long Record);" />
      <MemberSignature Language="F#" Value="static member Unlock : int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Unlock (FileNumber, Record)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Record" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Record">Optional. Number of the only record or byte to lock or unlock</param>
        <summary>Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Lock` und `Unlock` Funktionen in Umgebungen verwendet werden, in denen mehrere Prozesse benötigen möglicherweise Zugriff auf die gleiche Datei.  
  
 `Lock` und `Unlock` Funktionen werden immer paarweise verwendet. Die Argumente für `Lock` und `Unlock` müssen identisch sein.  
  
 Wenn `Record`, oder `FromRecord` und `ToRecord` sind nicht angegeben wird, wird die Sperre für die gesamte Datei sein. Wenn `Record` allein entspricht der einzelne Datensatz gesperrt/entsperrt werden.  
  
 Wenn die Datei, für die sequenzielle Eingabe oder Ausgabe geöffnet wurde, `Lock` und `Unlock` Auswirkungen auf die gesamte Datei und unabhängig vom angegebenen Bereich `FromRecord` und`ToRecord`.  
  
   
  
## Examples  
 Dieses Beispiel veranschaulicht die Verwendung der `Lock` und `Unlock` Funktionen. In diesem Beispiel wird vorausgesetzt, dass `People.txt` ist eine Datei, die Datensätze der Struktur enthält `Person`.  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber, int64 FromRecord, int64 ToRecord) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer, FromRecord As Long, ToRecord As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="F#" Value="static member Unlock : int * int64 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Unlock (FileNumber, FromRecord, ToRecord)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FromRecord" Type="System.Int64" />
        <Parameter Name="ToRecord" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="FromRecord">Optional. Number of the first record or byte to lock or unlock.</param>
        <param name="ToRecord">Optional. Number of the last record or byte to lock or unlock.</param>
        <summary>Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Lock` und `Unlock` Funktionen in Umgebungen verwendet werden, in denen mehrere Prozesse benötigen möglicherweise Zugriff auf die gleiche Datei.  
  
 `Lock` und `Unlock` Funktionen werden immer paarweise verwendet. Die Argumente für `Lock` und `Unlock` müssen identisch sein.  
  
 Wenn `Record`, oder `FromRecord` und `ToRecord` sind nicht angegeben wird, wird die Sperre für die gesamte Datei sein. Wenn `Record` allein entspricht der einzelne Datensatz gesperrt/entsperrt werden.  
  
 Wenn die Datei, für die sequenzielle Eingabe oder Ausgabe geöffnet wurde, `Lock` und `Unlock` Auswirkungen auf die gesamte Datei und unabhängig vom angegebenen Bereich `FromRecord` und`ToRecord`.  
  
   
  
## Examples  
 Dieses Beispiel veranschaulicht die Verwendung der `Lock` und `Unlock` Funktionen. In diesem Beispiel wird vorausgesetzt, dass `People.txt` ist eine Datei, die Datensätze der Struktur enthält `Person`.  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Write(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member Write : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Write (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. An <see langword="Integer" /> expression that contains any valid file number.</param>
        <param name="Output">Optional. One or more comma-delimited expressions to write to a file.</param>
        <summary>Writes data to a sequential file. Data written with <see langword="Write" /> is usually read from a file by using <see langword="Input" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Write` und `WriteLine` Funktionen für Abwärtskompatibilität angeboten werden und die Leistung beeinträchtigen. Für nicht-Legacyanwendungen der `My.Computer.FileSystem` Objekt bietet eine bessere Leistung. Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Wenn Sie weglassen `Output`, eine leere Zeile in die Datei ausgegeben. Mehrere Ausdrücke können durch ein Komma getrennt werden.  
  
 Im Gegensatz zu den `Print` -Funktion, die `Write` -Funktion fügt Kommas zwischen Elementen und Zeichenfolgen in Anführungszeichen ein, wie sie in die Datei geschrieben werden. Sie müssen keinen explizite Trennzeichen in der Liste zu platzieren. Wenn `Write` wird verwendet, um das Schreiben von Daten in eine Datei, die nur numerische `Boolean`, Date, Null, und `Error` Datenformate werden unterstützt. Die folgenden universellen Annahmen werden befolgt werden, damit die Daten immer lesen können, und unter Verwendung ordnungsgemäß interpretiert `Input`unabhängig vom Gebietsschema:  
  
-   Numerische Daten werden immer geschrieben mithilfe des Punkts als dezimales Trennzeichen.  
  
-   Für `Boolean` Daten, entweder `#TRUE#` oder `#FALSE#` gedruckt wird. Die `True` und `False` Schlüsselwörter sind unabhängig vom Gebietsschema nicht übersetzt.  
  
-   Datumsdaten werden in die Datei unter Verwendung des universellen Datumsformat geschrieben. Wenn das Datum oder die Zeitkomponente fehlen oder gleich NULL, so wird nur der Teil werden in die Datei geschrieben.  
  
-   Nichts in die Datei geschrieben wird, wenn `Output` Daten ist leer. Beachten Sie jedoch bei null-Daten `#NULL#` geschrieben wird.  
  
-   Für `Error` Daten, die Ausgabe angezeigt wird, als `#ERROR errorcode#`. Die `Error` Schlüsselwort wird unabhängig vom Gebietsschema nicht übersetzt.  
  
 `WriteLine` Fügt ein neue Zeilenumbruchzeichen (d. h. eine Carriage Return/Line feed, oder `Chr(13) + Chr(10)`), nachdem das letzte Zeichen im geschrieben wurde `Output` in die Datei.  
  
 Sie können die Anführungszeichen in einer Zeichenfolge einbetten, durch die Verwendung doppelter Anführungszeichen oder "". Ein auf ein Objekt angewendeter  
  
 [!code-vb[VbVbalrCatRef#63](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#63)]  
  
 Gibt eine Zeichenfolge mit dem Wert des `Double quotation marks aren't "difficult" to handle`.  
  
 Schreiben in eine Datei mithilfe der `Write` oder `WriteLine` Funktionen erfordert `Append` aus Zugriff auf die `FileIOPermissionAccess` Enumeration. Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `Write` Funktion, um Rohdaten in eine sequenzielle Datei schreiben.  
  
 [!code-vb[VbVbalrCatRef#64](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#64)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void WriteLine(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteLine (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member WriteLine : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.WriteLine (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. An <see langword="Integer" /> expression that contains any valid file number.</param>
        <param name="Output">Optional. One or more comma-delimited expressions to write to a file.</param>
        <summary>Writes data to a sequential file. Data written with <see langword="Write" /> is usually read from a file by using <see langword="Input" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Write` und `WriteLine` Funktionen für Abwärtskompatibilität angeboten werden und die Leistung beeinträchtigen. Für nicht-Legacyanwendungen der `My.Computer.FileSystem` Objekt bietet eine bessere Leistung. Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Wenn Sie weglassen `Output`, eine leere Zeile in die Datei ausgegeben. Mehrere Ausdrücke können durch ein Komma getrennt werden.  
  
 Im Gegensatz zu den `Print` -Funktion, die `Write` -Funktion fügt Kommas zwischen Elementen und Zeichenfolgen in Anführungszeichen ein, wie sie in die Datei geschrieben werden. Sie müssen keinen explizite Trennzeichen in der Liste zu platzieren. Wenn `Write` wird verwendet, um das Schreiben von Daten in eine Datei, die nur numerische `Boolean`, Date, Null, und `Error` Datenformate werden unterstützt. Die folgenden universellen Annahmen werden befolgt werden, damit die Daten immer lesen können, und unter Verwendung ordnungsgemäß interpretiert `Input`unabhängig vom Gebietsschema:  
  
-   Numerische Daten werden immer geschrieben mithilfe des Punkts als dezimales Trennzeichen.  
  
-   Für `Boolean` Daten, entweder `#TRUE#` oder `#FALSE#` gedruckt wird. Die `True` und `False` Schlüsselwörter sind unabhängig vom Gebietsschema nicht übersetzt.  
  
-   Datumsdaten werden in die Datei unter Verwendung des universellen Datumsformat geschrieben. Wenn das Datum oder die Zeitkomponente fehlen oder gleich NULL, so wird nur der Teil werden in die Datei geschrieben.  
  
-   Nichts in die Datei geschrieben wird, wenn `Output` Daten ist leer. Beachten Sie jedoch bei null-Daten `#NULL#` geschrieben wird.  
  
-   Für `Error` Daten, die Ausgabe angezeigt wird, als `#ERROR errorcode#`. Die `Error` Schlüsselwort wird unabhängig vom Gebietsschema nicht übersetzt.  
  
 `WriteLine` Fügt ein neue Zeilenumbruchzeichen (d. h. eine Carriage Return/Line feed, oder `Chr(13) + Chr(10)`), nachdem das letzte Zeichen im geschrieben wurde `Output` in die Datei.  
  
 Sie können die Anführungszeichen in einer Zeichenfolge einbetten, durch die Verwendung doppelter Anführungszeichen oder "". Ein auf ein Objekt angewendeter  
  
 [!code-vb[VbVbalrCatRef#63](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#63)]  
  
 Gibt eine Zeichenfolge mit dem Wert des `Double quotation marks aren't "difficult" to handle`.  
  
 Schreiben in eine Datei mithilfe der `Write` oder `WriteLine` Funktionen erfordert `Append` aus Zugriff auf die `FileIOPermissionAccess` Enumeration. Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `Write` Funktion, um Rohdaten in eine sequenzielle Datei schreiben.  
  
 [!code-vb[VbVbalrCatRef#64](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#64)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
  </Members>
</Type>