<Type Name="FileSystem" FullName="Microsoft.VisualBasic.FileSystem">
  <TypeSignature Language="C#" Value="public sealed class FileSystem" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit FileSystem extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.VisualBasic.FileSystem" />
  <TypeSignature Language="VB.NET" Value="Public Module FileSystem" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileSystem sealed" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic</AssemblyName>
    <AssemblyVersion>10.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>Microsoft.VisualBasic.CompilerServices.StandardModule</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Security.SecurityCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="d705e-101">Das <see langword="FileSystem" />-Modul enthält Prozeduren, mit denen Datei-, Verzeichnis- oder Ordner- und Systemoperationen ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="d705e-101">The <see langword="FileSystem" /> module contains the procedures that are used to perform file, directory or folder, and system operations.</span></span> <span data-ttu-id="d705e-102">Das <see langword="My" />-Feature ermöglicht bei Datei-E/A-Vorgängen höhere Produktivität und Leistung als bei Verwendung des <see langword="FileSystem" />-Moduls.</span><span class="sxs-lookup"><span data-stu-id="d705e-102">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than using the <see langword="FileSystem" /> module.</span></span> <span data-ttu-id="d705e-103">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-103">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d705e-104">Dieses Modul unterstützt die Visual Basic-Schlüsselwörter und Laufzeit-Bibliothekscode-Elemente, die Zugriff auf Dateien und Ordner.</span><span class="sxs-lookup"><span data-stu-id="d705e-104">This module supports the Visual Basic language keywords and run-time library members that access files and folders.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d705e-105">Dieses Beispiel verwendet die `GetAttr` -Funktion können Sie die Attribute einer Datei und das Verzeichnis oder die Ordner zu ermitteln.</span><span class="sxs-lookup"><span data-stu-id="d705e-105">This example uses the `GetAttr` function to determine the attributes of a file and directory or folder.</span></span>  
  
 [!code-vb[VbVbalrCatRef#25](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#25)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="ChDir">
      <MemberSignature Language="C#" Value="public static void ChDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDir(System::String ^ Path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path"><span data-ttu-id="d705e-106">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-106">Required.</span></span> <span data-ttu-id="d705e-107">Ein <see langword="String" />-Ausdruck, der das Verzeichnis oder den Ordner bezeichnet, der zum neuen Verzeichnis oder Ordner wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-107">A <see langword="String" /> expression that identifies which directory or folder becomes the new default directory or folder.</span></span> <span data-ttu-id="d705e-108"><c>Path</c> enthält möglicherweise das Laufwerk.</span><span class="sxs-lookup"><span data-stu-id="d705e-108"><c>Path</c> may include the drive.</span></span> <span data-ttu-id="d705e-109">Wenn kein Laufwerk angegeben wird, ändert <see langword="ChDir" /> das Standardverzeichnis oder den Ordner in das aktuelle Laufwerk.</span><span class="sxs-lookup"><span data-stu-id="d705e-109">If no drive is specified, <see langword="ChDir" /> changes the default directory or folder on the current drive.</span></span></param>
        <summary><span data-ttu-id="d705e-110">Ändert das aktuelle Verzeichnis oder den aktuellen Ordner.</span><span class="sxs-lookup"><span data-stu-id="d705e-110">Changes the current directory or folder.</span></span> <span data-ttu-id="d705e-111">Das <see langword="My" />-Feature ermöglicht bei Datei-E/A-Vorgängen eine höhere Produktivität und Leistung als die <see langword="ChDir" />-Funktion.</span><span class="sxs-lookup"><span data-stu-id="d705e-111">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than the <see langword="ChDir" /> function.</span></span> <span data-ttu-id="d705e-112">Weitere Informationen finden Sie unter <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-112">For more information, see <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" /> .</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d705e-113">Die `ChDir` -Funktion ändert das Standardverzeichnis, aber nicht das Standardlaufwerk.</span><span class="sxs-lookup"><span data-stu-id="d705e-113">The `ChDir` function changes the default directory, but not the default drive.</span></span> <span data-ttu-id="d705e-114">Beispielsweise ist das Standard-Laufwerk C, die folgende Anweisung ändert das Standardverzeichnis auf Laufwerk D, C, bleibt das Standardlaufwerk jedoch:</span><span class="sxs-lookup"><span data-stu-id="d705e-114">For example, if the default drive is C, the following statement changes the default directory on drive D, but C remains the default drive:</span></span>  
  
 [!code-vb[VbVbalrCatRef#39](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#39)]  
  
 <span data-ttu-id="d705e-115">Lassen Sie relative verzeichnisänderungen wird durch zwei Punkte wie folgt eingeben:</span><span class="sxs-lookup"><span data-stu-id="d705e-115">You can make relative directory changes is by typing two periods, as follows:</span></span>  
  
 [!code-vb[VbVbalrCatRef#40](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#40)]  
  
> [!IMPORTANT]
>  <span data-ttu-id="d705e-116">Die `ChDir` -Funktion erfordert die Berechtigung für nicht verwalteten Code, die die Ausführung in teilweise vertrauenswürdigen Umgebungen beeinträchtigen können.</span><span class="sxs-lookup"><span data-stu-id="d705e-116">The `ChDir` function requires unmanaged code permission, which may affect its execution in partial-trust situations.</span></span> <span data-ttu-id="d705e-117">Weitere Informationen finden Sie unter <xref:System.Security.Permissions.SecurityPermission> und.</span><span class="sxs-lookup"><span data-stu-id="d705e-117">For more information, see <xref:System.Security.Permissions.SecurityPermission> and .</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d705e-118">Dieses Beispiel verwendet die `ChDir` Funktion, um das aktuelle Verzeichnis oder einen Ordner zu ändern.</span><span class="sxs-lookup"><span data-stu-id="d705e-118">This example uses the `ChDir` function to change the current directory or folder.</span></span>  
  
 [!code-vb[VbVbalrCatRef#41](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="d705e-119"><paramref name="Path" /> ist leer.</span><span class="sxs-lookup"><span data-stu-id="d705e-119"><paramref name="Path" /> is empty.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="d705e-120">Angegebenes Laufwerk ungültig oder nicht verfügbar.</span><span class="sxs-lookup"><span data-stu-id="d705e-120">Invalid drive is specified, or drive is unavailable.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ChDrive">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d705e-121">Ändert das aktuelle Laufwerk.</span><span class="sxs-lookup"><span data-stu-id="d705e-121">Changes the current drive.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ChDrive">
      <MemberSignature Language="C#" Value="public static void ChDrive (char Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDrive(char Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDrive (Drive As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDrive(char Drive);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="Drive"><span data-ttu-id="d705e-122">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-122">Required.</span></span> <span data-ttu-id="d705e-123">Zeichenfolgenausdruck, der ein vorhandenes Laufwerk angibt.</span><span class="sxs-lookup"><span data-stu-id="d705e-123">String expression that specifies an existing drive.</span></span> <span data-ttu-id="d705e-124">Wenn Sie eine Zeichenfolge der Länge 0 (null) ("") angeben, ändert sich das aktuelle Laufwerk nicht.</span><span class="sxs-lookup"><span data-stu-id="d705e-124">If you supply a zero-length string (""), the current drive does not change.</span></span> <span data-ttu-id="d705e-125">Wenn das <c>Drive</c>-Argument eine Zeichenfolge mit mehreren Zeichen ist, verwendet <see langword="ChDrive" /> nur den ersten Buchstaben.</span><span class="sxs-lookup"><span data-stu-id="d705e-125">If the <c>Drive</c> argument is a multiple-character string, <see langword="ChDrive" /> uses only the first letter.</span></span></param>
        <summary><span data-ttu-id="d705e-126">Ändert das aktuelle Laufwerk.</span><span class="sxs-lookup"><span data-stu-id="d705e-126">Changes the current drive.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d705e-127">Die `ChDrive` -Funktion erfordert die Berechtigung nicht verwaltete Code sich möglicherweise auf ihre Ausführung in teilweise vertrauenswürdigen Umgebungen auswirken.</span><span class="sxs-lookup"><span data-stu-id="d705e-127">The `ChDrive` function requires unmanaged-code permission, which may affect its execution in partial-trust situations.</span></span> <span data-ttu-id="d705e-128">Weitere Informationen finden Sie unter <xref:System.Security.Permissions.SecurityPermission> und [Codezugriffsberechtigungen](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).</span><span class="sxs-lookup"><span data-stu-id="d705e-128">For more information, see <xref:System.Security.Permissions.SecurityPermission> and [Code Access Permissions](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d705e-129">Dieses Beispiel verwendet die `ChDrive` Funktion, um das aktuelle Laufwerk zu ändern.</span><span class="sxs-lookup"><span data-stu-id="d705e-129">This example uses the `ChDrive` function to change the current drive.</span></span> <span data-ttu-id="d705e-130">Die Funktion löst eine Ausnahme aus, wenn das Laufwerk nicht vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="d705e-130">The function throws an exception if the drive does not exist.</span></span>  
  
 [!code-vb[VbVbalrCatRef#32](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="d705e-131">Angegebenes Laufwerk ungültig oder nicht verfügbar.</span><span class="sxs-lookup"><span data-stu-id="d705e-131">Invalid drive is specified, or drive is unavailable.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="ChDrive">
      <MemberSignature Language="C#" Value="public static void ChDrive (string Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDrive(string Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDrive (Drive As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDrive(System::String ^ Drive);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Drive"><span data-ttu-id="d705e-132">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-132">Required.</span></span> <span data-ttu-id="d705e-133">Zeichenfolgenausdruck, der ein vorhandenes Laufwerk angibt.</span><span class="sxs-lookup"><span data-stu-id="d705e-133">String expression that specifies an existing drive.</span></span> <span data-ttu-id="d705e-134">Wenn Sie eine Zeichenfolge der Länge 0 (null) ("") angeben, ändert sich das aktuelle Laufwerk nicht.</span><span class="sxs-lookup"><span data-stu-id="d705e-134">If you supply a zero-length string (""), the current drive does not change.</span></span> <span data-ttu-id="d705e-135">Wenn das <c>Drive</c>-Argument eine Zeichenfolge mit mehreren Zeichen ist, verwendet <see langword="ChDrive" /> nur den ersten Buchstaben.</span><span class="sxs-lookup"><span data-stu-id="d705e-135">If the <c>Drive</c> argument is a multiple-character string, <see langword="ChDrive" /> uses only the first letter.</span></span></param>
        <summary><span data-ttu-id="d705e-136">Ändert das aktuelle Laufwerk.</span><span class="sxs-lookup"><span data-stu-id="d705e-136">Changes the current drive.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d705e-137">Die `ChDrive` -Funktion erfordert die Berechtigung nicht verwaltete Code sich möglicherweise auf ihre Ausführung in teilweise vertrauenswürdigen Umgebungen auswirken.</span><span class="sxs-lookup"><span data-stu-id="d705e-137">The `ChDrive` function requires unmanaged-code permission, which may affect its execution in partial-trust situations.</span></span> <span data-ttu-id="d705e-138">Weitere Informationen finden Sie unter <xref:System.Security.Permissions.SecurityPermission> und [Codezugriffsberechtigungen](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).</span><span class="sxs-lookup"><span data-stu-id="d705e-138">For more information, see <xref:System.Security.Permissions.SecurityPermission> and [Code Access Permissions](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d705e-139">Dieses Beispiel verwendet die `ChDrive` Funktion, um das aktuelle Laufwerk zu ändern.</span><span class="sxs-lookup"><span data-stu-id="d705e-139">This example uses the `ChDrive` function to change the current drive.</span></span> <span data-ttu-id="d705e-140">Die Funktion löst eine Ausnahme aus, wenn das Laufwerk nicht vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="d705e-140">The function throws an exception if the drive does not exist.</span></span>  
  
 [!code-vb[VbVbalrCatRef#32](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="d705e-141">Angegebenes Laufwerk ungültig oder nicht verfügbar.</span><span class="sxs-lookup"><span data-stu-id="d705e-141">Invalid drive is specified, or drive is unavailable.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CurDir">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d705e-142">Gibt eine Zeichenfolge mit dem aktuellen Pfad zurück.</span><span class="sxs-lookup"><span data-stu-id="d705e-142">Returns a string representing the current path.</span></span> <span data-ttu-id="d705e-143">Das <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> ermöglicht bei Datei-E/A-Vorgängen höhere Produktivität und Leistung als <see langword="CurDir" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-143">The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than <see langword="CurDir" />.</span></span> <span data-ttu-id="d705e-144">Weitere Informationen finden Sie unter <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-144">For more information, see <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CurDir">
      <MemberSignature Language="C#" Value="public static string CurDir ();" />
      <MemberSignature Language="ILAsm" Value=".method public static string CurDir() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.CurDir" />
      <MemberSignature Language="VB.NET" Value="Public Function CurDir () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CurDir();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d705e-145">Gibt eine Zeichenfolge mit dem aktuellen Pfad zurück.</span><span class="sxs-lookup"><span data-stu-id="d705e-145">Returns a string representing the current path.</span></span> <span data-ttu-id="d705e-146">Das <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> ermöglicht bei Datei-E/A-Vorgängen höhere Produktivität und Leistung als <see langword="CurDir" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-146">The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than <see langword="CurDir" />.</span></span> <span data-ttu-id="d705e-147">Weitere Informationen finden Sie unter <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-147">For more information, see <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</span></span></summary>
        <returns><span data-ttu-id="d705e-148">Eine Zeichenfolge mit dem aktuellen Pfad.</span><span class="sxs-lookup"><span data-stu-id="d705e-148">A string representing the current path.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="d705e-149">Dieses Beispiel verwendet die `CurDir` Funktion, um den aktuellen Pfad zurückzugeben.</span><span class="sxs-lookup"><span data-stu-id="d705e-149">This example uses the `CurDir` function to return the current path.</span></span>  
  
 [!code-vb[VbVbalrCatRef#65](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#65)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <Member MemberName="CurDir">
      <MemberSignature Language="C#" Value="public static string CurDir (char Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static string CurDir(char Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.CurDir(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function CurDir (Drive As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CurDir(char Drive);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="Drive"><span data-ttu-id="d705e-150">Dies ist optional.</span><span class="sxs-lookup"><span data-stu-id="d705e-150">Optional.</span></span> <span data-ttu-id="d705e-151">Ein <see langword="Char" />-Ausdruck, der ein vorhandenes Laufwerk angibt.</span><span class="sxs-lookup"><span data-stu-id="d705e-151"><see langword="Char" /> expression that specifies an existing drive.</span></span> <span data-ttu-id="d705e-152">Wenn kein Laufwerk angegeben wird oder <c>Drive</c> eine Zeichenfolgen der Länge 0 (null) ("") ist, gibt <see langword="CurDir" /> den Pfad für das aktuelle Laufwerk zurück.</span><span class="sxs-lookup"><span data-stu-id="d705e-152">If no drive is specified, or if <c>Drive</c> is a zero-length string (""), <see langword="CurDir" /> returns the path for the current drive.</span></span></param>
        <summary><span data-ttu-id="d705e-153">Gibt eine Zeichenfolge mit dem aktuellen Pfad zurück.</span><span class="sxs-lookup"><span data-stu-id="d705e-153">Returns a string representing the current path.</span></span> <span data-ttu-id="d705e-154">Das <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> ermöglicht bei Datei-E/A-Vorgängen höhere Produktivität und Leistung als <see langword="CurDir" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-154">The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than <see langword="CurDir" />.</span></span> <span data-ttu-id="d705e-155">Weitere Informationen finden Sie unter <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-155">For more information, see <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</span></span></summary>
        <returns><span data-ttu-id="d705e-156">Eine Zeichenfolge mit dem aktuellen Pfad.</span><span class="sxs-lookup"><span data-stu-id="d705e-156">A string representing the current path.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="d705e-157">Dieses Beispiel verwendet die `CurDir` Funktion, um den aktuellen Pfad zurückzugeben.</span><span class="sxs-lookup"><span data-stu-id="d705e-157">This example uses the `CurDir` function to return the current path.</span></span>  
  
 [!code-vb[VbVbalrCatRef#65](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#65)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dir">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d705e-158">Gibt eine Zeichenfolge zurück, die den Namen einer Datei, eines Verzeichnisses oder eines Ordners darstellt, der einem bestimmten Muster oder Dateiattribut oder der Volumebezeichnung eines Laufwerks entspricht.</span><span class="sxs-lookup"><span data-stu-id="d705e-158">Returns a string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive.</span></span> <span data-ttu-id="d705e-159">Das <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> ermöglicht bei Datei-E/A-Vorgängen höhere Produktivität und Leistung als die <see langword="Dir" />-Funktion.</span><span class="sxs-lookup"><span data-stu-id="d705e-159">The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than the <see langword="Dir" /> function.</span></span> <span data-ttu-id="d705e-160">Weitere Informationen finden Sie unter <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-160">See <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" /> for more information.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dir">
      <MemberSignature Language="C#" Value="public static string Dir ();" />
      <MemberSignature Language="ILAsm" Value=".method public static string Dir() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Dir" />
      <MemberSignature Language="VB.NET" Value="Public Function Dir () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Dir();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d705e-161">Gibt eine Zeichenfolge zurück, die den Namen einer Datei, eines Verzeichnisses oder eines Ordners darstellt, der einem bestimmten Muster oder Dateiattribut oder der Volumebezeichnung eines Laufwerks entspricht.</span><span class="sxs-lookup"><span data-stu-id="d705e-161">Returns a string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive.</span></span> <span data-ttu-id="d705e-162">Das <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> ermöglicht bei Datei-E/A-Vorgängen höhere Produktivität und Leistung als die <see langword="Dir" />-Funktion.</span><span class="sxs-lookup"><span data-stu-id="d705e-162">The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than the <see langword="Dir" /> function.</span></span> <span data-ttu-id="d705e-163">Weitere Informationen finden Sie unter <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-163">See <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" /> for more information.</span></span></summary>
        <returns><span data-ttu-id="d705e-164">Eine Zeichenfolge, die den Namen einer Datei, eines Verzeichnisses oder eines Ordners darstellt, der einem bestimmten Muster oder Dateiattribut oder der Volumebezeichnung eines Laufwerks entspricht.</span><span class="sxs-lookup"><span data-stu-id="d705e-164">A string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d705e-165">Die `Dir` Funktion unterstützt die Verwendung von mehreren Zeichen (`*`) und ein einzelnes Zeichen (`?`) mit Platzhaltern für mehrere Dateien anzugeben.</span><span class="sxs-lookup"><span data-stu-id="d705e-165">The `Dir` function supports the use of multiple-character (`*`) and single-character (`?`) wildcards to specify multiple files.</span></span>  
  
 <span data-ttu-id="d705e-166">`VbVolume` Gibt die Volumebezeichnung für das Laufwerk anstelle von einem bestimmten Dateinamen zurück.</span><span class="sxs-lookup"><span data-stu-id="d705e-166">`VbVolume` returns the volume label for the drive instead of a specific file name.</span></span>  
  
 <span data-ttu-id="d705e-167">Geben Sie an einer `PathName` erstmalig, die Sie Aufrufen der `Dir` Funktion.</span><span class="sxs-lookup"><span data-stu-id="d705e-167">You must supply a `PathName` the first time that you call the `Dir` function.</span></span> <span data-ttu-id="d705e-168">Um das nächste Element abzurufen, können Sie aufeinander folgende Aufrufe vorzunehmen die `Dir` Funktion ohne Parameter.</span><span class="sxs-lookup"><span data-stu-id="d705e-168">To retrieve the next item, you can make subsequent calls to the `Dir` function without parameters.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="d705e-169">Ordnungsgemäß ausgeführt. die `Dir` -Funktion erfordert die <xref:System.Security.Permissions.FileIOPermissionAccess.Read> und <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery> des flags <xref:System.Security.Permissions.FileIOPermission> , die den Ausführungscode gewährt werden.</span><span class="sxs-lookup"><span data-stu-id="d705e-169">To run correctly, the `Dir` function requires the <xref:System.Security.Permissions.FileIOPermissionAccess.Read> and <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery> flags of <xref:System.Security.Permissions.FileIOPermission> to be granted to the executing code.</span></span> <span data-ttu-id="d705e-170">Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermission>, <xref:System.Security.SecurityException>, und [Codezugriffsberechtigungen](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).</span><span class="sxs-lookup"><span data-stu-id="d705e-170">For more information, see <xref:System.Security.Permissions.FileIOPermission>, <xref:System.Security.SecurityException>, and [Code Access Permissions](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).</span></span>  
  
 <span data-ttu-id="d705e-171">Die `Attributes` Argument Enumerationswerte sind wie folgt:</span><span class="sxs-lookup"><span data-stu-id="d705e-171">The `Attributes` argument enumeration values are as follows:</span></span>  
  
|<span data-ttu-id="d705e-172">Wert</span><span class="sxs-lookup"><span data-stu-id="d705e-172">Value</span></span>|<span data-ttu-id="d705e-173">Konstante</span><span class="sxs-lookup"><span data-stu-id="d705e-173">Constant</span></span>|<span data-ttu-id="d705e-174">Beschreibung </span><span class="sxs-lookup"><span data-stu-id="d705e-174">Description</span></span>|  
|-|-|-|  
|`Normal`|`vbnormal`|<span data-ttu-id="d705e-175">Standard.</span><span class="sxs-lookup"><span data-stu-id="d705e-175">Default.</span></span> <span data-ttu-id="d705e-176">Gibt Dateien ohne Attribute an.</span><span class="sxs-lookup"><span data-stu-id="d705e-176">Specifies files without attributes.</span></span>|  
|`ReadOnly`|`vbReadOnly`|<span data-ttu-id="d705e-177">Gibt an, schreibgeschützte Dateien sowie Dateien ohne Attribute.</span><span class="sxs-lookup"><span data-stu-id="d705e-177">Specifies read-only files, and also files without attributes.</span></span>|  
|`Hidden`|`vbHidden`|<span data-ttu-id="d705e-178">Gibt an, ausgeblendete Dateien sowie Dateien ohne Attribute.</span><span class="sxs-lookup"><span data-stu-id="d705e-178">Specifies hidden files, and also files without attributes.</span></span>|  
|`System`|`vbSystem`|<span data-ttu-id="d705e-179">Gibt an, das Systemdateien und auch Dateien ohne Attribute.</span><span class="sxs-lookup"><span data-stu-id="d705e-179">Specifies system files, and also files without attributes.</span></span>|  
|`Volume`|`vbVolume`|<span data-ttu-id="d705e-180">Gibt die Volumebezeichnung. Wenn andere Attribute angegeben wird, `vbVolume` wird ignoriert.</span><span class="sxs-lookup"><span data-stu-id="d705e-180">Specifies volume label; if any other attribute is specified, `vbVolume` is ignored.</span></span>|  
|`Directory`|`vbDirectory`|<span data-ttu-id="d705e-181">Gibt an, Verzeichnissen oder Ordnern sowie Dateien ohne Attribute.</span><span class="sxs-lookup"><span data-stu-id="d705e-181">Specifies directories or folders, and also files without attributes.</span></span>|  
|`Archive`|`vbArchive`|<span data-ttu-id="d705e-182">Die Datei wurde nach der letzten Sicherung geändert.</span><span class="sxs-lookup"><span data-stu-id="d705e-182">File has changed since last backup.</span></span>|  
|`Alias`|`vbAlias`|<span data-ttu-id="d705e-183">Die Datei hat einen anderen Namen.</span><span class="sxs-lookup"><span data-stu-id="d705e-183">File has a different name.</span></span>|  
  
> [!NOTE]
>  <span data-ttu-id="d705e-184">Diese Enumerationen werden von der Visual Basic-Sprache angegeben und können überall im Code anstelle der eigentlichen Werte verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="d705e-184">These enumerations are specified by the Visual Basic language and can be used anywhere in your code instead of the actual values.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d705e-185">Dieses Beispiel verwendet die `Dir` Funktion zum Überprüfen, ob bestimmte Dateien und Verzeichnisse vorhanden sind.</span><span class="sxs-lookup"><span data-stu-id="d705e-185">This example uses the `Dir` function to check if certain files and directories exist.</span></span>  
  
 [!code-vb[VbVbalrCatRef#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Dir">
      <MemberSignature Language="C#" Value="public static string Dir (string PathName, Microsoft.VisualBasic.FileAttribute Attributes = Microsoft.VisualBasic.FileAttribute.Normal);" />
      <MemberSignature Language="ILAsm" Value=".method public static string Dir(string PathName, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)" />
      <MemberSignature Language="VB.NET" Value="Public Function Dir (PathName As String, Optional Attributes As FileAttribute = Microsoft.VisualBasic.FileAttribute.Normal) As String" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
        <Parameter Name="Attributes" Type="Microsoft.VisualBasic.FileAttribute" />
      </Parameters>
      <Docs>
        <param name="PathName"><span data-ttu-id="d705e-186">Dies ist optional.</span><span class="sxs-lookup"><span data-stu-id="d705e-186">Optional.</span></span> <span data-ttu-id="d705e-187"><see langword="String" />-Ausdruck, der einen Dateinamen, ein Verzeichnis, einen Ordnernamen oder eine Volumebezeichnung des Laufwerks angibt.</span><span class="sxs-lookup"><span data-stu-id="d705e-187"><see langword="String" /> expression that specifies a file name, directory or folder name, or drive volume label.</span></span> <span data-ttu-id="d705e-188">Eine Zeichenfolge der Länge 0 (null) (<see langword="&quot;&quot;" />) wird zurückgegeben, wenn <c>PathName</c> nicht gefunden wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-188">A zero-length string (<see langword="&quot;&quot;" />) is returned if <c>PathName</c> is not found.</span></span></param>
        <param name="Attributes"><span data-ttu-id="d705e-189">Dies ist optional.</span><span class="sxs-lookup"><span data-stu-id="d705e-189">Optional.</span></span> <span data-ttu-id="d705e-190">Enumeration oder numerischer Ausdruck, dessen Wert Dateiattribute angibt.</span><span class="sxs-lookup"><span data-stu-id="d705e-190">Enumeration or numeric expression whose value specifies file attributes.</span></span> <span data-ttu-id="d705e-191">Wenn der Wert nicht angegeben wird, gibt <see langword="Dir" /> Dateien zurück, die mit <c>PathName</c> übereinstimmen, aber keine Attribute besitzen.</span><span class="sxs-lookup"><span data-stu-id="d705e-191">If omitted, <see langword="Dir" /> returns files that match <c>PathName</c> but have no attributes.</span></span></param>
        <summary><span data-ttu-id="d705e-192">Gibt eine Zeichenfolge zurück, die den Namen einer Datei, eines Verzeichnisses oder eines Ordners darstellt, der einem bestimmten Muster oder Dateiattribut oder der Volumebezeichnung eines Laufwerks entspricht.</span><span class="sxs-lookup"><span data-stu-id="d705e-192">Returns a string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive.</span></span> <span data-ttu-id="d705e-193">Das <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> ermöglicht bei Datei-E/A-Vorgängen höhere Produktivität und Leistung als die <see langword="Dir" />-Funktion.</span><span class="sxs-lookup"><span data-stu-id="d705e-193">The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than the <see langword="Dir" /> function.</span></span> <span data-ttu-id="d705e-194">Weitere Informationen finden Sie unter <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-194">See <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" /> for more information.</span></span></summary>
        <returns><span data-ttu-id="d705e-195">Eine Zeichenfolge, die den Namen einer Datei, eines Verzeichnisses oder eines Ordners darstellt, der einem bestimmten Muster oder Dateiattribut oder der Volumebezeichnung eines Laufwerks entspricht.</span><span class="sxs-lookup"><span data-stu-id="d705e-195">A string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d705e-196">Die `Dir` Funktion unterstützt die Verwendung von mehreren Zeichen (`*`) und ein einzelnes Zeichen (`?`) mit Platzhaltern für mehrere Dateien anzugeben.</span><span class="sxs-lookup"><span data-stu-id="d705e-196">The `Dir` function supports the use of multiple-character (`*`) and single-character (`?`) wildcards to specify multiple files.</span></span>  
  
 <span data-ttu-id="d705e-197">`VbVolume` Gibt die Volumebezeichnung für das Laufwerk anstelle von einem bestimmten Dateinamen zurück.</span><span class="sxs-lookup"><span data-stu-id="d705e-197">`VbVolume` returns the volume label for the drive instead of a specific file name.</span></span>  
  
 <span data-ttu-id="d705e-198">Geben Sie an einer `PathName` erstmalig, die Sie Aufrufen der `Dir` Funktion.</span><span class="sxs-lookup"><span data-stu-id="d705e-198">You must supply a `PathName` the first time that you call the `Dir` function.</span></span> <span data-ttu-id="d705e-199">Um das nächste Element abzurufen, können Sie aufeinander folgende Aufrufe vorzunehmen die `Dir` Funktion ohne Parameter.</span><span class="sxs-lookup"><span data-stu-id="d705e-199">To retrieve the next item, you can make subsequent calls to the `Dir` function with no parameters.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="d705e-200">Ordnungsgemäß ausgeführt. die `Dir` -Funktion erfordert die <xref:System.Security.Permissions.FileIOPermissionAccess.Read> und <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery> des flags <xref:System.Security.Permissions.FileIOPermission> , die den Ausführungscode gewährt werden.</span><span class="sxs-lookup"><span data-stu-id="d705e-200">To run correctly, the `Dir` function requires the <xref:System.Security.Permissions.FileIOPermissionAccess.Read> and <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery> flags of <xref:System.Security.Permissions.FileIOPermission> to be granted to the executing code.</span></span> <span data-ttu-id="d705e-201">Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermission>, <xref:System.Security.SecurityException>, und [Codezugriffsberechtigungen](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).</span><span class="sxs-lookup"><span data-stu-id="d705e-201">For more information, see <xref:System.Security.Permissions.FileIOPermission>, <xref:System.Security.SecurityException>, and [Code Access Permissions](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).</span></span>  
  
 <span data-ttu-id="d705e-202">Die `Attributes` Argument Enumerationswerte sind wie folgt:</span><span class="sxs-lookup"><span data-stu-id="d705e-202">The `Attributes` argument enumeration values are as follows:</span></span>  
  
|<span data-ttu-id="d705e-203">Wert</span><span class="sxs-lookup"><span data-stu-id="d705e-203">Value</span></span>|<span data-ttu-id="d705e-204">Konstante</span><span class="sxs-lookup"><span data-stu-id="d705e-204">Constant</span></span>|<span data-ttu-id="d705e-205">Beschreibung </span><span class="sxs-lookup"><span data-stu-id="d705e-205">Description</span></span>|  
|-|-|-|  
|`Normal`|`vbnormal`|<span data-ttu-id="d705e-206">Standard.</span><span class="sxs-lookup"><span data-stu-id="d705e-206">Default.</span></span> <span data-ttu-id="d705e-207">Gibt die Dateien, die keine Attribute aufweisen.</span><span class="sxs-lookup"><span data-stu-id="d705e-207">Specifies files that have no attributes.</span></span>|  
|`ReadOnly`|`vbReadOnly`|<span data-ttu-id="d705e-208">Gibt schreibgeschützte Dateien zusätzlich zu Dateien, die keine Attribute aufweisen.</span><span class="sxs-lookup"><span data-stu-id="d705e-208">Specifies read-only files, in addition to files that have no attributes.</span></span>|  
|`Hidden`|`vbHidden`|<span data-ttu-id="d705e-209">Gibt versteckte Dateien zusätzlich zu Dateien, die keine Attribute aufweisen.</span><span class="sxs-lookup"><span data-stu-id="d705e-209">Specifies hidden files, in addition to files that have no attributes.</span></span>|  
|`System`|`vbSystem`|<span data-ttu-id="d705e-210">Gibt die Systemdateien, zusätzlich zu Dateien, die keine Attribute aufweisen.</span><span class="sxs-lookup"><span data-stu-id="d705e-210">Specifies system files, in addition to files that have no attributes.</span></span>|  
|`Volume`|`vbVolume`|<span data-ttu-id="d705e-211">Gibt die Volumebezeichnung. Wenn andere Attribute angegeben wird, `vbVolume` wird ignoriert.</span><span class="sxs-lookup"><span data-stu-id="d705e-211">Specifies volume label; if any other attribute is specified, `vbVolume` is ignored.</span></span>|  
|`Directory`|`vbDirectory`|<span data-ttu-id="d705e-212">Gibt an, Verzeichnissen oder Ordnern, zusätzlich zu Dateien, die keine Attribute aufweisen.</span><span class="sxs-lookup"><span data-stu-id="d705e-212">Specifies directories or folders, in addition to files that have no attributes.</span></span>|  
|`Archive`|`vbArchive`|<span data-ttu-id="d705e-213">Die Datei wurde nach der letzten Sicherung geändert.</span><span class="sxs-lookup"><span data-stu-id="d705e-213">File has changed since last backup.</span></span>|  
|`Alias`|`vbAlias`|<span data-ttu-id="d705e-214">Die Datei hat einen anderen Namen.</span><span class="sxs-lookup"><span data-stu-id="d705e-214">File has a different name.</span></span>|  
  
> [!NOTE]
>  <span data-ttu-id="d705e-215">Diese Enumerationen werden von der Visual Basic-Sprache angegeben und können überall im Code anstelle der eigentlichen Werte verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="d705e-215">These enumerations are specified by the Visual Basic language and can be used anywhere in your code in place of the actual values.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d705e-216">Dieses Beispiel verwendet die `Dir` Funktion zum Überprüfen, ob bestimmte Dateien und Verzeichnisse vorhanden sind.</span><span class="sxs-lookup"><span data-stu-id="d705e-216">This example uses the `Dir` function to check if certain files and directories exist.</span></span>  
  
 [!code-vb[VbVbalrCatRef#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
      </Docs>
    </Member>
    <Member MemberName="EOF">
      <MemberSignature Language="C#" Value="public static bool EOF (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static bool EOF(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function EOF (FileNumber As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool EOF(int FileNumber);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="d705e-217">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-217">Required.</span></span> <span data-ttu-id="d705e-218">Ein <see langword="Integer" /> mit einer beliebigen gültigen Dateinummer.</span><span class="sxs-lookup"><span data-stu-id="d705e-218">An <see langword="Integer" /> that contains any valid file number.</span></span></param>
        <summary><span data-ttu-id="d705e-219">Gibt den booleschen Wert <see langword="True" /> zurück, wenn das Ende einer für <see langword="Random" />- oder sequenziellen <see langword="Input" />-Zugriff geöffneten Datei erreicht wurde.</span><span class="sxs-lookup"><span data-stu-id="d705e-219">Returns a Boolean value <see langword="True" /> when the end of a file opened for <see langword="Random" /> or sequential <see langword="Input" /> has been reached.</span></span></summary>
        <returns><span data-ttu-id="d705e-220">Gibt den booleschen Wert <see langword="True" /> zurück, wenn das Ende einer für <see langword="Random" />- oder sequenziellen <see langword="Input" />-Zugriff geöffneten Datei erreicht wurde.</span><span class="sxs-lookup"><span data-stu-id="d705e-220">Returns a Boolean value <see langword="True" /> when the end of a file opened for <see langword="Random" /> or sequential <see langword="Input" /> has been reached.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d705e-221">Verwendung `EOF` vermeiden Sie den Fehler generiert, wird versucht, die nach dem Ende einer Datei Eingabe abzurufen.</span><span class="sxs-lookup"><span data-stu-id="d705e-221">Use `EOF` to avoid the error generated by attempting to get input past the end of a file.</span></span>  
  
 <span data-ttu-id="d705e-222">Die `EOF` -Funktion gibt `False` fort, bis das Ende der Datei erreicht wurde.</span><span class="sxs-lookup"><span data-stu-id="d705e-222">The `EOF` function returns `False` until the end of the file has been reached.</span></span> <span data-ttu-id="d705e-223">Dateien für geöffnet `Random` oder `Binary` Zugriff `EOF` gibt `False` erst nach der Ausführung der letzten `FileGet` Funktion kann nicht zum Lesen der vollständigen Datensatzes.</span><span class="sxs-lookup"><span data-stu-id="d705e-223">With files opened for `Random` or `Binary` access, `EOF` returns `False` until the last executed `FileGet` function is unable to read a whole record.</span></span>  
  
 <span data-ttu-id="d705e-224">Dateien für geöffnet `Binary` zugreifen, beim Lesen der Datei mithilfe der `Input` Funktion bis `EOF` gibt `True` wird ein Fehler generiert.</span><span class="sxs-lookup"><span data-stu-id="d705e-224">With files opened for `Binary` access, an attempt to read through the file using the `Input` function until `EOF` returns `True` generates an error.</span></span> <span data-ttu-id="d705e-225">Verwenden Sie die `LOF` und `Loc` anstelle von Funktionen `EOF` beim Lesen von Binärdateien mit `Input`, oder verwenden Sie `Get` bei Verwendung der `EOF` Funktion.</span><span class="sxs-lookup"><span data-stu-id="d705e-225">Use the `LOF` and `Loc` functions instead of `EOF` when reading binary files with `Input`, or use `Get` when using the `EOF` function.</span></span> <span data-ttu-id="d705e-226">Dateien für geöffnet `Output`, `EOF` gibt immer `True`.</span><span class="sxs-lookup"><span data-stu-id="d705e-226">With files opened for `Output`, `EOF` always returns `True`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d705e-227">Dieses Beispiel verwendet die `EOF` Funktion, um das Ende einer Datei zu erkennen.</span><span class="sxs-lookup"><span data-stu-id="d705e-227">This example uses the `EOF` function to detect the end of a file.</span></span> <span data-ttu-id="d705e-228">In diesem Beispiel wird vorausgesetzt, dass `Testfile` ist eine Textdatei, die mehrere Textzeilen enthält.</span><span class="sxs-lookup"><span data-stu-id="d705e-228">This example assumes that `Testfile` is a text file that contains several lines of text.</span></span>  
  
 [!code-vb[VbVbalrCatRef#62](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#62)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="d705e-229">Dateimodus ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="d705e-229">File mode is invalid.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FileAttr">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.OpenMode FileAttr (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.OpenMode FileAttr(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileAttr (FileNumber As Integer) As OpenMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::OpenMode FileAttr(int FileNumber);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.OpenMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="d705e-230">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-230">Required.</span></span> <span data-ttu-id="d705e-231"><see langword="Integer" /></span><span class="sxs-lookup"><span data-stu-id="d705e-231"><see langword="Integer" />.</span></span> <span data-ttu-id="d705e-232">Eine beliebige gültige Dateinummer.</span><span class="sxs-lookup"><span data-stu-id="d705e-232">Any valid file number.</span></span></param>
        <summary><span data-ttu-id="d705e-233">Gibt eine Enumeration zurück, die den Dateimodus für Dateien darstellt, die mit der <see langword="FileOpen" />-Funktion geöffnet wurden.</span><span class="sxs-lookup"><span data-stu-id="d705e-233">Returns an enumeration representing the file mode for files opened using the <see langword="FileOpen" /> function.</span></span> <span data-ttu-id="d705e-234">Das <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> ermöglicht bei Datei-E/A-Vorgängen höhere Produktivität und Leistung als die <see langword="FileAttr" />-Funktion.</span><span class="sxs-lookup"><span data-stu-id="d705e-234">The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than the <see langword="FileAttr" /> function.</span></span> <span data-ttu-id="d705e-235">Weitere Informationen finden Sie unter <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-235">See <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" /> for more information.</span></span></summary>
        <returns><span data-ttu-id="d705e-236">Die folgenden Enumerationswerte geben den Dateizugriffsmodus an:</span><span class="sxs-lookup"><span data-stu-id="d705e-236">The following enumeration values indicate the file access mode:</span></span>  
  
 <span data-ttu-id="d705e-237"><list type="table"><item><term> Wert</span><span class="sxs-lookup"><span data-stu-id="d705e-237"><list type="table"><item><term> Value</span></span>  
  
 <span data-ttu-id="d705e-238"></term><description> Modus</span><span class="sxs-lookup"><span data-stu-id="d705e-238"></term><description> Mode</span></span>  
  
 <span data-ttu-id="d705e-239"></description></item><item><term> 1</span><span class="sxs-lookup"><span data-stu-id="d705e-239"></description></item><item><term> 1</span></span>  
  
 <span data-ttu-id="d705e-240"></term><description><see langword="OpenMode.Input" /></description></item><item><term> 2</span><span class="sxs-lookup"><span data-stu-id="d705e-240"></term><description><see langword="OpenMode.Input" /></description></item><item><term> 2</span></span>  
  
 <span data-ttu-id="d705e-241"></term><description><see langword="OpenMode.Output" /></description></item><item><term> 4</span><span class="sxs-lookup"><span data-stu-id="d705e-241"></term><description><see langword="OpenMode.Output" /></description></item><item><term> 4</span></span>  
  
 <span data-ttu-id="d705e-242"></term><description><see langword="OpenMode.Random" /></description></item><item><term> 8</span><span class="sxs-lookup"><span data-stu-id="d705e-242"></term><description><see langword="OpenMode.Random" /></description></item><item><term> 8</span></span>  
  
 <span data-ttu-id="d705e-243"></term><description><see langword="OpenMode.Append" /></description></item><item><term> 32</span><span class="sxs-lookup"><span data-stu-id="d705e-243"></term><description><see langword="OpenMode.Append" /></description></item><item><term> 32</span></span>  
  
 </term><description><see langword="OpenMode.Binary" /></description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d705e-244">Diese Funktion gibt eine Enumeration, die den Dateimodus mit geöffneten Dateien darstellt. die `FileOpen` Funktion.</span><span class="sxs-lookup"><span data-stu-id="d705e-244">This function returns an enumeration representing the file mode for files opened using the `FileOpen` function.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d705e-245">Dieses Beispiel verwendet die `FileAttr` Funktion, um den Dateimodus einer geöffneten Datei zurückzugeben.</span><span class="sxs-lookup"><span data-stu-id="d705e-245">This example uses the `FileAttr` function to return the file mode of an open file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#46](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#46)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FileClose">
      <MemberSignature Language="C#" Value="public static void FileClose (params int[] FileNumbers);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileClose(int32[] FileNumbers) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileClose (ParamArray FileNumbers As Integer())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileClose(... cli::array &lt;int&gt; ^ FileNumbers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumbers" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumbers"><span data-ttu-id="d705e-246">Dies ist optional.</span><span class="sxs-lookup"><span data-stu-id="d705e-246">Optional.</span></span> <span data-ttu-id="d705e-247">Parameterarray von 0 oder mehr zu schließenden Channels.</span><span class="sxs-lookup"><span data-stu-id="d705e-247">Parameter array of 0 or more channels to be closed.</span></span></param>
        <summary><span data-ttu-id="d705e-248">Schließt die Eingabe/Ausgabe (E/A) für eine Datei, die mit der <see langword="FileOpen" />-Funktion geöffnet wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-248">Concludes input/output (I/O) to a file opened using the <see langword="FileOpen" /> function.</span></span> <span data-ttu-id="d705e-249"><see langword="My" /> ermöglicht bei Datei-E/A-Vorgängen eine höhere Produktivität und Leistung.</span><span class="sxs-lookup"><span data-stu-id="d705e-249"><see langword="My" /> gives you better productivity and performance in file I/O operations.</span></span> <span data-ttu-id="d705e-250">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-250">See <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> for more information.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d705e-251">Die `FileClose` Funktion wird für Abwärtskompatibilität angeboten und die Leistung beeinträchtigen.</span><span class="sxs-lookup"><span data-stu-id="d705e-251">The `FileClose` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="d705e-252">Für nicht-Legacyanwendungen der `My.Computer.FileSystem` Objekt bietet eine bessere Leistung.</span><span class="sxs-lookup"><span data-stu-id="d705e-252">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="d705e-253">Weitere Informationen finden Sie unter [wie: Lesen von Text aus Dateien mit einem StreamReader](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md),[wie: Schreiben von Text in Dateien mit einem StreamWriter](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md), und [Exemplarische Vorgehensweise: Bearbeiten von Dateien und Verzeichnissen in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories.md).</span><span class="sxs-lookup"><span data-stu-id="d705e-253">For more information, see [How to: Read Text from Files with a StreamReader](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md),[How to: Write Text to Files with a StreamWriter](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md), and [Walkthrough: Manipulating Files and Directories in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories.md).</span></span>  
  
 <span data-ttu-id="d705e-254">Wenn Sie weglassen `FileNumbers`, allen aktive Dateien geöffnet werden, indem Sie die `FileOpen` Funktion geschlossen werden.</span><span class="sxs-lookup"><span data-stu-id="d705e-254">If you omit `FileNumbers`, all active files opened by the `FileOpen` function are closed.</span></span>  
  
 <span data-ttu-id="d705e-255">Beim Schließen von Dateien, die für geöffnet waren `Output` oder `Append`, wird der endgültige Puffer der Ausgabe in die Betriebssystempuffer für diese Datei geschrieben.</span><span class="sxs-lookup"><span data-stu-id="d705e-255">When you close files that were opened for `Output` or `Append`, the final buffer of output is written to the operating system buffer for that file.</span></span> <span data-ttu-id="d705e-256">Alle geschlossenen zugeordnete Pufferspeicher Datei freigegeben ist.</span><span class="sxs-lookup"><span data-stu-id="d705e-256">All buffer space associated with the closed file is released.</span></span>  
  
 <span data-ttu-id="d705e-257">Wenn die `FileClose` Funktion ausgeführt wird, wird die Zuordnung einer Datei mit der Datei Zahl enden.</span><span class="sxs-lookup"><span data-stu-id="d705e-257">When the `FileClose` function is executed, the association of a file with its file number ends.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d705e-258">Dieses Beispiel verwendet die `FileClose` Funktion zum Schließen einer Datei geöffnet wird, für `Input`.</span><span class="sxs-lookup"><span data-stu-id="d705e-258">This example uses the `FileClose` function to close a file opened for `Input`.</span></span>  
  
 [!code-vb[VbVbalrCatRef#69](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#69)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="d705e-259"><paramref name="FileNumber" /> existiert nicht.</span><span class="sxs-lookup"><span data-stu-id="d705e-259"><paramref name="FileNumber" /> does not exist.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Reset" />
      </Docs>
    </Member>
    <Member MemberName="FileCopy">
      <MemberSignature Language="C#" Value="public static void FileCopy (string Source, string Destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileCopy(string Source, string Destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileCopy(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileCopy (Source As String, Destination As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileCopy(System::String ^ Source, System::String ^ Destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Source" Type="System.String" />
        <Parameter Name="Destination" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Source"><span data-ttu-id="d705e-260">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-260">Required.</span></span> <span data-ttu-id="d705e-261">Ein <see langword="String" />-Ausdruck, der den Namen der zu kopierenden Datei angibt.</span><span class="sxs-lookup"><span data-stu-id="d705e-261"><see langword="String" /> expression that specifies the name of the file to be copied.</span></span> <span data-ttu-id="d705e-262"><c>Source</c> kann das Verzeichnis oder den Ordner sowie das Laufwerk der Quelldatei beinhalten.</span><span class="sxs-lookup"><span data-stu-id="d705e-262"><c>Source</c> may include the directory or folder, and drive, of the source file.</span></span></param>
        <param name="Destination"><span data-ttu-id="d705e-263">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-263">Required.</span></span> <span data-ttu-id="d705e-264">Ein <see langword="String" />-Ausdruck, der den Zieldateinamen angibt.</span><span class="sxs-lookup"><span data-stu-id="d705e-264"><see langword="String" /> expression that specifies the destination file name.</span></span> <span data-ttu-id="d705e-265"><c>Destination</c> kann das Verzeichnis oder den Ordner sowie das Laufwerk der Zieldatei beinhalten.</span><span class="sxs-lookup"><span data-stu-id="d705e-265"><c>Destination</c> may include the directory or folder, and drive, of the destination file.</span></span></param>
        <summary><span data-ttu-id="d705e-266">Kopiert eine Datei</span><span class="sxs-lookup"><span data-stu-id="d705e-266">Copies a file.</span></span> <span data-ttu-id="d705e-267">Das <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> ermöglicht bei Datei-E/A-Vorgängen höhere Produktivität und Leistung als <see langword="FileCopy" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-267">The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than <see langword="FileCopy" />.</span></span> <span data-ttu-id="d705e-268">Weitere Informationen finden Sie unter <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile(System.String,System.String)" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-268">See <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile(System.String,System.String)" /> for more information.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d705e-269">Wenn Sie versuchen, verwenden Sie die `FileCopy` -Funktion auf eine aktuell geöffnete Datei ein Fehler auftritt.</span><span class="sxs-lookup"><span data-stu-id="d705e-269">If you try to use the `FileCopy` function on a currently open file, an error occurs.</span></span>  
  
 <span data-ttu-id="d705e-270">`FileCopy` erfordert volle Vertrauenswürdigkeit auf dem lokalen Laufwerk funktioniert.</span><span class="sxs-lookup"><span data-stu-id="d705e-270">`FileCopy` requires full trust to work on the local drive.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d705e-271">Dieses Beispiel verwendet die `FileCopy` Funktion, um eine Datei auf einen anderen kopieren.</span><span class="sxs-lookup"><span data-stu-id="d705e-271">This example uses the `FileCopy` function to copy one file to another.</span></span> <span data-ttu-id="d705e-272">Für dieses Beispiel wird davon ausgegangen, die `SrcFile` ist eine Datei, die Daten enthält.</span><span class="sxs-lookup"><span data-stu-id="d705e-272">For purposes of this example, assume that `SrcFile` is a file that contains data.</span></span>  
  
 [!code-vb[VbVbalrCatRef#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="d705e-273"><paramref name="Source" /> oder <paramref name="Destination" /> ist ungültig oder nicht angegeben.</span><span class="sxs-lookup"><span data-stu-id="d705e-273"><paramref name="Source" /> or <paramref name="Destination" /> is invalid or not specified.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="d705e-274">Datei ist bereits geöffnet.</span><span class="sxs-lookup"><span data-stu-id="d705e-274">File is already open.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="d705e-275">Die Datei ist nicht vorhanden.</span><span class="sxs-lookup"><span data-stu-id="d705e-275">File does not exist.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <Member MemberName="FileDateTime">
      <MemberSignature Language="C#" Value="public static DateTime FileDateTime (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype System.DateTime FileDateTime(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileDateTime (PathName As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime FileDateTime(System::String ^ PathName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName"><span data-ttu-id="d705e-276">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-276">Required.</span></span> <span data-ttu-id="d705e-277">Ein <see langword="String" />-Ausdruck, der einen Dateinamen angibt.</span><span class="sxs-lookup"><span data-stu-id="d705e-277"><see langword="String" /> expression that specifies a file name.</span></span> <span data-ttu-id="d705e-278"><c>PathName</c> kann das Verzeichnis bzw. den Ordner und das Laufwerk enthalten.</span><span class="sxs-lookup"><span data-stu-id="d705e-278"><c>PathName</c> may include the directory or folder, and the drive.</span></span></param>
        <summary><span data-ttu-id="d705e-279">Gibt einen <see langword="Date" />-Wert zurück, der Datum und Uhrzeit des Schreibvorgangs in einer Datei angibt.</span><span class="sxs-lookup"><span data-stu-id="d705e-279">Returns a <see langword="Date" /> value that indicates the date and time a file was written to.</span></span> <span data-ttu-id="d705e-280">Das <see langword="My" />-Feature bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FileDateTime" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-280">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileDateTime" />.</span></span> <span data-ttu-id="d705e-281">Weitere Informationen finden Sie unter <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" /></span><span class="sxs-lookup"><span data-stu-id="d705e-281">For more information, see <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" /></span></span></summary>
        <returns>
          <span data-ttu-id="d705e-282">Ein <see langword="Date" />-Wert, der Datum und Uhrzeit der Erstellung oder letzten Änderung der Datei angibt.</span><span class="sxs-lookup"><span data-stu-id="d705e-282"><see langword="Date" /> value that indicates the date and time a file was created or last modified.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="d705e-283">Dieses Beispiel verwendet die `FileDateTime` Funktion, um das Datum zu bestimmen und die Uhrzeit einer Datei erstellt oder zuletzt geändert wurde.</span><span class="sxs-lookup"><span data-stu-id="d705e-283">This example uses the `FileDateTime` function to determine the date and time a file was created or last modified.</span></span> <span data-ttu-id="d705e-284">Das Format von Datum und Uhrzeit angezeigt, basiert auf dem Gebietsschema des Systems.</span><span class="sxs-lookup"><span data-stu-id="d705e-284">The format of the date and time displayed is based on the locale settings of the system.</span></span>  
  
 [!code-vb[VbVbalrCatRef#34](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#34)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="d705e-285"><paramref name="PathName" /> ist ungültig oder enthält Platzhalterzeichen.</span><span class="sxs-lookup"><span data-stu-id="d705e-285"><paramref name="PathName" /> is invalid or contains wildcards.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="d705e-286">Zieldatei ist nicht vorhanden.</span><span class="sxs-lookup"><span data-stu-id="d705e-286">Target file does not exist.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FileGet">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d705e-287">Liest Daten aus einer offenen Datenträgerdatei in eine Variable.</span><span class="sxs-lookup"><span data-stu-id="d705e-287">Reads data from an open disk file into a variable.</span></span> <span data-ttu-id="d705e-288">Die <see langword="My" />-Funktion bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FileGet" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-288">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span></span> <span data-ttu-id="d705e-289">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-289">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref bool Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, bool&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Boolean, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="d705e-290">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-290">Required.</span></span> <span data-ttu-id="d705e-291">Eine beliebige gültige Dateinummer.</span><span class="sxs-lookup"><span data-stu-id="d705e-291">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="d705e-292">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-292">Required.</span></span> <span data-ttu-id="d705e-293">Der gültige Name einer Variablen, in die Daten gelesen werden.</span><span class="sxs-lookup"><span data-stu-id="d705e-293">Valid variable name into which data is read.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="d705e-294">Dies ist optional.</span><span class="sxs-lookup"><span data-stu-id="d705e-294">Optional.</span></span> <span data-ttu-id="d705e-295">Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), bei der der Lesevorgang beginnt.</span><span class="sxs-lookup"><span data-stu-id="d705e-295">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span></span></param>
        <summary><span data-ttu-id="d705e-296">Liest Daten aus einer offenen Datenträgerdatei in eine Variable.</span><span class="sxs-lookup"><span data-stu-id="d705e-296">Reads data from an open disk file into a variable.</span></span> <span data-ttu-id="d705e-297">Das <see langword="My" />-Feature bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FileGet" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-297">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span></span> <span data-ttu-id="d705e-298">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /></span><span class="sxs-lookup"><span data-stu-id="d705e-298">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /></span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d705e-299">`FileGet` gilt nur in `Random` und `Binary` Modus.</span><span class="sxs-lookup"><span data-stu-id="d705e-299">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="d705e-300">Datenlesevorgänge mit `FileGet` bezieht sich normalerweise in eine Datei mit `FilePut`.</span><span class="sxs-lookup"><span data-stu-id="d705e-300">Data read with `FileGet` is usually written to a file with `FilePut`.</span></span>  
  
 <span data-ttu-id="d705e-301">Der erste Datensatz oder Byte in einer Datei befindet sich an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 usw. ist.</span><span class="sxs-lookup"><span data-stu-id="d705e-301">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="d705e-302">Wenn Sie weglassen `RecordNumber`, den nächsten Datensatz bzw. Byte nach dem letzten `FileGet` oder `FilePut` Funktion (oder verweist, zu dem letzten `Seek` Funktion) gelesen wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-302">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="d705e-303">Beim Lesen aus Dateien nicht Beurteilen der Inhalt einer Datei, die anhand der Dateinamenerweiterung.</span><span class="sxs-lookup"><span data-stu-id="d705e-303">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="d705e-304">Eine Datei mit dem Namen "Form1.vb" möglicherweise z. B. nicht über ein Visual Basic-Quelldatei.</span><span class="sxs-lookup"><span data-stu-id="d705e-304">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="d705e-305">Zufällige Modus</span><span class="sxs-lookup"><span data-stu-id="d705e-305">Random Mode</span></span>  
 <span data-ttu-id="d705e-306">Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:</span><span class="sxs-lookup"><span data-stu-id="d705e-306">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="d705e-307">Wenn die Länge des zu lesenden Daten kleiner als die Länge ist, angegeben der `RecordLength` -Klausel der `FileOpen` -Funktion, `FileGet` liest nachfolgende Datensätze Datensatzlänge.</span><span class="sxs-lookup"><span data-stu-id="d705e-307">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="d705e-308">Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt.</span><span class="sxs-lookup"><span data-stu-id="d705e-308">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="d705e-309">Da die Menge der Leerstellen Daten nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen empfiehlt sich, die Datensatzlänge der Länge der zu lesenden Daten überein.</span><span class="sxs-lookup"><span data-stu-id="d705e-309">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="d705e-310">Die Zielvariable eine Zeichenfolge ist, standardmäßig `FileGet` liest einen 2-Byte-Deskriptor, die Länge der Zeichenfolge enthält, und liest dann die Daten, die in die Variable aufgenommen wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-310">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="d705e-311">Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="d705e-311">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="d705e-312">Visual Basic 6.0 und früheren Versionen unterstützen Zeichenfolgen mit fester Länge. Wenn in einer Datei zu speichern, wird der Längendeskriptor nicht geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="d705e-312">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="d705e-313">Wenn Sie eine Zeichenfolge ohne Deskriptor lesen möchten, übergeben Sie `True` auf die `StringIsFixedLength` Parameter, und die Zeichenfolge, die Sie einlesen, sollte die richtige Länge.</span><span class="sxs-lookup"><span data-stu-id="d705e-313">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="d705e-314">Wenn die Zielvariable ein Array ist, können Sie auswählen, ob einen Deskriptor für die Größe und die Dimension des Arrays zu lesen.</span><span class="sxs-lookup"><span data-stu-id="d705e-314">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="d705e-315">Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`.</span><span class="sxs-lookup"><span data-stu-id="d705e-315">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="d705e-316">Beim Lesen des Arrays müssen Sie die Möglichkeit zu entsprechen, die das Array geschrieben wurde.</span><span class="sxs-lookup"><span data-stu-id="d705e-316">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="d705e-317">Wenn sie mit dem Deskriptor geschrieben wurde, müssen Sie den Deskriptor lesen.</span><span class="sxs-lookup"><span data-stu-id="d705e-317">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="d705e-318">Der Deskriptor nicht verwendet wird, die Größe und die Grenzen des Arrays übergebenen `FileGet` ermittelt das weitere Vorgehen zu lesen.</span><span class="sxs-lookup"><span data-stu-id="d705e-318">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="d705e-319">Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang.</span><span class="sxs-lookup"><span data-stu-id="d705e-319">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="d705e-320">Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl von Dimensionen: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="d705e-320">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="d705e-321">Die Länge des Datensatzes gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Arraydeskriptor zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="d705e-321">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="d705e-322">Die folgende Arraydeklaration erfordert z. B. 218 Bytes, wenn das Array geschrieben wird auf den Datenträger.</span><span class="sxs-lookup"><span data-stu-id="d705e-322">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="d705e-323">Die 218 Bytes werden wie folgt verteilt:</span><span class="sxs-lookup"><span data-stu-id="d705e-323">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="d705e-324">18 Bytes für den Deskriptor: (2 + 8 \* 2)</span><span class="sxs-lookup"><span data-stu-id="d705e-324">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="d705e-325">200 Bytes für die Daten: (10 * 5 * 4).</span><span class="sxs-lookup"><span data-stu-id="d705e-325">200 bytes for the data: (5 * 10 * 4).</span></span>  
  
-   <span data-ttu-id="d705e-326">Wenn die Variable in gelesen werden, andere Typen von Variablen (keine Zeichenfolge variabler Länge oder ein Objekt), `FileGet` liest nur die Daten die Variablen.</span><span class="sxs-lookup"><span data-stu-id="d705e-326">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="d705e-327">Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge der Daten, die gelesen werden können.</span><span class="sxs-lookup"><span data-stu-id="d705e-327">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="d705e-328">`FileGet` liest Sie Elemente von Strukturen, als ob einzeln gelesen wurden, mit dem Unterschied, dass keine Auffüllung zwischen Elementen vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="d705e-328">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="d705e-329">Auf dem Datenträger ein dynamisches array, in einem benutzerdefinierten Typ (mit geschriebene `FilePut`) ein Deskriptor, dessen Länge 2 plus 8 Mal der Anzahl der Dimensionen gleich, vorangestellt ist: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="d705e-329">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="d705e-330">Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes, die zum Lesen der einzelnen Elemente erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-330">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="d705e-331">Dies schließt alle Arrays und ihrer Deskriptoren.</span><span class="sxs-lookup"><span data-stu-id="d705e-331">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="d705e-332">Die `VBFixedString` Attribut angewendet werden kann, zu Zeichenfolgenfeldern in den Strukturen an, dass die Größe der Zeichenfolge beim Schreiben auf den Datenträger.</span><span class="sxs-lookup"><span data-stu-id="d705e-332">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="d705e-333">Binärmodus</span><span class="sxs-lookup"><span data-stu-id="d705e-333">Binary Mode</span></span>  
 <span data-ttu-id="d705e-334">Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` -Modus-Regeln gelten, bis auf einige Ausnahmen.</span><span class="sxs-lookup"><span data-stu-id="d705e-334">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="d705e-335">Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:</span><span class="sxs-lookup"><span data-stu-id="d705e-335">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="d705e-336">Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen.</span><span class="sxs-lookup"><span data-stu-id="d705e-336">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="d705e-337">`FileGet` Liest alle Variablen zusammenhängend vom Datenträger. d. h. ohne Auffüllung zwischen Datensätzen.</span><span class="sxs-lookup"><span data-stu-id="d705e-337">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="d705e-338">Für ein beliebiges Array als ein Array in einer Struktur `FileGet` liest nur die Daten.</span><span class="sxs-lookup"><span data-stu-id="d705e-338">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="d705e-339">Es wird kein Deskriptor gelesen.</span><span class="sxs-lookup"><span data-stu-id="d705e-339">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="d705e-340">`FileGet` liest die Zeichenfolgen mit variabler Länge, die keine Elemente von Strukturen ohne erwartet den Längendeskriptor 2-Byte-sind.</span><span class="sxs-lookup"><span data-stu-id="d705e-340">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="d705e-341">Die Anzahl der gelesenen Bytes entspricht die Anzahl der Zeichen, die bereits in der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="d705e-341">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="d705e-342">Lesen aus einer Datei mithilfe der`FileGet` -Funktion erfordert `Read` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.</span><span class="sxs-lookup"><span data-stu-id="d705e-342">Reading from a file by using the`FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="d705e-343"><paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</span><span class="sxs-lookup"><span data-stu-id="d705e-343"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="d705e-344">Dateimodus ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="d705e-344">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref byte Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, unsigned int8&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Byte, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="d705e-345">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-345">Required.</span></span> <span data-ttu-id="d705e-346">Eine beliebige gültige Dateinummer.</span><span class="sxs-lookup"><span data-stu-id="d705e-346">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="d705e-347">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-347">Required.</span></span> <span data-ttu-id="d705e-348">Der gültige Name einer Variablen, in die Daten gelesen werden.</span><span class="sxs-lookup"><span data-stu-id="d705e-348">Valid variable name into which data is read.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="d705e-349">Dies ist optional.</span><span class="sxs-lookup"><span data-stu-id="d705e-349">Optional.</span></span> <span data-ttu-id="d705e-350">Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), bei der der Lesevorgang beginnt.</span><span class="sxs-lookup"><span data-stu-id="d705e-350">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span></span></param>
        <summary><span data-ttu-id="d705e-351">Liest Daten aus einer offenen Datenträgerdatei in eine Variable.</span><span class="sxs-lookup"><span data-stu-id="d705e-351">Reads data from an open disk file into a variable.</span></span> <span data-ttu-id="d705e-352">Die <see langword="My" />-Funktion bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FileGet" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-352">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span></span> <span data-ttu-id="d705e-353">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-353">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d705e-354">`FileGet` gilt nur in `Random` und `Binary` Modus.</span><span class="sxs-lookup"><span data-stu-id="d705e-354">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="d705e-355">Datenlesevorgänge mit `FileGet` bezieht sich normalerweise in eine Datei mit `FilePut`.</span><span class="sxs-lookup"><span data-stu-id="d705e-355">Data read with `FileGet` is usually written to a file with `FilePut`.</span></span>  
  
 <span data-ttu-id="d705e-356">Der erste Datensatz oder Byte in einer Datei befindet sich an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 usw. ist.</span><span class="sxs-lookup"><span data-stu-id="d705e-356">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="d705e-357">Wenn Sie weglassen `RecordNumber`, den nächsten Datensatz bzw. Byte nach dem letzten `FileGet` oder `FilePut` Funktion (oder verweist, zu dem letzten `Seek` Funktion) gelesen wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-357">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="d705e-358">Beim Lesen aus Dateien nicht Beurteilen der Inhalt einer Datei, die anhand der Dateinamenerweiterung.</span><span class="sxs-lookup"><span data-stu-id="d705e-358">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="d705e-359">Eine Datei mit dem Namen "Form1.vb" möglicherweise z. B. nicht über ein Visual Basic-Quelldatei.</span><span class="sxs-lookup"><span data-stu-id="d705e-359">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="d705e-360">Zufällige Modus</span><span class="sxs-lookup"><span data-stu-id="d705e-360">Random Mode</span></span>  
 <span data-ttu-id="d705e-361">Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:</span><span class="sxs-lookup"><span data-stu-id="d705e-361">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="d705e-362">Wenn die Länge des zu lesenden Daten kleiner als die Länge ist, angegeben der `RecordLength` -Klausel der `FileOpen` -Funktion, `FileGet` liest nachfolgende Datensätze Datensatzlänge.</span><span class="sxs-lookup"><span data-stu-id="d705e-362">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="d705e-363">Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt.</span><span class="sxs-lookup"><span data-stu-id="d705e-363">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="d705e-364">Da die Menge der Leerstellen Daten nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen empfiehlt sich, die Datensatzlänge der Länge der zu lesenden Daten überein.</span><span class="sxs-lookup"><span data-stu-id="d705e-364">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="d705e-365">Die Zielvariable eine Zeichenfolge ist, standardmäßig `FileGet` liest einen 2-Byte-Deskriptor, die Länge der Zeichenfolge enthält, und liest dann die Daten, die in die Variable aufgenommen wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-365">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="d705e-366">Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="d705e-366">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="d705e-367">Visual Basic 6.0 und früheren Versionen unterstützen Zeichenfolgen mit fester Länge. Wenn in einer Datei zu speichern, wird der Längendeskriptor nicht geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="d705e-367">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="d705e-368">Wenn Sie eine Zeichenfolge ohne Deskriptor lesen möchten, übergeben Sie `True` auf die `StringIsFixedLength` Parameter, und die Zeichenfolge, die Sie einlesen, sollte die richtige Länge.</span><span class="sxs-lookup"><span data-stu-id="d705e-368">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="d705e-369">Wenn die Zielvariable ein Array ist, können Sie auswählen, ob einen Deskriptor für die Größe und die Dimension des Arrays zu lesen.</span><span class="sxs-lookup"><span data-stu-id="d705e-369">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="d705e-370">Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`.</span><span class="sxs-lookup"><span data-stu-id="d705e-370">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="d705e-371">Beim Lesen des Arrays müssen Sie die Möglichkeit zu entsprechen, die das Array geschrieben wurde.</span><span class="sxs-lookup"><span data-stu-id="d705e-371">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="d705e-372">Wenn sie mit dem Deskriptor geschrieben wurde, müssen Sie den Deskriptor lesen.</span><span class="sxs-lookup"><span data-stu-id="d705e-372">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="d705e-373">Wenn der Deskriptor nicht verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-373">If the descriptor is not used.</span></span> <span data-ttu-id="d705e-374">Übergeben Sie die Größe und die Grenzen des Arrays in `FileGet` ermittelt das weitere Vorgehen zu lesen.</span><span class="sxs-lookup"><span data-stu-id="d705e-374">Then the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="d705e-375">Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang.</span><span class="sxs-lookup"><span data-stu-id="d705e-375">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="d705e-376">Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl von Dimensionen: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="d705e-376">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="d705e-377">Die Länge des Datensatzes gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Arraydeskriptor zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="d705e-377">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="d705e-378">Die folgende Arraydeklaration erfordert z. B. 218 Bytes, wenn das Array geschrieben wird auf den Datenträger.</span><span class="sxs-lookup"><span data-stu-id="d705e-378">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="d705e-379">Die 218 Bytes werden wie folgt verteilt:</span><span class="sxs-lookup"><span data-stu-id="d705e-379">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="d705e-380">18 Bytes für den Deskriptor: (2 + 8 \* 2)</span><span class="sxs-lookup"><span data-stu-id="d705e-380">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="d705e-381">200 Bytes für die Daten: (10 * 5 * 4).</span><span class="sxs-lookup"><span data-stu-id="d705e-381">200 bytes for the data: (5 * 10 * 4).</span></span>  
  
-   <span data-ttu-id="d705e-382">Wenn die Variable in gelesen werden, andere Typen von Variablen (keine Zeichenfolge variabler Länge oder ein Objekt), `FileGet` liest nur die Daten die Variablen.</span><span class="sxs-lookup"><span data-stu-id="d705e-382">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="d705e-383">Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge der Daten, die gelesen werden können.</span><span class="sxs-lookup"><span data-stu-id="d705e-383">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="d705e-384">`FileGet` liest Sie Elemente von Strukturen, als ob einzeln gelesen wurden, mit dem Unterschied, dass keine Auffüllung zwischen Elementen vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="d705e-384">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="d705e-385">Auf dem Datenträger ein dynamisches array, in einem benutzerdefinierten Typ (mit geschriebene `FilePut`) ein Deskriptor, dessen Länge 2 plus 8 Mal der Anzahl der Dimensionen gleich, vorangestellt ist: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="d705e-385">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="d705e-386">Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes, die zum Lesen der einzelnen Elemente erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-386">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="d705e-387">Dies schließt alle Arrays und ihrer Deskriptoren.</span><span class="sxs-lookup"><span data-stu-id="d705e-387">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="d705e-388">Die `VBFixedString` Attribut angewendet werden kann, zu Zeichenfolgenfeldern in den Strukturen an, dass die Größe der Zeichenfolge beim Schreiben auf den Datenträger.</span><span class="sxs-lookup"><span data-stu-id="d705e-388">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="d705e-389">Binärmodus</span><span class="sxs-lookup"><span data-stu-id="d705e-389">Binary Mode</span></span>  
 <span data-ttu-id="d705e-390">Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` -Modus-Regeln gelten, bis auf einige Ausnahmen.</span><span class="sxs-lookup"><span data-stu-id="d705e-390">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="d705e-391">Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:</span><span class="sxs-lookup"><span data-stu-id="d705e-391">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="d705e-392">Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen.</span><span class="sxs-lookup"><span data-stu-id="d705e-392">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="d705e-393">`FileGet` Liest alle Variablen zusammenhängend vom Datenträger. d. h. ohne Auffüllung zwischen Datensätzen.</span><span class="sxs-lookup"><span data-stu-id="d705e-393">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="d705e-394">Für ein beliebiges Array als ein Array in einer Struktur `FileGet` liest nur die Daten.</span><span class="sxs-lookup"><span data-stu-id="d705e-394">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="d705e-395">Es wird kein Deskriptor gelesen.</span><span class="sxs-lookup"><span data-stu-id="d705e-395">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="d705e-396">`FileGet` liest die Zeichenfolgen mit variabler Länge, die keine Elemente von Strukturen ohne erwartet den Längendeskriptor 2-Byte-sind.</span><span class="sxs-lookup"><span data-stu-id="d705e-396">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="d705e-397">Die Anzahl der gelesenen Bytes entspricht die Anzahl der Zeichen, die bereits in der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="d705e-397">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="d705e-398">Lesen aus einer Datei mithilfe der `FileGet` -Funktion erfordert `Read` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.</span><span class="sxs-lookup"><span data-stu-id="d705e-398">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="d705e-399"><paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</span><span class="sxs-lookup"><span data-stu-id="d705e-399"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="d705e-400">Dateimodus ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="d705e-400">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref char Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, char&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Char, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="d705e-401">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-401">Required.</span></span> <span data-ttu-id="d705e-402">Eine beliebige gültige Dateinummer.</span><span class="sxs-lookup"><span data-stu-id="d705e-402">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="d705e-403">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-403">Required.</span></span> <span data-ttu-id="d705e-404">Der gültige Name einer Variablen, in die Daten gelesen werden.</span><span class="sxs-lookup"><span data-stu-id="d705e-404">Valid variable name into which data is read.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="d705e-405">Dies ist optional.</span><span class="sxs-lookup"><span data-stu-id="d705e-405">Optional.</span></span> <span data-ttu-id="d705e-406">Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), bei der der Lesevorgang beginnt.</span><span class="sxs-lookup"><span data-stu-id="d705e-406">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span></span></param>
        <summary><span data-ttu-id="d705e-407">Liest Daten aus einer offenen Datenträgerdatei in eine Variable.</span><span class="sxs-lookup"><span data-stu-id="d705e-407">Reads data from an open disk file into a variable.</span></span> <span data-ttu-id="d705e-408">Die <see langword="My" />-Funktion bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FileGet" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-408">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span></span> <span data-ttu-id="d705e-409">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-409">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d705e-410">`FileGet` gilt nur in `Random` und `Binary` Modus.</span><span class="sxs-lookup"><span data-stu-id="d705e-410">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="d705e-411">Datenlesevorgänge mit `FileGet` bezieht sich normalerweise in eine Datei mit `FilePut`.</span><span class="sxs-lookup"><span data-stu-id="d705e-411">Data read with `FileGet` is usually written to a file with `FilePut`.</span></span>  
  
 <span data-ttu-id="d705e-412">Der erste Datensatz oder Byte in einer Datei befindet sich an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 usw. ist.</span><span class="sxs-lookup"><span data-stu-id="d705e-412">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="d705e-413">Wenn Sie weglassen `RecordNumber`, den nächsten Datensatz bzw. Byte nach dem letzten `FileGet` oder `FilePut` Funktion (oder verweist, zu dem letzten `Seek` Funktion) gelesen wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-413">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="d705e-414">Beim Lesen aus Dateien nicht Beurteilen der Inhalt einer Datei, die anhand der Dateinamenerweiterung.</span><span class="sxs-lookup"><span data-stu-id="d705e-414">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="d705e-415">Eine Datei mit dem Namen "Form1.vb" möglicherweise z. B. nicht über ein Visual Basic-Quelldatei.</span><span class="sxs-lookup"><span data-stu-id="d705e-415">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="d705e-416">Zufällige Modus</span><span class="sxs-lookup"><span data-stu-id="d705e-416">Random Mode</span></span>  
 <span data-ttu-id="d705e-417">Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:</span><span class="sxs-lookup"><span data-stu-id="d705e-417">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="d705e-418">Wenn die Länge des zu lesenden Daten kleiner als die Länge ist, angegeben der `RecordLength` -Klausel der `FileOpen` -Funktion, `FileGet` liest nachfolgende Datensätze Datensatzlänge.</span><span class="sxs-lookup"><span data-stu-id="d705e-418">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="d705e-419">Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt.</span><span class="sxs-lookup"><span data-stu-id="d705e-419">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="d705e-420">Da die Menge der Leerstellen Daten nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen empfiehlt sich, die Datensatzlänge der Länge der zu lesenden Daten überein.</span><span class="sxs-lookup"><span data-stu-id="d705e-420">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="d705e-421">Die Zielvariable eine Zeichenfolge ist, standardmäßig `FileGet` liest einen 2-Byte-Deskriptor, die Länge der Zeichenfolge enthält, und liest dann die Daten, die in die Variable aufgenommen wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-421">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="d705e-422">Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="d705e-422">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="d705e-423">Visual Basic 6.0 und früheren Versionen unterstützen Zeichenfolgen mit fester Länge. Wenn in einer Datei zu speichern, wird der Längendeskriptor nicht geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="d705e-423">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="d705e-424">Wenn Sie eine Zeichenfolge ohne Deskriptor lesen möchten, übergeben Sie `True` auf die `StringIsFixedLength` Parameter, und die Zeichenfolge, die Sie einlesen, sollte die richtige Länge.</span><span class="sxs-lookup"><span data-stu-id="d705e-424">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="d705e-425">Wenn die Zielvariable ein Array ist, können Sie auswählen, ob einen Deskriptor für die Größe und die Dimension des Arrays zu lesen.</span><span class="sxs-lookup"><span data-stu-id="d705e-425">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="d705e-426">Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`.</span><span class="sxs-lookup"><span data-stu-id="d705e-426">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="d705e-427">Beim Lesen des Arrays müssen Sie die Möglichkeit zu entsprechen, die das Array geschrieben wurde.</span><span class="sxs-lookup"><span data-stu-id="d705e-427">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="d705e-428">Wenn sie mit dem Deskriptor geschrieben wurde, müssen Sie den Deskriptor lesen.</span><span class="sxs-lookup"><span data-stu-id="d705e-428">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="d705e-429">Der Deskriptor nicht verwendet wird, die Größe und die Grenzen des Arrays übergebenen `FileGet` ermittelt das weitere Vorgehen zu lesen.</span><span class="sxs-lookup"><span data-stu-id="d705e-429">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="d705e-430">Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang.</span><span class="sxs-lookup"><span data-stu-id="d705e-430">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="d705e-431">Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl von Dimensionen: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="d705e-431">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="d705e-432">Die Länge des Datensatzes gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Arraydeskriptor zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="d705e-432">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="d705e-433">Die folgende Arraydeklaration erfordert z. B. 218 Bytes, wenn das Array geschrieben wird auf den Datenträger.</span><span class="sxs-lookup"><span data-stu-id="d705e-433">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="d705e-434">Die 218 Bytes werden wie folgt verteilt:</span><span class="sxs-lookup"><span data-stu-id="d705e-434">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="d705e-435">18 Bytes für den Deskriptor: (2 + 8 \* 2)</span><span class="sxs-lookup"><span data-stu-id="d705e-435">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="d705e-436">200 Bytes für die Daten: (10 * 5 * 4).</span><span class="sxs-lookup"><span data-stu-id="d705e-436">200 bytes for the data: (5 * 10 * 4).</span></span>  
  
-   <span data-ttu-id="d705e-437">Wenn die Variable in gelesen werden, andere Typen von Variablen (keine Zeichenfolge variabler Länge oder ein Objekt), `FileGet` liest nur die Daten die Variablen.</span><span class="sxs-lookup"><span data-stu-id="d705e-437">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="d705e-438">Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge der Daten, die gelesen werden können.</span><span class="sxs-lookup"><span data-stu-id="d705e-438">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="d705e-439">`FileGet` liest Sie Elemente von Strukturen, als ob einzeln gelesen wurden, mit dem Unterschied, dass keine Auffüllung zwischen Elementen vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="d705e-439">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="d705e-440">Auf dem Datenträger ein dynamisches array, in einem benutzerdefinierten Typ (mit geschriebene `FilePut`) ein Deskriptor, dessen Länge 2 plus 8 Mal der Anzahl der Dimensionen gleich, vorangestellt ist: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="d705e-440">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="d705e-441">Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes, die zum Lesen der einzelnen Elemente erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-441">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="d705e-442">Dies schließt alle Arrays und ihrer Deskriptoren.</span><span class="sxs-lookup"><span data-stu-id="d705e-442">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="d705e-443">Die `VBFixedString` Attribut angewendet werden kann, zu Zeichenfolgenfeldern in den Strukturen an, dass die Größe der Zeichenfolge beim Schreiben auf den Datenträger.</span><span class="sxs-lookup"><span data-stu-id="d705e-443">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="d705e-444">Binärmodus</span><span class="sxs-lookup"><span data-stu-id="d705e-444">Binary Mode</span></span>  
 <span data-ttu-id="d705e-445">Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` -Modus-Regeln gelten, bis auf einige Ausnahmen.</span><span class="sxs-lookup"><span data-stu-id="d705e-445">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="d705e-446">Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:</span><span class="sxs-lookup"><span data-stu-id="d705e-446">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="d705e-447">Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen.</span><span class="sxs-lookup"><span data-stu-id="d705e-447">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="d705e-448">`FileGet` Liest alle Variablen zusammenhängend vom Datenträger. d. h. ohne Auffüllung zwischen Datensätzen.</span><span class="sxs-lookup"><span data-stu-id="d705e-448">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="d705e-449">Für ein beliebiges Array als ein Array in einer Struktur `FileGet` liest nur die Daten.</span><span class="sxs-lookup"><span data-stu-id="d705e-449">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="d705e-450">Es wird kein Deskriptor gelesen.</span><span class="sxs-lookup"><span data-stu-id="d705e-450">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="d705e-451">`FileGet` liest die Zeichenfolgen mit variabler Länge, die keine Elemente von Strukturen ohne erwartet den Längendeskriptor 2-Byte-sind.</span><span class="sxs-lookup"><span data-stu-id="d705e-451">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="d705e-452">Die Anzahl der gelesenen Bytes entspricht die Anzahl der Zeichen, die bereits in der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="d705e-452">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="d705e-453">Lesen aus einer Datei mithilfe der `FileGet` -Funktion erfordert `Read` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.</span><span class="sxs-lookup"><span data-stu-id="d705e-453">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="d705e-454"><paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</span><span class="sxs-lookup"><span data-stu-id="d705e-454"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="d705e-455">Dateimodus ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="d705e-455">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref DateTime Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, valuetype System.DateTime&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As DateTime, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="d705e-456">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-456">Required.</span></span> <span data-ttu-id="d705e-457">Eine beliebige gültige Dateinummer.</span><span class="sxs-lookup"><span data-stu-id="d705e-457">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="d705e-458">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-458">Required.</span></span> <span data-ttu-id="d705e-459">Der gültige Name einer Variablen, in die Daten gelesen werden.</span><span class="sxs-lookup"><span data-stu-id="d705e-459">Valid variable name into which data is read.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="d705e-460">Dies ist optional.</span><span class="sxs-lookup"><span data-stu-id="d705e-460">Optional.</span></span> <span data-ttu-id="d705e-461">Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), bei der der Lesevorgang beginnt.</span><span class="sxs-lookup"><span data-stu-id="d705e-461">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span></span></param>
        <summary><span data-ttu-id="d705e-462">Liest Daten aus einer offenen Datenträgerdatei in eine Variable.</span><span class="sxs-lookup"><span data-stu-id="d705e-462">Reads data from an open disk file into a variable.</span></span> <span data-ttu-id="d705e-463">Die <see langword="My" />-Funktion bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FileGet" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-463">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span></span> <span data-ttu-id="d705e-464">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-464">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d705e-465">`FileGet` gilt nur in `Random` und `Binary` Modus.</span><span class="sxs-lookup"><span data-stu-id="d705e-465">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="d705e-466">Datenlesevorgänge mit `FileGet` bezieht sich normalerweise in eine Datei mit `FilePut`.</span><span class="sxs-lookup"><span data-stu-id="d705e-466">Data read with `FileGet` is usually written to a file with `FilePut`.</span></span>  
  
 <span data-ttu-id="d705e-467">Der erste Datensatz oder Byte in einer Datei befindet sich an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 usw. ist.</span><span class="sxs-lookup"><span data-stu-id="d705e-467">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="d705e-468">Wenn Sie weglassen `RecordNumber`, den nächsten Datensatz bzw. Byte nach dem letzten `FileGet` oder `FilePut` Funktion (oder verweist, zu dem letzten `Seek` Funktion) gelesen wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-468">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="d705e-469">Beim Lesen aus Dateien nicht Beurteilen der Inhalt einer Datei, die anhand der Dateinamenerweiterung.</span><span class="sxs-lookup"><span data-stu-id="d705e-469">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="d705e-470">Eine Datei mit dem Namen "Form1.vb" möglicherweise z. B. nicht über ein Visual Basic-Quelldatei.</span><span class="sxs-lookup"><span data-stu-id="d705e-470">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="d705e-471">Zufällige Modus</span><span class="sxs-lookup"><span data-stu-id="d705e-471">Random Mode</span></span>  
 <span data-ttu-id="d705e-472">Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:</span><span class="sxs-lookup"><span data-stu-id="d705e-472">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="d705e-473">Wenn die Länge des zu lesenden Daten kleiner als die Länge ist, angegeben der `RecordLength` -Klausel der `FileOpen` -Funktion,`FileGet` liest nachfolgende Datensätze Datensatzlänge.</span><span class="sxs-lookup"><span data-stu-id="d705e-473">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function,`FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="d705e-474">Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt.</span><span class="sxs-lookup"><span data-stu-id="d705e-474">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="d705e-475">Da die Menge der Leerstellen Daten nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen empfiehlt sich, die Datensatzlänge der Länge der zu lesenden Daten überein.</span><span class="sxs-lookup"><span data-stu-id="d705e-475">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="d705e-476">Die Zielvariable eine Zeichenfolge ist, standardmäßig `FileGet` liest einen 2-Byte-Deskriptor, die Länge der Zeichenfolge enthält, und liest dann die Daten, die in die Variable aufgenommen wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-476">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="d705e-477">Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="d705e-477">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="d705e-478">Visual Basic 6.0 und früheren Versionen unterstützen Zeichenfolgen mit fester Länge. Wenn in einer Datei zu speichern, wird der Längendeskriptor nicht geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="d705e-478">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="d705e-479">Wenn Sie eine Zeichenfolge ohne Deskriptor lesen möchten, übergeben Sie `True` auf die `StringIsFixedLength` Parameter, und die Zeichenfolge, die Sie einlesen, sollte die richtige Länge.</span><span class="sxs-lookup"><span data-stu-id="d705e-479">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="d705e-480">Wenn die Zielvariable ein Array ist, können Sie auswählen, ob einen Deskriptor für die Größe und die Dimension des Arrays zu lesen.</span><span class="sxs-lookup"><span data-stu-id="d705e-480">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="d705e-481">Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`.</span><span class="sxs-lookup"><span data-stu-id="d705e-481">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="d705e-482">Beim Lesen des Arrays müssen Sie die Möglichkeit zu entsprechen, die das Array geschrieben wurde.</span><span class="sxs-lookup"><span data-stu-id="d705e-482">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="d705e-483">Wenn sie mit dem Deskriptor geschrieben wurde, müssen Sie den Deskriptor lesen.</span><span class="sxs-lookup"><span data-stu-id="d705e-483">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="d705e-484">Der Deskriptor nicht verwendet wird, die Größe und die Grenzen des Arrays übergebenen `FileGet` ermittelt das weitere Vorgehen zu lesen.</span><span class="sxs-lookup"><span data-stu-id="d705e-484">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="d705e-485">Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang.</span><span class="sxs-lookup"><span data-stu-id="d705e-485">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="d705e-486">Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl von Dimensionen: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="d705e-486">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="d705e-487">Die Länge des Datensatzes gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Arraydeskriptor zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="d705e-487">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="d705e-488">Die folgende Arraydeklaration erfordert z. B. 218 Bytes, wenn das Array geschrieben wird auf den Datenträger.</span><span class="sxs-lookup"><span data-stu-id="d705e-488">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="d705e-489">Die 218 Bytes werden wie folgt verteilt:</span><span class="sxs-lookup"><span data-stu-id="d705e-489">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="d705e-490">18 Bytes für den Deskriptor: (2 + 8 \* 2)</span><span class="sxs-lookup"><span data-stu-id="d705e-490">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="d705e-491">200 Bytes für die Daten: (10 * 5 * 4).</span><span class="sxs-lookup"><span data-stu-id="d705e-491">200 bytes for the data: (5 * 10 * 4).</span></span>  
  
-   <span data-ttu-id="d705e-492">Wenn die Variable in gelesen werden, andere Typen von Variablen (keine Zeichenfolge variabler Länge oder ein Objekt), `FileGet` liest nur die Daten die Variablen.</span><span class="sxs-lookup"><span data-stu-id="d705e-492">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="d705e-493">Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge der Daten, die gelesen werden können.</span><span class="sxs-lookup"><span data-stu-id="d705e-493">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="d705e-494">`FileGet` liest Sie Elemente von Strukturen, als ob einzeln gelesen wurden, mit dem Unterschied, dass keine Auffüllung zwischen Elementen vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="d705e-494">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="d705e-495">Auf dem Datenträger ein dynamisches array, in einem benutzerdefinierten Typ (mit geschriebene `FilePut`) ein Deskriptor, dessen Länge 2 plus 8 Mal der Anzahl der Dimensionen gleich, vorangestellt ist: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="d705e-495">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="d705e-496">Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes, die zum Lesen der einzelnen Elemente erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-496">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="d705e-497">Dies schließt alle Arrays und ihrer Deskriptoren.</span><span class="sxs-lookup"><span data-stu-id="d705e-497">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="d705e-498">Die `VBFixedString` Attribut angewendet werden kann, zu Zeichenfolgenfeldern in den Strukturen an, dass die Größe der Zeichenfolge beim Schreiben auf den Datenträger.</span><span class="sxs-lookup"><span data-stu-id="d705e-498">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="d705e-499">Binärmodus</span><span class="sxs-lookup"><span data-stu-id="d705e-499">Binary Mode</span></span>  
 <span data-ttu-id="d705e-500">Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` -Modus-Regeln gelten, bis auf einige Ausnahmen.</span><span class="sxs-lookup"><span data-stu-id="d705e-500">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="d705e-501">Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:</span><span class="sxs-lookup"><span data-stu-id="d705e-501">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="d705e-502">Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen.</span><span class="sxs-lookup"><span data-stu-id="d705e-502">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="d705e-503">`FileGet` Liest alle Variablen zusammenhängend vom Datenträger. d. h. ohne Auffüllung zwischen Datensätzen.</span><span class="sxs-lookup"><span data-stu-id="d705e-503">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="d705e-504">Für ein beliebiges Array als ein Array in einer Struktur `FileGet` liest nur die Daten.</span><span class="sxs-lookup"><span data-stu-id="d705e-504">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="d705e-505">Es wird kein Deskriptor gelesen.</span><span class="sxs-lookup"><span data-stu-id="d705e-505">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="d705e-506">`FileGet` liest die Zeichenfolgen mit variabler Länge, die keine Elemente von Strukturen ohne erwartet den Längendeskriptor 2-Byte-sind.</span><span class="sxs-lookup"><span data-stu-id="d705e-506">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="d705e-507">Die Anzahl der gelesenen Bytes entspricht die Anzahl der Zeichen, die bereits in der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="d705e-507">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="d705e-508">Lesen aus einer Datei mithilfe der `FileGet` -Funktion erfordert `Read` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.</span><span class="sxs-lookup"><span data-stu-id="d705e-508">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="d705e-509"><paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</span><span class="sxs-lookup"><span data-stu-id="d705e-509"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="d705e-510">Dateimodus ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="d705e-510">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref decimal Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, valuetype System.Decimal&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Decimal, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="d705e-511">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-511">Required.</span></span> <span data-ttu-id="d705e-512">Eine beliebige gültige Dateinummer.</span><span class="sxs-lookup"><span data-stu-id="d705e-512">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="d705e-513">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-513">Required.</span></span> <span data-ttu-id="d705e-514">Der gültige Name einer Variablen, in die Daten gelesen werden.</span><span class="sxs-lookup"><span data-stu-id="d705e-514">Valid variable name into which data is read.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="d705e-515">Dies ist optional.</span><span class="sxs-lookup"><span data-stu-id="d705e-515">Optional.</span></span> <span data-ttu-id="d705e-516">Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), bei der der Lesevorgang beginnt.</span><span class="sxs-lookup"><span data-stu-id="d705e-516">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span></span></param>
        <summary><span data-ttu-id="d705e-517">Liest Daten aus einer offenen Datenträgerdatei in eine Variable.</span><span class="sxs-lookup"><span data-stu-id="d705e-517">Reads data from an open disk file into a variable.</span></span> <span data-ttu-id="d705e-518">Die <see langword="My" />-Funktion bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FileGet" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-518">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span></span> <span data-ttu-id="d705e-519">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-519">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d705e-520">`FileGet` gilt nur in `Random` und `Binary` Modus.</span><span class="sxs-lookup"><span data-stu-id="d705e-520">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="d705e-521">Datenlesevorgänge mit `FileGet` in der Regel in eine Datei geschrieben wird, mithilfe von `FilePut`.</span><span class="sxs-lookup"><span data-stu-id="d705e-521">Data read with `FileGet` is usually written to a file by using `FilePut`.</span></span>  
  
 <span data-ttu-id="d705e-522">Der erste Datensatz oder Byte in einer Datei befindet sich an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 usw. ist.</span><span class="sxs-lookup"><span data-stu-id="d705e-522">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="d705e-523">Wenn Sie weglassen `RecordNumber`, den nächsten Datensatz bzw. Byte nach dem letzten `FileGet` oder `FilePut` Funktion (oder verweist, zu dem letzten `Seek` Funktion) gelesen wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-523">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="d705e-524">Beim Lesen aus Dateien nicht Beurteilen der Inhalt einer Datei, die anhand der Dateinamenerweiterung.</span><span class="sxs-lookup"><span data-stu-id="d705e-524">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="d705e-525">Eine Datei mit dem Namen "Form1.vb" möglicherweise z. B. nicht über ein Visual Basic-Quelldatei.</span><span class="sxs-lookup"><span data-stu-id="d705e-525">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="d705e-526">Zufällige Modus</span><span class="sxs-lookup"><span data-stu-id="d705e-526">Random Mode</span></span>  
 <span data-ttu-id="d705e-527">Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:</span><span class="sxs-lookup"><span data-stu-id="d705e-527">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="d705e-528">Wenn die Länge des zu lesenden Daten kleiner als die Länge ist, angegeben der `RecordLength` -Klausel der `FileOpen` -Funktion, `FileGet` liest nachfolgende Datensätze Datensatzlänge.</span><span class="sxs-lookup"><span data-stu-id="d705e-528">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="d705e-529">Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt.</span><span class="sxs-lookup"><span data-stu-id="d705e-529">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="d705e-530">Da die Menge der Leerstellen Daten nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen empfiehlt sich, die Datensatzlänge der Länge der zu lesenden Daten überein.</span><span class="sxs-lookup"><span data-stu-id="d705e-530">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="d705e-531">Die Zielvariable eine Zeichenfolge ist, standardmäßig `FileGet` liest einen 2-Byte-Deskriptor, die Länge der Zeichenfolge enthält, und liest dann die Daten, die in die Variable aufgenommen wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-531">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="d705e-532">Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="d705e-532">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="d705e-533">Visual Basic 6.0 und früheren Versionen unterstützen Zeichenfolgen mit fester Länge. Wenn in einer Datei zu speichern, wird der Längendeskriptor nicht geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="d705e-533">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="d705e-534">Wenn Sie eine Zeichenfolge ohne Deskriptor lesen möchten, übergeben Sie `True` auf die `StringIsFixedLength` Parameter, und die Zeichenfolge, die Sie einlesen, sollte die richtige Länge.</span><span class="sxs-lookup"><span data-stu-id="d705e-534">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="d705e-535">Wenn die Zielvariable ein Array ist, können Sie auswählen, ob einen Deskriptor für die Größe und die Dimension des Arrays zu lesen.</span><span class="sxs-lookup"><span data-stu-id="d705e-535">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="d705e-536">Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`.</span><span class="sxs-lookup"><span data-stu-id="d705e-536">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="d705e-537">Beim Lesen des Arrays müssen Sie die Möglichkeit zu entsprechen, die das Array geschrieben wurde.</span><span class="sxs-lookup"><span data-stu-id="d705e-537">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="d705e-538">Wenn sie mit dem Deskriptor geschrieben wurde, müssen Sie den Deskriptor lesen.</span><span class="sxs-lookup"><span data-stu-id="d705e-538">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="d705e-539">Der Deskriptor nicht verwendet wird, die Größe und die Grenzen des Arrays übergebenen `FileGet` ermittelt das weitere Vorgehen zu lesen.</span><span class="sxs-lookup"><span data-stu-id="d705e-539">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="d705e-540">Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang.</span><span class="sxs-lookup"><span data-stu-id="d705e-540">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="d705e-541">Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl von Dimensionen: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="d705e-541">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="d705e-542">Die Länge des Datensatzes gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Arraydeskriptor zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="d705e-542">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="d705e-543">Die folgende Arraydeklaration erfordert z. B. 218 Bytes, wenn das Array geschrieben wird auf den Datenträger.</span><span class="sxs-lookup"><span data-stu-id="d705e-543">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="d705e-544">Die 218 Bytes werden wie folgt verteilt:</span><span class="sxs-lookup"><span data-stu-id="d705e-544">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="d705e-545">18 Bytes für den Deskriptor: (2 + 8 \* 2)</span><span class="sxs-lookup"><span data-stu-id="d705e-545">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="d705e-546">200 Bytes für die Daten: (10 * 5 * 4).</span><span class="sxs-lookup"><span data-stu-id="d705e-546">200 bytes for the data: (5 * 10 * 4).</span></span>  
  
-   <span data-ttu-id="d705e-547">Wenn die Variable in gelesen werden, andere Typen von Variablen (keine Zeichenfolge variabler Länge oder ein Objekt), `FileGet` liest nur die Daten die Variablen.</span><span class="sxs-lookup"><span data-stu-id="d705e-547">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="d705e-548">Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge der Daten, die gelesen werden können.</span><span class="sxs-lookup"><span data-stu-id="d705e-548">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="d705e-549">`FileGet` liest Sie Elemente von Strukturen, als ob einzeln gelesen wurden, mit dem Unterschied, dass keine Auffüllung zwischen Elementen vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="d705e-549">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="d705e-550">Auf dem Datenträger ein dynamisches array, in einem benutzerdefinierten Typ (mit geschriebene `FilePut`) ein Deskriptor, dessen Länge 2 plus 8 Mal der Anzahl der Dimensionen gleich, vorangestellt ist: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="d705e-550">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="d705e-551">Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes, die zum Lesen der einzelnen Elemente erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-551">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="d705e-552">Dies schließt alle Arrays und ihrer Deskriptoren.</span><span class="sxs-lookup"><span data-stu-id="d705e-552">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="d705e-553">Die `VBFixedString` Attribut angewendet werden kann, zu Zeichenfolgenfeldern in den Strukturen an, dass die Größe der Zeichenfolge beim Schreiben auf den Datenträger.</span><span class="sxs-lookup"><span data-stu-id="d705e-553">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="d705e-554">Binärmodus</span><span class="sxs-lookup"><span data-stu-id="d705e-554">Binary Mode</span></span>  
 <span data-ttu-id="d705e-555">Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` -Modus-Regeln gelten, bis auf einige Ausnahmen.</span><span class="sxs-lookup"><span data-stu-id="d705e-555">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="d705e-556">Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:</span><span class="sxs-lookup"><span data-stu-id="d705e-556">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="d705e-557">Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen.</span><span class="sxs-lookup"><span data-stu-id="d705e-557">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="d705e-558">`FileGet` Liest alle Variablen zusammenhängend vom Datenträger. d. h. ohne Auffüllung zwischen Datensätzen.</span><span class="sxs-lookup"><span data-stu-id="d705e-558">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="d705e-559">Für ein beliebiges Array als ein Array in einer Struktur `FileGet` liest nur die Daten.</span><span class="sxs-lookup"><span data-stu-id="d705e-559">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="d705e-560">Es wird kein Deskriptor gelesen.</span><span class="sxs-lookup"><span data-stu-id="d705e-560">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="d705e-561">`FileGet` liest die Zeichenfolgen mit variabler Länge, die keine Elemente von Strukturen ohne erwartet den Längendeskriptor 2-Byte-sind.</span><span class="sxs-lookup"><span data-stu-id="d705e-561">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="d705e-562">Die Anzahl der gelesenen Bytes entspricht die Anzahl der Zeichen, die bereits in der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="d705e-562">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="d705e-563">Lesen aus einer Datei mithilfe der `FileGet` -Funktion erfordert `Read` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.</span><span class="sxs-lookup"><span data-stu-id="d705e-563">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="d705e-564"><paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</span><span class="sxs-lookup"><span data-stu-id="d705e-564"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="d705e-565">Dateimodus ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="d705e-565">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref double Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, float64&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Double, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="d705e-566">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-566">Required.</span></span> <span data-ttu-id="d705e-567">Eine beliebige gültige Dateinummer.</span><span class="sxs-lookup"><span data-stu-id="d705e-567">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="d705e-568">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-568">Required.</span></span> <span data-ttu-id="d705e-569">Der gültige Name einer Variablen, in die Daten gelesen werden.</span><span class="sxs-lookup"><span data-stu-id="d705e-569">Valid variable name into which data is read.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="d705e-570">Dies ist optional.</span><span class="sxs-lookup"><span data-stu-id="d705e-570">Optional.</span></span> <span data-ttu-id="d705e-571">Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), bei der der Lesevorgang beginnt.</span><span class="sxs-lookup"><span data-stu-id="d705e-571">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span></span></param>
        <summary><span data-ttu-id="d705e-572">Liest Daten aus einer offenen Datenträgerdatei in eine Variable.</span><span class="sxs-lookup"><span data-stu-id="d705e-572">Reads data from an open disk file into a variable.</span></span> <span data-ttu-id="d705e-573">Die <see langword="My" />-Funktion bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FileGet" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-573">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span></span> <span data-ttu-id="d705e-574">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-574">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d705e-575">`FileGet` gilt nur in `Random` und `Binary` Modus.</span><span class="sxs-lookup"><span data-stu-id="d705e-575">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="d705e-576">Datenlesevorgänge mit `FileGet` in der Regel in eine Datei geschrieben wird, mithilfe von `FilePut`.</span><span class="sxs-lookup"><span data-stu-id="d705e-576">Data read with `FileGet` is usually written to a file by using `FilePut`.</span></span>  
  
 <span data-ttu-id="d705e-577">Der erste Datensatz oder Byte in einer Datei befindet sich an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 usw. ist.</span><span class="sxs-lookup"><span data-stu-id="d705e-577">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="d705e-578">Wenn Sie weglassen `RecordNumber`, den nächsten Datensatz bzw. Byte nach dem letzten `FileGet` oder `FilePut` Funktion (oder verweist, zu dem letzten `Seek` Funktion) gelesen wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-578">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="d705e-579">Beim Lesen aus Dateien nicht Beurteilen der Inhalt einer Datei, die anhand der Dateinamenerweiterung.</span><span class="sxs-lookup"><span data-stu-id="d705e-579">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="d705e-580">Eine Datei mit dem Namen "Form1.vb" möglicherweise z. B. nicht über ein Visual Basic-Quelldatei.</span><span class="sxs-lookup"><span data-stu-id="d705e-580">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="d705e-581">Zufällige Modus</span><span class="sxs-lookup"><span data-stu-id="d705e-581">Random Mode</span></span>  
 <span data-ttu-id="d705e-582">Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:</span><span class="sxs-lookup"><span data-stu-id="d705e-582">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="d705e-583">Wenn die Länge des zu lesenden Daten kleiner als die Länge ist, angegeben der `RecordLength` -Klausel der `FileOpen` -Funktion, `FileGet` liest nachfolgende Datensätze Datensatzlänge.</span><span class="sxs-lookup"><span data-stu-id="d705e-583">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="d705e-584">Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt.</span><span class="sxs-lookup"><span data-stu-id="d705e-584">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="d705e-585">Da die Menge der Leerstellen Daten nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen empfiehlt sich, die Datensatzlänge der Länge der zu lesenden Daten überein.</span><span class="sxs-lookup"><span data-stu-id="d705e-585">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="d705e-586">Die Zielvariable eine Zeichenfolge ist, standardmäßig `FileGet` liest einen 2-Byte-Deskriptor, die Länge der Zeichenfolge enthält, und liest dann die Daten, die in die Variable aufgenommen wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-586">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="d705e-587">Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="d705e-587">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="d705e-588">Visual Basic 6.0 und früheren Versionen unterstützen Zeichenfolgen mit fester Länge. Wenn in einer Datei zu speichern, wird der Längendeskriptor nicht geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="d705e-588">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="d705e-589">Wenn Sie eine Zeichenfolge ohne Deskriptor lesen möchten, übergeben Sie `True` auf die `StringIsFixedLength` Parameter, und die Zeichenfolge, die Sie einlesen, sollte die richtige Länge.</span><span class="sxs-lookup"><span data-stu-id="d705e-589">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="d705e-590">Wenn die Zielvariable ein Array ist, können Sie auswählen, ob einen Deskriptor für die Größe und die Dimension des Arrays zu lesen.</span><span class="sxs-lookup"><span data-stu-id="d705e-590">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="d705e-591">Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`.</span><span class="sxs-lookup"><span data-stu-id="d705e-591">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="d705e-592">Beim Lesen des Arrays müssen Sie die Möglichkeit zu entsprechen, die das Array geschrieben wurde.</span><span class="sxs-lookup"><span data-stu-id="d705e-592">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="d705e-593">Wenn sie mit dem Deskriptor geschrieben wurde, müssen Sie den Deskriptor lesen.</span><span class="sxs-lookup"><span data-stu-id="d705e-593">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="d705e-594">Der Deskriptor nicht verwendet wird, die Größe und die Grenzen des Arrays übergebenen `FileGet` ermittelt das weitere Vorgehen zu lesen.</span><span class="sxs-lookup"><span data-stu-id="d705e-594">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="d705e-595">Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang.</span><span class="sxs-lookup"><span data-stu-id="d705e-595">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="d705e-596">Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl von Dimensionen: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="d705e-596">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="d705e-597">Die Länge des Datensatzes gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Arraydeskriptor zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="d705e-597">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="d705e-598">Die folgende Arraydeklaration erfordert z. B. 218 Bytes, wenn das Array geschrieben wird auf den Datenträger.</span><span class="sxs-lookup"><span data-stu-id="d705e-598">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="d705e-599">Die 218 Bytes werden wie folgt verteilt:</span><span class="sxs-lookup"><span data-stu-id="d705e-599">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="d705e-600">18 Bytes für den Deskriptor: (2 + 8 \* 2)</span><span class="sxs-lookup"><span data-stu-id="d705e-600">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="d705e-601">200 Bytes für die Daten: (10 * 5 * 4).</span><span class="sxs-lookup"><span data-stu-id="d705e-601">200 bytes for the data: (5 * 10 * 4).</span></span>  
  
-   <span data-ttu-id="d705e-602">Wenn die Variable in gelesen werden, andere Typen von Variablen (keine Zeichenfolge variabler Länge oder ein Objekt), `FileGet` liest nur die Daten die Variablen.</span><span class="sxs-lookup"><span data-stu-id="d705e-602">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="d705e-603">Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge der Daten, die gelesen werden können.</span><span class="sxs-lookup"><span data-stu-id="d705e-603">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="d705e-604">`FileGet` liest Sie Elemente von Strukturen, als ob einzeln gelesen wurden, mit dem Unterschied, dass keine Auffüllung zwischen Elementen vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="d705e-604">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="d705e-605">Auf dem Datenträger ein dynamisches array, in einem benutzerdefinierten Typ (mit geschriebene `FilePut`) ein Deskriptor, dessen Länge 2 plus 8 Mal der Anzahl der Dimensionen gleich, vorangestellt ist: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="d705e-605">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="d705e-606">Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes, die zum Lesen der einzelnen Elemente erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-606">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="d705e-607">Dies schließt alle Arrays und ihrer Deskriptoren.</span><span class="sxs-lookup"><span data-stu-id="d705e-607">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="d705e-608">Die `VBFixedString` Attribut angewendet werden kann, zu Zeichenfolgenfeldern in den Strukturen an, dass die Größe der Zeichenfolge beim Schreiben auf den Datenträger.</span><span class="sxs-lookup"><span data-stu-id="d705e-608">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="d705e-609">Binärmodus</span><span class="sxs-lookup"><span data-stu-id="d705e-609">Binary Mode</span></span>  
 <span data-ttu-id="d705e-610">Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` -Modus-Regeln gelten, bis auf einige Ausnahmen.</span><span class="sxs-lookup"><span data-stu-id="d705e-610">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="d705e-611">Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:</span><span class="sxs-lookup"><span data-stu-id="d705e-611">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="d705e-612">Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen.</span><span class="sxs-lookup"><span data-stu-id="d705e-612">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="d705e-613">`FileGet` Liest alle Variablen zusammenhängend vom Datenträger. d. h. ohne Auffüllung zwischen Datensätzen.</span><span class="sxs-lookup"><span data-stu-id="d705e-613">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="d705e-614">Für ein beliebiges Array als ein Array in einer Struktur `FileGet` liest nur die Daten.</span><span class="sxs-lookup"><span data-stu-id="d705e-614">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="d705e-615">Es wird kein Deskriptor gelesen.</span><span class="sxs-lookup"><span data-stu-id="d705e-615">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="d705e-616">`FileGet` liest die Zeichenfolgen mit variabler Länge, die keine Elemente von Strukturen ohne erwartet den Längendeskriptor 2-Byte-sind.</span><span class="sxs-lookup"><span data-stu-id="d705e-616">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="d705e-617">Die Anzahl der gelesenen Bytes entspricht die Anzahl der Zeichen, die bereits in der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="d705e-617">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="d705e-618">Lesen aus einer Datei mithilfe der`FileGet` -Funktion erfordert `Read` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.</span><span class="sxs-lookup"><span data-stu-id="d705e-618">Reading from a file by using the`FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="d705e-619"><paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</span><span class="sxs-lookup"><span data-stu-id="d705e-619"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="d705e-620">Dateimodus ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="d705e-620">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref short Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int16&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Short, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="d705e-621">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-621">Required.</span></span> <span data-ttu-id="d705e-622">Eine beliebige gültige Dateinummer.</span><span class="sxs-lookup"><span data-stu-id="d705e-622">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="d705e-623">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-623">Required.</span></span> <span data-ttu-id="d705e-624">Der gültige Name einer Variablen, in die Daten gelesen werden.</span><span class="sxs-lookup"><span data-stu-id="d705e-624">Valid variable name into which data is read.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="d705e-625">Dies ist optional.</span><span class="sxs-lookup"><span data-stu-id="d705e-625">Optional.</span></span> <span data-ttu-id="d705e-626">Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), bei der der Lesevorgang beginnt.</span><span class="sxs-lookup"><span data-stu-id="d705e-626">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span></span></param>
        <summary><span data-ttu-id="d705e-627">Liest Daten aus einer offenen Datenträgerdatei in eine Variable.</span><span class="sxs-lookup"><span data-stu-id="d705e-627">Reads data from an open disk file into a variable.</span></span> <span data-ttu-id="d705e-628">Die <see langword="My" />-Funktion bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FileGet" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-628">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span></span> <span data-ttu-id="d705e-629">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-629">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d705e-630">`FileGet` gilt nur in `Random` und `Binary` Modus.</span><span class="sxs-lookup"><span data-stu-id="d705e-630">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="d705e-631">Datenlesevorgänge mit `FileGet` in der Regel in eine Datei geschrieben wird, mithilfe von `FilePut`.</span><span class="sxs-lookup"><span data-stu-id="d705e-631">Data read with `FileGet` is usually written to a file by using `FilePut`.</span></span>  
  
 <span data-ttu-id="d705e-632">Der erste Datensatz oder Byte in einer Datei befindet sich an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 usw. ist.</span><span class="sxs-lookup"><span data-stu-id="d705e-632">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="d705e-633">Wenn Sie weglassen `RecordNumber`, den nächsten Datensatz bzw. Byte nach dem letzten `FileGet` oder `FilePut` Funktion (oder verweist, zu dem letzten `Seek` Funktion) gelesen wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-633">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="d705e-634">Beim Lesen aus Dateien nicht Beurteilen der Inhalt einer Datei, die anhand der Dateinamenerweiterung.</span><span class="sxs-lookup"><span data-stu-id="d705e-634">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="d705e-635">Eine Datei mit dem Namen "Form1.vb" möglicherweise z. B. nicht über ein Visual Basic-Quelldatei.</span><span class="sxs-lookup"><span data-stu-id="d705e-635">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="d705e-636">Zufällige Modus</span><span class="sxs-lookup"><span data-stu-id="d705e-636">Random Mode</span></span>  
 <span data-ttu-id="d705e-637">Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:</span><span class="sxs-lookup"><span data-stu-id="d705e-637">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="d705e-638">Wenn die Länge des zu lesenden Daten kleiner als die Länge ist, angegeben der `RecordLength` -Klausel der `FileOpen` -Funktion, `FileGet` liest nachfolgende Datensätze Datensatzlänge.</span><span class="sxs-lookup"><span data-stu-id="d705e-638">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="d705e-639">Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt.</span><span class="sxs-lookup"><span data-stu-id="d705e-639">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="d705e-640">Da die Menge der Leerstellen Daten nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen empfiehlt sich, die Datensatzlänge der Länge der zu lesenden Daten überein.</span><span class="sxs-lookup"><span data-stu-id="d705e-640">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="d705e-641">Die Zielvariable eine Zeichenfolge ist, standardmäßig `FileGet` liest einen 2-Byte-Deskriptor, die Länge der Zeichenfolge enthält, und liest dann die Daten, die in die Variable aufgenommen wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-641">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="d705e-642">Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="d705e-642">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="d705e-643">Visual Basic 6.0 und früheren Versionen unterstützen Zeichenfolgen mit fester Länge. Wenn in einer Datei zu speichern, wird der Längendeskriptor nicht geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="d705e-643">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="d705e-644">Wenn Sie eine Zeichenfolge ohne Deskriptor lesen möchten, übergeben Sie `True` auf die `StringIsFixedLength` Parameter, und die Zeichenfolge, die Sie einlesen, sollte die richtige Länge.</span><span class="sxs-lookup"><span data-stu-id="d705e-644">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="d705e-645">Wenn die Zielvariable ein Array ist, können Sie auswählen, ob einen Deskriptor für die Größe und die Dimension des Arrays zu lesen.</span><span class="sxs-lookup"><span data-stu-id="d705e-645">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="d705e-646">Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`.</span><span class="sxs-lookup"><span data-stu-id="d705e-646">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="d705e-647">Beim Lesen des Arrays müssen Sie die Möglichkeit zu entsprechen, die das Array geschrieben wurde.</span><span class="sxs-lookup"><span data-stu-id="d705e-647">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="d705e-648">Wenn sie mit dem Deskriptor geschrieben wurde, müssen Sie den Deskriptor lesen.</span><span class="sxs-lookup"><span data-stu-id="d705e-648">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="d705e-649">Der Deskriptor nicht verwendet wird, die Größe und die Grenzen des Arrays übergebenen `FileGet` ermittelt das weitere Vorgehen zu lesen.</span><span class="sxs-lookup"><span data-stu-id="d705e-649">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="d705e-650">Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang.</span><span class="sxs-lookup"><span data-stu-id="d705e-650">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="d705e-651">Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl von Dimensionen: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="d705e-651">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="d705e-652">Die Länge des Datensatzes gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Arraydeskriptor zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="d705e-652">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="d705e-653">Die folgende Arraydeklaration erfordert z. B. 218 Bytes, wenn das Array geschrieben wird auf den Datenträger.</span><span class="sxs-lookup"><span data-stu-id="d705e-653">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="d705e-654">Die 218 Bytes werden wie folgt verteilt:</span><span class="sxs-lookup"><span data-stu-id="d705e-654">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="d705e-655">18 Bytes für den Deskriptor: (2 + 8 \* 2)</span><span class="sxs-lookup"><span data-stu-id="d705e-655">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="d705e-656">200 Bytes für die Daten: (10 * 5 * 4).</span><span class="sxs-lookup"><span data-stu-id="d705e-656">200 bytes for the data: (5 * 10 * 4).</span></span>  
  
-   <span data-ttu-id="d705e-657">Wenn die Variable in gelesen werden, andere Typen von Variablen (keine Zeichenfolge variabler Länge oder ein Objekt), `FileGet` liest nur die Daten die Variablen.</span><span class="sxs-lookup"><span data-stu-id="d705e-657">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="d705e-658">Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge der Daten, die gelesen werden können.</span><span class="sxs-lookup"><span data-stu-id="d705e-658">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="d705e-659">`FileGet` liest Sie Elemente von Strukturen, als ob einzeln gelesen wurden, mit dem Unterschied, dass keine Auffüllung zwischen Elementen vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="d705e-659">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="d705e-660">Auf dem Datenträger ein dynamisches array, in einem benutzerdefinierten Typ (mit geschriebene `FilePut`) ein Deskriptor, dessen Länge 2 plus 8 Mal der Anzahl der Dimensionen gleich, vorangestellt ist: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="d705e-660">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="d705e-661">Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes, die zum Lesen der einzelnen Elemente erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-661">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="d705e-662">Dies schließt alle Arrays und ihrer Deskriptoren.</span><span class="sxs-lookup"><span data-stu-id="d705e-662">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="d705e-663">Die `VBFixedString` Attribut angewendet werden kann, zu Zeichenfolgenfeldern in den Strukturen an, dass die Größe der Zeichenfolge beim Schreiben auf den Datenträger.</span><span class="sxs-lookup"><span data-stu-id="d705e-663">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="d705e-664">Binärmodus</span><span class="sxs-lookup"><span data-stu-id="d705e-664">Binary Mode</span></span>  
 <span data-ttu-id="d705e-665">Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` -Modus-Regeln gelten, bis auf einige Ausnahmen.</span><span class="sxs-lookup"><span data-stu-id="d705e-665">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="d705e-666">Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:</span><span class="sxs-lookup"><span data-stu-id="d705e-666">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="d705e-667">Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen.</span><span class="sxs-lookup"><span data-stu-id="d705e-667">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="d705e-668">`FileGet` Liest alle Variablen zusammenhängend vom Datenträger. d. h. ohne Auffüllung zwischen Datensätzen.</span><span class="sxs-lookup"><span data-stu-id="d705e-668">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="d705e-669">Für ein beliebiges Array als ein Array in einer Struktur `FileGet` liest nur die Daten.</span><span class="sxs-lookup"><span data-stu-id="d705e-669">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="d705e-670">Es wird kein Deskriptor gelesen.</span><span class="sxs-lookup"><span data-stu-id="d705e-670">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="d705e-671">`FileGet` liest die Zeichenfolgen mit variabler Länge, die keine Elemente von Strukturen ohne erwartet den Längendeskriptor 2-Byte-sind.</span><span class="sxs-lookup"><span data-stu-id="d705e-671">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="d705e-672">Die Anzahl der gelesenen Bytes entspricht die Anzahl der Zeichen, die bereits in der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="d705e-672">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="d705e-673">Lesen aus einer Datei mithilfe der `FileGet` -Funktion erfordert `Read` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.</span><span class="sxs-lookup"><span data-stu-id="d705e-673">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="d705e-674"><paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</span><span class="sxs-lookup"><span data-stu-id="d705e-674"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="d705e-675">Dateimodus ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="d705e-675">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref int Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int32&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Integer, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="d705e-676">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-676">Required.</span></span> <span data-ttu-id="d705e-677">Eine beliebige gültige Dateinummer.</span><span class="sxs-lookup"><span data-stu-id="d705e-677">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="d705e-678">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-678">Required.</span></span> <span data-ttu-id="d705e-679">Der gültige Name einer Variablen, in die Daten gelesen werden.</span><span class="sxs-lookup"><span data-stu-id="d705e-679">Valid variable name into which data is read.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="d705e-680">Dies ist optional.</span><span class="sxs-lookup"><span data-stu-id="d705e-680">Optional.</span></span> <span data-ttu-id="d705e-681">Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), bei der der Lesevorgang beginnt.</span><span class="sxs-lookup"><span data-stu-id="d705e-681">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span></span></param>
        <summary><span data-ttu-id="d705e-682">Liest Daten aus einer offenen Datenträgerdatei in eine Variable.</span><span class="sxs-lookup"><span data-stu-id="d705e-682">Reads data from an open disk file into a variable.</span></span> <span data-ttu-id="d705e-683">Die <see langword="My" />-Funktion bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FileGet" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-683">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span></span> <span data-ttu-id="d705e-684">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-684">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d705e-685">`FileGet` gilt nur in `Random` und `Binary` Modus.</span><span class="sxs-lookup"><span data-stu-id="d705e-685">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="d705e-686">Datenlesevorgänge mit `FileGet` in der Regel in eine Datei geschrieben wird, mithilfe von `FilePut`.</span><span class="sxs-lookup"><span data-stu-id="d705e-686">Data read with `FileGet` is usually written to a file by using `FilePut`.</span></span>  
  
 <span data-ttu-id="d705e-687">Der erste Datensatz oder Byte in einer Datei befindet sich an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 usw. ist.</span><span class="sxs-lookup"><span data-stu-id="d705e-687">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="d705e-688">Wenn Sie weglassen `RecordNumber`, den nächsten Datensatz bzw. Byte nach dem letzten `FileGet` oder `FilePut` Funktion (oder verweist, zu dem letzten `Seek` Funktion) gelesen wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-688">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="d705e-689">Beim Lesen aus Dateien nicht Beurteilen der Inhalt einer Datei, die anhand der Dateinamenerweiterung.</span><span class="sxs-lookup"><span data-stu-id="d705e-689">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="d705e-690">Eine Datei mit dem Namen "Form1.vb" möglicherweise z. B. nicht über ein Visual Basic-Quelldatei.</span><span class="sxs-lookup"><span data-stu-id="d705e-690">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="d705e-691">Zufällige Modus</span><span class="sxs-lookup"><span data-stu-id="d705e-691">Random Mode</span></span>  
 <span data-ttu-id="d705e-692">Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:</span><span class="sxs-lookup"><span data-stu-id="d705e-692">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="d705e-693">Wenn die Länge des zu lesenden Daten kleiner als die Länge ist, angegeben der `RecordLength` -Klausel der `FileOpen` -Funktion, `FileGet` liest nachfolgende Datensätze Datensatzlänge.</span><span class="sxs-lookup"><span data-stu-id="d705e-693">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="d705e-694">Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt.</span><span class="sxs-lookup"><span data-stu-id="d705e-694">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="d705e-695">Da die Menge der Leerstellen Daten nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen empfiehlt sich, die Datensatzlänge der Länge der zu lesenden Daten überein.</span><span class="sxs-lookup"><span data-stu-id="d705e-695">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="d705e-696">Die Zielvariable eine Zeichenfolge ist, standardmäßig `FileGet` liest einen 2-Byte-Deskriptor, die Länge der Zeichenfolge enthält, und liest dann die Daten, die in die Variable aufgenommen wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-696">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="d705e-697">Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="d705e-697">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="d705e-698">Visual Basic 6.0 und früheren Versionen unterstützen Zeichenfolgen mit fester Länge. Wenn in einer Datei zu speichern, wird der Längendeskriptor nicht geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="d705e-698">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="d705e-699">Wenn Sie eine Zeichenfolge ohne Deskriptor lesen möchten, übergeben Sie `True` auf die `StringIsFixedLength` Parameter, und die Zeichenfolge, die Sie einlesen, sollte die richtige Länge.</span><span class="sxs-lookup"><span data-stu-id="d705e-699">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="d705e-700">Wenn die Zielvariable ein Array ist, können Sie auswählen, ob einen Deskriptor für die Größe und die Dimension des Arrays zu lesen.</span><span class="sxs-lookup"><span data-stu-id="d705e-700">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="d705e-701">Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`.</span><span class="sxs-lookup"><span data-stu-id="d705e-701">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="d705e-702">Beim Lesen des Arrays müssen Sie die Möglichkeit zu entsprechen, die das Array geschrieben wurde.</span><span class="sxs-lookup"><span data-stu-id="d705e-702">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="d705e-703">Wenn sie mit dem Deskriptor geschrieben wurde, müssen Sie den Deskriptor lesen.</span><span class="sxs-lookup"><span data-stu-id="d705e-703">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="d705e-704">Der Deskriptor nicht verwendet wird, die Größe und die Grenzen des Arrays übergebenen `FileGet` ermittelt das weitere Vorgehen zu lesen.</span><span class="sxs-lookup"><span data-stu-id="d705e-704">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="d705e-705">Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang.</span><span class="sxs-lookup"><span data-stu-id="d705e-705">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="d705e-706">Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl von Dimensionen: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="d705e-706">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="d705e-707">Die Länge des Datensatzes gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Arraydeskriptor zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="d705e-707">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="d705e-708">Die folgende Arraydeklaration erfordert z. B. 218 Bytes, wenn das Array geschrieben wird auf den Datenträger.</span><span class="sxs-lookup"><span data-stu-id="d705e-708">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="d705e-709">Die 218 Bytes werden wie folgt verteilt:</span><span class="sxs-lookup"><span data-stu-id="d705e-709">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="d705e-710">18 Bytes für den Deskriptor: (2 + 8 \* 2)</span><span class="sxs-lookup"><span data-stu-id="d705e-710">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="d705e-711">200 Bytes für die Daten: (10 * 5 * 4).</span><span class="sxs-lookup"><span data-stu-id="d705e-711">200 bytes for the data: (5 * 10 * 4).</span></span>  
  
-   <span data-ttu-id="d705e-712">Wenn die Variable in gelesen werden, andere Typen von Variablen (keine Zeichenfolge variabler Länge oder ein Objekt), `FileGet` liest nur die Daten die Variablen.</span><span class="sxs-lookup"><span data-stu-id="d705e-712">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="d705e-713">Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge der Daten, die gelesen werden können.</span><span class="sxs-lookup"><span data-stu-id="d705e-713">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="d705e-714">`FileGet` liest Sie Elemente von Strukturen, als ob einzeln gelesen wurden, mit dem Unterschied, dass keine Auffüllung zwischen Elementen vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="d705e-714">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="d705e-715">Auf dem Datenträger ein dynamisches array, in einem benutzerdefinierten Typ (mit geschriebene `FilePut`) ein Deskriptor, dessen Länge 2 plus 8 Mal der Anzahl der Dimensionen gleich, vorangestellt ist: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="d705e-715">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="d705e-716">Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes, die zum Lesen der einzelnen Elemente erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-716">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="d705e-717">Dies schließt alle Arrays und ihrer Deskriptoren.</span><span class="sxs-lookup"><span data-stu-id="d705e-717">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="d705e-718">Die `VBFixedString` Attribut angewendet werden kann, zu Zeichenfolgenfeldern in den Strukturen an, dass die Größe der Zeichenfolge beim Schreiben auf den Datenträger.</span><span class="sxs-lookup"><span data-stu-id="d705e-718">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="d705e-719">Binärmodus</span><span class="sxs-lookup"><span data-stu-id="d705e-719">Binary Mode</span></span>  
 <span data-ttu-id="d705e-720">Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` -Modus-Regeln gelten, bis auf einige Ausnahmen.</span><span class="sxs-lookup"><span data-stu-id="d705e-720">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="d705e-721">Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:</span><span class="sxs-lookup"><span data-stu-id="d705e-721">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="d705e-722">Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen.</span><span class="sxs-lookup"><span data-stu-id="d705e-722">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="d705e-723">`FileGet` Liest alle Variablen zusammenhängend vom Datenträger. d. h. ohne Auffüllung zwischen Datensätzen.</span><span class="sxs-lookup"><span data-stu-id="d705e-723">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="d705e-724">Für ein beliebiges Array als ein Array in einer Struktur `FileGet` liest nur die Daten.</span><span class="sxs-lookup"><span data-stu-id="d705e-724">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="d705e-725">Es wird kein Deskriptor gelesen.</span><span class="sxs-lookup"><span data-stu-id="d705e-725">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="d705e-726">`FileGet` liest die Zeichenfolgen mit variabler Länge, die keine Elemente von Strukturen ohne erwartet den Längendeskriptor 2-Byte-sind.</span><span class="sxs-lookup"><span data-stu-id="d705e-726">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="d705e-727">Die Anzahl der gelesenen Bytes entspricht die Anzahl der Zeichen, die bereits in der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="d705e-727">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="d705e-728">Lesen aus einer Datei mithilfe der `FileGet` -Funktion erfordert `Read` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.</span><span class="sxs-lookup"><span data-stu-id="d705e-728">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="d705e-729"><paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</span><span class="sxs-lookup"><span data-stu-id="d705e-729"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="d705e-730">Dateimodus ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="d705e-730">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref long Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int64&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Long, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="d705e-731">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-731">Required.</span></span> <span data-ttu-id="d705e-732">Eine beliebige gültige Dateinummer.</span><span class="sxs-lookup"><span data-stu-id="d705e-732">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="d705e-733">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-733">Required.</span></span> <span data-ttu-id="d705e-734">Der gültige Name einer Variablen, in die Daten gelesen werden.</span><span class="sxs-lookup"><span data-stu-id="d705e-734">Valid variable name into which data is read.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="d705e-735">Dies ist optional.</span><span class="sxs-lookup"><span data-stu-id="d705e-735">Optional.</span></span> <span data-ttu-id="d705e-736">Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), bei der der Lesevorgang beginnt.</span><span class="sxs-lookup"><span data-stu-id="d705e-736">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span></span></param>
        <summary><span data-ttu-id="d705e-737">Liest Daten aus einer offenen Datenträgerdatei in eine Variable.</span><span class="sxs-lookup"><span data-stu-id="d705e-737">Reads data from an open disk file into a variable.</span></span> <span data-ttu-id="d705e-738">Die <see langword="My" />-Funktion bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FileGet" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-738">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span></span> <span data-ttu-id="d705e-739">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-739">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d705e-740">`FileGet` gilt nur in `Random` und `Binary` Modus.</span><span class="sxs-lookup"><span data-stu-id="d705e-740">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="d705e-741">Datenlesevorgänge mit `FileGet` in der Regel in eine Datei geschrieben wird, mithilfe von `FilePut`.</span><span class="sxs-lookup"><span data-stu-id="d705e-741">Data read with `FileGet` is usually written to a file by using `FilePut`.</span></span>  
  
 <span data-ttu-id="d705e-742">Der erste Datensatz oder Byte in einer Datei befindet sich an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 usw. ist.</span><span class="sxs-lookup"><span data-stu-id="d705e-742">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="d705e-743">Wenn Sie weglassen `RecordNumber`, den nächsten Datensatz bzw. Byte nach dem letzten `FileGet` oder `FilePut` Funktion (oder verweist, zu dem letzten `Seek` Funktion) gelesen wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-743">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="d705e-744">Beim Lesen aus Dateien nicht Beurteilen der Inhalt einer Datei, die anhand der Dateinamenerweiterung.</span><span class="sxs-lookup"><span data-stu-id="d705e-744">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="d705e-745">Eine Datei mit dem Namen "Form1.vb" möglicherweise z. B. nicht über ein Visual Basic-Quelldatei.</span><span class="sxs-lookup"><span data-stu-id="d705e-745">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="d705e-746">Zufällige Modus</span><span class="sxs-lookup"><span data-stu-id="d705e-746">Random Mode</span></span>  
 <span data-ttu-id="d705e-747">Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:</span><span class="sxs-lookup"><span data-stu-id="d705e-747">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="d705e-748">Wenn die Länge des zu lesenden Daten kleiner als die Länge ist, angegeben der `RecordLength` -Klausel der `FileOpen` -Funktion, `FileGet` liest nachfolgende Datensätze Datensatzlänge.</span><span class="sxs-lookup"><span data-stu-id="d705e-748">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="d705e-749">Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt.</span><span class="sxs-lookup"><span data-stu-id="d705e-749">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="d705e-750">Da die Menge der Leerstellen Daten nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen empfiehlt sich, die Datensatzlänge der Länge der zu lesenden Daten überein.</span><span class="sxs-lookup"><span data-stu-id="d705e-750">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="d705e-751">Die Zielvariable eine Zeichenfolge ist, standardmäßig `FileGet` liest einen 2-Byte-Deskriptor, die Länge der Zeichenfolge enthält, und liest dann die Daten, die in die Variable aufgenommen wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-751">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="d705e-752">Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="d705e-752">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="d705e-753">Visual Basic 6.0 und früheren Versionen unterstützen Zeichenfolgen mit fester Länge. Wenn in einer Datei zu speichern, wird der Längendeskriptor nicht geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="d705e-753">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="d705e-754">Wenn Sie eine Zeichenfolge ohne Deskriptor lesen möchten, übergeben Sie `True` auf die `StringIsFixedLength` Parameter, und die Zeichenfolge, die Sie einlesen, sollte die richtige Länge.</span><span class="sxs-lookup"><span data-stu-id="d705e-754">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="d705e-755">Wenn die Zielvariable ein Array ist, können Sie auswählen, ob einen Deskriptor für die Größe und die Dimension des Arrays zu lesen.</span><span class="sxs-lookup"><span data-stu-id="d705e-755">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="d705e-756">Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`.</span><span class="sxs-lookup"><span data-stu-id="d705e-756">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="d705e-757">Beim Lesen des Arrays müssen Sie die Möglichkeit zu entsprechen, die das Array geschrieben wurde.</span><span class="sxs-lookup"><span data-stu-id="d705e-757">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="d705e-758">Wenn sie mit dem Deskriptor geschrieben wurde, müssen Sie den Deskriptor lesen.</span><span class="sxs-lookup"><span data-stu-id="d705e-758">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="d705e-759">Der Deskriptor nicht verwendet wird, die Größe und die Grenzen des Arrays übergebenen `FileGet` ermittelt das weitere Vorgehen zu lesen.</span><span class="sxs-lookup"><span data-stu-id="d705e-759">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="d705e-760">Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang.</span><span class="sxs-lookup"><span data-stu-id="d705e-760">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="d705e-761">Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl von Dimensionen: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="d705e-761">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="d705e-762">Die Länge des Datensatzes gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Arraydeskriptor zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="d705e-762">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="d705e-763">Die folgende Arraydeklaration erfordert z. B. 218 Bytes, wenn das Array geschrieben wird auf den Datenträger.</span><span class="sxs-lookup"><span data-stu-id="d705e-763">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="d705e-764">Die 218 Bytes werden wie folgt verteilt:</span><span class="sxs-lookup"><span data-stu-id="d705e-764">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="d705e-765">18 Bytes für den Deskriptor: (2 + 8 \* 2)</span><span class="sxs-lookup"><span data-stu-id="d705e-765">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="d705e-766">200 Bytes für die Daten: (10 * 5 * 4).</span><span class="sxs-lookup"><span data-stu-id="d705e-766">200 bytes for the data: (5 * 10 * 4).</span></span>  
  
-   <span data-ttu-id="d705e-767">Wenn die Variable in gelesen werden, andere Typen von Variablen (keine Zeichenfolge variabler Länge oder ein Objekt), `FileGet` liest nur die Daten die Variablen.</span><span class="sxs-lookup"><span data-stu-id="d705e-767">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="d705e-768">Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge der Daten, die gelesen werden können.</span><span class="sxs-lookup"><span data-stu-id="d705e-768">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="d705e-769">`FileGet` liest Sie Elemente von Strukturen, als ob einzeln gelesen wurden, mit dem Unterschied, dass keine Auffüllung zwischen Elementen vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="d705e-769">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="d705e-770">Auf dem Datenträger ein dynamisches array, in einem benutzerdefinierten Typ (mit geschriebene `FilePut`) ein Deskriptor, dessen Länge 2 plus 8 Mal der Anzahl der Dimensionen gleich, vorangestellt ist: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="d705e-770">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="d705e-771">Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes, die zum Lesen der einzelnen Elemente erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-771">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="d705e-772">Dies schließt alle Arrays und ihrer Deskriptoren.</span><span class="sxs-lookup"><span data-stu-id="d705e-772">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="d705e-773">Die `VBFixedString` Attribut angewendet werden kann, zu Zeichenfolgenfeldern in den Strukturen an, dass die Größe der Zeichenfolge beim Schreiben auf den Datenträger.</span><span class="sxs-lookup"><span data-stu-id="d705e-773">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="d705e-774">Binärmodus</span><span class="sxs-lookup"><span data-stu-id="d705e-774">Binary Mode</span></span>  
 <span data-ttu-id="d705e-775">Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` -Modus-Regeln gelten, bis auf einige Ausnahmen.</span><span class="sxs-lookup"><span data-stu-id="d705e-775">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="d705e-776">Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:</span><span class="sxs-lookup"><span data-stu-id="d705e-776">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="d705e-777">Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen.</span><span class="sxs-lookup"><span data-stu-id="d705e-777">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="d705e-778">`FileGet` Liest alle Variablen zusammenhängend vom Datenträger. d. h. ohne Auffüllung zwischen Datensätzen.</span><span class="sxs-lookup"><span data-stu-id="d705e-778">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="d705e-779">Für ein beliebiges Array als ein Array in einer Struktur `FileGet` liest nur die Daten.</span><span class="sxs-lookup"><span data-stu-id="d705e-779">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="d705e-780">Es wird kein Deskriptor gelesen.</span><span class="sxs-lookup"><span data-stu-id="d705e-780">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="d705e-781">`FileGet` liest die Zeichenfolgen mit variabler Länge, die keine Elemente von Strukturen ohne erwartet den Längendeskriptor 2-Byte-sind.</span><span class="sxs-lookup"><span data-stu-id="d705e-781">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="d705e-782">Die Anzahl der gelesenen Bytes entspricht die Anzahl der Zeichen, die bereits in der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="d705e-782">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="d705e-783">Lesen aus einer Datei mithilfe der `FileGet` -Funktion erfordert `Read` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.</span><span class="sxs-lookup"><span data-stu-id="d705e-783">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="d705e-784"><paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</span><span class="sxs-lookup"><span data-stu-id="d705e-784"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="d705e-785">Dateimodus ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="d705e-785">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref float Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, float32&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Single, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="d705e-786">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-786">Required.</span></span> <span data-ttu-id="d705e-787">Eine beliebige gültige Dateinummer.</span><span class="sxs-lookup"><span data-stu-id="d705e-787">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="d705e-788">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-788">Required.</span></span> <span data-ttu-id="d705e-789">Der gültige Name einer Variablen, in die Daten gelesen werden.</span><span class="sxs-lookup"><span data-stu-id="d705e-789">Valid variable name into which data is read.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="d705e-790">Dies ist optional.</span><span class="sxs-lookup"><span data-stu-id="d705e-790">Optional.</span></span> <span data-ttu-id="d705e-791">Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), bei der der Lesevorgang beginnt.</span><span class="sxs-lookup"><span data-stu-id="d705e-791">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span></span></param>
        <summary><span data-ttu-id="d705e-792">Liest Daten aus einer offenen Datenträgerdatei in eine Variable.</span><span class="sxs-lookup"><span data-stu-id="d705e-792">Reads data from an open disk file into a variable.</span></span> <span data-ttu-id="d705e-793">Die <see langword="My" />-Funktion bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FileGet" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-793">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span></span> <span data-ttu-id="d705e-794">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-794">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d705e-795">`FileGet` gilt nur in `Random` und `Binary` Modus.</span><span class="sxs-lookup"><span data-stu-id="d705e-795">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="d705e-796">Datenlesevorgänge mit `FileGet` in der Regel in eine Datei geschrieben wird, mithilfe von `FilePut`.</span><span class="sxs-lookup"><span data-stu-id="d705e-796">Data read with `FileGet` is usually written to a file by using `FilePut`.</span></span>  
  
 <span data-ttu-id="d705e-797">Der erste Datensatz oder Byte in einer Datei befindet sich an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 usw. ist.</span><span class="sxs-lookup"><span data-stu-id="d705e-797">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="d705e-798">Wenn Sie weglassen `RecordNumber`, den nächsten Datensatz bzw. Byte nach dem letzten `FileGet` oder `FilePut` Funktion (oder verweist, zu dem letzten `Seek` Funktion) gelesen wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-798">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="d705e-799">Beim Lesen aus Dateien nicht Beurteilen der Inhalt einer Datei, die anhand der Dateinamenerweiterung.</span><span class="sxs-lookup"><span data-stu-id="d705e-799">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="d705e-800">Eine Datei mit dem Namen "Form1.vb" möglicherweise z. B. nicht über ein Visual Basic-Quelldatei.</span><span class="sxs-lookup"><span data-stu-id="d705e-800">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="d705e-801">Zufällige Modus</span><span class="sxs-lookup"><span data-stu-id="d705e-801">Random Mode</span></span>  
 <span data-ttu-id="d705e-802">Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:</span><span class="sxs-lookup"><span data-stu-id="d705e-802">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="d705e-803">Wenn die Länge des zu lesenden Daten kleiner als die Länge ist, angegeben der `RecordLength` -Klausel der `FileOpen` -Funktion, `FileGet` liest nachfolgende Datensätze Datensatzlänge.</span><span class="sxs-lookup"><span data-stu-id="d705e-803">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="d705e-804">Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt.</span><span class="sxs-lookup"><span data-stu-id="d705e-804">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="d705e-805">Da die Menge der Leerstellen Daten nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen empfiehlt sich, die Datensatzlänge der Länge der zu lesenden Daten überein.</span><span class="sxs-lookup"><span data-stu-id="d705e-805">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="d705e-806">Die Zielvariable eine Zeichenfolge ist, standardmäßig `FileGet` liest einen 2-Byte-Deskriptor, die Länge der Zeichenfolge enthält, und liest dann die Daten, die in die Variable aufgenommen wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-806">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="d705e-807">Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="d705e-807">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="d705e-808">Visual Basic 6.0 und früheren Versionen unterstützen Zeichenfolgen mit fester Länge. Wenn in einer Datei zu speichern, wird der Längendeskriptor nicht geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="d705e-808">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="d705e-809">Wenn Sie eine Zeichenfolge ohne Deskriptor lesen möchten, übergeben Sie `True` auf die `StringIsFixedLength` Parameter, und die Zeichenfolge, die Sie einlesen, sollte die richtige Länge.</span><span class="sxs-lookup"><span data-stu-id="d705e-809">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="d705e-810">Wenn die Zielvariable ein Array ist, können Sie auswählen, ob einen Deskriptor für die Größe und die Dimension des Arrays zu lesen.</span><span class="sxs-lookup"><span data-stu-id="d705e-810">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="d705e-811">Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`.</span><span class="sxs-lookup"><span data-stu-id="d705e-811">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="d705e-812">Beim Lesen des Arrays müssen Sie die Möglichkeit zu entsprechen, die das Array geschrieben wurde.</span><span class="sxs-lookup"><span data-stu-id="d705e-812">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="d705e-813">Wenn sie mit dem Deskriptor geschrieben wurde, müssen Sie den Deskriptor lesen.</span><span class="sxs-lookup"><span data-stu-id="d705e-813">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="d705e-814">Der Deskriptor nicht verwendet wird, die Größe und die Grenzen des Arrays übergebenen `FileGet` ermittelt das weitere Vorgehen zu lesen.</span><span class="sxs-lookup"><span data-stu-id="d705e-814">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="d705e-815">Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang.</span><span class="sxs-lookup"><span data-stu-id="d705e-815">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="d705e-816">Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl von Dimensionen: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="d705e-816">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="d705e-817">Die Länge des Datensatzes gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Arraydeskriptor zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="d705e-817">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="d705e-818">Die folgende Arraydeklaration erfordert z. B. 218 Bytes, wenn das Array geschrieben wird auf den Datenträger.</span><span class="sxs-lookup"><span data-stu-id="d705e-818">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="d705e-819">Die 218 Bytes werden wie folgt verteilt:</span><span class="sxs-lookup"><span data-stu-id="d705e-819">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="d705e-820">18 Bytes für den Deskriptor: (2 + 8 \* 2)</span><span class="sxs-lookup"><span data-stu-id="d705e-820">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="d705e-821">200 Bytes für die Daten: (10 * 5 * 4).</span><span class="sxs-lookup"><span data-stu-id="d705e-821">200 bytes for the data: (5 * 10 * 4).</span></span>  
  
-   <span data-ttu-id="d705e-822">Wenn die Variable in gelesen werden, andere Typen von Variablen (keine Zeichenfolge variabler Länge oder ein Objekt), `FileGet` liest nur die Daten die Variablen.</span><span class="sxs-lookup"><span data-stu-id="d705e-822">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="d705e-823">Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge der Daten, die gelesen werden können.</span><span class="sxs-lookup"><span data-stu-id="d705e-823">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="d705e-824">`FileGet` liest Sie Elemente von Strukturen, als ob einzeln gelesen wurden, mit dem Unterschied, dass keine Auffüllung zwischen Elementen vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="d705e-824">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="d705e-825">Auf dem Datenträger ein dynamisches array, in einem benutzerdefinierten Typ (mit geschriebene `FilePut`) ein Deskriptor, dessen Länge 2 plus 8 Mal der Anzahl der Dimensionen gleich, vorangestellt ist: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="d705e-825">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="d705e-826">Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes, die zum Lesen der einzelnen Elemente erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-826">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="d705e-827">Dies schließt alle Arrays und ihrer Deskriptoren.</span><span class="sxs-lookup"><span data-stu-id="d705e-827">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="d705e-828">Die `VBFixedString` Attribut angewendet werden kann, zu Zeichenfolgenfeldern in den Strukturen an, dass die Größe der Zeichenfolge beim Schreiben auf den Datenträger.</span><span class="sxs-lookup"><span data-stu-id="d705e-828">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="d705e-829">Binärmodus</span><span class="sxs-lookup"><span data-stu-id="d705e-829">Binary Mode</span></span>  
 <span data-ttu-id="d705e-830">Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` -Modus-Regeln gelten, bis auf einige Ausnahmen.</span><span class="sxs-lookup"><span data-stu-id="d705e-830">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="d705e-831">Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:</span><span class="sxs-lookup"><span data-stu-id="d705e-831">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="d705e-832">Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen.</span><span class="sxs-lookup"><span data-stu-id="d705e-832">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="d705e-833">`FileGet` Liest alle Variablen zusammenhängend vom Datenträger. d. h. ohne Auffüllung zwischen Datensätzen.</span><span class="sxs-lookup"><span data-stu-id="d705e-833">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="d705e-834">Für ein beliebiges Array als ein Array in einer Struktur `FileGet` liest nur die Daten.</span><span class="sxs-lookup"><span data-stu-id="d705e-834">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="d705e-835">Es wird kein Deskriptor gelesen.</span><span class="sxs-lookup"><span data-stu-id="d705e-835">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="d705e-836">`FileGet` liest die Zeichenfolgen mit variabler Länge, die keine Elemente von Strukturen ohne erwartet den Längendeskriptor 2-Byte-sind.</span><span class="sxs-lookup"><span data-stu-id="d705e-836">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="d705e-837">Die Anzahl der gelesenen Bytes entspricht die Anzahl der Zeichen, die bereits in der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="d705e-837">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="d705e-838">Lesen aus einer Datei mithilfe der `FileGet` -Funktion erfordert `Read` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.</span><span class="sxs-lookup"><span data-stu-id="d705e-838">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="d705e-839"><paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</span><span class="sxs-lookup"><span data-stu-id="d705e-839"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="d705e-840">Dateimodus ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="d705e-840">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref ValueType Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, class System.ValueType&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As ValueType, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.ValueType&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="d705e-841">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-841">Required.</span></span> <span data-ttu-id="d705e-842">Eine beliebige gültige Dateinummer.</span><span class="sxs-lookup"><span data-stu-id="d705e-842">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="d705e-843">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-843">Required.</span></span> <span data-ttu-id="d705e-844">Der gültige Name einer Variablen, in die Daten gelesen werden.</span><span class="sxs-lookup"><span data-stu-id="d705e-844">Valid variable name into which data is read.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="d705e-845">Dies ist optional.</span><span class="sxs-lookup"><span data-stu-id="d705e-845">Optional.</span></span> <span data-ttu-id="d705e-846">Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), bei der der Lesevorgang beginnt.</span><span class="sxs-lookup"><span data-stu-id="d705e-846">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span></span></param>
        <summary><span data-ttu-id="d705e-847">Liest Daten aus einer offenen Datenträgerdatei in eine Variable.</span><span class="sxs-lookup"><span data-stu-id="d705e-847">Reads data from an open disk file into a variable.</span></span> <span data-ttu-id="d705e-848">Die <see langword="My" />-Funktion bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FileGet" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-848">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span></span> <span data-ttu-id="d705e-849">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-849">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d705e-850">`FileGet` gilt nur in `Random` und `Binary` Modus.</span><span class="sxs-lookup"><span data-stu-id="d705e-850">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="d705e-851">Datenlesevorgänge mit `FileGet` in der Regel in eine Datei geschrieben wird, mithilfe von `FilePut`.</span><span class="sxs-lookup"><span data-stu-id="d705e-851">Data read with `FileGet` is usually written to a file by using `FilePut`.</span></span>  
  
 <span data-ttu-id="d705e-852">Der erste Datensatz oder Byte in einer Datei befindet sich an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 usw. ist.</span><span class="sxs-lookup"><span data-stu-id="d705e-852">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="d705e-853">Wenn Sie weglassen `RecordNumber`, den nächsten Datensatz bzw. Byte nach dem letzten `FileGet` oder `FilePut` Funktion (oder verweist, zu dem letzten `Seek` Funktion) gelesen wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-853">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="d705e-854">Beim Lesen aus Dateien nicht Beurteilen der Inhalt einer Datei, die anhand der Dateinamenerweiterung.</span><span class="sxs-lookup"><span data-stu-id="d705e-854">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="d705e-855">Eine Datei mit dem Namen "Form1.vb" möglicherweise z. B. nicht über ein Visual Basic-Quelldatei.</span><span class="sxs-lookup"><span data-stu-id="d705e-855">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="d705e-856">Zufällige Modus</span><span class="sxs-lookup"><span data-stu-id="d705e-856">Random Mode</span></span>  
 <span data-ttu-id="d705e-857">Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:</span><span class="sxs-lookup"><span data-stu-id="d705e-857">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="d705e-858">Wenn die Länge des zu lesenden Daten kleiner als die Länge ist, angegeben der `RecordLength` -Klausel der `FileOpen` -Funktion, `FileGet` liest nachfolgende Datensätze Datensatzlänge.</span><span class="sxs-lookup"><span data-stu-id="d705e-858">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="d705e-859">Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt.</span><span class="sxs-lookup"><span data-stu-id="d705e-859">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="d705e-860">Da die Menge der Leerstellen Daten nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen empfiehlt sich, die Datensatzlänge der Länge der zu lesenden Daten überein.</span><span class="sxs-lookup"><span data-stu-id="d705e-860">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="d705e-861">Die Zielvariable eine Zeichenfolge ist, standardmäßig `FileGet` liest einen 2-Byte-Deskriptor, die Länge der Zeichenfolge enthält, und liest dann die Daten, die in die Variable aufgenommen wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-861">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="d705e-862">Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="d705e-862">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="d705e-863">Visual Basic 6.0 und früheren Versionen unterstützen Zeichenfolgen mit fester Länge. Wenn in einer Datei zu speichern, wird der Längendeskriptor nicht geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="d705e-863">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="d705e-864">Wenn Sie eine Zeichenfolge ohne Deskriptor lesen möchten, übergeben Sie `True` auf die `StringIsFixedLength` Parameter, und die Zeichenfolge, die Sie einlesen, sollte die richtige Länge.</span><span class="sxs-lookup"><span data-stu-id="d705e-864">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="d705e-865">Wenn die Zielvariable ein Array ist, können Sie auswählen, ob einen Deskriptor für die Größe und die Dimension des Arrays zu lesen.</span><span class="sxs-lookup"><span data-stu-id="d705e-865">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="d705e-866">Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`.</span><span class="sxs-lookup"><span data-stu-id="d705e-866">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="d705e-867">Beim Lesen des Arrays müssen Sie die Möglichkeit zu entsprechen, die das Array geschrieben wurde.</span><span class="sxs-lookup"><span data-stu-id="d705e-867">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="d705e-868">Wenn sie mit dem Deskriptor geschrieben wurde, müssen Sie den Deskriptor lesen.</span><span class="sxs-lookup"><span data-stu-id="d705e-868">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="d705e-869">Der Deskriptor nicht verwendet wird, die Größe und die Grenzen des Arrays übergebenen `FileGet` ermittelt das weitere Vorgehen zu lesen.</span><span class="sxs-lookup"><span data-stu-id="d705e-869">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="d705e-870">Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang.</span><span class="sxs-lookup"><span data-stu-id="d705e-870">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="d705e-871">Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl von Dimensionen: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="d705e-871">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="d705e-872">Die Länge des Datensatzes gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Arraydeskriptor zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="d705e-872">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="d705e-873">Die folgende Arraydeklaration erfordert z. B. 218 Bytes, wenn das Array geschrieben wird auf den Datenträger.</span><span class="sxs-lookup"><span data-stu-id="d705e-873">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="d705e-874">Die 218 Bytes werden wie folgt verteilt:</span><span class="sxs-lookup"><span data-stu-id="d705e-874">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="d705e-875">18 Bytes für den Deskriptor: (2 + 8 \* 2)</span><span class="sxs-lookup"><span data-stu-id="d705e-875">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="d705e-876">200 Bytes für die Daten: (10 * 5 * 4).</span><span class="sxs-lookup"><span data-stu-id="d705e-876">200 bytes for the data: (5 * 10 * 4).</span></span>  
  
-   <span data-ttu-id="d705e-877">Wenn die Variable in gelesen werden, andere Typen von Variablen (keine Zeichenfolge variabler Länge oder ein Objekt), `FileGet` liest nur die Daten die Variablen.</span><span class="sxs-lookup"><span data-stu-id="d705e-877">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="d705e-878">Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge der Daten, die gelesen werden können.</span><span class="sxs-lookup"><span data-stu-id="d705e-878">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="d705e-879">`FileGet` liest Sie Elemente von Strukturen, als ob einzeln gelesen wurden, mit dem Unterschied, dass keine Auffüllung zwischen Elementen vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="d705e-879">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="d705e-880">Auf dem Datenträger ein dynamisches array, in einem benutzerdefinierten Typ (mit geschriebene `FilePut`) ein Deskriptor, dessen Länge 2 plus 8 Mal der Anzahl der Dimensionen gleich, vorangestellt ist: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="d705e-880">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="d705e-881">Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes, die zum Lesen der einzelnen Elemente erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-881">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="d705e-882">Dies schließt alle Arrays und ihrer Deskriptoren.</span><span class="sxs-lookup"><span data-stu-id="d705e-882">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="d705e-883">Die `VBFixedString` Attribut angewendet werden kann, zu Zeichenfolgenfeldern in den Strukturen an, dass die Größe der Zeichenfolge beim Schreiben auf den Datenträger.</span><span class="sxs-lookup"><span data-stu-id="d705e-883">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="d705e-884">Binärmodus</span><span class="sxs-lookup"><span data-stu-id="d705e-884">Binary Mode</span></span>  
 <span data-ttu-id="d705e-885">Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` -Modus-Regeln gelten, bis auf einige Ausnahmen.</span><span class="sxs-lookup"><span data-stu-id="d705e-885">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="d705e-886">Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:</span><span class="sxs-lookup"><span data-stu-id="d705e-886">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="d705e-887">Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen.</span><span class="sxs-lookup"><span data-stu-id="d705e-887">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="d705e-888">`FileGet` Liest alle Variablen zusammenhängend vom Datenträger. d. h. ohne Auffüllung zwischen Datensätzen.</span><span class="sxs-lookup"><span data-stu-id="d705e-888">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="d705e-889">Für ein beliebiges Array als ein Array in einer Struktur `FileGet` liest nur die Daten.</span><span class="sxs-lookup"><span data-stu-id="d705e-889">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="d705e-890">Es wird kein Deskriptor gelesen.</span><span class="sxs-lookup"><span data-stu-id="d705e-890">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="d705e-891">`FileGet` liest die Zeichenfolgen mit variabler Länge, die keine Elemente von Strukturen ohne erwartet den Längendeskriptor 2-Byte-sind.</span><span class="sxs-lookup"><span data-stu-id="d705e-891">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="d705e-892">Die Anzahl der gelesenen Bytes entspricht die Anzahl der Zeichen, die bereits in der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="d705e-892">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="d705e-893">Lesen aus einer Datei mithilfe der `FileGet` -Funktion erfordert `Read` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.</span><span class="sxs-lookup"><span data-stu-id="d705e-893">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="d705e-894"><paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</span><span class="sxs-lookup"><span data-stu-id="d705e-894"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="d705e-895">Dateimodus ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="d705e-895">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref string Value, long RecordNumber = -1, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, string&amp; Value, int64 RecordNumber, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As String, Optional RecordNumber As Long = -1, Optional StringIsFixedLength As Boolean = false)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="d705e-896">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-896">Required.</span></span> <span data-ttu-id="d705e-897">Eine beliebige gültige Dateinummer.</span><span class="sxs-lookup"><span data-stu-id="d705e-897">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="d705e-898">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-898">Required.</span></span> <span data-ttu-id="d705e-899">Der gültige Name einer Variablen, in die Daten gelesen werden.</span><span class="sxs-lookup"><span data-stu-id="d705e-899">Valid variable name into which data is read.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="d705e-900">Dies ist optional.</span><span class="sxs-lookup"><span data-stu-id="d705e-900">Optional.</span></span> <span data-ttu-id="d705e-901">Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), bei der der Lesevorgang beginnt.</span><span class="sxs-lookup"><span data-stu-id="d705e-901">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span></span></param>
        <param name="StringIsFixedLength"><span data-ttu-id="d705e-902">Dies ist optional.</span><span class="sxs-lookup"><span data-stu-id="d705e-902">Optional.</span></span> <span data-ttu-id="d705e-903">Betrifft nur das Schreiben einer Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="d705e-903">Applies only when writing a string.</span></span> <span data-ttu-id="d705e-904">Gibt an, ob ein 2-Byte-Deskriptor für die Zeichenfolge geschrieben werden soll, der die Länge beschreibt.</span><span class="sxs-lookup"><span data-stu-id="d705e-904">Specifies whether to write a two-byte descriptor for the string that describes the length.</span></span> <span data-ttu-id="d705e-905">Der Standardwert ist <see langword="False" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-905">The default is <see langword="False" />.</span></span></param>
        <summary><span data-ttu-id="d705e-906">Liest Daten aus einer offenen Datenträgerdatei in eine Variable.</span><span class="sxs-lookup"><span data-stu-id="d705e-906">Reads data from an open disk file into a variable.</span></span> <span data-ttu-id="d705e-907">Die <see langword="My" />-Funktion bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FileGet" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-907">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span></span> <span data-ttu-id="d705e-908">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-908">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d705e-909">`FileGet` gilt nur in `Random` und `Binary` Modus.</span><span class="sxs-lookup"><span data-stu-id="d705e-909">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="d705e-910">Datenlesevorgänge mit `FileGet` in der Regel in eine Datei geschrieben wird, mithilfe von `FilePut`.</span><span class="sxs-lookup"><span data-stu-id="d705e-910">Data read with `FileGet` is usually written to a file by using `FilePut`.</span></span>  
  
 <span data-ttu-id="d705e-911">Der erste Datensatz oder Byte in einer Datei befindet sich an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 usw. ist.</span><span class="sxs-lookup"><span data-stu-id="d705e-911">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="d705e-912">Wenn Sie weglassen `RecordNumber`, den nächsten Datensatz bzw. Byte nach dem letzten `FileGet` oder `FilePut` Funktion (oder verweist, zu dem letzten `Seek` Funktion) gelesen wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-912">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="d705e-913">Beim Lesen aus Dateien nicht Beurteilen der Inhalt einer Datei, die anhand der Dateinamenerweiterung.</span><span class="sxs-lookup"><span data-stu-id="d705e-913">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="d705e-914">Eine Datei mit dem Namen "Form1.vb" möglicherweise z. B. nicht über ein Visual Basic-Quelldatei.</span><span class="sxs-lookup"><span data-stu-id="d705e-914">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="d705e-915">Zufällige Modus</span><span class="sxs-lookup"><span data-stu-id="d705e-915">Random Mode</span></span>  
 <span data-ttu-id="d705e-916">Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:</span><span class="sxs-lookup"><span data-stu-id="d705e-916">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="d705e-917">Wenn die Länge des zu lesenden Daten kleiner als die Länge ist, angegeben der `RecordLength` -Klausel der `FileOpen` -Funktion, `FileGet` liest nachfolgende Datensätze Datensatzlänge.</span><span class="sxs-lookup"><span data-stu-id="d705e-917">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="d705e-918">Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt.</span><span class="sxs-lookup"><span data-stu-id="d705e-918">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="d705e-919">Da die Menge der Leerstellen Daten nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen empfiehlt sich, die Datensatzlänge der Länge der zu lesenden Daten überein.</span><span class="sxs-lookup"><span data-stu-id="d705e-919">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="d705e-920">Die Zielvariable eine Zeichenfolge ist, standardmäßig `FileGet` liest einen 2-Byte-Deskriptor, die Länge der Zeichenfolge enthält, und liest dann die Daten, die in die Variable aufgenommen wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-920">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="d705e-921">Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="d705e-921">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="d705e-922">Visual Basic 6.0 und früheren Versionen unterstützen Zeichenfolgen mit fester Länge. Wenn in einer Datei zu speichern, wird der Längendeskriptor nicht geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="d705e-922">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="d705e-923">Wenn Sie eine Zeichenfolge ohne Deskriptor lesen möchten, übergeben Sie `True` auf die `StringIsFixedLength` Parameter, und die Zeichenfolge, die Sie einlesen, sollte die richtige Länge.</span><span class="sxs-lookup"><span data-stu-id="d705e-923">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="d705e-924">Wenn die Zielvariable ein Array ist, können Sie auswählen, ob einen Deskriptor für die Größe und die Dimension des Arrays zu lesen.</span><span class="sxs-lookup"><span data-stu-id="d705e-924">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="d705e-925">Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`.</span><span class="sxs-lookup"><span data-stu-id="d705e-925">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="d705e-926">Beim Lesen des Arrays müssen Sie die Möglichkeit zu entsprechen, die das Array geschrieben wurde.</span><span class="sxs-lookup"><span data-stu-id="d705e-926">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="d705e-927">Wenn sie mit dem Deskriptor geschrieben wurde, müssen Sie den Deskriptor lesen.</span><span class="sxs-lookup"><span data-stu-id="d705e-927">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="d705e-928">Der Deskriptor nicht verwendet wird, die Größe und die Grenzen des Arrays übergebenen `FileGet` ermittelt das weitere Vorgehen zu lesen.</span><span class="sxs-lookup"><span data-stu-id="d705e-928">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="d705e-929">Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang.</span><span class="sxs-lookup"><span data-stu-id="d705e-929">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="d705e-930">Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl von Dimensionen: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="d705e-930">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="d705e-931">Die Länge des Datensatzes gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Arraydeskriptor zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="d705e-931">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="d705e-932">Die folgende Arraydeklaration erfordert z. B. 218 Bytes, wenn das Array geschrieben wird auf den Datenträger.</span><span class="sxs-lookup"><span data-stu-id="d705e-932">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="d705e-933">Die 218 Bytes werden wie folgt verteilt:</span><span class="sxs-lookup"><span data-stu-id="d705e-933">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="d705e-934">18 Bytes für den Deskriptor: (2 + 8 \* 2)</span><span class="sxs-lookup"><span data-stu-id="d705e-934">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="d705e-935">200 Bytes für die Daten: (10 * 5 * 4).</span><span class="sxs-lookup"><span data-stu-id="d705e-935">200 bytes for the data: (5 * 10 * 4).</span></span>  
  
-   <span data-ttu-id="d705e-936">Wenn die Variable in gelesen werden, andere Typen von Variablen (keine Zeichenfolge variabler Länge oder ein Objekt), `FileGet` liest nur die Daten die Variablen.</span><span class="sxs-lookup"><span data-stu-id="d705e-936">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="d705e-937">Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge der Daten, die gelesen werden können.</span><span class="sxs-lookup"><span data-stu-id="d705e-937">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="d705e-938">`FileGet` liest Sie Elemente von Strukturen, als ob einzeln gelesen wurden, mit dem Unterschied, dass keine Auffüllung zwischen Elementen vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="d705e-938">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="d705e-939">Auf dem Datenträger ein dynamisches array, in einem benutzerdefinierten Typ (mit geschriebene `FilePut`) ein Deskriptor, dessen Länge 2 plus 8 Mal der Anzahl der Dimensionen gleich, vorangestellt ist: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="d705e-939">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="d705e-940">Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes, die zum Lesen der einzelnen Elemente erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-940">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="d705e-941">Dies schließt alle Arrays und ihrer Deskriptoren.</span><span class="sxs-lookup"><span data-stu-id="d705e-941">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="d705e-942">Die `VBFixedString` Attribut angewendet werden kann, zu Zeichenfolgenfeldern in den Strukturen an, dass die Größe der Zeichenfolge beim Schreiben auf den Datenträger.</span><span class="sxs-lookup"><span data-stu-id="d705e-942">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="d705e-943">Binärmodus</span><span class="sxs-lookup"><span data-stu-id="d705e-943">Binary Mode</span></span>  
 <span data-ttu-id="d705e-944">Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` -Modus-Regeln gelten, bis auf einige Ausnahmen.</span><span class="sxs-lookup"><span data-stu-id="d705e-944">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="d705e-945">Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:</span><span class="sxs-lookup"><span data-stu-id="d705e-945">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="d705e-946">Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen.</span><span class="sxs-lookup"><span data-stu-id="d705e-946">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="d705e-947">`FileGet` Liest alle Variablen zusammenhängend vom Datenträger. d. h. ohne Auffüllung zwischen Datensätzen.</span><span class="sxs-lookup"><span data-stu-id="d705e-947">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="d705e-948">Für ein beliebiges Array als ein Array in einer Struktur `FileGet` liest nur die Daten.</span><span class="sxs-lookup"><span data-stu-id="d705e-948">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="d705e-949">Es wird kein Deskriptor gelesen.</span><span class="sxs-lookup"><span data-stu-id="d705e-949">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="d705e-950">`FileGet` liest die Zeichenfolgen mit variabler Länge, die keine Elemente von Strukturen ohne erwartet den Längendeskriptor 2-Byte-sind.</span><span class="sxs-lookup"><span data-stu-id="d705e-950">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="d705e-951">Die Anzahl der gelesenen Bytes entspricht die Anzahl der Zeichen, die bereits in der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="d705e-951">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="d705e-952">Lesen aus einer Datei mithilfe der `FileGet` -Funktion erfordert `Read` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.</span><span class="sxs-lookup"><span data-stu-id="d705e-952">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="d705e-953"><paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</span><span class="sxs-lookup"><span data-stu-id="d705e-953"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="d705e-954">Dateimodus ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="d705e-954">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, class System.Array&amp; Value, int64 RecordNumber, bool ArrayIsDynamic, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Array, Optional RecordNumber As Long = -1, Optional ArrayIsDynamic As Boolean = false, Optional StringIsFixedLength As Boolean = false)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Array&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="ArrayIsDynamic" Type="System.Boolean" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="d705e-955">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-955">Required.</span></span> <span data-ttu-id="d705e-956">Eine beliebige gültige Dateinummer.</span><span class="sxs-lookup"><span data-stu-id="d705e-956">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="d705e-957">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-957">Required.</span></span> <span data-ttu-id="d705e-958">Der gültige Name einer Variablen, in die Daten gelesen werden.</span><span class="sxs-lookup"><span data-stu-id="d705e-958">Valid variable name into which data is read.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="d705e-959">Dies ist optional.</span><span class="sxs-lookup"><span data-stu-id="d705e-959">Optional.</span></span> <span data-ttu-id="d705e-960">Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), bei der der Lesevorgang beginnt.</span><span class="sxs-lookup"><span data-stu-id="d705e-960">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span></span></param>
        <param name="ArrayIsDynamic"><span data-ttu-id="d705e-961">Dies ist optional.</span><span class="sxs-lookup"><span data-stu-id="d705e-961">Optional.</span></span> <span data-ttu-id="d705e-962">Betrifft nur das Schreiben eines Arrays.</span><span class="sxs-lookup"><span data-stu-id="d705e-962">Applies only when writing an array.</span></span> <span data-ttu-id="d705e-963">Gibt an, ob das Array als dynamisches Array behandelt werden soll und ein Arraydeskriptor erforderlich ist, der die Größe und die Begrenzungen des Arrays beschreibt.</span><span class="sxs-lookup"><span data-stu-id="d705e-963">Specifies whether the array is to be treated as dynamic and whether an array descriptor describing the size and bounds of the array is necessary.</span></span></param>
        <param name="StringIsFixedLength"><span data-ttu-id="d705e-964">Dies ist optional.</span><span class="sxs-lookup"><span data-stu-id="d705e-964">Optional.</span></span> <span data-ttu-id="d705e-965">Betrifft nur das Schreiben einer Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="d705e-965">Applies only when writing a string.</span></span> <span data-ttu-id="d705e-966">Gibt an, ob ein 2-Byte-Deskriptor für die Zeichenfolge geschrieben werden soll, der die Länge beschreibt.</span><span class="sxs-lookup"><span data-stu-id="d705e-966">Specifies whether to write a two-byte descriptor for the string that describes the length.</span></span> <span data-ttu-id="d705e-967">Der Standardwert ist <see langword="False" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-967">The default is <see langword="False" />.</span></span></param>
        <summary><span data-ttu-id="d705e-968">Liest Daten aus einer offenen Datenträgerdatei in eine Variable.</span><span class="sxs-lookup"><span data-stu-id="d705e-968">Reads data from an open disk file into a variable.</span></span> <span data-ttu-id="d705e-969">Die <see langword="My" />-Funktion bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FileGet" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-969">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span></span> <span data-ttu-id="d705e-970">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-970">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d705e-971">`FileGet` gilt nur in `Random` und `Binary` Modus.</span><span class="sxs-lookup"><span data-stu-id="d705e-971">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="d705e-972">Datenlesevorgänge mit `FileGet` in der Regel in eine Datei geschrieben wird, mithilfe von `FilePut`.</span><span class="sxs-lookup"><span data-stu-id="d705e-972">Data read with `FileGet` is usually written to a file by using `FilePut`.</span></span>  
  
 <span data-ttu-id="d705e-973">Der erste Datensatz oder Byte in einer Datei befindet sich an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 usw. ist.</span><span class="sxs-lookup"><span data-stu-id="d705e-973">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="d705e-974">Wenn Sie weglassen `RecordNumber`, den nächsten Datensatz bzw. Byte nach dem letzten `FileGet` oder `FilePut` Funktion (oder verweist, zu dem letzten `Seek` Funktion) gelesen wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-974">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="d705e-975">Beim Lesen aus Dateien nicht Beurteilen der Inhalt einer Datei, die anhand der Dateinamenerweiterung.</span><span class="sxs-lookup"><span data-stu-id="d705e-975">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="d705e-976">Eine Datei mit dem Namen "Form1.vb" möglicherweise z. B. nicht über ein Visual Basic-Quelldatei.</span><span class="sxs-lookup"><span data-stu-id="d705e-976">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="d705e-977">Zufällige Modus</span><span class="sxs-lookup"><span data-stu-id="d705e-977">Random Mode</span></span>  
 <span data-ttu-id="d705e-978">Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:</span><span class="sxs-lookup"><span data-stu-id="d705e-978">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="d705e-979">Wenn die Länge des zu lesenden Daten kleiner als die Länge ist, angegeben der `RecordLength` -Klausel der `FileOpen` -Funktion, `FileGet` liest nachfolgende Datensätze Datensatzlänge.</span><span class="sxs-lookup"><span data-stu-id="d705e-979">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="d705e-980">Der Abstand zwischen dem Ende eines Datensatzes und das Starten des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt.</span><span class="sxs-lookup"><span data-stu-id="d705e-980">The space between the end of one record and the starting of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="d705e-981">Da die Menge der Leerstellen Daten nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen empfiehlt sich, die Datensatzlänge der Länge der zu lesenden Daten überein.</span><span class="sxs-lookup"><span data-stu-id="d705e-981">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="d705e-982">Die Zielvariable eine Zeichenfolge ist, standardmäßig `FileGet` liest einen 2-Byte-Deskriptor, die Länge der Zeichenfolge enthält, und liest dann die Daten, die in die Variable aufgenommen wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-982">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="d705e-983">Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="d705e-983">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="d705e-984">Visual Basic 6.0 und früheren Versionen unterstützen Zeichenfolgen mit fester Länge. Wenn in einer Datei zu speichern, wird der Längendeskriptor nicht geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="d705e-984">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="d705e-985">Wenn Sie eine Zeichenfolge ohne Deskriptor lesen möchten, übergeben Sie `True` auf die `StringIsFixedLength` Parameter, und die Zeichenfolge, die Sie einlesen, sollte die richtige Länge.</span><span class="sxs-lookup"><span data-stu-id="d705e-985">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="d705e-986">Wenn die Zielvariable ein Array ist, können Sie auswählen, ob einen Deskriptor für die Größe und die Dimension des Arrays zu lesen.</span><span class="sxs-lookup"><span data-stu-id="d705e-986">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="d705e-987">Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`.</span><span class="sxs-lookup"><span data-stu-id="d705e-987">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="d705e-988">Beim Lesen des Arrays müssen Sie die Möglichkeit zu entsprechen, die das Array geschrieben wurde.</span><span class="sxs-lookup"><span data-stu-id="d705e-988">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="d705e-989">Wenn sie mit dem Deskriptor geschrieben wurde, müssen Sie den Deskriptor lesen.</span><span class="sxs-lookup"><span data-stu-id="d705e-989">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="d705e-990">Der Deskriptor nicht verwendet wird, die Größe und die Grenzen des Arrays übergebenen `FileGet` ermittelt das weitere Vorgehen zu lesen.</span><span class="sxs-lookup"><span data-stu-id="d705e-990">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="d705e-991">Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang.</span><span class="sxs-lookup"><span data-stu-id="d705e-991">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="d705e-992">Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl von Dimensionen: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="d705e-992">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="d705e-993">Die Länge des Datensatzes gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Arraydeskriptor zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="d705e-993">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="d705e-994">Die folgende Arraydeklaration erfordert z. B. 218 Bytes, wenn das Array geschrieben wird auf den Datenträger.</span><span class="sxs-lookup"><span data-stu-id="d705e-994">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="d705e-995">Die 218 Bytes werden wie folgt verteilt:</span><span class="sxs-lookup"><span data-stu-id="d705e-995">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="d705e-996">18 Bytes für den Deskriptor: (2 + 8 \* 2)</span><span class="sxs-lookup"><span data-stu-id="d705e-996">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="d705e-997">200 Bytes für die Daten: (10 * 5 * 4).</span><span class="sxs-lookup"><span data-stu-id="d705e-997">200 bytes for the data: (5 * 10 * 4).</span></span>  
  
-   <span data-ttu-id="d705e-998">Wenn die Variable in gelesen werden, andere Typen von Variablen (keine Zeichenfolge variabler Länge oder ein Objekt), `FileGet` liest nur die Daten die Variablen.</span><span class="sxs-lookup"><span data-stu-id="d705e-998">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="d705e-999">Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge der Daten, die gelesen werden können.</span><span class="sxs-lookup"><span data-stu-id="d705e-999">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="d705e-1000">`FileGet` liest Sie Elemente von Strukturen, als ob einzeln gelesen wurden, mit dem Unterschied, dass keine Auffüllung zwischen Elementen vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="d705e-1000">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="d705e-1001">Auf dem Datenträger ein dynamisches array, in einem benutzerdefinierten Typ (mit geschriebene `FilePut`) ein Deskriptor, dessen Länge 2 plus 8 Mal der Anzahl der Dimensionen gleich, vorangestellt ist: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="d705e-1001">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="d705e-1002">Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes, die zum Lesen der einzelnen Elemente erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-1002">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="d705e-1003">Dies schließt alle Arrays und ihrer Deskriptoren.</span><span class="sxs-lookup"><span data-stu-id="d705e-1003">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="d705e-1004">Die `VBFixedString` Attribut angewendet werden kann, zu Zeichenfolgenfeldern in den Strukturen an, dass die Größe der Zeichenfolge beim Schreiben auf den Datenträger.</span><span class="sxs-lookup"><span data-stu-id="d705e-1004">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="d705e-1005">Binärmodus</span><span class="sxs-lookup"><span data-stu-id="d705e-1005">Binary Mode</span></span>  
 <span data-ttu-id="d705e-1006">Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` -Modus-Regeln gelten, bis auf einige Ausnahmen.</span><span class="sxs-lookup"><span data-stu-id="d705e-1006">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="d705e-1007">Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:</span><span class="sxs-lookup"><span data-stu-id="d705e-1007">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="d705e-1008">Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen.</span><span class="sxs-lookup"><span data-stu-id="d705e-1008">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="d705e-1009">`FileGet` Liest alle Variablen zusammenhängend vom Datenträger. d. h. ohne Auffüllung zwischen Datensätzen.</span><span class="sxs-lookup"><span data-stu-id="d705e-1009">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="d705e-1010">Für ein beliebiges Array als ein Array in einer Struktur `FileGet` liest nur die Daten.</span><span class="sxs-lookup"><span data-stu-id="d705e-1010">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="d705e-1011">Es wird kein Deskriptor gelesen.</span><span class="sxs-lookup"><span data-stu-id="d705e-1011">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="d705e-1012">`FileGet` liest die Zeichenfolgen mit variabler Länge, die keine Elemente von Strukturen ohne erwartet den Längendeskriptor 2-Byte-sind.</span><span class="sxs-lookup"><span data-stu-id="d705e-1012">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="d705e-1013">Die Anzahl der gelesenen Bytes entspricht die Anzahl der Zeichen, die bereits in der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="d705e-1013">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="d705e-1014">Lesen aus einer Datei mithilfe der `FileGet` -Funktion erfordert `Read` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.</span><span class="sxs-lookup"><span data-stu-id="d705e-1014">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="d705e-1015"><paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</span><span class="sxs-lookup"><span data-stu-id="d705e-1015"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="d705e-1016">Dateimodus ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="d705e-1016">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGetObject">
      <MemberSignature Language="C#" Value="public static void FileGetObject (int FileNumber, ref object Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGetObject(int32 FileNumber, object&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGetObject (FileNumber As Integer, ByRef Value As Object, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="d705e-1017">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-1017">Required.</span></span> <span data-ttu-id="d705e-1018">Eine beliebige gültige Dateinummer.</span><span class="sxs-lookup"><span data-stu-id="d705e-1018">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="d705e-1019">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-1019">Required.</span></span> <span data-ttu-id="d705e-1020">Der gültige Name einer Variablen, in die Daten gelesen werden.</span><span class="sxs-lookup"><span data-stu-id="d705e-1020">Valid variable name into which data is read.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="d705e-1021">Dies ist optional.</span><span class="sxs-lookup"><span data-stu-id="d705e-1021">Optional.</span></span> <span data-ttu-id="d705e-1022">Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), bei der der Lesevorgang beginnt.</span><span class="sxs-lookup"><span data-stu-id="d705e-1022">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span></span></param>
        <summary><span data-ttu-id="d705e-1023">Liest Daten aus einer offenen Datenträgerdatei in eine Variable.</span><span class="sxs-lookup"><span data-stu-id="d705e-1023">Reads data from an open disk file into a variable.</span></span>  <span data-ttu-id="d705e-1024">Die <see langword="My" />-Funktion bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FileGetObject" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-1024">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGetObject" />.</span></span> <span data-ttu-id="d705e-1025">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-1025">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d705e-1026">Die `FileGetObject` -Funktion wird verwendet, statt `FileGet` um Mehrdeutigkeiten zum Zeitpunkt der Kompilierung zu vermeiden, wenn Typ `Object` wird z. B. anstelle eines anderen Typs zurückgegeben `Integer`, `Long`, `Short`usw. lauten.</span><span class="sxs-lookup"><span data-stu-id="d705e-1026">The `FileGetObject` function is used instead of `FileGet` to avoid ambiguities at compile time if type `Object` is returned instead of another type, such as `Integer`, `Long`, `Short`, and so forth.</span></span>  
  
 <span data-ttu-id="d705e-1027">Wenn Sie beabsichtigen, schreiben die `Variant` Typ `FileGetObject` ist erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-1027">If you intend to write out the `Variant` type, `FileGetObject` is required.</span></span> <span data-ttu-id="d705e-1028">Im Zweifelsfall, wenn Sie ein Objekt für den zweiten Parameter verwenden, wird immer empfohlen, dass Sie verwenden `FilePutObject` und `FileGetObject`.</span><span class="sxs-lookup"><span data-stu-id="d705e-1028">When in doubt, if you are using an object for the second parameter, it is always suggested that you use `FilePutObject` and `FileGetObject`.</span></span>  
  
 <span data-ttu-id="d705e-1029">`FileGetObject` gilt nur in `Random` und `Binary` Modus.</span><span class="sxs-lookup"><span data-stu-id="d705e-1029">`FileGetObject` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="d705e-1030">Datenlesevorgänge mit `FileGetObject` wird in der Regel mit geschrieben `FilePutObject`.</span><span class="sxs-lookup"><span data-stu-id="d705e-1030">Data read with `FileGetObject` is usually written with `FilePutObject`.</span></span>  
  
 <span data-ttu-id="d705e-1031">Der erste Datensatz oder Byte in einer Datei befindet sich an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 usw. ist.</span><span class="sxs-lookup"><span data-stu-id="d705e-1031">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="d705e-1032">Wenn Sie weglassen `RecordNumber`, `FileGetObject` liest den Datensatz oder ein Byte nach dem letzten `FileGetObject` oder `FilePutObject` Funktion (oder verweist, zu dem letzten `Seek` Funktion).</span><span class="sxs-lookup"><span data-stu-id="d705e-1032">If you omit `RecordNumber`, `FileGetObject` reads the record or byte after the last `FileGetObject` or `FilePutObject` function (or pointed to by the last `Seek` function).</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="d705e-1033">Zufällige Modus</span><span class="sxs-lookup"><span data-stu-id="d705e-1033">Random Mode</span></span>  
 <span data-ttu-id="d705e-1034">Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:</span><span class="sxs-lookup"><span data-stu-id="d705e-1034">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="d705e-1035">Wenn die Länge des zu lesenden Daten kleiner als die Länge ist, angegeben der `RecordLength` -Klausel der `FileOpen` -Funktion, `FileGetObject` liest nachfolgende Datensätze Datensatzlänge.</span><span class="sxs-lookup"><span data-stu-id="d705e-1035">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGetObject` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="d705e-1036">Der Abstand zwischen dem Ende eines Datensatzes und den Anfang des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt.</span><span class="sxs-lookup"><span data-stu-id="d705e-1036">The space between the end of one record and the beginning of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="d705e-1037">Da die Menge der Leerstellen Daten genau ermittelt werden kann, ist es sinnvoll, die Datensatzlänge der Länge der zu lesenden Daten überein.</span><span class="sxs-lookup"><span data-stu-id="d705e-1037">Because the amount of padding data cannot be precisely determined, it is a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="d705e-1038">Wenn die Zielvariable eine Zeichenfolge, in der Standardeinstellung ist `FileGetObject` liest einen 2-Byte-Deskriptor mit der Zeichenfolgenlänge und liest dann die Daten, die in die Variable aufgenommen wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-1038">If the variable being read into is a string, by default `FileGetObject` reads a two-byte descriptor containing the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="d705e-1039">Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="d705e-1039">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="d705e-1040">Visual Basic 6.0 und früheren Versionen unterstützen Zeichenfolgen mit fester Länge und in eine Datei beim Lesen der Längendeskriptor nicht geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="d705e-1040">Visual Basic 6.0 and earlier versions support fixed-length strings and when read to a file, the length descriptor is not written.</span></span> <span data-ttu-id="d705e-1041">Wenn Sie eine Zeichenfolge ohne Deskriptor lesen möchten, übergeben Sie `True` auf die `StringIsFixedLength` Parameter, und die Zeichenfolge, die Sie einlesen, sollte die richtige Länge.</span><span class="sxs-lookup"><span data-stu-id="d705e-1041">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="d705e-1042">Wenn die Zielvariable ein Array, und klicken Sie dann auf die angegebene Datensatzlänge ist die `RecordLength` Parameter in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Arraydeskriptor zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1042">If the variable being read into is an array, then the record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="d705e-1043">Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang.</span><span class="sxs-lookup"><span data-stu-id="d705e-1043">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="d705e-1044">Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl von Dimensionen: 2 + 8 \* NumberOfDimensions.</span><span class="sxs-lookup"><span data-stu-id="d705e-1044">Its length equals 2 plus 8 times the number of dimensions: 2 + 8 \* NumberOfDimensions.</span></span>  
  
     <span data-ttu-id="d705e-1045">Die folgende Arraydeklaration erfordert z. B. 218 Bytes, wenn das Array geschrieben wird auf den Datenträger:</span><span class="sxs-lookup"><span data-stu-id="d705e-1045">For example, the following array declaration requires 218 bytes when the array is written to disk:</span></span>  
  
     [!code-vb[VbVbalrCatRef#27](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#27)]  
  
     <span data-ttu-id="d705e-1046">Die 218 Bytes werden wie folgt verteilt: 18 Bytes für den Deskriptor (2 + 8 \* 2) und 100 Bytes für die Daten (10 \* 5 \* 4).</span><span class="sxs-lookup"><span data-stu-id="d705e-1046">The 218 bytes are distributed as follows: 18 bytes for the descriptor (2 + 8 \* 2), and 100 bytes for the data (5 \* 10 \* 4).</span></span>  
  
-   <span data-ttu-id="d705e-1047">`FileGetObject` liest Sie Elemente von Strukturen, als ob einzeln gelesen wurden, mit dem Unterschied, dass keine Auffüllung zwischen Elementen vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="d705e-1047">`FileGetObject` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="d705e-1048">Auf dem Datenträger ein dynamisches array, in einem benutzerdefinierten Typ (mit geschriebene `FilePutObject`) ein Deskriptor, dessen Länge 2 plus 8 Mal der Anzahl der Dimensionen gleich, vorangestellt ist: 2 + 8 \* NumberOfDimensions.</span><span class="sxs-lookup"><span data-stu-id="d705e-1048">On disk, a dynamic array in a user-defined type (written with `FilePutObject`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: 2 + 8 \* NumberOfDimensions.</span></span> <span data-ttu-id="d705e-1049">Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes, die zum Lesen der einzelnen Elemente, einschließlich aller Arrays und ihrer Deskriptoren erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-1049">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements, including any arrays and their descriptors.</span></span> <span data-ttu-id="d705e-1050">Die <xref:Microsoft.VisualBasic.VBFixedStringAttribute> Klasse angewendet werden kann, zu Zeichenfolgenfeldern in den Strukturen an, dass die Größe der Zeichenfolge beim Schreiben auf den Datenträger.</span><span class="sxs-lookup"><span data-stu-id="d705e-1050">The <xref:Microsoft.VisualBasic.VBFixedStringAttribute> class can be applied to string fields in the structures to indicate the size of string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="d705e-1051">Binärmodus</span><span class="sxs-lookup"><span data-stu-id="d705e-1051">Binary Mode</span></span>  
 <span data-ttu-id="d705e-1052">Für Dateien in geöffnet `Binary` aller-Modus die `Random` Regeln anwenden, mit den folgenden Ausnahmen:</span><span class="sxs-lookup"><span data-stu-id="d705e-1052">For files opened in `Binary` mode, all of the `Random` rules apply, with these exceptions:</span></span>  
  
-   <span data-ttu-id="d705e-1053">Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen.</span><span class="sxs-lookup"><span data-stu-id="d705e-1053">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="d705e-1054">`FileGetObject` Liest alle Variablen vom Datenträger zusammenhängend, d. h. ohne Abstand zwischen den Datensätzen.</span><span class="sxs-lookup"><span data-stu-id="d705e-1054">`FileGetObject` reads all variables from disk contiguously, that is, with no padding between records.</span></span>  
  
-   <span data-ttu-id="d705e-1055">Für ein beliebiges Array als ein Array in einer Struktur `FileGetObject` liest nur die Daten.</span><span class="sxs-lookup"><span data-stu-id="d705e-1055">For any array other than an array in a structure, `FileGetObject` reads only the data.</span></span> <span data-ttu-id="d705e-1056">Es wird kein Deskriptor gelesen.</span><span class="sxs-lookup"><span data-stu-id="d705e-1056">No descriptor is read.</span></span>  
  
 <span data-ttu-id="d705e-1057">`FileGetObject` liest die Zeichenfolgen mit variabler Länge, die keine Elemente von Strukturen ohne erwartet den Längendeskriptor 2-Byte-sind.</span><span class="sxs-lookup"><span data-stu-id="d705e-1057">`FileGetObject` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="d705e-1058">Die Anzahl der gelesenen Bytes entspricht die Anzahl der Zeichen, die bereits in der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="d705e-1058">The number of bytes read equals the number of characters already in the string.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="d705e-1059">Beim Lesen aus Dateien nicht Beurteilen der Inhalt einer Datei, die anhand der Dateinamenerweiterung.</span><span class="sxs-lookup"><span data-stu-id="d705e-1059">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="d705e-1060">Eine Datei namens "Form1.vb" möglicherweise z. B. keine Visual Basic-Quelldatei.</span><span class="sxs-lookup"><span data-stu-id="d705e-1060">For example, a file named Form1.vb may not be a Visual Basic source file.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d705e-1061">Im folgenden Beispiel liest, einen Datensatz in einer Testdatei und ruft dann ab.</span><span class="sxs-lookup"><span data-stu-id="d705e-1061">The following example reads a record into a test file and then retrieves it.</span></span>  
  
 [!code-vb[VbVbalrCatRef#26](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#26)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
      </Docs>
    </Member>
    <Member MemberName="FileLen">
      <MemberSignature Language="C#" Value="public static long FileLen (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 FileLen(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileLen (PathName As String) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long FileLen(System::String ^ PathName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName"><span data-ttu-id="d705e-1062">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-1062">Required.</span></span> <span data-ttu-id="d705e-1063"><see langword="String" />-Ausdruck, der eine Datei angibt.</span><span class="sxs-lookup"><span data-stu-id="d705e-1063"><see langword="String" /> expression that specifies a file.</span></span> <span data-ttu-id="d705e-1064"><c>PathName</c> kann das Verzeichnis bzw. den Ordner und das Laufwerk enthalten.</span><span class="sxs-lookup"><span data-stu-id="d705e-1064"><c>PathName</c> may include the directory or folder, and the drive.</span></span></param>
        <summary><span data-ttu-id="d705e-1065">Gibt einen <see langword="Long" />-Wert zurück, der die Länge einer Datei in Bytes angibt.</span><span class="sxs-lookup"><span data-stu-id="d705e-1065">Returns a <see langword="Long" /> value that specifies the length of a file in bytes.</span></span> <span data-ttu-id="d705e-1066">Das <see langword="My" />-Feature bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FileLen" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-1066">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileLen" />.</span></span> <span data-ttu-id="d705e-1067">Weitere Informationen finden Sie unter <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-1067">For more information, see <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />.</span></span></summary>
        <returns>
          <span data-ttu-id="d705e-1068"><see langword="Long" />-Wert, der die Länge einer Datei in Bytes angibt.</span><span class="sxs-lookup"><span data-stu-id="d705e-1068"><see langword="Long" /> value that specifies the length of a file in bytes.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d705e-1069">Wenn die angegebene Datei geöffnet wann ist die `FileLen` Funktion aufgerufen wird, wird der zurückgegebene Wert stellt die Größe der Datei zu dem Zeitpunkt, der sie geöffnet wurde.</span><span class="sxs-lookup"><span data-stu-id="d705e-1069">If the specified file is open when the `FileLen` function is called, the value returned represents the size of the file at the time it was opened.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d705e-1070">Um die aktuelle Länge einer geöffneten Datei abzurufen, verwenden die `LOF` Funktion.</span><span class="sxs-lookup"><span data-stu-id="d705e-1070">To obtain the current length of an open file, use the `LOF` function.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d705e-1071">Dieses Beispiel verwendet die `FileLen` Funktion, um die Länge einer Datei in Bytes zurück.</span><span class="sxs-lookup"><span data-stu-id="d705e-1071">This example uses the `FileLen` function to return the length of a file in bytes.</span></span> <span data-ttu-id="d705e-1072">Für dieses Beispiel wird davon ausgegangen, die `TestFile` ist eine Datei, die einige Daten enthält.</span><span class="sxs-lookup"><span data-stu-id="d705e-1072">For purposes of this example, assume that `TestFile` is a file that contains some data.</span></span>  
  
 [!code-vb[VbVbalrCatRef#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="d705e-1073">Die Datei ist nicht vorhanden.</span><span class="sxs-lookup"><span data-stu-id="d705e-1073">File does not exist.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <Member MemberName="FileOpen">
      <MemberSignature Language="C#" Value="public static void FileOpen (int FileNumber, string FileName, Microsoft.VisualBasic.OpenMode Mode, Microsoft.VisualBasic.OpenAccess Access = Microsoft.VisualBasic.OpenAccess.Default, Microsoft.VisualBasic.OpenShare Share = Microsoft.VisualBasic.OpenShare.Default, int RecordLength = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileOpen(int32 FileNumber, string FileName, valuetype Microsoft.VisualBasic.OpenMode Mode, valuetype Microsoft.VisualBasic.OpenAccess Access, valuetype Microsoft.VisualBasic.OpenShare Share, int32 RecordLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileOpen (FileNumber As Integer, FileName As String, Mode As OpenMode, Optional Access As OpenAccess = Microsoft.VisualBasic.OpenAccess.Default, Optional Share As OpenShare = Microsoft.VisualBasic.OpenShare.Default, Optional RecordLength As Integer = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FileName" Type="System.String" />
        <Parameter Name="Mode" Type="Microsoft.VisualBasic.OpenMode" />
        <Parameter Name="Access" Type="Microsoft.VisualBasic.OpenAccess" />
        <Parameter Name="Share" Type="Microsoft.VisualBasic.OpenShare" />
        <Parameter Name="RecordLength" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="d705e-1074">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-1074">Required.</span></span> <span data-ttu-id="d705e-1075">Eine beliebige gültige Dateinummer.</span><span class="sxs-lookup"><span data-stu-id="d705e-1075">Any valid file number.</span></span> <span data-ttu-id="d705e-1076">Verwenden Sie die <see langword="FreeFile" />-Funktion, um die nächste verfügbare Dateinummer zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="d705e-1076">Use the <see langword="FreeFile" /> function to obtain the next available file number.</span></span></param>
        <param name="FileName"><span data-ttu-id="d705e-1077">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-1077">Required.</span></span> <span data-ttu-id="d705e-1078"><see langword="String" />-Ausdruck, der einen Dateinamen angibt. Kann das Verzeichnis oder den Ordner und das Laufwerk enthalten.</span><span class="sxs-lookup"><span data-stu-id="d705e-1078"><see langword="String" /> expression that specifies a file name—may include directory or folder, and drive.</span></span></param>
        <param name="Mode"><span data-ttu-id="d705e-1079">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-1079">Required.</span></span> <span data-ttu-id="d705e-1080">Eine Enumeration, die den Dateimodus angibt: <see langword="Append" />, <see langword="Binary" />, <see langword="Input" />, <see langword="Output" /> oder <see langword="Random" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-1080">Enumeration specifying the file mode: <see langword="Append" />, <see langword="Binary" />, <see langword="Input" />, <see langword="Output" />, or <see langword="Random" />.</span></span> <span data-ttu-id="d705e-1081">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.OpenMode" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-1081">For more information, see <see cref="T:Microsoft.VisualBasic.OpenMode" /> .</span></span></param>
        <param name="Access"><span data-ttu-id="d705e-1082">Dies ist optional.</span><span class="sxs-lookup"><span data-stu-id="d705e-1082">Optional.</span></span> <span data-ttu-id="d705e-1083">Eine Enumeration, die die für eine offene Datei erlaubten Operationen angibt: <see langword="Read" />, <see langword="Write" /> oder <see langword="ReadWrite" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-1083">Enumeration specifying the operations permitted on the open file: <see langword="Read" />, <see langword="Write" />, or <see langword="ReadWrite" />.</span></span> <span data-ttu-id="d705e-1084">Wird standardmäßig auf <see langword="ReadWrite" /> festgelegt.</span><span class="sxs-lookup"><span data-stu-id="d705e-1084">Defaults to <see langword="ReadWrite" />.</span></span> <span data-ttu-id="d705e-1085">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.OpenAccess" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-1085">For more information, see <see cref="T:Microsoft.VisualBasic.OpenAccess" /> .</span></span></param>
        <param name="Share"><span data-ttu-id="d705e-1086">Dies ist optional.</span><span class="sxs-lookup"><span data-stu-id="d705e-1086">Optional.</span></span> <span data-ttu-id="d705e-1087">Eine Enumeration, die für eine offene Datei aus anderen Prozessen nicht erlaubten Operationen angibt: <see langword="Shared" />, <see langword="Lock Read" />, <see langword="Lock Write" /> und <see langword="Lock Read Write" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-1087">Enumeration specifying the operations not permitted on the open file by other processes: <see langword="Shared" />, <see langword="Lock Read" />, <see langword="Lock Write" />, and <see langword="Lock Read Write" />.</span></span> <span data-ttu-id="d705e-1088">Wird standardmäßig auf <see langword="Lock Read Write" /> festgelegt.</span><span class="sxs-lookup"><span data-stu-id="d705e-1088">Defaults to <see langword="Lock Read Write" />.</span></span> <span data-ttu-id="d705e-1089">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.OpenShare" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-1089">For more information, see <see cref="T:Microsoft.VisualBasic.OpenShare" /> .</span></span></param>
        <param name="RecordLength"><span data-ttu-id="d705e-1090">Dies ist optional.</span><span class="sxs-lookup"><span data-stu-id="d705e-1090">Optional.</span></span> <span data-ttu-id="d705e-1091">Eine Zahl kleiner oder gleich 32.767 (Bytes).</span><span class="sxs-lookup"><span data-stu-id="d705e-1091">Number less than or equal to 32,767 (bytes).</span></span> <span data-ttu-id="d705e-1092">Bei Dateien, die mit Random-Zugriff geöffnet wurden, ist dieser Wert die Datensatzlänge.</span><span class="sxs-lookup"><span data-stu-id="d705e-1092">For files opened for random access, this value is the record length.</span></span> <span data-ttu-id="d705e-1093">Bei sequenziellen Dateien ist dieser Wert die Anzahl von gepufferten Zeichen.</span><span class="sxs-lookup"><span data-stu-id="d705e-1093">For sequential files, this value is the number of characters buffered.</span></span></param>
        <summary><span data-ttu-id="d705e-1094">Öffnet eine Datei für Eingabe oder Ausgabe.</span><span class="sxs-lookup"><span data-stu-id="d705e-1094">Opens a file for input or output.</span></span> <span data-ttu-id="d705e-1095">Das <see langword="My" />-Feature bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FileOpen" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-1095">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileOpen" />.</span></span> <span data-ttu-id="d705e-1096">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-1096">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d705e-1097">Die `FileOpen` Funktion wird für Abwärtskompatibilität angeboten und die Leistung beeinträchtigen.</span><span class="sxs-lookup"><span data-stu-id="d705e-1097">The `FileOpen` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="d705e-1098">Für nicht-Legacyanwendungen der `My.Computer.FileSystem` Objekt bietet eine bessere Leistung.</span><span class="sxs-lookup"><span data-stu-id="d705e-1098">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="d705e-1099">Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="d705e-1099">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="d705e-1100">Sie müssen eine Datei öffnen, bevor alle e/a-Vorgang darauf ausgeführt werden kann.</span><span class="sxs-lookup"><span data-stu-id="d705e-1100">You must open a file before any I/O operation can be performed on it.</span></span> <span data-ttu-id="d705e-1101">`FileOpen` reserviert einen Puffer für e/a auf die Datei, und bestimmt den Modus des Zugriffs für die Verwendung mit dem Puffer.</span><span class="sxs-lookup"><span data-stu-id="d705e-1101">`FileOpen` allocates a buffer for I/O to the file and determines the mode of access to use with the buffer.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="d705e-1102">Beim Schreiben in eine Datei eine Anwendung möglicherweise eine Datei erstellen, wenn die Datei mit der er schreiben möchte nicht vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="d705e-1102">When writing to a file, an application may have to create a file, if the file to which it is trying to write does not exist.</span></span> <span data-ttu-id="d705e-1103">Zu diesem Zweck benötigt er die Berechtigung für das Verzeichnis, in dem die Datei erstellt werden.</span><span class="sxs-lookup"><span data-stu-id="d705e-1103">To do so, it needs permission for the directory in which the file is to be created.</span></span> <span data-ttu-id="d705e-1104">Jedoch, wenn die Datei durch angegeben `FileName` vorhanden ist, muss die Anwendung `Write` Berechtigungen nur für die Datei selbst.</span><span class="sxs-lookup"><span data-stu-id="d705e-1104">However, if the file specified by `FileName` does exist, the application needs `Write` permission only to the file itself.</span></span> <span data-ttu-id="d705e-1105">Immer, wenn möglich, zur Verbesserung der Sicherheit erstellen Sie die Datei während der Bereitstellung und gewähren Sie `Write` Berechtigungen für diese Datei nur, anstatt das gesamte Verzeichnis.</span><span class="sxs-lookup"><span data-stu-id="d705e-1105">Wherever possible, to help improve security, create the file during deployment and grant `Write` permission to that file only, instead of to the whole directory.</span></span> <span data-ttu-id="d705e-1106">Schreiben Sie Daten in Verzeichnissen nach Benutzer statt auf das Stammverzeichnis oder das Verzeichnis für Programmdateien, um Sicherheit zu verbessern.</span><span class="sxs-lookup"><span data-stu-id="d705e-1106">To help improve security, write data to user directories instead of to the root directory or the Program Files directory.</span></span>  
  
 <span data-ttu-id="d705e-1107">Der Kanal geöffnet verwendbaren mithilfe der `FreeFile()` Funktion.</span><span class="sxs-lookup"><span data-stu-id="d705e-1107">The channel to open can be found by using the `FreeFile()` function.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="d705e-1108">Die `FileOpen` -Funktion erfordert `Read` aus Zugriff auf die `FileIOPermissionAccess` -Enumeration, die sich möglicherweise auf ihre Ausführung in teilweise vertrauenswürdigen Umgebungen auswirken.</span><span class="sxs-lookup"><span data-stu-id="d705e-1108">The `FileOpen` function requires `Read` access from the `FileIOPermissionAccess` enumeration, which may affect its execution in partial trust situations.</span></span> <span data-ttu-id="d705e-1109">Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.</span><span class="sxs-lookup"><span data-stu-id="d705e-1109">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d705e-1110">Dieses Beispiel zeigt verschiedene Verwendungsmöglichkeiten der der `FileOpen` Funktion, um ein- und Ausgabe in eine Datei zu ermöglichen.</span><span class="sxs-lookup"><span data-stu-id="d705e-1110">This example illustrates various uses of the `FileOpen` function to enable input and output to a file.</span></span>  
  
 <span data-ttu-id="d705e-1111">Der folgende Code öffnet die Datei `TestFile` in `Input` Modus.</span><span class="sxs-lookup"><span data-stu-id="d705e-1111">The following code opens the file `TestFile` in `Input` mode.</span></span>  
  
 [!code-vb[VbVbalrCatRef#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#5)]  
  
 <span data-ttu-id="d705e-1112">In diesem Beispiel öffnet die Datei im `Binary` Modus ausschließlich für Schreibvorgänge.</span><span class="sxs-lookup"><span data-stu-id="d705e-1112">This example opens the file in `Binary` mode for writing operations only.</span></span>  
  
 [!code-vb[VbVbalrCatRef#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#6)]  
  
 <span data-ttu-id="d705e-1113">Das folgende Beispiel öffnet die Datei im `Random` Modus.</span><span class="sxs-lookup"><span data-stu-id="d705e-1113">The following example opens the file in `Random` mode.</span></span> <span data-ttu-id="d705e-1114">Die Datei enthält die Datensätze mit der Struktur `Person`.</span><span class="sxs-lookup"><span data-stu-id="d705e-1114">The file contains records of the structure `Person`.</span></span>  
  
 [!code-vb[VbVbalrCatRef#7](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#7)]  
  
 <span data-ttu-id="d705e-1115">Dieses Codebeispiel öffnet die Datei im `Output` Modus; jeder Prozess kann lesen oder Schreiben in die Datei.</span><span class="sxs-lookup"><span data-stu-id="d705e-1115">This code example opens the file in `Output` mode; any process can read or write to file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#8)]  
  
 <span data-ttu-id="d705e-1116">Dieses Codebeispiel öffnet die Datei im `Binary` Modus zum Lesen; andere Prozesse die Datei können nicht gelesen werden.</span><span class="sxs-lookup"><span data-stu-id="d705e-1116">This code example opens the file in `Binary` mode for reading; other processes cannot read file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d705e-1117">Datensatzlänge ist negativ (und nicht gleich -1).</span><span class="sxs-lookup"><span data-stu-id="d705e-1117">Record length is negative (and not equal to -1).</span></span></exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="d705e-1118"><paramref name="FileName" /> ist bereits geöffnet, oder <paramref name="FileName" /> ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="d705e-1118"><paramref name="FileName" /> is already open, or <paramref name="FileName" /> is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FreeFile" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FilePut">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d705e-1119">Schreibt Daten aus einer Variablen in eine Datei auf einem Datenträger.</span><span class="sxs-lookup"><span data-stu-id="d705e-1119">Writes data from a variable to a disk file.</span></span> <span data-ttu-id="d705e-1120">Das <see langword="My" />-Feature bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FilePut" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-1120">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span></span> <span data-ttu-id="d705e-1121">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-1121">F For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, bool Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, bool Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Boolean, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="d705e-1122">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-1122">Required.</span></span> <span data-ttu-id="d705e-1123">Eine beliebige gültige Dateinummer.</span><span class="sxs-lookup"><span data-stu-id="d705e-1123">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="d705e-1124">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-1124">Required.</span></span> <span data-ttu-id="d705e-1125">Gültiger Variablenname, der auf den Datenträger geschriebene Daten enthält.</span><span class="sxs-lookup"><span data-stu-id="d705e-1125">Valid variable name that contains data written to disk.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="d705e-1126">Dies ist optional.</span><span class="sxs-lookup"><span data-stu-id="d705e-1126">Optional.</span></span> <span data-ttu-id="d705e-1127">Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), an der der Schreibvorgang beginnt.</span><span class="sxs-lookup"><span data-stu-id="d705e-1127">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span></span></param>
        <summary><span data-ttu-id="d705e-1128">Schreibt Daten aus einer Variablen in eine Datei auf einem Datenträger.</span><span class="sxs-lookup"><span data-stu-id="d705e-1128">Writes data from a variable to a disk file.</span></span> <span data-ttu-id="d705e-1129">Das <see langword="My" />-Feature bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FilePut" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-1129">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span></span> <span data-ttu-id="d705e-1130">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-1130">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d705e-1131">`FilePut` gilt nur in `Random` und `Binary` Modus.</span><span class="sxs-lookup"><span data-stu-id="d705e-1131">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="d705e-1132">Mit `FilePut` geschriebene Daten werden in der Regel mit `FileGet` aus einer Datei gelesen.</span><span class="sxs-lookup"><span data-stu-id="d705e-1132">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="d705e-1133">Der erste Datensatz oder Byte in einer Datei befindet sich an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 usw. ist.</span><span class="sxs-lookup"><span data-stu-id="d705e-1133">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="d705e-1134">Wenn Sie weglassen `RecordNumber`, den nächsten Datensatz bzw. Byte nach dem letzten `FileGet` oder `FilePut` Funktion oder verweist, zu dem letzten `Seek` Funktion geschrieben wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-1134">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="d705e-1135">Die `StringIsFixedLength` -Argument steuert, ob die Funktion Zeichenfolgen als Variable oder feste Länge interpretiert.</span><span class="sxs-lookup"><span data-stu-id="d705e-1135">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="d705e-1136">`FilePut` den Längendeskriptor wird nicht geschrieben werden, wenn das Argument ist `True`.</span><span class="sxs-lookup"><span data-stu-id="d705e-1136">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="d705e-1137">Bei Verwendung von `StringIsFixedLength`  =  `True` mit `FilePut`, was identisch mit `FileGet`, und Sie müssen sicherstellen, dass die Zeichenfolge mit der erwarteten Länge initialisiert wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-1137">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="d705e-1138">Zufällige Modus</span><span class="sxs-lookup"><span data-stu-id="d705e-1138">Random Mode</span></span>  
 <span data-ttu-id="d705e-1139">Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:</span><span class="sxs-lookup"><span data-stu-id="d705e-1139">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="d705e-1140">Wenn die Länge des zu schreibenden Daten kleiner als die Länge ist, angegeben der `RecordLength` -Klausel der `FileOpen` -Funktion, `FilePut` nachfolgende Datensätze auf Datensatzlänge schreibt.</span><span class="sxs-lookup"><span data-stu-id="d705e-1140">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="d705e-1141">Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt.</span><span class="sxs-lookup"><span data-stu-id="d705e-1141">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="d705e-1142">Da die Menge der Leerstellen Daten nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen empfiehlt sich, die Datensatzlänge der Länge der zu schreibenden Daten überein.</span><span class="sxs-lookup"><span data-stu-id="d705e-1142">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="d705e-1143">Ist die Länge des zu schreibenden Daten größer als die Länge, angegeben der `RecordLength` -Klausel der `FileOpen` -Funktion eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="d705e-1143">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="d705e-1144">Eine Zeichenfolge ist, die Zielvariable `FilePut` schreibt einen 2-Byte-Deskriptor, der die Länge der Zeichenfolge enthält, und schreibt dann die Daten, die in die Variable aufgenommen wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-1144">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="d705e-1145">Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge sein.</span><span class="sxs-lookup"><span data-stu-id="d705e-1145">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="d705e-1146">Wenn die Zielvariable ein Objekt ist, die einen numerischen Typ enthält `FilePut` zwei Bytes, identifizieren den `VarType` des Objekts und schreibt dann die Variable.</span><span class="sxs-lookup"><span data-stu-id="d705e-1146">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="d705e-1147">Enthält z. B. wenn ein Objekt zu schreiben, die eine ganze Zahl `FilePut` schreibt sechs Bytes: 2 Bytes, die Identifizierung des Objekts als `VarType(3)` (`Integer`) und vier Bytes, die Daten enthalten.</span><span class="sxs-lookup"><span data-stu-id="d705e-1147">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="d705e-1148">Die angegebene Datensatzlänge der `RecordLength` Parameter in der `FileOpen` Funktion muss mindestens zwei Bytes größer als die tatsächliche Anzahl von Bytes, die zum Speichern von Variablen erforderlich sein.</span><span class="sxs-lookup"><span data-stu-id="d705e-1148">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="d705e-1149">Ist die Zielvariable ein Objekt, das eine Zeichenfolge enthält `FilePut` schreibt eine 2-Byte-Deskriptor, identifiziert die `VarType(8)` des Objekts, ein 2-Byte-Deskriptor, der angibt, der Länge der Zeichenfolge und anschließend die Zeichenfolgendaten.</span><span class="sxs-lookup"><span data-stu-id="d705e-1149">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="d705e-1150">Die angegebene Datensatzlänge der `RecordLength` Parameter in der `FileOpen` Funktion muss mindestens vier Bytes größer als die tatsächliche Länge der Zeichenfolge sein.</span><span class="sxs-lookup"><span data-stu-id="d705e-1150">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="d705e-1151">Wenn Sie eine Zeichenfolge ohne Deskriptor ablegen möchten, sollten Sie übergeben `True` auf die `StringIsFixedLength` Parameter, und die Zeichenfolge, die Sie einlesen, sollte die richtige Länge.</span><span class="sxs-lookup"><span data-stu-id="d705e-1151">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="d705e-1152">Wenn die Zielvariable ein Array ist, müssen Sie eine Auswahl, ob einen Deskriptor für die Größe und die Dimensionen des Arrays zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1152">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="d705e-1153">Visual Basic 6.0 und früheren Versionen Dateideskriptor für dynamische Arrays und nicht für Arrays mit fester Größe zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1153">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="d705e-1154">Visual Basic 2005 standardmäßig kein Deskriptor geschrieben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1154">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="d705e-1155">Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`.</span><span class="sxs-lookup"><span data-stu-id="d705e-1155">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="d705e-1156">Wenn das Array zu schreiben, müssen Sie entsprechend der Weise wird das Array gelesen werden; Wenn mit dem Deskriptor gelesen werden, müssen Sie den Deskriptor schreiben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1156">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="d705e-1157">Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang.</span><span class="sxs-lookup"><span data-stu-id="d705e-1157">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="d705e-1158">Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl von Dimensionen: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="d705e-1158">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="d705e-1159">Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Arraydeskriptor zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1159">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="d705e-1160">Die folgende Arraydeklaration erfordert z. B. 218 Bytes, wenn das Array geschrieben wird auf den Datenträger.</span><span class="sxs-lookup"><span data-stu-id="d705e-1160">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="d705e-1161">Wenn die Zielvariable einen anderen Typ der Variable (keine Zeichenfolge variabler Länge oder ein Objekt), ist `FilePut` schreibt nur die Daten der Variablen.</span><span class="sxs-lookup"><span data-stu-id="d705e-1161">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="d705e-1162">Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge der zu schreibenden Daten.</span><span class="sxs-lookup"><span data-stu-id="d705e-1162">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="d705e-1163">`FilePut` Schreibt die Elemente von Strukturen, als ob jeder einzeln geschrieben wurden jedoch keine Auffüllung zwischen Elementen.</span><span class="sxs-lookup"><span data-stu-id="d705e-1163">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="d705e-1164">Die `VBFixedString` Attribut angewendet werden kann, zu Zeichenfolgenfeldern in den Strukturen an, dass die Größe der Zeichenfolge beim Schreiben auf den Datenträger.</span><span class="sxs-lookup"><span data-stu-id="d705e-1164">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="d705e-1165">String-Felder, die mehr als Bytes angegeben die `VBFixedString` Attribut werden abgeschnitten, beim Schreiben auf den Datenträger</span><span class="sxs-lookup"><span data-stu-id="d705e-1165">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="d705e-1166">Binärmodus</span><span class="sxs-lookup"><span data-stu-id="d705e-1166">Binary Mode</span></span>  
 <span data-ttu-id="d705e-1167">Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` -Modus-Regeln gelten, bis auf einige Ausnahmen.</span><span class="sxs-lookup"><span data-stu-id="d705e-1167">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="d705e-1168">Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:</span><span class="sxs-lookup"><span data-stu-id="d705e-1168">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="d705e-1169">Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen.</span><span class="sxs-lookup"><span data-stu-id="d705e-1169">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="d705e-1170">`FilePut` Schreibt alle Variablen zusammenhängend, d. h. ohne Leerraum zwischen Datensätzen Datenträger an.</span><span class="sxs-lookup"><span data-stu-id="d705e-1170">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="d705e-1171">Für ein beliebiges Array als ein Array in einer Struktur `FilePut` schreibt nur die Daten.</span><span class="sxs-lookup"><span data-stu-id="d705e-1171">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="d705e-1172">Es wird kein Deskriptor geschrieben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1172">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="d705e-1173">`FilePut` schreibt Zeichenfolgen variabler Länge, die keine Elemente von Strukturen ohne Längendeskriptor 2-Byte-sind.</span><span class="sxs-lookup"><span data-stu-id="d705e-1173">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="d705e-1174">Die Anzahl der geschriebenen Bytes entspricht die Anzahl der Zeichen in der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="d705e-1174">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="d705e-1175">Die folgenden Anweisungen wird z. B. 11 Bytes Datei Zahl 1 schreiben:</span><span class="sxs-lookup"><span data-stu-id="d705e-1175">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="d705e-1176">Schreiben in eine Datei mithilfe der `FilePut` -Funktion erfordert `Write` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.</span><span class="sxs-lookup"><span data-stu-id="d705e-1176">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d705e-1177">Dieses Beispiel verwendet die `FilePut` Funktion, um Daten in eine Datei schreiben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1177">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="d705e-1178">Fünf Datensätze der Struktur `Person` in die Datei geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="d705e-1178">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="d705e-1179"><paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</span><span class="sxs-lookup"><span data-stu-id="d705e-1179"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="d705e-1180">Dateimodus ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="d705e-1180">File mode is invalid.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, byte Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, unsigned int8 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Byte, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="d705e-1181">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-1181">Required.</span></span> <span data-ttu-id="d705e-1182">Eine beliebige gültige Dateinummer.</span><span class="sxs-lookup"><span data-stu-id="d705e-1182">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="d705e-1183">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-1183">Required.</span></span> <span data-ttu-id="d705e-1184">Gültiger Variablenname, der auf den Datenträger geschriebene Daten enthält.</span><span class="sxs-lookup"><span data-stu-id="d705e-1184">Valid variable name that contains data written to disk.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="d705e-1185">Dies ist optional.</span><span class="sxs-lookup"><span data-stu-id="d705e-1185">Optional.</span></span> <span data-ttu-id="d705e-1186">Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), an der der Schreibvorgang beginnt.</span><span class="sxs-lookup"><span data-stu-id="d705e-1186">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span></span></param>
        <summary><span data-ttu-id="d705e-1187">Schreibt Daten aus einer Variablen in eine Datei auf einem Datenträger.</span><span class="sxs-lookup"><span data-stu-id="d705e-1187">Writes data from a variable to a disk file.</span></span> <span data-ttu-id="d705e-1188">Das <see langword="My" />-Feature bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FilePut" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-1188">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span></span> <span data-ttu-id="d705e-1189">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-1189">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d705e-1190">`FilePut` gilt nur in `Random` und `Binary` Modus.</span><span class="sxs-lookup"><span data-stu-id="d705e-1190">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="d705e-1191">Mit `FilePut` geschriebene Daten werden in der Regel mit `FileGet` aus einer Datei gelesen.</span><span class="sxs-lookup"><span data-stu-id="d705e-1191">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="d705e-1192">Der erste Datensatz oder Byte in einer Datei befindet sich an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 usw. ist.</span><span class="sxs-lookup"><span data-stu-id="d705e-1192">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="d705e-1193">Wenn Sie weglassen `RecordNumber`, den nächsten Datensatz bzw. Byte nach dem letzten `FileGet` oder `FilePut` Funktion oder verweist, zu dem letzten `Seek` Funktion geschrieben wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-1193">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="d705e-1194">Die `StringIsFixedLength` -Argument steuert, ob die Funktion Zeichenfolgen als Variable oder feste Länge interpretiert.</span><span class="sxs-lookup"><span data-stu-id="d705e-1194">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="d705e-1195">`FilePut` den Längendeskriptor wird nicht geschrieben werden, wenn das Argument ist `True`.</span><span class="sxs-lookup"><span data-stu-id="d705e-1195">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="d705e-1196">Bei Verwendung von `StringIsFixedLength`  =  `True` mit `FilePut`, was identisch mit `FileGet`, und Sie müssen sicherstellen, dass die Zeichenfolge mit der erwarteten Länge initialisiert wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-1196">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="d705e-1197">Zufällige Modus</span><span class="sxs-lookup"><span data-stu-id="d705e-1197">Random Mode</span></span>  
 <span data-ttu-id="d705e-1198">Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:</span><span class="sxs-lookup"><span data-stu-id="d705e-1198">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="d705e-1199">Wenn die Länge des zu schreibenden Daten kleiner als die Länge ist, angegeben der `RecordLength` -Klausel der `FileOpen` -Funktion, `FilePut` nachfolgende Datensätze auf Datensatzlänge schreibt.</span><span class="sxs-lookup"><span data-stu-id="d705e-1199">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="d705e-1200">Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt.</span><span class="sxs-lookup"><span data-stu-id="d705e-1200">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="d705e-1201">Da die Menge der Leerstellen Daten nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen empfiehlt sich, die Datensatzlänge der Länge der zu schreibenden Daten überein.</span><span class="sxs-lookup"><span data-stu-id="d705e-1201">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="d705e-1202">Ist die Länge des zu schreibenden Daten größer als die Länge, angegeben der `RecordLength` -Klausel der `FileOpen` -Funktion eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="d705e-1202">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="d705e-1203">Eine Zeichenfolge ist, die Zielvariable `FilePut` schreibt einen 2-Byte-Deskriptor, der die Länge der Zeichenfolge enthält, und schreibt dann die Daten, die in die Variable aufgenommen wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-1203">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="d705e-1204">Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge sein.</span><span class="sxs-lookup"><span data-stu-id="d705e-1204">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="d705e-1205">Wenn die Zielvariable ein Objekt ist, die einen numerischen Typ enthält `FilePut` zwei Bytes, identifizieren den `VarType` des Objekts und schreibt dann die Variable.</span><span class="sxs-lookup"><span data-stu-id="d705e-1205">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="d705e-1206">Enthält z. B. wenn ein Objekt zu schreiben, die eine ganze Zahl `FilePut` schreibt sechs Bytes: 2 Bytes, die Identifizierung des Objekts als `VarType(3)` (`Integer`) und vier Bytes, die Daten enthalten.</span><span class="sxs-lookup"><span data-stu-id="d705e-1206">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="d705e-1207">Die angegebene Datensatzlänge der `RecordLength` Parameter in der `FileOpen` Funktion muss mindestens zwei Bytes größer als die tatsächliche Anzahl von Bytes, die zum Speichern von Variablen erforderlich sein.</span><span class="sxs-lookup"><span data-stu-id="d705e-1207">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="d705e-1208">Ist die Zielvariable ein Objekt, das eine Zeichenfolge enthält `FilePut` schreibt eine 2-Byte-Deskriptor, identifiziert die `VarType(8)` des Objekts, ein 2-Byte-Deskriptor, der angibt, der Länge der Zeichenfolge und anschließend die Zeichenfolgendaten.</span><span class="sxs-lookup"><span data-stu-id="d705e-1208">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="d705e-1209">Die angegebene Datensatzlänge der `RecordLength` Parameter in der `FileOpen` Funktion muss mindestens vier Bytes größer als die tatsächliche Länge der Zeichenfolge sein.</span><span class="sxs-lookup"><span data-stu-id="d705e-1209">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="d705e-1210">Wenn Sie eine Zeichenfolge ohne Deskriptor ablegen möchten, sollten Sie übergeben `True` auf die `StringIsFixedLength` Parameter, und die Zeichenfolge, die Sie einlesen, sollte die richtige Länge.</span><span class="sxs-lookup"><span data-stu-id="d705e-1210">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="d705e-1211">Wenn die Zielvariable ein Array ist, müssen Sie eine Auswahl, ob einen Deskriptor für die Größe und die Dimensionen des Arrays zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1211">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="d705e-1212">Visual Basic 6.0 und früheren Versionen Dateideskriptor für dynamische Arrays und nicht für Arrays mit fester Größe zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1212">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="d705e-1213">Visual Basic 2005 standardmäßig kein Deskriptor geschrieben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1213">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="d705e-1214">Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`.</span><span class="sxs-lookup"><span data-stu-id="d705e-1214">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="d705e-1215">Wenn das Array zu schreiben, müssen Sie entsprechend der Weise wird das Array gelesen werden; Wenn mit dem Deskriptor gelesen werden, müssen Sie den Deskriptor schreiben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1215">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="d705e-1216">Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang.</span><span class="sxs-lookup"><span data-stu-id="d705e-1216">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="d705e-1217">Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl von Dimensionen: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="d705e-1217">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="d705e-1218">Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Arraydeskriptor zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1218">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="d705e-1219">Die folgende Arraydeklaration erfordert z. B. 218 Bytes, wenn das Array geschrieben wird auf den Datenträger.</span><span class="sxs-lookup"><span data-stu-id="d705e-1219">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="d705e-1220">Wenn die Zielvariable einen anderen Typ der Variable (keine Zeichenfolge variabler Länge oder ein Objekt), ist `FilePut` schreibt nur die Daten der Variablen.</span><span class="sxs-lookup"><span data-stu-id="d705e-1220">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="d705e-1221">Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge der zu schreibenden Daten.</span><span class="sxs-lookup"><span data-stu-id="d705e-1221">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="d705e-1222">`FilePut` Schreibt die Elemente von Strukturen, als ob jeder einzeln geschrieben wurden jedoch keine Auffüllung zwischen Elementen.</span><span class="sxs-lookup"><span data-stu-id="d705e-1222">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="d705e-1223">Die `VBFixedString` Attribut angewendet werden kann, zu Zeichenfolgenfeldern in den Strukturen an, dass die Größe der Zeichenfolge beim Schreiben auf den Datenträger.</span><span class="sxs-lookup"><span data-stu-id="d705e-1223">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="d705e-1224">String-Felder, die mehr als Bytes angegeben die `VBFixedString` Attribut werden abgeschnitten, beim Schreiben auf den Datenträger</span><span class="sxs-lookup"><span data-stu-id="d705e-1224">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="d705e-1225">Binärmodus</span><span class="sxs-lookup"><span data-stu-id="d705e-1225">Binary Mode</span></span>  
 <span data-ttu-id="d705e-1226">Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` -Modus-Regeln gelten, bis auf einige Ausnahmen.</span><span class="sxs-lookup"><span data-stu-id="d705e-1226">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="d705e-1227">Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:</span><span class="sxs-lookup"><span data-stu-id="d705e-1227">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="d705e-1228">Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen.</span><span class="sxs-lookup"><span data-stu-id="d705e-1228">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="d705e-1229">`FilePut` Schreibt alle Variablen zusammenhängend, d. h. ohne Leerraum zwischen Datensätzen Datenträger an.</span><span class="sxs-lookup"><span data-stu-id="d705e-1229">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="d705e-1230">Für ein beliebiges Array als ein Array in einer Struktur `FilePut` schreibt nur die Daten.</span><span class="sxs-lookup"><span data-stu-id="d705e-1230">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="d705e-1231">Es wird kein Deskriptor geschrieben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1231">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="d705e-1232">`FilePut` schreibt Zeichenfolgen variabler Länge, die keine Elemente von Strukturen ohne Längendeskriptor 2-Byte-sind.</span><span class="sxs-lookup"><span data-stu-id="d705e-1232">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="d705e-1233">Die Anzahl der geschriebenen Bytes entspricht die Anzahl der Zeichen in der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="d705e-1233">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="d705e-1234">Die folgenden Anweisungen wird z. B. 11 Bytes Datei Zahl 1 schreiben:</span><span class="sxs-lookup"><span data-stu-id="d705e-1234">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="d705e-1235">Schreiben in eine Datei mithilfe der `FilePut` -Funktion erfordert `Write` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.</span><span class="sxs-lookup"><span data-stu-id="d705e-1235">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d705e-1236">Dieses Beispiel verwendet die `FilePut` Funktion, um Daten in eine Datei schreiben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1236">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="d705e-1237">Fünf Datensätze der Struktur `Person` in die Datei geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="d705e-1237">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="d705e-1238"><paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</span><span class="sxs-lookup"><span data-stu-id="d705e-1238"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="d705e-1239">Dateimodus ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="d705e-1239">File mode is invalid.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, char Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, char Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Char, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="d705e-1240">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-1240">Required.</span></span> <span data-ttu-id="d705e-1241">Eine beliebige gültige Dateinummer.</span><span class="sxs-lookup"><span data-stu-id="d705e-1241">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="d705e-1242">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-1242">Required.</span></span> <span data-ttu-id="d705e-1243">Gültiger Variablenname, der auf den Datenträger geschriebene Daten enthält.</span><span class="sxs-lookup"><span data-stu-id="d705e-1243">Valid variable name that contains data written to disk.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="d705e-1244">Dies ist optional.</span><span class="sxs-lookup"><span data-stu-id="d705e-1244">Optional.</span></span> <span data-ttu-id="d705e-1245">Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), an der der Schreibvorgang beginnt.</span><span class="sxs-lookup"><span data-stu-id="d705e-1245">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span></span></param>
        <summary><span data-ttu-id="d705e-1246">Schreibt Daten aus einer Variablen in eine Datei auf einem Datenträger.</span><span class="sxs-lookup"><span data-stu-id="d705e-1246">Writes data from a variable to a disk file.</span></span> <span data-ttu-id="d705e-1247">Das <see langword="My" />-Feature bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FilePut" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-1247">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span></span> <span data-ttu-id="d705e-1248">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-1248">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d705e-1249">`FilePut` gilt nur in `Random` und `Binary` Modus.</span><span class="sxs-lookup"><span data-stu-id="d705e-1249">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="d705e-1250">Mit `FilePut` geschriebene Daten werden in der Regel mit `FileGet` aus einer Datei gelesen.</span><span class="sxs-lookup"><span data-stu-id="d705e-1250">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="d705e-1251">Der erste Datensatz oder Byte in einer Datei befindet sich an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 usw. ist.</span><span class="sxs-lookup"><span data-stu-id="d705e-1251">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="d705e-1252">Wenn Sie weglassen `RecordNumber`, den nächsten Datensatz bzw. Byte nach dem letzten `FileGet` oder `FilePut` Funktion oder verweist, zu dem letzten `Seek` Funktion geschrieben wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-1252">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="d705e-1253">Die `StringIsFixedLength` -Argument steuert, ob die Funktion Zeichenfolgen als Variable oder feste Länge interpretiert.</span><span class="sxs-lookup"><span data-stu-id="d705e-1253">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="d705e-1254">`FilePut` den Längendeskriptor wird nicht geschrieben werden, wenn das Argument ist `True`.</span><span class="sxs-lookup"><span data-stu-id="d705e-1254">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="d705e-1255">Bei Verwendung von `StringIsFixedLength`  =  `True` mit `FilePut`, was identisch mit `FileGet`, und Sie müssen sicherstellen, dass die Zeichenfolge mit der erwarteten Länge initialisiert wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-1255">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="d705e-1256">Zufällige Modus</span><span class="sxs-lookup"><span data-stu-id="d705e-1256">Random Mode</span></span>  
 <span data-ttu-id="d705e-1257">Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:</span><span class="sxs-lookup"><span data-stu-id="d705e-1257">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="d705e-1258">Wenn die Länge des zu schreibenden Daten kleiner als die Länge ist, angegeben der `RecordLength` -Klausel der `FileOpen` -Funktion, `FilePut` nachfolgende Datensätze auf Datensatzlänge schreibt.</span><span class="sxs-lookup"><span data-stu-id="d705e-1258">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="d705e-1259">Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt.</span><span class="sxs-lookup"><span data-stu-id="d705e-1259">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="d705e-1260">Da die Menge der Leerstellen Daten nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen empfiehlt sich, die Datensatzlänge der Länge der zu schreibenden Daten überein.</span><span class="sxs-lookup"><span data-stu-id="d705e-1260">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="d705e-1261">Ist die Länge des zu schreibenden Daten größer als die Länge, angegeben der `RecordLength` -Klausel der `FileOpen` -Funktion eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="d705e-1261">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="d705e-1262">Eine Zeichenfolge ist, die Zielvariable `FilePut` schreibt einen 2-Byte-Deskriptor, der die Länge der Zeichenfolge enthält, und schreibt dann die Daten, die in die Variable aufgenommen wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-1262">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="d705e-1263">Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge sein.</span><span class="sxs-lookup"><span data-stu-id="d705e-1263">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="d705e-1264">Wenn die Zielvariable ein Objekt ist, die einen numerischen Typ enthält `FilePut` zwei Bytes, identifizieren den `VarType` des Objekts und schreibt dann die Variable.</span><span class="sxs-lookup"><span data-stu-id="d705e-1264">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="d705e-1265">Enthält z. B. wenn ein Objekt zu schreiben, die eine ganze Zahl `FilePut` schreibt sechs Bytes: 2 Bytes, die Identifizierung des Objekts als `VarType(3)` (`Integer`) und vier Bytes, die Daten enthalten.</span><span class="sxs-lookup"><span data-stu-id="d705e-1265">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="d705e-1266">Die angegebene Datensatzlänge der `RecordLength` Parameter in der `FileOpen` Funktion muss mindestens zwei Bytes größer als die tatsächliche Anzahl von Bytes, die zum Speichern von Variablen erforderlich sein.</span><span class="sxs-lookup"><span data-stu-id="d705e-1266">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="d705e-1267">Ist die Zielvariable ein Objekt, das eine Zeichenfolge enthält `FilePut` schreibt eine 2-Byte-Deskriptor, identifiziert die `VarType(8)` des Objekts, ein 2-Byte-Deskriptor, der angibt, der Länge der Zeichenfolge und anschließend die Zeichenfolgendaten.</span><span class="sxs-lookup"><span data-stu-id="d705e-1267">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="d705e-1268">Die angegebene Datensatzlänge der `RecordLength` Parameter in der `FileOpen` Funktion muss mindestens vier Bytes größer als die tatsächliche Länge der Zeichenfolge sein.</span><span class="sxs-lookup"><span data-stu-id="d705e-1268">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="d705e-1269">Wenn Sie eine Zeichenfolge ohne Deskriptor ablegen möchten, sollten Sie übergeben `True` auf die `StringIsFixedLength` Parameter, und die Zeichenfolge, die Sie einlesen, sollte die richtige Länge.</span><span class="sxs-lookup"><span data-stu-id="d705e-1269">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="d705e-1270">Wenn die Zielvariable ein Array ist, müssen Sie eine Auswahl, ob einen Deskriptor für die Größe und die Dimensionen des Arrays zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1270">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="d705e-1271">Visual Basic 6.0 und früheren Versionen Dateideskriptor für dynamische Arrays und nicht für Arrays mit fester Größe zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1271">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="d705e-1272">Visual Basic 2005 standardmäßig kein Deskriptor geschrieben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1272">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="d705e-1273">Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`.</span><span class="sxs-lookup"><span data-stu-id="d705e-1273">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="d705e-1274">Wenn das Array zu schreiben, müssen Sie entsprechend der Weise wird das Array gelesen werden; Wenn mit dem Deskriptor gelesen werden, müssen Sie den Deskriptor schreiben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1274">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="d705e-1275">Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang.</span><span class="sxs-lookup"><span data-stu-id="d705e-1275">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="d705e-1276">Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl von Dimensionen: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="d705e-1276">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="d705e-1277">Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Arraydeskriptor zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1277">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="d705e-1278">Die folgende Arraydeklaration erfordert z. B. 218 Bytes, wenn das Array geschrieben wird auf den Datenträger.</span><span class="sxs-lookup"><span data-stu-id="d705e-1278">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="d705e-1279">Wenn die Zielvariable einen anderen Typ der Variable (keine Zeichenfolge variabler Länge oder ein Objekt), ist `FilePut` schreibt nur die Daten der Variablen.</span><span class="sxs-lookup"><span data-stu-id="d705e-1279">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="d705e-1280">Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge der zu schreibenden Daten.</span><span class="sxs-lookup"><span data-stu-id="d705e-1280">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="d705e-1281">`FilePut` Schreibt die Elemente von Strukturen, als ob jeder einzeln geschrieben wurden jedoch keine Auffüllung zwischen Elementen.</span><span class="sxs-lookup"><span data-stu-id="d705e-1281">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="d705e-1282">Die `VBFixedString` Attribut angewendet werden kann, zu Zeichenfolgenfeldern in den Strukturen an, dass die Größe der Zeichenfolge beim Schreiben auf den Datenträger.</span><span class="sxs-lookup"><span data-stu-id="d705e-1282">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="d705e-1283">String-Felder, die mehr als Bytes angegeben die `VBFixedString` Attribut werden abgeschnitten, beim Schreiben auf den Datenträger</span><span class="sxs-lookup"><span data-stu-id="d705e-1283">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="d705e-1284">Binärmodus</span><span class="sxs-lookup"><span data-stu-id="d705e-1284">Binary Mode</span></span>  
 <span data-ttu-id="d705e-1285">Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` -Modus-Regeln gelten, bis auf einige Ausnahmen.</span><span class="sxs-lookup"><span data-stu-id="d705e-1285">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="d705e-1286">Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:</span><span class="sxs-lookup"><span data-stu-id="d705e-1286">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="d705e-1287">Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen.</span><span class="sxs-lookup"><span data-stu-id="d705e-1287">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="d705e-1288">`FilePut` Schreibt alle Variablen zusammenhängend, d. h. ohne Leerraum zwischen Datensätzen Datenträger an.</span><span class="sxs-lookup"><span data-stu-id="d705e-1288">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="d705e-1289">Für ein beliebiges Array als ein Array in einer Struktur `FilePut` schreibt nur die Daten.</span><span class="sxs-lookup"><span data-stu-id="d705e-1289">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="d705e-1290">Es wird kein Deskriptor geschrieben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1290">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="d705e-1291">`FilePut` schreibt Zeichenfolgen variabler Länge, die keine Elemente von Strukturen ohne Längendeskriptor 2-Byte-sind.</span><span class="sxs-lookup"><span data-stu-id="d705e-1291">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="d705e-1292">Die Anzahl der geschriebenen Bytes entspricht die Anzahl der Zeichen in der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="d705e-1292">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="d705e-1293">Die folgenden Anweisungen wird z. B. 11 Bytes Datei Zahl 1 schreiben:</span><span class="sxs-lookup"><span data-stu-id="d705e-1293">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="d705e-1294">Schreiben in eine Datei mithilfe der `FilePut` -Funktion erfordert `Write` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.</span><span class="sxs-lookup"><span data-stu-id="d705e-1294">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d705e-1295">Dieses Beispiel verwendet die `FilePut` Funktion, um Daten in eine Datei schreiben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1295">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="d705e-1296">Fünf Datensätze der Struktur `Person` in die Datei geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="d705e-1296">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="d705e-1297"><paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</span><span class="sxs-lookup"><span data-stu-id="d705e-1297"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="d705e-1298">Dateimodus ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="d705e-1298">File mode is invalid.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, DateTime Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, valuetype System.DateTime Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As DateTime, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="d705e-1299">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-1299">Required.</span></span> <span data-ttu-id="d705e-1300">Eine beliebige gültige Dateinummer.</span><span class="sxs-lookup"><span data-stu-id="d705e-1300">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="d705e-1301">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-1301">Required.</span></span> <span data-ttu-id="d705e-1302">Gültiger Variablenname, der auf den Datenträger geschriebene Daten enthält.</span><span class="sxs-lookup"><span data-stu-id="d705e-1302">Valid variable name that contains data written to disk.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="d705e-1303">Dies ist optional.</span><span class="sxs-lookup"><span data-stu-id="d705e-1303">Optional.</span></span> <span data-ttu-id="d705e-1304">Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), an der der Schreibvorgang beginnt.</span><span class="sxs-lookup"><span data-stu-id="d705e-1304">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span></span></param>
        <summary><span data-ttu-id="d705e-1305">Schreibt Daten aus einer Variablen in eine Datei auf einem Datenträger.</span><span class="sxs-lookup"><span data-stu-id="d705e-1305">Writes data from a variable to a disk file.</span></span> <span data-ttu-id="d705e-1306">Das <see langword="My" />-Feature bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FilePut" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-1306">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span></span> <span data-ttu-id="d705e-1307">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-1307">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d705e-1308">`FilePut` gilt nur in `Random` und `Binary` Modus.</span><span class="sxs-lookup"><span data-stu-id="d705e-1308">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="d705e-1309">Mit `FilePut` geschriebene Daten werden in der Regel mit `FileGet` aus einer Datei gelesen.</span><span class="sxs-lookup"><span data-stu-id="d705e-1309">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="d705e-1310">Der erste Datensatz oder Byte in einer Datei befindet sich an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 usw. ist.</span><span class="sxs-lookup"><span data-stu-id="d705e-1310">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="d705e-1311">Wenn Sie weglassen `RecordNumber`, den nächsten Datensatz bzw. Byte nach dem letzten `FileGet` oder `FilePut` Funktion oder verweist, zu dem letzten `Seek` Funktion geschrieben wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-1311">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="d705e-1312">Die `StringIsFixedLength` -Argument steuert, ob die Funktion Zeichenfolgen als Variable oder feste Länge interpretiert.</span><span class="sxs-lookup"><span data-stu-id="d705e-1312">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="d705e-1313">`FilePut` den Längendeskriptor wird nicht geschrieben werden, wenn das Argument ist `True`.</span><span class="sxs-lookup"><span data-stu-id="d705e-1313">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="d705e-1314">Bei Verwendung von `StringIsFixedLength`  =  `True` mit `FilePut`, was identisch mit `FileGet`, und Sie müssen sicherstellen, dass die Zeichenfolge mit der erwarteten Länge initialisiert wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-1314">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="d705e-1315">Zufällige Modus</span><span class="sxs-lookup"><span data-stu-id="d705e-1315">Random Mode</span></span>  
 <span data-ttu-id="d705e-1316">Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:</span><span class="sxs-lookup"><span data-stu-id="d705e-1316">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="d705e-1317">Wenn die Länge des zu schreibenden Daten kleiner als die Länge ist, angegeben der `RecordLength` -Klausel der `FileOpen` -Funktion, `FilePut` nachfolgende Datensätze auf Datensatzlänge schreibt.</span><span class="sxs-lookup"><span data-stu-id="d705e-1317">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="d705e-1318">Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt.</span><span class="sxs-lookup"><span data-stu-id="d705e-1318">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="d705e-1319">Da die Menge der Leerstellen Daten nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen empfiehlt sich, die Datensatzlänge der Länge der zu schreibenden Daten überein.</span><span class="sxs-lookup"><span data-stu-id="d705e-1319">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="d705e-1320">Ist die Länge des zu schreibenden Daten größer als die Länge, angegeben der `RecordLength` -Klausel der `FileOpen` -Funktion eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="d705e-1320">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="d705e-1321">Eine Zeichenfolge ist, die Zielvariable `FilePut` schreibt einen 2-Byte-Deskriptor, der die Länge der Zeichenfolge enthält, und schreibt dann die Daten, die in die Variable aufgenommen wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-1321">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="d705e-1322">Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge sein.</span><span class="sxs-lookup"><span data-stu-id="d705e-1322">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="d705e-1323">Wenn die Zielvariable ein Objekt ist, die einen numerischen Typ enthält `FilePut` zwei Bytes, identifizieren den `VarType` des Objekts und schreibt dann die Variable.</span><span class="sxs-lookup"><span data-stu-id="d705e-1323">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="d705e-1324">Enthält z. B. wenn ein Objekt zu schreiben, die eine ganze Zahl `FilePut` schreibt sechs Bytes: 2 Bytes, die Identifizierung des Objekts als `VarType(3)` (`Integer`) und vier Bytes, die Daten enthalten.</span><span class="sxs-lookup"><span data-stu-id="d705e-1324">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="d705e-1325">Die angegebene Datensatzlänge der `RecordLength` Parameter in der `FileOpen` Funktion muss mindestens zwei Bytes größer als die tatsächliche Anzahl von Bytes, die zum Speichern von Variablen erforderlich sein.</span><span class="sxs-lookup"><span data-stu-id="d705e-1325">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="d705e-1326">Ist die Zielvariable ein Objekt, das eine Zeichenfolge enthält `FilePut` schreibt eine 2-Byte-Deskriptor, identifiziert die `VarType(8)` des Objekts, ein 2-Byte-Deskriptor, der angibt, der Länge der Zeichenfolge und anschließend die Zeichenfolgendaten.</span><span class="sxs-lookup"><span data-stu-id="d705e-1326">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="d705e-1327">Die angegebene Datensatzlänge der `RecordLength` Parameter in der `FileOpen` Funktion muss mindestens vier Bytes größer als die tatsächliche Länge der Zeichenfolge sein.</span><span class="sxs-lookup"><span data-stu-id="d705e-1327">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="d705e-1328">Wenn Sie eine Zeichenfolge ohne Deskriptor ablegen möchten, sollten Sie übergeben `True` auf die `StringIsFixedLength` Parameter, und die Zeichenfolge, die Sie einlesen, sollte die richtige Länge.</span><span class="sxs-lookup"><span data-stu-id="d705e-1328">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="d705e-1329">Wenn die Zielvariable ein Array ist, müssen Sie eine Auswahl, ob einen Deskriptor für die Größe und die Dimensionen des Arrays zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1329">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="d705e-1330">Visual Basic 6.0 und früheren Versionen Dateideskriptor für dynamische Arrays und nicht für Arrays mit fester Größe zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1330">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="d705e-1331">Visual Basic 2005 standardmäßig kein Deskriptor geschrieben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1331">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="d705e-1332">Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`.</span><span class="sxs-lookup"><span data-stu-id="d705e-1332">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="d705e-1333">Wenn das Array zu schreiben, müssen Sie entsprechend der Weise wird das Array gelesen werden; Wenn mit dem Deskriptor gelesen werden, müssen Sie den Deskriptor schreiben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1333">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="d705e-1334">Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang.</span><span class="sxs-lookup"><span data-stu-id="d705e-1334">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="d705e-1335">Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl von Dimensionen: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="d705e-1335">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="d705e-1336">Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Arraydeskriptor zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1336">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="d705e-1337">Die folgende Arraydeklaration erfordert z. B. 218 Bytes, wenn das Array geschrieben wird auf den Datenträger.</span><span class="sxs-lookup"><span data-stu-id="d705e-1337">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="d705e-1338">Wenn die Zielvariable einen anderen Typ der Variable (keine Zeichenfolge variabler Länge oder ein Objekt), ist `FilePut` schreibt nur die Daten der Variablen.</span><span class="sxs-lookup"><span data-stu-id="d705e-1338">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="d705e-1339">Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge der zu schreibenden Daten.</span><span class="sxs-lookup"><span data-stu-id="d705e-1339">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="d705e-1340">`FilePut` Schreibt die Elemente von Strukturen, als ob jeder einzeln geschrieben wurden jedoch keine Auffüllung zwischen Elementen.</span><span class="sxs-lookup"><span data-stu-id="d705e-1340">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="d705e-1341">Die `VBFixedString` Attribut angewendet werden kann, zu Zeichenfolgenfeldern in den Strukturen an, dass die Größe der Zeichenfolge beim Schreiben auf den Datenträger.</span><span class="sxs-lookup"><span data-stu-id="d705e-1341">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="d705e-1342">String-Felder, die mehr als Bytes angegeben die `VBFixedString` Attribut werden abgeschnitten, beim Schreiben auf den Datenträger</span><span class="sxs-lookup"><span data-stu-id="d705e-1342">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="d705e-1343">Binärmodus</span><span class="sxs-lookup"><span data-stu-id="d705e-1343">Binary Mode</span></span>  
 <span data-ttu-id="d705e-1344">Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` -Modus-Regeln gelten, bis auf einige Ausnahmen.</span><span class="sxs-lookup"><span data-stu-id="d705e-1344">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="d705e-1345">Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:</span><span class="sxs-lookup"><span data-stu-id="d705e-1345">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="d705e-1346">Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen.</span><span class="sxs-lookup"><span data-stu-id="d705e-1346">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="d705e-1347">`FilePut` Schreibt alle Variablen zusammenhängend, d. h. ohne Leerraum zwischen Datensätzen Datenträger an.</span><span class="sxs-lookup"><span data-stu-id="d705e-1347">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="d705e-1348">Für ein beliebiges Array als ein Array in einer Struktur `FilePut` schreibt nur die Daten.</span><span class="sxs-lookup"><span data-stu-id="d705e-1348">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="d705e-1349">Es wird kein Deskriptor geschrieben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1349">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="d705e-1350">`FilePut` schreibt Zeichenfolgen variabler Länge, die keine Elemente von Strukturen ohne Längendeskriptor 2-Byte-sind.</span><span class="sxs-lookup"><span data-stu-id="d705e-1350">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="d705e-1351">Die Anzahl der geschriebenen Bytes entspricht die Anzahl der Zeichen in der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="d705e-1351">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="d705e-1352">Die folgenden Anweisungen wird z. B. 11 Bytes Datei Zahl 1 schreiben:</span><span class="sxs-lookup"><span data-stu-id="d705e-1352">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="d705e-1353">Schreiben in eine Datei mithilfe der `FilePut` -Funktion erfordert `Write` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.</span><span class="sxs-lookup"><span data-stu-id="d705e-1353">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d705e-1354">Dieses Beispiel verwendet die `FilePut` Funktion, um Daten in eine Datei schreiben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1354">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="d705e-1355">Fünf Datensätze der Struktur `Person` in die Datei geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="d705e-1355">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="d705e-1356"><paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</span><span class="sxs-lookup"><span data-stu-id="d705e-1356"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="d705e-1357">Dateimodus ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="d705e-1357">File mode is invalid.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, decimal Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, valuetype System.Decimal Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Decimal, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="d705e-1358">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-1358">Required.</span></span> <span data-ttu-id="d705e-1359">Eine beliebige gültige Dateinummer.</span><span class="sxs-lookup"><span data-stu-id="d705e-1359">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="d705e-1360">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-1360">Required.</span></span> <span data-ttu-id="d705e-1361">Gültiger Variablenname, der auf den Datenträger geschriebene Daten enthält.</span><span class="sxs-lookup"><span data-stu-id="d705e-1361">Valid variable name that contains data written to disk.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="d705e-1362">Dies ist optional.</span><span class="sxs-lookup"><span data-stu-id="d705e-1362">Optional.</span></span> <span data-ttu-id="d705e-1363">Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), an der der Schreibvorgang beginnt.</span><span class="sxs-lookup"><span data-stu-id="d705e-1363">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span></span></param>
        <summary><span data-ttu-id="d705e-1364">Schreibt Daten aus einer Variablen in eine Datei auf einem Datenträger.</span><span class="sxs-lookup"><span data-stu-id="d705e-1364">Writes data from a variable to a disk file.</span></span> <span data-ttu-id="d705e-1365">Das <see langword="My" />-Feature bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FilePut" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-1365">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span></span> <span data-ttu-id="d705e-1366">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-1366">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d705e-1367">`FilePut` gilt nur in `Random` und `Binary` Modus.</span><span class="sxs-lookup"><span data-stu-id="d705e-1367">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="d705e-1368">Mit `FilePut` geschriebene Daten werden in der Regel mit `FileGet` aus einer Datei gelesen.</span><span class="sxs-lookup"><span data-stu-id="d705e-1368">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="d705e-1369">Der erste Datensatz oder Byte in einer Datei befindet sich an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 usw. ist.</span><span class="sxs-lookup"><span data-stu-id="d705e-1369">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="d705e-1370">Wenn Sie weglassen `RecordNumber`, den nächsten Datensatz bzw. Byte nach dem letzten `FileGet` oder `FilePut` Funktion oder verweist, zu dem letzten `Seek` Funktion geschrieben wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-1370">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="d705e-1371">Die `StringIsFixedLength` -Argument steuert, ob die Funktion Zeichenfolgen als Variable oder feste Länge interpretiert.</span><span class="sxs-lookup"><span data-stu-id="d705e-1371">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="d705e-1372">`FilePut` den Längendeskriptor wird nicht geschrieben werden, wenn das Argument ist `True`.</span><span class="sxs-lookup"><span data-stu-id="d705e-1372">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="d705e-1373">Bei Verwendung von `StringIsFixedLength`  =  `True` mit `FilePut`, was identisch mit `FileGet`, und Sie müssen sicherstellen, dass die Zeichenfolge mit der erwarteten Länge initialisiert wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-1373">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="d705e-1374">Zufällige Modus</span><span class="sxs-lookup"><span data-stu-id="d705e-1374">Random Mode</span></span>  
 <span data-ttu-id="d705e-1375">Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:</span><span class="sxs-lookup"><span data-stu-id="d705e-1375">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="d705e-1376">Wenn die Länge des zu schreibenden Daten kleiner als die Länge ist, angegeben der `RecordLength` -Klausel der `FileOpen` -Funktion, `FilePut` nachfolgende Datensätze auf Datensatzlänge schreibt.</span><span class="sxs-lookup"><span data-stu-id="d705e-1376">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="d705e-1377">Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt.</span><span class="sxs-lookup"><span data-stu-id="d705e-1377">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="d705e-1378">Da die Menge der Leerstellen Daten nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen empfiehlt sich, die Datensatzlänge der Länge der zu schreibenden Daten überein.</span><span class="sxs-lookup"><span data-stu-id="d705e-1378">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="d705e-1379">Ist die Länge des zu schreibenden Daten größer als die Länge, angegeben der `RecordLength` -Klausel der `FileOpen` -Funktion eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="d705e-1379">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="d705e-1380">Eine Zeichenfolge ist, die Zielvariable `FilePut` schreibt einen 2-Byte-Deskriptor, der die Länge der Zeichenfolge enthält, und schreibt dann die Daten, die in die Variable aufgenommen wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-1380">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="d705e-1381">Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge sein.</span><span class="sxs-lookup"><span data-stu-id="d705e-1381">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="d705e-1382">Wenn die Zielvariable ein Objekt ist, die einen numerischen Typ enthält `FilePut` zwei Bytes, identifizieren den `VarType` des Objekts und schreibt dann die Variable.</span><span class="sxs-lookup"><span data-stu-id="d705e-1382">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="d705e-1383">Enthält z. B. wenn ein Objekt zu schreiben, die eine ganze Zahl `FilePut` schreibt sechs Bytes: 2 Bytes, die Identifizierung des Objekts als `VarType(3)` (`Integer`) und vier Bytes, die Daten enthalten.</span><span class="sxs-lookup"><span data-stu-id="d705e-1383">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="d705e-1384">Die angegebene Datensatzlänge der `RecordLength` Parameter in der `FileOpen` Funktion muss mindestens zwei Bytes größer als die tatsächliche Anzahl von Bytes, die zum Speichern von Variablen erforderlich sein.</span><span class="sxs-lookup"><span data-stu-id="d705e-1384">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="d705e-1385">Ist die Zielvariable ein Objekt, das eine Zeichenfolge enthält `FilePut` schreibt eine 2-Byte-Deskriptor, identifiziert die `VarType(8)` des Objekts, ein 2-Byte-Deskriptor, der angibt, der Länge der Zeichenfolge und anschließend die Zeichenfolgendaten.</span><span class="sxs-lookup"><span data-stu-id="d705e-1385">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="d705e-1386">Die angegebene Datensatzlänge der `RecordLength` Parameter in der `FileOpen` Funktion muss mindestens vier Bytes größer als die tatsächliche Länge der Zeichenfolge sein.</span><span class="sxs-lookup"><span data-stu-id="d705e-1386">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="d705e-1387">Wenn Sie eine Zeichenfolge ohne Deskriptor ablegen möchten, sollten Sie übergeben `True` auf die `StringIsFixedLength` Parameter, und die Zeichenfolge, die Sie einlesen, sollte die richtige Länge.</span><span class="sxs-lookup"><span data-stu-id="d705e-1387">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="d705e-1388">Wenn die Zielvariable ein Array ist, müssen Sie eine Auswahl, ob einen Deskriptor für die Größe und die Dimensionen des Arrays zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1388">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="d705e-1389">Visual Basic 6.0 und früheren Versionen Dateideskriptor für dynamische Arrays und nicht für Arrays mit fester Größe zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1389">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="d705e-1390">Visual Basic 2005 standardmäßig kein Deskriptor geschrieben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1390">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="d705e-1391">Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`.</span><span class="sxs-lookup"><span data-stu-id="d705e-1391">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="d705e-1392">Wenn das Array zu schreiben, müssen Sie entsprechend der Weise wird das Array gelesen werden; Wenn mit dem Deskriptor gelesen werden, müssen Sie den Deskriptor schreiben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1392">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="d705e-1393">Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang.</span><span class="sxs-lookup"><span data-stu-id="d705e-1393">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="d705e-1394">Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl von Dimensionen: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="d705e-1394">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="d705e-1395">Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Arraydeskriptor zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1395">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="d705e-1396">Die folgende Arraydeklaration erfordert z. B. 218 Bytes, wenn das Array geschrieben wird auf den Datenträger.</span><span class="sxs-lookup"><span data-stu-id="d705e-1396">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="d705e-1397">Wenn die Zielvariable einen anderen Typ der Variable (keine Zeichenfolge variabler Länge oder ein Objekt), ist `FilePut` schreibt nur die Daten der Variablen.</span><span class="sxs-lookup"><span data-stu-id="d705e-1397">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="d705e-1398">Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge der zu schreibenden Daten.</span><span class="sxs-lookup"><span data-stu-id="d705e-1398">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="d705e-1399">`FilePut` Schreibt die Elemente von Strukturen, als ob jeder einzeln geschrieben wurden jedoch keine Auffüllung zwischen Elementen.</span><span class="sxs-lookup"><span data-stu-id="d705e-1399">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="d705e-1400">Die `VBFixedString` Attribut angewendet werden kann, zu Zeichenfolgenfeldern in den Strukturen an, dass die Größe der Zeichenfolge beim Schreiben auf den Datenträger.</span><span class="sxs-lookup"><span data-stu-id="d705e-1400">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="d705e-1401">String-Felder, die mehr als Bytes angegeben die `VBFixedString` Attribut werden abgeschnitten, beim Schreiben auf den Datenträger</span><span class="sxs-lookup"><span data-stu-id="d705e-1401">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="d705e-1402">Binärmodus</span><span class="sxs-lookup"><span data-stu-id="d705e-1402">Binary Mode</span></span>  
 <span data-ttu-id="d705e-1403">Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` -Modus-Regeln gelten, bis auf einige Ausnahmen.</span><span class="sxs-lookup"><span data-stu-id="d705e-1403">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="d705e-1404">Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:</span><span class="sxs-lookup"><span data-stu-id="d705e-1404">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="d705e-1405">Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen.</span><span class="sxs-lookup"><span data-stu-id="d705e-1405">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="d705e-1406">`FilePut` Schreibt alle Variablen zusammenhängend, d. h. ohne Leerraum zwischen Datensätzen Datenträger an.</span><span class="sxs-lookup"><span data-stu-id="d705e-1406">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="d705e-1407">Für ein beliebiges Array als ein Array in einer Struktur `FilePut` schreibt nur die Daten.</span><span class="sxs-lookup"><span data-stu-id="d705e-1407">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="d705e-1408">Es wird kein Deskriptor geschrieben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1408">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="d705e-1409">`FilePut` schreibt Zeichenfolgen variabler Länge, die keine Elemente von Strukturen ohne Längendeskriptor 2-Byte-sind.</span><span class="sxs-lookup"><span data-stu-id="d705e-1409">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="d705e-1410">Die Anzahl der geschriebenen Bytes entspricht die Anzahl der Zeichen in der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="d705e-1410">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="d705e-1411">Die folgenden Anweisungen wird z. B. 11 Bytes Datei Zahl 1 schreiben:</span><span class="sxs-lookup"><span data-stu-id="d705e-1411">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="d705e-1412">Schreiben in eine Datei mithilfe der `FilePut` -Funktion erfordert `Write` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.</span><span class="sxs-lookup"><span data-stu-id="d705e-1412">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d705e-1413">Dieses Beispiel verwendet die `FilePut` Funktion, um Daten in eine Datei schreiben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1413">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="d705e-1414">Fünf Datensätze der Struktur `Person` in die Datei geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="d705e-1414">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="d705e-1415"><paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</span><span class="sxs-lookup"><span data-stu-id="d705e-1415"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="d705e-1416">Dateimodus ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="d705e-1416">File mode is invalid.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, double Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, float64 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Double, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="d705e-1417">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-1417">Required.</span></span> <span data-ttu-id="d705e-1418">Eine beliebige gültige Dateinummer.</span><span class="sxs-lookup"><span data-stu-id="d705e-1418">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="d705e-1419">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-1419">Required.</span></span> <span data-ttu-id="d705e-1420">Gültiger Variablenname, der auf den Datenträger geschriebene Daten enthält.</span><span class="sxs-lookup"><span data-stu-id="d705e-1420">Valid variable name that contains data written to disk.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="d705e-1421">Dies ist optional.</span><span class="sxs-lookup"><span data-stu-id="d705e-1421">Optional.</span></span> <span data-ttu-id="d705e-1422">Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), an der der Schreibvorgang beginnt.</span><span class="sxs-lookup"><span data-stu-id="d705e-1422">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span></span></param>
        <summary><span data-ttu-id="d705e-1423">Schreibt Daten aus einer Variablen in eine Datei auf einem Datenträger.</span><span class="sxs-lookup"><span data-stu-id="d705e-1423">Writes data from a variable to a disk file.</span></span> <span data-ttu-id="d705e-1424">Das <see langword="My" />-Feature bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FilePut" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-1424">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span></span> <span data-ttu-id="d705e-1425">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-1425">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d705e-1426">`FilePut` gilt nur in `Random` und `Binary` Modus.</span><span class="sxs-lookup"><span data-stu-id="d705e-1426">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="d705e-1427">Mit `FilePut` geschriebene Daten werden in der Regel mit `FileGet` aus einer Datei gelesen.</span><span class="sxs-lookup"><span data-stu-id="d705e-1427">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="d705e-1428">Der erste Datensatz oder Byte in einer Datei befindet sich an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 usw. ist.</span><span class="sxs-lookup"><span data-stu-id="d705e-1428">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="d705e-1429">Wenn Sie weglassen `RecordNumber`, den nächsten Datensatz bzw. Byte nach dem letzten `FileGet` oder `FilePut` Funktion oder verweist, zu dem letzten `Seek` Funktion geschrieben wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-1429">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="d705e-1430">Die `StringIsFixedLength` -Argument steuert, ob die Funktion Zeichenfolgen als Variable oder feste Länge interpretiert.</span><span class="sxs-lookup"><span data-stu-id="d705e-1430">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="d705e-1431">`FilePut` den Längendeskriptor wird nicht geschrieben werden, wenn das Argument ist `True`.</span><span class="sxs-lookup"><span data-stu-id="d705e-1431">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="d705e-1432">Bei Verwendung von `StringIsFixedLength`  =  `True` mit `FilePut`, was identisch mit `FileGet`, und Sie müssen sicherstellen, dass die Zeichenfolge mit der erwarteten Länge initialisiert wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-1432">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="d705e-1433">Zufällige Modus</span><span class="sxs-lookup"><span data-stu-id="d705e-1433">Random Mode</span></span>  
 <span data-ttu-id="d705e-1434">Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:</span><span class="sxs-lookup"><span data-stu-id="d705e-1434">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="d705e-1435">Wenn die Länge des zu schreibenden Daten kleiner als die Länge ist, angegeben der `RecordLength` -Klausel der `FileOpen` -Funktion, `FilePut` nachfolgende Datensätze auf Datensatzlänge schreibt.</span><span class="sxs-lookup"><span data-stu-id="d705e-1435">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="d705e-1436">Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt.</span><span class="sxs-lookup"><span data-stu-id="d705e-1436">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="d705e-1437">Da die Menge der Leerstellen Daten nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen empfiehlt sich, die Datensatzlänge der Länge der zu schreibenden Daten überein.</span><span class="sxs-lookup"><span data-stu-id="d705e-1437">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="d705e-1438">Ist die Länge des zu schreibenden Daten größer als die Länge, angegeben der `RecordLength` -Klausel der `FileOpen` -Funktion eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="d705e-1438">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="d705e-1439">Eine Zeichenfolge ist, die Zielvariable `FilePut` schreibt einen 2-Byte-Deskriptor, der die Länge der Zeichenfolge enthält, und schreibt dann die Daten, die in die Variable aufgenommen wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-1439">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="d705e-1440">Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge sein.</span><span class="sxs-lookup"><span data-stu-id="d705e-1440">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="d705e-1441">Wenn die Zielvariable ein Objekt ist, die einen numerischen Typ enthält `FilePut` zwei Bytes, identifizieren den `VarType` des Objekts und schreibt dann die Variable.</span><span class="sxs-lookup"><span data-stu-id="d705e-1441">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="d705e-1442">Enthält z. B. wenn ein Objekt zu schreiben, die eine ganze Zahl `FilePut` schreibt sechs Bytes: 2 Bytes, die Identifizierung des Objekts als `VarType(3)` (`Integer`) und vier Bytes, die Daten enthalten.</span><span class="sxs-lookup"><span data-stu-id="d705e-1442">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="d705e-1443">Die angegebene Datensatzlänge der `RecordLength` Parameter in der `FileOpen` Funktion muss mindestens zwei Bytes größer als die tatsächliche Anzahl von Bytes, die zum Speichern von Variablen erforderlich sein.</span><span class="sxs-lookup"><span data-stu-id="d705e-1443">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="d705e-1444">Ist die Zielvariable ein Objekt, das eine Zeichenfolge enthält `FilePut` schreibt eine 2-Byte-Deskriptor, identifiziert die `VarType(8)` des Objekts, ein 2-Byte-Deskriptor, der angibt, der Länge der Zeichenfolge und anschließend die Zeichenfolgendaten.</span><span class="sxs-lookup"><span data-stu-id="d705e-1444">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="d705e-1445">Die angegebene Datensatzlänge der `RecordLength` Parameter in der `FileOpen` Funktion muss mindestens vier Bytes größer als die tatsächliche Länge der Zeichenfolge sein.</span><span class="sxs-lookup"><span data-stu-id="d705e-1445">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="d705e-1446">Wenn Sie eine Zeichenfolge ohne Deskriptor ablegen möchten, sollten Sie übergeben `True` auf die `StringIsFixedLength` Parameter, und die Zeichenfolge, die Sie einlesen, sollte die richtige Länge.</span><span class="sxs-lookup"><span data-stu-id="d705e-1446">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="d705e-1447">Wenn die Zielvariable ein Array ist, müssen Sie eine Auswahl, ob einen Deskriptor für die Größe und die Dimensionen des Arrays zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1447">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="d705e-1448">Visual Basic 6.0 und früheren Versionen Dateideskriptor für dynamische Arrays und nicht für Arrays mit fester Größe zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1448">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="d705e-1449">Visual Basic 2005 standardmäßig kein Deskriptor geschrieben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1449">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="d705e-1450">Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`.</span><span class="sxs-lookup"><span data-stu-id="d705e-1450">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="d705e-1451">Wenn das Array zu schreiben, müssen Sie entsprechend der Weise wird das Array gelesen werden; Wenn mit dem Deskriptor gelesen werden, müssen Sie den Deskriptor schreiben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1451">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="d705e-1452">Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang.</span><span class="sxs-lookup"><span data-stu-id="d705e-1452">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="d705e-1453">Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl von Dimensionen: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="d705e-1453">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="d705e-1454">Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Arraydeskriptor zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1454">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="d705e-1455">Die folgende Arraydeklaration erfordert z. B. 218 Bytes, wenn das Array geschrieben wird auf den Datenträger.</span><span class="sxs-lookup"><span data-stu-id="d705e-1455">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="d705e-1456">Wenn die Zielvariable einen anderen Typ der Variable (keine Zeichenfolge variabler Länge oder ein Objekt), ist `FilePut` schreibt nur die Daten der Variablen.</span><span class="sxs-lookup"><span data-stu-id="d705e-1456">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="d705e-1457">Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge der zu schreibenden Daten.</span><span class="sxs-lookup"><span data-stu-id="d705e-1457">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="d705e-1458">`FilePut` Schreibt die Elemente von Strukturen, als ob jeder einzeln geschrieben wurden jedoch keine Auffüllung zwischen Elementen.</span><span class="sxs-lookup"><span data-stu-id="d705e-1458">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="d705e-1459">Die `VBFixedString` Attribut angewendet werden kann, zu Zeichenfolgenfeldern in den Strukturen an, dass die Größe der Zeichenfolge beim Schreiben auf den Datenträger.</span><span class="sxs-lookup"><span data-stu-id="d705e-1459">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="d705e-1460">String-Felder, die mehr als Bytes angegeben die `VBFixedString` Attribut werden abgeschnitten, beim Schreiben auf den Datenträger</span><span class="sxs-lookup"><span data-stu-id="d705e-1460">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="d705e-1461">Binärmodus</span><span class="sxs-lookup"><span data-stu-id="d705e-1461">Binary Mode</span></span>  
 <span data-ttu-id="d705e-1462">Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` -Modus-Regeln gelten, bis auf einige Ausnahmen.</span><span class="sxs-lookup"><span data-stu-id="d705e-1462">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="d705e-1463">Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:</span><span class="sxs-lookup"><span data-stu-id="d705e-1463">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="d705e-1464">Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen.</span><span class="sxs-lookup"><span data-stu-id="d705e-1464">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="d705e-1465">`FilePut` Schreibt alle Variablen zusammenhängend, d. h. ohne Leerraum zwischen Datensätzen Datenträger an.</span><span class="sxs-lookup"><span data-stu-id="d705e-1465">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="d705e-1466">Für ein beliebiges Array als ein Array in einer Struktur `FilePut` schreibt nur die Daten.</span><span class="sxs-lookup"><span data-stu-id="d705e-1466">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="d705e-1467">Es wird kein Deskriptor geschrieben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1467">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="d705e-1468">`FilePut` schreibt Zeichenfolgen variabler Länge, die keine Elemente von Strukturen ohne Längendeskriptor 2-Byte-sind.</span><span class="sxs-lookup"><span data-stu-id="d705e-1468">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="d705e-1469">Die Anzahl der geschriebenen Bytes entspricht die Anzahl der Zeichen in der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="d705e-1469">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="d705e-1470">Die folgenden Anweisungen wird z. B. 11 Bytes Datei Zahl 1 schreiben:</span><span class="sxs-lookup"><span data-stu-id="d705e-1470">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="d705e-1471">Schreiben in eine Datei mithilfe der `FilePut` -Funktion erfordert `Write` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.</span><span class="sxs-lookup"><span data-stu-id="d705e-1471">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d705e-1472">Dieses Beispiel verwendet die `FilePut` Funktion, um Daten in eine Datei schreiben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1472">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="d705e-1473">Fünf Datensätze der Struktur `Person` in die Datei geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="d705e-1473">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="d705e-1474"><paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</span><span class="sxs-lookup"><span data-stu-id="d705e-1474"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="d705e-1475">Dateimodus ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="d705e-1475">File mode is invalid.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, short Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int16 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Short, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="d705e-1476">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-1476">Required.</span></span> <span data-ttu-id="d705e-1477">Eine beliebige gültige Dateinummer.</span><span class="sxs-lookup"><span data-stu-id="d705e-1477">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="d705e-1478">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-1478">Required.</span></span> <span data-ttu-id="d705e-1479">Gültiger Variablenname, der auf den Datenträger geschriebene Daten enthält.</span><span class="sxs-lookup"><span data-stu-id="d705e-1479">Valid variable name that contains data written to disk.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="d705e-1480">Dies ist optional.</span><span class="sxs-lookup"><span data-stu-id="d705e-1480">Optional.</span></span> <span data-ttu-id="d705e-1481">Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), an der der Schreibvorgang beginnt.</span><span class="sxs-lookup"><span data-stu-id="d705e-1481">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span></span></param>
        <summary><span data-ttu-id="d705e-1482">Schreibt Daten aus einer Variablen in eine Datei auf einem Datenträger.</span><span class="sxs-lookup"><span data-stu-id="d705e-1482">Writes data from a variable to a disk file.</span></span> <span data-ttu-id="d705e-1483">Das <see langword="My" />-Feature bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FilePut" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-1483">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span></span> <span data-ttu-id="d705e-1484">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-1484">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d705e-1485">`FilePut` gilt nur in `Random` und `Binary` Modus.</span><span class="sxs-lookup"><span data-stu-id="d705e-1485">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="d705e-1486">Mit `FilePut` geschriebene Daten werden in der Regel mit `FileGet` aus einer Datei gelesen.</span><span class="sxs-lookup"><span data-stu-id="d705e-1486">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="d705e-1487">Der erste Datensatz oder Byte in einer Datei befindet sich an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 usw. ist.</span><span class="sxs-lookup"><span data-stu-id="d705e-1487">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="d705e-1488">Wenn Sie weglassen `RecordNumber`, den nächsten Datensatz bzw. Byte nach dem letzten `FileGet` oder `FilePut` Funktion oder verweist, zu dem letzten `Seek` Funktion geschrieben wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-1488">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="d705e-1489">Die `StringIsFixedLength` -Argument steuert, ob die Funktion Zeichenfolgen als Variable oder feste Länge interpretiert.</span><span class="sxs-lookup"><span data-stu-id="d705e-1489">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="d705e-1490">`FilePut` den Längendeskriptor wird nicht geschrieben werden, wenn das Argument ist `True`.</span><span class="sxs-lookup"><span data-stu-id="d705e-1490">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="d705e-1491">Bei Verwendung von `StringIsFixedLength`  =  `True` mit `FilePut`, was identisch mit `FileGet`, und Sie müssen sicherstellen, dass die Zeichenfolge mit der erwarteten Länge initialisiert wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-1491">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="d705e-1492">Zufällige Modus</span><span class="sxs-lookup"><span data-stu-id="d705e-1492">Random Mode</span></span>  
 <span data-ttu-id="d705e-1493">Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:</span><span class="sxs-lookup"><span data-stu-id="d705e-1493">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="d705e-1494">Wenn die Länge des zu schreibenden Daten kleiner als die Länge ist, angegeben der `RecordLength` -Klausel der `FileOpen` -Funktion, `FilePut` nachfolgende Datensätze auf Datensatzlänge schreibt.</span><span class="sxs-lookup"><span data-stu-id="d705e-1494">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="d705e-1495">Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt.</span><span class="sxs-lookup"><span data-stu-id="d705e-1495">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="d705e-1496">Da die Menge der Leerstellen Daten nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen empfiehlt sich, die Datensatzlänge der Länge der zu schreibenden Daten überein.</span><span class="sxs-lookup"><span data-stu-id="d705e-1496">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="d705e-1497">Ist die Länge des zu schreibenden Daten größer als die Länge, angegeben der `RecordLength` -Klausel der `FileOpen` -Funktion eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="d705e-1497">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="d705e-1498">Eine Zeichenfolge ist, die Zielvariable `FilePut` schreibt einen 2-Byte-Deskriptor, der die Länge der Zeichenfolge enthält, und schreibt dann die Daten, die in die Variable aufgenommen wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-1498">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="d705e-1499">Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge sein.</span><span class="sxs-lookup"><span data-stu-id="d705e-1499">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="d705e-1500">Wenn die Zielvariable ein Objekt ist, die einen numerischen Typ enthält `FilePut` zwei Bytes, identifizieren den `VarType` des Objekts und schreibt dann die Variable.</span><span class="sxs-lookup"><span data-stu-id="d705e-1500">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="d705e-1501">Enthält z. B. wenn ein Objekt zu schreiben, die eine ganze Zahl `FilePut` schreibt sechs Bytes: 2 Bytes, die Identifizierung des Objekts als `VarType(3)` (`Integer`) und vier Bytes, die Daten enthalten.</span><span class="sxs-lookup"><span data-stu-id="d705e-1501">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="d705e-1502">Die angegebene Datensatzlänge der `RecordLength` Parameter in der `FileOpen` Funktion muss mindestens zwei Bytes größer als die tatsächliche Anzahl von Bytes, die zum Speichern von Variablen erforderlich sein.</span><span class="sxs-lookup"><span data-stu-id="d705e-1502">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="d705e-1503">Ist die Zielvariable ein Objekt, das eine Zeichenfolge enthält `FilePut` schreibt eine 2-Byte-Deskriptor, identifiziert die`VarType(8)` des Objekts, ein 2-Byte-Deskriptor, der angibt, der Länge der Zeichenfolge und anschließend die Zeichenfolgendaten.</span><span class="sxs-lookup"><span data-stu-id="d705e-1503">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the`VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="d705e-1504">Die angegebene Datensatzlänge der `RecordLength` Parameter in der `FileOpen` Funktion muss mindestens vier Bytes größer als die tatsächliche Länge der Zeichenfolge sein.</span><span class="sxs-lookup"><span data-stu-id="d705e-1504">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="d705e-1505">Wenn Sie eine Zeichenfolge ohne Deskriptor ablegen möchten, sollten Sie übergeben `True` auf die `StringIsFixedLength` Parameter, und die Zeichenfolge, die Sie einlesen, sollte die richtige Länge.</span><span class="sxs-lookup"><span data-stu-id="d705e-1505">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="d705e-1506">Wenn die Zielvariable ein Array ist, müssen Sie eine Auswahl, ob einen Deskriptor für die Größe und die Dimensionen des Arrays zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1506">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="d705e-1507">Visual Basic 6.0 und früheren Versionen Dateideskriptor für dynamische Arrays und nicht für Arrays mit fester Größe zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1507">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="d705e-1508">Visual Basic 2005 standardmäßig kein Deskriptor geschrieben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1508">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="d705e-1509">Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`.</span><span class="sxs-lookup"><span data-stu-id="d705e-1509">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="d705e-1510">Wenn das Array zu schreiben, müssen Sie entsprechend der Weise wird das Array gelesen werden; Wenn mit dem Deskriptor gelesen werden, müssen Sie den Deskriptor schreiben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1510">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="d705e-1511">Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang.</span><span class="sxs-lookup"><span data-stu-id="d705e-1511">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="d705e-1512">Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl von Dimensionen: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="d705e-1512">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="d705e-1513">Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Arraydeskriptor zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1513">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="d705e-1514">Die folgende Arraydeklaration erfordert z. B. 218 Bytes, wenn das Array geschrieben wird auf den Datenträger.</span><span class="sxs-lookup"><span data-stu-id="d705e-1514">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="d705e-1515">Wenn die Zielvariable einen anderen Typ der Variable (keine Zeichenfolge variabler Länge oder ein Objekt), ist `FilePut` schreibt nur die Daten der Variablen.</span><span class="sxs-lookup"><span data-stu-id="d705e-1515">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="d705e-1516">Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge der zu schreibenden Daten.</span><span class="sxs-lookup"><span data-stu-id="d705e-1516">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="d705e-1517">`FilePut` Schreibt die Elemente von Strukturen, als ob jeder einzeln geschrieben wurden jedoch keine Auffüllung zwischen Elementen.</span><span class="sxs-lookup"><span data-stu-id="d705e-1517">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="d705e-1518">Die `VBFixedString` Attribut angewendet werden kann, zu Zeichenfolgenfeldern in den Strukturen an, dass die Größe der Zeichenfolge beim Schreiben auf den Datenträger.</span><span class="sxs-lookup"><span data-stu-id="d705e-1518">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="d705e-1519">String-Felder, die mehr als Bytes angegeben die `VBFixedString` Attribut werden abgeschnitten, beim Schreiben auf den Datenträger</span><span class="sxs-lookup"><span data-stu-id="d705e-1519">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="d705e-1520">Binärmodus</span><span class="sxs-lookup"><span data-stu-id="d705e-1520">Binary Mode</span></span>  
 <span data-ttu-id="d705e-1521">Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` -Modus-Regeln gelten, bis auf einige Ausnahmen.</span><span class="sxs-lookup"><span data-stu-id="d705e-1521">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="d705e-1522">Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:</span><span class="sxs-lookup"><span data-stu-id="d705e-1522">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="d705e-1523">Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen.</span><span class="sxs-lookup"><span data-stu-id="d705e-1523">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="d705e-1524">`FilePut` Schreibt alle Variablen zusammenhängend, d. h. ohne Leerraum zwischen Datensätzen Datenträger an.</span><span class="sxs-lookup"><span data-stu-id="d705e-1524">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="d705e-1525">Für ein beliebiges Array als ein Array in einer Struktur `FilePut` schreibt nur die Daten.</span><span class="sxs-lookup"><span data-stu-id="d705e-1525">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="d705e-1526">Es wird kein Deskriptor geschrieben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1526">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="d705e-1527">`FilePut` schreibt Zeichenfolgen variabler Länge, die keine Elemente von Strukturen ohne Längendeskriptor 2-Byte-sind.</span><span class="sxs-lookup"><span data-stu-id="d705e-1527">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="d705e-1528">Die Anzahl der geschriebenen Bytes entspricht die Anzahl der Zeichen in der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="d705e-1528">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="d705e-1529">Die folgenden Anweisungen wird z. B. 11 Bytes Datei Zahl 1 schreiben:</span><span class="sxs-lookup"><span data-stu-id="d705e-1529">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="d705e-1530">Schreiben in eine Datei mithilfe der `FilePut` -Funktion erfordert `Write` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.</span><span class="sxs-lookup"><span data-stu-id="d705e-1530">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d705e-1531">Dieses Beispiel verwendet die `FilePut` Funktion, um Daten in eine Datei schreiben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1531">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="d705e-1532">Fünf Datensätze der Struktur `Person` in die Datei geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="d705e-1532">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="d705e-1533"><paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</span><span class="sxs-lookup"><span data-stu-id="d705e-1533"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="d705e-1534">Dateimodus ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="d705e-1534">File mode is invalid.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, int Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int32 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Integer, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="d705e-1535">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-1535">Required.</span></span> <span data-ttu-id="d705e-1536">Eine beliebige gültige Dateinummer.</span><span class="sxs-lookup"><span data-stu-id="d705e-1536">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="d705e-1537">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-1537">Required.</span></span> <span data-ttu-id="d705e-1538">Gültiger Variablenname, der auf den Datenträger geschriebene Daten enthält.</span><span class="sxs-lookup"><span data-stu-id="d705e-1538">Valid variable name that contains data written to disk.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="d705e-1539">Dies ist optional.</span><span class="sxs-lookup"><span data-stu-id="d705e-1539">Optional.</span></span> <span data-ttu-id="d705e-1540">Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), an der der Schreibvorgang beginnt.</span><span class="sxs-lookup"><span data-stu-id="d705e-1540">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span></span></param>
        <summary><span data-ttu-id="d705e-1541">Schreibt Daten aus einer Variablen in eine Datei auf einem Datenträger.</span><span class="sxs-lookup"><span data-stu-id="d705e-1541">Writes data from a variable to a disk file.</span></span> <span data-ttu-id="d705e-1542">Das <see langword="My" />-Feature bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FilePut" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-1542">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span></span> <span data-ttu-id="d705e-1543">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-1543">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d705e-1544">`FilePut` gilt nur in `Random` und `Binary` Modus.</span><span class="sxs-lookup"><span data-stu-id="d705e-1544">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="d705e-1545">Mit `FilePut` geschriebene Daten werden in der Regel mit `FileGet` aus einer Datei gelesen.</span><span class="sxs-lookup"><span data-stu-id="d705e-1545">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="d705e-1546">Der erste Datensatz oder Byte in einer Datei befindet sich an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 usw. ist.</span><span class="sxs-lookup"><span data-stu-id="d705e-1546">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="d705e-1547">Wenn Sie weglassen `RecordNumber`, den nächsten Datensatz bzw. Byte nach dem letzten `FileGet` oder `FilePut` Funktion oder verweist, zu dem letzten `Seek` Funktion geschrieben wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-1547">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="d705e-1548">Die `StringIsFixedLength` -Argument steuert, ob die Funktion Zeichenfolgen als Variable oder feste Länge interpretiert.</span><span class="sxs-lookup"><span data-stu-id="d705e-1548">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="d705e-1549">`FilePut` den Längendeskriptor wird nicht geschrieben werden, wenn das Argument ist `True`.</span><span class="sxs-lookup"><span data-stu-id="d705e-1549">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="d705e-1550">Bei Verwendung von `StringIsFixedLength`  =  `True` mit `FilePut`, was identisch mit `FileGet`, und Sie müssen sicherstellen, dass die Zeichenfolge mit der erwarteten Länge initialisiert wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-1550">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="d705e-1551">Zufällige Modus</span><span class="sxs-lookup"><span data-stu-id="d705e-1551">Random Mode</span></span>  
 <span data-ttu-id="d705e-1552">Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:</span><span class="sxs-lookup"><span data-stu-id="d705e-1552">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="d705e-1553">Wenn die Länge des zu schreibenden Daten kleiner als die Länge ist, angegeben der `RecordLength` -Klausel der `FileOpen` -Funktion, `FilePut` nachfolgende Datensätze auf Datensatzlänge schreibt.</span><span class="sxs-lookup"><span data-stu-id="d705e-1553">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="d705e-1554">Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt.</span><span class="sxs-lookup"><span data-stu-id="d705e-1554">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="d705e-1555">Da die Menge der Leerstellen Daten nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen empfiehlt sich, die Datensatzlänge der Länge der zu schreibenden Daten überein.</span><span class="sxs-lookup"><span data-stu-id="d705e-1555">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="d705e-1556">Ist die Länge des zu schreibenden Daten größer als die Länge, angegeben der `RecordLength` -Klausel der `FileOpen` -Funktion eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="d705e-1556">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="d705e-1557">Eine Zeichenfolge ist, die Zielvariable `FilePut` schreibt einen 2-Byte-Deskriptor, der die Länge der Zeichenfolge enthält, und schreibt dann die Daten, die in die Variable aufgenommen wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-1557">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="d705e-1558">Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge sein.</span><span class="sxs-lookup"><span data-stu-id="d705e-1558">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="d705e-1559">Wenn die Zielvariable ein Objekt ist, die einen numerischen Typ enthält `FilePut` zwei Bytes, identifizieren den `VarType` des Objekts und schreibt dann die Variable.</span><span class="sxs-lookup"><span data-stu-id="d705e-1559">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="d705e-1560">Enthält z. B. wenn ein Objekt zu schreiben, die eine ganze Zahl `FilePut` schreibt sechs Bytes: 2 Bytes, die Identifizierung des Objekts als `VarType(3)` (`Integer`) und vier Bytes, die Daten enthalten.</span><span class="sxs-lookup"><span data-stu-id="d705e-1560">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="d705e-1561">Die angegebene Datensatzlänge der `RecordLength` Parameter in der `FileOpen` Funktion muss mindestens zwei Bytes größer als die tatsächliche Anzahl von Bytes, die zum Speichern von Variablen erforderlich sein.</span><span class="sxs-lookup"><span data-stu-id="d705e-1561">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="d705e-1562">Ist die Zielvariable ein Objekt, das eine Zeichenfolge enthält `FilePut` schreibt eine 2-Byte-Deskriptor, identifiziert die `VarType(8)` des Objekts, ein 2-Byte-Deskriptor, der angibt, der Länge der Zeichenfolge und anschließend die Zeichenfolgendaten.</span><span class="sxs-lookup"><span data-stu-id="d705e-1562">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="d705e-1563">Die angegebene Datensatzlänge der `RecordLength` Parameter in der `FileOpen` Funktion muss mindestens vier Bytes größer als die tatsächliche Länge der Zeichenfolge sein.</span><span class="sxs-lookup"><span data-stu-id="d705e-1563">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="d705e-1564">Wenn Sie eine Zeichenfolge ohne Deskriptor ablegen möchten, sollten Sie übergeben `True` auf die `StringIsFixedLength` Parameter, und die Zeichenfolge, die Sie einlesen, sollte die richtige Länge.</span><span class="sxs-lookup"><span data-stu-id="d705e-1564">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="d705e-1565">Wenn die Zielvariable ein Array ist, müssen Sie eine Auswahl, ob einen Deskriptor für die Größe und die Dimensionen des Arrays zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1565">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="d705e-1566">Visual Basic 6.0 und früheren Versionen Dateideskriptor für dynamische Arrays und nicht für Arrays mit fester Größe zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1566">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="d705e-1567">Visual Basic 2005 standardmäßig kein Deskriptor geschrieben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1567">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="d705e-1568">Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`.</span><span class="sxs-lookup"><span data-stu-id="d705e-1568">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="d705e-1569">Wenn das Array zu schreiben, müssen Sie entsprechend der Weise wird das Array gelesen werden; Wenn mit dem Deskriptor gelesen werden, müssen Sie den Deskriptor schreiben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1569">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="d705e-1570">Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang.</span><span class="sxs-lookup"><span data-stu-id="d705e-1570">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="d705e-1571">Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl von Dimensionen: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="d705e-1571">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="d705e-1572">Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Arraydeskriptor zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1572">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="d705e-1573">Die folgende Arraydeklaration erfordert z. B. 218 Bytes, wenn das Array geschrieben wird auf den Datenträger.</span><span class="sxs-lookup"><span data-stu-id="d705e-1573">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="d705e-1574">Wenn die Zielvariable einen anderen Typ der Variable (keine Zeichenfolge variabler Länge oder ein Objekt), ist `FilePut` schreibt nur die Daten der Variablen.</span><span class="sxs-lookup"><span data-stu-id="d705e-1574">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="d705e-1575">Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge der zu schreibenden Daten.</span><span class="sxs-lookup"><span data-stu-id="d705e-1575">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="d705e-1576">`FilePut` Schreibt die Elemente von Strukturen, als ob jeder einzeln geschrieben wurden jedoch keine Auffüllung zwischen Elementen.</span><span class="sxs-lookup"><span data-stu-id="d705e-1576">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="d705e-1577">Die `VBFixedString` Attribut angewendet werden kann, zu Zeichenfolgenfeldern in den Strukturen an, dass die Größe der Zeichenfolge beim Schreiben auf den Datenträger.</span><span class="sxs-lookup"><span data-stu-id="d705e-1577">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="d705e-1578">String-Felder, die mehr als Bytes angegeben die `VBFixedString` Attribut werden abgeschnitten, beim Schreiben auf den Datenträger</span><span class="sxs-lookup"><span data-stu-id="d705e-1578">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="d705e-1579">Binärmodus</span><span class="sxs-lookup"><span data-stu-id="d705e-1579">Binary Mode</span></span>  
 <span data-ttu-id="d705e-1580">Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` -Modus-Regeln gelten, bis auf einige Ausnahmen.</span><span class="sxs-lookup"><span data-stu-id="d705e-1580">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="d705e-1581">Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:</span><span class="sxs-lookup"><span data-stu-id="d705e-1581">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="d705e-1582">Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen.</span><span class="sxs-lookup"><span data-stu-id="d705e-1582">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="d705e-1583">`FilePut` Schreibt alle Variablen zusammenhängend, d. h. ohne Leerraum zwischen Datensätzen Datenträger an.</span><span class="sxs-lookup"><span data-stu-id="d705e-1583">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="d705e-1584">Für ein beliebiges Array als ein Array in einer Struktur `FilePut` schreibt nur die Daten.</span><span class="sxs-lookup"><span data-stu-id="d705e-1584">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="d705e-1585">Es wird kein Deskriptor geschrieben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1585">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="d705e-1586">`FilePut` schreibt Zeichenfolgen variabler Länge, die keine Elemente von Strukturen ohne Längendeskriptor 2-Byte-sind.</span><span class="sxs-lookup"><span data-stu-id="d705e-1586">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="d705e-1587">Die Anzahl der geschriebenen Bytes entspricht die Anzahl der Zeichen in der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="d705e-1587">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="d705e-1588">Die folgenden Anweisungen wird z. B. 11 Bytes Datei Zahl 1 schreiben:</span><span class="sxs-lookup"><span data-stu-id="d705e-1588">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="d705e-1589">Schreiben in eine Datei mithilfe der `FilePut` -Funktion erfordert `Write` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.</span><span class="sxs-lookup"><span data-stu-id="d705e-1589">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d705e-1590">Dieses Beispiel verwendet die `FilePut` Funktion, um Daten in eine Datei schreiben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1590">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="d705e-1591">Fünf Datensätze der Struktur `Person` in die Datei geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="d705e-1591">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="d705e-1592"><paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</span><span class="sxs-lookup"><span data-stu-id="d705e-1592"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="d705e-1593">Dateimodus ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="d705e-1593">File mode is invalid.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, long Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int64 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Long, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="d705e-1594">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-1594">Required.</span></span> <span data-ttu-id="d705e-1595">Eine beliebige gültige Dateinummer.</span><span class="sxs-lookup"><span data-stu-id="d705e-1595">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="d705e-1596">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-1596">Required.</span></span> <span data-ttu-id="d705e-1597">Gültiger Variablenname, der auf den Datenträger geschriebene Daten enthält.</span><span class="sxs-lookup"><span data-stu-id="d705e-1597">Valid variable name that contains data written to disk.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="d705e-1598">Dies ist optional.</span><span class="sxs-lookup"><span data-stu-id="d705e-1598">Optional.</span></span> <span data-ttu-id="d705e-1599">Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), an der der Schreibvorgang beginnt.</span><span class="sxs-lookup"><span data-stu-id="d705e-1599">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span></span></param>
        <summary><span data-ttu-id="d705e-1600">Schreibt Daten aus einer Variablen in eine Datei auf einem Datenträger.</span><span class="sxs-lookup"><span data-stu-id="d705e-1600">Writes data from a variable to a disk file.</span></span> <span data-ttu-id="d705e-1601">Das <see langword="My" />-Feature bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FilePut" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-1601">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span></span> <span data-ttu-id="d705e-1602">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-1602">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d705e-1603">`FilePut` gilt nur in `Random` und `Binary` Modus.</span><span class="sxs-lookup"><span data-stu-id="d705e-1603">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="d705e-1604">Mit `FilePut` geschriebene Daten werden in der Regel mit `FileGet` aus einer Datei gelesen.</span><span class="sxs-lookup"><span data-stu-id="d705e-1604">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="d705e-1605">Der erste Datensatz oder Byte in einer Datei befindet sich an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 usw. ist.</span><span class="sxs-lookup"><span data-stu-id="d705e-1605">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="d705e-1606">Wenn Sie weglassen `RecordNumber`, den nächsten Datensatz bzw. Byte nach dem letzten `FileGet` oder `FilePut` Funktion oder verweist, zu dem letzten `Seek` Funktion geschrieben wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-1606">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="d705e-1607">Die `StringIsFixedLength` -Argument steuert, ob die Funktion Zeichenfolgen als Variable oder feste Länge interpretiert.</span><span class="sxs-lookup"><span data-stu-id="d705e-1607">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="d705e-1608">`FilePut` den Längendeskriptor wird nicht geschrieben werden, wenn das Argument ist `True`.</span><span class="sxs-lookup"><span data-stu-id="d705e-1608">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="d705e-1609">Bei Verwendung von `StringIsFixedLength`  =  `True` mit `FilePut`, was identisch mit `FileGet`, und Sie müssen sicherstellen, dass die Zeichenfolge mit der erwarteten Länge initialisiert wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-1609">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="d705e-1610">Zufällige Modus</span><span class="sxs-lookup"><span data-stu-id="d705e-1610">Random Mode</span></span>  
 <span data-ttu-id="d705e-1611">Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:</span><span class="sxs-lookup"><span data-stu-id="d705e-1611">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="d705e-1612">Wenn die Länge des zu schreibenden Daten kleiner als die Länge ist, angegeben der `RecordLength` -Klausel der `FileOpen` -Funktion, `FilePut` nachfolgende Datensätze auf Datensatzlänge schreibt.</span><span class="sxs-lookup"><span data-stu-id="d705e-1612">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="d705e-1613">Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt.</span><span class="sxs-lookup"><span data-stu-id="d705e-1613">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="d705e-1614">Da die Menge der Leerstellen Daten nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen empfiehlt sich, die Datensatzlänge der Länge der zu schreibenden Daten überein.</span><span class="sxs-lookup"><span data-stu-id="d705e-1614">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="d705e-1615">Ist die Länge des zu schreibenden Daten größer als die Länge, angegeben der `RecordLength` -Klausel der `FileOpen` -Funktion eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="d705e-1615">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="d705e-1616">Eine Zeichenfolge ist, die Zielvariable `FilePut` schreibt einen 2-Byte-Deskriptor, der die Länge der Zeichenfolge enthält, und schreibt dann die Daten, die in die Variable aufgenommen wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-1616">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="d705e-1617">Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge sein.</span><span class="sxs-lookup"><span data-stu-id="d705e-1617">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="d705e-1618">Wenn die Zielvariable ein Objekt ist, die einen numerischen Typ enthält `FilePut` zwei Bytes, identifizieren den `VarType` des Objekts und schreibt dann die Variable.</span><span class="sxs-lookup"><span data-stu-id="d705e-1618">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="d705e-1619">Enthält z. B. wenn ein Objekt zu schreiben, die eine ganze Zahl `FilePut` schreibt sechs Bytes: 2 Bytes, die Identifizierung des Objekts als `VarType(3)` (`Integer`) und vier Bytes, die Daten enthalten.</span><span class="sxs-lookup"><span data-stu-id="d705e-1619">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="d705e-1620">Die angegebene Datensatzlänge der `RecordLength` Parameter in der `FileOpen` Funktion muss mindestens zwei Bytes größer als die tatsächliche Anzahl von Bytes, die zum Speichern von Variablen erforderlich sein.</span><span class="sxs-lookup"><span data-stu-id="d705e-1620">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="d705e-1621">Ist die Zielvariable ein Objekt, das eine Zeichenfolge enthält `FilePut` schreibt eine 2-Byte-Deskriptor, identifiziert die `VarType(8)` des Objekts, ein 2-Byte-Deskriptor, der angibt, der Länge der Zeichenfolge und anschließend die Zeichenfolgendaten.</span><span class="sxs-lookup"><span data-stu-id="d705e-1621">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="d705e-1622">Die angegebene Datensatzlänge der `RecordLength` Parameter in der `FileOpen` Funktion muss mindestens vier Bytes größer als die tatsächliche Länge der Zeichenfolge sein.</span><span class="sxs-lookup"><span data-stu-id="d705e-1622">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="d705e-1623">Wenn Sie eine Zeichenfolge ohne Deskriptor ablegen möchten, sollten Sie übergeben `True` auf die `StringIsFixedLength` Parameter, und die Zeichenfolge, die Sie einlesen, sollte die richtige Länge.</span><span class="sxs-lookup"><span data-stu-id="d705e-1623">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="d705e-1624">Wenn die Zielvariable ein Array ist, müssen Sie eine Auswahl, ob einen Deskriptor für die Größe und die Dimensionen des Arrays zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1624">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="d705e-1625">Visual Basic 6.0 und früheren Versionen Dateideskriptor für dynamische Arrays und nicht für Arrays mit fester Größe zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1625">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="d705e-1626">Visual Basic 2005 standardmäßig kein Deskriptor geschrieben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1626">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="d705e-1627">Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`.</span><span class="sxs-lookup"><span data-stu-id="d705e-1627">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="d705e-1628">Wenn das Array zu schreiben, müssen Sie entsprechend der Weise wird das Array gelesen werden; Wenn mit dem Deskriptor gelesen werden, müssen Sie den Deskriptor schreiben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1628">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="d705e-1629">Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang.</span><span class="sxs-lookup"><span data-stu-id="d705e-1629">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="d705e-1630">Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl von Dimensionen: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="d705e-1630">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="d705e-1631">Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Arraydeskriptor zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1631">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="d705e-1632">Die folgende Arraydeklaration erfordert z. B. 218 Bytes, wenn das Array geschrieben wird auf den Datenträger.</span><span class="sxs-lookup"><span data-stu-id="d705e-1632">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="d705e-1633">Wenn die Zielvariable einen anderen Typ der Variable (keine Zeichenfolge variabler Länge oder ein Objekt), ist `FilePut` schreibt nur die Daten der Variablen.</span><span class="sxs-lookup"><span data-stu-id="d705e-1633">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="d705e-1634">Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge der zu schreibenden Daten.</span><span class="sxs-lookup"><span data-stu-id="d705e-1634">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="d705e-1635">`FilePut` Schreibt die Elemente von Strukturen, als ob jeder einzeln geschrieben wurden jedoch keine Auffüllung zwischen Elementen.</span><span class="sxs-lookup"><span data-stu-id="d705e-1635">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="d705e-1636">Die `VBFixedString` Attribut angewendet werden kann, zu Zeichenfolgenfeldern in den Strukturen an, dass die Größe der Zeichenfolge beim Schreiben auf den Datenträger.</span><span class="sxs-lookup"><span data-stu-id="d705e-1636">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="d705e-1637">String-Felder, die mehr als Bytes angegeben die `VBFixedString` Attribut werden abgeschnitten, beim Schreiben auf den Datenträger</span><span class="sxs-lookup"><span data-stu-id="d705e-1637">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="d705e-1638">Binärmodus</span><span class="sxs-lookup"><span data-stu-id="d705e-1638">Binary Mode</span></span>  
 <span data-ttu-id="d705e-1639">Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` -Modus-Regeln gelten, bis auf einige Ausnahmen.</span><span class="sxs-lookup"><span data-stu-id="d705e-1639">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="d705e-1640">Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:</span><span class="sxs-lookup"><span data-stu-id="d705e-1640">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="d705e-1641">Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen.</span><span class="sxs-lookup"><span data-stu-id="d705e-1641">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="d705e-1642">`FilePut` Schreibt alle Variablen zusammenhängend, d. h. ohne Leerraum zwischen Datensätzen Datenträger an.</span><span class="sxs-lookup"><span data-stu-id="d705e-1642">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="d705e-1643">Für ein beliebiges Array als ein Array in einer Struktur `FilePut` schreibt nur die Daten.</span><span class="sxs-lookup"><span data-stu-id="d705e-1643">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="d705e-1644">Es wird kein Deskriptor geschrieben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1644">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="d705e-1645">`FilePut` schreibt Zeichenfolgen variabler Länge, die keine Elemente von Strukturen ohne Längendeskriptor 2-Byte-sind.</span><span class="sxs-lookup"><span data-stu-id="d705e-1645">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="d705e-1646">Die Anzahl der geschriebenen Bytes entspricht die Anzahl der Zeichen in der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="d705e-1646">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="d705e-1647">Die folgenden Anweisungen wird z. B. 11 Bytes Datei Zahl 1 schreiben:</span><span class="sxs-lookup"><span data-stu-id="d705e-1647">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="d705e-1648">Schreiben in eine Datei mithilfe der `FilePut` -Funktion erfordert `Write` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.</span><span class="sxs-lookup"><span data-stu-id="d705e-1648">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d705e-1649">Dieses Beispiel verwendet die `FilePut` Funktion, um Daten in eine Datei schreiben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1649">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="d705e-1650">Fünf Datensätze der Struktur `Person` in die Datei geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="d705e-1650">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="d705e-1651"><paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</span><span class="sxs-lookup"><span data-stu-id="d705e-1651"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="d705e-1652">Dateimodus ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="d705e-1652">File mode is invalid.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, float Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, float32 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Single, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="d705e-1653">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-1653">Required.</span></span> <span data-ttu-id="d705e-1654">Eine beliebige gültige Dateinummer.</span><span class="sxs-lookup"><span data-stu-id="d705e-1654">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="d705e-1655">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-1655">Required.</span></span> <span data-ttu-id="d705e-1656">Gültiger Variablenname, der auf den Datenträger geschriebene Daten enthält.</span><span class="sxs-lookup"><span data-stu-id="d705e-1656">Valid variable name that contains data written to disk.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="d705e-1657">Dies ist optional.</span><span class="sxs-lookup"><span data-stu-id="d705e-1657">Optional.</span></span> <span data-ttu-id="d705e-1658">Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), an der der Schreibvorgang beginnt.</span><span class="sxs-lookup"><span data-stu-id="d705e-1658">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span></span></param>
        <summary><span data-ttu-id="d705e-1659">Schreibt Daten aus einer Variablen in eine Datei auf einem Datenträger.</span><span class="sxs-lookup"><span data-stu-id="d705e-1659">Writes data from a variable to a disk file.</span></span> <span data-ttu-id="d705e-1660">Das <see langword="My" />-Feature bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FilePut" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-1660">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span></span> <span data-ttu-id="d705e-1661">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-1661">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d705e-1662">`FilePut` gilt nur in `Random` und `Binary` Modus.</span><span class="sxs-lookup"><span data-stu-id="d705e-1662">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="d705e-1663">Mit `FilePut` geschriebene Daten werden in der Regel mit `FileGet` aus einer Datei gelesen.</span><span class="sxs-lookup"><span data-stu-id="d705e-1663">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="d705e-1664">Der erste Datensatz oder Byte in einer Datei befindet sich an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 usw. ist.</span><span class="sxs-lookup"><span data-stu-id="d705e-1664">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="d705e-1665">Wenn Sie weglassen `RecordNumber`, den nächsten Datensatz bzw. Byte nach dem letzten `FileGet` oder `FilePut` Funktion oder verweist, zu dem letzten `Seek` Funktion geschrieben wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-1665">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="d705e-1666">Die `StringIsFixedLength` -Argument steuert, ob die Funktion Zeichenfolgen als Variable oder feste Länge interpretiert.</span><span class="sxs-lookup"><span data-stu-id="d705e-1666">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="d705e-1667">`FilePut` den Längendeskriptor wird nicht geschrieben werden, wenn das Argument ist `True`.</span><span class="sxs-lookup"><span data-stu-id="d705e-1667">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="d705e-1668">Bei Verwendung von `StringIsFixedLength`  =  `True` mit `FilePut`, was identisch mit `FileGet`, und Sie müssen sicherstellen, dass die Zeichenfolge mit der erwarteten Länge initialisiert wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-1668">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="d705e-1669">Zufällige Modus</span><span class="sxs-lookup"><span data-stu-id="d705e-1669">Random Mode</span></span>  
 <span data-ttu-id="d705e-1670">Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:</span><span class="sxs-lookup"><span data-stu-id="d705e-1670">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="d705e-1671">Wenn die Länge des zu schreibenden Daten kleiner als die Länge ist, angegeben der `RecordLength` -Klausel der `FileOpen` -Funktion, `FilePut` nachfolgende Datensätze auf Datensatzlänge schreibt.</span><span class="sxs-lookup"><span data-stu-id="d705e-1671">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="d705e-1672">Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt.</span><span class="sxs-lookup"><span data-stu-id="d705e-1672">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="d705e-1673">Da die Menge der Leerstellen Daten nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen empfiehlt sich, die Datensatzlänge der Länge der zu schreibenden Daten überein.</span><span class="sxs-lookup"><span data-stu-id="d705e-1673">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="d705e-1674">Ist die Länge des zu schreibenden Daten größer als die Länge, angegeben der `RecordLength` -Klausel der `FileOpen` -Funktion eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="d705e-1674">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="d705e-1675">Eine Zeichenfolge ist, die Zielvariable `FilePut` schreibt einen 2-Byte-Deskriptor, der die Länge der Zeichenfolge enthält, und schreibt dann die Daten, die in die Variable aufgenommen wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-1675">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="d705e-1676">Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge sein.</span><span class="sxs-lookup"><span data-stu-id="d705e-1676">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="d705e-1677">Wenn die Zielvariable ein Objekt ist, die einen numerischen Typ enthält `FilePut` zwei Bytes, identifizieren den `VarType` des Objekts und schreibt dann die Variable.</span><span class="sxs-lookup"><span data-stu-id="d705e-1677">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="d705e-1678">Enthält z. B. wenn ein Objekt zu schreiben, die eine ganze Zahl `FilePut` schreibt sechs Bytes: 2 Bytes, die Identifizierung des Objekts als `VarType(3)` (`Integer`) und vier Bytes, die Daten enthalten.</span><span class="sxs-lookup"><span data-stu-id="d705e-1678">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="d705e-1679">Die angegebene Datensatzlänge der `RecordLength` Parameter in der `FileOpen` Funktion muss mindestens zwei Bytes größer als die tatsächliche Anzahl von Bytes, die zum Speichern von Variablen erforderlich sein.</span><span class="sxs-lookup"><span data-stu-id="d705e-1679">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="d705e-1680">Ist die Zielvariable ein Objekt, das eine Zeichenfolge enthält `FilePut` schreibt eine 2-Byte-Deskriptor, identifiziert die `VarType(8)` des Objekts, ein 2-Byte-Deskriptor, der angibt, der Länge der Zeichenfolge und anschließend die Zeichenfolgendaten.</span><span class="sxs-lookup"><span data-stu-id="d705e-1680">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="d705e-1681">Die angegebene Datensatzlänge der `RecordLength` Parameter in der `FileOpen` Funktion muss mindestens vier Bytes größer als die tatsächliche Länge der Zeichenfolge sein.</span><span class="sxs-lookup"><span data-stu-id="d705e-1681">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="d705e-1682">Wenn Sie eine Zeichenfolge ohne Deskriptor ablegen möchten, sollten Sie übergeben `True` auf die `StringIsFixedLength` Parameter, und die Zeichenfolge, die Sie einlesen, sollte die richtige Länge.</span><span class="sxs-lookup"><span data-stu-id="d705e-1682">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="d705e-1683">Wenn die Zielvariable ein Array ist, müssen Sie eine Auswahl, ob einen Deskriptor für die Größe und die Dimensionen des Arrays zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1683">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="d705e-1684">Visual Basic 6.0 und früheren Versionen Dateideskriptor für dynamische Arrays und nicht für Arrays mit fester Größe zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1684">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="d705e-1685">Visual Basic 2005 standardmäßig kein Deskriptor geschrieben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1685">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="d705e-1686">Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`.</span><span class="sxs-lookup"><span data-stu-id="d705e-1686">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="d705e-1687">Wenn das Array zu schreiben, müssen Sie entsprechend der Weise wird das Array gelesen werden; Wenn mit dem Deskriptor gelesen werden, müssen Sie den Deskriptor schreiben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1687">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="d705e-1688">Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang.</span><span class="sxs-lookup"><span data-stu-id="d705e-1688">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="d705e-1689">Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl von Dimensionen: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="d705e-1689">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="d705e-1690">Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Arraydeskriptor zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1690">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="d705e-1691">Die folgende Arraydeklaration erfordert z. B. 218 Bytes, wenn das Array geschrieben wird auf den Datenträger.</span><span class="sxs-lookup"><span data-stu-id="d705e-1691">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="d705e-1692">Wenn die Zielvariable einen anderen Typ der Variable (keine Zeichenfolge variabler Länge oder ein Objekt), ist `FilePut` schreibt nur die Daten der Variablen.</span><span class="sxs-lookup"><span data-stu-id="d705e-1692">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="d705e-1693">Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge der zu schreibenden Daten.</span><span class="sxs-lookup"><span data-stu-id="d705e-1693">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="d705e-1694">`FilePut` Schreibt die Elemente von Strukturen, als ob jeder einzeln geschrieben wurden jedoch keine Auffüllung zwischen Elementen.</span><span class="sxs-lookup"><span data-stu-id="d705e-1694">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="d705e-1695">Die `VBFixedString` Attribut angewendet werden kann, zu Zeichenfolgenfeldern in den Strukturen an, dass die Größe der Zeichenfolge beim Schreiben auf den Datenträger.</span><span class="sxs-lookup"><span data-stu-id="d705e-1695">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="d705e-1696">String-Felder, die mehr als Bytes angegeben die `VBFixedString` Attribut werden abgeschnitten, beim Schreiben auf den Datenträger</span><span class="sxs-lookup"><span data-stu-id="d705e-1696">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="d705e-1697">Binärmodus</span><span class="sxs-lookup"><span data-stu-id="d705e-1697">Binary Mode</span></span>  
 <span data-ttu-id="d705e-1698">Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` -Modus-Regeln gelten, bis auf einige Ausnahmen.</span><span class="sxs-lookup"><span data-stu-id="d705e-1698">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="d705e-1699">Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:</span><span class="sxs-lookup"><span data-stu-id="d705e-1699">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="d705e-1700">Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen.</span><span class="sxs-lookup"><span data-stu-id="d705e-1700">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="d705e-1701">`FilePut` Schreibt alle Variablen zusammenhängend, d. h. ohne Leerraum zwischen Datensätzen Datenträger an.</span><span class="sxs-lookup"><span data-stu-id="d705e-1701">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="d705e-1702">Für ein beliebiges Array als ein Array in einer Struktur `FilePut` schreibt nur die Daten.</span><span class="sxs-lookup"><span data-stu-id="d705e-1702">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="d705e-1703">Es wird kein Deskriptor geschrieben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1703">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="d705e-1704">`FilePut` schreibt Zeichenfolgen variabler Länge, die keine Elemente von Strukturen ohne Längendeskriptor 2-Byte-sind.</span><span class="sxs-lookup"><span data-stu-id="d705e-1704">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="d705e-1705">Die Anzahl der geschriebenen Bytes entspricht die Anzahl der Zeichen in der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="d705e-1705">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="d705e-1706">Die folgenden Anweisungen wird z. B. 11 Bytes Datei Zahl 1 schreiben:</span><span class="sxs-lookup"><span data-stu-id="d705e-1706">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="d705e-1707">Schreiben in eine Datei mithilfe der `FilePut` -Funktion erfordert `Write` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.</span><span class="sxs-lookup"><span data-stu-id="d705e-1707">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d705e-1708">Dieses Beispiel verwendet die `FilePut` Funktion, um Daten in eine Datei schreiben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1708">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="d705e-1709">Fünf Datensätze der Struktur `Person` in die Datei geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="d705e-1709">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="d705e-1710"><paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</span><span class="sxs-lookup"><span data-stu-id="d705e-1710"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="d705e-1711">Dateimodus ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="d705e-1711">File mode is invalid.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, ValueType Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, class System.ValueType Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As ValueType, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.ValueType" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="d705e-1712">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-1712">Required.</span></span> <span data-ttu-id="d705e-1713">Eine beliebige gültige Dateinummer.</span><span class="sxs-lookup"><span data-stu-id="d705e-1713">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="d705e-1714">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-1714">Required.</span></span> <span data-ttu-id="d705e-1715">Gültiger Variablenname, der auf den Datenträger geschriebene Daten enthält.</span><span class="sxs-lookup"><span data-stu-id="d705e-1715">Valid variable name that contains data written to disk.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="d705e-1716">Dies ist optional.</span><span class="sxs-lookup"><span data-stu-id="d705e-1716">Optional.</span></span> <span data-ttu-id="d705e-1717">Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), an der der Schreibvorgang beginnt.</span><span class="sxs-lookup"><span data-stu-id="d705e-1717">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span></span></param>
        <summary><span data-ttu-id="d705e-1718">Schreibt Daten aus einer Variablen in eine Datei auf einem Datenträger.</span><span class="sxs-lookup"><span data-stu-id="d705e-1718">Writes data from a variable to a disk file.</span></span> <span data-ttu-id="d705e-1719">Das <see langword="My" />-Feature bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FilePut" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-1719">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span></span> <span data-ttu-id="d705e-1720">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-1720">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d705e-1721">`FilePut` gilt nur in `Random` und `Binary` Modus.</span><span class="sxs-lookup"><span data-stu-id="d705e-1721">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="d705e-1722">Mit `FilePut` geschriebene Daten werden in der Regel mit `FileGet` aus einer Datei gelesen.</span><span class="sxs-lookup"><span data-stu-id="d705e-1722">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="d705e-1723">Der erste Datensatz oder Byte in einer Datei befindet sich an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 usw. ist.</span><span class="sxs-lookup"><span data-stu-id="d705e-1723">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="d705e-1724">Wenn Sie weglassen `RecordNumber`, den nächsten Datensatz bzw. Byte nach dem letzten `FileGet` oder `FilePut` Funktion oder verweist, zu dem letzten `Seek` Funktion geschrieben wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-1724">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="d705e-1725">Die `StringIsFixedLength` -Argument steuert, ob die Funktion Zeichenfolgen als Variable oder feste Länge interpretiert.</span><span class="sxs-lookup"><span data-stu-id="d705e-1725">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="d705e-1726">`FilePut` den Längendeskriptor wird nicht geschrieben werden, wenn das Argument ist `True`.</span><span class="sxs-lookup"><span data-stu-id="d705e-1726">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="d705e-1727">Bei Verwendung von `StringIsFixedLength`  =  `True` mit `FilePut`, was identisch mit `FileGet`, und Sie müssen sicherstellen, dass die Zeichenfolge mit der erwarteten Länge initialisiert wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-1727">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="d705e-1728">Zufällige Modus</span><span class="sxs-lookup"><span data-stu-id="d705e-1728">Random Mode</span></span>  
 <span data-ttu-id="d705e-1729">Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:</span><span class="sxs-lookup"><span data-stu-id="d705e-1729">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="d705e-1730">Wenn die Länge des zu schreibenden Daten kleiner als die Länge ist, angegeben der`RecordLength` -Klausel der `FileOpen` -Funktion, `FilePut` nachfolgende Datensätze auf Datensatzlänge schreibt.</span><span class="sxs-lookup"><span data-stu-id="d705e-1730">If the length of the data being written is less than the length specified in the`RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="d705e-1731">Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt.</span><span class="sxs-lookup"><span data-stu-id="d705e-1731">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="d705e-1732">Da die Menge der Leerstellen Daten nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen empfiehlt sich, die Datensatzlänge der Länge der zu schreibenden Daten überein.</span><span class="sxs-lookup"><span data-stu-id="d705e-1732">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="d705e-1733">Ist die Länge des zu schreibenden Daten größer als die Länge, angegeben der `RecordLength` -Klausel der `FileOpen` -Funktion eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="d705e-1733">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="d705e-1734">Eine Zeichenfolge ist, die Zielvariable `FilePut` schreibt einen 2-Byte-Deskriptor, der die Länge der Zeichenfolge enthält, und schreibt dann die Daten, die in die Variable aufgenommen wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-1734">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="d705e-1735">Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge sein.</span><span class="sxs-lookup"><span data-stu-id="d705e-1735">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="d705e-1736">Wenn die Zielvariable ein Objekt ist, die einen numerischen Typ enthält `FilePut` zwei Bytes, identifizieren den `VarType` des Objekts und schreibt dann die Variable.</span><span class="sxs-lookup"><span data-stu-id="d705e-1736">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="d705e-1737">Enthält z. B. wenn ein Objekt zu schreiben, die eine ganze Zahl `FilePut` schreibt sechs Bytes: 2 Bytes, die Identifizierung des Objekts als `VarType(3)` (`Integer`) und vier Bytes, die Daten enthalten.</span><span class="sxs-lookup"><span data-stu-id="d705e-1737">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="d705e-1738">Die angegebene Datensatzlänge der `RecordLength` Parameter in der `FileOpen` Funktion muss mindestens zwei Bytes größer als die tatsächliche Anzahl von Bytes, die zum Speichern von Variablen erforderlich sein.</span><span class="sxs-lookup"><span data-stu-id="d705e-1738">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="d705e-1739">Ist die Zielvariable ein Objekt, das eine Zeichenfolge enthält `FilePut` schreibt eine 2-Byte-Deskriptor, identifiziert die `VarType(8)` des Objekts, ein 2-Byte-Deskriptor, der angibt, der Länge der Zeichenfolge und anschließend die Zeichenfolgendaten.</span><span class="sxs-lookup"><span data-stu-id="d705e-1739">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="d705e-1740">Die angegebene Datensatzlänge der `RecordLength` Parameter in der `FileOpen` Funktion muss mindestens vier Bytes größer als die tatsächliche Länge der Zeichenfolge sein.</span><span class="sxs-lookup"><span data-stu-id="d705e-1740">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="d705e-1741">Wenn Sie eine Zeichenfolge ohne Deskriptor ablegen möchten, sollten Sie übergeben `True` auf die `StringIsFixedLength` Parameter, und die Zeichenfolge, die Sie einlesen, sollte die richtige Länge.</span><span class="sxs-lookup"><span data-stu-id="d705e-1741">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="d705e-1742">Wenn die Zielvariable ein Array ist, müssen Sie eine Auswahl, ob einen Deskriptor für die Größe und die Dimensionen des Arrays zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1742">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="d705e-1743">Visual Basic 6.0 und früheren Versionen Dateideskriptor für dynamische Arrays und nicht für Arrays mit fester Größe zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1743">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="d705e-1744">Visual Basic 2005 standardmäßig kein Deskriptor geschrieben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1744">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="d705e-1745">Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`.</span><span class="sxs-lookup"><span data-stu-id="d705e-1745">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="d705e-1746">Wenn das Array zu schreiben, müssen Sie entsprechend der Weise wird das Array gelesen werden; Wenn mit dem Deskriptor gelesen werden, müssen Sie den Deskriptor schreiben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1746">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="d705e-1747">Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang.</span><span class="sxs-lookup"><span data-stu-id="d705e-1747">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="d705e-1748">Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl von Dimensionen: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="d705e-1748">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="d705e-1749">Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Arraydeskriptor zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1749">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="d705e-1750">Die folgende Arraydeklaration erfordert z. B. 218 Bytes, wenn das Array geschrieben wird auf den Datenträger.</span><span class="sxs-lookup"><span data-stu-id="d705e-1750">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="d705e-1751">Wenn die Zielvariable einen anderen Typ der Variable (keine Zeichenfolge variabler Länge oder ein Objekt), ist `FilePut` schreibt nur die Daten der Variablen.</span><span class="sxs-lookup"><span data-stu-id="d705e-1751">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="d705e-1752">Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge der zu schreibenden Daten.</span><span class="sxs-lookup"><span data-stu-id="d705e-1752">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="d705e-1753">`FilePut` Schreibt die Elemente von Strukturen, als ob jeder einzeln geschrieben wurden jedoch keine Auffüllung zwischen Elementen.</span><span class="sxs-lookup"><span data-stu-id="d705e-1753">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="d705e-1754">Die `VBFixedString` Attribut angewendet werden kann, zu Zeichenfolgenfeldern in den Strukturen an, dass die Größe der Zeichenfolge beim Schreiben auf den Datenträger.</span><span class="sxs-lookup"><span data-stu-id="d705e-1754">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="d705e-1755">String-Felder, die mehr als Bytes angegeben die `VBFixedString` Attribut werden abgeschnitten, beim Schreiben auf den Datenträger</span><span class="sxs-lookup"><span data-stu-id="d705e-1755">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="d705e-1756">Binärmodus</span><span class="sxs-lookup"><span data-stu-id="d705e-1756">Binary Mode</span></span>  
 <span data-ttu-id="d705e-1757">Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` -Modus-Regeln gelten, bis auf einige Ausnahmen.</span><span class="sxs-lookup"><span data-stu-id="d705e-1757">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="d705e-1758">Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:</span><span class="sxs-lookup"><span data-stu-id="d705e-1758">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="d705e-1759">Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen.</span><span class="sxs-lookup"><span data-stu-id="d705e-1759">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="d705e-1760">`FilePut` Schreibt alle Variablen zusammenhängend, d. h. ohne Leerraum zwischen Datensätzen Datenträger an.</span><span class="sxs-lookup"><span data-stu-id="d705e-1760">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="d705e-1761">Für ein beliebiges Array als ein Array in einer Struktur `FilePut` schreibt nur die Daten.</span><span class="sxs-lookup"><span data-stu-id="d705e-1761">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="d705e-1762">Es wird kein Deskriptor geschrieben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1762">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="d705e-1763">`FilePut` schreibt Zeichenfolgen variabler Länge, die keine Elemente von Strukturen ohne Längendeskriptor 2-Byte-sind.</span><span class="sxs-lookup"><span data-stu-id="d705e-1763">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="d705e-1764">Die Anzahl der geschriebenen Bytes entspricht die Anzahl der Zeichen in der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="d705e-1764">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="d705e-1765">Die folgenden Anweisungen wird z. B. 11 Bytes Datei Zahl 1 schreiben:</span><span class="sxs-lookup"><span data-stu-id="d705e-1765">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="d705e-1766">Schreiben in eine Datei mithilfe der `FilePut` -Funktion erfordert `Write` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.</span><span class="sxs-lookup"><span data-stu-id="d705e-1766">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d705e-1767">Dieses Beispiel verwendet die `FilePut` Funktion, um Daten in eine Datei schreiben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1767">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="d705e-1768">Fünf Datensätze der Struktur `Person` in die Datei geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="d705e-1768">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="d705e-1769"><paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</span><span class="sxs-lookup"><span data-stu-id="d705e-1769"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="d705e-1770">Dateimodus ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="d705e-1770">File mode is invalid.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (object FileNumber, object Value, object RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(object FileNumber, object Value, object RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Object, Value As Object, Optional RecordNumber As Object = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("This member has been deprecated. Please use FilePutObject to write Object types, or coerce FileNumber and RecordNumber to Integer for writing non-Object types. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Object" />
        <Parameter Name="Value" Type="System.Object" />
        <Parameter Name="RecordNumber" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="d705e-1771">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-1771">Required.</span></span> <span data-ttu-id="d705e-1772">Eine beliebige gültige Dateinummer.</span><span class="sxs-lookup"><span data-stu-id="d705e-1772">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="d705e-1773">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-1773">Required.</span></span> <span data-ttu-id="d705e-1774">Gültiger Variablenname, der auf den Datenträger geschriebene Daten enthält.</span><span class="sxs-lookup"><span data-stu-id="d705e-1774">Valid variable name that contains data written to disk.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="d705e-1775">Dies ist optional.</span><span class="sxs-lookup"><span data-stu-id="d705e-1775">Optional.</span></span> <span data-ttu-id="d705e-1776">Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), an der der Schreibvorgang beginnt.</span><span class="sxs-lookup"><span data-stu-id="d705e-1776">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span></span></param>
        <summary><span data-ttu-id="d705e-1777">Schreibt Daten aus einer Variablen in eine Datei auf einem Datenträger.</span><span class="sxs-lookup"><span data-stu-id="d705e-1777">Writes data from a variable to a disk file.</span></span> <span data-ttu-id="d705e-1778">Das <see langword="My" />-Feature bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FilePut" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-1778">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span></span> <span data-ttu-id="d705e-1779">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-1779">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d705e-1780">`FilePut` gilt nur in `Random` und `Binary` Modus.</span><span class="sxs-lookup"><span data-stu-id="d705e-1780">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="d705e-1781">Mit `FilePut` geschriebene Daten werden in der Regel mit `FileGet` aus einer Datei gelesen.</span><span class="sxs-lookup"><span data-stu-id="d705e-1781">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="d705e-1782">Der erste Datensatz oder Byte in einer Datei befindet sich an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 usw. ist.</span><span class="sxs-lookup"><span data-stu-id="d705e-1782">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="d705e-1783">Wenn Sie weglassen `RecordNumber`, den nächsten Datensatz bzw. Byte nach dem letzten `FileGet` oder `FilePut` Funktion oder verweist, zu dem letzten `Seek` Funktion geschrieben wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-1783">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="d705e-1784">Die `StringIsFixedLength` -Argument steuert, ob die Funktion Zeichenfolgen als Variable oder feste Länge interpretiert.</span><span class="sxs-lookup"><span data-stu-id="d705e-1784">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="d705e-1785">`FilePut` den Längendeskriptor wird nicht geschrieben werden, wenn das Argument ist `True`.</span><span class="sxs-lookup"><span data-stu-id="d705e-1785">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="d705e-1786">Bei Verwendung von `StringIsFixedLength`  =  `True` mit `FilePut`, was identisch mit `FileGet`, und Sie müssen sicherstellen, dass die Zeichenfolge mit der erwarteten Länge initialisiert wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-1786">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="d705e-1787">Zufällige Modus</span><span class="sxs-lookup"><span data-stu-id="d705e-1787">Random Mode</span></span>  
 <span data-ttu-id="d705e-1788">Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:</span><span class="sxs-lookup"><span data-stu-id="d705e-1788">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="d705e-1789">Wenn die Länge des zu schreibenden Daten kleiner als die Länge ist, angegeben der `RecordLength` -Klausel der `FileOpen` -Funktion, `FilePut` nachfolgende Datensätze auf Datensatzlänge schreibt.</span><span class="sxs-lookup"><span data-stu-id="d705e-1789">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="d705e-1790">Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt.</span><span class="sxs-lookup"><span data-stu-id="d705e-1790">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="d705e-1791">Da die Menge der Leerstellen Daten nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen empfiehlt sich, die Datensatzlänge der Länge der zu schreibenden Daten überein.</span><span class="sxs-lookup"><span data-stu-id="d705e-1791">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="d705e-1792">Ist die Länge des zu schreibenden Daten größer als die Länge, angegeben der `RecordLength` -Klausel der `FileOpen` -Funktion eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="d705e-1792">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="d705e-1793">Eine Zeichenfolge ist, die Zielvariable `FilePut` schreibt einen 2-Byte-Deskriptor, der die Länge der Zeichenfolge enthält, und schreibt dann die Daten, die in die Variable aufgenommen wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-1793">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="d705e-1794">Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge sein.</span><span class="sxs-lookup"><span data-stu-id="d705e-1794">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="d705e-1795">Wenn die Zielvariable ein Objekt ist, die einen numerischen Typ enthält `FilePut` zwei Bytes, identifizieren den `VarType` des Objekts und schreibt dann die Variable.</span><span class="sxs-lookup"><span data-stu-id="d705e-1795">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="d705e-1796">Enthält z. B. wenn ein Objekt zu schreiben, die eine ganze Zahl `FilePut` schreibt sechs Bytes: 2 Bytes, die Identifizierung des Objekts als `VarType(3)` (`Integer`) und vier Bytes, die Daten enthalten.</span><span class="sxs-lookup"><span data-stu-id="d705e-1796">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="d705e-1797">Die angegebene Datensatzlänge der `RecordLength` Parameter in der `FileOpen` Funktion muss mindestens zwei Bytes größer als die tatsächliche Anzahl von Bytes, die zum Speichern von Variablen erforderlich sein.</span><span class="sxs-lookup"><span data-stu-id="d705e-1797">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="d705e-1798">Ist die Zielvariable ein Objekt, das eine Zeichenfolge enthält `FilePut` schreibt eine 2-Byte-Deskriptor, identifiziert die `VarType(8)` des Objekts, ein 2-Byte-Deskriptor, der angibt, der Länge der Zeichenfolge und anschließend die Zeichenfolgendaten.</span><span class="sxs-lookup"><span data-stu-id="d705e-1798">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="d705e-1799">Die angegebene Datensatzlänge der `RecordLength` Parameter in der `FileOpen` Funktion muss mindestens vier Bytes größer als die tatsächliche Länge der Zeichenfolge sein.</span><span class="sxs-lookup"><span data-stu-id="d705e-1799">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="d705e-1800">Wenn Sie eine Zeichenfolge ohne Deskriptor ablegen möchten, sollten Sie übergeben `True` auf die `StringIsFixedLength` Parameter, und die Zeichenfolge, die Sie einlesen, sollte die richtige Länge.</span><span class="sxs-lookup"><span data-stu-id="d705e-1800">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="d705e-1801">Wenn die Zielvariable ein Array ist, müssen Sie eine Auswahl, ob einen Deskriptor für die Größe und die Dimensionen des Arrays zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1801">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="d705e-1802">Visual Basic 6.0 und früheren Versionen Dateideskriptor für dynamische Arrays und nicht für Arrays mit fester Größe zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1802">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="d705e-1803">Visual Basic 2005 standardmäßig kein Deskriptor geschrieben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1803">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="d705e-1804">Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`.</span><span class="sxs-lookup"><span data-stu-id="d705e-1804">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="d705e-1805">Wenn das Array zu schreiben, müssen Sie entsprechend der Weise wird das Array gelesen werden; Wenn mit dem Deskriptor gelesen werden, müssen Sie den Deskriptor schreiben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1805">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="d705e-1806">Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang.</span><span class="sxs-lookup"><span data-stu-id="d705e-1806">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="d705e-1807">Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl von Dimensionen: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="d705e-1807">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="d705e-1808">Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Arraydeskriptor zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1808">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="d705e-1809">Die folgende Arraydeklaration erfordert z. B. 218 Bytes, wenn das Array geschrieben wird auf den Datenträger.</span><span class="sxs-lookup"><span data-stu-id="d705e-1809">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="d705e-1810">Wenn die Zielvariable einen anderen Typ der Variable (keine Zeichenfolge variabler Länge oder ein Objekt), ist `FilePut` schreibt nur die Daten der Variablen.</span><span class="sxs-lookup"><span data-stu-id="d705e-1810">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="d705e-1811">Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge der zu schreibenden Daten.</span><span class="sxs-lookup"><span data-stu-id="d705e-1811">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="d705e-1812">`FilePut` Schreibt die Elemente von Strukturen, als ob jeder einzeln geschrieben wurden jedoch keine Auffüllung zwischen Elementen.</span><span class="sxs-lookup"><span data-stu-id="d705e-1812">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="d705e-1813">Die `VBFixedString` Attribut angewendet werden kann, zu Zeichenfolgenfeldern in den Strukturen an, dass die Größe der Zeichenfolge beim Schreiben auf den Datenträger.</span><span class="sxs-lookup"><span data-stu-id="d705e-1813">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="d705e-1814">String-Felder, die mehr als Bytes angegeben die `VBFixedString` Attribut werden abgeschnitten, beim Schreiben auf den Datenträger</span><span class="sxs-lookup"><span data-stu-id="d705e-1814">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="d705e-1815">Binärmodus</span><span class="sxs-lookup"><span data-stu-id="d705e-1815">Binary Mode</span></span>  
 <span data-ttu-id="d705e-1816">Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` -Modus-Regeln gelten, bis auf einige Ausnahmen.</span><span class="sxs-lookup"><span data-stu-id="d705e-1816">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="d705e-1817">Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:</span><span class="sxs-lookup"><span data-stu-id="d705e-1817">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="d705e-1818">Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen.</span><span class="sxs-lookup"><span data-stu-id="d705e-1818">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="d705e-1819">`FilePut` Schreibt alle Variablen zusammenhängend, d. h. ohne Leerraum zwischen Datensätzen Datenträger an.</span><span class="sxs-lookup"><span data-stu-id="d705e-1819">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="d705e-1820">Für ein beliebiges Array als ein Array in einer Struktur `FilePut` schreibt nur die Daten.</span><span class="sxs-lookup"><span data-stu-id="d705e-1820">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="d705e-1821">Es wird kein Deskriptor geschrieben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1821">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="d705e-1822">`FilePut` schreibt Zeichenfolgen variabler Länge, die keine Elemente von Strukturen ohne Längendeskriptor 2-Byte-sind.</span><span class="sxs-lookup"><span data-stu-id="d705e-1822">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="d705e-1823">Die Anzahl der geschriebenen Bytes entspricht die Anzahl der Zeichen in der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="d705e-1823">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="d705e-1824">Die folgenden Anweisungen wird z. B. 11 Bytes Datei Zahl 1 schreiben:</span><span class="sxs-lookup"><span data-stu-id="d705e-1824">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="d705e-1825">Schreiben in eine Datei mithilfe der `FilePut` -Funktion erfordert `Write` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.</span><span class="sxs-lookup"><span data-stu-id="d705e-1825">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d705e-1826">Dieses Beispiel verwendet die `FilePut` Funktion, um Daten in eine Datei schreiben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1826">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="d705e-1827">Fünf Datensätze der Struktur `Person` in die Datei geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="d705e-1827">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="d705e-1828"><paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</span><span class="sxs-lookup"><span data-stu-id="d705e-1828"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="d705e-1829">Dateimodus ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="d705e-1829">File mode is invalid.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, string Value, long RecordNumber = -1, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, string Value, int64 RecordNumber, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As String, Optional RecordNumber As Long = -1, Optional StringIsFixedLength As Boolean = false)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="d705e-1830">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-1830">Required.</span></span> <span data-ttu-id="d705e-1831">Eine beliebige gültige Dateinummer.</span><span class="sxs-lookup"><span data-stu-id="d705e-1831">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="d705e-1832">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-1832">Required.</span></span> <span data-ttu-id="d705e-1833">Gültiger Variablenname, der auf den Datenträger geschriebene Daten enthält.</span><span class="sxs-lookup"><span data-stu-id="d705e-1833">Valid variable name that contains data written to disk.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="d705e-1834">Dies ist optional.</span><span class="sxs-lookup"><span data-stu-id="d705e-1834">Optional.</span></span> <span data-ttu-id="d705e-1835">Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), an der der Schreibvorgang beginnt.</span><span class="sxs-lookup"><span data-stu-id="d705e-1835">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span></span></param>
        <param name="StringIsFixedLength"><span data-ttu-id="d705e-1836">Dies ist optional.</span><span class="sxs-lookup"><span data-stu-id="d705e-1836">Optional.</span></span> <span data-ttu-id="d705e-1837">Betrifft nur das Schreiben einer Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="d705e-1837">Applies only when writing a string.</span></span> <span data-ttu-id="d705e-1838">Gibt an, ob ein 2-Byte-Zeichenfolgenlängendeskriptor in die Datei für die Zeichenfolge geschrieben werden soll.</span><span class="sxs-lookup"><span data-stu-id="d705e-1838">Specifies whether to write a two-byte string length descriptor for the string to the file.</span></span> <span data-ttu-id="d705e-1839">Der Standardwert ist <see langword="False" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-1839">The default is <see langword="False" />.</span></span></param>
        <summary><span data-ttu-id="d705e-1840">Schreibt Daten aus einer Variablen in eine Datei auf einem Datenträger.</span><span class="sxs-lookup"><span data-stu-id="d705e-1840">Writes data from a variable to a disk file.</span></span> <span data-ttu-id="d705e-1841">Das <see langword="My" />-Feature bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FilePut" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-1841">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span></span> <span data-ttu-id="d705e-1842">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-1842">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />..</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d705e-1843">`FilePut` gilt nur in `Random` und `Binary` Modus.</span><span class="sxs-lookup"><span data-stu-id="d705e-1843">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="d705e-1844">Mit `FilePut` geschriebene Daten werden in der Regel mit `FileGet` aus einer Datei gelesen.</span><span class="sxs-lookup"><span data-stu-id="d705e-1844">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="d705e-1845">Der erste Datensatz oder Byte in einer Datei befindet sich an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 usw. ist.</span><span class="sxs-lookup"><span data-stu-id="d705e-1845">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="d705e-1846">Wenn Sie weglassen `RecordNumber`, den nächsten Datensatz bzw. Byte nach dem letzten `FileGet` oder `FilePut` Funktion oder verweist, zu dem letzten `Seek` Funktion geschrieben wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-1846">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="d705e-1847">Die `StringIsFixedLength` -Argument steuert, ob die Funktion Zeichenfolgen als Variable oder feste Länge interpretiert.</span><span class="sxs-lookup"><span data-stu-id="d705e-1847">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="d705e-1848">`FilePut` den Längendeskriptor wird nicht geschrieben werden, wenn das Argument ist `True`.</span><span class="sxs-lookup"><span data-stu-id="d705e-1848">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="d705e-1849">Bei Verwendung von `StringIsFixedLength`  =  `True` mit `FilePut`, was identisch mit `FileGet`, und Sie müssen sicherstellen, dass die Zeichenfolge mit der erwarteten Länge initialisiert wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-1849">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="d705e-1850">Zufällige Modus</span><span class="sxs-lookup"><span data-stu-id="d705e-1850">Random Mode</span></span>  
 <span data-ttu-id="d705e-1851">Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:</span><span class="sxs-lookup"><span data-stu-id="d705e-1851">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="d705e-1852">Wenn die Länge des zu schreibenden Daten kleiner als die Länge ist, angegeben der `RecordLength` -Klausel der `FileOpen` -Funktion, `FilePut` nachfolgende Datensätze auf Datensatzlänge schreibt.</span><span class="sxs-lookup"><span data-stu-id="d705e-1852">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="d705e-1853">Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt.</span><span class="sxs-lookup"><span data-stu-id="d705e-1853">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="d705e-1854">Da die Menge der Leerstellen Daten nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen empfiehlt sich, die Datensatzlänge der Länge der zu schreibenden Daten überein.</span><span class="sxs-lookup"><span data-stu-id="d705e-1854">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="d705e-1855">Ist die Länge des zu schreibenden Daten größer als die Länge, angegeben der `RecordLength` -Klausel der `FileOpen` -Funktion eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="d705e-1855">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="d705e-1856">Eine Zeichenfolge ist, die Zielvariable `FilePut` schreibt einen 2-Byte-Deskriptor, der die Länge der Zeichenfolge enthält, und schreibt dann die Daten, die in die Variable aufgenommen wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-1856">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="d705e-1857">Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge sein.</span><span class="sxs-lookup"><span data-stu-id="d705e-1857">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="d705e-1858">Wenn die Zielvariable ein Objekt ist, die einen numerischen Typ enthält `FilePut` zwei Bytes, identifizieren den `VarType` des Objekts und schreibt dann die Variable.</span><span class="sxs-lookup"><span data-stu-id="d705e-1858">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="d705e-1859">Enthält z. B. wenn ein Objekt zu schreiben, die eine ganze Zahl `FilePut` schreibt sechs Bytes: 2 Bytes, die Identifizierung des Objekts als `VarType(3)` (`Integer`) und vier Bytes, die Daten enthalten.</span><span class="sxs-lookup"><span data-stu-id="d705e-1859">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="d705e-1860">Die angegebene Datensatzlänge der `RecordLength` Parameter in der `FileOpen` Funktion muss mindestens zwei Bytes größer als die tatsächliche Anzahl von Bytes, die zum Speichern von Variablen erforderlich sein.</span><span class="sxs-lookup"><span data-stu-id="d705e-1860">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="d705e-1861">Ist die Zielvariable ein Objekt, das eine Zeichenfolge enthält `FilePut` schreibt eine 2-Byte-Deskriptor, identifiziert die `VarType(8)` des Objekts, ein 2-Byte-Deskriptor, der angibt, der Länge der Zeichenfolge und anschließend die Zeichenfolgendaten.</span><span class="sxs-lookup"><span data-stu-id="d705e-1861">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="d705e-1862">Die angegebene Datensatzlänge der `RecordLength` Parameter in der `FileOpen` Funktion muss mindestens vier Bytes größer als die tatsächliche Länge der Zeichenfolge sein.</span><span class="sxs-lookup"><span data-stu-id="d705e-1862">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="d705e-1863">Wenn Sie eine Zeichenfolge ohne Deskriptor ablegen möchten, sollten Sie übergeben `True` auf die `StringIsFixedLength` Parameter, und die Zeichenfolge, die Sie einlesen, sollte die richtige Länge.</span><span class="sxs-lookup"><span data-stu-id="d705e-1863">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="d705e-1864">Wenn die Zielvariable ein Array ist, müssen Sie eine Auswahl, ob einen Deskriptor für die Größe und die Dimensionen des Arrays zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1864">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="d705e-1865">Visual Basic 6.0 und früheren Versionen Dateideskriptor für dynamische Arrays und nicht für Arrays mit fester Größe zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1865">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="d705e-1866">Visual Basic 2005 standardmäßig kein Deskriptor geschrieben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1866">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="d705e-1867">Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`.</span><span class="sxs-lookup"><span data-stu-id="d705e-1867">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="d705e-1868">Wenn das Array zu schreiben, müssen Sie entsprechend der Weise wird das Array gelesen werden; Wenn mit dem Deskriptor gelesen werden, müssen Sie den Deskriptor schreiben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1868">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="d705e-1869">Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang.</span><span class="sxs-lookup"><span data-stu-id="d705e-1869">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="d705e-1870">Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl von Dimensionen: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="d705e-1870">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="d705e-1871">Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Arraydeskriptor zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1871">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="d705e-1872">Die folgende Arraydeklaration erfordert z. B. 218 Bytes, wenn das Array geschrieben wird auf den Datenträger.</span><span class="sxs-lookup"><span data-stu-id="d705e-1872">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="d705e-1873">Wenn die Zielvariable einen anderen Typ der Variable (keine Zeichenfolge variabler Länge oder ein Objekt), ist `FilePut` schreibt nur die Daten der Variablen.</span><span class="sxs-lookup"><span data-stu-id="d705e-1873">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="d705e-1874">Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge der zu schreibenden Daten.</span><span class="sxs-lookup"><span data-stu-id="d705e-1874">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="d705e-1875">`FilePut` Schreibt die Elemente von Strukturen, als ob jeder einzeln geschrieben wurden jedoch keine Auffüllung zwischen Elementen.</span><span class="sxs-lookup"><span data-stu-id="d705e-1875">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="d705e-1876">Die `VBFixedString` Attribut angewendet werden kann, zu Zeichenfolgenfeldern in den Strukturen an, dass die Größe der Zeichenfolge beim Schreiben auf den Datenträger.</span><span class="sxs-lookup"><span data-stu-id="d705e-1876">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="d705e-1877">String-Felder, die mehr als Bytes angegeben die `VBFixedString` Attribut werden abgeschnitten, beim Schreiben auf den Datenträger</span><span class="sxs-lookup"><span data-stu-id="d705e-1877">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="d705e-1878">Binärmodus</span><span class="sxs-lookup"><span data-stu-id="d705e-1878">Binary Mode</span></span>  
 <span data-ttu-id="d705e-1879">Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` -Modus-Regeln gelten, bis auf einige Ausnahmen.</span><span class="sxs-lookup"><span data-stu-id="d705e-1879">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="d705e-1880">Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:</span><span class="sxs-lookup"><span data-stu-id="d705e-1880">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="d705e-1881">Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen.</span><span class="sxs-lookup"><span data-stu-id="d705e-1881">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="d705e-1882">`FilePut` Schreibt alle Variablen zusammenhängend, d. h. ohne Leerraum zwischen Datensätzen Datenträger an.</span><span class="sxs-lookup"><span data-stu-id="d705e-1882">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="d705e-1883">Für ein beliebiges Array als ein Array in einer Struktur `FilePut` schreibt nur die Daten.</span><span class="sxs-lookup"><span data-stu-id="d705e-1883">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="d705e-1884">Es wird kein Deskriptor geschrieben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1884">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="d705e-1885">`FilePut` schreibt Zeichenfolgen variabler Länge, die keine Elemente von Strukturen ohne Längendeskriptor 2-Byte-sind.</span><span class="sxs-lookup"><span data-stu-id="d705e-1885">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="d705e-1886">Die Anzahl der geschriebenen Bytes entspricht die Anzahl der Zeichen in der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="d705e-1886">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="d705e-1887">Die folgenden Anweisungen wird z. B. 11 Bytes Datei Zahl 1 schreiben:</span><span class="sxs-lookup"><span data-stu-id="d705e-1887">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="d705e-1888">Schreiben in eine Datei mithilfe der `FilePut` -Funktion erfordert `Write` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.</span><span class="sxs-lookup"><span data-stu-id="d705e-1888">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d705e-1889">Dieses Beispiel verwendet die `FilePut` Funktion, um Daten in eine Datei schreiben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1889">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="d705e-1890">Fünf Datensätze der Struktur `Person` in die Datei geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="d705e-1890">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="d705e-1891"><paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</span><span class="sxs-lookup"><span data-stu-id="d705e-1891"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="d705e-1892">Dateimodus ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="d705e-1892">File mode is invalid.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, class System.Array Value, int64 RecordNumber, bool ArrayIsDynamic, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Array, Optional RecordNumber As Long = -1, Optional ArrayIsDynamic As Boolean = false, Optional StringIsFixedLength As Boolean = false)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Array" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="ArrayIsDynamic" Type="System.Boolean" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="d705e-1893">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-1893">Required.</span></span> <span data-ttu-id="d705e-1894">Eine beliebige gültige Dateinummer.</span><span class="sxs-lookup"><span data-stu-id="d705e-1894">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="d705e-1895">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-1895">Required.</span></span> <span data-ttu-id="d705e-1896">Gültiger Variablenname, der auf den Datenträger geschriebene Daten enthält.</span><span class="sxs-lookup"><span data-stu-id="d705e-1896">Valid variable name that contains data written to disk.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="d705e-1897">Dies ist optional.</span><span class="sxs-lookup"><span data-stu-id="d705e-1897">Optional.</span></span> <span data-ttu-id="d705e-1898">Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), an der der Schreibvorgang beginnt.</span><span class="sxs-lookup"><span data-stu-id="d705e-1898">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span></span></param>
        <param name="ArrayIsDynamic"><span data-ttu-id="d705e-1899">Dies ist optional.</span><span class="sxs-lookup"><span data-stu-id="d705e-1899">Optional.</span></span> <span data-ttu-id="d705e-1900">Betrifft nur das Schreiben eines Arrays.</span><span class="sxs-lookup"><span data-stu-id="d705e-1900">Applies only when writing an array.</span></span> <span data-ttu-id="d705e-1901">Gibt an, ob das Array als dynamisches Array behandelt werden soll und ein Arraydeskriptor für die Zeichenfolge erforderlich ist, der die Länge beschreibt.</span><span class="sxs-lookup"><span data-stu-id="d705e-1901">Specifies whether the array is to be treated as dynamic, and whether to write an array descriptor for the string that describes the length.</span></span></param>
        <param name="StringIsFixedLength"><span data-ttu-id="d705e-1902">Dies ist optional.</span><span class="sxs-lookup"><span data-stu-id="d705e-1902">Optional.</span></span> <span data-ttu-id="d705e-1903">Betrifft nur das Schreiben einer Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="d705e-1903">Applies only when writing a string.</span></span> <span data-ttu-id="d705e-1904">Gibt an, ob ein 2-Byte-Zeichenfolgenlängendeskriptor in die Datei für die Zeichenfolge geschrieben werden soll.</span><span class="sxs-lookup"><span data-stu-id="d705e-1904">Specifies whether to write a two-byte string length descriptor for the string to the file.</span></span> <span data-ttu-id="d705e-1905">Der Standardwert ist <see langword="False" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-1905">The default is <see langword="False" />.</span></span></param>
        <summary><span data-ttu-id="d705e-1906">Schreibt Daten aus einer Variablen in eine Datei auf einem Datenträger.</span><span class="sxs-lookup"><span data-stu-id="d705e-1906">Writes data from a variable to a disk file.</span></span> <span data-ttu-id="d705e-1907">Das <see langword="My" />-Feature bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FilePut" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-1907">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span></span> <span data-ttu-id="d705e-1908">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-1908">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d705e-1909">`FilePut` gilt nur in `Random` und `Binary` Modus.</span><span class="sxs-lookup"><span data-stu-id="d705e-1909">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="d705e-1910">Mit `FilePut` geschriebene Daten werden in der Regel mit `FileGet` aus einer Datei gelesen.</span><span class="sxs-lookup"><span data-stu-id="d705e-1910">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="d705e-1911">Der erste Datensatz oder Byte in einer Datei befindet sich an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 usw. ist.</span><span class="sxs-lookup"><span data-stu-id="d705e-1911">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="d705e-1912">Wenn Sie weglassen `RecordNumber`, den nächsten Datensatz bzw. Byte nach dem letzten `FileGet` oder `FilePut` Funktion oder verweist, zu dem letzten `Seek` Funktion geschrieben wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-1912">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="d705e-1913">Die `StringIsFixedLength` -Argument steuert, ob die Funktion Zeichenfolgen als Variable oder feste Länge interpretiert.</span><span class="sxs-lookup"><span data-stu-id="d705e-1913">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="d705e-1914">`FilePut` den Längendeskriptor wird nicht geschrieben werden, wenn das Argument ist `True`.</span><span class="sxs-lookup"><span data-stu-id="d705e-1914">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="d705e-1915">Bei Verwendung von `StringIsFixedLength`  =  `True` mit `FilePut`, was identisch mit `FileGet`, und Sie müssen sicherstellen, dass die Zeichenfolge mit der erwarteten Länge initialisiert wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-1915">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="d705e-1916">Zufällige Modus</span><span class="sxs-lookup"><span data-stu-id="d705e-1916">Random Mode</span></span>  
 <span data-ttu-id="d705e-1917">Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:</span><span class="sxs-lookup"><span data-stu-id="d705e-1917">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="d705e-1918">Wenn die Länge des zu schreibenden Daten kleiner als die Länge ist, angegeben der `RecordLength` -Klausel der `FileOpen` -Funktion, `FilePut` nachfolgende Datensätze auf Datensatzlänge schreibt.</span><span class="sxs-lookup"><span data-stu-id="d705e-1918">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="d705e-1919">Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt.</span><span class="sxs-lookup"><span data-stu-id="d705e-1919">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="d705e-1920">Da die Menge der Leerstellen Daten nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen empfiehlt sich, die Datensatzlänge der Länge der zu schreibenden Daten überein.</span><span class="sxs-lookup"><span data-stu-id="d705e-1920">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="d705e-1921">Ist die Länge des zu schreibenden Daten größer als die Länge, angegeben der `RecordLength` -Klausel der `FileOpen` -Funktion eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="d705e-1921">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="d705e-1922">Eine Zeichenfolge ist, die Zielvariable `FilePut` schreibt einen 2-Byte-Deskriptor, der die Länge der Zeichenfolge enthält, und schreibt dann die Daten, die in die Variable aufgenommen wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-1922">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="d705e-1923">Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge sein.</span><span class="sxs-lookup"><span data-stu-id="d705e-1923">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="d705e-1924">Wenn die Zielvariable ein Objekt ist, die einen numerischen Typ enthält `FilePut` zwei Bytes, identifizieren den `VarType` des Objekts und schreibt dann die Variable.</span><span class="sxs-lookup"><span data-stu-id="d705e-1924">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="d705e-1925">Enthält z. B. wenn ein Objekt zu schreiben, die eine ganze Zahl `FilePut` schreibt sechs Bytes: 2 Bytes, die Identifizierung des Objekts als `VarType(3)` (`Integer`) und vier Bytes, die Daten enthalten.</span><span class="sxs-lookup"><span data-stu-id="d705e-1925">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="d705e-1926">Die angegebene Datensatzlänge der `RecordLength` Parameter in der `FileOpen` Funktion muss mindestens zwei Bytes größer als die tatsächliche Anzahl von Bytes, die zum Speichern von Variablen erforderlich sein.</span><span class="sxs-lookup"><span data-stu-id="d705e-1926">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="d705e-1927">Ist die Zielvariable ein Objekt, das eine Zeichenfolge enthält `FilePut` schreibt eine 2-Byte-Deskriptor, identifiziert die `VarType(8)` des Objekts, ein 2-Byte-Deskriptor, der angibt, der Länge der Zeichenfolge und anschließend die Zeichenfolgendaten.</span><span class="sxs-lookup"><span data-stu-id="d705e-1927">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="d705e-1928">Die angegebene Datensatzlänge der `RecordLength` Parameter in der `FileOpen` Funktion muss mindestens vier Bytes größer als die tatsächliche Länge der Zeichenfolge sein.</span><span class="sxs-lookup"><span data-stu-id="d705e-1928">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="d705e-1929">Wenn Sie eine Zeichenfolge ohne Deskriptor ablegen möchten, sollten Sie übergeben `True` auf die `StringIsFixedLength` Parameter, und die Zeichenfolge, die Sie einlesen, sollte die richtige Länge.</span><span class="sxs-lookup"><span data-stu-id="d705e-1929">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="d705e-1930">Wenn die Zielvariable ein Array ist, müssen Sie eine Auswahl, ob einen Deskriptor für die Größe und die Dimensionen des Arrays zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1930">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="d705e-1931">Visual Basic 6.0 und früheren Versionen Dateideskriptor für dynamische Arrays und nicht für Arrays mit fester Größe zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1931">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="d705e-1932">Visual Basic 2005 standardmäßig kein Deskriptor geschrieben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1932">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="d705e-1933">Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`.</span><span class="sxs-lookup"><span data-stu-id="d705e-1933">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="d705e-1934">Wenn das Array zu schreiben, müssen Sie entsprechend der Weise wird das Array gelesen werden; Wenn mit dem Deskriptor gelesen werden, müssen Sie den Deskriptor schreiben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1934">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="d705e-1935">Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang.</span><span class="sxs-lookup"><span data-stu-id="d705e-1935">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="d705e-1936">Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl von Dimensionen: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="d705e-1936">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="d705e-1937">Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Arraydeskriptor zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1937">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="d705e-1938">Die folgende Arraydeklaration erfordert z. B. 218 Bytes, wenn das Array geschrieben wird auf den Datenträger.</span><span class="sxs-lookup"><span data-stu-id="d705e-1938">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="d705e-1939">Wenn die Zielvariable einen anderen Typ der Variable (keine Zeichenfolge variabler Länge oder ein Objekt), ist `FilePut` schreibt nur die Daten der Variablen.</span><span class="sxs-lookup"><span data-stu-id="d705e-1939">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="d705e-1940">Die Länge des Datensatzes gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge der zu schreibenden Daten.</span><span class="sxs-lookup"><span data-stu-id="d705e-1940">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="d705e-1941">`FilePut` Schreibt die Elemente von Strukturen, als ob jeder einzeln geschrieben wurden jedoch keine Auffüllung zwischen Elementen.</span><span class="sxs-lookup"><span data-stu-id="d705e-1941">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="d705e-1942">Die `VBFixedString` Attribut angewendet werden kann, zu Zeichenfolgenfeldern in den Strukturen an, dass die Größe der Zeichenfolge beim Schreiben auf den Datenträger.</span><span class="sxs-lookup"><span data-stu-id="d705e-1942">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="d705e-1943">String-Felder, die mehr als Bytes angegeben die `VBFixedString` Attribut werden abgeschnitten, beim Schreiben auf den Datenträger</span><span class="sxs-lookup"><span data-stu-id="d705e-1943">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="d705e-1944">Binärmodus</span><span class="sxs-lookup"><span data-stu-id="d705e-1944">Binary Mode</span></span>  
 <span data-ttu-id="d705e-1945">Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` -Modus-Regeln gelten, bis auf einige Ausnahmen.</span><span class="sxs-lookup"><span data-stu-id="d705e-1945">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="d705e-1946">Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:</span><span class="sxs-lookup"><span data-stu-id="d705e-1946">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="d705e-1947">Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen.</span><span class="sxs-lookup"><span data-stu-id="d705e-1947">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="d705e-1948">`FilePut` Schreibt alle Variablen zusammenhängend, d. h. ohne Leerraum zwischen Datensätzen Datenträger an.</span><span class="sxs-lookup"><span data-stu-id="d705e-1948">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="d705e-1949">Für ein beliebiges Array als ein Array in einer Struktur `FilePut` schreibt nur die Daten.</span><span class="sxs-lookup"><span data-stu-id="d705e-1949">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="d705e-1950">Es wird kein Deskriptor geschrieben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1950">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="d705e-1951">`FilePut` schreibt Zeichenfolgen variabler Länge, die keine Elemente von Strukturen ohne Längendeskriptor 2-Byte-sind.</span><span class="sxs-lookup"><span data-stu-id="d705e-1951">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="d705e-1952">Die Anzahl der geschriebenen Bytes entspricht die Anzahl der Zeichen in der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="d705e-1952">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="d705e-1953">Die folgenden Anweisungen wird z. B. 11 Bytes Datei Zahl 1 schreiben:</span><span class="sxs-lookup"><span data-stu-id="d705e-1953">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="d705e-1954">Schreiben in eine Datei mithilfe der `FilePut` -Funktion erfordert `Write` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.</span><span class="sxs-lookup"><span data-stu-id="d705e-1954">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d705e-1955">Dieses Beispiel verwendet die `FilePut` Funktion, um Daten in eine Datei schreiben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1955">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="d705e-1956">Fünf Datensätze der Struktur `Person` in die Datei geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="d705e-1956">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="d705e-1957"><paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</span><span class="sxs-lookup"><span data-stu-id="d705e-1957"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="d705e-1958">Dateimodus ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="d705e-1958">File mode is invalid.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePutObject">
      <MemberSignature Language="C#" Value="public static void FilePutObject (int FileNumber, object Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePutObject(int32 FileNumber, object Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePutObject (FileNumber As Integer, Value As Object, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="d705e-1959">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-1959">Required.</span></span> <span data-ttu-id="d705e-1960">Eine beliebige gültige Dateinummer.</span><span class="sxs-lookup"><span data-stu-id="d705e-1960">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="d705e-1961">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-1961">Required.</span></span> <span data-ttu-id="d705e-1962">Gültiger Variablenname, der auf den Datenträger geschriebene Daten enthält.</span><span class="sxs-lookup"><span data-stu-id="d705e-1962">Valid variable name that contains data written to disk.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="d705e-1963">Dies ist optional.</span><span class="sxs-lookup"><span data-stu-id="d705e-1963">Optional.</span></span> <span data-ttu-id="d705e-1964">Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), an der der Schreibvorgang beginnt.</span><span class="sxs-lookup"><span data-stu-id="d705e-1964">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span></span></param>
        <summary><span data-ttu-id="d705e-1965">Schreibt Daten aus einer Variablen in eine Datei auf einem Datenträger.</span><span class="sxs-lookup"><span data-stu-id="d705e-1965">Writes data from a variable to a disk file.</span></span>  <span data-ttu-id="d705e-1966">Das <see langword="My" />-Feature bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FilePutObject" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-1966">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePutObject" />.</span></span> <span data-ttu-id="d705e-1967">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-1967">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d705e-1968">Die `FilePutObject` Funktion dient anstelle von `FilePut` um Mehrdeutigkeiten zum Zeitpunkt der Kompilierung zu vermeiden, wenn Typ `Object` wird z. B. anstelle eines anderen Typs übergeben `Integer`, `Long`, `Short`usw.</span><span class="sxs-lookup"><span data-stu-id="d705e-1968">The `FilePutObject` function is used instead of `FilePut` to avoid ambiguities at compile time if type `Object` is passed instead of another type, such as `Integer`, `Long`, `Short`, and so forth.</span></span>  
  
 <span data-ttu-id="d705e-1969">`FilePutObject` schreibt und liest Deskriptoren, die das Objekt zu beschreiben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1969">`FilePutObject` writes and reads descriptors that describe the object.</span></span> <span data-ttu-id="d705e-1970">Wenn Sie beabsichtigen, schreiben die `Variant` Typ `FilePutObject` ist erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-1970">If you intend to write out the `Variant` type, `FilePutObject` is required.</span></span> <span data-ttu-id="d705e-1971">Im Zweifelsfall, wenn Sie ein Objekt für den zweiten Parameter verwenden, wird empfohlen, dass Sie immer verwenden `FilePutObject` und `FileGetObject`.</span><span class="sxs-lookup"><span data-stu-id="d705e-1971">When in doubt, if you are using an object for the second parameter, we recommend that you always use `FilePutObject` and `FileGetObject`.</span></span>  
  
 <span data-ttu-id="d705e-1972">`FilePutObject` gilt nur in `Random` und `Binary` Modus.</span><span class="sxs-lookup"><span data-stu-id="d705e-1972">`FilePutObject` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="d705e-1973">Mit `FilePutObject` geschriebene Daten werden in der Regel mit `FileGetObject` aus einer Datei gelesen.</span><span class="sxs-lookup"><span data-stu-id="d705e-1973">Data written with `FilePutObject` is usually read from a file by using `FileGetObject`.</span></span>  
  
 <span data-ttu-id="d705e-1974">Der erste Datensatz oder Byte in einer Datei befindet sich an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 usw. ist.</span><span class="sxs-lookup"><span data-stu-id="d705e-1974">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="d705e-1975">Wenn Sie weglassen `RecordNumber`, `FilePutObject` schreibt den nächsten Datensatz bzw. Byte nach dem letzten `FileGetObject` oder `FilePutObject` Funktion (oder den Datensatz bzw. das Byte verweist, zu dem letzten `Seek` Funktion).</span><span class="sxs-lookup"><span data-stu-id="d705e-1975">If you omit `RecordNumber`, `FilePutObject` writes the next record or byte after the last `FileGetObject` or `FilePutObject` function (or the record or byte pointed to by the last `Seek` function).</span></span>  
  
 <span data-ttu-id="d705e-1976">Die `StringIsFixedLength` -Argument steuert, ob die Funktion Zeichenfolgen als Variable oder feste Länge interpretiert.</span><span class="sxs-lookup"><span data-stu-id="d705e-1976">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="d705e-1977">`FilePutObject` den Längendeskriptor wird nicht geschrieben werden, wenn das Argument ist `True`.</span><span class="sxs-lookup"><span data-stu-id="d705e-1977">`FilePutObject` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="d705e-1978">Bei Verwendung von `StringIsFixedLength`  =  `True` mit `FilePutObject`, was identisch mit `FileGetObject`, und Sie müssen auch sicherstellen, dass die Zeichenfolge mit der erwarteten Länge initialisiert wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-1978">If you use `StringIsFixedLength` = `True` with `FilePutObject`, you have to do the same with `FileGetObject`, and you must also make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="d705e-1979">Zufällige Modus</span><span class="sxs-lookup"><span data-stu-id="d705e-1979">Random Mode</span></span>  
 <span data-ttu-id="d705e-1980">Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:</span><span class="sxs-lookup"><span data-stu-id="d705e-1980">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="d705e-1981">Wenn die Länge des zu schreibenden Daten kleiner als die Länge ist, angegeben der `RecordLength` -Klausel der `FileOpen` -Funktion, `FilePutObject` nachfolgende Datensätze auf Datensatzlänge schreibt.</span><span class="sxs-lookup"><span data-stu-id="d705e-1981">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePutObject` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="d705e-1982">Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt.</span><span class="sxs-lookup"><span data-stu-id="d705e-1982">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="d705e-1983">Da die Menge der Leerstellen Daten genau ermittelt werden kann, ist es im Allgemeinen empfiehlt sich, die Datensatzlänge der Länge der zu schreibenden Daten überein.</span><span class="sxs-lookup"><span data-stu-id="d705e-1983">Because the amount of padding data cannot be precisely determined, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="d705e-1984">Ist die Länge des zu schreibenden Daten größer als die Länge, angegeben der `RecordLength` -Klausel der `FileOpen` -Funktion eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="d705e-1984">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception is thrown.</span></span>  
  
-   <span data-ttu-id="d705e-1985">Wenn die Zielvariable ein Objekt ist, die einen numerischen Typ enthält `FilePutObject` zwei Bytes, identifizieren den `VarType` des Objekts und schreibt dann die Variable.</span><span class="sxs-lookup"><span data-stu-id="d705e-1985">If the variable being written is an object that contains a numeric type, `FilePutObject` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="d705e-1986">Enthält z. B. wenn ein Objekt zu schreiben, die eine ganze Zahl `FilePutObject` schreibt sechs Bytes: 2 Bytes, die Identifizierung des Objekts als `VarType(3)` (`Integer`) und vier Bytes, die Daten enthalten.</span><span class="sxs-lookup"><span data-stu-id="d705e-1986">For example, when writing an object that contains an integer, `FilePutObject` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="d705e-1987">Die angegebene Datensatzlänge der `RecordLength` Parameter in der `FileOpen` Funktion muss mindestens zwei Bytes größer als die tatsächliche Anzahl von Bytes, die zum Speichern von Variablen erforderlich sein.</span><span class="sxs-lookup"><span data-stu-id="d705e-1987">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="d705e-1988">Ob die Zielvariable ein Objekt, das eine Zeichenfolge enthält `FilePutObject` schreibt eine 2-Byte-Deskriptor identifizieren die `VarType(8)` des Objekts, ein 2-Byte-Deskriptor, der angibt, der Länge der Zeichenfolge und anschließend die Zeichenfolgendaten.</span><span class="sxs-lookup"><span data-stu-id="d705e-1988">If the variable being written is an object that contains a string, `FilePutObject` writes a two-byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="d705e-1989">Die angegebene Datensatzlänge der `RecordLength` Parameter in der `FileOpen` Funktion muss mindestens vier Bytes größer als die tatsächliche Länge der Zeichenfolge sein.</span><span class="sxs-lookup"><span data-stu-id="d705e-1989">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="d705e-1990">Wenn Sie eine Zeichenfolge ohne Deskriptor ablegen möchten, sollten Sie übergeben `True` auf die `StringIsFixedLength` Parameter, und die Zeichenfolge, die Sie einlesen, sollte die richtige Länge.</span><span class="sxs-lookup"><span data-stu-id="d705e-1990">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="d705e-1991">Wenn die Zielvariable ein Array, und klicken Sie dann auf die angegebene Datensatzlänge ist die `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Arraydeskriptor zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1991">If the variable being written is an array, then the record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="d705e-1992">Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang.</span><span class="sxs-lookup"><span data-stu-id="d705e-1992">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="d705e-1993">Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl von Dimensionen: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="d705e-1993">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="d705e-1994">Binärmodus</span><span class="sxs-lookup"><span data-stu-id="d705e-1994">Binary Mode</span></span>  
 <span data-ttu-id="d705e-1995">Für Dateien in geöffnet `Binary` Modus alle der `Random` -Modus-Regeln gelten, außer:</span><span class="sxs-lookup"><span data-stu-id="d705e-1995">For files opened in `Binary` mode, all the `Random` mode rules apply, except:</span></span>  
  
-   <span data-ttu-id="d705e-1996">Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen.</span><span class="sxs-lookup"><span data-stu-id="d705e-1996">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="d705e-1997">`FilePutObject` Schreibt alle Variablen zusammenhängend, d. h. ohne Leerraum zwischen Datensätzen Datenträger an.</span><span class="sxs-lookup"><span data-stu-id="d705e-1997">`FilePutObject` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d705e-1998">Dieses Beispiel verwendet die `FilePutObject` Funktion, um eine Zeichenfolge in eine Datei zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="d705e-1998">This example uses the `FilePutObject` function to write a string to a file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#54](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#54)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />
      </Docs>
    </Member>
    <Member MemberName="FileWidth">
      <MemberSignature Language="C#" Value="public static void FileWidth (int FileNumber, int RecordWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileWidth(int32 FileNumber, int32 RecordWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileWidth (FileNumber As Integer, RecordWidth As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileWidth(int FileNumber, int RecordWidth);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="RecordWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="d705e-1999">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-1999">Required.</span></span> <span data-ttu-id="d705e-2000">Eine beliebige gültige Dateinummer.</span><span class="sxs-lookup"><span data-stu-id="d705e-2000">Any valid file number.</span></span></param>
        <param name="RecordWidth"><span data-ttu-id="d705e-2001">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-2001">Required.</span></span> <span data-ttu-id="d705e-2002">Ein numerischer Ausdruck im Bereich 0-255 einschließlich, der angibt, wie viele Zeichen auf einer Zeile stehen, bevor eine neue Zeile beginnt.</span><span class="sxs-lookup"><span data-stu-id="d705e-2002">Numeric expression in the range 0–255, inclusive, which indicates how many characters appear on a line before a new line is started.</span></span> <span data-ttu-id="d705e-2003">Wenn <c>RecordWidth</c> gleich 0 ist, ist die Länge einer Zeile unbegrenzt.</span><span class="sxs-lookup"><span data-stu-id="d705e-2003">If <c>RecordWidth</c> equals 0, there is no limit to the length of a line.</span></span> <span data-ttu-id="d705e-2004">Der Standardwert für <c>RecordWidth</c> ist 0 (null).</span><span class="sxs-lookup"><span data-stu-id="d705e-2004">The default value for <c>RecordWidth</c> is 0.</span></span></param>
        <summary><span data-ttu-id="d705e-2005">Weist einer Datei, die mit der <see langword="FileOpen" />-Funktion geöffnet wurde, eine Ausgabezeilenbreite zu.</span><span class="sxs-lookup"><span data-stu-id="d705e-2005">Assigns an output line width to a file opened by using the <see langword="FileOpen" /> function.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="d705e-2006">Dieses Beispiel verwendet die `FileWidth` Funktion, um die Ausgabezeilenbreite für eine Datei festzulegen.</span><span class="sxs-lookup"><span data-stu-id="d705e-2006">This example uses the `FileWidth` function to set the output line width for a file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#10](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="d705e-2007">Dateimodus ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="d705e-2007">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FreeFile">
      <MemberSignature Language="C#" Value="public static int FreeFile ();" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 FreeFile() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FreeFile" />
      <MemberSignature Language="VB.NET" Value="Public Function FreeFile () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int FreeFile();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d705e-2008">Gibt einen <see langword="Integer" />-Wert zurück, der die nächste zur Verwendung durch die <see langword="FileOpen" />-Funktion verfügbare Dateinummer darstellt.</span><span class="sxs-lookup"><span data-stu-id="d705e-2008">Returns an <see langword="Integer" /> value that represents the next file number available for use by the <see langword="FileOpen" /> function.</span></span></summary>
        <returns><span data-ttu-id="d705e-2009">Gibt einen <see langword="Integer" />-Wert zurück, der die nächste zur Verwendung durch die <see langword="FileOpen" />-Funktion verfügbare Dateinummer darstellt.</span><span class="sxs-lookup"><span data-stu-id="d705e-2009">Returns an <see langword="Integer" /> value that represents the next file number available for use by the <see langword="FileOpen" /> function.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d705e-2010">Verwendung `FreeFile` eine Dateinummer angeben, die nicht bereits verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-2010">Use `FreeFile` to supply a file number that is not already being used.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d705e-2011">Dieses Beispiel verwendet die `FreeFile` Funktion, um die nächste verfügbare Zahl zurückzugeben.</span><span class="sxs-lookup"><span data-stu-id="d705e-2011">This example uses the `FreeFile` function to return the next available file number.</span></span> <span data-ttu-id="d705e-2012">Für die Ausgabe innerhalb der Schleife werden fünf Dateien geöffnet, und einige Beispieldaten werden an jede geschrieben.</span><span class="sxs-lookup"><span data-stu-id="d705e-2012">Five files are opened for output within the loop, and some sample data is written to each.</span></span>  
  
 [!code-vb[VbVbalrCatRef#55](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#55)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="d705e-2013">Mehr als 255 Dateien verwendet.</span><span class="sxs-lookup"><span data-stu-id="d705e-2013">More than 255 files are in use.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="GetAttr">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.FileAttribute GetAttr (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.FileAttribute GetAttr(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAttr (PathName As String) As FileAttribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::FileAttribute GetAttr(System::String ^ PathName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.FileAttribute</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName"><span data-ttu-id="d705e-2014">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-2014">Required.</span></span> <span data-ttu-id="d705e-2015">Ein <see langword="String" />-Ausdruck, der einen Datei-, Verzeichnis- oder Ordnernamen angibt.</span><span class="sxs-lookup"><span data-stu-id="d705e-2015"><see langword="String" /> expression that specifies a file, directory, or folder name.</span></span> <span data-ttu-id="d705e-2016"><c>PathName</c> kann auch das Verzeichnis oder den Ordner sowie das Laufwerk beinhalten.</span><span class="sxs-lookup"><span data-stu-id="d705e-2016"><c>PathName</c> can include the directory or folder, and the drive.</span></span></param>
        <summary><span data-ttu-id="d705e-2017">Gibt einen <see langword="FileAttribute" />-Wert zurück, der die Attribute einer Datei, eines Verzeichnisses oder eines Ordners darstellt.</span><span class="sxs-lookup"><span data-stu-id="d705e-2017">Returns a <see langword="FileAttribute" /> value that represents the attributes of a file, directory, or folder.</span></span> <span data-ttu-id="d705e-2018">Das <see langword="My" />-Feature bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FileAttribute" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-2018">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileAttribute" />.</span></span> <span data-ttu-id="d705e-2019">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-2019">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <returns><span data-ttu-id="d705e-2020">Der von <see langword="GetAttr" /> zurückgegebene Wert ist die Summe aus folgenden Enumerationswerten:</span><span class="sxs-lookup"><span data-stu-id="d705e-2020">The value returned by <see langword="GetAttr" /> is the sum of the following enumeration values:</span></span>  
  
 <span data-ttu-id="d705e-2021"><list type="table"><item><term> Wert</span><span class="sxs-lookup"><span data-stu-id="d705e-2021"><list type="table"><item><term> Value</span></span>  
  
 <span data-ttu-id="d705e-2022"></term><description> Konstante</span><span class="sxs-lookup"><span data-stu-id="d705e-2022"></term><description> Constant</span></span>  
  
 <span data-ttu-id="d705e-2023"></description><description> Beschreibung</span><span class="sxs-lookup"><span data-stu-id="d705e-2023"></description><description> Description</span></span>  
  
 <span data-ttu-id="d705e-2024"></description></item><item><term><see langword="Normal" /></term><description><see langword="vbNormal" /></description><description> Normal.</span><span class="sxs-lookup"><span data-stu-id="d705e-2024"></description></item><item><term><see langword="Normal" /></term><description><see langword="vbNormal" /></description><description> Normal.</span></span>  
  
 <span data-ttu-id="d705e-2025"></description></item><item><term><see langword="ReadOnly" /></term><description><see langword="vbReadOnly" /></description><description> Schreibgeschützt.</span><span class="sxs-lookup"><span data-stu-id="d705e-2025"></description></item><item><term><see langword="ReadOnly" /></term><description><see langword="vbReadOnly" /></description><description> Read-only.</span></span>  
  
 <span data-ttu-id="d705e-2026"></description></item><item><term><see langword="Hidden" /></term><description><see langword="vbHidden" /></description><description> Ausgeblendet.</span><span class="sxs-lookup"><span data-stu-id="d705e-2026"></description></item><item><term><see langword="Hidden" /></term><description><see langword="vbHidden" /></description><description> Hidden.</span></span>  
  
 <span data-ttu-id="d705e-2027"></description></item><item><term><see langword="System" /></term><description><see langword="vbSystem" /></description><description> Systemdatei.</span><span class="sxs-lookup"><span data-stu-id="d705e-2027"></description></item><item><term><see langword="System" /></term><description><see langword="vbSystem" /></description><description> System file.</span></span>  
  
 <span data-ttu-id="d705e-2028"></description></item><item><term><see langword="Directory" /></term><description><see langword="vbDirectory" /></description><description> Verzeichnis oder Ordner.</span><span class="sxs-lookup"><span data-stu-id="d705e-2028"></description></item><item><term><see langword="Directory" /></term><description><see langword="vbDirectory" /></description><description> Directory or folder.</span></span>  
  
 <span data-ttu-id="d705e-2029"></description></item><item><term><see langword="Archive" /></term><description><see langword="vbArchive" /></description><description> Die Datei wurde nach der letzten Sicherung geändert.</span><span class="sxs-lookup"><span data-stu-id="d705e-2029"></description></item><item><term><see langword="Archive" /></term><description><see langword="vbArchive" /></description><description> File has changed since last backup.</span></span>  
  
 <span data-ttu-id="d705e-2030"></description></item><item><term><see langword="Alias" /></term><description><see langword="vbAlias" /></description><description> Die Datei hat einen anderen Namen.</span><span class="sxs-lookup"><span data-stu-id="d705e-2030"></description></item><item><term><see langword="Alias" /></term><description><see langword="vbAlias" /></description><description> File has a different name.</span></span>  
  
 </description></item></list><block subset="none" type="note"><para>  
 <span data-ttu-id="d705e-2031">Diese Enumerationen werden von der Programmiersprache Visual Basic angegeben.</span><span class="sxs-lookup"><span data-stu-id="d705e-2031">These enumerations are specified by the Visual Basic language.</span></span> <span data-ttu-id="d705e-2032">Die Namen können überall im Code anstelle von tatsächlichen Werten verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="d705e-2032">The names can be used anywhere in your code in place of the actual values.</span></span>  
  
</para></block></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d705e-2033">Verwenden, um zu bestimmen, welche Attribute festgelegt werden, die `And` Operator einen bitweisen Vergleich von den Rückgabewert von Durchführen der `GetAttr` -Funktion und den Wert des Attributs Einzeldatei werden sollen.</span><span class="sxs-lookup"><span data-stu-id="d705e-2033">To determine which attributes are set, use the `And` operator to perform a bitwise comparison of the value returned by the `GetAttr` function and the value of the individual file attribute you want.</span></span> <span data-ttu-id="d705e-2034">Wenn das Ergebnis nicht 0 (null) ist, wird dieses Attribut für die benannte Datei festgelegt.</span><span class="sxs-lookup"><span data-stu-id="d705e-2034">If the result is not zero, that attribute is set for the named file.</span></span> <span data-ttu-id="d705e-2035">Beispielsweise ist der Rückgabewert der folgenden `And` Ausdruck ist NULL, wenn die `Archive` -Attribut nicht festgelegt ist:</span><span class="sxs-lookup"><span data-stu-id="d705e-2035">For example, the return value of the following `And` expression is zero if the `Archive` attribute is not set:</span></span>  
  
```vb  
Result = GetAttr(FName) And vbArchive  
```  
  
 <span data-ttu-id="d705e-2036">Ein Wert ungleich NULL wird zurückgegeben, wenn die `Archive` -Attribut festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="d705e-2036">A nonzero value is returned if the `Archive` attribute is set.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d705e-2037">Dieses Beispiel verwendet die `GetAttr` -Funktion können Sie die Attribute einer Datei und das Verzeichnis oder die Ordner zu ermitteln.</span><span class="sxs-lookup"><span data-stu-id="d705e-2037">This example uses the `GetAttr` function to determine the attributes of a file and directory or folder.</span></span>  
  
 [!code-vb[VbVbalrCatRef#25](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="d705e-2038"><paramref name="Pathname" /> ist ungültig oder enthält Platzhalterzeichen.</span><span class="sxs-lookup"><span data-stu-id="d705e-2038"><paramref name="Pathname" /> is invalid or contains wildcards.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="d705e-2039">Zieldatei ist nicht vorhanden.</span><span class="sxs-lookup"><span data-stu-id="d705e-2039">Target file does not exist.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Input">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d705e-2040">Liest Daten aus einer geöffneten sequenziellen Datei und weist diese Variablen zu.</span><span class="sxs-lookup"><span data-stu-id="d705e-2040">Reads data from an open sequential file and assigns the data to variables.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref bool Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, bool&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, bool % Value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="d705e-2041">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-2041">Required.</span></span> <span data-ttu-id="d705e-2042">Eine beliebige gültige Dateinummer.</span><span class="sxs-lookup"><span data-stu-id="d705e-2042">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="d705e-2043">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-2043">Required.</span></span> <span data-ttu-id="d705e-2044">Eine Variable, der die aus der Datei gelesenen Werte zugewiesen werden, kann kein Array und keine Objektvariable sein.</span><span class="sxs-lookup"><span data-stu-id="d705e-2044">Variable that is assigned the values read from the file—cannot be an array or object variable.</span></span></param>
        <summary><span data-ttu-id="d705e-2045">Liest Daten aus einer geöffneten sequenziellen Datei und weist diese Variablen zu.</span><span class="sxs-lookup"><span data-stu-id="d705e-2045">Reads data from an open sequential file and assigns the data to variables.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d705e-2046">Die `Input` Funktion wird für Abwärtskompatibilität angeboten und die Leistung beeinträchtigen.</span><span class="sxs-lookup"><span data-stu-id="d705e-2046">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="d705e-2047">Für nicht-Legacyanwendungen der `My.Computer.FileSystem` Objekt bietet eine bessere Leistung.</span><span class="sxs-lookup"><span data-stu-id="d705e-2047">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="d705e-2048">Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="d705e-2048">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="d705e-2049">Datenlesevorgänge mit `Input` in der Regel in eine Datei geschrieben wird, mithilfe von `Write`.</span><span class="sxs-lookup"><span data-stu-id="d705e-2049">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="d705e-2050">Verwenden Sie diese Funktion nur mit geöffneten Dateien `Input` oder `Binary` Modus.</span><span class="sxs-lookup"><span data-stu-id="d705e-2050">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="d705e-2051">Beim Lesen aus Dateien nicht Beurteilen der Inhalt der Datei anhand der Dateinamenerweiterung.</span><span class="sxs-lookup"><span data-stu-id="d705e-2051">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="d705e-2052">Eine Datei mit dem Namen "Form1.vb" möglicherweise z. B. keine Visual Basic 2005-Quelldatei.</span><span class="sxs-lookup"><span data-stu-id="d705e-2052">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="d705e-2053">Beim Lesen standard Zeichenfolgen- oder numerische Daten ohne Änderung Variablen zugewiesen werden.</span><span class="sxs-lookup"><span data-stu-id="d705e-2053">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="d705e-2054">Die folgende Tabelle verdeutlicht, wie die Eingabedaten behandelt werden.</span><span class="sxs-lookup"><span data-stu-id="d705e-2054">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="d705e-2055">Daten</span><span class="sxs-lookup"><span data-stu-id="d705e-2055">Data</span></span>|<span data-ttu-id="d705e-2056">Variablen zugewiesenen Wert</span><span class="sxs-lookup"><span data-stu-id="d705e-2056">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="d705e-2057">Komma oder Leerzeile begrenzen</span><span class="sxs-lookup"><span data-stu-id="d705e-2057">Delimiting comma or blank line</span></span>|<span data-ttu-id="d705e-2058">Empty</span><span class="sxs-lookup"><span data-stu-id="d705e-2058">Empty</span></span>|  
|<span data-ttu-id="d705e-2059">#NULL#</span><span class="sxs-lookup"><span data-stu-id="d705e-2059">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="d705e-2060">#TRUE # "oder" #FALSE #</span><span class="sxs-lookup"><span data-stu-id="d705e-2060">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="d705e-2061">`True` oder `False`</span><span class="sxs-lookup"><span data-stu-id="d705e-2061">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="d705e-2062">Das Datum und/oder eine Uhrzeit, die durch den Ausdruck dargestellt wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-2062">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="d705e-2063">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="d705e-2063">#ERROR `errornumber`#</span></span>|<span data-ttu-id="d705e-2064">`errornumber` (Variable ist ein Objekt, das als Fehler gekennzeichnet)</span><span class="sxs-lookup"><span data-stu-id="d705e-2064">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="d705e-2065">Wenn das Ende der Datei wird erreicht, während Sie eines Datenelements, die Eingabe wird beendet und ein Fehler auftritt.</span><span class="sxs-lookup"><span data-stu-id="d705e-2065">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d705e-2066">Die `Input` Funktion ist nicht lokalisiert.</span><span class="sxs-lookup"><span data-stu-id="d705e-2066">The `Input` function is not localized.</span></span> <span data-ttu-id="d705e-2067">Z. B. wenn eingegebene 3,14159, in der deutschen Version wird nur 3 zurückgegeben, da das Komma als Trennzeichen Variablen statt als Dezimaltrennzeichen behandelt wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-2067">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="d705e-2068">Lesen aus einer Datei mithilfe der `Input` -Funktion erfordert `Read` aus Zugriff auf die `FileIOPermissionAccess` Enumeration.</span><span class="sxs-lookup"><span data-stu-id="d705e-2068">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="d705e-2069">Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="d705e-2069">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d705e-2070">Dieses Beispiel verwendet die `Input` Funktion zum Lesen von Daten aus einer Datei in zwei Variablen.</span><span class="sxs-lookup"><span data-stu-id="d705e-2070">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="d705e-2071">In diesem Beispiel wird vorausgesetzt, dass `TestFile` ist eine Datei, die einige Zeilen der Daten, die Sie mithilfe von geschrieben hat die `Write` -Funktion, jede Zeile mit einer Zeichenfolge in Anführungszeichen und eine Zahl, die durch Kommas getrennt ein, z. B.: ("Hello", 234).</span><span class="sxs-lookup"><span data-stu-id="d705e-2071">This example assumes that `TestFile` is a file that has some lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="d705e-2072">Dateimodus ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="d705e-2072">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref byte Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, unsigned int8&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Byte % Value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="d705e-2073">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-2073">Required.</span></span> <span data-ttu-id="d705e-2074">Eine beliebige gültige Dateinummer.</span><span class="sxs-lookup"><span data-stu-id="d705e-2074">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="d705e-2075">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-2075">Required.</span></span> <span data-ttu-id="d705e-2076">Eine Variable, der die aus der Datei gelesenen Werte zugewiesen werden, kann kein Array und keine Objektvariable sein.</span><span class="sxs-lookup"><span data-stu-id="d705e-2076">Variable that is assigned the values read from the file—cannot be an array or object variable.</span></span></param>
        <summary><span data-ttu-id="d705e-2077">Liest Daten aus einer geöffneten sequenziellen Datei und weist diese Variablen zu.</span><span class="sxs-lookup"><span data-stu-id="d705e-2077">Reads data from an open sequential file and assigns the data to variables.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d705e-2078">Die `Input` Funktion wird für Abwärtskompatibilität angeboten und die Leistung beeinträchtigen.</span><span class="sxs-lookup"><span data-stu-id="d705e-2078">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="d705e-2079">Für nicht-Legacyanwendungen der `My.Computer.FileSystem` Objekt bietet eine bessere Leistung.</span><span class="sxs-lookup"><span data-stu-id="d705e-2079">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="d705e-2080">Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="d705e-2080">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="d705e-2081">Datenlesevorgänge mit `Input` in der Regel in eine Datei geschrieben wird, mithilfe von `Write`.</span><span class="sxs-lookup"><span data-stu-id="d705e-2081">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="d705e-2082">Verwenden Sie diese Funktion nur mit geöffneten Dateien `Input` oder `Binary` Modus.</span><span class="sxs-lookup"><span data-stu-id="d705e-2082">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="d705e-2083">Beim Lesen aus Dateien nicht Beurteilen der Inhalt der Datei anhand der Dateinamenerweiterung.</span><span class="sxs-lookup"><span data-stu-id="d705e-2083">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="d705e-2084">Eine Datei mit dem Namen "Form1.vb" möglicherweise z. B. keine Visual Basic 2005-Quelldatei.</span><span class="sxs-lookup"><span data-stu-id="d705e-2084">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="d705e-2085">Beim Lesen standard Zeichenfolgen- oder numerische Daten ohne Änderung Variablen zugewiesen werden.</span><span class="sxs-lookup"><span data-stu-id="d705e-2085">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="d705e-2086">Die folgende Tabelle verdeutlicht, wie die Eingabedaten behandelt werden.</span><span class="sxs-lookup"><span data-stu-id="d705e-2086">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="d705e-2087">Daten</span><span class="sxs-lookup"><span data-stu-id="d705e-2087">Data</span></span>|<span data-ttu-id="d705e-2088">Variablen zugewiesenen Wert</span><span class="sxs-lookup"><span data-stu-id="d705e-2088">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="d705e-2089">Komma oder Leerzeile begrenzen</span><span class="sxs-lookup"><span data-stu-id="d705e-2089">Delimiting comma or blank line</span></span>|<span data-ttu-id="d705e-2090">Empty</span><span class="sxs-lookup"><span data-stu-id="d705e-2090">Empty</span></span>|  
|<span data-ttu-id="d705e-2091">#NULL#</span><span class="sxs-lookup"><span data-stu-id="d705e-2091">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="d705e-2092">#TRUE # "oder" #FALSE #</span><span class="sxs-lookup"><span data-stu-id="d705e-2092">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="d705e-2093">`True` oder `False`</span><span class="sxs-lookup"><span data-stu-id="d705e-2093">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="d705e-2094">Das Datum und/oder eine Uhrzeit, die durch den Ausdruck dargestellt wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-2094">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="d705e-2095">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="d705e-2095">#ERROR `errornumber`#</span></span>|<span data-ttu-id="d705e-2096">`errornumber` (Variable ist ein Objekt, das als Fehler gekennzeichnet)</span><span class="sxs-lookup"><span data-stu-id="d705e-2096">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="d705e-2097">Wenn das Ende der Datei wird erreicht, während Sie eines Datenelements, die Eingabe wird beendet und ein Fehler auftritt.</span><span class="sxs-lookup"><span data-stu-id="d705e-2097">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d705e-2098">Die `Input` Funktion ist nicht lokalisiert.</span><span class="sxs-lookup"><span data-stu-id="d705e-2098">The `Input` function is not localized.</span></span> <span data-ttu-id="d705e-2099">Z. B. wenn eingegebene 3,14159, in der deutschen Version wird nur 3 zurückgegeben, da das Komma als Trennzeichen Variablen statt als Dezimaltrennzeichen behandelt wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-2099">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="d705e-2100">Lesen aus einer Datei mithilfe der `Input` -Funktion erfordert `Read` aus Zugriff auf die `FileIOPermissionAccess` Enumeration.</span><span class="sxs-lookup"><span data-stu-id="d705e-2100">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="d705e-2101">Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="d705e-2101">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d705e-2102">Dieses Beispiel verwendet die `Input` Funktion zum Lesen von Daten aus einer Datei in zwei Variablen.</span><span class="sxs-lookup"><span data-stu-id="d705e-2102">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="d705e-2103">In diesem Beispiel wird vorausgesetzt, dass `TestFile` ist eine Datei, die einige Zeilen der Daten, die Sie mithilfe von geschrieben hat die `Write` -Funktion, jede Zeile mit einer Zeichenfolge in Anführungszeichen und eine Zahl, die durch Kommas getrennt ein, z. B.: ("Hello", 234).</span><span class="sxs-lookup"><span data-stu-id="d705e-2103">This example assumes that `TestFile` is a file that has some lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="d705e-2104">Dateimodus ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="d705e-2104">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref char Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, char&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, char % Value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="d705e-2105">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-2105">Required.</span></span> <span data-ttu-id="d705e-2106">Eine beliebige gültige Dateinummer.</span><span class="sxs-lookup"><span data-stu-id="d705e-2106">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="d705e-2107">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-2107">Required.</span></span> <span data-ttu-id="d705e-2108">Eine Variable, der die aus der Datei gelesenen Werte zugewiesen werden, kann kein Array und keine Objektvariable sein.</span><span class="sxs-lookup"><span data-stu-id="d705e-2108">Variable that is assigned the values read from the file—cannot be an array or object variable.</span></span></param>
        <summary><span data-ttu-id="d705e-2109">Liest Daten aus einer geöffneten sequenziellen Datei und weist diese Variablen zu.</span><span class="sxs-lookup"><span data-stu-id="d705e-2109">Reads data from an open sequential file and assigns the data to variables.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d705e-2110">Die `Input` Funktion wird für Abwärtskompatibilität angeboten und die Leistung beeinträchtigen.</span><span class="sxs-lookup"><span data-stu-id="d705e-2110">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="d705e-2111">Für nicht-Legacyanwendungen der `My.Computer.FileSystem` Objekt bietet eine bessere Leistung.</span><span class="sxs-lookup"><span data-stu-id="d705e-2111">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="d705e-2112">Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="d705e-2112">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="d705e-2113">Datenlesevorgänge mit `Input` in der Regel in eine Datei geschrieben wird, mithilfe von `Write`.</span><span class="sxs-lookup"><span data-stu-id="d705e-2113">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="d705e-2114">Verwenden Sie diese Funktion nur mit geöffneten Dateien `Input` oder `Binary` Modus.</span><span class="sxs-lookup"><span data-stu-id="d705e-2114">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="d705e-2115">Beim Lesen aus Dateien nicht Beurteilen der Inhalt der Datei anhand der Dateinamenerweiterung.</span><span class="sxs-lookup"><span data-stu-id="d705e-2115">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="d705e-2116">Eine Datei mit dem Namen "Form1.vb" möglicherweise z. B. keine Visual Basic 2005-Quelldatei.</span><span class="sxs-lookup"><span data-stu-id="d705e-2116">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="d705e-2117">Beim Lesen standard Zeichenfolgen- oder numerische Daten ohne Änderung Variablen zugewiesen werden.</span><span class="sxs-lookup"><span data-stu-id="d705e-2117">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="d705e-2118">Die folgende Tabelle verdeutlicht, wie die Eingabedaten behandelt werden.</span><span class="sxs-lookup"><span data-stu-id="d705e-2118">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="d705e-2119">Daten</span><span class="sxs-lookup"><span data-stu-id="d705e-2119">Data</span></span>|<span data-ttu-id="d705e-2120">Variablen zugewiesenen Wert</span><span class="sxs-lookup"><span data-stu-id="d705e-2120">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="d705e-2121">Komma oder Leerzeile begrenzen</span><span class="sxs-lookup"><span data-stu-id="d705e-2121">Delimiting comma or blank line</span></span>|<span data-ttu-id="d705e-2122">Empty</span><span class="sxs-lookup"><span data-stu-id="d705e-2122">Empty</span></span>|  
|<span data-ttu-id="d705e-2123">#NULL#</span><span class="sxs-lookup"><span data-stu-id="d705e-2123">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="d705e-2124">#TRUE # "oder" #FALSE #</span><span class="sxs-lookup"><span data-stu-id="d705e-2124">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="d705e-2125">`True` oder `False`</span><span class="sxs-lookup"><span data-stu-id="d705e-2125">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="d705e-2126">Das Datum und/oder eine Uhrzeit, die durch den Ausdruck dargestellt wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-2126">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="d705e-2127">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="d705e-2127">#ERROR `errornumber`#</span></span>|<span data-ttu-id="d705e-2128">`errornumber` (Variable ist ein Objekt, das als Fehler gekennzeichnet)</span><span class="sxs-lookup"><span data-stu-id="d705e-2128">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="d705e-2129">Wenn das Ende der Datei wird erreicht, während Sie eines Datenelements, die Eingabe wird beendet und ein Fehler auftritt.</span><span class="sxs-lookup"><span data-stu-id="d705e-2129">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d705e-2130">Die `Input` Funktion ist nicht lokalisiert.</span><span class="sxs-lookup"><span data-stu-id="d705e-2130">The `Input` function is not localized.</span></span> <span data-ttu-id="d705e-2131">Z. B. wenn eingegebene 3,14159, in der deutschen Version wird nur 3 zurückgegeben, da das Komma als Trennzeichen Variablen statt als Dezimaltrennzeichen behandelt wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-2131">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="d705e-2132">Lesen aus einer Datei mithilfe der `Input` -Funktion erfordert `Read` aus Zugriff auf die `FileIOPermissionAccess` Enumeration.</span><span class="sxs-lookup"><span data-stu-id="d705e-2132">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="d705e-2133">Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="d705e-2133">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d705e-2134">Dieses Beispiel verwendet die `Input` Funktion zum Lesen von Daten aus einer Datei in zwei Variablen.</span><span class="sxs-lookup"><span data-stu-id="d705e-2134">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="d705e-2135">In diesem Beispiel wird vorausgesetzt, dass `TestFile` ist eine Datei, die mehrere Zeilen mit Daten, die Sie mithilfe von geschrieben hat die `Write` -Funktion, jede Zeile mit einer Zeichenfolge in Anführungszeichen und eine Zahl, die durch Kommas getrennt ein, z. B.: ("Hello", 234).</span><span class="sxs-lookup"><span data-stu-id="d705e-2135">This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="d705e-2136">Dateimodus ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="d705e-2136">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref DateTime Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, valuetype System.DateTime&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, DateTime % Value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="d705e-2137">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-2137">Required.</span></span> <span data-ttu-id="d705e-2138">Eine beliebige gültige Dateinummer.</span><span class="sxs-lookup"><span data-stu-id="d705e-2138">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="d705e-2139">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-2139">Required.</span></span> <span data-ttu-id="d705e-2140">Eine Variable, der die aus der Datei gelesenen Werte zugewiesen werden, kann kein Array und keine Objektvariable sein.</span><span class="sxs-lookup"><span data-stu-id="d705e-2140">Variable that is assigned the values read from the file—cannot be an array or object variable.</span></span></param>
        <summary><span data-ttu-id="d705e-2141">Liest Daten aus einer geöffneten sequenziellen Datei und weist diese Variablen zu.</span><span class="sxs-lookup"><span data-stu-id="d705e-2141">Reads data from an open sequential file and assigns the data to variables.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d705e-2142">Die `Input` Funktion wird für Abwärtskompatibilität angeboten und die Leistung beeinträchtigen.</span><span class="sxs-lookup"><span data-stu-id="d705e-2142">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="d705e-2143">Für nicht-Legacyanwendungen der `My.Computer.FileSystem` Objekt bietet eine bessere Leistung.</span><span class="sxs-lookup"><span data-stu-id="d705e-2143">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="d705e-2144">Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="d705e-2144">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="d705e-2145">Datenlesevorgänge mit `Input` in der Regel in eine Datei geschrieben wird, mithilfe von `Write`.</span><span class="sxs-lookup"><span data-stu-id="d705e-2145">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="d705e-2146">Verwenden Sie diese Funktion nur mit geöffneten Dateien `Input` oder `Binary` Modus.</span><span class="sxs-lookup"><span data-stu-id="d705e-2146">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="d705e-2147">Beim Lesen aus Dateien nicht Beurteilen der Inhalt der Datei anhand der Dateinamenerweiterung.</span><span class="sxs-lookup"><span data-stu-id="d705e-2147">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="d705e-2148">Eine Datei mit dem Namen "Form1.vb" möglicherweise z. B. keine Visual Basic 2005-Quelldatei.</span><span class="sxs-lookup"><span data-stu-id="d705e-2148">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="d705e-2149">Beim Lesen standard Zeichenfolgen- oder numerische Daten ohne Änderung Variablen zugewiesen werden.</span><span class="sxs-lookup"><span data-stu-id="d705e-2149">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="d705e-2150">Die folgende Tabelle verdeutlicht, wie die Eingabedaten behandelt werden.</span><span class="sxs-lookup"><span data-stu-id="d705e-2150">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="d705e-2151">Daten</span><span class="sxs-lookup"><span data-stu-id="d705e-2151">Data</span></span>|<span data-ttu-id="d705e-2152">Variablen zugewiesenen Wert</span><span class="sxs-lookup"><span data-stu-id="d705e-2152">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="d705e-2153">Komma oder Leerzeile begrenzen</span><span class="sxs-lookup"><span data-stu-id="d705e-2153">Delimiting comma or blank line</span></span>|<span data-ttu-id="d705e-2154">Empty</span><span class="sxs-lookup"><span data-stu-id="d705e-2154">Empty</span></span>|  
|<span data-ttu-id="d705e-2155">#NULL#</span><span class="sxs-lookup"><span data-stu-id="d705e-2155">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="d705e-2156">#TRUE # "oder" #FALSE #</span><span class="sxs-lookup"><span data-stu-id="d705e-2156">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="d705e-2157">`True` oder `False`</span><span class="sxs-lookup"><span data-stu-id="d705e-2157">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="d705e-2158">Das Datum und/oder eine Uhrzeit, die durch den Ausdruck dargestellt wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-2158">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="d705e-2159">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="d705e-2159">#ERROR `errornumber`#</span></span>|<span data-ttu-id="d705e-2160">`errornumber` (Variable ist ein Objekt, das als Fehler gekennzeichnet)</span><span class="sxs-lookup"><span data-stu-id="d705e-2160">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="d705e-2161">Wenn das Ende der Datei wird erreicht, während Sie eines Datenelements, die Eingabe wird beendet und ein Fehler auftritt.</span><span class="sxs-lookup"><span data-stu-id="d705e-2161">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d705e-2162">Die `Input` Funktion ist nicht lokalisiert.</span><span class="sxs-lookup"><span data-stu-id="d705e-2162">The `Input` function is not localized.</span></span> <span data-ttu-id="d705e-2163">Z. B. wenn eingegebene 3,14159, in der deutschen Version wird nur 3 zurückgegeben, da das Komma als Trennzeichen Variablen statt als Dezimaltrennzeichen behandelt wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-2163">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="d705e-2164">Lesen aus einer Datei mithilfe der `Input` -Funktion erfordert `Read` aus Zugriff auf die `FileIOPermissionAccess` Enumeration.</span><span class="sxs-lookup"><span data-stu-id="d705e-2164">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="d705e-2165">Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="d705e-2165">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d705e-2166">Dieses Beispiel verwendet die `Input` Funktion zum Lesen von Daten aus einer Datei in zwei Variablen.</span><span class="sxs-lookup"><span data-stu-id="d705e-2166">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="d705e-2167">In diesem Beispiel wird vorausgesetzt, dass `TestFile` ist eine Datei, die mehrere Zeilen mit Daten, die Sie mithilfe von geschrieben hat die `Write` -Funktion, jede Zeile mit einer Zeichenfolge in Anführungszeichen und eine Zahl, die durch Kommas getrennt ein, z. B.: ("Hello", 234).</span><span class="sxs-lookup"><span data-stu-id="d705e-2167">This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="d705e-2168">Dateimodus ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="d705e-2168">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref decimal Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, valuetype System.Decimal&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Decimal % Value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="d705e-2169">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-2169">Required.</span></span> <span data-ttu-id="d705e-2170">Eine beliebige gültige Dateinummer.</span><span class="sxs-lookup"><span data-stu-id="d705e-2170">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="d705e-2171">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-2171">Required.</span></span> <span data-ttu-id="d705e-2172">Eine Variable, der die aus der Datei gelesenen Werte zugewiesen werden, kann kein Array und keine Objektvariable sein.</span><span class="sxs-lookup"><span data-stu-id="d705e-2172">Variable that is assigned the values read from the file—cannot be an array or object variable.</span></span></param>
        <summary><span data-ttu-id="d705e-2173">Liest Daten aus einer geöffneten sequenziellen Datei und weist diese Variablen zu.</span><span class="sxs-lookup"><span data-stu-id="d705e-2173">Reads data from an open sequential file and assigns the data to variables.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d705e-2174">Die `Input` Funktion wird für Abwärtskompatibilität angeboten und die Leistung beeinträchtigen.</span><span class="sxs-lookup"><span data-stu-id="d705e-2174">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="d705e-2175">Für nicht-Legacyanwendungen der `My.Computer.FileSystem` Objekt bietet eine bessere Leistung.</span><span class="sxs-lookup"><span data-stu-id="d705e-2175">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="d705e-2176">Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="d705e-2176">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="d705e-2177">Datenlesevorgänge mit `Input` in der Regel in eine Datei geschrieben wird, mithilfe von `Write`.</span><span class="sxs-lookup"><span data-stu-id="d705e-2177">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="d705e-2178">Verwenden Sie diese Funktion nur mit geöffneten Dateien `Input` oder `Binary` Modus.</span><span class="sxs-lookup"><span data-stu-id="d705e-2178">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="d705e-2179">Beim Lesen aus Dateien nicht Beurteilen der Inhalt der Datei anhand der Dateinamenerweiterung.</span><span class="sxs-lookup"><span data-stu-id="d705e-2179">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="d705e-2180">Eine Datei mit dem Namen "Form1.vb" möglicherweise z. B. keine Visual Basic 2005-Quelldatei.</span><span class="sxs-lookup"><span data-stu-id="d705e-2180">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="d705e-2181">Beim Lesen standard Zeichenfolgen- oder numerische Daten ohne Änderung Variablen zugewiesen werden.</span><span class="sxs-lookup"><span data-stu-id="d705e-2181">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="d705e-2182">Die folgende Tabelle verdeutlicht, wie die Eingabedaten behandelt werden.</span><span class="sxs-lookup"><span data-stu-id="d705e-2182">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="d705e-2183">Daten</span><span class="sxs-lookup"><span data-stu-id="d705e-2183">Data</span></span>|<span data-ttu-id="d705e-2184">Variablen zugewiesenen Wert</span><span class="sxs-lookup"><span data-stu-id="d705e-2184">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="d705e-2185">Komma oder Leerzeile begrenzen</span><span class="sxs-lookup"><span data-stu-id="d705e-2185">Delimiting comma or blank line</span></span>|<span data-ttu-id="d705e-2186">Empty</span><span class="sxs-lookup"><span data-stu-id="d705e-2186">Empty</span></span>|  
|<span data-ttu-id="d705e-2187">#NULL#</span><span class="sxs-lookup"><span data-stu-id="d705e-2187">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="d705e-2188">#TRUE # "oder" #FALSE #</span><span class="sxs-lookup"><span data-stu-id="d705e-2188">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="d705e-2189">`True` oder `False`</span><span class="sxs-lookup"><span data-stu-id="d705e-2189">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="d705e-2190">Das Datum und/oder eine Uhrzeit, die durch den Ausdruck dargestellt wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-2190">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="d705e-2191">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="d705e-2191">#ERROR `errornumber`#</span></span>|<span data-ttu-id="d705e-2192">`errornumber` (Variable ist ein Objekt, das als Fehler gekennzeichnet)</span><span class="sxs-lookup"><span data-stu-id="d705e-2192">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="d705e-2193">Wenn das Ende der Datei wird erreicht, während Sie eines Datenelements, die Eingabe wird beendet und ein Fehler auftritt.</span><span class="sxs-lookup"><span data-stu-id="d705e-2193">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d705e-2194">Die `Input` Funktion ist nicht lokalisiert.</span><span class="sxs-lookup"><span data-stu-id="d705e-2194">The `Input` function is not localized.</span></span> <span data-ttu-id="d705e-2195">Z. B. wenn eingegebene 3,14159, in der deutschen Version wird nur 3 zurückgegeben, da das Komma als Trennzeichen Variablen statt als Dezimaltrennzeichen behandelt wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-2195">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="d705e-2196">Lesen aus einer Datei mithilfe der `Input` -Funktion erfordert `Read` aus Zugriff auf die `FileIOPermissionAccess` Enumeration.</span><span class="sxs-lookup"><span data-stu-id="d705e-2196">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="d705e-2197">Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="d705e-2197">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d705e-2198">Dieses Beispiel verwendet die `Input` Funktion zum Lesen von Daten aus einer Datei in zwei Variablen.</span><span class="sxs-lookup"><span data-stu-id="d705e-2198">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="d705e-2199">In diesem Beispiel wird vorausgesetzt, dass `TestFile` ist eine Datei, die mehrere Zeilen mit Daten, die Sie mithilfe von geschrieben hat die `Write` -Funktion, jede Zeile mit einer Zeichenfolge in Anführungszeichen und eine Zahl, die durch Kommas getrennt ein, z. B.: ("Hello", 234).</span><span class="sxs-lookup"><span data-stu-id="d705e-2199">This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="d705e-2200">Dateimodus ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="d705e-2200">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref double Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, float64&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, double % Value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="d705e-2201">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-2201">Required.</span></span> <span data-ttu-id="d705e-2202">Eine beliebige gültige Dateinummer.</span><span class="sxs-lookup"><span data-stu-id="d705e-2202">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="d705e-2203">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-2203">Required.</span></span> <span data-ttu-id="d705e-2204">Eine Variable, der die aus der Datei gelesenen Werte zugewiesen werden, kann kein Array und keine Objektvariable sein.</span><span class="sxs-lookup"><span data-stu-id="d705e-2204">Variable that is assigned the values read from the file—cannot be an array or object variable.</span></span></param>
        <summary><span data-ttu-id="d705e-2205">Liest Daten aus einer geöffneten sequenziellen Datei und weist diese Variablen zu.</span><span class="sxs-lookup"><span data-stu-id="d705e-2205">Reads data from an open sequential file and assigns the data to variables.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d705e-2206">Die `Input` Funktion wird für Abwärtskompatibilität angeboten und die Leistung beeinträchtigen.</span><span class="sxs-lookup"><span data-stu-id="d705e-2206">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="d705e-2207">Für nicht-Legacyanwendungen der `My.Computer.FileSystem` Objekt bietet eine bessere Leistung.</span><span class="sxs-lookup"><span data-stu-id="d705e-2207">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="d705e-2208">Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="d705e-2208">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="d705e-2209">Datenlesevorgänge mit `Input` in der Regel in eine Datei geschrieben wird, mithilfe von `Write`.</span><span class="sxs-lookup"><span data-stu-id="d705e-2209">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="d705e-2210">Verwenden Sie diese Funktion nur mit geöffneten Dateien `Input` oder `Binary` Modus.</span><span class="sxs-lookup"><span data-stu-id="d705e-2210">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="d705e-2211">Beim Lesen aus Dateien nicht Beurteilen der Inhalt der Datei anhand der Dateinamenerweiterung.</span><span class="sxs-lookup"><span data-stu-id="d705e-2211">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="d705e-2212">Eine Datei mit dem Namen "Form1.vb" möglicherweise z. B. keine Visual Basic 2005-Quelldatei.</span><span class="sxs-lookup"><span data-stu-id="d705e-2212">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="d705e-2213">Beim Lesen standard Zeichenfolgen- oder numerische Daten ohne Änderung Variablen zugewiesen werden.</span><span class="sxs-lookup"><span data-stu-id="d705e-2213">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="d705e-2214">Die folgende Tabelle verdeutlicht, wie die Eingabedaten behandelt werden.</span><span class="sxs-lookup"><span data-stu-id="d705e-2214">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="d705e-2215">Daten</span><span class="sxs-lookup"><span data-stu-id="d705e-2215">Data</span></span>|<span data-ttu-id="d705e-2216">Variablen zugewiesenen Wert</span><span class="sxs-lookup"><span data-stu-id="d705e-2216">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="d705e-2217">Komma oder Leerzeile begrenzen</span><span class="sxs-lookup"><span data-stu-id="d705e-2217">Delimiting comma or blank line</span></span>|<span data-ttu-id="d705e-2218">Empty</span><span class="sxs-lookup"><span data-stu-id="d705e-2218">Empty</span></span>|  
|<span data-ttu-id="d705e-2219">#NULL#</span><span class="sxs-lookup"><span data-stu-id="d705e-2219">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="d705e-2220">#TRUE # "oder" #FALSE #</span><span class="sxs-lookup"><span data-stu-id="d705e-2220">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="d705e-2221">`True` oder `False`</span><span class="sxs-lookup"><span data-stu-id="d705e-2221">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="d705e-2222">Das Datum und/oder eine Uhrzeit, die durch den Ausdruck dargestellt wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-2222">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="d705e-2223">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="d705e-2223">#ERROR `errornumber`#</span></span>|<span data-ttu-id="d705e-2224">`errornumber` (Variable ist ein Objekt, das als Fehler gekennzeichnet)</span><span class="sxs-lookup"><span data-stu-id="d705e-2224">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="d705e-2225">Wenn das Ende der Datei wird erreicht, während Sie eines Datenelements, die Eingabe wird beendet und ein Fehler auftritt.</span><span class="sxs-lookup"><span data-stu-id="d705e-2225">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d705e-2226">Die `Input` Funktion ist nicht lokalisiert.</span><span class="sxs-lookup"><span data-stu-id="d705e-2226">The `Input` function is not localized.</span></span> <span data-ttu-id="d705e-2227">Z. B. wenn eingegebene 3,14159, in der deutschen Version wird nur 3 zurückgegeben, da das Komma als Trennzeichen Variablen statt als Dezimaltrennzeichen behandelt wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-2227">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="d705e-2228">Lesen aus einer Datei mithilfe der `Input` -Funktion erfordert `Read` aus Zugriff auf die `FileIOPermissionAccess` Enumeration.</span><span class="sxs-lookup"><span data-stu-id="d705e-2228">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="d705e-2229">Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="d705e-2229">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d705e-2230">Dieses Beispiel verwendet die `Input` Funktion zum Lesen von Daten aus einer Datei in zwei Variablen.</span><span class="sxs-lookup"><span data-stu-id="d705e-2230">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="d705e-2231">In diesem Beispiel wird vorausgesetzt, dass `TestFile` ist eine Datei, die mehrere Zeilen mit Daten, die Sie mithilfe von geschrieben hat die `Write` -Funktion, jede Zeile mit einer Zeichenfolge in Anführungszeichen und eine Zahl, die durch Kommas getrennt ein, z. B.: ("Hello", 234).</span><span class="sxs-lookup"><span data-stu-id="d705e-2231">This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="d705e-2232">Dateimodus ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="d705e-2232">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref short Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int16&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, short % Value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="d705e-2233">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-2233">Required.</span></span> <span data-ttu-id="d705e-2234">Eine beliebige gültige Dateinummer.</span><span class="sxs-lookup"><span data-stu-id="d705e-2234">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="d705e-2235">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-2235">Required.</span></span> <span data-ttu-id="d705e-2236">Eine Variable, der die aus der Datei gelesenen Werte zugewiesen werden, kann kein Array und keine Objektvariable sein.</span><span class="sxs-lookup"><span data-stu-id="d705e-2236">Variable that is assigned the values read from the file—cannot be an array or object variable.</span></span></param>
        <summary><span data-ttu-id="d705e-2237">Liest Daten aus einer geöffneten sequenziellen Datei und weist diese Variablen zu.</span><span class="sxs-lookup"><span data-stu-id="d705e-2237">Reads data from an open sequential file and assigns the data to variables.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d705e-2238">Die `Input` Funktion wird für Abwärtskompatibilität angeboten und die Leistung beeinträchtigen.</span><span class="sxs-lookup"><span data-stu-id="d705e-2238">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="d705e-2239">Für nicht-Legacyanwendungen der `My.Computer.FileSystem` Objekt bietet eine bessere Leistung.</span><span class="sxs-lookup"><span data-stu-id="d705e-2239">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="d705e-2240">Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="d705e-2240">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="d705e-2241">Datenlesevorgänge mit `Input` in der Regel in eine Datei geschrieben wird, mithilfe von `Write`.</span><span class="sxs-lookup"><span data-stu-id="d705e-2241">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="d705e-2242">Verwenden Sie diese Funktion nur mit geöffneten Dateien `Input` oder `Binary` Modus.</span><span class="sxs-lookup"><span data-stu-id="d705e-2242">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="d705e-2243">Beim Lesen aus Dateien nicht Beurteilen der Inhalt der Datei anhand der Dateinamenerweiterung.</span><span class="sxs-lookup"><span data-stu-id="d705e-2243">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="d705e-2244">Eine Datei mit dem Namen "Form1.vb" möglicherweise z. B. keine Visual Basic 2005-Quelldatei.</span><span class="sxs-lookup"><span data-stu-id="d705e-2244">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="d705e-2245">Beim Lesen standard Zeichenfolgen- oder numerische Daten ohne Änderung Variablen zugewiesen werden.</span><span class="sxs-lookup"><span data-stu-id="d705e-2245">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="d705e-2246">Die folgende Tabelle verdeutlicht, wie die Eingabedaten behandelt werden.</span><span class="sxs-lookup"><span data-stu-id="d705e-2246">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="d705e-2247">Daten</span><span class="sxs-lookup"><span data-stu-id="d705e-2247">Data</span></span>|<span data-ttu-id="d705e-2248">Variablen zugewiesenen Wert</span><span class="sxs-lookup"><span data-stu-id="d705e-2248">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="d705e-2249">Komma oder Leerzeile begrenzen</span><span class="sxs-lookup"><span data-stu-id="d705e-2249">Delimiting comma or blank line</span></span>|<span data-ttu-id="d705e-2250">Empty</span><span class="sxs-lookup"><span data-stu-id="d705e-2250">Empty</span></span>|  
|<span data-ttu-id="d705e-2251">#NULL#</span><span class="sxs-lookup"><span data-stu-id="d705e-2251">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="d705e-2252">#TRUE # "oder" #FALSE #</span><span class="sxs-lookup"><span data-stu-id="d705e-2252">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="d705e-2253">`True` oder `False`</span><span class="sxs-lookup"><span data-stu-id="d705e-2253">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="d705e-2254">Das Datum und/oder eine Uhrzeit, die durch den Ausdruck dargestellt wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-2254">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="d705e-2255">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="d705e-2255">#ERROR `errornumber`#</span></span>|<span data-ttu-id="d705e-2256">`errornumber` (Variable ist ein Objekt, das als Fehler gekennzeichnet)</span><span class="sxs-lookup"><span data-stu-id="d705e-2256">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="d705e-2257">Wenn das Ende der Datei wird erreicht, während Sie eines Datenelements, die Eingabe wird beendet und ein Fehler auftritt.</span><span class="sxs-lookup"><span data-stu-id="d705e-2257">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d705e-2258">Die `Input` Funktion ist nicht lokalisiert.</span><span class="sxs-lookup"><span data-stu-id="d705e-2258">The `Input` function is not localized.</span></span> <span data-ttu-id="d705e-2259">Z. B. wenn eingegebene 3,14159, in der deutschen Version wird nur 3 zurückgegeben, da das Komma als Trennzeichen Variablen statt als Dezimaltrennzeichen behandelt wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-2259">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="d705e-2260">Lesen aus einer Datei mithilfe der `Input` -Funktion erfordert `Read` aus Zugriff auf die `FileIOPermissionAccess` Enumeration.</span><span class="sxs-lookup"><span data-stu-id="d705e-2260">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="d705e-2261">Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="d705e-2261">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d705e-2262">Dieses Beispiel verwendet die `Input` Funktion zum Lesen von Daten aus einer Datei in zwei Variablen.</span><span class="sxs-lookup"><span data-stu-id="d705e-2262">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="d705e-2263">In diesem Beispiel wird vorausgesetzt, dass `TestFile` ist eine Datei, die mehrere Zeilen mit Daten, die Sie mithilfe von geschrieben hat die `Write` -Funktion, jede Zeile mit einer Zeichenfolge in Anführungszeichen und eine Zahl, die durch Kommas getrennt ein, z. B.: ("Hello", 234).</span><span class="sxs-lookup"><span data-stu-id="d705e-2263">This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="d705e-2264">Dateimodus ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="d705e-2264">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref int Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int32&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, int % Value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="d705e-2265">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-2265">Required.</span></span> <span data-ttu-id="d705e-2266">Eine beliebige gültige Dateinummer.</span><span class="sxs-lookup"><span data-stu-id="d705e-2266">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="d705e-2267">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-2267">Required.</span></span> <span data-ttu-id="d705e-2268">Eine Variable, der die aus der Datei gelesenen Werte zugewiesen werden, kann kein Array und keine Objektvariable sein.</span><span class="sxs-lookup"><span data-stu-id="d705e-2268">Variable that is assigned the values read from the file—cannot be an array or object variable.</span></span></param>
        <summary><span data-ttu-id="d705e-2269">Liest Daten aus einer geöffneten sequenziellen Datei und weist diese Variablen zu.</span><span class="sxs-lookup"><span data-stu-id="d705e-2269">Reads data from an open sequential file and assigns the data to variables.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d705e-2270">Die `Input` Funktion wird für Abwärtskompatibilität angeboten und die Leistung beeinträchtigen.</span><span class="sxs-lookup"><span data-stu-id="d705e-2270">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="d705e-2271">Für nicht-Legacyanwendungen der `My.Computer.FileSystem` Objekt bietet eine bessere Leistung.</span><span class="sxs-lookup"><span data-stu-id="d705e-2271">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="d705e-2272">Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="d705e-2272">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="d705e-2273">Datenlesevorgänge mit `Input` in der Regel in eine Datei geschrieben wird, mithilfe von `Write`.</span><span class="sxs-lookup"><span data-stu-id="d705e-2273">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="d705e-2274">Verwenden Sie diese Funktion nur mit geöffneten Dateien `Input` oder `Binary` Modus.</span><span class="sxs-lookup"><span data-stu-id="d705e-2274">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="d705e-2275">Beim Lesen aus Dateien nicht Beurteilen der Inhalt der Datei anhand der Dateinamenerweiterung.</span><span class="sxs-lookup"><span data-stu-id="d705e-2275">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="d705e-2276">Eine Datei mit dem Namen "Form1.vb" möglicherweise z. B. keine Visual Basic 2005-Quelldatei.</span><span class="sxs-lookup"><span data-stu-id="d705e-2276">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="d705e-2277">Beim Lesen standard Zeichenfolgen- oder numerische Daten ohne Änderung Variablen zugewiesen werden.</span><span class="sxs-lookup"><span data-stu-id="d705e-2277">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="d705e-2278">Die folgende Tabelle verdeutlicht, wie die Eingabedaten behandelt werden.</span><span class="sxs-lookup"><span data-stu-id="d705e-2278">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="d705e-2279">Daten</span><span class="sxs-lookup"><span data-stu-id="d705e-2279">Data</span></span>|<span data-ttu-id="d705e-2280">Variablen zugewiesenen Wert</span><span class="sxs-lookup"><span data-stu-id="d705e-2280">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="d705e-2281">Komma oder Leerzeile begrenzen</span><span class="sxs-lookup"><span data-stu-id="d705e-2281">Delimiting comma or blank line</span></span>|<span data-ttu-id="d705e-2282">Empty</span><span class="sxs-lookup"><span data-stu-id="d705e-2282">Empty</span></span>|  
|<span data-ttu-id="d705e-2283">#NULL#</span><span class="sxs-lookup"><span data-stu-id="d705e-2283">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="d705e-2284">#TRUE # "oder" #FALSE #</span><span class="sxs-lookup"><span data-stu-id="d705e-2284">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="d705e-2285">`True` oder `False`</span><span class="sxs-lookup"><span data-stu-id="d705e-2285">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="d705e-2286">Das Datum und/oder eine Uhrzeit, die durch den Ausdruck dargestellt wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-2286">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="d705e-2287">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="d705e-2287">#ERROR `errornumber`#</span></span>|<span data-ttu-id="d705e-2288">`errornumber` (Variable ist ein Objekt, das als Fehler gekennzeichnet)</span><span class="sxs-lookup"><span data-stu-id="d705e-2288">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="d705e-2289">Wenn das Ende der Datei wird erreicht, während Sie eines Datenelements, die Eingabe wird beendet und ein Fehler auftritt.</span><span class="sxs-lookup"><span data-stu-id="d705e-2289">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d705e-2290">Die `Input` Funktion ist nicht lokalisiert.</span><span class="sxs-lookup"><span data-stu-id="d705e-2290">The `Input` function is not localized.</span></span> <span data-ttu-id="d705e-2291">Z. B. wenn eingegebene 3,14159, in der deutschen Version wird nur 3 zurückgegeben, da das Komma als Trennzeichen Variablen statt als Dezimaltrennzeichen behandelt wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-2291">For example, in the German version, if you input 3,14159, it returns only 3, since the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="d705e-2292">Lesen aus einer Datei mithilfe der `Input` -Funktion erfordert `Read` aus Zugriff auf die `FileIOPermissionAccess` Enumeration.</span><span class="sxs-lookup"><span data-stu-id="d705e-2292">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="d705e-2293">Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="d705e-2293">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d705e-2294">Dieses Beispiel verwendet die `Input` Funktion zum Lesen von Daten aus einer Datei in zwei Variablen.</span><span class="sxs-lookup"><span data-stu-id="d705e-2294">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="d705e-2295">In diesem Beispiel wird vorausgesetzt, dass `TestFile` ist eine Datei, die mehrere Zeilen mit Daten, die Sie mithilfe von geschrieben hat die `Write` -Funktion, jede Zeile mit einer Zeichenfolge in Anführungszeichen und eine Zahl, die durch Kommas getrennt ein, z. B.: ("Hello", 234).</span><span class="sxs-lookup"><span data-stu-id="d705e-2295">This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="d705e-2296">Dateimodus ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="d705e-2296">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref long Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int64&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, long % Value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="d705e-2297">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-2297">Required.</span></span> <span data-ttu-id="d705e-2298">Eine beliebige gültige Dateinummer.</span><span class="sxs-lookup"><span data-stu-id="d705e-2298">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="d705e-2299">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-2299">Required.</span></span> <span data-ttu-id="d705e-2300">Eine Variable, der die aus der Datei gelesenen Werte zugewiesen werden, kann kein Array und keine Objektvariable sein.</span><span class="sxs-lookup"><span data-stu-id="d705e-2300">Variable that is assigned the values read from the file—cannot be an array or object variable.</span></span></param>
        <summary><span data-ttu-id="d705e-2301">Liest Daten aus einer geöffneten sequenziellen Datei und weist diese Variablen zu.</span><span class="sxs-lookup"><span data-stu-id="d705e-2301">Reads data from an open sequential file and assigns the data to variables.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d705e-2302">Die `Input` Funktion wird für Abwärtskompatibilität angeboten und die Leistung beeinträchtigen.</span><span class="sxs-lookup"><span data-stu-id="d705e-2302">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="d705e-2303">Für nicht-Legacyanwendungen der `My.Computer.FileSystem` Objekt bietet eine bessere Leistung.</span><span class="sxs-lookup"><span data-stu-id="d705e-2303">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="d705e-2304">Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="d705e-2304">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="d705e-2305">Datenlesevorgänge mit `Input` in der Regel in eine Datei geschrieben wird, mithilfe von `Write`.</span><span class="sxs-lookup"><span data-stu-id="d705e-2305">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="d705e-2306">Verwenden Sie diese Funktion nur mit geöffneten Dateien `Input` oder `Binary` Modus.</span><span class="sxs-lookup"><span data-stu-id="d705e-2306">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="d705e-2307">Beim Lesen aus Dateien nicht Beurteilen der Inhalt der Datei anhand der Dateinamenerweiterung.</span><span class="sxs-lookup"><span data-stu-id="d705e-2307">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="d705e-2308">Eine Datei mit dem Namen "Form1.vb" möglicherweise z. B. keine Visual Basic 2005-Quelldatei.</span><span class="sxs-lookup"><span data-stu-id="d705e-2308">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="d705e-2309">Beim Lesen standard Zeichenfolgen- oder numerische Daten ohne Änderung Variablen zugewiesen werden.</span><span class="sxs-lookup"><span data-stu-id="d705e-2309">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="d705e-2310">Die folgende Tabelle verdeutlicht, wie die Eingabedaten behandelt werden.</span><span class="sxs-lookup"><span data-stu-id="d705e-2310">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="d705e-2311">Daten</span><span class="sxs-lookup"><span data-stu-id="d705e-2311">Data</span></span>|<span data-ttu-id="d705e-2312">Variablen zugewiesenen Wert</span><span class="sxs-lookup"><span data-stu-id="d705e-2312">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="d705e-2313">Komma oder Leerzeile begrenzen</span><span class="sxs-lookup"><span data-stu-id="d705e-2313">Delimiting comma or blank line</span></span>|<span data-ttu-id="d705e-2314">Empty</span><span class="sxs-lookup"><span data-stu-id="d705e-2314">Empty</span></span>|  
|<span data-ttu-id="d705e-2315">#NULL#</span><span class="sxs-lookup"><span data-stu-id="d705e-2315">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="d705e-2316">#TRUE # "oder" #FALSE #</span><span class="sxs-lookup"><span data-stu-id="d705e-2316">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="d705e-2317">`True` oder `False`</span><span class="sxs-lookup"><span data-stu-id="d705e-2317">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="d705e-2318">Das Datum und/oder eine Uhrzeit, die durch den Ausdruck dargestellt wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-2318">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="d705e-2319">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="d705e-2319">#ERROR `errornumber`#</span></span>|<span data-ttu-id="d705e-2320">`errornumber` (Variable ist ein Objekt, das als Fehler gekennzeichnet)</span><span class="sxs-lookup"><span data-stu-id="d705e-2320">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="d705e-2321">Wenn das Ende der Datei wird erreicht, während Sie eines Datenelements, die Eingabe wird beendet und ein Fehler auftritt.</span><span class="sxs-lookup"><span data-stu-id="d705e-2321">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d705e-2322">Die `Input` Funktion ist nicht lokalisiert.</span><span class="sxs-lookup"><span data-stu-id="d705e-2322">The `Input` function is not localized.</span></span> <span data-ttu-id="d705e-2323">Z. B. wenn eingegebene 3,14159, in der deutschen Version wird nur 3 zurückgegeben, da das Komma als Trennzeichen Variablen statt als Dezimaltrennzeichen behandelt wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-2323">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="d705e-2324">Lesen aus einer Datei mithilfe der `Input` -Funktion erfordert `Read` aus Zugriff auf die `FileIOPermissionAccess` Enumeration.</span><span class="sxs-lookup"><span data-stu-id="d705e-2324">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="d705e-2325">Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="d705e-2325">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d705e-2326">Dieses Beispiel verwendet die `Input` Funktion zum Lesen von Daten aus einer Datei in zwei Variablen.</span><span class="sxs-lookup"><span data-stu-id="d705e-2326">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="d705e-2327">In diesem Beispiel wird vorausgesetzt, dass `TestFile` ist eine Datei, die mehrere Zeilen mit Daten, die Sie mithilfe von geschrieben hat die `Write` -Funktion, jede Zeile mit einer Zeichenfolge in Anführungszeichen und eine Zahl, die durch Kommas getrennt ein, z. B.: ("Hello", 234).</span><span class="sxs-lookup"><span data-stu-id="d705e-2327">This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="d705e-2328">Dateimodus ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="d705e-2328">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref object Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, object&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Object ^ % Value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="d705e-2329">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-2329">Required.</span></span> <span data-ttu-id="d705e-2330">Eine beliebige gültige Dateinummer.</span><span class="sxs-lookup"><span data-stu-id="d705e-2330">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="d705e-2331">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-2331">Required.</span></span> <span data-ttu-id="d705e-2332">Eine Variable, der die aus der Datei gelesenen Werte zugewiesen werden, kann kein Array und keine Objektvariable sein.</span><span class="sxs-lookup"><span data-stu-id="d705e-2332">Variable that is assigned the values read from the file—cannot be an array or object variable.</span></span></param>
        <summary><span data-ttu-id="d705e-2333">Liest Daten aus einer geöffneten sequenziellen Datei und weist diese Variablen zu.</span><span class="sxs-lookup"><span data-stu-id="d705e-2333">Reads data from an open sequential file and assigns the data to variables.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d705e-2334">Die `Input` Funktion wird für Abwärtskompatibilität angeboten und die Leistung beeinträchtigen.</span><span class="sxs-lookup"><span data-stu-id="d705e-2334">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="d705e-2335">Für nicht-Legacyanwendungen der `My.Computer.FileSystem` Objekt bietet eine bessere Leistung.</span><span class="sxs-lookup"><span data-stu-id="d705e-2335">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="d705e-2336">Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="d705e-2336">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="d705e-2337">Datenlesevorgänge mit `Input` in der Regel in eine Datei geschrieben wird, mithilfe von `Write`.</span><span class="sxs-lookup"><span data-stu-id="d705e-2337">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="d705e-2338">Verwenden Sie diese Funktion nur mit geöffneten Dateien `Input` oder `Binary` Modus.</span><span class="sxs-lookup"><span data-stu-id="d705e-2338">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="d705e-2339">Beim Lesen aus Dateien nicht Beurteilen der Inhalt der Datei anhand der Dateinamenerweiterung.</span><span class="sxs-lookup"><span data-stu-id="d705e-2339">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="d705e-2340">Eine Datei mit dem Namen "Form1.vb" möglicherweise z. B. keine Visual Basic 2005-Quelldatei.</span><span class="sxs-lookup"><span data-stu-id="d705e-2340">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="d705e-2341">Beim Lesen standard Zeichenfolgen- oder numerische Daten ohne Änderung Variablen zugewiesen werden.</span><span class="sxs-lookup"><span data-stu-id="d705e-2341">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="d705e-2342">Die folgende Tabelle verdeutlicht, wie die Eingabedaten behandelt werden.</span><span class="sxs-lookup"><span data-stu-id="d705e-2342">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="d705e-2343">Daten</span><span class="sxs-lookup"><span data-stu-id="d705e-2343">Data</span></span>|<span data-ttu-id="d705e-2344">Variablen zugewiesenen Wert</span><span class="sxs-lookup"><span data-stu-id="d705e-2344">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="d705e-2345">Komma oder Leerzeile begrenzen</span><span class="sxs-lookup"><span data-stu-id="d705e-2345">Delimiting comma or blank line</span></span>|<span data-ttu-id="d705e-2346">Empty</span><span class="sxs-lookup"><span data-stu-id="d705e-2346">Empty</span></span>|  
|<span data-ttu-id="d705e-2347">#NULL#</span><span class="sxs-lookup"><span data-stu-id="d705e-2347">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="d705e-2348">#TRUE # "oder" #FALSE #</span><span class="sxs-lookup"><span data-stu-id="d705e-2348">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="d705e-2349">`True` oder `False`</span><span class="sxs-lookup"><span data-stu-id="d705e-2349">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="d705e-2350">Das Datum und/oder eine Uhrzeit, die durch den Ausdruck dargestellt wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-2350">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="d705e-2351">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="d705e-2351">#ERROR `errornumber`#</span></span>|<span data-ttu-id="d705e-2352">`errornumber` (Variable ist ein Objekt, das als Fehler gekennzeichnet)</span><span class="sxs-lookup"><span data-stu-id="d705e-2352">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="d705e-2353">Wenn das Ende der Datei wird erreicht, während Sie eines Datenelements, die Eingabe wird beendet und ein Fehler auftritt.</span><span class="sxs-lookup"><span data-stu-id="d705e-2353">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d705e-2354">Die `Input` Funktion ist nicht lokalisiert.</span><span class="sxs-lookup"><span data-stu-id="d705e-2354">The `Input` function is not localized.</span></span> <span data-ttu-id="d705e-2355">Z. B. wenn eingegebene 3,14159, in der deutschen Version wird nur 3 zurückgegeben, da das Komma als Trennzeichen Variablen statt als Dezimaltrennzeichen behandelt wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-2355">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="d705e-2356">Lesen aus einer Datei mithilfe der `Input` -Funktion erfordert `Read` aus Zugriff auf die `FileIOPermissionAccess` Enumeration.</span><span class="sxs-lookup"><span data-stu-id="d705e-2356">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="d705e-2357">Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="d705e-2357">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d705e-2358">Dieses Beispiel verwendet die `Input` Funktion zum Lesen von Daten aus einer Datei in zwei Variablen.</span><span class="sxs-lookup"><span data-stu-id="d705e-2358">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="d705e-2359">In diesem Beispiel wird vorausgesetzt, dass `TestFile` ist eine Datei, die mehrere Zeilen mit Daten, die Sie mithilfe von geschrieben hat die `Write` -Funktion, jede Zeile mit einer Zeichenfolge in Anführungszeichen und eine Zahl, die durch Kommas getrennt ein, z. B.: ("Hello", 234).</span><span class="sxs-lookup"><span data-stu-id="d705e-2359">This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="d705e-2360">Dateimodus ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="d705e-2360">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref float Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, float32&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, float % Value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="d705e-2361">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-2361">Required.</span></span> <span data-ttu-id="d705e-2362">Eine beliebige gültige Dateinummer.</span><span class="sxs-lookup"><span data-stu-id="d705e-2362">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="d705e-2363">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-2363">Required.</span></span> <span data-ttu-id="d705e-2364">Eine Variable, der die aus der Datei gelesenen Werte zugewiesen werden, kann kein Array und keine Objektvariable sein.</span><span class="sxs-lookup"><span data-stu-id="d705e-2364">Variable that is assigned the values read from the file—cannot be an array or object variable.</span></span></param>
        <summary><span data-ttu-id="d705e-2365">Liest Daten aus einer geöffneten sequenziellen Datei und weist diese Variablen zu.</span><span class="sxs-lookup"><span data-stu-id="d705e-2365">Reads data from an open sequential file and assigns the data to variables.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d705e-2366">Die `Input` Funktion wird für Abwärtskompatibilität angeboten und die Leistung beeinträchtigen.</span><span class="sxs-lookup"><span data-stu-id="d705e-2366">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="d705e-2367">Für nicht-Legacyanwendungen der `My.Computer.FileSystem` Objekt bietet eine bessere Leistung.</span><span class="sxs-lookup"><span data-stu-id="d705e-2367">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="d705e-2368">Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="d705e-2368">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="d705e-2369">Datenlesevorgänge mit `Input` in der Regel in eine Datei geschrieben wird, mithilfe von `Write`.</span><span class="sxs-lookup"><span data-stu-id="d705e-2369">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="d705e-2370">Verwenden Sie diese Funktion nur mit geöffneten Dateien `Input` oder `Binary` Modus.</span><span class="sxs-lookup"><span data-stu-id="d705e-2370">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="d705e-2371">Beim Lesen aus Dateien nicht Beurteilen der Inhalt der Datei anhand der Dateinamenerweiterung.</span><span class="sxs-lookup"><span data-stu-id="d705e-2371">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="d705e-2372">Eine Datei mit dem Namen "Form1.vb" möglicherweise z. B. keine Visual Basic 2005-Quelldatei.</span><span class="sxs-lookup"><span data-stu-id="d705e-2372">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="d705e-2373">Beim Lesen standard Zeichenfolgen- oder numerische Daten ohne Änderung Variablen zugewiesen werden.</span><span class="sxs-lookup"><span data-stu-id="d705e-2373">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="d705e-2374">Die folgende Tabelle verdeutlicht, wie die Eingabedaten behandelt werden.</span><span class="sxs-lookup"><span data-stu-id="d705e-2374">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="d705e-2375">Daten</span><span class="sxs-lookup"><span data-stu-id="d705e-2375">Data</span></span>|<span data-ttu-id="d705e-2376">Variablen zugewiesenen Wert</span><span class="sxs-lookup"><span data-stu-id="d705e-2376">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="d705e-2377">Komma oder Leerzeile begrenzen</span><span class="sxs-lookup"><span data-stu-id="d705e-2377">Delimiting comma or blank line</span></span>|<span data-ttu-id="d705e-2378">Empty</span><span class="sxs-lookup"><span data-stu-id="d705e-2378">Empty</span></span>|  
|<span data-ttu-id="d705e-2379">#NULL#</span><span class="sxs-lookup"><span data-stu-id="d705e-2379">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="d705e-2380">#TRUE # "oder" #FALSE #</span><span class="sxs-lookup"><span data-stu-id="d705e-2380">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="d705e-2381">`True` oder `False`</span><span class="sxs-lookup"><span data-stu-id="d705e-2381">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="d705e-2382">Das Datum und/oder eine Uhrzeit, die durch den Ausdruck dargestellt wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-2382">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="d705e-2383">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="d705e-2383">#ERROR `errornumber`#</span></span>|<span data-ttu-id="d705e-2384">`errornumber` (Variable ist ein Objekt, das als Fehler gekennzeichnet)</span><span class="sxs-lookup"><span data-stu-id="d705e-2384">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="d705e-2385">Wenn das Ende der Datei wird erreicht, während Sie eines Datenelements, die Eingabe wird beendet und ein Fehler auftritt.</span><span class="sxs-lookup"><span data-stu-id="d705e-2385">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d705e-2386">Die `Input` Funktion ist nicht lokalisiert.</span><span class="sxs-lookup"><span data-stu-id="d705e-2386">The `Input` function is not localized.</span></span> <span data-ttu-id="d705e-2387">Z. B. wenn eingegebene 3,14159, in der deutschen Version wird nur 3 zurückgegeben, da das Komma als Trennzeichen Variablen statt als Dezimaltrennzeichen behandelt wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-2387">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="d705e-2388">Lesen aus einer Datei mithilfe der `Input` -Funktion erfordert `Read` aus Zugriff auf die `FileIOPermissionAccess` Enumeration.</span><span class="sxs-lookup"><span data-stu-id="d705e-2388">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="d705e-2389">Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="d705e-2389">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d705e-2390">Dieses Beispiel verwendet die `Input` Funktion zum Lesen von Daten aus einer Datei in zwei Variablen.</span><span class="sxs-lookup"><span data-stu-id="d705e-2390">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="d705e-2391">In diesem Beispiel wird vorausgesetzt, dass `TestFile` ist eine Datei, die mehrere Zeilen mit Daten, die Sie mithilfe von geschrieben hat die `Write` -Funktion, jede Zeile mit einer Zeichenfolge in Anführungszeichen und eine Zahl, die durch Kommas getrennt ein, z. B.: ("Hello", 234).</span><span class="sxs-lookup"><span data-stu-id="d705e-2391">This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="d705e-2392">Dateimodus ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="d705e-2392">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref string Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, string&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::String ^ % Value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="d705e-2393">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-2393">Required.</span></span> <span data-ttu-id="d705e-2394">Eine beliebige gültige Dateinummer.</span><span class="sxs-lookup"><span data-stu-id="d705e-2394">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="d705e-2395">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-2395">Required.</span></span> <span data-ttu-id="d705e-2396">Eine Variable, der die aus der Datei gelesenen Werte zugewiesen werden, kann kein Array und keine Objektvariable sein.</span><span class="sxs-lookup"><span data-stu-id="d705e-2396">Variable that is assigned the values read from the file—cannot be an array or object variable.</span></span></param>
        <summary><span data-ttu-id="d705e-2397">Liest Daten aus einer geöffneten sequenziellen Datei und weist diese Variablen zu.</span><span class="sxs-lookup"><span data-stu-id="d705e-2397">Reads data from an open sequential file and assigns the data to variables.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d705e-2398">Die `Input` Funktion wird für Abwärtskompatibilität angeboten und die Leistung beeinträchtigen.</span><span class="sxs-lookup"><span data-stu-id="d705e-2398">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="d705e-2399">Für nicht-Legacyanwendungen der `My.Computer.FileSystem` Objekt bietet eine bessere Leistung.</span><span class="sxs-lookup"><span data-stu-id="d705e-2399">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="d705e-2400">Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="d705e-2400">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="d705e-2401">Datenlesevorgänge mit `Input` in der Regel in eine Datei geschrieben wird, mithilfe von `Write`.</span><span class="sxs-lookup"><span data-stu-id="d705e-2401">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="d705e-2402">Verwenden Sie diese Funktion nur mit geöffneten Dateien `Input` oder `Binary` Modus.</span><span class="sxs-lookup"><span data-stu-id="d705e-2402">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="d705e-2403">Beim Lesen aus Dateien nicht Beurteilen der Inhalt der Datei anhand der Dateinamenerweiterung.</span><span class="sxs-lookup"><span data-stu-id="d705e-2403">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="d705e-2404">Eine Datei mit dem Namen "Form1.vb" möglicherweise z. B. keine Visual Basic 2005-Quelldatei.</span><span class="sxs-lookup"><span data-stu-id="d705e-2404">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="d705e-2405">Beim Lesen standard Zeichenfolgen- oder numerische Daten ohne Änderung Variablen zugewiesen werden.</span><span class="sxs-lookup"><span data-stu-id="d705e-2405">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="d705e-2406">Die folgende Tabelle verdeutlicht, wie die Eingabedaten behandelt werden.</span><span class="sxs-lookup"><span data-stu-id="d705e-2406">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="d705e-2407">Daten</span><span class="sxs-lookup"><span data-stu-id="d705e-2407">Data</span></span>|<span data-ttu-id="d705e-2408">Variablen zugewiesenen Wert</span><span class="sxs-lookup"><span data-stu-id="d705e-2408">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="d705e-2409">Komma oder Leerzeile begrenzen</span><span class="sxs-lookup"><span data-stu-id="d705e-2409">Delimiting comma or blank line</span></span>|<span data-ttu-id="d705e-2410">Empty</span><span class="sxs-lookup"><span data-stu-id="d705e-2410">Empty</span></span>|  
|<span data-ttu-id="d705e-2411">#NULL#</span><span class="sxs-lookup"><span data-stu-id="d705e-2411">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="d705e-2412">#TRUE # "oder" #FALSE #</span><span class="sxs-lookup"><span data-stu-id="d705e-2412">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="d705e-2413">`True` oder `False`</span><span class="sxs-lookup"><span data-stu-id="d705e-2413">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="d705e-2414">Das Datum und/oder eine Uhrzeit, die durch den Ausdruck dargestellt wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-2414">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="d705e-2415">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="d705e-2415">#ERROR `errornumber`#</span></span>|<span data-ttu-id="d705e-2416">`errornumber` (Variable ist ein Objekt, das als Fehler gekennzeichnet)</span><span class="sxs-lookup"><span data-stu-id="d705e-2416">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="d705e-2417">Wenn das Ende der Datei wird erreicht, während Sie eines Datenelements, die Eingabe wird beendet und ein Fehler auftritt.</span><span class="sxs-lookup"><span data-stu-id="d705e-2417">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d705e-2418">Die `Input` Funktion ist nicht lokalisiert.</span><span class="sxs-lookup"><span data-stu-id="d705e-2418">The `Input` function is not localized.</span></span> <span data-ttu-id="d705e-2419">Z. B. wenn eingegebene 3,14159, in der deutschen Version wird nur 3 zurückgegeben, da das Komma als Trennzeichen Variablen statt als Dezimaltrennzeichen behandelt wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-2419">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="d705e-2420">Lesen aus einer Datei mithilfe der `Input` -Funktion erfordert `Read` aus Zugriff auf die `FileIOPermissionAccess` Enumeration.</span><span class="sxs-lookup"><span data-stu-id="d705e-2420">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="d705e-2421">Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="d705e-2421">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d705e-2422">Dieses Beispiel verwendet die `Input` Funktion zum Lesen von Daten aus einer Datei in zwei Variablen.</span><span class="sxs-lookup"><span data-stu-id="d705e-2422">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="d705e-2423">In diesem Beispiel wird vorausgesetzt, dass `TestFile` ist eine Datei, die mehrere Zeilen mit Daten, die Sie mithilfe von geschrieben hat die `Write` -Funktion, jede Zeile mit einer Zeichenfolge in Anführungszeichen und eine Zahl, die durch Kommas getrennt ein, z. B.: ("Hello", 234).</span><span class="sxs-lookup"><span data-stu-id="d705e-2423">This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="d705e-2424">Dateimodus ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="d705e-2424">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="InputString">
      <MemberSignature Language="C#" Value="public static string InputString (int FileNumber, int CharCount);" />
      <MemberSignature Language="ILAsm" Value=".method public static string InputString(int32 FileNumber, int32 CharCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function InputString (FileNumber As Integer, CharCount As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ InputString(int FileNumber, int CharCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="CharCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="d705e-2425">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-2425">Required.</span></span> <span data-ttu-id="d705e-2426">Eine beliebige gültige Dateinummer.</span><span class="sxs-lookup"><span data-stu-id="d705e-2426">Any valid file number.</span></span></param>
        <param name="CharCount"><span data-ttu-id="d705e-2427">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-2427">Required.</span></span> <span data-ttu-id="d705e-2428">Ein beliebiger gültiger numerischer Ausdruck, der die Anzahl der zu lesenden Zeichen angibt.</span><span class="sxs-lookup"><span data-stu-id="d705e-2428">Any valid numeric expression specifying the number of characters to read.</span></span></param>
        <summary><span data-ttu-id="d705e-2429">Gibt einen <see langword="String" />-Wert zurück, der Zeichen aus einer im Modus <see langword="Input" /> oder <see langword="Binary" /> geöffneten Datei enthält.</span><span class="sxs-lookup"><span data-stu-id="d705e-2429">Returns <see langword="String" /> value that contains characters from a file opened in <see langword="Input" /> or <see langword="Binary" /> mode.</span></span> <span data-ttu-id="d705e-2430">Das <see langword="My" />-Feature bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="InputString" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-2430">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="InputString" />.</span></span> <span data-ttu-id="d705e-2431">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-2431">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <returns><span data-ttu-id="d705e-2432">Gibt einen <see langword="String" />-Wert zurück, der Zeichen aus einer im Modus <see langword="Input" /> oder <see langword="Binary" /> geöffneten Datei enthält.</span><span class="sxs-lookup"><span data-stu-id="d705e-2432">Returns <see langword="String" /> value that contains characters from a file opened in <see langword="Input" /> or <see langword="Binary" /> mode.</span></span> <span data-ttu-id="d705e-2433">Das <see langword="My" />-Feature bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="InputString" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-2433">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="InputString" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d705e-2434">Die `InputString` Funktion wird für Abwärtskompatibilität angeboten und die Leistung beeinträchtigen.</span><span class="sxs-lookup"><span data-stu-id="d705e-2434">The `InputString` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="d705e-2435">Für nicht-Legacyanwendungen der `My.Computer.FileSystem` Objekt bietet eine bessere Leistung.</span><span class="sxs-lookup"><span data-stu-id="d705e-2435">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="d705e-2436">Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="d705e-2436">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="d705e-2437">Mit gelesenen Daten der `InputString` Funktion ist in der Regel in eine Datei geschrieben, mit `Print` oder `FilePut`.</span><span class="sxs-lookup"><span data-stu-id="d705e-2437">Data read with the `InputString` function is usually written to a file by using `Print` or `FilePut`.</span></span> <span data-ttu-id="d705e-2438">Verwenden Sie diese Funktion nur mit geöffneten Dateien `Input` oder `Binary` Modus.</span><span class="sxs-lookup"><span data-stu-id="d705e-2438">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
 <span data-ttu-id="d705e-2439">Im Gegensatz zu den `Input` -Funktion, die `InputString` Funktion gibt alle Zeichen gelesen.</span><span class="sxs-lookup"><span data-stu-id="d705e-2439">Unlike the `Input` function, the `InputString` function returns all the characters it reads.</span></span> <span data-ttu-id="d705e-2440">Dies schließt Kommas, Wagenrückläufen, Zeilenvorschüben, Anführungszeichen und führende Leerzeichen.</span><span class="sxs-lookup"><span data-stu-id="d705e-2440">This includes commas, carriage returns, line feeds, quotation marks, and leading spaces.</span></span>  
  
 <span data-ttu-id="d705e-2441">Dateien für geöffnet `Binary` zugreifen, beim Lesen der Datei mithilfe der `InputString` Funktion bis `EOF` gibt `True` wird ein Fehler generiert.</span><span class="sxs-lookup"><span data-stu-id="d705e-2441">With files opened for `Binary` access, an attempt to read through the file by using the `InputString` function until `EOF` returns `True` generates an error.</span></span> <span data-ttu-id="d705e-2442">Verwenden Sie die `LOF` und `Loc` anstelle von Funktionen `EOF` beim Lesen von Binärdateien mit `InputString`, oder verwenden Sie `FileGet` bei Verwendung der `EOF` Funktion.</span><span class="sxs-lookup"><span data-stu-id="d705e-2442">Use the `LOF` and `Loc` functions instead of `EOF` when you read binary files by using `InputString`, or use `FileGet` when you use the `EOF` function.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d705e-2443">Beim Lesen aus Dateien, nehmen Sie keine sicherheitsrelevanten Aspekten der Inhalt der Datei anhand der Dateinamenerweiterung.</span><span class="sxs-lookup"><span data-stu-id="d705e-2443">When reading from files, do not make security decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="d705e-2444">Eine Datei namens "Form1.vb" möglicherweise z. B. keine Visual Basic-Quelldatei.</span><span class="sxs-lookup"><span data-stu-id="d705e-2444">For example, a file named Form1.vb may not be a Visual Basic source file.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d705e-2445">Dieses Beispiel verwendet die `InputString` Funktion, um Zeichen zu einem Zeitpunkt aus einer Datei gelesen und zum Drucken der `Output` Fenster.</span><span class="sxs-lookup"><span data-stu-id="d705e-2445">This example uses the `InputString` function to read one character at a time from a file and print it to the `Output` window.</span></span> <span data-ttu-id="d705e-2446">In diesem Beispiel wird vorausgesetzt, dass `MyFile` ist eine Textdatei, die mehrere mit Beispieldaten Zeilen.</span><span class="sxs-lookup"><span data-stu-id="d705e-2446">This example assumes that `MyFile` is a text file that has several lines of sample data.</span></span>  
  
 [!code-vb[VbVbalrCatRef#33](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#33)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="d705e-2447"><paramref name="FileNumber" /> existiert nicht.</span><span class="sxs-lookup"><span data-stu-id="d705e-2447"><paramref name="FileNumber" /> does not exist.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="d705e-2448"><paramref name="CharCount" /> &lt; 0 oder &gt; 214.</span><span class="sxs-lookup"><span data-stu-id="d705e-2448"><paramref name="CharCount" /> &lt; 0 or &gt; 214.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
      </Docs>
    </Member>
    <Member MemberName="Kill">
      <MemberSignature Language="C#" Value="public static void Kill (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Kill(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Kill (PathName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Kill(System::String ^ PathName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName"><span data-ttu-id="d705e-2449">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-2449">Required.</span></span> <span data-ttu-id="d705e-2450">Ein <see langword="String" />-Ausdruck, der einen oder mehrere Namen von zu löschenden Dateien angibt.</span><span class="sxs-lookup"><span data-stu-id="d705e-2450"><see langword="String" /> expression that specifies one or more file names to be deleted.</span></span> <span data-ttu-id="d705e-2451"><c>PathName</c> kann auch das Verzeichnis oder den Ordner sowie das Laufwerk beinhalten.</span><span class="sxs-lookup"><span data-stu-id="d705e-2451"><c>PathName</c> can include the directory or folder, and the drive.</span></span></param>
        <summary><span data-ttu-id="d705e-2452">Löscht Dateien von einem Datenträger.</span><span class="sxs-lookup"><span data-stu-id="d705e-2452">Deletes files from a disk.</span></span> <span data-ttu-id="d705e-2453">Das <see langword="My" />-Feature bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="Kill" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-2453">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Kill" />.</span></span> <span data-ttu-id="d705e-2454">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-2454">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> .</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d705e-2455">`Kill` unterstützt die Verwendung von mehreren Zeichen (`*`) und ein einzelnes Zeichen (`?`) mit Platzhaltern für mehrere Dateien anzugeben.</span><span class="sxs-lookup"><span data-stu-id="d705e-2455">`Kill` supports the use of multiple-character (`*`) and single-character (`?`) wildcards to specify multiple files.</span></span>  
  
 <span data-ttu-id="d705e-2456">**Sicherheitshinweis** zum Ausführen der `Kill` -Funktion erfordert `Read` und `PathDiscovery` des flags <xref:System.Security.Permissions.FileIOPermission> , die den Ausführungscode gewährt werden.</span><span class="sxs-lookup"><span data-stu-id="d705e-2456">**Security Note** In order to execute, the `Kill` function requires `Read` and `PathDiscovery` flags of <xref:System.Security.Permissions.FileIOPermission> to be granted to the executing code.</span></span> <span data-ttu-id="d705e-2457">Weitere Informationen finden Sie unter <xref:System.Security.SecurityException> [Codezugriffsberechtigungen](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)</span><span class="sxs-lookup"><span data-stu-id="d705e-2457">For more information, see <xref:System.Security.SecurityException>[Code Access Permissions](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d705e-2458">Dieses Beispiel verwendet die `Kill` Funktion, um eine Datei von einem Datenträger zu löschen.</span><span class="sxs-lookup"><span data-stu-id="d705e-2458">This example uses the `Kill` function to delete a file from a disk.</span></span>  
  
 [!code-vb[VbVbalrCatRef#60](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#60)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="d705e-2459">Zieldatei(en) geöffnet.</span><span class="sxs-lookup"><span data-stu-id="d705e-2459">Target file(s) open.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="d705e-2460">Zieldatei(en) nicht gefunden.</span><span class="sxs-lookup"><span data-stu-id="d705e-2460">Target file(s) not found.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="d705e-2461">Berechtigung verweigert.</span><span class="sxs-lookup"><span data-stu-id="d705e-2461">Permission denied.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <Member MemberName="LineInput">
      <MemberSignature Language="C#" Value="public static string LineInput (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static string LineInput(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.LineInput(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LineInput (FileNumber As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ LineInput(int FileNumber);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="d705e-2462">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-2462">Required.</span></span> <span data-ttu-id="d705e-2463">Eine beliebige gültige Dateinummer.</span><span class="sxs-lookup"><span data-stu-id="d705e-2463">Any valid file number.</span></span></param>
        <summary><span data-ttu-id="d705e-2464">Liest eine einzelne Zeile aus einer offenen sequenziellen Datei und weist diese einer <see langword="String" />-Variablen zu.</span><span class="sxs-lookup"><span data-stu-id="d705e-2464">Reads a single line from an open sequential file and assigns it to a <see langword="String" /> variable.</span></span></summary>
        <returns><span data-ttu-id="d705e-2465">Liest eine einzelne Zeile aus einer offenen sequenziellen Datei und weist diese einer <see langword="String" />-Variablen zu.</span><span class="sxs-lookup"><span data-stu-id="d705e-2465">Reads a single line from an open sequential file and assigns it to a <see langword="String" /> variable.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d705e-2466">Die `LineInput` Funktion wird für Abwärtskompatibilität angeboten und die Leistung beeinträchtigen.</span><span class="sxs-lookup"><span data-stu-id="d705e-2466">The `LineInput` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="d705e-2467">Für nicht-Legacyanwendungen der `My.Computer.FileSystem` Objekt bietet eine bessere Leistung.</span><span class="sxs-lookup"><span data-stu-id="d705e-2467">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="d705e-2468">Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="d705e-2468">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="d705e-2469">Datenlesevorgänge mit `LineInput` in der Regel in eine Datei geschrieben wird, mithilfe von `Print`.</span><span class="sxs-lookup"><span data-stu-id="d705e-2469">Data read with `LineInput` is usually written to a file by using `Print`.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="d705e-2470">Beim Lesen aus Dateien nicht Beurteilen der Inhalt einer Datei, die anhand der Dateinamenerweiterung.</span><span class="sxs-lookup"><span data-stu-id="d705e-2470">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="d705e-2471">Eine Datei mit dem Namen "Form1.vb" möglicherweise z. B. nicht über ein Visual Basic-Quelldatei.</span><span class="sxs-lookup"><span data-stu-id="d705e-2471">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
 <span data-ttu-id="d705e-2472">Die `LineInput` Funktion liest Zeichen aus einer Datei eine schrittweise, bis er erkennt, dass einen Wagenrücklauf (`Chr(13)`) oder Wagenrücklauf/Zeilenvorschub (`Chr(13) + Chr(10)`) Sequenz.</span><span class="sxs-lookup"><span data-stu-id="d705e-2472">The `LineInput` function reads from a file one character at a time until it encounters a carriage return (`Chr(13)`) or carriage return/line feed (`Chr(13) + Chr(10)`) sequence.</span></span> <span data-ttu-id="d705e-2473">Carriage Return/Line feed Sequenzen werden übersprungen und nicht auf die Zeichenfolge angefügt.</span><span class="sxs-lookup"><span data-stu-id="d705e-2473">Carriage return/line feed sequences are skipped instead of appended to the character string.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="d705e-2474">Lesen aus einer Datei mithilfe der `LineInput` -Funktion erfordert `Read` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.</span><span class="sxs-lookup"><span data-stu-id="d705e-2474">Reading from a file by using the `LineInput` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d705e-2475">Dieses Beispiel verwendet die `LineInput` Funktion, um eine Zeile aus einer sequenziellen Datei gelesen und einer Variablen zuweisen.</span><span class="sxs-lookup"><span data-stu-id="d705e-2475">This example uses the `LineInput` function to read a line from a sequential file and assign it to a variable.</span></span> <span data-ttu-id="d705e-2476">In diesem Beispiel wird vorausgesetzt, dass `TestFile` ist eine Textdatei, die mehrere mit Beispieldaten Zeilen.</span><span class="sxs-lookup"><span data-stu-id="d705e-2476">This example assumes that `TestFile` is a text file that has several lines of sample data.</span></span>  
  
 [!code-vb[VbVbalrCatRef#19](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.EndOfStreamException"><span data-ttu-id="d705e-2477">Dateiende erreicht.</span><span class="sxs-lookup"><span data-stu-id="d705e-2477">End of file reached.</span></span></exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="d705e-2478"><paramref name="FileNumber" /> existiert nicht.</span><span class="sxs-lookup"><span data-stu-id="d705e-2478"><paramref name="FileNumber" /> does not exist.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.Strings.Chr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.ChrW(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
      </Docs>
    </Member>
    <Member MemberName="Loc">
      <MemberSignature Language="C#" Value="public static long Loc (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 Loc(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Loc (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Loc(int FileNumber);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="d705e-2479">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-2479">Required.</span></span> <span data-ttu-id="d705e-2480">Eine beliebige gültige <see langword="Integer" />-Dateinummer.</span><span class="sxs-lookup"><span data-stu-id="d705e-2480">Any valid <see langword="Integer" /> file number.</span></span></param>
        <summary><span data-ttu-id="d705e-2481">Gibt einen <see langword="Long" />-Wert zurück, der die aktuelle Lese-/Schreibposition in einer offenen Datei angibt.</span><span class="sxs-lookup"><span data-stu-id="d705e-2481">Returns a <see langword="Long" /> value that specifies the current read/write position in an open file.</span></span></summary>
        <returns><span data-ttu-id="d705e-2482">Gibt einen <see langword="Long" />-Wert zurück, der die aktuelle Lese-/Schreibposition in einer offenen Datei angibt.</span><span class="sxs-lookup"><span data-stu-id="d705e-2482">Returns a <see langword="Long" /> value that specifies the current read/write position in an open file.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d705e-2483">Die `Loc` Funktion ist nullbasiert; verwenden, um das erste Byte in einer Datei abrufen, wird 0 zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="d705e-2483">The `Loc` function is zero-based; using it to retrieve the first byte in a file will return 0.</span></span>  
  
 <span data-ttu-id="d705e-2484">Die `Loc` Funktion wird für Abwärtskompatibilität angeboten und die Leistung beeinträchtigen.</span><span class="sxs-lookup"><span data-stu-id="d705e-2484">The `Loc` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="d705e-2485">Für nicht-Legacyanwendungen der `My.Computer.FileSystem` Objekt bietet eine bessere Leistung.</span><span class="sxs-lookup"><span data-stu-id="d705e-2485">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="d705e-2486">Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="d705e-2486">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="d705e-2487">Nachfolgend wird den Rückgabewert für jede Dateizugriffsmodus beschrieben:</span><span class="sxs-lookup"><span data-stu-id="d705e-2487">The following describes the return value for each file access mode:</span></span>  
  
|<span data-ttu-id="d705e-2488">Modus</span><span class="sxs-lookup"><span data-stu-id="d705e-2488">Mode</span></span>|<span data-ttu-id="d705e-2489">Rückgabewert</span><span class="sxs-lookup"><span data-stu-id="d705e-2489">Return value</span></span>|  
|-|-|  
|`Random`|<span data-ttu-id="d705e-2490">Die Nummer des letzten Datensatzes lesen oder in die Datei geschrieben.</span><span class="sxs-lookup"><span data-stu-id="d705e-2490">Number of the last record read from or written to the file.</span></span>|  
|`Sequential`|<span data-ttu-id="d705e-2491">Aktuelle Byteposition in der Datei, geteilt durch 128.</span><span class="sxs-lookup"><span data-stu-id="d705e-2491">Current byte position in the file divided by 128.</span></span> <span data-ttu-id="d705e-2492">Zurückgegebene Informationen werden jedoch von `Loc` für sequenzielle Dateien ist weder verwendet noch benötigt.</span><span class="sxs-lookup"><span data-stu-id="d705e-2492">However, information returned by `Loc` for sequential files is neither used nor required.</span></span>|  
|`Binary`|<span data-ttu-id="d705e-2493">Die Position des letzten Bytes gelesen bzw. geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="d705e-2493">Position of the last byte read or written.</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="d705e-2494">Dieses Beispiel verwendet die `Loc` Funktion, um die aktuelle Lese-/Schreibposition in einer geöffneten Datei zurückzugeben.</span><span class="sxs-lookup"><span data-stu-id="d705e-2494">This example uses the `Loc` function to return the current read/write position in an open file.</span></span> <span data-ttu-id="d705e-2495">In diesem Beispiel wird vorausgesetzt, dass `MyFile` ist eine Textdatei, die mehrere mit Beispieldaten Zeilen.</span><span class="sxs-lookup"><span data-stu-id="d705e-2495">This example assumes that `MyFile` is a text file that has several lines of sample data.</span></span>  
  
 [!code-vb[VbVbalrCatRef#17](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="d705e-2496">Dateimodus ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="d705e-2496">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Lock">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d705e-2497">Steuert den Zugriff durch andere Prozesse auf die gesamte mithilfe der <see langword="Open" />-Funktion geöffnete Datei oder einen Teil davon.</span><span class="sxs-lookup"><span data-stu-id="d705e-2497">Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function.</span></span> <span data-ttu-id="d705e-2498">Das <see langword="My" />-Feature ermöglicht bei Datei-E/A-Vorgängen höhere Produktivität und Leistung als <see langword="Lock" /> und <see langword="Unlock" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-2498">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />.</span></span> <span data-ttu-id="d705e-2499">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-2499">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="d705e-2500">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-2500">Required.</span></span> <span data-ttu-id="d705e-2501">Eine beliebige gültige Dateinummer.</span><span class="sxs-lookup"><span data-stu-id="d705e-2501">Any valid file number.</span></span></param>
        <summary><span data-ttu-id="d705e-2502">Steuert den Zugriff durch andere Prozesse auf die gesamte mithilfe der <see langword="Open" />-Funktion geöffnete Datei oder einen Teil davon.</span><span class="sxs-lookup"><span data-stu-id="d705e-2502">Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function.</span></span> <span data-ttu-id="d705e-2503">Das <see langword="My" />-Feature ermöglicht bei Datei-E/A-Vorgängen höhere Produktivität und Leistung als <see langword="Lock" /> und <see langword="Unlock" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-2503">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />.</span></span> <span data-ttu-id="d705e-2504">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-2504">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d705e-2505">Die `Lock` und `Unlock` Funktionen in Umgebungen verwendet werden, in denen mehrere Prozesse benötigen möglicherweise Zugriff auf die gleiche Datei.</span><span class="sxs-lookup"><span data-stu-id="d705e-2505">The `Lock` and `Unlock` functions are used in environments where several processes might need access to the same file.</span></span>  
  
 <span data-ttu-id="d705e-2506">`Lock` und `Unlock` Funktionen werden immer paarweise verwendet.</span><span class="sxs-lookup"><span data-stu-id="d705e-2506">`Lock` and `Unlock` functions are always used in pairs.</span></span> <span data-ttu-id="d705e-2507">Die Argumente für `Lock` und `Unlock` müssen identisch sein.</span><span class="sxs-lookup"><span data-stu-id="d705e-2507">The arguments to `Lock` and `Unlock` must be identical.</span></span>  
  
 <span data-ttu-id="d705e-2508">Wenn `Record`, oder `FromRecord` und `ToRecord` sind nicht angegeben wird, wird die Sperre für die gesamte Datei sein.</span><span class="sxs-lookup"><span data-stu-id="d705e-2508">If `Record`, or `FromRecord` and `ToRecord` are not supplied, the lock will be for the whole file.</span></span> <span data-ttu-id="d705e-2509">Wenn `Record` allein entspricht der einzelne Datensatz gesperrt/entsperrt werden.</span><span class="sxs-lookup"><span data-stu-id="d705e-2509">If `Record` alone is specified the single record will be locked/unlocked.</span></span>  
  
 <span data-ttu-id="d705e-2510">Wenn die Datei, für die sequenzielle Eingabe oder Ausgabe geöffnet wurde, `Lock` und `Unlock` Auswirkungen auf die gesamte Datei und unabhängig vom angegebenen Bereich `FromRecord` und`ToRecord`.</span><span class="sxs-lookup"><span data-stu-id="d705e-2510">If the file has been opened for sequential input or output, `Lock` and `Unlock` affect the whole file, regardless of the range specified by `FromRecord` and`ToRecord`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d705e-2511">Dieses Beispiel veranschaulicht die Verwendung der `Lock` und `Unlock` Funktionen.</span><span class="sxs-lookup"><span data-stu-id="d705e-2511">This example illustrates the use of the `Lock` and `Unlock` functions.</span></span> <span data-ttu-id="d705e-2512">In diesem Beispiel wird vorausgesetzt, dass `People.txt` ist eine Datei, die Datensätze der Struktur enthält `Person`.</span><span class="sxs-lookup"><span data-stu-id="d705e-2512">This example assumes that `People.txt` is a file that contains records of the structure `Person`.</span></span>  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="d705e-2513">Dateimodus ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="d705e-2513">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber, long Record);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber, int64 Record) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer, Record As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber, long Record);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Record" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="d705e-2514">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-2514">Required.</span></span> <span data-ttu-id="d705e-2515">Eine beliebige gültige Dateinummer.</span><span class="sxs-lookup"><span data-stu-id="d705e-2515">Any valid file number.</span></span></param>
        <param name="Record"><span data-ttu-id="d705e-2516">Dies ist optional.</span><span class="sxs-lookup"><span data-stu-id="d705e-2516">Optional.</span></span> <span data-ttu-id="d705e-2517">Die Nummer des einzigen zu sperrenden oder zu entsperrenden Datensatzes.</span><span class="sxs-lookup"><span data-stu-id="d705e-2517">Number of the only record or byte to lock or unlock</span></span></param>
        <summary><span data-ttu-id="d705e-2518">Steuert den Zugriff durch andere Prozesse auf die gesamte mithilfe der <see langword="Open" />-Funktion geöffnete Datei oder einen Teil davon.</span><span class="sxs-lookup"><span data-stu-id="d705e-2518">Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function.</span></span> <span data-ttu-id="d705e-2519">Das <see langword="My" />-Feature ermöglicht bei Datei-E/A-Vorgängen höhere Produktivität und Leistung als <see langword="Lock" /> und <see langword="Unlock" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-2519">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />.</span></span> <span data-ttu-id="d705e-2520">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-2520">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d705e-2521">Die `Lock` und `Unlock` Funktionen in Umgebungen verwendet werden, in denen mehrere Prozesse benötigen möglicherweise Zugriff auf die gleiche Datei.</span><span class="sxs-lookup"><span data-stu-id="d705e-2521">The `Lock` and `Unlock` functions are used in environments where several processes might need access to the same file.</span></span>  
  
 <span data-ttu-id="d705e-2522">`Lock` und `Unlock` Funktionen werden immer paarweise verwendet.</span><span class="sxs-lookup"><span data-stu-id="d705e-2522">`Lock` and `Unlock` functions are always used in pairs.</span></span> <span data-ttu-id="d705e-2523">Die Argumente für `Lock` und `Unlock` müssen identisch sein.</span><span class="sxs-lookup"><span data-stu-id="d705e-2523">The arguments to `Lock` and `Unlock` must be identical.</span></span>  
  
 <span data-ttu-id="d705e-2524">Wenn `Record`, oder `FromRecord` und `ToRecord` sind nicht angegeben wird, wird die Sperre für die gesamte Datei sein.</span><span class="sxs-lookup"><span data-stu-id="d705e-2524">If `Record`, or `FromRecord` and `ToRecord` are not supplied, the lock will be for the whole file.</span></span> <span data-ttu-id="d705e-2525">Wenn `Record` allein entspricht der einzelne Datensatz gesperrt/entsperrt werden.</span><span class="sxs-lookup"><span data-stu-id="d705e-2525">If `Record` alone is specified the single record will be locked/unlocked.</span></span>  
  
 <span data-ttu-id="d705e-2526">Wenn die Datei, für die sequenzielle Eingabe oder Ausgabe geöffnet wurde, `Lock` und `Unlock` Auswirkungen auf die gesamte Datei und unabhängig vom angegebenen Bereich `FromRecord` und`ToRecord`.</span><span class="sxs-lookup"><span data-stu-id="d705e-2526">If the file has been opened for sequential input or output, `Lock` and `Unlock` affect the whole file, regardless of the range specified by `FromRecord` and`ToRecord`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d705e-2527">Dieses Beispiel veranschaulicht die Verwendung der `Lock` und `Unlock` Funktionen.</span><span class="sxs-lookup"><span data-stu-id="d705e-2527">This example illustrates the use of the `Lock` and `Unlock` functions.</span></span> <span data-ttu-id="d705e-2528">In diesem Beispiel wird vorausgesetzt, dass `People.txt` ist eine Datei, die Datensätze der Struktur enthält `Person`.</span><span class="sxs-lookup"><span data-stu-id="d705e-2528">This example assumes that `People.txt` is a file that contains records of the structure `Person`.</span></span>  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="d705e-2529">Dateimodus ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="d705e-2529">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber, int64 FromRecord, int64 ToRecord) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer, FromRecord As Long, ToRecord As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber, long FromRecord, long ToRecord);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FromRecord" Type="System.Int64" />
        <Parameter Name="ToRecord" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="d705e-2530">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-2530">Required.</span></span> <span data-ttu-id="d705e-2531">Eine beliebige gültige Dateinummer.</span><span class="sxs-lookup"><span data-stu-id="d705e-2531">Any valid file number.</span></span></param>
        <param name="FromRecord"><span data-ttu-id="d705e-2532">Dies ist optional.</span><span class="sxs-lookup"><span data-stu-id="d705e-2532">Optional.</span></span> <span data-ttu-id="d705e-2533">Die Nummer des ersten zu sperrenden oder zu entsperrenden Datensatzes.</span><span class="sxs-lookup"><span data-stu-id="d705e-2533">Number of the first record or byte to lock or unlock.</span></span></param>
        <param name="ToRecord"><span data-ttu-id="d705e-2534">Dies ist optional.</span><span class="sxs-lookup"><span data-stu-id="d705e-2534">Optional.</span></span> <span data-ttu-id="d705e-2535">Die Nummer des letzten zu sperrenden oder zu entsperrenden Datensatzes.</span><span class="sxs-lookup"><span data-stu-id="d705e-2535">Number of the last record or byte to lock or unlock.</span></span></param>
        <summary><span data-ttu-id="d705e-2536">Steuert den Zugriff durch andere Prozesse auf die gesamte mithilfe der <see langword="Open" />-Funktion geöffnete Datei oder einen Teil davon.</span><span class="sxs-lookup"><span data-stu-id="d705e-2536">Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function.</span></span> <span data-ttu-id="d705e-2537">Das <see langword="My" />-Feature ermöglicht bei Datei-E/A-Vorgängen höhere Produktivität und Leistung als <see langword="Lock" /> und <see langword="Unlock" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-2537">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />.</span></span> <span data-ttu-id="d705e-2538">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-2538">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d705e-2539">Die `Lock` und `Unlock` Funktionen in Umgebungen verwendet werden, in denen mehrere Prozesse benötigen möglicherweise Zugriff auf die gleiche Datei.</span><span class="sxs-lookup"><span data-stu-id="d705e-2539">The `Lock` and `Unlock` functions are used in environments where several processes might need access to the same file.</span></span>  
  
 <span data-ttu-id="d705e-2540">`Lock` und `Unlock` Funktionen werden immer paarweise verwendet.</span><span class="sxs-lookup"><span data-stu-id="d705e-2540">`Lock` and `Unlock` functions are always used in pairs.</span></span> <span data-ttu-id="d705e-2541">Die Argumente für `Lock` und `Unlock` müssen identisch sein.</span><span class="sxs-lookup"><span data-stu-id="d705e-2541">The arguments to `Lock` and `Unlock` must be identical.</span></span>  
  
 <span data-ttu-id="d705e-2542">Wenn `Record`, oder `FromRecord` und `ToRecord` sind nicht angegeben wird, wird die Sperre für die gesamte Datei sein.</span><span class="sxs-lookup"><span data-stu-id="d705e-2542">If `Record`, or `FromRecord` and `ToRecord` are not supplied, the lock will be for the whole file.</span></span> <span data-ttu-id="d705e-2543">Wenn `Record` allein entspricht der einzelne Datensatz gesperrt/entsperrt werden.</span><span class="sxs-lookup"><span data-stu-id="d705e-2543">If `Record` alone is specified the single record will be locked/unlocked.</span></span>  
  
 <span data-ttu-id="d705e-2544">Wenn die Datei, für die sequenzielle Eingabe oder Ausgabe geöffnet wurde, `Lock` und `Unlock` Auswirkungen auf die gesamte Datei und unabhängig vom angegebenen Bereich `FromRecord` und`ToRecord`.</span><span class="sxs-lookup"><span data-stu-id="d705e-2544">If the file has been opened for sequential input or output, `Lock` and `Unlock` affect the whole file, regardless of the range specified by `FromRecord` and`ToRecord`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d705e-2545">Dieses Beispiel veranschaulicht die Verwendung der `Lock` und `Unlock` Funktionen.</span><span class="sxs-lookup"><span data-stu-id="d705e-2545">This example illustrates the use of the `Lock` and `Unlock` functions.</span></span> <span data-ttu-id="d705e-2546">In diesem Beispiel wird vorausgesetzt, dass `People.txt` ist eine Datei, die Datensätze der Struktur enthält `Person`.</span><span class="sxs-lookup"><span data-stu-id="d705e-2546">This example assumes that `People.txt` is a file that contains records of the structure `Person`.</span></span>  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="d705e-2547">Dateimodus ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="d705e-2547">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="LOF">
      <MemberSignature Language="C#" Value="public static long LOF (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 LOF(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LOF (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long LOF(int FileNumber);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="d705e-2548">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-2548">Required.</span></span> <span data-ttu-id="d705e-2549">Ein <see langword="Integer" /> mit einer gültigen Dateinummer.</span><span class="sxs-lookup"><span data-stu-id="d705e-2549">An <see langword="Integer" /> that contains a valid file number.</span></span></param>
        <summary><span data-ttu-id="d705e-2550">Gibt einen <see langword="Long" /> zurück, der die Größe einer mit der <see langword="FileOpen" />-Funktion geöffneten Datei in Bytes darstellt.</span><span class="sxs-lookup"><span data-stu-id="d705e-2550">Returns a <see langword="Long" /> representing the size, in bytes, of a file opened by using the <see langword="FileOpen" /> function.</span></span> <span data-ttu-id="d705e-2551">Das <see langword="My" />-Feature bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="LOF" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-2551">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="LOF" />.</span></span> <span data-ttu-id="d705e-2552">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-2552">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <returns><span data-ttu-id="d705e-2553">Gibt einen <see langword="Long" /> zurück, der die Größe einer mit der <see langword="FileOpen" />-Funktion geöffneten Datei in Bytes darstellt.</span><span class="sxs-lookup"><span data-stu-id="d705e-2553">Returns a <see langword="Long" /> representing the size, in bytes, of a file opened by using the <see langword="FileOpen" /> function.</span></span> <span data-ttu-id="d705e-2554">Das <see langword="My" />-Feature bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="LOF" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-2554">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="LOF" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d705e-2555">Verwenden der `FileLen` Funktion, um die Länge einer Datei zu erhalten, die nicht geöffnet ist.</span><span class="sxs-lookup"><span data-stu-id="d705e-2555">Use the `FileLen` function to obtain the length of a file that is not open.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d705e-2556">Dieses Beispiel verwendet die `LOF` -Funktion können Sie die Größe einer geöffneten Datei zu ermitteln.</span><span class="sxs-lookup"><span data-stu-id="d705e-2556">This example uses the `LOF` function to determine the size of an open file.</span></span> <span data-ttu-id="d705e-2557">In diesem Beispiel wird vorausgesetzt, dass `TestFile` ist eine Textdatei, die Beispieldaten enthält.</span><span class="sxs-lookup"><span data-stu-id="d705e-2557">This example assumes that `TestFile` is a text file that contains sample data.</span></span>  
  
 [!code-vb[VbVbalrCatRef#23](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="d705e-2558">Dateimodus ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="d705e-2558">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="MkDir">
      <MemberSignature Language="C#" Value="public static void MkDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void MkDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MkDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MkDir(System::String ^ Path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path"><span data-ttu-id="d705e-2559">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-2559">Required.</span></span> <span data-ttu-id="d705e-2560"><see langword="String" />-Ausdruck, der das zu erstellende Verzeichnis identifiziert.</span><span class="sxs-lookup"><span data-stu-id="d705e-2560"><see langword="String" /> expression that identifies the directory to be created.</span></span> <span data-ttu-id="d705e-2561"><c>Path</c> enthält möglicherweise das Laufwerk.</span><span class="sxs-lookup"><span data-stu-id="d705e-2561">The <c>Path</c> may include the drive.</span></span> <span data-ttu-id="d705e-2562">Wenn kein Laufwerk angegeben wird, erstellt <see langword="MkDir" /> das neue Verzeichnis auf dem aktuellen Laufwerk.</span><span class="sxs-lookup"><span data-stu-id="d705e-2562">If no drive is specified, <see langword="MkDir" /> creates the new directory on the current drive.</span></span></param>
        <summary><span data-ttu-id="d705e-2563">Erstellt ein neues Verzeichnis.</span><span class="sxs-lookup"><span data-stu-id="d705e-2563">Creates a new directory.</span></span> <span data-ttu-id="d705e-2564">Das <see langword="My" />-Feature bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="MkDir" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-2564">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="MkDir" />.</span></span> <span data-ttu-id="d705e-2565">Weitere Informationen finden Sie unter <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CreateDirectory(System.String)" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-2565">For more information, see <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CreateDirectory(System.String)" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d705e-2566">Diese Funktion wird ein neues Verzeichnis erstellt.</span><span class="sxs-lookup"><span data-stu-id="d705e-2566">This function creates a new directory.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d705e-2567">Dieses Beispiel verwendet die `MkDir` Funktion zum Erstellen eines Verzeichnisses.</span><span class="sxs-lookup"><span data-stu-id="d705e-2567">This example uses the `MkDir` function to create a directory.</span></span> <span data-ttu-id="d705e-2568">Wenn das Laufwerk nicht angegeben wird, wird das neue Verzeichnis auf das aktuelle Laufwerk erstellt.</span><span class="sxs-lookup"><span data-stu-id="d705e-2568">If the drive is not specified, the new directory is created on the current drive.</span></span>  
  
 [!code-vb[VbVbalrCatRef#38](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#38)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="d705e-2569"><paramref name="Path" /> ist nicht angegeben oder leer.</span><span class="sxs-lookup"><span data-stu-id="d705e-2569"><paramref name="Path" /> is not specified or is empty.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="d705e-2570">Berechtigung verweigert.</span><span class="sxs-lookup"><span data-stu-id="d705e-2570">Permission denied.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="d705e-2571">Verzeichnis ist bereits vorhanden.</span><span class="sxs-lookup"><span data-stu-id="d705e-2571">Directory already exists.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Print">
      <MemberSignature Language="C#" Value="public static void Print (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Print(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Print (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Print(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="d705e-2572">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-2572">Required.</span></span> <span data-ttu-id="d705e-2573">Eine beliebige gültige Dateinummer.</span><span class="sxs-lookup"><span data-stu-id="d705e-2573">Any valid file number.</span></span></param>
        <param name="Output"><span data-ttu-id="d705e-2574">Dies ist optional.</span><span class="sxs-lookup"><span data-stu-id="d705e-2574">Optional.</span></span> <span data-ttu-id="d705e-2575">0 (null) oder mehrere durch Trennzeichen getrennte Ausdrücke, die in eine Datei geschrieben werden sollen.</span><span class="sxs-lookup"><span data-stu-id="d705e-2575">Zero or more comma-delimited expressions to write to a file.</span></span>  
  
 <span data-ttu-id="d705e-2576">Die <c>Output</c>-Argumenteinstellungen lauten:</span><span class="sxs-lookup"><span data-stu-id="d705e-2576">The <c>Output</c> argument settings are:</span></span>  
  
 <span data-ttu-id="d705e-2577"><see langword="T:System.IO.IOException" />: Dateimodus ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="d705e-2577"><see langword="T:System.IO.IOException" />: File mode is invalid.</span></span>  
  
 <span data-ttu-id="d705e-2578"><see langword="T:System.IO.IOException" />: <c>FileNumber</c> ist nicht vorhanden.</span><span class="sxs-lookup"><span data-stu-id="d705e-2578"><see langword="T:System.IO.IOException" />: <c>FileNumber</c> does not exist.</span></span></param>
        <summary><span data-ttu-id="d705e-2579">Schreibt für die Anzeige formatierte Daten in eine sequenzielle Datei.</span><span class="sxs-lookup"><span data-stu-id="d705e-2579">Writes display-formatted data to a sequential file.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d705e-2580">Die `Print` und `PrintLine` Funktionen für Abwärtskompatibilität angeboten werden und die Leistung beeinträchtigen.</span><span class="sxs-lookup"><span data-stu-id="d705e-2580">The `Print` and `PrintLine` functions are provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="d705e-2581">Für nicht-Legacyanwendungen der `My.Computer.FileSystem` Objekt bietet eine bessere Leistung.</span><span class="sxs-lookup"><span data-stu-id="d705e-2581">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="d705e-2582">Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="d705e-2582">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="d705e-2583">`Print` Schließt einen Zeilenvorschub am Ende einer Zeile nicht; allerdings `PrintLine` umfasst einen Zeilenvorschub.</span><span class="sxs-lookup"><span data-stu-id="d705e-2583">`Print` does not include a line feed at the end of a line; however, `PrintLine` does include a line feed.</span></span>  
  
 <span data-ttu-id="d705e-2584">Mit geschriebenen Daten `Print` in der Regel aus einer Datei lesen, mit `LineInput` oder `Input`.</span><span class="sxs-lookup"><span data-stu-id="d705e-2584">Data written with `Print` is usually read from a file by using `LineInput` or `Input`.</span></span>  
  
 <span data-ttu-id="d705e-2585">Wenn Sie weglassen `Output` für `PrintLine`, eine leere Zeile wird ausgegeben, in der Datei; für `Print`, nichts wird ausgegeben.</span><span class="sxs-lookup"><span data-stu-id="d705e-2585">If you omit `Output` for `PrintLine`, a blank line is printed to the file; for `Print`, nothing is output.</span></span> <span data-ttu-id="d705e-2586">Mehrere Ausdrücke, die durch ein Komma voneinander getrennt werden so ausgerichtet, Registerkarte Grenzen, sondern mischen Kommas und `TAB` kann zu inkonsistente Ergebnissen führen.</span><span class="sxs-lookup"><span data-stu-id="d705e-2586">Multiple expressions separated with a comma will be aligned on tab boundaries, but mixing commas and `TAB` may cause inconsistent results.</span></span>  
  
 <span data-ttu-id="d705e-2587">Für `Boolean` Daten, entweder `True` oder `False` gedruckt wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-2587">For `Boolean` data, either `True` or `False` is printed.</span></span> <span data-ttu-id="d705e-2588">Die `True` und `False` Schlüsselwörter sind unabhängig vom Gebietsschema nicht übersetzt.</span><span class="sxs-lookup"><span data-stu-id="d705e-2588">The `True` and `False` keywords are not translated, regardless of the locale.</span></span>  
  
 <span data-ttu-id="d705e-2589">Datumsdaten werden in die Datei geschrieben, mit das standardmäßige kurze Datumsformat, die vom System erkannt wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-2589">Date data is written to the file by using the standard short date format recognized by your system.</span></span> <span data-ttu-id="d705e-2590">Wenn das Datum oder die Zeitkomponente fehlen oder gleich NULL, so wird nur der Teil werden in die Datei geschrieben.</span><span class="sxs-lookup"><span data-stu-id="d705e-2590">When either the date or the time component is missing or zero, only the part provided is written to the file.</span></span>  
  
 <span data-ttu-id="d705e-2591">Nichts in die Datei geschrieben wird, wenn `Output` Daten ist leer.</span><span class="sxs-lookup"><span data-stu-id="d705e-2591">Nothing is written to the file if `Output` data is empty.</span></span> <span data-ttu-id="d705e-2592">Jedoch wenn `Output` Listendaten ist `DBNull`, `Null` in die Datei geschrieben wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-2592">However, if `Output` list data is `DBNull`, `Null` is written to the file.</span></span>  
  
 <span data-ttu-id="d705e-2593">Für `Error` Daten, die Ausgabe angezeigt wird, als `Error errorcode`.</span><span class="sxs-lookup"><span data-stu-id="d705e-2593">For `Error` data, the output appears as `Error errorcode`.</span></span> <span data-ttu-id="d705e-2594">Die `Error` Schlüsselwort wird unabhängig vom Gebietsschema nicht übersetzt.</span><span class="sxs-lookup"><span data-stu-id="d705e-2594">The `Error` keyword is not translated regardless of the locale.</span></span>  
  
 <span data-ttu-id="d705e-2595">Alle Daten, die in die Datei geschrieben wird, mit `Print` ist Dezimaltrennzeichen; d. h. die Daten ist richtig formatiert mit entsprechenden Dezimaltrennzeichen.</span><span class="sxs-lookup"><span data-stu-id="d705e-2595">All data written to the file by using `Print` is internationally aware; that is, the data is correctly formatted using the appropriate decimal separator.</span></span> <span data-ttu-id="d705e-2596">Wenn der Benutzer möchte Ausgabedaten für die Verwendung in mehreren Gebietsschemas `Write` verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="d705e-2596">If the user wishes to output data for use by multiple locales, `Write` should be used.</span></span>  
  
 <span data-ttu-id="d705e-2597">Schreiben in eine Datei mithilfe der `Print` oder `PrintLine` Funktionen erfordert `Write` aus Zugriff auf die `FileIOPermissionAccess` Enumeration.</span><span class="sxs-lookup"><span data-stu-id="d705e-2597">Writing to a file by using the `Print` or `PrintLine` functions requires `Write` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="d705e-2598">Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="d705e-2598">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess> .</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d705e-2599">Dieses Beispiel verwendet die `Print` und `PrintLine` Funktionen, um Daten in eine Datei schreiben.</span><span class="sxs-lookup"><span data-stu-id="d705e-2599">This example uses the `Print` and `PrintLine` functions to write data to a file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#53](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#53)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="PrintLine">
      <MemberSignature Language="C#" Value="public static void PrintLine (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void PrintLine(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub PrintLine (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PrintLine(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="d705e-2600">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-2600">Required.</span></span> <span data-ttu-id="d705e-2601">Eine beliebige gültige Dateinummer.</span><span class="sxs-lookup"><span data-stu-id="d705e-2601">Any valid file number.</span></span></param>
        <param name="Output"><span data-ttu-id="d705e-2602">Dies ist optional.</span><span class="sxs-lookup"><span data-stu-id="d705e-2602">Optional.</span></span> <span data-ttu-id="d705e-2603">0 (null) oder mehrere durch Trennzeichen getrennte Ausdrücke, die in eine Datei geschrieben werden sollen.</span><span class="sxs-lookup"><span data-stu-id="d705e-2603">Zero or more comma-delimited expressions to write to a file.</span></span>  
  
 <span data-ttu-id="d705e-2604">Die <c>Output</c>-Argumenteinstellungen lauten:</span><span class="sxs-lookup"><span data-stu-id="d705e-2604">The <c>Output</c> argument settings are:</span></span>  
  
 <span data-ttu-id="d705e-2605"><see langword="T:System.IO.IOException" />: Dateimodus ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="d705e-2605"><see langword="T:System.IO.IOException" />: File mode is invalid.</span></span>  
  
 <span data-ttu-id="d705e-2606"><see langword="T:System.IO.IOException" />: <c>FileNumber</c> ist nicht vorhanden.</span><span class="sxs-lookup"><span data-stu-id="d705e-2606"><see langword="T:System.IO.IOException" />: <c>FileNumber</c> does not exist.</span></span></param>
        <summary><span data-ttu-id="d705e-2607">Schreibt für die Anzeige formatierte Daten in eine sequenzielle Datei.</span><span class="sxs-lookup"><span data-stu-id="d705e-2607">Writes display-formatted data to a sequential file.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d705e-2608">Die `Print` und `PrintLine` Funktionen für Abwärtskompatibilität angeboten werden und die Leistung beeinträchtigen.</span><span class="sxs-lookup"><span data-stu-id="d705e-2608">The `Print` and `PrintLine` functions are provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="d705e-2609">Für nicht-Legacyanwendungen der `My.Computer.FileSystem` Objekt bietet eine bessere Leistung.</span><span class="sxs-lookup"><span data-stu-id="d705e-2609">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="d705e-2610">Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="d705e-2610">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="d705e-2611">`Print` Schließt einen Zeilenvorschub am Ende einer Zeile nicht; allerdings`PrintLine` umfasst einen Zeilenvorschub.</span><span class="sxs-lookup"><span data-stu-id="d705e-2611">`Print` does not include a line feed at the end of a line; however,`PrintLine` does include a line feed.</span></span>  
  
 <span data-ttu-id="d705e-2612">Mit geschriebenen Daten `Print` in der Regel aus einer Datei lesen, mit `LineInput` oder `Input`.</span><span class="sxs-lookup"><span data-stu-id="d705e-2612">Data written with `Print` is usually read from a file by using `LineInput` or `Input`.</span></span>  
  
 <span data-ttu-id="d705e-2613">Wenn Sie weglassen `Output` für `PrintLine`, eine leere Zeile wird ausgegeben, in der Datei; für `Print`, nichts wird ausgegeben.</span><span class="sxs-lookup"><span data-stu-id="d705e-2613">If you omit `Output` for `PrintLine`, a blank line is printed to the file; for `Print`, nothing is output.</span></span> <span data-ttu-id="d705e-2614">Mehrere Ausdrücke, die durch ein Komma voneinander getrennt werden so ausgerichtet, Registerkarte Grenzen, sondern mischen Kommas und `TAB` kann zu inkonsistente Ergebnissen führen.</span><span class="sxs-lookup"><span data-stu-id="d705e-2614">Multiple expressions separated with a comma will be aligned on tab boundaries, but mixing commas and `TAB` may cause inconsistent results.</span></span>  
  
 <span data-ttu-id="d705e-2615">Für `Boolean` Daten, entweder `True` oder `False` gedruckt wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-2615">For `Boolean` data, either `True` or `False` is printed.</span></span> <span data-ttu-id="d705e-2616">Die `True` und `False` Schlüsselwörter sind unabhängig vom Gebietsschema nicht übersetzt.</span><span class="sxs-lookup"><span data-stu-id="d705e-2616">The `True` and `False` keywords are not translated, regardless of the locale.</span></span>  
  
 <span data-ttu-id="d705e-2617">Datumsdaten werden in die Datei geschrieben, mit das standardmäßige kurze Datumsformat vom System erkannt.</span><span class="sxs-lookup"><span data-stu-id="d705e-2617">Date data is written to the file by using the standard short date format recognized by the system.</span></span> <span data-ttu-id="d705e-2618">Wenn das Datum oder die Zeitkomponente fehlen oder gleich NULL, so wird nur der Teil werden in die Datei geschrieben.</span><span class="sxs-lookup"><span data-stu-id="d705e-2618">When either the date or the time component is missing or zero, only the part provided is written to the file.</span></span>  
  
 <span data-ttu-id="d705e-2619">Nichts in die Datei geschrieben wird, wenn `Output` Daten ist leer.</span><span class="sxs-lookup"><span data-stu-id="d705e-2619">Nothing is written to the file if `Output` data is empty.</span></span> <span data-ttu-id="d705e-2620">Jedoch wenn `Output` Listendaten ist `DBNull`, `Null` in die Datei geschrieben wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-2620">However, if `Output` list data is `DBNull`, `Null` is written to the file.</span></span>  
  
 <span data-ttu-id="d705e-2621">Für `Error` Daten, die Ausgabe angezeigt wird, als `Error errorcode`.</span><span class="sxs-lookup"><span data-stu-id="d705e-2621">For `Error` data, the output appears as `Error errorcode`.</span></span> <span data-ttu-id="d705e-2622">Die `Error` Schlüsselwort wird unabhängig vom Gebietsschema nicht übersetzt.</span><span class="sxs-lookup"><span data-stu-id="d705e-2622">The `Error` keyword is not translated regardless of the locale.</span></span>  
  
 <span data-ttu-id="d705e-2623">Alle Daten, die in die Datei geschrieben wird, mit `Print` ist Dezimaltrennzeichen; d. h. die Daten ist richtig formatiert mit entsprechenden Dezimaltrennzeichen.</span><span class="sxs-lookup"><span data-stu-id="d705e-2623">All data written to the file by using `Print` is internationally aware; that is, the data is correctly formatted using the appropriate decimal separator.</span></span> <span data-ttu-id="d705e-2624">Wenn der Benutzer möchte Ausgabedaten für die Verwendung in mehreren Gebietsschemas `Write` verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="d705e-2624">If the user wishes to output data for use by multiple locales, `Write` should be used.</span></span>  
  
 <span data-ttu-id="d705e-2625">Schreiben in eine Datei mithilfe der `Print` oder `PrintLine` Funktionen erfordert `Write` aus Zugriff auf die `FileIOPermissionAccess` Enumeration.</span><span class="sxs-lookup"><span data-stu-id="d705e-2625">Writing to a file by using the `Print` or `PrintLine` functions requires `Write` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="d705e-2626">Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="d705e-2626">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess> .</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d705e-2627">Dieses Beispiel verwendet die `Print` und `PrintLine` Funktionen, um Daten in eine Datei schreiben.</span><span class="sxs-lookup"><span data-stu-id="d705e-2627">This example uses the `Print` and `PrintLine` functions to write data to a file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#53](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#53)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Rename">
      <MemberSignature Language="C#" Value="public static void Rename (string OldPath, string NewPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Rename(string OldPath, string NewPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Rename (OldPath As String, NewPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Rename(System::String ^ OldPath, System::String ^ NewPath);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="OldPath" Type="System.String" />
        <Parameter Name="NewPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="OldPath"><span data-ttu-id="d705e-2628">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-2628">Required.</span></span> <span data-ttu-id="d705e-2629">Ein <see langword="String" />-Ausdruck, der den Namen und den Speicherort der vorhandenen Datei angibt.</span><span class="sxs-lookup"><span data-stu-id="d705e-2629"><see langword="String" /> expression that specifies the existing file name and location.</span></span> <span data-ttu-id="d705e-2630"><c>OldPath</c> kann das Verzeichnis und das Laufwerk der Datei beinhalten.</span><span class="sxs-lookup"><span data-stu-id="d705e-2630"><c>OldPath</c> may include the directory, and drive, of the file.</span></span></param>
        <param name="NewPath"><span data-ttu-id="d705e-2631">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-2631">Required.</span></span> <span data-ttu-id="d705e-2632">Ein <see langword="String" />-Ausdruck, der den Namen und den Speicherort der neuen Datei angibt.</span><span class="sxs-lookup"><span data-stu-id="d705e-2632"><see langword="String" /> expression that specifies the new file name and location.</span></span> <span data-ttu-id="d705e-2633"><c>NewPath</c> kann das Verzeichnis und das Laufwerk des Zielspeicherorts beinhalten.</span><span class="sxs-lookup"><span data-stu-id="d705e-2633"><c>NewPath</c> may include directory and drive of the destination location.</span></span> <span data-ttu-id="d705e-2634">Der durch <c>NewPath</c> angegebene Dateiname darf noch nicht vorhanden sein.</span><span class="sxs-lookup"><span data-stu-id="d705e-2634">The file name specified by <c>NewPath</c> cannot already exist.</span></span></param>
        <summary><span data-ttu-id="d705e-2635">Benennt eine Datenträgerdatei oder ein Verzeichnis um.</span><span class="sxs-lookup"><span data-stu-id="d705e-2635">Renames a disk file or directory.</span></span> <span data-ttu-id="d705e-2636">Das <see langword="My" />-Feature bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="Rename" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-2636">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Rename" />.</span></span> <span data-ttu-id="d705e-2637">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-2637">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d705e-2638">Die`Rename` Funktion benennt eine Datei und in ein anderes Verzeichnis verschoben, wenn es erforderlich ist.</span><span class="sxs-lookup"><span data-stu-id="d705e-2638">The`Rename` function renames a file and moves it to a different directory, if it is required.</span></span> <span data-ttu-id="d705e-2639">Die `Rename` Funktion kann eine Datei auf Laufwerken verschoben, aber es kann nur ein vorhandenes Verzeichnis umbenennen Wenn beide `NewPath` und `OldPath` auf dem gleichen Laufwerk befinden.</span><span class="sxs-lookup"><span data-stu-id="d705e-2639">The `Rename` function can move a file across drives, but it can only rename an existing directory when both `NewPath` and `OldPath` are located on the same drive.</span></span> <span data-ttu-id="d705e-2640">`Rename` eine neue Datei oder ein Verzeichnis kann nicht erstellt werden.</span><span class="sxs-lookup"><span data-stu-id="d705e-2640">`Rename` cannot create a new file or directory.</span></span>  
  
 <span data-ttu-id="d705e-2641">Mithilfe der `Rename` Funktion in einer geöffneten Datei erzeugt einen Fehler.</span><span class="sxs-lookup"><span data-stu-id="d705e-2641">Using the `Rename` function on an open file produces an error.</span></span> <span data-ttu-id="d705e-2642">Sie müssen eine geöffnete Datei schließen, bevor Sie es umbenennen.</span><span class="sxs-lookup"><span data-stu-id="d705e-2642">You must close an open file before renaming it.</span></span> <span data-ttu-id="d705e-2643">`Rename` Argumente können nicht mehrere Zeichen (\*) und Platzhalter für einzelne Zeichen (?) enthalten.</span><span class="sxs-lookup"><span data-stu-id="d705e-2643">`Rename` arguments cannot include multiple-character (\*) and single-character (?) wildcards.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="d705e-2644">Bei Verwendung `Rename` um eine Datei aus einem ungeschützten Speicherort auf einem geschützten Speicherort zu kopieren, die Datei behält die weniger eingeschränkten Berechtigungen.</span><span class="sxs-lookup"><span data-stu-id="d705e-2644">When using `Rename` to copy a file from an unprotected location to a protected location, the file retains the less restricted rights.</span></span> <span data-ttu-id="d705e-2645">Stellen Sie sicher, dass Sie nicht über ein mögliches Sicherheitsrisiko entstehen.</span><span class="sxs-lookup"><span data-stu-id="d705e-2645">Check to make sure that you are not introducing a possible security risk.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d705e-2646">Dieses Beispiel verwendet die `Rename` Funktion zum Umbenennen einer Datei.</span><span class="sxs-lookup"><span data-stu-id="d705e-2646">This example uses the `Rename` function to rename a file.</span></span> <span data-ttu-id="d705e-2647">Für den Rahmen dieses Beispiels wird davon ausgegangen Sie, dass die Verzeichnisse, die bereits vorhanden sind.</span><span class="sxs-lookup"><span data-stu-id="d705e-2647">For purposes of this example, assume that the directories that are specified already exist.</span></span>  
  
 [!code-vb[VbVbalrCatRef#30](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#30)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d705e-2648">Der Pfad ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="d705e-2648">Path is invalid.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="d705e-2649">Die <paramref name="OldPath" />-Datei ist nicht vorhanden.</span><span class="sxs-lookup"><span data-stu-id="d705e-2649"><paramref name="OldPath" /> file does not exist.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="d705e-2650">Kann nicht auf anderes Gerät umbenannt werden.</span><span class="sxs-lookup"><span data-stu-id="d705e-2650">Cannot rename to different device.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public static void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public static void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Reset();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d705e-2651">Schließt alle mit der <see langword="FileOpen" />-Funktion geöffneten Datenträgerdateien.</span><span class="sxs-lookup"><span data-stu-id="d705e-2651">Closes all disk files opened by using the <see langword="FileOpen" /> function.</span></span> <span data-ttu-id="d705e-2652">Das <see langword="My" />-Feature bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="Reset" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-2652">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Reset" />.</span></span> <span data-ttu-id="d705e-2653">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-2653">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d705e-2654">Die `Reset` -Funktion schließt alle aktive Dateien geöffnet, indem die `FileOpen` Funktion, und hat die gleiche Funktion wie `FileClose()` ohne Parameter.</span><span class="sxs-lookup"><span data-stu-id="d705e-2654">The `Reset` function closes all active files opened by the `FileOpen` function and has the same function as `FileClose()` without any parameters.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d705e-2655">Dieses Beispiel verwendet die `Reset` Funktion, um alle geöffneten Dateien geschlossen und der Inhalt aller Dateipuffer auf dem Datenträger festgeschrieben.</span><span class="sxs-lookup"><span data-stu-id="d705e-2655">This example uses the `Reset` function to close all open files and write the contents of all file buffers to disk.</span></span> <span data-ttu-id="d705e-2656">Beachten Sie die Verwendung der `Object` Variable `FileNumber` als eine Zeichenfolge und eine Zahl.</span><span class="sxs-lookup"><span data-stu-id="d705e-2656">Note the use of the `Object` variable `FileNumber` as both a string and a number.</span></span>  
  
 [!code-vb[VbVbalrCatRef#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#12)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="RmDir">
      <MemberSignature Language="C#" Value="public static void RmDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void RmDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RmDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RmDir(System::String ^ Path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path"><span data-ttu-id="d705e-2657">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-2657">Required.</span></span> <span data-ttu-id="d705e-2658"><see langword="String" />-Ausdruck, der das zu entfernende Verzeichnis oder den zu entfernenden Ordner identifiziert.</span><span class="sxs-lookup"><span data-stu-id="d705e-2658"><see langword="String" /> expression that identifies the directory or folder to be removed.</span></span> <span data-ttu-id="d705e-2659"><c>Path</c> kann das Laufwerk enthalten.</span><span class="sxs-lookup"><span data-stu-id="d705e-2659"><c>Path</c> can include the drive.</span></span> <span data-ttu-id="d705e-2660">Wenn kein Laufwerk angegeben wird, entfernt <see langword="RmDir" /> das Verzeichnis vom aktuellen Laufwerk.</span><span class="sxs-lookup"><span data-stu-id="d705e-2660">If no drive is specified, <see langword="RmDir" /> removes the directory on the current drive.</span></span></param>
        <summary><span data-ttu-id="d705e-2661">Entfernt ein vorhandenes Verzeichnis.</span><span class="sxs-lookup"><span data-stu-id="d705e-2661">Removes an existing directory.</span></span> <span data-ttu-id="d705e-2662">Das <see langword="My" />-Feature bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="RmDir" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-2662">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="RmDir" />.</span></span> <span data-ttu-id="d705e-2663">Weitere Informationen finden Sie unter <see cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-2663">For more information, see <see cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d705e-2664">Ein Fehler auftritt, wenn Sie versuchen, `RmDir` in einem Verzeichnis, das Dateien enthält.</span><span class="sxs-lookup"><span data-stu-id="d705e-2664">An error occurs if you try to use `RmDir` on a directory that contains files.</span></span> <span data-ttu-id="d705e-2665">Verwenden der `Kill` Funktion, um alle Dateien zu löschen, bevor Sie versuchen, ein Verzeichnis zu entfernen.</span><span class="sxs-lookup"><span data-stu-id="d705e-2665">Use the `Kill` function to delete all files before you try to remove a directory.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d705e-2666">Dieses Beispiel verwendet die `RmDir` Funktion, um ein vorhandenes Verzeichnis zu entfernen.</span><span class="sxs-lookup"><span data-stu-id="d705e-2666">This example uses the `RmDir` function to remove an existing directory.</span></span>  
  
 [!code-vb[VbVbalrCatRef#31](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#31)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="d705e-2667"><paramref name="Path" /> ist nicht angegeben oder leer.</span><span class="sxs-lookup"><span data-stu-id="d705e-2667"><paramref name="Path" /> is not specified or is empty.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="d705e-2668">Zielverzeichnis enthält Dateien.</span><span class="sxs-lookup"><span data-stu-id="d705e-2668">Target directory contains files.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="d705e-2669">Verzeichnis ist nicht vorhanden.</span><span class="sxs-lookup"><span data-stu-id="d705e-2669">Directory does not exist.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Seek">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d705e-2670">Gibt einen <see langword="Long" />-Wert zurück, der die aktuelle Lese-/Schreibposition innerhalb einer mithilfe der <see langword="FileOpen" />-Funktion geöffneten Datei angibt, oder legt die Position des nächsten Lese-/Schreibvorgangs innerhalb einer mithilfe der <see langword="FileOpen" />-Funktion geöffneten Datei fest.</span><span class="sxs-lookup"><span data-stu-id="d705e-2670">Returns a <see langword="Long" /> specifying the current read/write position in a file opened by using the <see langword="FileOpen" /> function, or sets the position for the next read/write operation in a file opened by using the <see langword="FileOpen" /> function.</span></span> <span data-ttu-id="d705e-2671">Das <see langword="My" />-Feature bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="Seek" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-2671">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Seek" />.</span></span> <span data-ttu-id="d705e-2672">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-2672">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public static long Seek (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 Seek(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Seek (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Seek(int FileNumber);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="d705e-2673">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-2673">Required.</span></span> <span data-ttu-id="d705e-2674">Ein <see langword="Integer" /> mit einer gültigen Dateinummer.</span><span class="sxs-lookup"><span data-stu-id="d705e-2674">An <see langword="Integer" /> that contains a valid file number.</span></span></param>
        <summary><span data-ttu-id="d705e-2675">Gibt einen <see langword="Long" />-Wert zurück, der die aktuelle Lese-/Schreibposition innerhalb einer mithilfe der <see langword="FileOpen" />-Funktion geöffneten Datei angibt, oder legt die Position des nächsten Lese-/Schreibvorgangs innerhalb einer mithilfe der <see langword="FileOpen" />-Funktion geöffneten Datei fest.</span><span class="sxs-lookup"><span data-stu-id="d705e-2675">Returns a <see langword="Long" /> specifying the current read/write position in a file opened by using the <see langword="FileOpen" /> function, or sets the position for the next read/write operation in a file opened by using the <see langword="FileOpen" /> function.</span></span> <span data-ttu-id="d705e-2676">Das <see langword="My" />-Feature bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="Seek" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-2676">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Seek" />.</span></span> <span data-ttu-id="d705e-2677">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-2677">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <returns><span data-ttu-id="d705e-2678">Gibt einen <see langword="Long" />-Wert zurück, der die aktuelle Lese-/Schreibposition innerhalb einer mithilfe der <see langword="FileOpen" />-Funktion geöffneten Datei angibt, oder legt die Position des nächsten Lese-/Schreibvorgangs innerhalb einer mithilfe der <see langword="FileOpen" />-Funktion geöffneten Datei fest.</span><span class="sxs-lookup"><span data-stu-id="d705e-2678">Returns a <see langword="Long" /> specifying the current read/write position in a file opened by using the <see langword="FileOpen" /> function, or sets the position for the next read/write operation in a file opened by using the <see langword="FileOpen" /> function.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d705e-2679">`Seek` Gibt einen Wert zwischen 1 und 2.147.483.647 (entspricht 2 ^ 31-1), inklusive.</span><span class="sxs-lookup"><span data-stu-id="d705e-2679">`Seek` returns a value between 1 and 2,147,483,647 (equivalent to 2^31 – 1), inclusive.</span></span>  
  
 <span data-ttu-id="d705e-2680">Im folgenden werden die Rückgabewerte für jede Dateizugriffsmodus beschrieben:</span><span class="sxs-lookup"><span data-stu-id="d705e-2680">The following describes the return values for each file access mode:</span></span>  
  
|<span data-ttu-id="d705e-2681">Modus</span><span class="sxs-lookup"><span data-stu-id="d705e-2681">Mode</span></span>|<span data-ttu-id="d705e-2682">Rückgabewert</span><span class="sxs-lookup"><span data-stu-id="d705e-2682">Return Value</span></span>|  
|-|-|  
|`Random`|<span data-ttu-id="d705e-2683">Nummer des nächsten Datensatzes gelesen bzw. geschrieben werden</span><span class="sxs-lookup"><span data-stu-id="d705e-2683">Number of the next record read or written</span></span>|  
|<span data-ttu-id="d705e-2684">`Binary`, `Input`, `Output`, `Append`</span><span class="sxs-lookup"><span data-stu-id="d705e-2684">`Binary`, `Input`, `Output`, `Append`</span></span>|<span data-ttu-id="d705e-2685">Die Byteposition mit der nächste Vorgang auftritt.</span><span class="sxs-lookup"><span data-stu-id="d705e-2685">Byte position at which the next operation occurs.</span></span> <span data-ttu-id="d705e-2686">Das erste Byte in einer Datei befindet sich an Position 1, das zweite Byte an Position 2 usw. ist.</span><span class="sxs-lookup"><span data-stu-id="d705e-2686">The first byte in a file is at position 1, the second byte is at position 2, and so on.</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="d705e-2687">Dieses Beispiel verwendet die `Seek` Funktion, um die aktuelle Dateiposition zurückzugeben.</span><span class="sxs-lookup"><span data-stu-id="d705e-2687">This example uses the `Seek` function to return the current file position.</span></span> <span data-ttu-id="d705e-2688">Das Beispiel setzt voraus `TestFile` ist eine Datei, die Datensätze der Struktur enthält `Record`.</span><span class="sxs-lookup"><span data-stu-id="d705e-2688">The example assumes `TestFile` is a file that contains records of the structure `Record`.</span></span>  
  
 [!code-vb[VbVbalrCatRef#47](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#47)]  
  
 <span data-ttu-id="d705e-2689">Für Dateien in geöffnet `Random` Modus `Seek` gibt die Anzahl des nächsten Datensatzes zurück.</span><span class="sxs-lookup"><span data-stu-id="d705e-2689">For files opened in `Random` mode, `Seek` returns the number of next record.</span></span>  
  
 [!code-vb[VbVbalrCatRef#48](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#48)]  
  
 <span data-ttu-id="d705e-2690">Für Dateien, die nicht in den Modi geöffnet `Random` Modus `Seek` gibt die Byteposition mit der nächste Vorgang auftritt.</span><span class="sxs-lookup"><span data-stu-id="d705e-2690">For files opened in modes other than `Random` mode, `Seek` returns the byte position at which the next operation occurs.</span></span> <span data-ttu-id="d705e-2691">Angenommen `TestFile` ist eine Datei, die mehrere Textzeilen enthält.</span><span class="sxs-lookup"><span data-stu-id="d705e-2691">Assume `TestFile` is a file that contains several lines of text.</span></span>  
  
 [!code-vb[VbVbalrCatRef#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#49)]  
  
 <span data-ttu-id="d705e-2692">Dieses Beispiel verwendet die `Seek` Funktion, positionieren Sie die für den nächsten Lese- oder Schreibvorgang in einer Datei.</span><span class="sxs-lookup"><span data-stu-id="d705e-2692">This example uses the `Seek` function to set the position for the next read or write in a file.</span></span>  
  
 <span data-ttu-id="d705e-2693">Für Dateien, die nicht in den Modi geöffnet `Random` Modus `Seek` legt die Byteposition mit der nächste Vorgang auftritt.</span><span class="sxs-lookup"><span data-stu-id="d705e-2693">For files opened in modes other than `Random` mode, `Seek` sets the byte position at which the next operation occurs.</span></span> <span data-ttu-id="d705e-2694">Angenommen `TestFile` ist eine Datei, die mehrere Textzeilen enthält.</span><span class="sxs-lookup"><span data-stu-id="d705e-2694">Assume `TestFile` is a file that contains several lines of text.</span></span>  
  
 [!code-vb[VbVbalrCatRef#52](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="d705e-2695">Dateimodus ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="d705e-2695">File mode is invalid.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public static void Seek (int FileNumber, long Position);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Seek(int32 FileNumber, int64 Position) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Seek (FileNumber As Integer, Position As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Seek(int FileNumber, long Position);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Position" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="d705e-2696">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-2696">Required.</span></span> <span data-ttu-id="d705e-2697">Ein <see langword="Integer" /> mit einer gültigen Dateinummer.</span><span class="sxs-lookup"><span data-stu-id="d705e-2697">An <see langword="Integer" /> that contains a valid file number.</span></span></param>
        <param name="Position"><span data-ttu-id="d705e-2698">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-2698">Required.</span></span> <span data-ttu-id="d705e-2699">Eine Zahl im Bereich 1-2.147.483.647 einschließlich, die angibt, wo die nächste Lese-/Schreiboperation erfolgen soll.</span><span class="sxs-lookup"><span data-stu-id="d705e-2699">Number in the range 1–2,147,483,647, inclusive, that indicates where the next read/write operation should occur.</span></span></param>
        <summary><span data-ttu-id="d705e-2700">Gibt einen <see langword="Long" />-Wert zurück, der die aktuelle Lese-/Schreibposition innerhalb einer mithilfe der <see langword="FileOpen" />-Funktion geöffneten Datei angibt, oder legt die Position des nächsten Lese-/Schreibvorgangs innerhalb einer mithilfe der <see langword="FileOpen" />-Funktion geöffneten Datei fest.</span><span class="sxs-lookup"><span data-stu-id="d705e-2700">Returns a <see langword="Long" /> specifying the current read/write position in a file opened by using the <see langword="FileOpen" /> function, or sets the position for the next read/write operation in a file opened by using the <see langword="FileOpen" /> function.</span></span> <span data-ttu-id="d705e-2701">Das <see langword="My" />-Feature bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="Seek" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-2701">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Seek" />.</span></span> <span data-ttu-id="d705e-2702">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-2702">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d705e-2703">`Seek` Gibt einen Wert zwischen 1 und 2.147.483.647 (entspricht 2 ^ 31-1), inklusive.</span><span class="sxs-lookup"><span data-stu-id="d705e-2703">`Seek` returns a value between 1 and 2,147,483,647 (equivalent to 2^31 – 1), inclusive.</span></span>  
  
 <span data-ttu-id="d705e-2704">Im folgenden werden die Rückgabewerte für jede Dateizugriffsmodus beschrieben:</span><span class="sxs-lookup"><span data-stu-id="d705e-2704">The following describes the return values for each file access mode:</span></span>  
  
|<span data-ttu-id="d705e-2705">Modus</span><span class="sxs-lookup"><span data-stu-id="d705e-2705">Mode</span></span>|<span data-ttu-id="d705e-2706">Rückgabewert</span><span class="sxs-lookup"><span data-stu-id="d705e-2706">Return Value</span></span>|  
|-|-|  
|`Random`|<span data-ttu-id="d705e-2707">Nummer des nächsten Datensatzes gelesen bzw. geschrieben werden</span><span class="sxs-lookup"><span data-stu-id="d705e-2707">Number of the next record read or written</span></span>|  
|<span data-ttu-id="d705e-2708">`Binary`, `Input`, `Output`, `Append`</span><span class="sxs-lookup"><span data-stu-id="d705e-2708">`Binary`, `Input`, `Output`, `Append`</span></span>|<span data-ttu-id="d705e-2709">Die Byteposition mit der nächste Vorgang auftritt.</span><span class="sxs-lookup"><span data-stu-id="d705e-2709">Byte position at which the next operation occurs.</span></span> <span data-ttu-id="d705e-2710">Das erste Byte in einer Datei befindet sich an Position 1, das zweite Byte an Position 2 usw. ist.</span><span class="sxs-lookup"><span data-stu-id="d705e-2710">The first byte in a file is at position 1, the second byte is at position 2, and so on.</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="d705e-2711">Dieses Beispiel verwendet die `Seek` Funktion, um die aktuelle Dateiposition zurückzugeben.</span><span class="sxs-lookup"><span data-stu-id="d705e-2711">This example uses the `Seek` function to return the current file position.</span></span> <span data-ttu-id="d705e-2712">Das Beispiel setzt voraus `TestFile` ist eine Datei, die Datensätze der Struktur enthält `Record`.</span><span class="sxs-lookup"><span data-stu-id="d705e-2712">The example assumes `TestFile` is a file that contains records of the structure `Record`.</span></span>  
  
 [!code-vb[VbVbalrCatRef#47](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#47)]  
  
 <span data-ttu-id="d705e-2713">Für Dateien in geöffnet `Random` Modus `Seek` gibt die Anzahl des nächsten Datensatzes zurück.</span><span class="sxs-lookup"><span data-stu-id="d705e-2713">For files opened in `Random` mode, `Seek` returns the number of next record.</span></span>  
  
 [!code-vb[VbVbalrCatRef#48](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#48)]  
  
 <span data-ttu-id="d705e-2714">Für Dateien, die nicht in den Modi geöffnet `Random` Modus `Seek` gibt die Byteposition mit der nächste Vorgang auftritt.</span><span class="sxs-lookup"><span data-stu-id="d705e-2714">For files opened in modes other than `Random` mode, `Seek` returns the byte position at which the next operation occurs.</span></span> <span data-ttu-id="d705e-2715">Angenommen `TestFile` ist eine Datei, die mehrere Textzeilen enthält.</span><span class="sxs-lookup"><span data-stu-id="d705e-2715">Assume `TestFile` is a file that contains several lines of text.</span></span>  
  
 [!code-vb[VbVbalrCatRef#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#49)]  
  
 <span data-ttu-id="d705e-2716">Dieses Beispiel verwendet die `Seek` Funktion, positionieren Sie die für den nächsten Lese- oder Schreibvorgang in einer Datei.</span><span class="sxs-lookup"><span data-stu-id="d705e-2716">This example uses the `Seek` function to set the position for the next read or write in a file.</span></span>  
  
 <span data-ttu-id="d705e-2717">Für Dateien, die nicht in den Modi geöffnet `Random` Modus `Seek` legt die Byteposition mit der nächste Vorgang auftritt.</span><span class="sxs-lookup"><span data-stu-id="d705e-2717">For files opened in modes other than `Random` mode, `Seek` sets the byte position at which the next operation occurs.</span></span> <span data-ttu-id="d705e-2718">Angenommen `TestFile` ist eine Datei, die mehrere Textzeilen enthält.</span><span class="sxs-lookup"><span data-stu-id="d705e-2718">Assume `TestFile` is a file that contains several lines of text.</span></span>  
  
 [!code-vb[VbVbalrCatRef#52](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="d705e-2719">Dateimodus ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="d705e-2719">File mode is invalid.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="SetAttr">
      <MemberSignature Language="C#" Value="public static void SetAttr (string PathName, Microsoft.VisualBasic.FileAttribute Attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static void SetAttr(string PathName, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAttr (PathName As String, Attributes As FileAttribute)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetAttr(System::String ^ PathName, Microsoft::VisualBasic::FileAttribute Attributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
        <Parameter Name="Attributes" Type="Microsoft.VisualBasic.FileAttribute" />
      </Parameters>
      <Docs>
        <param name="PathName"><span data-ttu-id="d705e-2720">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-2720">Required.</span></span> <span data-ttu-id="d705e-2721">Ein <see langword="String" />-Ausdruck, der einen Dateinamen angibt.</span><span class="sxs-lookup"><span data-stu-id="d705e-2721"><see langword="String" /> expression that specifies a file name.</span></span> <span data-ttu-id="d705e-2722"><c>PathName</c> kann auch das Verzeichnis oder den Ordner sowie das Laufwerk beinhalten.</span><span class="sxs-lookup"><span data-stu-id="d705e-2722"><c>PathName</c> can include directory or folder, and drive.</span></span></param>
        <param name="Attributes"><span data-ttu-id="d705e-2723">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-2723">Required.</span></span> <span data-ttu-id="d705e-2724">Konstanter oder numerischer Ausdruck, dessen Summe Dateiattribute angibt.</span><span class="sxs-lookup"><span data-stu-id="d705e-2724">Constant or numeric expression, whose sum specifies file attributes.</span></span></param>
        <summary><span data-ttu-id="d705e-2725">Legt Attributinformationen für eine Datei fest.</span><span class="sxs-lookup"><span data-stu-id="d705e-2725">Sets attribute information for a file.</span></span> <span data-ttu-id="d705e-2726">Das <see langword="My" />-Feature bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="SetAttr" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-2726">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="SetAttr" />.</span></span> <span data-ttu-id="d705e-2727">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-2727">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d705e-2728">Ein Laufzeitfehler tritt auf, wenn Sie versuchen, die Attribute einer geöffneten Datei festzulegen.</span><span class="sxs-lookup"><span data-stu-id="d705e-2728">A run-time error occurs if you try to set the attributes of an open file.</span></span>  
  
 <span data-ttu-id="d705e-2729">Die `Attributes` Argument Enumerationswerte sind wie folgt:</span><span class="sxs-lookup"><span data-stu-id="d705e-2729">The `Attributes` argument enumeration values are as follows:</span></span>  
  
|<span data-ttu-id="d705e-2730">Wert</span><span class="sxs-lookup"><span data-stu-id="d705e-2730">Value</span></span>|<span data-ttu-id="d705e-2731">Konstante</span><span class="sxs-lookup"><span data-stu-id="d705e-2731">Constant</span></span>|<span data-ttu-id="d705e-2732">Beschreibung </span><span class="sxs-lookup"><span data-stu-id="d705e-2732">Description</span></span>|  
|-|-|-|  
|`Normal`|`vbNormal`|<span data-ttu-id="d705e-2733">Normal (Standard).</span><span class="sxs-lookup"><span data-stu-id="d705e-2733">Normal (default).</span></span>|  
|`ReadOnly`|`vbReadOnly`|<span data-ttu-id="d705e-2734">Schreibgeschützt.</span><span class="sxs-lookup"><span data-stu-id="d705e-2734">Read-only.</span></span>|  
|`Hidden`|`vbHidden`|<span data-ttu-id="d705e-2735">Ausgeblendet.</span><span class="sxs-lookup"><span data-stu-id="d705e-2735">Hidden.</span></span>|  
|`System`|`vbSystem`|<span data-ttu-id="d705e-2736">Systemdatei.</span><span class="sxs-lookup"><span data-stu-id="d705e-2736">System file.</span></span>|  
|`Volume`|`vbVolume`|<span data-ttu-id="d705e-2737">Volumebezeichnung</span><span class="sxs-lookup"><span data-stu-id="d705e-2737">Volume label</span></span>|  
|`Directory`|`vbDirectory`|<span data-ttu-id="d705e-2738">Verzeichnis oder Ordner.</span><span class="sxs-lookup"><span data-stu-id="d705e-2738">Directory or folder.</span></span>|  
|`Archive`|`vbArchive`|<span data-ttu-id="d705e-2739">Die Datei wurde nach der letzten Sicherung geändert.</span><span class="sxs-lookup"><span data-stu-id="d705e-2739">File has changed since last backup.</span></span>|  
|`Alias`|`vbAlias`|<span data-ttu-id="d705e-2740">Die Datei hat einen anderen Namen.</span><span class="sxs-lookup"><span data-stu-id="d705e-2740">File has a different name.</span></span>|  
  
> [!NOTE]
>  <span data-ttu-id="d705e-2741">Diese Enumerationen werden von der Programmiersprache Visual Basic angegeben.</span><span class="sxs-lookup"><span data-stu-id="d705e-2741">These enumerations are specified by the Visual Basic language.</span></span> <span data-ttu-id="d705e-2742">Die Namen können überall im Code anstelle der eigentlichen Werte verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="d705e-2742">The names can be used anywhere in your code instead of the actual values.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d705e-2743">Dieses Beispiel verwendet die `SetAttr` Funktion, um Attribute für eine Datei festzulegen.</span><span class="sxs-lookup"><span data-stu-id="d705e-2743">This example uses the `SetAttr` function to set attributes for a file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#14](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="d705e-2744"><paramref name="Attribute" />-Typ ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="d705e-2744"><paramref name="Attribute" /> type is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />
      </Docs>
    </Member>
    <Member MemberName="SPC">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.SpcInfo SPC (short Count);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.SpcInfo SPC(int16 Count) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function SPC (Count As Short) As SpcInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::SpcInfo SPC(short Count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.SpcInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Count" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="Count"><span data-ttu-id="d705e-2745">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-2745">Required.</span></span> <span data-ttu-id="d705e-2746">Die Anzahl von Leerzeichen, die vor dem Anzeigen oder Ausgeben des nächsten Ausdrucks in einer Liste eingefügt werden sollen.</span><span class="sxs-lookup"><span data-stu-id="d705e-2746">The number of spaces to insert before displaying or printing the next expression in a list.</span></span></param>
        <summary><span data-ttu-id="d705e-2747">Wird mit der <see langword="Print" />-Funktion oder der <see langword="PrintLine" />-Funktion zum Positionieren der Ausgabe verwendet.</span><span class="sxs-lookup"><span data-stu-id="d705e-2747">Used with the <see langword="Print" /> or <see langword="PrintLine" /> function to position output.</span></span></summary>
        <returns><span data-ttu-id="d705e-2748">Wird mit der <see langword="Print" />-Funktion oder der <see langword="PrintLine" />-Funktion zum Positionieren der Ausgabe verwendet.</span><span class="sxs-lookup"><span data-stu-id="d705e-2748">Used with the <see langword="Print" /> or <see langword="PrintLine" /> function to position output.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d705e-2749">Wenn `Count` ist kleiner als die Breite der Ausgabezeile, sofort der nächste drucken Position die Anzahl von Leerzeichen gedruckter folgt.</span><span class="sxs-lookup"><span data-stu-id="d705e-2749">If `Count` is less than the output line width, the next print position immediately follows the number of spaces printed.</span></span> <span data-ttu-id="d705e-2750">Wenn`Count` ist größer als die Breite einer Ausgabezeile `SPC` wird die nächste drucken Position anhand der Formel berechnet:</span><span class="sxs-lookup"><span data-stu-id="d705e-2750">If`Count` is greater than the output line width, `SPC` calculates the next print position using the formula:</span></span>  
  
 <span data-ttu-id="d705e-2751">`currentprintposition`(+(`Count``Mod``width`))</span><span class="sxs-lookup"><span data-stu-id="d705e-2751">`currentprintposition`(+(`Count``Mod``width`))</span></span>  
  
 <span data-ttu-id="d705e-2752">Beispielsweise ist die aktuelle Position 24, die Breite der Ausgabe beträgt 80, und geben Sie `SPC(90)`, beginnt die nächste Ausgabe an Position 34 (aktuelle drucken Position + die restliche 90/80).</span><span class="sxs-lookup"><span data-stu-id="d705e-2752">For example, if the current print position is 24, the output line width is 80, and you specify `SPC(90)`, the next print will start at position 34 (current print position + the remainder of 90/80).</span></span> <span data-ttu-id="d705e-2753">Wenn unterscheiden sich die aktuelle Position und die Breite der Ausgabe ist kleiner als `Count` (oder `Count` `Mod` *Breite*), wird die `SPC` Funktion am Anfang der nächsten Zeile übersprungen und generiert Leerzeichen gleich `Count` – (*Breite* – *aktuelleAusgabeposition*).</span><span class="sxs-lookup"><span data-stu-id="d705e-2753">If the difference between the current print position and the output line width is less than `Count` (or `Count` `Mod` *width*), the `SPC` function skips to the start of the next line and generates spaces equal to `Count` – (*width* – *currentprintposition*).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d705e-2754">Stellen Sie sicher, dass die tabellarischen Spalten breit genug, um die Breite Buchstaben zu ermöglichen.</span><span class="sxs-lookup"><span data-stu-id="d705e-2754">Make sure your tabular columns are wide enough to allow for wide letters.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d705e-2755">Dieses Beispiel verwendet die `SPC` Funktion zum Positionieren der Ausgabe in eine Datei und die **Ausgabe** Fenster.</span><span class="sxs-lookup"><span data-stu-id="d705e-2755">This example uses the `SPC` function to position output in a file and in the **Output** window.</span></span>  
  
 [!code-vb[VbVbalrCatRef#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="TAB">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d705e-2756">Wird mit der <see langword="Print" />-Funktion oder der <see langword="PrintLine" />-Funktion zum Positionieren der Ausgabe verwendet.</span><span class="sxs-lookup"><span data-stu-id="d705e-2756">Used with the <see langword="Print" /> or <see langword="PrintLine" /> functions to position output.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TAB">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.TabInfo TAB ();" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.TabInfo TAB() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.TAB" />
      <MemberSignature Language="VB.NET" Value="Public Function TAB () As TabInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::TabInfo TAB();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.TabInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d705e-2757">Wird mit der <see langword="Print" />-Funktion oder der <see langword="PrintLine" />-Funktion zum Positionieren der Ausgabe verwendet.</span><span class="sxs-lookup"><span data-stu-id="d705e-2757">Used with the <see langword="Print" /> or <see langword="PrintLine" /> functions to position output.</span></span></summary>
        <returns><span data-ttu-id="d705e-2758">Wird mit der <see langword="Print" />-Funktion oder der <see langword="PrintLine" />-Funktion zum Positionieren der Ausgabe verwendet.</span><span class="sxs-lookup"><span data-stu-id="d705e-2758">Used with the <see langword="Print" /> or <see langword="PrintLine" /> functions to position output.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d705e-2759">Wenn die aktuelle drucken Position in der aktuellen Zeile überschreitet `Column`, `TAB` springt zu der Spaltenwert gleich `Column` in der nächsten Ausgabezeile.</span><span class="sxs-lookup"><span data-stu-id="d705e-2759">If the current print position on the current line is larger than `Column`, `TAB` skips to the column value equal to `Column` on the next output line.</span></span> <span data-ttu-id="d705e-2760">Wenn `Column` ist kleiner als 1, `TAB` verschiebt die Position in Spalte 1.</span><span class="sxs-lookup"><span data-stu-id="d705e-2760">If `Column` is less than 1, `TAB` moves the print position to column 1.</span></span> <span data-ttu-id="d705e-2761">Wenn `Column` ist größer als die Breite einer Ausgabezeile `TAB` wird die nächste drucken Position anhand der Formel berechnet:</span><span class="sxs-lookup"><span data-stu-id="d705e-2761">If `Column` is larger than the output line width, `TAB` calculates the next print position using the formula:</span></span>  
  
 <span data-ttu-id="d705e-2762">Mod Spaltenbreite</span><span class="sxs-lookup"><span data-stu-id="d705e-2762">Column Mod width</span></span>  
  
 <span data-ttu-id="d705e-2763">Z. B. wenn *Breite* beträgt 80, und geben Sie `TAB(90)`, beginnt die nächste Ausgabe in Spalte 10 (der Rest von 90/80).</span><span class="sxs-lookup"><span data-stu-id="d705e-2763">For example, if *width* is 80 and you specify `TAB(90)`, the next print will start at column 10 (the remainder of 90/80).</span></span> <span data-ttu-id="d705e-2764">Wenn `Column` ist kleiner als die aktuelle Position drucken, beginnt die Ausgabe in der nächsten Zeile an der berechneten.</span><span class="sxs-lookup"><span data-stu-id="d705e-2764">If `Column` is less than the current print position, printing starts on the next line at the calculated print position.</span></span> <span data-ttu-id="d705e-2765">Wenn die berechnete Position größer als die aktuelle Position ist, Drucken beginnt die Ausgabe an den berechneten Position in der gleichen Zeile.</span><span class="sxs-lookup"><span data-stu-id="d705e-2765">If the calculated print position is larger than the current print position, printing starts at the calculated print position on the same line.</span></span>  
  
 <span data-ttu-id="d705e-2766">Die am weitesten links stehende Position in einer Ausgabezeile ist immer 1.</span><span class="sxs-lookup"><span data-stu-id="d705e-2766">The leftmost print position on an output line is always 1.</span></span> <span data-ttu-id="d705e-2767">Bei Verwendung der `Print` oder `PrintLine` Funktionen zum Drucken auf Dateien, die äußersten rechten Position ist die aktuelle Breite der Ausgabedatei, die Sie festlegen können, mit der `FileWidth` Funktion.</span><span class="sxs-lookup"><span data-stu-id="d705e-2767">When you use the `Print` or `PrintLine` functions to print to files, the rightmost print position is the current width of the output file, which you can set using the `FileWidth` function.</span></span>  
  
 <span data-ttu-id="d705e-2768">Die `TAB` Funktion kann auch verwendet werden, mit der `WriteLine` Funktion.</span><span class="sxs-lookup"><span data-stu-id="d705e-2768">The `TAB` function can also be used with the `WriteLine` function.</span></span> <span data-ttu-id="d705e-2769">Es kann nicht verwendet werden, mit <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType> oder <xref:System.Console.WriteLine%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="d705e-2769">It cannot be used with <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType> or <xref:System.Console.WriteLine%2A?displayProperty=nameWithType>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d705e-2770">Stellen Sie sicher, dass die tabellarischen Spalten breit genug, um die Breite Buchstaben enthalten.</span><span class="sxs-lookup"><span data-stu-id="d705e-2770">Make sure your tabular columns are wide enough to contain wide letters.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d705e-2771">Dieses Beispiel verwendet die `TAB` Funktion zum Positionieren der Ausgabe in eine Datei und die **Ausgabe** Fenster.</span><span class="sxs-lookup"><span data-stu-id="d705e-2771">This example uses the `TAB` function to position output in a file and in the **Output** window.</span></span>  
  
 [!code-vb[VbVbalrCatRef#37](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#37)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="TAB">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.TabInfo TAB (short Column);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.TabInfo TAB(int16 Column) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.TAB(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function TAB (Column As Short) As TabInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::TabInfo TAB(short Column);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.TabInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Column" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="Column"><span data-ttu-id="d705e-2772">Dies ist optional.</span><span class="sxs-lookup"><span data-stu-id="d705e-2772">Optional.</span></span> <span data-ttu-id="d705e-2773">Die Spaltennummer, zu der vor dem Anzeigen oder Drucken des nächsten Ausdrucks in einer Liste gewechselt wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-2773">The column number moved to before displaying or printing the next expression in a list.</span></span> <span data-ttu-id="d705e-2774">Wenn der Wert nicht angegeben wird, verschiebt <see langword="TAB" /> die Einfügemarke an den Anfang der nächsten Ausgabezone.</span><span class="sxs-lookup"><span data-stu-id="d705e-2774">If omitted, <see langword="TAB" /> moves the insertion point to the start of the next print zone.</span></span></param>
        <summary><span data-ttu-id="d705e-2775">Wird mit der <see langword="Print" />-Funktion oder der <see langword="PrintLine" />-Funktion zum Positionieren der Ausgabe verwendet.</span><span class="sxs-lookup"><span data-stu-id="d705e-2775">Used with the <see langword="Print" /> or <see langword="PrintLine" /> functions to position output.</span></span></summary>
        <returns><span data-ttu-id="d705e-2776">Wird mit der <see langword="Print" />-Funktion oder der <see langword="PrintLine" />-Funktion zum Positionieren der Ausgabe verwendet.</span><span class="sxs-lookup"><span data-stu-id="d705e-2776">Used with the <see langword="Print" /> or <see langword="PrintLine" /> functions to position output.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d705e-2777">Wenn die aktuelle drucken Position in der aktuellen Zeile größer ist `Column`, `TAB` springt zu der Spaltenwert gleich `Column` in der nächsten Ausgabezeile.</span><span class="sxs-lookup"><span data-stu-id="d705e-2777">If the current print position on the current line is greater than `Column`, `TAB` skips to the column value equal to `Column` on the next output line.</span></span> <span data-ttu-id="d705e-2778">Wenn `Column` ist kleiner als 1, `TAB` verschiebt die Position in Spalte 1.</span><span class="sxs-lookup"><span data-stu-id="d705e-2778">If `Column` is less than 1, `TAB` moves the print position to column 1.</span></span> <span data-ttu-id="d705e-2779">Wenn `Column` ist größer als die Breite einer Ausgabezeile `TAB` wird die nächste drucken Position anhand der Formel berechnet:</span><span class="sxs-lookup"><span data-stu-id="d705e-2779">If `Column` is greater than the output line width, `TAB` calculates the next print position using the formula:</span></span>  
  
 <span data-ttu-id="d705e-2780">Mod Spaltenbreite</span><span class="sxs-lookup"><span data-stu-id="d705e-2780">Column Mod width</span></span>  
  
 <span data-ttu-id="d705e-2781">Z. B. wenn *Breite* beträgt 80, und geben Sie `TAB(90)`, beginnt die nächste Ausgabe in Spalte 10 (der Rest von 90/80).</span><span class="sxs-lookup"><span data-stu-id="d705e-2781">For example, if *width* is 80 and you specify `TAB(90)`, the next print will start at column 10 (the remainder of 90/80).</span></span> <span data-ttu-id="d705e-2782">Wenn `Column` ist kleiner als die aktuelle Position drucken, beginnt die Ausgabe in der nächsten Zeile an der berechneten.</span><span class="sxs-lookup"><span data-stu-id="d705e-2782">If `Column` is less than the current print position, printing starts on the next line at the calculated print position.</span></span> <span data-ttu-id="d705e-2783">Ist die berechnete Position größer als die aktuelle Position, Drucken beginnt die Ausgabe an den berechneten Position in der gleichen Zeile ein.</span><span class="sxs-lookup"><span data-stu-id="d705e-2783">If the calculated print position is greater than the current print position, printing starts at the calculated print position on the same line.</span></span>  
  
 <span data-ttu-id="d705e-2784">Die am weitesten links stehende Position in einer Ausgabezeile ist immer 1.</span><span class="sxs-lookup"><span data-stu-id="d705e-2784">The leftmost print position on an output line is always 1.</span></span> <span data-ttu-id="d705e-2785">Bei Verwendung der `Print` oder `PrintLine` Funktionen zum Drucken auf Dateien, die äußersten rechten Position ist die aktuelle Breite der Ausgabedatei, die Sie festlegen können, mit der `FileWidth` Funktion.</span><span class="sxs-lookup"><span data-stu-id="d705e-2785">When you use the `Print` or `PrintLine` functions to print to files, the rightmost print position is the current width of the output file, which you can set using the `FileWidth` function.</span></span>  
  
 <span data-ttu-id="d705e-2786">Die `TAB` Funktion kann auch verwendet werden, mit der `WriteLine` Funktion.</span><span class="sxs-lookup"><span data-stu-id="d705e-2786">The `TAB` function can also be used with the `WriteLine` function.</span></span> <span data-ttu-id="d705e-2787">Es kann nicht verwendet werden, mit <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType> oder <xref:System.Console.WriteLine%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="d705e-2787">It cannot be used with <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType> or <xref:System.Console.WriteLine%2A?displayProperty=nameWithType>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d705e-2788">Stellen Sie sicher, dass die tabellarischen Spalten breit genug, um die Breite Buchstaben enthalten.</span><span class="sxs-lookup"><span data-stu-id="d705e-2788">Make sure your tabular columns are wide enough to contain wide letters.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d705e-2789">Dieses Beispiel verwendet die `TAB` Funktion zum Positionieren der Ausgabe in eine Datei und die **Ausgabe** Fenster.</span><span class="sxs-lookup"><span data-stu-id="d705e-2789">This example uses the `TAB` function to position output in a file and in the **Output** window.</span></span>  
  
 [!code-vb[VbVbalrCatRef#37](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#37)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Unlock">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d705e-2790">Steuert den Zugriff durch andere Prozesse auf die gesamte mithilfe der <see langword="Open" />-Funktion geöffnete Datei oder einen Teil davon.</span><span class="sxs-lookup"><span data-stu-id="d705e-2790">Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function.</span></span> <span data-ttu-id="d705e-2791">Das <see langword="My" />-Feature ermöglicht bei Datei-E/A-Vorgängen höhere Produktivität und Leistung als <see langword="Lock" /> und <see langword="Unlock" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-2791">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />.</span></span> <span data-ttu-id="d705e-2792">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-2792">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="d705e-2793">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-2793">Required.</span></span> <span data-ttu-id="d705e-2794">Eine beliebige gültige Dateinummer.</span><span class="sxs-lookup"><span data-stu-id="d705e-2794">Any valid file number.</span></span></param>
        <summary><span data-ttu-id="d705e-2795">Steuert den Zugriff durch andere Prozesse auf die gesamte mithilfe der <see langword="Open" />-Funktion geöffnete Datei oder einen Teil davon.</span><span class="sxs-lookup"><span data-stu-id="d705e-2795">Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function.</span></span> <span data-ttu-id="d705e-2796">Das <see langword="My" />-Feature ermöglicht bei Datei-E/A-Vorgängen höhere Produktivität und Leistung als <see langword="Lock" /> und <see langword="Unlock" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-2796">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />.</span></span> <span data-ttu-id="d705e-2797">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-2797">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d705e-2798">Die `Lock` und `Unlock` Funktionen in Umgebungen verwendet werden, in denen mehrere Prozesse benötigen möglicherweise Zugriff auf die gleiche Datei.</span><span class="sxs-lookup"><span data-stu-id="d705e-2798">The `Lock` and `Unlock` functions are used in environments where several processes might need access to the same file.</span></span>  
  
 <span data-ttu-id="d705e-2799">`Lock` und `Unlock` Funktionen werden immer paarweise verwendet.</span><span class="sxs-lookup"><span data-stu-id="d705e-2799">`Lock` and `Unlock` functions are always used in pairs.</span></span> <span data-ttu-id="d705e-2800">Die Argumente für `Lock` und `Unlock` müssen identisch sein.</span><span class="sxs-lookup"><span data-stu-id="d705e-2800">The arguments to `Lock` and `Unlock` must be identical.</span></span>  
  
 <span data-ttu-id="d705e-2801">Wenn `Record`, oder `FromRecord` und `ToRecord` sind nicht angegeben wird, wird die Sperre für die gesamte Datei sein.</span><span class="sxs-lookup"><span data-stu-id="d705e-2801">If `Record`, or `FromRecord` and `ToRecord` are not supplied, the lock will be for the whole file.</span></span> <span data-ttu-id="d705e-2802">Wenn `Record` allein entspricht der einzelne Datensatz gesperrt/entsperrt werden.</span><span class="sxs-lookup"><span data-stu-id="d705e-2802">If `Record` alone is specified the single record will be locked/unlocked.</span></span>  
  
 <span data-ttu-id="d705e-2803">Wenn die Datei, für die sequenzielle Eingabe oder Ausgabe geöffnet wurde, `Lock` und `Unlock` Auswirkungen auf die gesamte Datei und unabhängig vom angegebenen Bereich `FromRecord` und`ToRecord`.</span><span class="sxs-lookup"><span data-stu-id="d705e-2803">If the file has been opened for sequential input or output, `Lock` and `Unlock` affect the whole file, regardless of the range specified by `FromRecord` and`ToRecord`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d705e-2804">Dieses Beispiel veranschaulicht die Verwendung der `Lock` und `Unlock` Funktionen.</span><span class="sxs-lookup"><span data-stu-id="d705e-2804">This example illustrates the use of the `Lock` and `Unlock` functions.</span></span> <span data-ttu-id="d705e-2805">In diesem Beispiel wird vorausgesetzt, dass `People.txt` ist eine Datei, die Datensätze der Struktur enthält `Person`.</span><span class="sxs-lookup"><span data-stu-id="d705e-2805">This example assumes that `People.txt` is a file that contains records of the structure `Person`.</span></span>  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="d705e-2806">Dateimodus ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="d705e-2806">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber, long Record);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber, int64 Record) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer, Record As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber, long Record);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Record" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="d705e-2807">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-2807">Required.</span></span> <span data-ttu-id="d705e-2808">Eine beliebige gültige Dateinummer.</span><span class="sxs-lookup"><span data-stu-id="d705e-2808">Any valid file number.</span></span></param>
        <param name="Record"><span data-ttu-id="d705e-2809">Dies ist optional.</span><span class="sxs-lookup"><span data-stu-id="d705e-2809">Optional.</span></span> <span data-ttu-id="d705e-2810">Die Nummer des einzigen zu sperrenden oder zu entsperrenden Datensatzes.</span><span class="sxs-lookup"><span data-stu-id="d705e-2810">Number of the only record or byte to lock or unlock</span></span></param>
        <summary><span data-ttu-id="d705e-2811">Steuert den Zugriff durch andere Prozesse auf die gesamte mithilfe der <see langword="Open" />-Funktion geöffnete Datei oder einen Teil davon.</span><span class="sxs-lookup"><span data-stu-id="d705e-2811">Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function.</span></span> <span data-ttu-id="d705e-2812">Das <see langword="My" />-Feature ermöglicht bei Datei-E/A-Vorgängen höhere Produktivität und Leistung als <see langword="Lock" /> und <see langword="Unlock" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-2812">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />.</span></span> <span data-ttu-id="d705e-2813">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-2813">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d705e-2814">Die `Lock` und `Unlock` Funktionen in Umgebungen verwendet werden, in denen mehrere Prozesse benötigen möglicherweise Zugriff auf die gleiche Datei.</span><span class="sxs-lookup"><span data-stu-id="d705e-2814">The `Lock` and `Unlock` functions are used in environments where several processes might need access to the same file.</span></span>  
  
 <span data-ttu-id="d705e-2815">`Lock` und `Unlock` Funktionen werden immer paarweise verwendet.</span><span class="sxs-lookup"><span data-stu-id="d705e-2815">`Lock` and `Unlock` functions are always used in pairs.</span></span> <span data-ttu-id="d705e-2816">Die Argumente für `Lock` und `Unlock` müssen identisch sein.</span><span class="sxs-lookup"><span data-stu-id="d705e-2816">The arguments to `Lock` and `Unlock` must be identical.</span></span>  
  
 <span data-ttu-id="d705e-2817">Wenn `Record`, oder `FromRecord` und `ToRecord` sind nicht angegeben wird, wird die Sperre für die gesamte Datei sein.</span><span class="sxs-lookup"><span data-stu-id="d705e-2817">If `Record`, or `FromRecord` and `ToRecord` are not supplied, the lock will be for the whole file.</span></span> <span data-ttu-id="d705e-2818">Wenn `Record` allein entspricht der einzelne Datensatz gesperrt/entsperrt werden.</span><span class="sxs-lookup"><span data-stu-id="d705e-2818">If `Record` alone is specified the single record will be locked/unlocked.</span></span>  
  
 <span data-ttu-id="d705e-2819">Wenn die Datei, für die sequenzielle Eingabe oder Ausgabe geöffnet wurde, `Lock` und `Unlock` Auswirkungen auf die gesamte Datei und unabhängig vom angegebenen Bereich `FromRecord` und`ToRecord`.</span><span class="sxs-lookup"><span data-stu-id="d705e-2819">If the file has been opened for sequential input or output, `Lock` and `Unlock` affect the whole file, regardless of the range specified by `FromRecord` and`ToRecord`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d705e-2820">Dieses Beispiel veranschaulicht die Verwendung der `Lock` und `Unlock` Funktionen.</span><span class="sxs-lookup"><span data-stu-id="d705e-2820">This example illustrates the use of the `Lock` and `Unlock` functions.</span></span> <span data-ttu-id="d705e-2821">In diesem Beispiel wird vorausgesetzt, dass `People.txt` ist eine Datei, die Datensätze der Struktur enthält `Person`.</span><span class="sxs-lookup"><span data-stu-id="d705e-2821">This example assumes that `People.txt` is a file that contains records of the structure `Person`.</span></span>  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="d705e-2822">Dateimodus ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="d705e-2822">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber, int64 FromRecord, int64 ToRecord) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer, FromRecord As Long, ToRecord As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber, long FromRecord, long ToRecord);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FromRecord" Type="System.Int64" />
        <Parameter Name="ToRecord" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="d705e-2823">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-2823">Required.</span></span> <span data-ttu-id="d705e-2824">Eine beliebige gültige Dateinummer.</span><span class="sxs-lookup"><span data-stu-id="d705e-2824">Any valid file number.</span></span></param>
        <param name="FromRecord"><span data-ttu-id="d705e-2825">Dies ist optional.</span><span class="sxs-lookup"><span data-stu-id="d705e-2825">Optional.</span></span> <span data-ttu-id="d705e-2826">Die Nummer des ersten zu sperrenden oder zu entsperrenden Datensatzes.</span><span class="sxs-lookup"><span data-stu-id="d705e-2826">Number of the first record or byte to lock or unlock.</span></span></param>
        <param name="ToRecord"><span data-ttu-id="d705e-2827">Dies ist optional.</span><span class="sxs-lookup"><span data-stu-id="d705e-2827">Optional.</span></span> <span data-ttu-id="d705e-2828">Die Nummer des letzten zu sperrenden oder zu entsperrenden Datensatzes.</span><span class="sxs-lookup"><span data-stu-id="d705e-2828">Number of the last record or byte to lock or unlock.</span></span></param>
        <summary><span data-ttu-id="d705e-2829">Steuert den Zugriff durch andere Prozesse auf die gesamte mithilfe der <see langword="Open" />-Funktion geöffnete Datei oder einen Teil davon.</span><span class="sxs-lookup"><span data-stu-id="d705e-2829">Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function.</span></span> <span data-ttu-id="d705e-2830">Das <see langword="My" />-Feature ermöglicht bei Datei-E/A-Vorgängen höhere Produktivität und Leistung als <see langword="Lock" /> und <see langword="Unlock" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-2830">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />.</span></span> <span data-ttu-id="d705e-2831">Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="d705e-2831">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d705e-2832">Die `Lock` und `Unlock` Funktionen in Umgebungen verwendet werden, in denen mehrere Prozesse benötigen möglicherweise Zugriff auf die gleiche Datei.</span><span class="sxs-lookup"><span data-stu-id="d705e-2832">The `Lock` and `Unlock` functions are used in environments where several processes might need access to the same file.</span></span>  
  
 <span data-ttu-id="d705e-2833">`Lock` und `Unlock` Funktionen werden immer paarweise verwendet.</span><span class="sxs-lookup"><span data-stu-id="d705e-2833">`Lock` and `Unlock` functions are always used in pairs.</span></span> <span data-ttu-id="d705e-2834">Die Argumente für `Lock` und `Unlock` müssen identisch sein.</span><span class="sxs-lookup"><span data-stu-id="d705e-2834">The arguments to `Lock` and `Unlock` must be identical.</span></span>  
  
 <span data-ttu-id="d705e-2835">Wenn `Record`, oder `FromRecord` und `ToRecord` sind nicht angegeben wird, wird die Sperre für die gesamte Datei sein.</span><span class="sxs-lookup"><span data-stu-id="d705e-2835">If `Record`, or `FromRecord` and `ToRecord` are not supplied, the lock will be for the whole file.</span></span> <span data-ttu-id="d705e-2836">Wenn `Record` allein entspricht der einzelne Datensatz gesperrt/entsperrt werden.</span><span class="sxs-lookup"><span data-stu-id="d705e-2836">If `Record` alone is specified the single record will be locked/unlocked.</span></span>  
  
 <span data-ttu-id="d705e-2837">Wenn die Datei, für die sequenzielle Eingabe oder Ausgabe geöffnet wurde, `Lock` und `Unlock` Auswirkungen auf die gesamte Datei und unabhängig vom angegebenen Bereich `FromRecord` und`ToRecord`.</span><span class="sxs-lookup"><span data-stu-id="d705e-2837">If the file has been opened for sequential input or output, `Lock` and `Unlock` affect the whole file, regardless of the range specified by `FromRecord` and`ToRecord`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d705e-2838">Dieses Beispiel veranschaulicht die Verwendung der `Lock` und `Unlock` Funktionen.</span><span class="sxs-lookup"><span data-stu-id="d705e-2838">This example illustrates the use of the `Lock` and `Unlock` functions.</span></span> <span data-ttu-id="d705e-2839">In diesem Beispiel wird vorausgesetzt, dass `People.txt` ist eine Datei, die Datensätze der Struktur enthält `Person`.</span><span class="sxs-lookup"><span data-stu-id="d705e-2839">This example assumes that `People.txt` is a file that contains records of the structure `Person`.</span></span>  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="d705e-2840">Dateimodus ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="d705e-2840">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Write(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="d705e-2841">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-2841">Required.</span></span> <span data-ttu-id="d705e-2842">Ein <see langword="Integer" />-Ausdruck, der eine beliebige gültige Dateinummer enthält.</span><span class="sxs-lookup"><span data-stu-id="d705e-2842">An <see langword="Integer" /> expression that contains any valid file number.</span></span></param>
        <param name="Output"><span data-ttu-id="d705e-2843">Dies ist optional.</span><span class="sxs-lookup"><span data-stu-id="d705e-2843">Optional.</span></span> <span data-ttu-id="d705e-2844">Ein Ausdruck oder mehrere, durch Trennzeichen getrennte Ausdrücke, die in eine Datei geschrieben werden sollen.</span><span class="sxs-lookup"><span data-stu-id="d705e-2844">One or more comma-delimited expressions to write to a file.</span></span></param>
        <summary><span data-ttu-id="d705e-2845">Schreibt Daten in eine sequenzielle Datei.</span><span class="sxs-lookup"><span data-stu-id="d705e-2845">Writes data to a sequential file.</span></span> <span data-ttu-id="d705e-2846">Mit <see langword="Write" /> geschriebene Daten werden in der Regel mit <see langword="Input" /> aus einer Datei gelesen.</span><span class="sxs-lookup"><span data-stu-id="d705e-2846">Data written with <see langword="Write" /> is usually read from a file by using <see langword="Input" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d705e-2847">Die `Write` und `WriteLine` Funktionen für Abwärtskompatibilität angeboten werden und die Leistung beeinträchtigen.</span><span class="sxs-lookup"><span data-stu-id="d705e-2847">The `Write` and `WriteLine` functions are provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="d705e-2848">Für nicht-Legacyanwendungen der `My.Computer.FileSystem` Objekt bietet eine bessere Leistung.</span><span class="sxs-lookup"><span data-stu-id="d705e-2848">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="d705e-2849">Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="d705e-2849">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="d705e-2850">Wenn Sie weglassen `Output`, eine leere Zeile in die Datei ausgegeben.</span><span class="sxs-lookup"><span data-stu-id="d705e-2850">If you omit `Output`, a blank line is printed to the file.</span></span> <span data-ttu-id="d705e-2851">Mehrere Ausdrücke können durch ein Komma getrennt werden.</span><span class="sxs-lookup"><span data-stu-id="d705e-2851">Multiple expressions can be separated with a comma.</span></span>  
  
 <span data-ttu-id="d705e-2852">Im Gegensatz zu den `Print` -Funktion, die `Write` -Funktion fügt Kommas zwischen Elementen und Zeichenfolgen in Anführungszeichen ein, wie sie in die Datei geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="d705e-2852">Unlike the `Print` function, the `Write` function inserts commas between items and quotation marks around strings as they are written to the file.</span></span> <span data-ttu-id="d705e-2853">Sie müssen keinen explizite Trennzeichen in der Liste zu platzieren.</span><span class="sxs-lookup"><span data-stu-id="d705e-2853">You do not have to put explicit delimiters in the list.</span></span> <span data-ttu-id="d705e-2854">Wenn `Write` wird verwendet, um das Schreiben von Daten in eine Datei, die nur numerische `Boolean`, Date, Null, und `Error` Datenformate werden unterstützt.</span><span class="sxs-lookup"><span data-stu-id="d705e-2854">When `Write` is used to write data to a file, only numeric, `Boolean`, date, null, and `Error` data formats are supported.</span></span> <span data-ttu-id="d705e-2855">Die folgenden universellen Annahmen werden befolgt werden, damit die Daten immer lesen können, und unter Verwendung ordnungsgemäß interpretiert `Input`unabhängig vom Gebietsschema:</span><span class="sxs-lookup"><span data-stu-id="d705e-2855">The following universal assumptions are followed so the data can always be read and correctly interpreted using `Input`, regardless of locale:</span></span>  
  
-   <span data-ttu-id="d705e-2856">Numerische Daten werden immer geschrieben mithilfe des Punkts als dezimales Trennzeichen.</span><span class="sxs-lookup"><span data-stu-id="d705e-2856">Numeric data is always written using the period as the decimal separator.</span></span>  
  
-   <span data-ttu-id="d705e-2857">Für `Boolean` Daten, entweder `#TRUE#` oder `#FALSE#` gedruckt wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-2857">For `Boolean` data, either `#TRUE#` or `#FALSE#` is printed.</span></span> <span data-ttu-id="d705e-2858">Die `True` und `False` Schlüsselwörter sind unabhängig vom Gebietsschema nicht übersetzt.</span><span class="sxs-lookup"><span data-stu-id="d705e-2858">The `True` and `False` keywords are not translated, regardless of locale.</span></span>  
  
-   <span data-ttu-id="d705e-2859">Datumsdaten werden in die Datei unter Verwendung des universellen Datumsformat geschrieben.</span><span class="sxs-lookup"><span data-stu-id="d705e-2859">Date data is written to the file using the universal date format.</span></span> <span data-ttu-id="d705e-2860">Wenn das Datum oder die Zeitkomponente fehlen oder gleich NULL, so wird nur der Teil werden in die Datei geschrieben.</span><span class="sxs-lookup"><span data-stu-id="d705e-2860">When either the date or the time component is missing or zero, only the part provided is written to the file.</span></span>  
  
-   <span data-ttu-id="d705e-2861">Nichts in die Datei geschrieben wird, wenn `Output` Daten ist leer.</span><span class="sxs-lookup"><span data-stu-id="d705e-2861">Nothing is written to the file if `Output` data is empty.</span></span> <span data-ttu-id="d705e-2862">Beachten Sie jedoch bei null-Daten `#NULL#` geschrieben wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-2862">However, for null data, `#NULL#` is written.</span></span>  
  
-   <span data-ttu-id="d705e-2863">Für `Error` Daten, die Ausgabe angezeigt wird, als `#ERROR errorcode#`.</span><span class="sxs-lookup"><span data-stu-id="d705e-2863">For `Error` data, the output appears as `#ERROR errorcode#`.</span></span> <span data-ttu-id="d705e-2864">Die `Error` Schlüsselwort wird unabhängig vom Gebietsschema nicht übersetzt.</span><span class="sxs-lookup"><span data-stu-id="d705e-2864">The `Error` keyword is not translated, regardless of locale.</span></span>  
  
 <span data-ttu-id="d705e-2865">`WriteLine` Fügt ein neue Zeilenumbruchzeichen (d. h. eine Carriage Return/Line feed, oder `Chr(13) + Chr(10)`), nachdem das letzte Zeichen im geschrieben wurde `Output` in die Datei.</span><span class="sxs-lookup"><span data-stu-id="d705e-2865">`WriteLine` inserts a newline character (that is, a carriage return/line feed, or `Chr(13) + Chr(10)`), after it has written the final character in `Output` to the file.</span></span>  
  
 <span data-ttu-id="d705e-2866">Sie können die Anführungszeichen in einer Zeichenfolge einbetten, durch die Verwendung doppelter Anführungszeichen oder "".</span><span class="sxs-lookup"><span data-stu-id="d705e-2866">You can embed quotation marks in a string by using double quotation marks, or "".</span></span> <span data-ttu-id="d705e-2867">Ein auf ein Objekt angewendeter</span><span class="sxs-lookup"><span data-stu-id="d705e-2867">For example,</span></span>  
  
 [!code-vb[VbVbalrCatRef#63](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#63)]  
  
 <span data-ttu-id="d705e-2868">Gibt eine Zeichenfolge mit dem Wert des `Double quotation marks aren't "difficult" to handle`.</span><span class="sxs-lookup"><span data-stu-id="d705e-2868">returns a string with the value of `Double quotation marks aren't "difficult" to handle`.</span></span>  
  
 <span data-ttu-id="d705e-2869">Schreiben in eine Datei mithilfe der `Write` oder `WriteLine` Funktionen erfordert `Append` aus Zugriff auf die `FileIOPermissionAccess` Enumeration.</span><span class="sxs-lookup"><span data-stu-id="d705e-2869">Writing to a file by using the `Write` or `WriteLine` functions requires `Append` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="d705e-2870">Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="d705e-2870">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess> .</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d705e-2871">Dieses Beispiel verwendet die `Write` Funktion, um Rohdaten in eine sequenzielle Datei schreiben.</span><span class="sxs-lookup"><span data-stu-id="d705e-2871">This example uses the `Write` function to write raw data to a sequential file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#64](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#64)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="d705e-2872">Dateimodus ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="d705e-2872">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void WriteLine(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteLine (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="d705e-2873">Erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d705e-2873">Required.</span></span> <span data-ttu-id="d705e-2874">Ein <see langword="Integer" />-Ausdruck, der eine beliebige gültige Dateinummer enthält.</span><span class="sxs-lookup"><span data-stu-id="d705e-2874">An <see langword="Integer" /> expression that contains any valid file number.</span></span></param>
        <param name="Output"><span data-ttu-id="d705e-2875">Dies ist optional.</span><span class="sxs-lookup"><span data-stu-id="d705e-2875">Optional.</span></span> <span data-ttu-id="d705e-2876">Ein Ausdruck oder mehrere, durch Trennzeichen getrennte Ausdrücke, die in eine Datei geschrieben werden sollen.</span><span class="sxs-lookup"><span data-stu-id="d705e-2876">One or more comma-delimited expressions to write to a file.</span></span></param>
        <summary><span data-ttu-id="d705e-2877">Schreibt Daten in eine sequenzielle Datei.</span><span class="sxs-lookup"><span data-stu-id="d705e-2877">Writes data to a sequential file.</span></span> <span data-ttu-id="d705e-2878">Mit <see langword="Write" /> geschriebene Daten werden in der Regel mit <see langword="Input" /> aus einer Datei gelesen.</span><span class="sxs-lookup"><span data-stu-id="d705e-2878">Data written with <see langword="Write" /> is usually read from a file by using <see langword="Input" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d705e-2879">Die `Write` und `WriteLine` Funktionen für Abwärtskompatibilität angeboten werden und die Leistung beeinträchtigen.</span><span class="sxs-lookup"><span data-stu-id="d705e-2879">The `Write` and `WriteLine` functions are provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="d705e-2880">Für nicht-Legacyanwendungen der `My.Computer.FileSystem` Objekt bietet eine bessere Leistung.</span><span class="sxs-lookup"><span data-stu-id="d705e-2880">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="d705e-2881">Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="d705e-2881">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="d705e-2882">Wenn Sie weglassen `Output`, eine leere Zeile in die Datei ausgegeben.</span><span class="sxs-lookup"><span data-stu-id="d705e-2882">If you omit `Output`, a blank line is printed to the file.</span></span> <span data-ttu-id="d705e-2883">Mehrere Ausdrücke können durch ein Komma getrennt werden.</span><span class="sxs-lookup"><span data-stu-id="d705e-2883">Multiple expressions can be separated with a comma.</span></span>  
  
 <span data-ttu-id="d705e-2884">Im Gegensatz zu den `Print` -Funktion, die `Write` -Funktion fügt Kommas zwischen Elementen und Zeichenfolgen in Anführungszeichen ein, wie sie in die Datei geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="d705e-2884">Unlike the `Print` function, the `Write` function inserts commas between items and quotation marks around strings as they are written to the file.</span></span> <span data-ttu-id="d705e-2885">Sie müssen keinen explizite Trennzeichen in der Liste zu platzieren.</span><span class="sxs-lookup"><span data-stu-id="d705e-2885">You do not have to put explicit delimiters in the list.</span></span> <span data-ttu-id="d705e-2886">Wenn `Write` wird verwendet, um das Schreiben von Daten in eine Datei, die nur numerische `Boolean`, Date, Null, und `Error` Datenformate werden unterstützt.</span><span class="sxs-lookup"><span data-stu-id="d705e-2886">When `Write` is used to write data to a file, only numeric, `Boolean`, date, null, and `Error` data formats are supported.</span></span> <span data-ttu-id="d705e-2887">Die folgenden universellen Annahmen werden befolgt werden, damit die Daten immer lesen können, und unter Verwendung ordnungsgemäß interpretiert `Input`unabhängig vom Gebietsschema:</span><span class="sxs-lookup"><span data-stu-id="d705e-2887">The following universal assumptions are followed so the data can always be read and correctly interpreted using `Input`, regardless of locale:</span></span>  
  
-   <span data-ttu-id="d705e-2888">Numerische Daten werden immer geschrieben mithilfe des Punkts als dezimales Trennzeichen.</span><span class="sxs-lookup"><span data-stu-id="d705e-2888">Numeric data is always written using the period as the decimal separator.</span></span>  
  
-   <span data-ttu-id="d705e-2889">Für `Boolean` Daten, entweder `#TRUE#` oder `#FALSE#` gedruckt wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-2889">For `Boolean` data, either `#TRUE#` or `#FALSE#` is printed.</span></span> <span data-ttu-id="d705e-2890">Die `True` und `False` Schlüsselwörter sind unabhängig vom Gebietsschema nicht übersetzt.</span><span class="sxs-lookup"><span data-stu-id="d705e-2890">The `True` and `False` keywords are not translated, regardless of locale.</span></span>  
  
-   <span data-ttu-id="d705e-2891">Datumsdaten werden in die Datei unter Verwendung des universellen Datumsformat geschrieben.</span><span class="sxs-lookup"><span data-stu-id="d705e-2891">Date data is written to the file using the universal date format.</span></span> <span data-ttu-id="d705e-2892">Wenn das Datum oder die Zeitkomponente fehlen oder gleich NULL, so wird nur der Teil werden in die Datei geschrieben.</span><span class="sxs-lookup"><span data-stu-id="d705e-2892">When either the date or the time component is missing or zero, only the part provided is written to the file.</span></span>  
  
-   <span data-ttu-id="d705e-2893">Nichts in die Datei geschrieben wird, wenn `Output` Daten ist leer.</span><span class="sxs-lookup"><span data-stu-id="d705e-2893">Nothing is written to the file if `Output` data is empty.</span></span> <span data-ttu-id="d705e-2894">Beachten Sie jedoch bei null-Daten `#NULL#` geschrieben wird.</span><span class="sxs-lookup"><span data-stu-id="d705e-2894">However, for null data, `#NULL#` is written.</span></span>  
  
-   <span data-ttu-id="d705e-2895">Für `Error` Daten, die Ausgabe angezeigt wird, als `#ERROR errorcode#`.</span><span class="sxs-lookup"><span data-stu-id="d705e-2895">For `Error` data, the output appears as `#ERROR errorcode#`.</span></span> <span data-ttu-id="d705e-2896">Die `Error` Schlüsselwort wird unabhängig vom Gebietsschema nicht übersetzt.</span><span class="sxs-lookup"><span data-stu-id="d705e-2896">The `Error` keyword is not translated, regardless of locale.</span></span>  
  
 <span data-ttu-id="d705e-2897">`WriteLine` Fügt ein neue Zeilenumbruchzeichen (d. h. eine Carriage Return/Line feed, oder `Chr(13) + Chr(10)`), nachdem das letzte Zeichen im geschrieben wurde `Output` in die Datei.</span><span class="sxs-lookup"><span data-stu-id="d705e-2897">`WriteLine` inserts a newline character (that is, a carriage return/line feed, or `Chr(13) + Chr(10)`), after it has written the final character in `Output` to the file.</span></span>  
  
 <span data-ttu-id="d705e-2898">Sie können die Anführungszeichen in einer Zeichenfolge einbetten, durch die Verwendung doppelter Anführungszeichen oder "".</span><span class="sxs-lookup"><span data-stu-id="d705e-2898">You can embed quotation marks in a string by using double quotation marks, or "".</span></span> <span data-ttu-id="d705e-2899">Ein auf ein Objekt angewendeter</span><span class="sxs-lookup"><span data-stu-id="d705e-2899">For example,</span></span>  
  
 [!code-vb[VbVbalrCatRef#63](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#63)]  
  
 <span data-ttu-id="d705e-2900">Gibt eine Zeichenfolge mit dem Wert des `Double quotation marks aren't "difficult" to handle`.</span><span class="sxs-lookup"><span data-stu-id="d705e-2900">returns a string with the value of `Double quotation marks aren't "difficult" to handle`.</span></span>  
  
 <span data-ttu-id="d705e-2901">Schreiben in eine Datei mithilfe der `Write` oder `WriteLine` Funktionen erfordert `Append` aus Zugriff auf die `FileIOPermissionAccess` Enumeration.</span><span class="sxs-lookup"><span data-stu-id="d705e-2901">Writing to a file by using the `Write` or `WriteLine` functions requires `Append` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="d705e-2902">Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="d705e-2902">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess> .</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d705e-2903">Dieses Beispiel verwendet die `Write` Funktion, um Rohdaten in eine sequenzielle Datei schreiben.</span><span class="sxs-lookup"><span data-stu-id="d705e-2903">This example uses the `Write` function to write raw data to a sequential file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#64](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#64)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
  </Members>
</Type>