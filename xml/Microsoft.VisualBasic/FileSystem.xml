<Type Name="FileSystem" FullName="Microsoft.VisualBasic.FileSystem">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="76423e19c418e3145c1946201eeb07bad53c0200" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39908793" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class FileSystem" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit FileSystem extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.VisualBasic.FileSystem" />
  <TypeSignature Language="VB.NET" Value="Public Module FileSystem" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileSystem sealed" />
  <TypeSignature Language="F#" Value="type FileSystem = class" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic</AssemblyName>
    <AssemblyVersion>7.0.5000.0</AssemblyVersion>
    <AssemblyVersion>8.0.0.0</AssemblyVersion>
    <AssemblyVersion>10.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
      <AttributeName>Microsoft.VisualBasic.CompilerServices.StandardModule</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
      <AttributeName>System.Security.SecurityCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Das <see langword="FileSystem" />-Modul enthält Prozeduren, mit denen Datei-, Verzeichnis- oder Ordner- und Systemoperationen ausgeführt werden. Das <see langword="My" />-Feature ermöglicht bei Datei-E/A-Vorgängen höhere Produktivität und Leistung als bei Verwendung des <see langword="FileSystem" />-Moduls. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Modul unterstützt die Schlüsselwörter von Visual Basic und die Laufzeitbibliothek-Member, die auf Dateien und Ordner zugreifen.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `GetAttr` -Funktion können Sie die Attribute einer Datei und Verzeichnis oder Ordner zu ermitteln.  
  
 [!code-vb[VbVbalrCatRef#25](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#25)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="ChDir">
      <MemberSignature Language="C#" Value="public static void ChDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDir(System::String ^ Path);" />
      <MemberSignature Language="F#" Value="static member ChDir : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.ChDir Path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">Erforderlich. Ein <see langword="String" />-Ausdruck, der das Verzeichnis oder den Ordner bezeichnet, der zum neuen Verzeichnis oder Ordner wird. <c>Path</c> enthält möglicherweise das Laufwerk. Wenn kein Laufwerk angegeben wird, ändert <see langword="ChDir" /> das Standardverzeichnis oder den Ordner in das aktuelle Laufwerk.</param>
        <summary>Ändert das aktuelle Verzeichnis oder den aktuellen Ordner. Das <see langword="My" />-Feature ermöglicht bei Datei-E/A-Vorgängen eine höhere Produktivität und Leistung als die <see langword="ChDir" />-Funktion. Weitere Informationen finden Sie unter <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `ChDir` -Funktion ändert das Standardverzeichnis, aber nicht das Standardlaufwerk. Z. B. wenn das Standard-Laufwerk C ist, die folgende Anweisung ändert sich das Standardverzeichnis auf Laufwerk D, C, bleibt das Standardlaufwerk jedoch:  
  
 [!code-vb[VbVbalrCatRef#39](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#39)]  
  
 Sie können relative machen verzeichnisänderungen wird durch zwei Punkte wie folgt eingeben:  
  
 [!code-vb[VbVbalrCatRef#40](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#40)]  
  
> [!IMPORTANT]
>  Die `ChDir` -Funktion erfordert eine Berechtigung für nicht verwalteten Code, die die Ausführung in teilweise vertrauenswürdigen Umgebungen beeinträchtigen können. Weitere Informationen finden Sie unter <xref:System.Security.Permissions.SecurityPermission> und.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `ChDir` Funktion, um das aktuelle Verzeichnis oder Ordner zu ändern.  
  
 [!code-vb[VbVbalrCatRef#41](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Path" /> ist leer.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Angegebenes Laufwerk ungültig oder nicht verfügbar.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ChDrive">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ändert das aktuelle Laufwerk.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ChDrive">
      <MemberSignature Language="C#" Value="public static void ChDrive (char Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDrive(char Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDrive (Drive As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDrive(char Drive);" />
      <MemberSignature Language="F#" Value="static member ChDrive : char -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.ChDrive Drive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="Drive">Erforderlich. Zeichenfolgenausdruck, der ein vorhandenes Laufwerk angibt. Wenn Sie eine Zeichenfolge der Länge 0 (null) ("") angeben, ändert sich das aktuelle Laufwerk nicht. Wenn das <c>Drive</c>-Argument eine Zeichenfolge mit mehreren Zeichen ist, verwendet <see langword="ChDrive" /> nur den ersten Buchstaben.</param>
        <summary>Ändert das aktuelle Laufwerk.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `ChDrive` -Funktion erfordert eine Berechtigung für nicht verwalteten Code, die die Ausführung in teilweise vertrauenswürdigen Umgebungen beeinträchtigen können. Weitere Informationen finden Sie unter <xref:System.Security.Permissions.SecurityPermission> und [Codezugriffsberechtigungen](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `ChDrive` Funktion, um das aktuelle Laufwerk zu ändern. Die Funktion löst eine Ausnahme aus, wenn das Laufwerk nicht vorhanden ist.  
  
 [!code-vb[VbVbalrCatRef#32](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Angegebenes Laufwerk ungültig oder nicht verfügbar.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="ChDrive">
      <MemberSignature Language="C#" Value="public static void ChDrive (string Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDrive(string Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDrive (Drive As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDrive(System::String ^ Drive);" />
      <MemberSignature Language="F#" Value="static member ChDrive : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.ChDrive Drive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Drive">Erforderlich. Zeichenfolgenausdruck, der ein vorhandenes Laufwerk angibt. Wenn Sie eine Zeichenfolge der Länge 0 (null) ("") angeben, ändert sich das aktuelle Laufwerk nicht. Wenn das <c>Drive</c>-Argument eine Zeichenfolge mit mehreren Zeichen ist, verwendet <see langword="ChDrive" /> nur den ersten Buchstaben.</param>
        <summary>Ändert das aktuelle Laufwerk.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `ChDrive` -Funktion erfordert eine Berechtigung für nicht verwalteten Code, die die Ausführung in teilweise vertrauenswürdigen Umgebungen beeinträchtigen können. Weitere Informationen finden Sie unter <xref:System.Security.Permissions.SecurityPermission> und [Codezugriffsberechtigungen](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `ChDrive` Funktion, um das aktuelle Laufwerk zu ändern. Die Funktion löst eine Ausnahme aus, wenn das Laufwerk nicht vorhanden ist.  
  
 [!code-vb[VbVbalrCatRef#32](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Angegebenes Laufwerk ungültig oder nicht verfügbar.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CurDir">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt eine Zeichenfolge mit dem aktuellen Pfad zurück. Das <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> ermöglicht bei Datei-E/A-Vorgängen höhere Produktivität und Leistung als <see langword="CurDir" />. Weitere Informationen finden Sie unter <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CurDir">
      <MemberSignature Language="C#" Value="public static string CurDir ();" />
      <MemberSignature Language="ILAsm" Value=".method public static string CurDir() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.CurDir" />
      <MemberSignature Language="VB.NET" Value="Public Function CurDir () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CurDir();" />
      <MemberSignature Language="F#" Value="static member CurDir : unit -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.CurDir " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine Zeichenfolge mit dem aktuellen Pfad zurück. Das <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> ermöglicht bei Datei-E/A-Vorgängen höhere Produktivität und Leistung als <see langword="CurDir" />. Weitere Informationen finden Sie unter <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</summary>
        <returns>Eine Zeichenfolge mit dem aktuellen Pfad.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Dieses Beispiel verwendet die `CurDir` Funktion den aktuellen Pfad zurück.  
  
 [!code-vb[VbVbalrCatRef#65](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#65)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <Member MemberName="CurDir">
      <MemberSignature Language="C#" Value="public static string CurDir (char Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static string CurDir(char Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.CurDir(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function CurDir (Drive As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CurDir(char Drive);" />
      <MemberSignature Language="F#" Value="static member CurDir : char -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.CurDir Drive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="Drive">Dies ist optional. Ein <see langword="Char" />-Ausdruck, der ein vorhandenes Laufwerk angibt. Wenn kein Laufwerk angegeben wird oder <c>Drive</c> eine Zeichenfolgen der Länge 0 (null) ("") ist, gibt <see langword="CurDir" /> den Pfad für das aktuelle Laufwerk zurück.</param>
        <summary>Gibt eine Zeichenfolge mit dem aktuellen Pfad zurück. Das <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> ermöglicht bei Datei-E/A-Vorgängen höhere Produktivität und Leistung als <see langword="CurDir" />. Weitere Informationen finden Sie unter <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</summary>
        <returns>Eine Zeichenfolge mit dem aktuellen Pfad.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Dieses Beispiel verwendet die `CurDir` Funktion den aktuellen Pfad zurück.  
  
 [!code-vb[VbVbalrCatRef#65](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#65)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dir">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt eine Zeichenfolge zurück, die den Namen einer Datei, eines Verzeichnisses oder eines Ordners darstellt, der einem bestimmten Muster oder Dateiattribut oder der Volumebezeichnung eines Laufwerks entspricht. Das <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> ermöglicht bei Datei-E/A-Vorgängen höhere Produktivität und Leistung als die <see langword="Dir" />-Funktion. Weitere Informationen finden Sie unter <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dir">
      <MemberSignature Language="C#" Value="public static string Dir ();" />
      <MemberSignature Language="ILAsm" Value=".method public static string Dir() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Dir" />
      <MemberSignature Language="VB.NET" Value="Public Function Dir () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Dir();" />
      <MemberSignature Language="F#" Value="static member Dir : unit -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.Dir " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine Zeichenfolge zurück, die den Namen einer Datei, eines Verzeichnisses oder eines Ordners darstellt, der einem bestimmten Muster oder Dateiattribut oder der Volumebezeichnung eines Laufwerks entspricht. Das <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> ermöglicht bei Datei-E/A-Vorgängen höhere Produktivität und Leistung als die <see langword="Dir" />-Funktion. Weitere Informationen finden Sie unter <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" />.</summary>
        <returns>Eine Zeichenfolge, die den Namen einer Datei, eines Verzeichnisses oder eines Ordners darstellt, der einem bestimmten Muster oder Dateiattribut oder der Volumebezeichnung eines Laufwerks entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Dir` Funktion unterstützt die Verwendung von mehreren Zeichen (`*`) und ein einzelnes Zeichen (`?`) mit Platzhaltern für mehrere Dateien anzugeben.  
  
 `VbVolume` Gibt die Volumebezeichnung des Laufwerks anstelle von einem bestimmten Dateinamen zurück.  
  
 Geben Sie an einer `PathName` beim ersten, die Sie Aufrufen der `Dir` Funktion. Um das nächste Element abzurufen, können Sie, aufeinander folgende Aufrufe der `Dir` Funktion ohne Parameter.  
  
> [!IMPORTANT]
>  Zur fehlerfreien Ausführung der `Dir` -Funktion erfordert die <xref:System.Security.Permissions.FileIOPermissionAccess.Read> und <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery> flags der <xref:System.Security.Permissions.FileIOPermission> der ausgeführte Code erteilt werden. Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermission>, <xref:System.Security.SecurityException>, und [Codezugriffsberechtigungen](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
 Die `Attributes` Argument Enumerationswerte lauten wie folgt:  
  
|Wert|Konstante|Beschreibung |  
|-|-|-|  
|`Normal`|`vbnormal`|Standard Gibt die Dateien ohne Attribute an.|  
|`ReadOnly`|`vbReadOnly`|Gibt an, schreibgeschützte Dateien sowie Dateien ohne Attribute.|  
|`Hidden`|`vbHidden`|Gibt an, alle Dateien, und auch Dateien ohne Attribute.|  
|`System`|`vbSystem`|Gibt an, das Systemdateien und auch Dateien ohne Attribute.|  
|`Volume`|`vbVolume`|Gibt die Volumebezeichnung an. Wenn alle anderen Attribute angegeben wird, `vbVolume` wird ignoriert.|  
|`Directory`|`vbDirectory`|Gibt an, Verzeichnissen oder Ordnern und auch Dateien ohne Attribute.|  
|`Archive`|`vbArchive`|Die Datei wurde nach der letzten Sicherung geändert.|  
|`Alias`|`vbAlias`|Die Datei hat einen anderen Namen.|  
  
> [!NOTE]
>  Diese Enumerationen werden von Visual Basic-Sprache angegeben und können überall in Ihrem Code anstelle der tatsächlichen Werte verwendet werden.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `Dir` Funktion zu überprüfen, ob bestimmte Dateien und Verzeichnisse vorhanden sind.  
  
 [!code-vb[VbVbalrCatRef#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Dir">
      <MemberSignature Language="C#" Value="public static string Dir (string Pathname, Microsoft.VisualBasic.FileAttribute Attributes = Microsoft.VisualBasic.FileAttribute.Normal);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Dir(string Pathname, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)" FrameworkAlternate="netframework-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function Dir (Pathname As String, Optional Attributes As FileAttribute = Microsoft.VisualBasic.FileAttribute.Normal) As String" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="F#" Value="static member Dir : string * Microsoft.VisualBasic.FileAttribute -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.Dir (Pathname, Attributes)" FrameworkAlternate="netframework-2.0" />
      <MemberSignature Language="C#" Value="public static string Dir (string PathName, Microsoft.VisualBasic.FileAttribute Attributes = Microsoft.VisualBasic.FileAttribute.Normal);" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public static string Dir(string PathName, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)" FrameworkAlternate="netframework-1.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="VB.NET" Value="Public Function Dir (PathName As String, Optional Attributes As FileAttribute = Microsoft.VisualBasic.FileAttribute.Normal) As String" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="F#" Value="static member Dir : string * Microsoft.VisualBasic.FileAttribute -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.Dir (PathName, Attributes)" FrameworkAlternate="netframework-1.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Pathname" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1" />
        <Parameter Name="PathName" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
        <Parameter Name="Attributes" Type="Microsoft.VisualBasic.FileAttribute" Index="1" />
      </Parameters>
      <Docs>
        <param name="PathName">Dies ist optional. <see langword="String" />-Ausdruck, der einen Dateinamen, ein Verzeichnis, einen Ordnernamen oder eine Volumebezeichnung des Laufwerks angibt. Eine Zeichenfolge der Länge 0 (null) (<see langword="&quot;&quot;" />) wird zurückgegeben, wenn <c>PathName</c> nicht gefunden wird.</param>
        <param name="Pathname">To be added.</param>
        <param name="Attributes">Dies ist optional. Enumeration oder numerischer Ausdruck, dessen Wert Dateiattribute angibt. Wenn der Wert nicht angegeben wird, gibt <see langword="Dir" /> Dateien zurück, die mit <c>PathName</c> übereinstimmen, aber keine Attribute besitzen.</param>
        <summary>Gibt eine Zeichenfolge zurück, die den Namen einer Datei, eines Verzeichnisses oder eines Ordners darstellt, der einem bestimmten Muster oder Dateiattribut oder der Volumebezeichnung eines Laufwerks entspricht. Das <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> ermöglicht bei Datei-E/A-Vorgängen höhere Produktivität und Leistung als die <see langword="Dir" />-Funktion. Weitere Informationen finden Sie unter <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" />.</summary>
        <returns>Eine Zeichenfolge, die den Namen einer Datei, eines Verzeichnisses oder eines Ordners darstellt, der einem bestimmten Muster oder Dateiattribut oder der Volumebezeichnung eines Laufwerks entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Dir` Funktion unterstützt die Verwendung von mehreren Zeichen (`*`) und ein einzelnes Zeichen (`?`) mit Platzhaltern für mehrere Dateien anzugeben.  
  
 `VbVolume` Gibt die Volumebezeichnung des Laufwerks anstelle von einem bestimmten Dateinamen zurück.  
  
 Geben Sie an einer `PathName` beim ersten, die Sie Aufrufen der `Dir` Funktion. Um das nächste Element abzurufen, können Sie, aufeinander folgende Aufrufe der `Dir` Funktion ohne Parameter.  
  
> [!IMPORTANT]
>  Zur fehlerfreien Ausführung der `Dir` -Funktion erfordert die <xref:System.Security.Permissions.FileIOPermissionAccess.Read> und <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery> flags der <xref:System.Security.Permissions.FileIOPermission> der ausgeführte Code erteilt werden. Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermission>, <xref:System.Security.SecurityException>, und [Codezugriffsberechtigungen](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
 Die `Attributes` Argument Enumerationswerte lauten wie folgt:  
  
|Wert|Konstante|Beschreibung |  
|-|-|-|  
|`Normal`|`vbnormal`|Standard Gibt Dateien an, die keine Attribute aufweisen.|  
|`ReadOnly`|`vbReadOnly`|Gibt an, nur-Lese Dateien zusätzlich zu den Dateien, die keine Attribute aufweisen.|  
|`Hidden`|`vbHidden`|Gibt die versteckte Dateien zusätzlich zu den Dateien, die keine Attribute aufweisen.|  
|`System`|`vbSystem`|Gibt an, der Systemdateien, zusätzlich zu den Dateien, die keine Attribute aufweisen.|  
|`Volume`|`vbVolume`|Gibt die Volumebezeichnung an. Wenn alle anderen Attribute angegeben wird, `vbVolume` wird ignoriert.|  
|`Directory`|`vbDirectory`|Gibt an, Verzeichnissen oder Ordnern, zusätzlich zu den Dateien, die keine Attribute aufweisen.|  
|`Archive`|`vbArchive`|Die Datei wurde nach der letzten Sicherung geändert.|  
|`Alias`|`vbAlias`|Die Datei hat einen anderen Namen.|  
  
> [!NOTE]
>  Diese Enumerationen werden von Visual Basic-Sprache angegeben und können überall in Ihrem Code anstelle von tatsächlichen Werten verwendet werden.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `Dir` Funktion zu überprüfen, ob bestimmte Dateien und Verzeichnisse vorhanden sind.  
  
 [!code-vb[VbVbalrCatRef#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
      </Docs>
    </Member>
    <Member MemberName="EOF">
      <MemberSignature Language="C#" Value="public static bool EOF (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static bool EOF(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function EOF (FileNumber As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool EOF(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member EOF : int -&gt; bool" Usage="Microsoft.VisualBasic.FileSystem.EOF FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Ein <see langword="Integer" /> mit einer beliebigen gültigen Dateinummer.</param>
        <summary>Gibt den booleschen Wert <see langword="True" /> zurück, wenn das Ende einer für <see langword="Random" />- oder sequenziellen <see langword="Input" />-Zugriff geöffneten Datei erreicht wurde.</summary>
        <returns>Gibt den booleschen Wert <see langword="True" /> zurück, wenn das Ende einer für <see langword="Random" />- oder sequenziellen <see langword="Input" />-Zugriff geöffneten Datei erreicht wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwendung `EOF` zur Vermeidung des Fehlers, bei dem Versuch, nach dem Ende einer Datei abrufen von Eingabe-generiert werden.  
  
 Die `EOF` -Funktion zurückgegeben `False` bis Ende der Datei erreicht wurde. Dateien für geöffnet `Random` oder `Binary` Zugriff `EOF` gibt `False` bis zur letzten Ausführung `FileGet` Funktion kann nicht zum Lesen der vollständigen Datensatzes.  
  
 Dateien für geöffnet `Binary` für den Zugriff auf einen Versuch, lesen Sie die Datei mit der `Input` Funktion bis `EOF` gibt `True` wird ein Fehler generiert. Verwenden Sie die `LOF` und `Loc` Funktionen anstelle von `EOF` beim Lesen von Binärdateien mit `Input`, oder verwenden Sie `Get` bei Verwendung der `EOF` Funktion. Dateien für geöffnet `Output`, `EOF` gibt immer `True`.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `EOF` Funktion, um das Ende einer Datei zu erkennen. In diesem Beispiel wird vorausgesetzt, dass `Testfile` ist eine Textdatei, die mehrere Zeilen Text enthält.  
  
 [!code-vb[VbVbalrCatRef#62](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#62)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FileAttr">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.OpenMode FileAttr (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.OpenMode FileAttr(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileAttr (FileNumber As Integer) As OpenMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::OpenMode FileAttr(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member FileAttr : int -&gt; Microsoft.VisualBasic.OpenMode" Usage="Microsoft.VisualBasic.FileSystem.FileAttr FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.OpenMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. <see langword="Integer" /> Eine beliebige gültige Dateinummer.</param>
        <summary>Gibt eine Enumeration zurück, die den Dateimodus für Dateien darstellt, die mit der <see langword="FileOpen" />-Funktion geöffnet wurden. Das <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> ermöglicht bei Datei-E/A-Vorgängen höhere Produktivität und Leistung als die <see langword="FileAttr" />-Funktion. Weitere Informationen finden Sie unter <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />.</summary>
        <returns>Die folgenden Enumerationswerte geben den Dateizugriffsmodus an: 
 <list type="table"><item><term> Wert  </term><description> Modus  </description></item><item><term> 1  </term><description><see langword="OpenMode.Input" /></description></item><item><term> 2  </term><description><see langword="OpenMode.Output" /></description></item><item><term> 4  </term><description><see langword="OpenMode.Random" /></description></item><item><term> 8  </term><description><see langword="OpenMode.Append" /></description></item><item><term> 32  </term><description><see langword="OpenMode.Binary" /></description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Funktion gibt eine Enumeration, die den Dateimodus mit geöffneten Dateien darstellt. die `FileOpen` Funktion.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `FileAttr` Funktion, die den Dateimodus, einer geöffneten Datei zurück.  
  
 [!code-vb[VbVbalrCatRef#46](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#46)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FileClose">
      <MemberSignature Language="C#" Value="public static void FileClose (params int[] FileNumbers);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileClose(int32[] FileNumbers) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileClose (ParamArray FileNumbers As Integer())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileClose(... cli::array &lt;int&gt; ^ FileNumbers);" />
      <MemberSignature Language="F#" Value="static member FileClose : int[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileClose FileNumbers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumbers" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumbers">Dies ist optional. Parameterarray von 0 oder mehr zu schließenden Channels.</param>
        <summary>Schließt die Eingabe/Ausgabe (E/A) für eine Datei, die mit der <see langword="FileOpen" />-Funktion geöffnet wird. <see langword="My" /> ermöglicht bei Datei-E/A-Vorgängen eine höhere Produktivität und Leistung. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `FileClose` -Funktion wird für Abwärtskompatibilität angeboten und die Leistung beeinträchtigen. Für neue Anwendungen die `My.Computer.FileSystem` Objekt bietet eine bessere Leistung. Weitere Informationen finden Sie unter [wie: Lesen von Text aus Dateien mit einem StreamReader](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md),[Vorgehensweise: Schreiben von Text in Dateien mit einem StreamWriter](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md), und [Exemplarische Vorgehensweise: Bearbeiten von Dateien und Verzeichnissen in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories.md).  
  
 Wenn Sie weglassen `FileNumbers`, alle aktive Dateien geöffnet werden, indem die `FileOpen` Funktion geschlossen werden.  
  
 Beim Schließen von Dateien, die für geöffnet wurden `Output` oder `Append`, wird der endgültige Puffer der Ausgabe in die Betriebssystempuffer für diese Datei geschrieben. Alle geschlossenen zugeordnete Pufferspeicher Datei wird veröffentlicht.  
  
 Wenn die `FileClose` Funktion ausgeführt wird, wird die Zuordnung einer Datei mit der Datei Zahl enden.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `FileClose` Funktion, um eine Datei zu schließen, die für geöffnet `Input`.  
  
 [!code-vb[VbVbalrCatRef#69](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#69)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <paramref name="FileNumber" /> ist nicht vorhanden.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Reset" />
      </Docs>
    </Member>
    <Member MemberName="FileCopy">
      <MemberSignature Language="C#" Value="public static void FileCopy (string Source, string Destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileCopy(string Source, string Destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileCopy(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileCopy (Source As String, Destination As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileCopy(System::String ^ Source, System::String ^ Destination);" />
      <MemberSignature Language="F#" Value="static member FileCopy : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileCopy (Source, Destination)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Source" Type="System.String" />
        <Parameter Name="Destination" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Source">Erforderlich. Ein <see langword="String" />-Ausdruck, der den Namen der zu kopierenden Datei angibt. <c>Source</c> kann das Verzeichnis oder den Ordner sowie das Laufwerk der Quelldatei beinhalten.</param>
        <param name="Destination">Erforderlich. Ein <see langword="String" />-Ausdruck, der den Zieldateinamen angibt. <c>Destination</c> kann das Verzeichnis oder den Ordner sowie das Laufwerk der Zieldatei beinhalten.</param>
        <summary>Kopiert eine Datei Das <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> ermöglicht bei Datei-E/A-Vorgängen höhere Produktivität und Leistung als <see langword="FileCopy" />. Weitere Informationen finden Sie unter <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile(System.String,System.String)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie versuchen, Sie verwenden die `FileCopy` funktionieren für eine aktuell geöffneten Datei ein Fehler auftritt.  
  
 `FileCopy` erfordert volle Vertrauenswürdigkeit auf dem lokalen Laufwerk funktioniert.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `FileCopy` Funktion, um eine Datei in ein anderes kopieren. Für dieses Beispiel wird angenommen, dass `SrcFile` ist eine Datei, die Daten enthält.  
  
 [!code-vb[VbVbalrCatRef#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Source" /> oder <paramref name="Destination" /> ist ungültig oder nicht angegeben.</exception>
        <exception cref="T:System.IO.IOException">Datei ist bereits geöffnet.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Datei ist nicht vorhanden.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <Member MemberName="FileDateTime">
      <MemberSignature Language="C#" Value="public static DateTime FileDateTime (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype System.DateTime FileDateTime(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileDateTime (PathName As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime FileDateTime(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member FileDateTime : string -&gt; DateTime" Usage="Microsoft.VisualBasic.FileSystem.FileDateTime PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">Erforderlich. Ein <see langword="String" />-Ausdruck, der einen Dateinamen angibt. <c>PathName</c> kann das Verzeichnis bzw. den Ordner und das Laufwerk enthalten.</param>
        <summary>Gibt einen <see langword="Date" />-Wert zurück, der Datum und Uhrzeit des Schreibvorgangs in einer Datei angibt. Die <see langword="My" />-Funktion bietet eine höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FileDateTime" />. Weitere Informationen finden Sie unter <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" /></summary>
        <returns>Ein <see langword="Date" />-Wert, der Datum und Uhrzeit der Erstellung oder letzten Änderung der Datei angibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Dieses Beispiel verwendet die `FileDateTime` Funktion, um das Datum zu bestimmen und die Uhrzeit einer Datei erstellt oder zuletzt geändert wurde. Das Format des Datums und der angezeigte Uhrzeit basiert auf den gebietsschemaeinstellungen des Systems.  
  
 [!code-vb[VbVbalrCatRef#34](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#34)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="PathName" /> ist ungültig oder enthält Platzhalterzeichen.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Zieldatei ist nicht vorhanden.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FileGet">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Liest Daten aus einer geöffneten Datenträgerdatei in eine Variable ein. Die <see langword="My" />-Funktion bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FileGet" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref bool Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, bool&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Boolean, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="Value">Erforderlich. Der gültige Name einer Variablen, in die Daten gelesen werden.</param>
        <param name="RecordNumber">Dies ist optional. Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), an der der Lesevorgang beginnt.</param>
        <summary>Liest Daten aus einer geöffneten Datenträgerdatei in eine Variable ein. Die <see langword="My" />-Funktion bietet eine höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FileGet" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` gilt nur in `Random` und `Binary` Modus.  
  
 Mit gelesene Daten `FileGet` richtet sich in der Regel in einer Datei mit `FilePut`.  
  
 Der erste Datensatz oder Bytes in eine Datei ist an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 und So weiter. Wenn Sie weglassen `RecordNumber`, den Datensatz bzw. das Byte, die nach der letzten `FileGet` oder `FilePut` Funktion (oder auf die von der letzten gezeigt `Seek` Funktion) gelesen wird.  
  
> [!IMPORTANT]
>  Beim Lesen aus Dateien, nehmen Sie keine Entscheidungen für den Inhalt einer Datei, die anhand der Dateinamenerweiterung. Z. B. möglicherweise eine Datei mit dem Namen "Form1.vb" in einer Visual Basic-Quelldatei nicht.  
  
## <a name="random-mode"></a>Zufällige Modus  
 Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:  
  
-   Wenn die Länge des zu lesenden Daten kleiner als die Länge, die im angegebenen die `RecordLength` -Klausel der `FileOpen` -Funktion `FileGet` liest nachfolgende Datensätze Datensatzlänge. Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt. Da die Menge der Daten der Auffüllung nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen eine gute Idee, die Datensatzlänge die Länge des zu lesenden Daten überein.  
  
-   Standardmäßig ist die Zielvariable eine Zeichenfolge, `FileGet` liest einen 2-Byte-Deskriptor, die Länge der Zeichenfolge enthält, und liest dann die Daten, die in der Variablen wechselt. Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge sein. Visual Basic 6.0 und früheren Versionen unterstützen Zeichenfolgen mit fester Länge. Wenn in einer Datei zu versetzen, wird der Längendeskriptor nicht geschrieben werden. Wenn Sie eine Zeichenfolge ohne den Deskriptor lesen möchten, sollten Sie übergeben `True` auf die `StringIsFixedLength` -Parameter, und die Zeichenfolge, die Sie lesen in muss die richtige Länge.  
  
-   Wenn die Zielvariable ein Array ist, können Sie auswählen, ob einen Deskriptor für die Größe und Dimension des Arrays zu lesen. Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`. Wenn Sie das Array zu lesen, müssen Sie die Möglichkeit zu entsprechen, die das Array geschrieben wurde. Wenn es mit dem Deskriptor geschrieben wurde, müssen Sie den Deskriptor zu lesen. Wenn der Deskriptor nicht verwendet wird, die Größe und die Grenzen des Arrays übergebenen `FileGet` bestimmen, was zu lesen.  
  
     Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang. Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl der Dimensionen: (2 + 8 * NumberOfDimensions). Die Datensatzlänge gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Deskriptor des Arrays zu schreiben. Beispielsweise erfordert die folgende Arraydeklaration 218 Bytes, wenn das Array geschrieben wird auf dem Datenträger.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     Die 218 Bytes werden wie folgt verteilt:  
  
    -   18 Bytes für den Deskriptor: (2 + 8 * 2)  
  
    -   200 Byte für die Daten: (10 * 5 * 4).  
  
-   Wenn die Variable Einlesen in einen anderen Typ von Variablen (keine Zeichenfolge variabler Länge oder ein Objekt), `FileGet` liest nur die Daten die Variablen. Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge der Daten gelesen werden können.  
  
-   `FileGet` liest die Elemente von Strukturen, als ob jedes einzeln gelesen wurden, jedoch keinen Leerraum zwischen den Elementen. Auf dem Datenträger ein dynamisches array, in einem benutzerdefinierten Typ (mit geschriebene `FilePut`) ein Deskriptor, deren Länge 2 plus 8 Mal der Anzahl der Dimensionen gleich, vorangestellt: (2 + 8 * NumberOfDimensions). Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes, die zum Lesen der einzelnen Elemente erforderlich sein. Dies schließt alle Arrays und ihren Deskriptoren. Die `VBFixedString` Attribut angewendet werden kann, Zeichenfolgenfelder in den Strukturen, das die Größe der eine Zeichenfolge, die beim Schreiben auf den Datenträger.  
  
## <a name="binary-mode"></a>Binärmodus  
 Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` Modus Regeln anzuwenden, bis auf einige Ausnahmen. Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:  
  
-   Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen. `FileGet` liest Sie alle Variablen aus dem Datenträger zusammenhängend. d. h. ohne Auffüllung zwischen Datensätzen.  
  
-   Für ein beliebiges Array als ein Array in einer Struktur `FileGet` liest nur die Daten. Es wird kein Deskriptor gelesen.  
  
-   `FileGet` liest die Zeichenfolgen mit variabler Länge, die nicht Elemente der Strukturen sind, ohne die von 2-Byte-Längendeskriptor erwartet werden. Die Anzahl der gelesenen Bytes entspricht die Anzahl der Zeichen, die bereits in der Zeichenfolge.  
  
    > [!IMPORTANT]
    >  Lesen aus einer Datei mithilfe der`FileGet` -Funktion erfordert `Read` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</exception>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref byte Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, unsigned int8&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Byte, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="Value">Erforderlich. Der gültige Name einer Variablen, in die Daten gelesen werden.</param>
        <param name="RecordNumber">Dies ist optional. Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), an der der Lesevorgang beginnt.</param>
        <summary>Liest Daten aus einer geöffneten Datenträgerdatei in eine Variable ein. Die <see langword="My" />-Funktion bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FileGet" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` gilt nur in `Random` und `Binary` Modus.  
  
 Mit gelesene Daten `FileGet` richtet sich in der Regel in einer Datei mit `FilePut`.  
  
 Der erste Datensatz oder Bytes in eine Datei ist an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 und So weiter. Wenn Sie weglassen `RecordNumber`, den Datensatz bzw. das Byte, die nach der letzten `FileGet` oder `FilePut` Funktion (oder auf die von der letzten gezeigt `Seek` Funktion) gelesen wird.  
  
> [!IMPORTANT]
>  Beim Lesen aus Dateien, nehmen Sie keine Entscheidungen für den Inhalt einer Datei, die anhand der Dateinamenerweiterung. Z. B. möglicherweise eine Datei mit dem Namen "Form1.vb" in einer Visual Basic-Quelldatei nicht.  
  
## <a name="random-mode"></a>Zufällige Modus  
 Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:  
  
-   Wenn die Länge des zu lesenden Daten kleiner als die Länge, die im angegebenen die `RecordLength` -Klausel der `FileOpen` -Funktion `FileGet` liest nachfolgende Datensätze Datensatzlänge. Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt. Da die Menge der Daten der Auffüllung nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen eine gute Idee, die Datensatzlänge die Länge des zu lesenden Daten überein.  
  
-   Standardmäßig ist die Zielvariable eine Zeichenfolge, `FileGet` liest einen 2-Byte-Deskriptor, die Länge der Zeichenfolge enthält, und liest dann die Daten, die in der Variablen wechselt. Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge sein. Visual Basic 6.0 und früheren Versionen unterstützen Zeichenfolgen mit fester Länge. Wenn in einer Datei zu versetzen, wird der Längendeskriptor nicht geschrieben werden. Wenn Sie eine Zeichenfolge ohne den Deskriptor lesen möchten, sollten Sie übergeben `True` auf die `StringIsFixedLength` -Parameter, und die Zeichenfolge, die Sie lesen in muss die richtige Länge.  
  
-   Wenn die Zielvariable ein Array ist, können Sie auswählen, ob einen Deskriptor für die Größe und Dimension des Arrays zu lesen. Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`. Wenn Sie das Array zu lesen, müssen Sie die Möglichkeit zu entsprechen, die das Array geschrieben wurde. Wenn es mit dem Deskriptor geschrieben wurde, müssen Sie den Deskriptor zu lesen. Wenn der Deskriptor nicht verwendet wird. Übergeben Sie die Größe und die Grenzen des Arrays in `FileGet` bestimmen, was zu lesen.  
  
     Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang. Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl der Dimensionen: (2 + 8 * NumberOfDimensions). Die Datensatzlänge gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Deskriptor des Arrays zu schreiben. Beispielsweise erfordert die folgende Arraydeklaration 218 Bytes, wenn das Array geschrieben wird auf dem Datenträger.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     Die 218 Bytes werden wie folgt verteilt:  
  
    -   18 Bytes für den Deskriptor: (2 + 8 * 2)  
  
    -   200 Byte für die Daten: (10 * 5 * 4).  
  
-   Wenn die Variable Einlesen in einen anderen Typ von Variablen (keine Zeichenfolge variabler Länge oder ein Objekt), `FileGet` liest nur die Daten die Variablen. Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge der Daten gelesen werden können.  
  
-   `FileGet` liest die Elemente von Strukturen, als ob jedes einzeln gelesen wurden, jedoch keinen Leerraum zwischen den Elementen. Auf dem Datenträger ein dynamisches array, in einem benutzerdefinierten Typ (mit geschriebene `FilePut`) ein Deskriptor, deren Länge 2 plus 8 Mal der Anzahl der Dimensionen gleich, vorangestellt: (2 + 8 * NumberOfDimensions). Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes, die zum Lesen der einzelnen Elemente erforderlich sein. Dies schließt alle Arrays und ihren Deskriptoren. Die `VBFixedString` Attribut angewendet werden kann, Zeichenfolgenfelder in den Strukturen, das die Größe der eine Zeichenfolge, die beim Schreiben auf den Datenträger.  
  
## <a name="binary-mode"></a>Binärmodus  
 Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` Modus Regeln anzuwenden, bis auf einige Ausnahmen. Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:  
  
-   Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen. `FileGet` liest Sie alle Variablen aus dem Datenträger zusammenhängend. d. h. ohne Auffüllung zwischen Datensätzen.  
  
-   Für ein beliebiges Array als ein Array in einer Struktur `FileGet` liest nur die Daten. Es wird kein Deskriptor gelesen.  
  
-   `FileGet` liest die Zeichenfolgen mit variabler Länge, die nicht Elemente der Strukturen sind, ohne die von 2-Byte-Längendeskriptor erwartet werden. Die Anzahl der gelesenen Bytes entspricht die Anzahl der Zeichen, die bereits in der Zeichenfolge.  
  
    > [!IMPORTANT]
    >  Lesen aus einer Datei mithilfe der `FileGet` -Funktion erfordert `Read` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</exception>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref char Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, char&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Char, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="Value">Erforderlich. Der gültige Name einer Variablen, in die Daten gelesen werden.</param>
        <param name="RecordNumber">Dies ist optional. Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), an der der Lesevorgang beginnt.</param>
        <summary>Liest Daten aus einer geöffneten Datenträgerdatei in eine Variable ein. Die <see langword="My" />-Funktion bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FileGet" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` gilt nur in `Random` und `Binary` Modus.  
  
 Mit gelesene Daten `FileGet` richtet sich in der Regel in einer Datei mit `FilePut`.  
  
 Der erste Datensatz oder Bytes in eine Datei ist an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 und So weiter. Wenn Sie weglassen `RecordNumber`, den Datensatz bzw. das Byte, die nach der letzten `FileGet` oder `FilePut` Funktion (oder auf die von der letzten gezeigt `Seek` Funktion) gelesen wird.  
  
> [!IMPORTANT]
>  Beim Lesen aus Dateien, nehmen Sie keine Entscheidungen für den Inhalt einer Datei, die anhand der Dateinamenerweiterung. Z. B. möglicherweise eine Datei mit dem Namen "Form1.vb" in einer Visual Basic-Quelldatei nicht.  
  
## <a name="random-mode"></a>Zufällige Modus  
 Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:  
  
-   Wenn die Länge des zu lesenden Daten kleiner als die Länge, die im angegebenen die `RecordLength` -Klausel der `FileOpen` -Funktion `FileGet` liest nachfolgende Datensätze Datensatzlänge. Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt. Da die Menge der Daten der Auffüllung nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen eine gute Idee, die Datensatzlänge die Länge des zu lesenden Daten überein.  
  
-   Standardmäßig ist die Zielvariable eine Zeichenfolge, `FileGet` liest einen 2-Byte-Deskriptor, die Länge der Zeichenfolge enthält, und liest dann die Daten, die in der Variablen wechselt. Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge sein. Visual Basic 6.0 und früheren Versionen unterstützen Zeichenfolgen mit fester Länge. Wenn in einer Datei zu versetzen, wird der Längendeskriptor nicht geschrieben werden. Wenn Sie eine Zeichenfolge ohne den Deskriptor lesen möchten, sollten Sie übergeben `True` auf die `StringIsFixedLength` -Parameter, und die Zeichenfolge, die Sie lesen in muss die richtige Länge.  
  
-   Wenn die Zielvariable ein Array ist, können Sie auswählen, ob einen Deskriptor für die Größe und Dimension des Arrays zu lesen. Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`. Wenn Sie das Array zu lesen, müssen Sie die Möglichkeit zu entsprechen, die das Array geschrieben wurde. Wenn es mit dem Deskriptor geschrieben wurde, müssen Sie den Deskriptor zu lesen. Wenn der Deskriptor nicht verwendet wird, die Größe und die Grenzen des Arrays übergebenen `FileGet` bestimmen, was zu lesen.  
  
     Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang. Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl der Dimensionen: (2 + 8 * NumberOfDimensions). Die Datensatzlänge gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Deskriptor des Arrays zu schreiben. Beispielsweise erfordert die folgende Arraydeklaration 218 Bytes, wenn das Array geschrieben wird auf dem Datenträger.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     Die 218 Bytes werden wie folgt verteilt:  
  
    -   18 Bytes für den Deskriptor: (2 + 8 * 2)  
  
    -   200 Byte für die Daten: (10 * 5 * 4).  
  
-   Wenn die Variable Einlesen in einen anderen Typ von Variablen (keine Zeichenfolge variabler Länge oder ein Objekt), `FileGet` liest nur die Daten die Variablen. Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge der Daten gelesen werden können.  
  
-   `FileGet` liest die Elemente von Strukturen, als ob jedes einzeln gelesen wurden, jedoch keinen Leerraum zwischen den Elementen. Auf dem Datenträger ein dynamisches array, in einem benutzerdefinierten Typ (mit geschriebene `FilePut`) ein Deskriptor, deren Länge 2 plus 8 Mal der Anzahl der Dimensionen gleich, vorangestellt: (2 + 8 * NumberOfDimensions). Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes, die zum Lesen der einzelnen Elemente erforderlich sein. Dies schließt alle Arrays und ihren Deskriptoren. Die `VBFixedString` Attribut angewendet werden kann, Zeichenfolgenfelder in den Strukturen, das die Größe der eine Zeichenfolge, die beim Schreiben auf den Datenträger.  
  
## <a name="binary-mode"></a>Binärmodus  
 Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` Modus Regeln anzuwenden, bis auf einige Ausnahmen. Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:  
  
-   Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen. `FileGet` liest Sie alle Variablen aus dem Datenträger zusammenhängend. d. h. ohne Auffüllung zwischen Datensätzen.  
  
-   Für ein beliebiges Array als ein Array in einer Struktur `FileGet` liest nur die Daten. Es wird kein Deskriptor gelesen.  
  
-   `FileGet` liest die Zeichenfolgen mit variabler Länge, die nicht Elemente der Strukturen sind, ohne die von 2-Byte-Längendeskriptor erwartet werden. Die Anzahl der gelesenen Bytes entspricht die Anzahl der Zeichen, die bereits in der Zeichenfolge.  
  
    > [!IMPORTANT]
    >  Lesen aus einer Datei mithilfe der `FileGet` -Funktion erfordert `Read` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</exception>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref DateTime Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, valuetype System.DateTime&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As DateTime, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="Value">Erforderlich. Der gültige Name einer Variablen, in die Daten gelesen werden.</param>
        <param name="RecordNumber">Dies ist optional. Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), an der der Lesevorgang beginnt.</param>
        <summary>Liest Daten aus einer geöffneten Datenträgerdatei in eine Variable ein. Die <see langword="My" />-Funktion bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FileGet" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` gilt nur in `Random` und `Binary` Modus.  
  
 Mit gelesene Daten `FileGet` richtet sich in der Regel in einer Datei mit `FilePut`.  
  
 Der erste Datensatz oder Bytes in eine Datei ist an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 und So weiter. Wenn Sie weglassen `RecordNumber`, den Datensatz bzw. das Byte, die nach der letzten `FileGet` oder `FilePut` Funktion (oder auf die von der letzten gezeigt `Seek` Funktion) gelesen wird.  
  
> [!IMPORTANT]
>  Beim Lesen aus Dateien, nehmen Sie keine Entscheidungen für den Inhalt einer Datei, die anhand der Dateinamenerweiterung. Z. B. möglicherweise eine Datei mit dem Namen "Form1.vb" in einer Visual Basic-Quelldatei nicht.  
  
## <a name="random-mode"></a>Zufällige Modus  
 Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:  
  
-   Wenn die Länge des zu lesenden Daten kleiner als die Länge, die im angegebenen die `RecordLength` -Klausel der `FileOpen` -Funktion`FileGet` liest nachfolgende Datensätze Datensatzlänge. Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt. Da die Menge der Daten der Auffüllung nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen eine gute Idee, die Datensatzlänge die Länge des zu lesenden Daten überein.  
  
-   Standardmäßig ist die Zielvariable eine Zeichenfolge, `FileGet` liest einen 2-Byte-Deskriptor, die Länge der Zeichenfolge enthält, und liest dann die Daten, die in der Variablen wechselt. Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge sein. Visual Basic 6.0 und früheren Versionen unterstützen Zeichenfolgen mit fester Länge. Wenn in einer Datei zu versetzen, wird der Längendeskriptor nicht geschrieben werden. Wenn Sie eine Zeichenfolge ohne den Deskriptor lesen möchten, sollten Sie übergeben `True` auf die `StringIsFixedLength` -Parameter, und die Zeichenfolge, die Sie lesen in muss die richtige Länge.  
  
-   Wenn die Zielvariable ein Array ist, können Sie auswählen, ob einen Deskriptor für die Größe und Dimension des Arrays zu lesen. Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`. Wenn Sie das Array zu lesen, müssen Sie die Möglichkeit zu entsprechen, die das Array geschrieben wurde. Wenn es mit dem Deskriptor geschrieben wurde, müssen Sie den Deskriptor zu lesen. Wenn der Deskriptor nicht verwendet wird, die Größe und die Grenzen des Arrays übergebenen `FileGet` bestimmen, was zu lesen.  
  
     Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang. Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl der Dimensionen: (2 + 8 * NumberOfDimensions). Die Datensatzlänge gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Deskriptor des Arrays zu schreiben. Beispielsweise erfordert die folgende Arraydeklaration 218 Bytes, wenn das Array geschrieben wird auf dem Datenträger.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     Die 218 Bytes werden wie folgt verteilt:  
  
    -   18 Bytes für den Deskriptor: (2 + 8 * 2)  
  
    -   200 Byte für die Daten: (10 * 5 * 4).  
  
-   Wenn die Variable Einlesen in einen anderen Typ von Variablen (keine Zeichenfolge variabler Länge oder ein Objekt), `FileGet` liest nur die Daten die Variablen. Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge der Daten gelesen werden können.  
  
-   `FileGet` liest die Elemente von Strukturen, als ob jedes einzeln gelesen wurden, jedoch keinen Leerraum zwischen den Elementen. Auf dem Datenträger ein dynamisches array, in einem benutzerdefinierten Typ (mit geschriebene `FilePut`) ein Deskriptor, deren Länge 2 plus 8 Mal der Anzahl der Dimensionen gleich, vorangestellt: (2 + 8 * NumberOfDimensions). Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes, die zum Lesen der einzelnen Elemente erforderlich sein. Dies schließt alle Arrays und ihren Deskriptoren. Die `VBFixedString` Attribut angewendet werden kann, Zeichenfolgenfelder in den Strukturen, das die Größe der eine Zeichenfolge, die beim Schreiben auf den Datenträger.  
  
## <a name="binary-mode"></a>Binärmodus  
 Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` Modus Regeln anzuwenden, bis auf einige Ausnahmen. Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:  
  
-   Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen. `FileGet` liest Sie alle Variablen aus dem Datenträger zusammenhängend. d. h. ohne Auffüllung zwischen Datensätzen.  
  
-   Für ein beliebiges Array als ein Array in einer Struktur `FileGet` liest nur die Daten. Es wird kein Deskriptor gelesen.  
  
-   `FileGet` liest die Zeichenfolgen mit variabler Länge, die nicht Elemente der Strukturen sind, ohne die von 2-Byte-Längendeskriptor erwartet werden. Die Anzahl der gelesenen Bytes entspricht die Anzahl der Zeichen, die bereits in der Zeichenfolge.  
  
    > [!IMPORTANT]
    >  Lesen aus einer Datei mithilfe der `FileGet` -Funktion erfordert `Read` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</exception>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref decimal Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, valuetype System.Decimal&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Decimal, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="Value">Erforderlich. Der gültige Name einer Variablen, in die Daten gelesen werden.</param>
        <param name="RecordNumber">Dies ist optional. Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), an der der Lesevorgang beginnt.</param>
        <summary>Liest Daten aus einer geöffneten Datenträgerdatei in eine Variable ein. Die <see langword="My" />-Funktion bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FileGet" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` gilt nur in `Random` und `Binary` Modus.  
  
 Mit gelesene Daten `FileGet` in der Regel in eine Datei geschrieben wird, mithilfe von `FilePut`.  
  
 Der erste Datensatz oder Bytes in eine Datei ist an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 und So weiter. Wenn Sie weglassen `RecordNumber`, den Datensatz bzw. das Byte, die nach der letzten `FileGet` oder `FilePut` Funktion (oder auf die von der letzten gezeigt `Seek` Funktion) gelesen wird.  
  
> [!IMPORTANT]
>  Beim Lesen aus Dateien, nehmen Sie keine Entscheidungen für den Inhalt einer Datei, die anhand der Dateinamenerweiterung. Z. B. möglicherweise eine Datei mit dem Namen "Form1.vb" in einer Visual Basic-Quelldatei nicht.  
  
## <a name="random-mode"></a>Zufällige Modus  
 Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:  
  
-   Wenn die Länge des zu lesenden Daten kleiner als die Länge, die im angegebenen die `RecordLength` -Klausel der `FileOpen` -Funktion `FileGet` liest nachfolgende Datensätze Datensatzlänge. Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt. Da die Menge der Daten der Auffüllung nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen eine gute Idee, die Datensatzlänge die Länge des zu lesenden Daten überein.  
  
-   Standardmäßig ist die Zielvariable eine Zeichenfolge, `FileGet` liest einen 2-Byte-Deskriptor, die Länge der Zeichenfolge enthält, und liest dann die Daten, die in der Variablen wechselt. Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge sein. Visual Basic 6.0 und früheren Versionen unterstützen Zeichenfolgen mit fester Länge. Wenn in einer Datei zu versetzen, wird der Längendeskriptor nicht geschrieben werden. Wenn Sie eine Zeichenfolge ohne den Deskriptor lesen möchten, sollten Sie übergeben `True` auf die `StringIsFixedLength` -Parameter, und die Zeichenfolge, die Sie lesen in muss die richtige Länge.  
  
-   Wenn die Zielvariable ein Array ist, können Sie auswählen, ob einen Deskriptor für die Größe und Dimension des Arrays zu lesen. Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`. Wenn Sie das Array zu lesen, müssen Sie die Möglichkeit zu entsprechen, die das Array geschrieben wurde. Wenn es mit dem Deskriptor geschrieben wurde, müssen Sie den Deskriptor zu lesen. Wenn der Deskriptor nicht verwendet wird, die Größe und die Grenzen des Arrays übergebenen `FileGet` bestimmen, was zu lesen.  
  
     Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang. Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl der Dimensionen: (2 + 8 * NumberOfDimensions). Die Datensatzlänge gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Deskriptor des Arrays zu schreiben. Beispielsweise erfordert die folgende Arraydeklaration 218 Bytes, wenn das Array geschrieben wird auf dem Datenträger.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     Die 218 Bytes werden wie folgt verteilt:  
  
    -   18 Bytes für den Deskriptor: (2 + 8 * 2)  
  
    -   200 Byte für die Daten: (10 * 5 * 4).  
  
-   Wenn die Variable Einlesen in einen anderen Typ von Variablen (keine Zeichenfolge variabler Länge oder ein Objekt), `FileGet` liest nur die Daten die Variablen. Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge der Daten gelesen werden können.  
  
-   `FileGet` liest die Elemente von Strukturen, als ob jedes einzeln gelesen wurden, jedoch keinen Leerraum zwischen den Elementen. Auf dem Datenträger ein dynamisches array, in einem benutzerdefinierten Typ (mit geschriebene `FilePut`) ein Deskriptor, deren Länge 2 plus 8 Mal der Anzahl der Dimensionen gleich, vorangestellt: (2 + 8 * NumberOfDimensions). Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes, die zum Lesen der einzelnen Elemente erforderlich sein. Dies schließt alle Arrays und ihren Deskriptoren. Die `VBFixedString` Attribut angewendet werden kann, Zeichenfolgenfelder in den Strukturen, das die Größe der eine Zeichenfolge, die beim Schreiben auf den Datenträger.  
  
## <a name="binary-mode"></a>Binärmodus  
 Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` Modus Regeln anzuwenden, bis auf einige Ausnahmen. Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:  
  
-   Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen. `FileGet` liest Sie alle Variablen aus dem Datenträger zusammenhängend. d. h. ohne Auffüllung zwischen Datensätzen.  
  
-   Für ein beliebiges Array als ein Array in einer Struktur `FileGet` liest nur die Daten. Es wird kein Deskriptor gelesen.  
  
-   `FileGet` liest die Zeichenfolgen mit variabler Länge, die nicht Elemente der Strukturen sind, ohne die von 2-Byte-Längendeskriptor erwartet werden. Die Anzahl der gelesenen Bytes entspricht die Anzahl der Zeichen, die bereits in der Zeichenfolge.  
  
    > [!IMPORTANT]
    >  Lesen aus einer Datei mithilfe der `FileGet` -Funktion erfordert `Read` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</exception>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref double Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, float64&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Double, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="Value">Erforderlich. Der gültige Name einer Variablen, in die Daten gelesen werden.</param>
        <param name="RecordNumber">Dies ist optional. Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), an der der Lesevorgang beginnt.</param>
        <summary>Liest Daten aus einer geöffneten Datenträgerdatei in eine Variable ein. Die <see langword="My" />-Funktion bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FileGet" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` gilt nur in `Random` und `Binary` Modus.  
  
 Mit gelesene Daten `FileGet` in der Regel in eine Datei geschrieben wird, mithilfe von `FilePut`.  
  
 Der erste Datensatz oder Bytes in eine Datei ist an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 und So weiter. Wenn Sie weglassen `RecordNumber`, den Datensatz bzw. das Byte, die nach der letzten `FileGet` oder `FilePut` Funktion (oder auf die von der letzten gezeigt `Seek` Funktion) gelesen wird.  
  
> [!IMPORTANT]
>  Beim Lesen aus Dateien, nehmen Sie keine Entscheidungen für den Inhalt einer Datei, die anhand der Dateinamenerweiterung. Z. B. möglicherweise eine Datei mit dem Namen "Form1.vb" in einer Visual Basic-Quelldatei nicht.  
  
## <a name="random-mode"></a>Zufällige Modus  
 Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:  
  
-   Wenn die Länge des zu lesenden Daten kleiner als die Länge, die im angegebenen die `RecordLength` -Klausel der `FileOpen` -Funktion `FileGet` liest nachfolgende Datensätze Datensatzlänge. Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt. Da die Menge der Daten der Auffüllung nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen eine gute Idee, die Datensatzlänge die Länge des zu lesenden Daten überein.  
  
-   Standardmäßig ist die Zielvariable eine Zeichenfolge, `FileGet` liest einen 2-Byte-Deskriptor, die Länge der Zeichenfolge enthält, und liest dann die Daten, die in der Variablen wechselt. Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge sein. Visual Basic 6.0 und früheren Versionen unterstützen Zeichenfolgen mit fester Länge. Wenn in einer Datei zu versetzen, wird der Längendeskriptor nicht geschrieben werden. Wenn Sie eine Zeichenfolge ohne den Deskriptor lesen möchten, sollten Sie übergeben `True` auf die `StringIsFixedLength` -Parameter, und die Zeichenfolge, die Sie lesen in muss die richtige Länge.  
  
-   Wenn die Zielvariable ein Array ist, können Sie auswählen, ob einen Deskriptor für die Größe und Dimension des Arrays zu lesen. Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`. Wenn Sie das Array zu lesen, müssen Sie die Möglichkeit zu entsprechen, die das Array geschrieben wurde. Wenn es mit dem Deskriptor geschrieben wurde, müssen Sie den Deskriptor zu lesen. Wenn der Deskriptor nicht verwendet wird, die Größe und die Grenzen des Arrays übergebenen `FileGet` bestimmen, was zu lesen.  
  
     Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang. Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl der Dimensionen: (2 + 8 * NumberOfDimensions). Die Datensatzlänge gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Deskriptor des Arrays zu schreiben. Beispielsweise erfordert die folgende Arraydeklaration 218 Bytes, wenn das Array geschrieben wird auf dem Datenträger.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     Die 218 Bytes werden wie folgt verteilt:  
  
    -   18 Bytes für den Deskriptor: (2 + 8 * 2)  
  
    -   200 Byte für die Daten: (10 * 5 * 4).  
  
-   Wenn die Variable Einlesen in einen anderen Typ von Variablen (keine Zeichenfolge variabler Länge oder ein Objekt), `FileGet` liest nur die Daten die Variablen. Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge der Daten gelesen werden können.  
  
-   `FileGet` liest die Elemente von Strukturen, als ob jedes einzeln gelesen wurden, jedoch keinen Leerraum zwischen den Elementen. Auf dem Datenträger ein dynamisches array, in einem benutzerdefinierten Typ (mit geschriebene `FilePut`) ein Deskriptor, deren Länge 2 plus 8 Mal der Anzahl der Dimensionen gleich, vorangestellt: (2 + 8 * NumberOfDimensions). Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes, die zum Lesen der einzelnen Elemente erforderlich sein. Dies schließt alle Arrays und ihren Deskriptoren. Die `VBFixedString` Attribut angewendet werden kann, Zeichenfolgenfelder in den Strukturen, das die Größe der eine Zeichenfolge, die beim Schreiben auf den Datenträger.  
  
## <a name="binary-mode"></a>Binärmodus  
 Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` Modus Regeln anzuwenden, bis auf einige Ausnahmen. Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:  
  
-   Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen. `FileGet` liest Sie alle Variablen aus dem Datenträger zusammenhängend. d. h. ohne Auffüllung zwischen Datensätzen.  
  
-   Für ein beliebiges Array als ein Array in einer Struktur `FileGet` liest nur die Daten. Es wird kein Deskriptor gelesen.  
  
-   `FileGet` liest die Zeichenfolgen mit variabler Länge, die nicht Elemente der Strukturen sind, ohne die von 2-Byte-Längendeskriptor erwartet werden. Die Anzahl der gelesenen Bytes entspricht die Anzahl der Zeichen, die bereits in der Zeichenfolge.  
  
    > [!IMPORTANT]
    >  Lesen aus einer Datei mithilfe der`FileGet` -Funktion erfordert `Read` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</exception>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref short Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int16&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Short, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="Value">Erforderlich. Der gültige Name einer Variablen, in die Daten gelesen werden.</param>
        <param name="RecordNumber">Dies ist optional. Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), an der der Lesevorgang beginnt.</param>
        <summary>Liest Daten aus einer geöffneten Datenträgerdatei in eine Variable ein. Die <see langword="My" />-Funktion bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FileGet" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` gilt nur in `Random` und `Binary` Modus.  
  
 Mit gelesene Daten `FileGet` in der Regel in eine Datei geschrieben wird, mithilfe von `FilePut`.  
  
 Der erste Datensatz oder Bytes in eine Datei ist an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 und So weiter. Wenn Sie weglassen `RecordNumber`, den Datensatz bzw. das Byte, die nach der letzten `FileGet` oder `FilePut` Funktion (oder auf die von der letzten gezeigt `Seek` Funktion) gelesen wird.  
  
> [!IMPORTANT]
>  Beim Lesen aus Dateien, nehmen Sie keine Entscheidungen für den Inhalt einer Datei, die anhand der Dateinamenerweiterung. Z. B. möglicherweise eine Datei mit dem Namen "Form1.vb" in einer Visual Basic-Quelldatei nicht.  
  
## <a name="random-mode"></a>Zufällige Modus  
 Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:  
  
-   Wenn die Länge des zu lesenden Daten kleiner als die Länge, die im angegebenen die `RecordLength` -Klausel der `FileOpen` -Funktion `FileGet` liest nachfolgende Datensätze Datensatzlänge. Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt. Da die Menge der Daten der Auffüllung nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen eine gute Idee, die Datensatzlänge die Länge des zu lesenden Daten überein.  
  
-   Standardmäßig ist die Zielvariable eine Zeichenfolge, `FileGet` liest einen 2-Byte-Deskriptor, die Länge der Zeichenfolge enthält, und liest dann die Daten, die in der Variablen wechselt. Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge sein. Visual Basic 6.0 und früheren Versionen unterstützen Zeichenfolgen mit fester Länge. Wenn in einer Datei zu versetzen, wird der Längendeskriptor nicht geschrieben werden. Wenn Sie eine Zeichenfolge ohne den Deskriptor lesen möchten, sollten Sie übergeben `True` auf die `StringIsFixedLength` -Parameter, und die Zeichenfolge, die Sie lesen in muss die richtige Länge.  
  
-   Wenn die Zielvariable ein Array ist, können Sie auswählen, ob einen Deskriptor für die Größe und Dimension des Arrays zu lesen. Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`. Wenn Sie das Array zu lesen, müssen Sie die Möglichkeit zu entsprechen, die das Array geschrieben wurde. Wenn es mit dem Deskriptor geschrieben wurde, müssen Sie den Deskriptor zu lesen. Wenn der Deskriptor nicht verwendet wird, die Größe und die Grenzen des Arrays übergebenen `FileGet` bestimmen, was zu lesen.  
  
     Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang. Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl der Dimensionen: (2 + 8 * NumberOfDimensions). Die Datensatzlänge gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Deskriptor des Arrays zu schreiben. Beispielsweise erfordert die folgende Arraydeklaration 218 Bytes, wenn das Array geschrieben wird auf dem Datenträger.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     Die 218 Bytes werden wie folgt verteilt:  
  
    -   18 Bytes für den Deskriptor: (2 + 8 * 2)  
  
    -   200 Byte für die Daten: (10 * 5 * 4).  
  
-   Wenn die Variable Einlesen in einen anderen Typ von Variablen (keine Zeichenfolge variabler Länge oder ein Objekt), `FileGet` liest nur die Daten die Variablen. Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge der Daten gelesen werden können.  
  
-   `FileGet` liest die Elemente von Strukturen, als ob jedes einzeln gelesen wurden, jedoch keinen Leerraum zwischen den Elementen. Auf dem Datenträger ein dynamisches array, in einem benutzerdefinierten Typ (mit geschriebene `FilePut`) ein Deskriptor, deren Länge 2 plus 8 Mal der Anzahl der Dimensionen gleich, vorangestellt: (2 + 8 * NumberOfDimensions). Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes, die zum Lesen der einzelnen Elemente erforderlich sein. Dies schließt alle Arrays und ihren Deskriptoren. Die `VBFixedString` Attribut angewendet werden kann, Zeichenfolgenfelder in den Strukturen, das die Größe der eine Zeichenfolge, die beim Schreiben auf den Datenträger.  
  
## <a name="binary-mode"></a>Binärmodus  
 Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` Modus Regeln anzuwenden, bis auf einige Ausnahmen. Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:  
  
-   Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen. `FileGet` liest Sie alle Variablen aus dem Datenträger zusammenhängend. d. h. ohne Auffüllung zwischen Datensätzen.  
  
-   Für ein beliebiges Array als ein Array in einer Struktur `FileGet` liest nur die Daten. Es wird kein Deskriptor gelesen.  
  
-   `FileGet` liest die Zeichenfolgen mit variabler Länge, die nicht Elemente der Strukturen sind, ohne die von 2-Byte-Längendeskriptor erwartet werden. Die Anzahl der gelesenen Bytes entspricht die Anzahl der Zeichen, die bereits in der Zeichenfolge.  
  
    > [!IMPORTANT]
    >  Lesen aus einer Datei mithilfe der `FileGet` -Funktion erfordert `Read` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</exception>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref int Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int32&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Integer, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="Value">Erforderlich. Der gültige Name einer Variablen, in die Daten gelesen werden.</param>
        <param name="RecordNumber">Dies ist optional. Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), an der der Lesevorgang beginnt.</param>
        <summary>Liest Daten aus einer geöffneten Datenträgerdatei in eine Variable ein. Die <see langword="My" />-Funktion bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FileGet" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` gilt nur in `Random` und `Binary` Modus.  
  
 Mit gelesene Daten `FileGet` in der Regel in eine Datei geschrieben wird, mithilfe von `FilePut`.  
  
 Der erste Datensatz oder Bytes in eine Datei ist an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 und So weiter. Wenn Sie weglassen `RecordNumber`, den Datensatz bzw. das Byte, die nach der letzten `FileGet` oder `FilePut` Funktion (oder auf die von der letzten gezeigt `Seek` Funktion) gelesen wird.  
  
> [!IMPORTANT]
>  Beim Lesen aus Dateien, nehmen Sie keine Entscheidungen für den Inhalt einer Datei, die anhand der Dateinamenerweiterung. Z. B. möglicherweise eine Datei mit dem Namen "Form1.vb" in einer Visual Basic-Quelldatei nicht.  
  
## <a name="random-mode"></a>Zufällige Modus  
 Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:  
  
-   Wenn die Länge des zu lesenden Daten kleiner als die Länge, die im angegebenen die `RecordLength` -Klausel der `FileOpen` -Funktion `FileGet` liest nachfolgende Datensätze Datensatzlänge. Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt. Da die Menge der Daten der Auffüllung nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen eine gute Idee, die Datensatzlänge die Länge des zu lesenden Daten überein.  
  
-   Standardmäßig ist die Zielvariable eine Zeichenfolge, `FileGet` liest einen 2-Byte-Deskriptor, die Länge der Zeichenfolge enthält, und liest dann die Daten, die in der Variablen wechselt. Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge sein. Visual Basic 6.0 und früheren Versionen unterstützen Zeichenfolgen mit fester Länge. Wenn in einer Datei zu versetzen, wird der Längendeskriptor nicht geschrieben werden. Wenn Sie eine Zeichenfolge ohne den Deskriptor lesen möchten, sollten Sie übergeben `True` auf die `StringIsFixedLength` -Parameter, und die Zeichenfolge, die Sie lesen in muss die richtige Länge.  
  
-   Wenn die Zielvariable ein Array ist, können Sie auswählen, ob einen Deskriptor für die Größe und Dimension des Arrays zu lesen. Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`. Wenn Sie das Array zu lesen, müssen Sie die Möglichkeit zu entsprechen, die das Array geschrieben wurde. Wenn es mit dem Deskriptor geschrieben wurde, müssen Sie den Deskriptor zu lesen. Wenn der Deskriptor nicht verwendet wird, die Größe und die Grenzen des Arrays übergebenen `FileGet` bestimmen, was zu lesen.  
  
     Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang. Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl der Dimensionen: (2 + 8 * NumberOfDimensions). Die Datensatzlänge gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Deskriptor des Arrays zu schreiben. Beispielsweise erfordert die folgende Arraydeklaration 218 Bytes, wenn das Array geschrieben wird auf dem Datenträger.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     Die 218 Bytes werden wie folgt verteilt:  
  
    -   18 Bytes für den Deskriptor: (2 + 8 * 2)  
  
    -   200 Byte für die Daten: (10 * 5 * 4).  
  
-   Wenn die Variable Einlesen in einen anderen Typ von Variablen (keine Zeichenfolge variabler Länge oder ein Objekt), `FileGet` liest nur die Daten die Variablen. Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge der Daten gelesen werden können.  
  
-   `FileGet` liest die Elemente von Strukturen, als ob jedes einzeln gelesen wurden, jedoch keinen Leerraum zwischen den Elementen. Auf dem Datenträger ein dynamisches array, in einem benutzerdefinierten Typ (mit geschriebene `FilePut`) ein Deskriptor, deren Länge 2 plus 8 Mal der Anzahl der Dimensionen gleich, vorangestellt: (2 + 8 * NumberOfDimensions). Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes, die zum Lesen der einzelnen Elemente erforderlich sein. Dies schließt alle Arrays und ihren Deskriptoren. Die `VBFixedString` Attribut angewendet werden kann, Zeichenfolgenfelder in den Strukturen, das die Größe der eine Zeichenfolge, die beim Schreiben auf den Datenträger.  
  
## <a name="binary-mode"></a>Binärmodus  
 Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` Modus Regeln anzuwenden, bis auf einige Ausnahmen. Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:  
  
-   Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen. `FileGet` liest Sie alle Variablen aus dem Datenträger zusammenhängend. d. h. ohne Auffüllung zwischen Datensätzen.  
  
-   Für ein beliebiges Array als ein Array in einer Struktur `FileGet` liest nur die Daten. Es wird kein Deskriptor gelesen.  
  
-   `FileGet` liest die Zeichenfolgen mit variabler Länge, die nicht Elemente der Strukturen sind, ohne die von 2-Byte-Längendeskriptor erwartet werden. Die Anzahl der gelesenen Bytes entspricht die Anzahl der Zeichen, die bereits in der Zeichenfolge.  
  
    > [!IMPORTANT]
    >  Lesen aus einer Datei mithilfe der `FileGet` -Funktion erfordert `Read` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</exception>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref long Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int64&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Long, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="Value">Erforderlich. Der gültige Name einer Variablen, in die Daten gelesen werden.</param>
        <param name="RecordNumber">Dies ist optional. Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), an der der Lesevorgang beginnt.</param>
        <summary>Liest Daten aus einer geöffneten Datenträgerdatei in eine Variable ein. Die <see langword="My" />-Funktion bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FileGet" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` gilt nur in `Random` und `Binary` Modus.  
  
 Mit gelesene Daten `FileGet` in der Regel in eine Datei geschrieben wird, mithilfe von `FilePut`.  
  
 Der erste Datensatz oder Bytes in eine Datei ist an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 und So weiter. Wenn Sie weglassen `RecordNumber`, den Datensatz bzw. das Byte, die nach der letzten `FileGet` oder `FilePut` Funktion (oder auf die von der letzten gezeigt `Seek` Funktion) gelesen wird.  
  
> [!IMPORTANT]
>  Beim Lesen aus Dateien, nehmen Sie keine Entscheidungen für den Inhalt einer Datei, die anhand der Dateinamenerweiterung. Z. B. möglicherweise eine Datei mit dem Namen "Form1.vb" in einer Visual Basic-Quelldatei nicht.  
  
## <a name="random-mode"></a>Zufällige Modus  
 Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:  
  
-   Wenn die Länge des zu lesenden Daten kleiner als die Länge, die im angegebenen die `RecordLength` -Klausel der `FileOpen` -Funktion `FileGet` liest nachfolgende Datensätze Datensatzlänge. Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt. Da die Menge der Daten der Auffüllung nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen eine gute Idee, die Datensatzlänge die Länge des zu lesenden Daten überein.  
  
-   Standardmäßig ist die Zielvariable eine Zeichenfolge, `FileGet` liest einen 2-Byte-Deskriptor, die Länge der Zeichenfolge enthält, und liest dann die Daten, die in der Variablen wechselt. Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge sein. Visual Basic 6.0 und früheren Versionen unterstützen Zeichenfolgen mit fester Länge. Wenn in einer Datei zu versetzen, wird der Längendeskriptor nicht geschrieben werden. Wenn Sie eine Zeichenfolge ohne den Deskriptor lesen möchten, sollten Sie übergeben `True` auf die `StringIsFixedLength` -Parameter, und die Zeichenfolge, die Sie lesen in muss die richtige Länge.  
  
-   Wenn die Zielvariable ein Array ist, können Sie auswählen, ob einen Deskriptor für die Größe und Dimension des Arrays zu lesen. Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`. Wenn Sie das Array zu lesen, müssen Sie die Möglichkeit zu entsprechen, die das Array geschrieben wurde. Wenn es mit dem Deskriptor geschrieben wurde, müssen Sie den Deskriptor zu lesen. Wenn der Deskriptor nicht verwendet wird, die Größe und die Grenzen des Arrays übergebenen `FileGet` bestimmen, was zu lesen.  
  
     Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang. Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl der Dimensionen: (2 + 8 * NumberOfDimensions). Die Datensatzlänge gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Deskriptor des Arrays zu schreiben. Beispielsweise erfordert die folgende Arraydeklaration 218 Bytes, wenn das Array geschrieben wird auf dem Datenträger.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     Die 218 Bytes werden wie folgt verteilt:  
  
    -   18 Bytes für den Deskriptor: (2 + 8 * 2)  
  
    -   200 Byte für die Daten: (10 * 5 * 4).  
  
-   Wenn die Variable Einlesen in einen anderen Typ von Variablen (keine Zeichenfolge variabler Länge oder ein Objekt), `FileGet` liest nur die Daten die Variablen. Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge der Daten gelesen werden können.  
  
-   `FileGet` liest die Elemente von Strukturen, als ob jedes einzeln gelesen wurden, jedoch keinen Leerraum zwischen den Elementen. Auf dem Datenträger ein dynamisches array, in einem benutzerdefinierten Typ (mit geschriebene `FilePut`) ein Deskriptor, deren Länge 2 plus 8 Mal der Anzahl der Dimensionen gleich, vorangestellt: (2 + 8 * NumberOfDimensions). Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes, die zum Lesen der einzelnen Elemente erforderlich sein. Dies schließt alle Arrays und ihren Deskriptoren. Die `VBFixedString` Attribut angewendet werden kann, Zeichenfolgenfelder in den Strukturen, das die Größe der eine Zeichenfolge, die beim Schreiben auf den Datenträger.  
  
## <a name="binary-mode"></a>Binärmodus  
 Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` Modus Regeln anzuwenden, bis auf einige Ausnahmen. Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:  
  
-   Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen. `FileGet` liest Sie alle Variablen aus dem Datenträger zusammenhängend. d. h. ohne Auffüllung zwischen Datensätzen.  
  
-   Für ein beliebiges Array als ein Array in einer Struktur `FileGet` liest nur die Daten. Es wird kein Deskriptor gelesen.  
  
-   `FileGet` liest die Zeichenfolgen mit variabler Länge, die nicht Elemente der Strukturen sind, ohne die von 2-Byte-Längendeskriptor erwartet werden. Die Anzahl der gelesenen Bytes entspricht die Anzahl der Zeichen, die bereits in der Zeichenfolge.  
  
    > [!IMPORTANT]
    >  Lesen aus einer Datei mithilfe der `FileGet` -Funktion erfordert `Read` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</exception>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref float Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, float32&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Single, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="Value">Erforderlich. Der gültige Name einer Variablen, in die Daten gelesen werden.</param>
        <param name="RecordNumber">Dies ist optional. Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), an der der Lesevorgang beginnt.</param>
        <summary>Liest Daten aus einer geöffneten Datenträgerdatei in eine Variable ein. Die <see langword="My" />-Funktion bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FileGet" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` gilt nur in `Random` und `Binary` Modus.  
  
 Mit gelesene Daten `FileGet` in der Regel in eine Datei geschrieben wird, mithilfe von `FilePut`.  
  
 Der erste Datensatz oder Bytes in eine Datei ist an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 und So weiter. Wenn Sie weglassen `RecordNumber`, den Datensatz bzw. das Byte, die nach der letzten `FileGet` oder `FilePut` Funktion (oder auf die von der letzten gezeigt `Seek` Funktion) gelesen wird.  
  
> [!IMPORTANT]
>  Beim Lesen aus Dateien, nehmen Sie keine Entscheidungen für den Inhalt einer Datei, die anhand der Dateinamenerweiterung. Z. B. möglicherweise eine Datei mit dem Namen "Form1.vb" in einer Visual Basic-Quelldatei nicht.  
  
## <a name="random-mode"></a>Zufällige Modus  
 Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:  
  
-   Wenn die Länge des zu lesenden Daten kleiner als die Länge, die im angegebenen die `RecordLength` -Klausel der `FileOpen` -Funktion `FileGet` liest nachfolgende Datensätze Datensatzlänge. Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt. Da die Menge der Daten der Auffüllung nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen eine gute Idee, die Datensatzlänge die Länge des zu lesenden Daten überein.  
  
-   Standardmäßig ist die Zielvariable eine Zeichenfolge, `FileGet` liest einen 2-Byte-Deskriptor, die Länge der Zeichenfolge enthält, und liest dann die Daten, die in der Variablen wechselt. Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge sein. Visual Basic 6.0 und früheren Versionen unterstützen Zeichenfolgen mit fester Länge. Wenn in einer Datei zu versetzen, wird der Längendeskriptor nicht geschrieben werden. Wenn Sie eine Zeichenfolge ohne den Deskriptor lesen möchten, sollten Sie übergeben `True` auf die `StringIsFixedLength` -Parameter, und die Zeichenfolge, die Sie lesen in muss die richtige Länge.  
  
-   Wenn die Zielvariable ein Array ist, können Sie auswählen, ob einen Deskriptor für die Größe und Dimension des Arrays zu lesen. Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`. Wenn Sie das Array zu lesen, müssen Sie die Möglichkeit zu entsprechen, die das Array geschrieben wurde. Wenn es mit dem Deskriptor geschrieben wurde, müssen Sie den Deskriptor zu lesen. Wenn der Deskriptor nicht verwendet wird, die Größe und die Grenzen des Arrays übergebenen `FileGet` bestimmen, was zu lesen.  
  
     Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang. Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl der Dimensionen: (2 + 8 * NumberOfDimensions). Die Datensatzlänge gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Deskriptor des Arrays zu schreiben. Beispielsweise erfordert die folgende Arraydeklaration 218 Bytes, wenn das Array geschrieben wird auf dem Datenträger.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     Die 218 Bytes werden wie folgt verteilt:  
  
    -   18 Bytes für den Deskriptor: (2 + 8 * 2)  
  
    -   200 Byte für die Daten: (10 * 5 * 4).  
  
-   Wenn die Variable Einlesen in einen anderen Typ von Variablen (keine Zeichenfolge variabler Länge oder ein Objekt), `FileGet` liest nur die Daten die Variablen. Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge der Daten gelesen werden können.  
  
-   `FileGet` liest die Elemente von Strukturen, als ob jedes einzeln gelesen wurden, jedoch keinen Leerraum zwischen den Elementen. Auf dem Datenträger ein dynamisches array, in einem benutzerdefinierten Typ (mit geschriebene `FilePut`) ein Deskriptor, deren Länge 2 plus 8 Mal der Anzahl der Dimensionen gleich, vorangestellt: (2 + 8 * NumberOfDimensions). Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes, die zum Lesen der einzelnen Elemente erforderlich sein. Dies schließt alle Arrays und ihren Deskriptoren. Die `VBFixedString` Attribut angewendet werden kann, Zeichenfolgenfelder in den Strukturen, das die Größe der eine Zeichenfolge, die beim Schreiben auf den Datenträger.  
  
## <a name="binary-mode"></a>Binärmodus  
 Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` Modus Regeln anzuwenden, bis auf einige Ausnahmen. Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:  
  
-   Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen. `FileGet` liest Sie alle Variablen aus dem Datenträger zusammenhängend. d. h. ohne Auffüllung zwischen Datensätzen.  
  
-   Für ein beliebiges Array als ein Array in einer Struktur `FileGet` liest nur die Daten. Es wird kein Deskriptor gelesen.  
  
-   `FileGet` liest die Zeichenfolgen mit variabler Länge, die nicht Elemente der Strukturen sind, ohne die von 2-Byte-Längendeskriptor erwartet werden. Die Anzahl der gelesenen Bytes entspricht die Anzahl der Zeichen, die bereits in der Zeichenfolge.  
  
    > [!IMPORTANT]
    >  Lesen aus einer Datei mithilfe der `FileGet` -Funktion erfordert `Read` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</exception>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref ValueType Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, class System.ValueType&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As ValueType, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.ValueType" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="Value">Erforderlich. Der gültige Name einer Variablen, in die Daten gelesen werden.</param>
        <param name="RecordNumber">Dies ist optional. Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), an der der Lesevorgang beginnt.</param>
        <summary>Liest Daten aus einer geöffneten Datenträgerdatei in eine Variable ein. Die <see langword="My" />-Funktion bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FileGet" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` gilt nur in `Random` und `Binary` Modus.  
  
 Mit gelesene Daten `FileGet` in der Regel in eine Datei geschrieben wird, mithilfe von `FilePut`.  
  
 Der erste Datensatz oder Bytes in eine Datei ist an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 und So weiter. Wenn Sie weglassen `RecordNumber`, den Datensatz bzw. das Byte, die nach der letzten `FileGet` oder `FilePut` Funktion (oder auf die von der letzten gezeigt `Seek` Funktion) gelesen wird.  
  
> [!IMPORTANT]
>  Beim Lesen aus Dateien, nehmen Sie keine Entscheidungen für den Inhalt einer Datei, die anhand der Dateinamenerweiterung. Z. B. möglicherweise eine Datei mit dem Namen "Form1.vb" in einer Visual Basic-Quelldatei nicht.  
  
## <a name="random-mode"></a>Zufällige Modus  
 Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:  
  
-   Wenn die Länge des zu lesenden Daten kleiner als die Länge, die im angegebenen die `RecordLength` -Klausel der `FileOpen` -Funktion `FileGet` liest nachfolgende Datensätze Datensatzlänge. Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt. Da die Menge der Daten der Auffüllung nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen eine gute Idee, die Datensatzlänge die Länge des zu lesenden Daten überein.  
  
-   Standardmäßig ist die Zielvariable eine Zeichenfolge, `FileGet` liest einen 2-Byte-Deskriptor, die Länge der Zeichenfolge enthält, und liest dann die Daten, die in der Variablen wechselt. Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge sein. Visual Basic 6.0 und früheren Versionen unterstützen Zeichenfolgen mit fester Länge. Wenn in einer Datei zu versetzen, wird der Längendeskriptor nicht geschrieben werden. Wenn Sie eine Zeichenfolge ohne den Deskriptor lesen möchten, sollten Sie übergeben `True` auf die `StringIsFixedLength` -Parameter, und die Zeichenfolge, die Sie lesen in muss die richtige Länge.  
  
-   Wenn die Zielvariable ein Array ist, können Sie auswählen, ob einen Deskriptor für die Größe und Dimension des Arrays zu lesen. Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`. Wenn Sie das Array zu lesen, müssen Sie die Möglichkeit zu entsprechen, die das Array geschrieben wurde. Wenn es mit dem Deskriptor geschrieben wurde, müssen Sie den Deskriptor zu lesen. Wenn der Deskriptor nicht verwendet wird, die Größe und die Grenzen des Arrays übergebenen `FileGet` bestimmen, was zu lesen.  
  
     Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang. Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl der Dimensionen: (2 + 8 * NumberOfDimensions). Die Datensatzlänge gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Deskriptor des Arrays zu schreiben. Beispielsweise erfordert die folgende Arraydeklaration 218 Bytes, wenn das Array geschrieben wird auf dem Datenträger.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     Die 218 Bytes werden wie folgt verteilt:  
  
    -   18 Bytes für den Deskriptor: (2 + 8 * 2)  
  
    -   200 Byte für die Daten: (10 * 5 * 4).  
  
-   Wenn die Variable Einlesen in einen anderen Typ von Variablen (keine Zeichenfolge variabler Länge oder ein Objekt), `FileGet` liest nur die Daten die Variablen. Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge der Daten gelesen werden können.  
  
-   `FileGet` liest die Elemente von Strukturen, als ob jedes einzeln gelesen wurden, jedoch keinen Leerraum zwischen den Elementen. Auf dem Datenträger ein dynamisches array, in einem benutzerdefinierten Typ (mit geschriebene `FilePut`) ein Deskriptor, deren Länge 2 plus 8 Mal der Anzahl der Dimensionen gleich, vorangestellt: (2 + 8 * NumberOfDimensions). Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes, die zum Lesen der einzelnen Elemente erforderlich sein. Dies schließt alle Arrays und ihren Deskriptoren. Die `VBFixedString` Attribut angewendet werden kann, Zeichenfolgenfelder in den Strukturen, das die Größe der eine Zeichenfolge, die beim Schreiben auf den Datenträger.  
  
## <a name="binary-mode"></a>Binärmodus  
 Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` Modus Regeln anzuwenden, bis auf einige Ausnahmen. Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:  
  
-   Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen. `FileGet` liest Sie alle Variablen aus dem Datenträger zusammenhängend. d. h. ohne Auffüllung zwischen Datensätzen.  
  
-   Für ein beliebiges Array als ein Array in einer Struktur `FileGet` liest nur die Daten. Es wird kein Deskriptor gelesen.  
  
-   `FileGet` liest die Zeichenfolgen mit variabler Länge, die nicht Elemente der Strukturen sind, ohne die von 2-Byte-Längendeskriptor erwartet werden. Die Anzahl der gelesenen Bytes entspricht die Anzahl der Zeichen, die bereits in der Zeichenfolge.  
  
    > [!IMPORTANT]
    >  Lesen aus einer Datei mithilfe der `FileGet` -Funktion erfordert `Read` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</exception>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref string Value, long RecordNumber = -1, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, string&amp; Value, int64 RecordNumber, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As String, Optional RecordNumber As Long = -1, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="Value">Erforderlich. Der gültige Name einer Variablen, in die Daten gelesen werden.</param>
        <param name="RecordNumber">Dies ist optional. Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), an der der Lesevorgang beginnt.</param>
        <param name="StringIsFixedLength">Dies ist optional. Betrifft nur das Schreiben einer Zeichenfolge. Gibt an, ob ein 2-Byte-Deskriptor für die Zeichenfolge geschrieben werden soll, der die Länge beschreibt. Der Standardwert ist <see langword="False" />.</param>
        <summary>Liest Daten aus einer geöffneten Datenträgerdatei in eine Variable ein. Die <see langword="My" />-Funktion bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FileGet" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` gilt nur in `Random` und `Binary` Modus.  
  
 Mit gelesene Daten `FileGet` in der Regel in eine Datei geschrieben wird, mithilfe von `FilePut`.  
  
 Der erste Datensatz oder Bytes in eine Datei ist an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 und So weiter. Wenn Sie weglassen `RecordNumber`, den Datensatz bzw. das Byte, die nach der letzten `FileGet` oder `FilePut` Funktion (oder auf die von der letzten gezeigt `Seek` Funktion) gelesen wird.  
  
> [!IMPORTANT]
>  Beim Lesen aus Dateien, nehmen Sie keine Entscheidungen für den Inhalt einer Datei, die anhand der Dateinamenerweiterung. Z. B. möglicherweise eine Datei mit dem Namen "Form1.vb" in einer Visual Basic-Quelldatei nicht.  
  
## <a name="random-mode"></a>Zufällige Modus  
 Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:  
  
-   Wenn die Länge des zu lesenden Daten kleiner als die Länge, die im angegebenen die `RecordLength` -Klausel der `FileOpen` -Funktion `FileGet` liest nachfolgende Datensätze Datensatzlänge. Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt. Da die Menge der Daten der Auffüllung nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen eine gute Idee, die Datensatzlänge die Länge des zu lesenden Daten überein.  
  
-   Standardmäßig ist die Zielvariable eine Zeichenfolge, `FileGet` liest einen 2-Byte-Deskriptor, die Länge der Zeichenfolge enthält, und liest dann die Daten, die in der Variablen wechselt. Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge sein. Visual Basic 6.0 und früheren Versionen unterstützen Zeichenfolgen mit fester Länge. Wenn in einer Datei zu versetzen, wird der Längendeskriptor nicht geschrieben werden. Wenn Sie eine Zeichenfolge ohne den Deskriptor lesen möchten, sollten Sie übergeben `True` auf die `StringIsFixedLength` -Parameter, und die Zeichenfolge, die Sie lesen in muss die richtige Länge.  
  
-   Wenn die Zielvariable ein Array ist, können Sie auswählen, ob einen Deskriptor für die Größe und Dimension des Arrays zu lesen. Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`. Wenn Sie das Array zu lesen, müssen Sie die Möglichkeit zu entsprechen, die das Array geschrieben wurde. Wenn es mit dem Deskriptor geschrieben wurde, müssen Sie den Deskriptor zu lesen. Wenn der Deskriptor nicht verwendet wird, die Größe und die Grenzen des Arrays übergebenen `FileGet` bestimmen, was zu lesen.  
  
     Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang. Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl der Dimensionen: (2 + 8 * NumberOfDimensions). Die Datensatzlänge gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Deskriptor des Arrays zu schreiben. Beispielsweise erfordert die folgende Arraydeklaration 218 Bytes, wenn das Array geschrieben wird auf dem Datenträger.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     Die 218 Bytes werden wie folgt verteilt:  
  
    -   18 Bytes für den Deskriptor: (2 + 8 * 2)  
  
    -   200 Byte für die Daten: (10 * 5 * 4).  
  
-   Wenn die Variable Einlesen in einen anderen Typ von Variablen (keine Zeichenfolge variabler Länge oder ein Objekt), `FileGet` liest nur die Daten die Variablen. Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge der Daten gelesen werden können.  
  
-   `FileGet` liest die Elemente von Strukturen, als ob jedes einzeln gelesen wurden, jedoch keinen Leerraum zwischen den Elementen. Auf dem Datenträger ein dynamisches array, in einem benutzerdefinierten Typ (mit geschriebene `FilePut`) ein Deskriptor, deren Länge 2 plus 8 Mal der Anzahl der Dimensionen gleich, vorangestellt: (2 + 8 * NumberOfDimensions). Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes, die zum Lesen der einzelnen Elemente erforderlich sein. Dies schließt alle Arrays und ihren Deskriptoren. Die `VBFixedString` Attribut angewendet werden kann, Zeichenfolgenfelder in den Strukturen, das die Größe der eine Zeichenfolge, die beim Schreiben auf den Datenträger.  
  
## <a name="binary-mode"></a>Binärmodus  
 Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` Modus Regeln anzuwenden, bis auf einige Ausnahmen. Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:  
  
-   Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen. `FileGet` liest Sie alle Variablen aus dem Datenträger zusammenhängend. d. h. ohne Auffüllung zwischen Datensätzen.  
  
-   Für ein beliebiges Array als ein Array in einer Struktur `FileGet` liest nur die Daten. Es wird kein Deskriptor gelesen.  
  
-   `FileGet` liest die Zeichenfolgen mit variabler Länge, die nicht Elemente der Strukturen sind, ohne die von 2-Byte-Längendeskriptor erwartet werden. Die Anzahl der gelesenen Bytes entspricht die Anzahl der Zeichen, die bereits in der Zeichenfolge.  
  
    > [!IMPORTANT]
    >  Lesen aus einer Datei mithilfe der `FileGet` -Funktion erfordert `Read` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</exception>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, class System.Array&amp; Value, int64 RecordNumber, bool ArrayIsDynamic, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Array, Optional RecordNumber As Long = -1, Optional ArrayIsDynamic As Boolean = false, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 * bool * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber, ArrayIsDynamic, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Array" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="ArrayIsDynamic" Type="System.Boolean" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="Value">Erforderlich. Der gültige Name einer Variablen, in die Daten gelesen werden.</param>
        <param name="RecordNumber">Dies ist optional. Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), an der der Lesevorgang beginnt.</param>
        <param name="ArrayIsDynamic">Dies ist optional. Betrifft nur das Schreiben eines Arrays. Gibt an, ob das Array als dynamisches Array behandelt werden soll und ein Arraydeskriptor erforderlich ist, der die Größe und die Begrenzungen des Arrays beschreibt.</param>
        <param name="StringIsFixedLength">Dies ist optional. Betrifft nur das Schreiben einer Zeichenfolge. Gibt an, ob ein 2-Byte-Deskriptor für die Zeichenfolge geschrieben werden soll, der die Länge beschreibt. Der Standardwert ist <see langword="False" />.</param>
        <summary>Liest Daten aus einer geöffneten Datenträgerdatei in eine Variable ein. Die <see langword="My" />-Funktion bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FileGet" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` gilt nur in `Random` und `Binary` Modus.  
  
 Mit gelesene Daten `FileGet` in der Regel in eine Datei geschrieben wird, mithilfe von `FilePut`.  
  
 Der erste Datensatz oder Bytes in eine Datei ist an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 und So weiter. Wenn Sie weglassen `RecordNumber`, den Datensatz bzw. das Byte, die nach der letzten `FileGet` oder `FilePut` Funktion (oder auf die von der letzten gezeigt `Seek` Funktion) gelesen wird.  
  
> [!IMPORTANT]
>  Beim Lesen aus Dateien, nehmen Sie keine Entscheidungen für den Inhalt einer Datei, die anhand der Dateinamenerweiterung. Z. B. möglicherweise eine Datei mit dem Namen "Form1.vb" in einer Visual Basic-Quelldatei nicht.  
  
## <a name="random-mode"></a>Zufällige Modus  
 Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:  
  
-   Wenn die Länge des zu lesenden Daten kleiner als die Länge, die im angegebenen die `RecordLength` -Klausel der `FileOpen` -Funktion `FileGet` liest nachfolgende Datensätze Datensatzlänge. Der Abstand zwischen dem Ende eines Datensatzes und das Starten des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt. Da die Menge der Daten der Auffüllung nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen eine gute Idee, die Datensatzlänge die Länge des zu lesenden Daten überein.  
  
-   Standardmäßig ist die Zielvariable eine Zeichenfolge, `FileGet` liest einen 2-Byte-Deskriptor, die Länge der Zeichenfolge enthält, und liest dann die Daten, die in der Variablen wechselt. Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge sein. Visual Basic 6.0 und früheren Versionen unterstützen Zeichenfolgen mit fester Länge. Wenn in einer Datei zu versetzen, wird der Längendeskriptor nicht geschrieben werden. Wenn Sie eine Zeichenfolge ohne den Deskriptor lesen möchten, sollten Sie übergeben `True` auf die `StringIsFixedLength` -Parameter, und die Zeichenfolge, die Sie lesen in muss die richtige Länge.  
  
-   Wenn die Zielvariable ein Array ist, können Sie auswählen, ob einen Deskriptor für die Größe und Dimension des Arrays zu lesen. Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`. Wenn Sie das Array zu lesen, müssen Sie die Möglichkeit zu entsprechen, die das Array geschrieben wurde. Wenn es mit dem Deskriptor geschrieben wurde, müssen Sie den Deskriptor zu lesen. Wenn der Deskriptor nicht verwendet wird, die Größe und die Grenzen des Arrays übergebenen `FileGet` bestimmen, was zu lesen.  
  
     Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang. Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl der Dimensionen: (2 + 8 * NumberOfDimensions). Die Datensatzlänge gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Deskriptor des Arrays zu schreiben. Beispielsweise erfordert die folgende Arraydeklaration 218 Bytes, wenn das Array geschrieben wird auf dem Datenträger.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     Die 218 Bytes werden wie folgt verteilt:  
  
    -   18 Bytes für den Deskriptor: (2 + 8 * 2)  
  
    -   200 Byte für die Daten: (10 * 5 * 4).  
  
-   Wenn die Variable Einlesen in einen anderen Typ von Variablen (keine Zeichenfolge variabler Länge oder ein Objekt), `FileGet` liest nur die Daten die Variablen. Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge der Daten gelesen werden können.  
  
-   `FileGet` liest die Elemente von Strukturen, als ob jedes einzeln gelesen wurden, jedoch keinen Leerraum zwischen den Elementen. Auf dem Datenträger ein dynamisches array, in einem benutzerdefinierten Typ (mit geschriebene `FilePut`) ein Deskriptor, deren Länge 2 plus 8 Mal der Anzahl der Dimensionen gleich, vorangestellt: (2 + 8 * NumberOfDimensions). Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes, die zum Lesen der einzelnen Elemente erforderlich sein. Dies schließt alle Arrays und ihren Deskriptoren. Die `VBFixedString` Attribut angewendet werden kann, Zeichenfolgenfelder in den Strukturen, das die Größe der eine Zeichenfolge, die beim Schreiben auf den Datenträger.  
  
## <a name="binary-mode"></a>Binärmodus  
 Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` Modus Regeln anzuwenden, bis auf einige Ausnahmen. Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:  
  
-   Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen. `FileGet` liest Sie alle Variablen aus dem Datenträger zusammenhängend. d. h. ohne Auffüllung zwischen Datensätzen.  
  
-   Für ein beliebiges Array als ein Array in einer Struktur `FileGet` liest nur die Daten. Es wird kein Deskriptor gelesen.  
  
-   `FileGet` liest die Zeichenfolgen mit variabler Länge, die nicht Elemente der Strukturen sind, ohne die von 2-Byte-Längendeskriptor erwartet werden. Die Anzahl der gelesenen Bytes entspricht die Anzahl der Zeichen, die bereits in der Zeichenfolge.  
  
    > [!IMPORTANT]
    >  Lesen aus einer Datei mithilfe der `FileGet` -Funktion erfordert `Read` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</exception>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGetObject">
      <MemberSignature Language="C#" Value="public static void FileGetObject (int FileNumber, ref object Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGetObject(int32 FileNumber, object&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGetObject (FileNumber As Integer, ByRef Value As Object, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGetObject : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGetObject (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="Value">Erforderlich. Der gültige Name einer Variablen, in die Daten gelesen werden.</param>
        <param name="RecordNumber">Dies ist optional. Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), an der der Lesevorgang beginnt.</param>
        <summary>Liest Daten aus einer geöffneten Datenträgerdatei in eine Variable ein.  Die <see langword="My" />-Funktion bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FileGetObject" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `FileGetObject` Funktion dient anstelle von `FileGet` um Mehrdeutigkeiten zum Zeitpunkt der Kompilierung zu vermeiden, wenn Typ `Object` wird zurückgegeben, anstelle eines anderen Typs, z. B. `Integer`, `Long`, `Short`und so weiter.  
  
 Wenn Sie beabsichtigen, schreibt die `Variant` Typ `FileGetObject` ist erforderlich. Im Zweifelsfall, wenn Sie ein Objekt für den zweiten Parameter verwenden, ist immer empfehlenswert, die Sie verwenden `FilePutObject` und `FileGetObject`.  
  
 `FileGetObject` gilt nur in `Random` und `Binary` Modus.  
  
 Mit gelesene Daten `FileGetObject` richtet sich in der Regel mit `FilePutObject`.  
  
 Der erste Datensatz oder Bytes in eine Datei ist an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 und So weiter. Wenn Sie weglassen `RecordNumber`, `FileGetObject` liest den Datensatz bzw. das Byte nach dem letzten `FileGetObject` oder `FilePutObject` Funktion (oder auf die von der letzten gezeigt `Seek` Funktion).  
  
## <a name="random-mode"></a>Zufällige Modus  
 Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:  
  
-   Wenn die Länge des zu lesenden Daten kleiner als die Länge, die im angegebenen die `RecordLength` -Klausel der `FileOpen` -Funktion `FileGetObject` liest nachfolgende Datensätze Datensatzlänge. Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt. Da die Menge der Daten der Auffüllung nicht genau bestimmt werden kann, ist es eine gute Idee, die Datensatzlänge die Länge des zu lesenden Daten überein.  
  
-   Wenn die Zielvariable eine Zeichenfolge, in der Standardeinstellung ist `FileGetObject` liest einen 2-Byte-Deskriptor, der die Länge der Zeichenfolge enthält, und liest dann die Daten, die in der Variablen wechselt. Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge sein. Visual Basic 6.0 und früheren Versionen unterstützen Zeichenfolgen mit fester Länge und in eine Datei beim Lesen der Längendeskriptor nicht geschrieben werden. Wenn Sie eine Zeichenfolge ohne den Deskriptor lesen möchten, sollten Sie übergeben `True` auf die `StringIsFixedLength` -Parameter, und die Zeichenfolge, die Sie lesen in muss die richtige Länge.  
  
-   Wenn die Zielvariable ein Array, und klicken Sie dann auf die angegebene Datensatzlänge ist die `RecordLength` Parameter in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Deskriptor des Arrays zu schreiben. Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang. Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl der Dimensionen: 2 + 8 * NumberOfDimensions.  
  
     Beispielsweise erfordert die folgende Arraydeklaration 218 Bytes, wenn das Array geschrieben wird auf den Datenträger:  
  
     [!code-vb[VbVbalrCatRef#27](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#27)]  
  
     Die 218 Bytes werden wie folgt verteilt: 18 Bytes für den Deskriptor (2 + 8 * 2), und 100 Bytes für die Daten (10 * 5 * 4).  
  
-   `FileGetObject` liest die Elemente von Strukturen, als ob jedes einzeln gelesen wurden, jedoch keinen Leerraum zwischen den Elementen. Auf dem Datenträger ein dynamisches array, in einem benutzerdefinierten Typ (mit geschriebene `FilePutObject`) ein Deskriptor, deren Länge 2 plus 8 Mal der Anzahl der Dimensionen gleich, vorangestellt ist: 2 + 8 * NumberOfDimensions. Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes, die zum Lesen der einzelnen Elemente, einschließlich aller Arrays und ihren Deskriptoren erforderlich sein. Die <xref:Microsoft.VisualBasic.VBFixedStringAttribute> Klasse angewendet werden kann, Zeichenfolgenfelder in den Strukturen, das die Größe der Zeichenfolge beim Schreiben auf den Datenträger.  
  
## <a name="binary-mode"></a>Binärmodus  
 Für Dateien in geöffnet `Binary` aller-Modus die `Random` Regeln anwenden, mit den folgenden Ausnahmen:  
  
-   Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen. `FileGetObject` Liest alle Variablen aus dem Datenträger zusammenhängend, also ohne Abstand zwischen den Datensätzen.  
  
-   Für ein beliebiges Array als ein Array in einer Struktur `FileGetObject` liest nur die Daten. Es wird kein Deskriptor gelesen.  
  
 `FileGetObject` liest die Zeichenfolgen mit variabler Länge, die nicht Elemente der Strukturen sind, ohne die von 2-Byte-Längendeskriptor erwartet werden. Die Anzahl der gelesenen Bytes entspricht die Anzahl der Zeichen, die bereits in der Zeichenfolge.  
  
> [!IMPORTANT]
>  Beim Lesen aus Dateien, nehmen Sie keine Entscheidungen für den Inhalt einer Datei, die anhand der Dateinamenerweiterung. Z. B. möglicherweise eine Datei namens "Form1.vb" in einer Visual Basic-Quelldatei nicht.  
  
   
  
## Examples  
 Das folgende Beispiel liest einen Datensatz in eine Datei, und klicken Sie dann abgerufen.  
  
 [!code-vb[VbVbalrCatRef#26](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#26)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
      </Docs>
    </Member>
    <Member MemberName="FileLen">
      <MemberSignature Language="C#" Value="public static long FileLen (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 FileLen(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileLen (PathName As String) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long FileLen(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member FileLen : string -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.FileLen PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">Erforderlich. Ein <see langword="String" />-Ausdruck, der eine Datei angibt. <c>PathName</c> kann das Verzeichnis bzw. den Ordner und das Laufwerk enthalten.</param>
        <summary>Gibt einen <see langword="Long" />-Wert zurück, der die Länge einer Datei in Bytes angibt. Das <see langword="My" />-Feature bietet höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FileLen" />. Weitere Informationen finden Sie unter <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />.</summary>
        <returns>Ein <see langword="Long" />-Wert, der die Länge einer Datei in Bytes angibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die angegebene Datei geöffnet, wenn ist die `FileLen` Funktion aufgerufen wird, wird der zurückgegebene Wert stellt die Größe der Datei, die zum Zeitpunkt der sie geöffnet wurde.  
  
> [!NOTE]
>  Um die aktuelle Länge einer geöffneten Datei zu erhalten, verwenden die `LOF` Funktion.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `FileLen` Funktion, um die Länge einer Datei in Byte zurück. Für dieses Beispiel wird angenommen, dass `TestFile` ist eine Datei, die Daten enthält.  
  
 [!code-vb[VbVbalrCatRef#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Die Datei ist nicht vorhanden.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <Member MemberName="FileOpen">
      <MemberSignature Language="C#" Value="public static void FileOpen (int FileNumber, string FileName, Microsoft.VisualBasic.OpenMode Mode, Microsoft.VisualBasic.OpenAccess Access = Microsoft.VisualBasic.OpenAccess.Default, Microsoft.VisualBasic.OpenShare Share = Microsoft.VisualBasic.OpenShare.Default, int RecordLength = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileOpen(int32 FileNumber, string FileName, valuetype Microsoft.VisualBasic.OpenMode Mode, valuetype Microsoft.VisualBasic.OpenAccess Access, valuetype Microsoft.VisualBasic.OpenShare Share, int32 RecordLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileOpen (FileNumber As Integer, FileName As String, Mode As OpenMode, Optional Access As OpenAccess = Microsoft.VisualBasic.OpenAccess.Default, Optional Share As OpenShare = Microsoft.VisualBasic.OpenShare.Default, Optional RecordLength As Integer = -1)" />
      <MemberSignature Language="F#" Value="static member FileOpen : int * string * Microsoft.VisualBasic.OpenMode * Microsoft.VisualBasic.OpenAccess * Microsoft.VisualBasic.OpenShare * int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileOpen (FileNumber, FileName, Mode, Access, Share, RecordLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FileName" Type="System.String" />
        <Parameter Name="Mode" Type="Microsoft.VisualBasic.OpenMode" />
        <Parameter Name="Access" Type="Microsoft.VisualBasic.OpenAccess" />
        <Parameter Name="Share" Type="Microsoft.VisualBasic.OpenShare" />
        <Parameter Name="RecordLength" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer. Verwenden Sie die <see langword="FreeFile" />-Funktion, um die nächste verfügbare Dateinummer zu erhalten.</param>
        <param name="FileName">Erforderlich. <see langword="String" />-Ausdruck, der einen Dateinamen angibt. Kann das Verzeichnis oder den Ordner und das Laufwerk enthalten.</param>
        <param name="Mode">Erforderlich. Eine Enumeration, die den Dateimodus angibt: <see langword="Append" />, <see langword="Binary" />, <see langword="Input" />, <see langword="Output" /> oder <see langword="Random" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.OpenMode" />.</param>
        <param name="Access">Dies ist optional. Eine Enumeration, die die für eine offene Datei erlaubten Operationen angibt: <see langword="Read" />, <see langword="Write" /> oder <see langword="ReadWrite" />. Wird standardmäßig auf <see langword="ReadWrite" /> festgelegt. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.OpenAccess" />.</param>
        <param name="Share">Dies ist optional. Eine Enumeration, die für eine offene Datei aus anderen Prozessen nicht erlaubten Operationen angibt: <see langword="Shared" />, <see langword="Lock Read" />, <see langword="Lock Write" /> und <see langword="Lock Read Write" />. Wird standardmäßig auf <see langword="Lock Read Write" /> festgelegt. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.OpenShare" />.</param>
        <param name="RecordLength">Dies ist optional. Eine Zahl kleiner oder gleich 32.767 (Bytes). Bei Dateien, die mit Random-Zugriff geöffnet wurden, ist dieser Wert die Datensatzlänge. Bei sequenziellen Dateien ist dieser Wert die Anzahl von gepufferten Zeichen.</param>
        <summary>Öffnet eine Datei für Eingabe oder Ausgabe. Die <see langword="My" />-Funktion bietet eine höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FileOpen" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `FileOpen` -Funktion wird für Abwärtskompatibilität angeboten und die Leistung beeinträchtigen. Für neue Anwendungen die `My.Computer.FileSystem` Objekt bietet eine bessere Leistung. Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Sie müssen eine Datei öffnen, bevor alle e/a-Vorgänge ausgeführt werden kann. `FileOpen` weist einen Puffer für e/a in die Datei, und bestimmt den Zugriffsmodus für die Verwendung mit dem Puffer.  
  
> [!IMPORTANT]
>  Beim Schreiben in eine Datei eine Anwendung möglicherweise eine Datei erstellen, wenn die Datei, auf die sie schreiben nicht vorhanden ist. Zu diesem Zweck benötigt diese Berechtigung für das Verzeichnis, in dem die Datei ist, erstellt werden. Aber wenn die Datei durch angegeben `FileName` vorhanden ist, muss die Anwendung `Write` Berechtigung nur für die Datei selbst. Ganz egal, wo möglich, zur Verbesserung der Sicherheit, erstellen Sie die Datei während der Bereitstellung und Grant `Write` Berechtigung für diese Datei nur, statt das gesamte Verzeichnis. Schreiben Sie Daten in Verzeichnissen nach Benutzer statt auf das Root-Verzeichnis oder das Verzeichnis Programme, um Sicherheit zu verbessern.  
  
 Der Kanal zum Öffnen finden Sie unter Verwendung der `FreeFile()` Funktion.  
  
> [!IMPORTANT]
>  Die `FileOpen` -Funktion erfordert `Read` aus Zugriff auf die `FileIOPermissionAccess` -Enumeration, die die Ausführung in teilweise vertrauenswürdigen Umgebungen auswirkt. Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.  
  
   
  
## Examples  
 Dieses Beispiel veranschaulicht verschiedene Verwendungen der der `FileOpen` Funktion, um die Eingabe und Ausgabe in eine Datei zu aktivieren.  
  
 Der folgende Code öffnet die Datei `TestFile` in `Input` Modus.  
  
 [!code-vb[VbVbalrCatRef#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#5)]  
  
 In diesem Beispiel öffnet die Datei im `Binary` Modus ausschließlich für Schreibvorgänge.  
  
 [!code-vb[VbVbalrCatRef#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#6)]  
  
 Das folgende Beispiel öffnet die Datei im `Random` Modus. Die Datei enthält die Datensätze der Struktur `Person`.  
  
 [!code-vb[VbVbalrCatRef#7](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#7)]  
  
 Dieses Codebeispiel öffnet die Datei im `Output` Modus: jeder Prozess kann lesen oder Schreiben in die Datei.  
  
 [!code-vb[VbVbalrCatRef#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#8)]  
  
 Dieses Codebeispiel öffnet die Datei im `Binary` Modus zum Lesen; andere Prozesse die Datei können nicht gelesen werden.  
  
 [!code-vb[VbVbalrCatRef#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Datensatzlänge ist negativ (und nicht gleich -1).</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="FileName" /> ist bereits geöffnet, oder <paramref name="FileName" /> ist ungültig.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FreeFile" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FilePut">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Schreibt Daten aus einer Variablen in eine Datei auf einem Datenträger. Die <see langword="My" />-Funktion bietet eine höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FilePut" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, bool Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, bool Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Boolean, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * bool * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="Value">Erforderlich. Gültiger Variablenname, der auf den Datenträger geschriebene Daten enthält.</param>
        <param name="RecordNumber">Dies ist optional. Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), an der der Schreibvorgang beginnt.</param>
        <summary>Schreibt Daten aus einer Variablen in eine Datei auf einem Datenträger. Die <see langword="My" />-Funktion bietet eine höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FilePut" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` gilt nur in `Random` und `Binary` Modus.  
  
 Mit `FilePut` geschriebene Daten werden normalerweise mit `FileGet` aus einer Datei gelesen.  
  
 Der erste Datensatz oder Bytes in eine Datei ist an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 und So weiter. Wenn Sie weglassen `RecordNumber`, den nächsten Datensatz bzw. Byte nach dem letzten `FileGet` oder `FilePut` Funktion oder auf die von der letzten gezeigt `Seek` Funktion geschrieben ist.  
  
 Die `StringIsFixedLength` -Argument steuert, ob die Funktion Zeichenfolgen variabler oder fester Länge interpretiert. `FilePut` den Längendeskriptor wird nicht geschrieben werden, wenn das Argument ist `True`. Bei Verwendung von `StringIsFixedLength`  =  `True` mit `FilePut`, müssen Sie das gleiche mit `FileGet`, und Sie müssen sicherstellen, dass die Zeichenfolge mit der erwarteten Länge initialisiert wird.  
  
## <a name="random-mode"></a>Zufällige Modus  
 Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:  
  
-   Wenn die Länge des zu schreibenden Daten kleiner als die Länge, die im angegebenen die `RecordLength` -Klausel der `FileOpen` -Funktion `FilePut` nachfolgende Datensätze auf Datensatzlänge schreibt. Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt. Da die Menge der Daten der Auffüllung nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen eine gute Idee, die Datensatzlänge die Länge des zu schreibenden Daten überein. Ist die Länge des zu schreibenden Daten größer als die Länge angegeben wird, der `RecordLength` -Klausel der `FileOpen` -Funktion eine Ausnahme ausgelöst.  
  
-   Wenn die Variable geschrieben wird eine Zeichenfolge, `FilePut` schreibt einen 2-Byte-Deskriptor, die Länge der Zeichenfolge enthält, und schreibt dann die Daten, die in der Variablen wechselt. Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge sein.  
  
-   Wenn die Variable geschrieben wird ein Objekt, das einen numerischen Typ enthält, `FilePut` schreibt zwei Bytes zur Identifizierung der `VarType` des Objekts und schreibt dann die Variable. Enthält z. B. wenn ein Objekt zu schreiben, die eine ganze Zahl, `FilePut` schreibt sechs Bytes: 2 Bytes, die das Objekt als identifizieren `VarType(3)` (`Integer`) und vier Bytes, die Daten enthalten. Die Datensatzlänge gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss größer als die tatsächliche Anzahl von Bytes zum Speichern der Variablen benötigt mindestens zwei Bytes sein.  
  
-   Wenn die Variable geschrieben wird ein Objekt, das eine Zeichenfolge, enthält `FilePut` schreibt eine 2-Byte-Deskriptor, identifiziert die `VarType(8)` des Objekts ein 2-Byte-Deskriptor, der angibt, der Länge der Zeichenfolge ein, und klicken Sie dann die Zeichenfolgendaten. Die Datensatzlänge gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss über mindestens vier Bytes größer als die tatsächliche Länge der Zeichenfolge sein. Wenn Sie eine Zeichenfolge ohne den Deskriptor ablegen möchten, sollten Sie übergeben `True` auf die `StringIsFixedLength` -Parameter, und die Zeichenfolge, die Sie lesen in muss die richtige Länge.  
  
-   Wenn die Zielvariable ein Array ist, müssen Sie entscheiden, ob einen Deskriptor für die Größe und die Dimensionen des Arrays zu schreiben. Schreiben den Dateideskriptor für ein dynamisches Array aber nicht für Arrays mit fester Größe, Visual Basic 6.0 und früheren Versionen. Visual Basic 2005 standardmäßig nicht das Schreiben des Deskriptors. Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`. Wenn Sie das Array zu schreiben, müssen Sie die Möglichkeit zu entsprechen, die das Array gelesen werden; Wenn sie mit der gelesen wird, müssen Sie den Deskriptor schreiben. Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang. Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl der Dimensionen: (2 + 8 * NumberOfDimensions). Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Deskriptor des Arrays zu schreiben. Beispielsweise erfordert die folgende Arraydeklaration 218 Bytes, wenn das Array geschrieben wird auf dem Datenträger.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Wenn die Variable geschrieben wird einen anderen Typ von Variablen (keine Zeichenfolge variabler Länge oder ein Objekt), `FilePut` schreibt nur die Daten der Variablen. Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge des zu schreibenden Daten.  
  
-   `FilePut` Schreibt die Elemente von Strukturen als ob jedes einzeln geschrieben wäre jedoch ohne Abstand zwischen Elementen. Die `VBFixedString` Attribut angewendet werden kann, Zeichenfolgenfelder in den Strukturen, das die Größe der Zeichenfolge beim Schreiben auf den Datenträger.  
  
    > [!NOTE]
    >  Felder, die mehr als Bytes angegeben Zeichenfolge die `VBFixedString` Attribut werden abgeschnitten, beim Schreiben auf den Datenträger  
  
## <a name="binary-mode"></a>Binärmodus  
 Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` Modus Regeln anzuwenden, bis auf einige Ausnahmen. Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:  
  
-   Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen. `FilePut` Schreibt alle Variablen zusammenhängend, d. h. ohne Leerraum zwischen Datensätzen Datenträger.  
  
-   Für ein beliebiges Array als ein Array in einer Struktur `FilePut` schreibt nur die Daten. Es wird kein Deskriptor geschrieben.  
  
-   `FilePut` Schreibt die Zeichenfolgen mit variabler Länge, die nicht Elemente der Strukturen sind, ohne die von 2-Byte-Längendeskriptor. Die Anzahl der geschriebenen Bytes entspricht die Anzahl der Zeichen in der Zeichenfolge. Beispielsweise schreiben die folgenden Anweisungen 11 Bytes beträgt, Dateinummer 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Schreiben in eine Datei mit den `FilePut` -Funktion erfordert `Write` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `FilePut` Funktion, um Daten in eine Datei zu schreiben. Fünf Datensätze in der Struktur `Person` in die Datei geschrieben werden.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</exception>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, byte Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, unsigned int8 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Byte, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * byte * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="Value">Erforderlich. Gültiger Variablenname, der auf den Datenträger geschriebene Daten enthält.</param>
        <param name="RecordNumber">Dies ist optional. Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), an der der Schreibvorgang beginnt.</param>
        <summary>Schreibt Daten aus einer Variablen in eine Datei auf einem Datenträger. Die <see langword="My" />-Funktion bietet eine höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FilePut" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` gilt nur in `Random` und `Binary` Modus.  
  
 Mit `FilePut` geschriebene Daten werden normalerweise mit `FileGet` aus einer Datei gelesen.  
  
 Der erste Datensatz oder Bytes in eine Datei ist an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 und So weiter. Wenn Sie weglassen `RecordNumber`, den nächsten Datensatz bzw. Byte nach dem letzten `FileGet` oder `FilePut` Funktion oder auf die von der letzten gezeigt `Seek` Funktion geschrieben ist.  
  
 Die `StringIsFixedLength` -Argument steuert, ob die Funktion Zeichenfolgen variabler oder fester Länge interpretiert. `FilePut` den Längendeskriptor wird nicht geschrieben werden, wenn das Argument ist `True`. Bei Verwendung von `StringIsFixedLength`  =  `True` mit `FilePut`, müssen Sie das gleiche mit `FileGet`, und Sie müssen sicherstellen, dass die Zeichenfolge mit der erwarteten Länge initialisiert wird.  
  
## <a name="random-mode"></a>Zufällige Modus  
 Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:  
  
-   Wenn die Länge des zu schreibenden Daten kleiner als die Länge, die im angegebenen die `RecordLength` -Klausel der `FileOpen` -Funktion `FilePut` nachfolgende Datensätze auf Datensatzlänge schreibt. Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt. Da die Menge der Daten der Auffüllung nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen eine gute Idee, die Datensatzlänge die Länge des zu schreibenden Daten überein. Ist die Länge des zu schreibenden Daten größer als die Länge angegeben wird, der `RecordLength` -Klausel der `FileOpen` -Funktion eine Ausnahme ausgelöst.  
  
-   Wenn die Variable geschrieben wird eine Zeichenfolge, `FilePut` schreibt einen 2-Byte-Deskriptor, die Länge der Zeichenfolge enthält, und schreibt dann die Daten, die in der Variablen wechselt. Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge sein.  
  
-   Wenn die Variable geschrieben wird ein Objekt, das einen numerischen Typ enthält, `FilePut` schreibt zwei Bytes zur Identifizierung der `VarType` des Objekts und schreibt dann die Variable. Enthält z. B. wenn ein Objekt zu schreiben, die eine ganze Zahl, `FilePut` schreibt sechs Bytes: 2 Bytes, die das Objekt als identifizieren `VarType(3)` (`Integer`) und vier Bytes, die Daten enthalten. Die Datensatzlänge gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss größer als die tatsächliche Anzahl von Bytes zum Speichern der Variablen benötigt mindestens zwei Bytes sein.  
  
-   Wenn die Variable geschrieben wird ein Objekt, das eine Zeichenfolge, enthält `FilePut` schreibt eine 2-Byte-Deskriptor, identifiziert die `VarType(8)` des Objekts ein 2-Byte-Deskriptor, der angibt, der Länge der Zeichenfolge ein, und klicken Sie dann die Zeichenfolgendaten. Die Datensatzlänge gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss über mindestens vier Bytes größer als die tatsächliche Länge der Zeichenfolge sein. Wenn Sie eine Zeichenfolge ohne den Deskriptor ablegen möchten, sollten Sie übergeben `True` auf die `StringIsFixedLength` -Parameter, und die Zeichenfolge, die Sie lesen in muss die richtige Länge.  
  
-   Wenn die Zielvariable ein Array ist, müssen Sie entscheiden, ob einen Deskriptor für die Größe und die Dimensionen des Arrays zu schreiben. Schreiben den Dateideskriptor für ein dynamisches Array aber nicht für Arrays mit fester Größe, Visual Basic 6.0 und früheren Versionen. Visual Basic 2005 standardmäßig nicht das Schreiben des Deskriptors. Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`. Wenn Sie das Array zu schreiben, müssen Sie die Möglichkeit zu entsprechen, die das Array gelesen werden; Wenn sie mit der gelesen wird, müssen Sie den Deskriptor schreiben. Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang. Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl der Dimensionen: (2 + 8 * NumberOfDimensions). Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Deskriptor des Arrays zu schreiben. Beispielsweise erfordert die folgende Arraydeklaration 218 Bytes, wenn das Array geschrieben wird auf dem Datenträger.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Wenn die Variable geschrieben wird einen anderen Typ von Variablen (keine Zeichenfolge variabler Länge oder ein Objekt), `FilePut` schreibt nur die Daten der Variablen. Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge des zu schreibenden Daten.  
  
-   `FilePut` Schreibt die Elemente von Strukturen als ob jedes einzeln geschrieben wäre jedoch ohne Abstand zwischen Elementen. Die `VBFixedString` Attribut angewendet werden kann, Zeichenfolgenfelder in den Strukturen, das die Größe der Zeichenfolge beim Schreiben auf den Datenträger.  
  
    > [!NOTE]
    >  Felder, die mehr als Bytes angegeben Zeichenfolge die `VBFixedString` Attribut werden abgeschnitten, beim Schreiben auf den Datenträger  
  
## <a name="binary-mode"></a>Binärmodus  
 Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` Modus Regeln anzuwenden, bis auf einige Ausnahmen. Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:  
  
-   Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen. `FilePut` Schreibt alle Variablen zusammenhängend, d. h. ohne Leerraum zwischen Datensätzen Datenträger.  
  
-   Für ein beliebiges Array als ein Array in einer Struktur `FilePut` schreibt nur die Daten. Es wird kein Deskriptor geschrieben.  
  
-   `FilePut` Schreibt die Zeichenfolgen mit variabler Länge, die nicht Elemente der Strukturen sind, ohne die von 2-Byte-Längendeskriptor. Die Anzahl der geschriebenen Bytes entspricht die Anzahl der Zeichen in der Zeichenfolge. Beispielsweise schreiben die folgenden Anweisungen 11 Bytes beträgt, Dateinummer 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Schreiben in eine Datei mit den `FilePut` -Funktion erfordert `Write` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `FilePut` Funktion, um Daten in eine Datei zu schreiben. Fünf Datensätze in der Struktur `Person` in die Datei geschrieben werden.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</exception>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, char Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, char Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Char, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * char * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="Value">Erforderlich. Gültiger Variablenname, der auf den Datenträger geschriebene Daten enthält.</param>
        <param name="RecordNumber">Dies ist optional. Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), an der der Schreibvorgang beginnt.</param>
        <summary>Schreibt Daten aus einer Variablen in eine Datei auf einem Datenträger. Die <see langword="My" />-Funktion bietet eine höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FilePut" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` gilt nur in `Random` und `Binary` Modus.  
  
 Mit `FilePut` geschriebene Daten werden normalerweise mit `FileGet` aus einer Datei gelesen.  
  
 Der erste Datensatz oder Bytes in eine Datei ist an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 und So weiter. Wenn Sie weglassen `RecordNumber`, den nächsten Datensatz bzw. Byte nach dem letzten `FileGet` oder `FilePut` Funktion oder auf die von der letzten gezeigt `Seek` Funktion geschrieben ist.  
  
 Die `StringIsFixedLength` -Argument steuert, ob die Funktion Zeichenfolgen variabler oder fester Länge interpretiert. `FilePut` den Längendeskriptor wird nicht geschrieben werden, wenn das Argument ist `True`. Bei Verwendung von `StringIsFixedLength`  =  `True` mit `FilePut`, müssen Sie das gleiche mit `FileGet`, und Sie müssen sicherstellen, dass die Zeichenfolge mit der erwarteten Länge initialisiert wird.  
  
## <a name="random-mode"></a>Zufällige Modus  
 Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:  
  
-   Wenn die Länge des zu schreibenden Daten kleiner als die Länge, die im angegebenen die `RecordLength` -Klausel der `FileOpen` -Funktion `FilePut` nachfolgende Datensätze auf Datensatzlänge schreibt. Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt. Da die Menge der Daten der Auffüllung nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen eine gute Idee, die Datensatzlänge die Länge des zu schreibenden Daten überein. Ist die Länge des zu schreibenden Daten größer als die Länge angegeben wird, der `RecordLength` -Klausel der `FileOpen` -Funktion eine Ausnahme ausgelöst.  
  
-   Wenn die Variable geschrieben wird eine Zeichenfolge, `FilePut` schreibt einen 2-Byte-Deskriptor, die Länge der Zeichenfolge enthält, und schreibt dann die Daten, die in der Variablen wechselt. Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge sein.  
  
-   Wenn die Variable geschrieben wird ein Objekt, das einen numerischen Typ enthält, `FilePut` schreibt zwei Bytes zur Identifizierung der `VarType` des Objekts und schreibt dann die Variable. Enthält z. B. wenn ein Objekt zu schreiben, die eine ganze Zahl, `FilePut` schreibt sechs Bytes: 2 Bytes, die das Objekt als identifizieren `VarType(3)` (`Integer`) und vier Bytes, die Daten enthalten. Die Datensatzlänge gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss größer als die tatsächliche Anzahl von Bytes zum Speichern der Variablen benötigt mindestens zwei Bytes sein.  
  
-   Wenn die Variable geschrieben wird ein Objekt, das eine Zeichenfolge, enthält `FilePut` schreibt eine 2-Byte-Deskriptor, identifiziert die `VarType(8)` des Objekts ein 2-Byte-Deskriptor, der angibt, der Länge der Zeichenfolge ein, und klicken Sie dann die Zeichenfolgendaten. Die Datensatzlänge gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss über mindestens vier Bytes größer als die tatsächliche Länge der Zeichenfolge sein. Wenn Sie eine Zeichenfolge ohne den Deskriptor ablegen möchten, sollten Sie übergeben `True` auf die `StringIsFixedLength` -Parameter, und die Zeichenfolge, die Sie lesen in muss die richtige Länge.  
  
-   Wenn die Zielvariable ein Array ist, müssen Sie entscheiden, ob einen Deskriptor für die Größe und die Dimensionen des Arrays zu schreiben. Schreiben den Dateideskriptor für ein dynamisches Array aber nicht für Arrays mit fester Größe, Visual Basic 6.0 und früheren Versionen. Visual Basic 2005 standardmäßig nicht das Schreiben des Deskriptors. Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`. Wenn Sie das Array zu schreiben, müssen Sie die Möglichkeit zu entsprechen, die das Array gelesen werden; Wenn sie mit der gelesen wird, müssen Sie den Deskriptor schreiben. Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang. Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl der Dimensionen: (2 + 8 * NumberOfDimensions). Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Deskriptor des Arrays zu schreiben. Beispielsweise erfordert die folgende Arraydeklaration 218 Bytes, wenn das Array geschrieben wird auf dem Datenträger.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Wenn die Variable geschrieben wird einen anderen Typ von Variablen (keine Zeichenfolge variabler Länge oder ein Objekt), `FilePut` schreibt nur die Daten der Variablen. Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge des zu schreibenden Daten.  
  
-   `FilePut` Schreibt die Elemente von Strukturen als ob jedes einzeln geschrieben wäre jedoch ohne Abstand zwischen Elementen. Die `VBFixedString` Attribut angewendet werden kann, Zeichenfolgenfelder in den Strukturen, das die Größe der Zeichenfolge beim Schreiben auf den Datenträger.  
  
    > [!NOTE]
    >  Felder, die mehr als Bytes angegeben Zeichenfolge die `VBFixedString` Attribut werden abgeschnitten, beim Schreiben auf den Datenträger  
  
## <a name="binary-mode"></a>Binärmodus  
 Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` Modus Regeln anzuwenden, bis auf einige Ausnahmen. Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:  
  
-   Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen. `FilePut` Schreibt alle Variablen zusammenhängend, d. h. ohne Leerraum zwischen Datensätzen Datenträger.  
  
-   Für ein beliebiges Array als ein Array in einer Struktur `FilePut` schreibt nur die Daten. Es wird kein Deskriptor geschrieben.  
  
-   `FilePut` Schreibt die Zeichenfolgen mit variabler Länge, die nicht Elemente der Strukturen sind, ohne die von 2-Byte-Längendeskriptor. Die Anzahl der geschriebenen Bytes entspricht die Anzahl der Zeichen in der Zeichenfolge. Beispielsweise schreiben die folgenden Anweisungen 11 Bytes beträgt, Dateinummer 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Schreiben in eine Datei mit den `FilePut` -Funktion erfordert `Write` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `FilePut` Funktion, um Daten in eine Datei zu schreiben. Fünf Datensätze in der Struktur `Person` in die Datei geschrieben werden.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</exception>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, DateTime Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, valuetype System.DateTime Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As DateTime, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * DateTime * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="Value">Erforderlich. Gültiger Variablenname, der auf den Datenträger geschriebene Daten enthält.</param>
        <param name="RecordNumber">Dies ist optional. Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), an der der Schreibvorgang beginnt.</param>
        <summary>Schreibt Daten aus einer Variablen in eine Datei auf einem Datenträger. Die <see langword="My" />-Funktion bietet eine höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FilePut" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` gilt nur in `Random` und `Binary` Modus.  
  
 Mit `FilePut` geschriebene Daten werden normalerweise mit `FileGet` aus einer Datei gelesen.  
  
 Der erste Datensatz oder Bytes in eine Datei ist an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 und So weiter. Wenn Sie weglassen `RecordNumber`, den nächsten Datensatz bzw. Byte nach dem letzten `FileGet` oder `FilePut` Funktion oder auf die von der letzten gezeigt `Seek` Funktion geschrieben ist.  
  
 Die `StringIsFixedLength` -Argument steuert, ob die Funktion Zeichenfolgen variabler oder fester Länge interpretiert. `FilePut` den Längendeskriptor wird nicht geschrieben werden, wenn das Argument ist `True`. Bei Verwendung von `StringIsFixedLength`  =  `True` mit `FilePut`, müssen Sie das gleiche mit `FileGet`, und Sie müssen sicherstellen, dass die Zeichenfolge mit der erwarteten Länge initialisiert wird.  
  
## <a name="random-mode"></a>Zufällige Modus  
 Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:  
  
-   Wenn die Länge des zu schreibenden Daten kleiner als die Länge, die im angegebenen die `RecordLength` -Klausel der `FileOpen` -Funktion `FilePut` nachfolgende Datensätze auf Datensatzlänge schreibt. Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt. Da die Menge der Daten der Auffüllung nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen eine gute Idee, die Datensatzlänge die Länge des zu schreibenden Daten überein. Ist die Länge des zu schreibenden Daten größer als die Länge angegeben wird, der `RecordLength` -Klausel der `FileOpen` -Funktion eine Ausnahme ausgelöst.  
  
-   Wenn die Variable geschrieben wird eine Zeichenfolge, `FilePut` schreibt einen 2-Byte-Deskriptor, die Länge der Zeichenfolge enthält, und schreibt dann die Daten, die in der Variablen wechselt. Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge sein.  
  
-   Wenn die Variable geschrieben wird ein Objekt, das einen numerischen Typ enthält, `FilePut` schreibt zwei Bytes zur Identifizierung der `VarType` des Objekts und schreibt dann die Variable. Enthält z. B. wenn ein Objekt zu schreiben, die eine ganze Zahl, `FilePut` schreibt sechs Bytes: 2 Bytes, die das Objekt als identifizieren `VarType(3)` (`Integer`) und vier Bytes, die Daten enthalten. Die Datensatzlänge gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss größer als die tatsächliche Anzahl von Bytes zum Speichern der Variablen benötigt mindestens zwei Bytes sein.  
  
-   Wenn die Variable geschrieben wird ein Objekt, das eine Zeichenfolge, enthält `FilePut` schreibt eine 2-Byte-Deskriptor, identifiziert die `VarType(8)` des Objekts ein 2-Byte-Deskriptor, der angibt, der Länge der Zeichenfolge ein, und klicken Sie dann die Zeichenfolgendaten. Die Datensatzlänge gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss über mindestens vier Bytes größer als die tatsächliche Länge der Zeichenfolge sein. Wenn Sie eine Zeichenfolge ohne den Deskriptor ablegen möchten, sollten Sie übergeben `True` auf die `StringIsFixedLength` -Parameter, und die Zeichenfolge, die Sie lesen in muss die richtige Länge.  
  
-   Wenn die Zielvariable ein Array ist, müssen Sie entscheiden, ob einen Deskriptor für die Größe und die Dimensionen des Arrays zu schreiben. Schreiben den Dateideskriptor für ein dynamisches Array aber nicht für Arrays mit fester Größe, Visual Basic 6.0 und früheren Versionen. Visual Basic 2005 standardmäßig nicht das Schreiben des Deskriptors. Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`. Wenn Sie das Array zu schreiben, müssen Sie die Möglichkeit zu entsprechen, die das Array gelesen werden; Wenn sie mit der gelesen wird, müssen Sie den Deskriptor schreiben. Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang. Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl der Dimensionen: (2 + 8 * NumberOfDimensions). Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Deskriptor des Arrays zu schreiben. Beispielsweise erfordert die folgende Arraydeklaration 218 Bytes, wenn das Array geschrieben wird auf dem Datenträger.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Wenn die Variable geschrieben wird einen anderen Typ von Variablen (keine Zeichenfolge variabler Länge oder ein Objekt), `FilePut` schreibt nur die Daten der Variablen. Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge des zu schreibenden Daten.  
  
-   `FilePut` Schreibt die Elemente von Strukturen als ob jedes einzeln geschrieben wäre jedoch ohne Abstand zwischen Elementen. Die `VBFixedString` Attribut angewendet werden kann, Zeichenfolgenfelder in den Strukturen, das die Größe der Zeichenfolge beim Schreiben auf den Datenträger.  
  
    > [!NOTE]
    >  Felder, die mehr als Bytes angegeben Zeichenfolge die `VBFixedString` Attribut werden abgeschnitten, beim Schreiben auf den Datenträger  
  
## <a name="binary-mode"></a>Binärmodus  
 Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` Modus Regeln anzuwenden, bis auf einige Ausnahmen. Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:  
  
-   Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen. `FilePut` Schreibt alle Variablen zusammenhängend, d. h. ohne Leerraum zwischen Datensätzen Datenträger.  
  
-   Für ein beliebiges Array als ein Array in einer Struktur `FilePut` schreibt nur die Daten. Es wird kein Deskriptor geschrieben.  
  
-   `FilePut` Schreibt die Zeichenfolgen mit variabler Länge, die nicht Elemente der Strukturen sind, ohne die von 2-Byte-Längendeskriptor. Die Anzahl der geschriebenen Bytes entspricht die Anzahl der Zeichen in der Zeichenfolge. Beispielsweise schreiben die folgenden Anweisungen 11 Bytes beträgt, Dateinummer 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Schreiben in eine Datei mit den `FilePut` -Funktion erfordert `Write` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `FilePut` Funktion, um Daten in eine Datei zu schreiben. Fünf Datensätze in der Struktur `Person` in die Datei geschrieben werden.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</exception>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, decimal Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, valuetype System.Decimal Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Decimal, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * decimal * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="Value">Erforderlich. Gültiger Variablenname, der auf den Datenträger geschriebene Daten enthält.</param>
        <param name="RecordNumber">Dies ist optional. Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), an der der Schreibvorgang beginnt.</param>
        <summary>Schreibt Daten aus einer Variablen in eine Datei auf einem Datenträger. Die <see langword="My" />-Funktion bietet eine höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FilePut" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` gilt nur in `Random` und `Binary` Modus.  
  
 Mit `FilePut` geschriebene Daten werden normalerweise mit `FileGet` aus einer Datei gelesen.  
  
 Der erste Datensatz oder Bytes in eine Datei ist an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 und So weiter. Wenn Sie weglassen `RecordNumber`, den nächsten Datensatz bzw. Byte nach dem letzten `FileGet` oder `FilePut` Funktion oder auf die von der letzten gezeigt `Seek` Funktion geschrieben ist.  
  
 Die `StringIsFixedLength` -Argument steuert, ob die Funktion Zeichenfolgen variabler oder fester Länge interpretiert. `FilePut` den Längendeskriptor wird nicht geschrieben werden, wenn das Argument ist `True`. Bei Verwendung von `StringIsFixedLength`  =  `True` mit `FilePut`, müssen Sie das gleiche mit `FileGet`, und Sie müssen sicherstellen, dass die Zeichenfolge mit der erwarteten Länge initialisiert wird.  
  
## <a name="random-mode"></a>Zufällige Modus  
 Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:  
  
-   Wenn die Länge des zu schreibenden Daten kleiner als die Länge, die im angegebenen die `RecordLength` -Klausel der `FileOpen` -Funktion `FilePut` nachfolgende Datensätze auf Datensatzlänge schreibt. Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt. Da die Menge der Daten der Auffüllung nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen eine gute Idee, die Datensatzlänge die Länge des zu schreibenden Daten überein. Ist die Länge des zu schreibenden Daten größer als die Länge angegeben wird, der `RecordLength` -Klausel der `FileOpen` -Funktion eine Ausnahme ausgelöst.  
  
-   Wenn die Variable geschrieben wird eine Zeichenfolge, `FilePut` schreibt einen 2-Byte-Deskriptor, die Länge der Zeichenfolge enthält, und schreibt dann die Daten, die in der Variablen wechselt. Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge sein.  
  
-   Wenn die Variable geschrieben wird ein Objekt, das einen numerischen Typ enthält, `FilePut` schreibt zwei Bytes zur Identifizierung der `VarType` des Objekts und schreibt dann die Variable. Enthält z. B. wenn ein Objekt zu schreiben, die eine ganze Zahl, `FilePut` schreibt sechs Bytes: 2 Bytes, die das Objekt als identifizieren `VarType(3)` (`Integer`) und vier Bytes, die Daten enthalten. Die Datensatzlänge gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss größer als die tatsächliche Anzahl von Bytes zum Speichern der Variablen benötigt mindestens zwei Bytes sein.  
  
-   Wenn die Variable geschrieben wird ein Objekt, das eine Zeichenfolge, enthält `FilePut` schreibt eine 2-Byte-Deskriptor, identifiziert die `VarType(8)` des Objekts ein 2-Byte-Deskriptor, der angibt, der Länge der Zeichenfolge ein, und klicken Sie dann die Zeichenfolgendaten. Die Datensatzlänge gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss über mindestens vier Bytes größer als die tatsächliche Länge der Zeichenfolge sein. Wenn Sie eine Zeichenfolge ohne den Deskriptor ablegen möchten, sollten Sie übergeben `True` auf die `StringIsFixedLength` -Parameter, und die Zeichenfolge, die Sie lesen in muss die richtige Länge.  
  
-   Wenn die Zielvariable ein Array ist, müssen Sie entscheiden, ob einen Deskriptor für die Größe und die Dimensionen des Arrays zu schreiben. Schreiben den Dateideskriptor für ein dynamisches Array aber nicht für Arrays mit fester Größe, Visual Basic 6.0 und früheren Versionen. Visual Basic 2005 standardmäßig nicht das Schreiben des Deskriptors. Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`. Wenn Sie das Array zu schreiben, müssen Sie die Möglichkeit zu entsprechen, die das Array gelesen werden; Wenn sie mit der gelesen wird, müssen Sie den Deskriptor schreiben. Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang. Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl der Dimensionen: (2 + 8 * NumberOfDimensions). Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Deskriptor des Arrays zu schreiben. Beispielsweise erfordert die folgende Arraydeklaration 218 Bytes, wenn das Array geschrieben wird auf dem Datenträger.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Wenn die Variable geschrieben wird einen anderen Typ von Variablen (keine Zeichenfolge variabler Länge oder ein Objekt), `FilePut` schreibt nur die Daten der Variablen. Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge des zu schreibenden Daten.  
  
-   `FilePut` Schreibt die Elemente von Strukturen als ob jedes einzeln geschrieben wäre jedoch ohne Abstand zwischen Elementen. Die `VBFixedString` Attribut angewendet werden kann, Zeichenfolgenfelder in den Strukturen, das die Größe der Zeichenfolge beim Schreiben auf den Datenträger.  
  
    > [!NOTE]
    >  Felder, die mehr als Bytes angegeben Zeichenfolge die `VBFixedString` Attribut werden abgeschnitten, beim Schreiben auf den Datenträger  
  
## <a name="binary-mode"></a>Binärmodus  
 Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` Modus Regeln anzuwenden, bis auf einige Ausnahmen. Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:  
  
-   Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen. `FilePut` Schreibt alle Variablen zusammenhängend, d. h. ohne Leerraum zwischen Datensätzen Datenträger.  
  
-   Für ein beliebiges Array als ein Array in einer Struktur `FilePut` schreibt nur die Daten. Es wird kein Deskriptor geschrieben.  
  
-   `FilePut` Schreibt die Zeichenfolgen mit variabler Länge, die nicht Elemente der Strukturen sind, ohne die von 2-Byte-Längendeskriptor. Die Anzahl der geschriebenen Bytes entspricht die Anzahl der Zeichen in der Zeichenfolge. Beispielsweise schreiben die folgenden Anweisungen 11 Bytes beträgt, Dateinummer 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Schreiben in eine Datei mit den `FilePut` -Funktion erfordert `Write` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `FilePut` Funktion, um Daten in eine Datei zu schreiben. Fünf Datensätze in der Struktur `Person` in die Datei geschrieben werden.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</exception>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, double Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, float64 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Double, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * double * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="Value">Erforderlich. Gültiger Variablenname, der auf den Datenträger geschriebene Daten enthält.</param>
        <param name="RecordNumber">Dies ist optional. Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), an der der Schreibvorgang beginnt.</param>
        <summary>Schreibt Daten aus einer Variablen in eine Datei auf einem Datenträger. Die <see langword="My" />-Funktion bietet eine höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FilePut" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` gilt nur in `Random` und `Binary` Modus.  
  
 Mit `FilePut` geschriebene Daten werden normalerweise mit `FileGet` aus einer Datei gelesen.  
  
 Der erste Datensatz oder Bytes in eine Datei ist an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 und So weiter. Wenn Sie weglassen `RecordNumber`, den nächsten Datensatz bzw. Byte nach dem letzten `FileGet` oder `FilePut` Funktion oder auf die von der letzten gezeigt `Seek` Funktion geschrieben ist.  
  
 Die `StringIsFixedLength` -Argument steuert, ob die Funktion Zeichenfolgen variabler oder fester Länge interpretiert. `FilePut` den Längendeskriptor wird nicht geschrieben werden, wenn das Argument ist `True`. Bei Verwendung von `StringIsFixedLength`  =  `True` mit `FilePut`, müssen Sie das gleiche mit `FileGet`, und Sie müssen sicherstellen, dass die Zeichenfolge mit der erwarteten Länge initialisiert wird.  
  
## <a name="random-mode"></a>Zufällige Modus  
 Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:  
  
-   Wenn die Länge des zu schreibenden Daten kleiner als die Länge, die im angegebenen die `RecordLength` -Klausel der `FileOpen` -Funktion `FilePut` nachfolgende Datensätze auf Datensatzlänge schreibt. Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt. Da die Menge der Daten der Auffüllung nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen eine gute Idee, die Datensatzlänge die Länge des zu schreibenden Daten überein. Ist die Länge des zu schreibenden Daten größer als die Länge angegeben wird, der `RecordLength` -Klausel der `FileOpen` -Funktion eine Ausnahme ausgelöst.  
  
-   Wenn die Variable geschrieben wird eine Zeichenfolge, `FilePut` schreibt einen 2-Byte-Deskriptor, die Länge der Zeichenfolge enthält, und schreibt dann die Daten, die in der Variablen wechselt. Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge sein.  
  
-   Wenn die Variable geschrieben wird ein Objekt, das einen numerischen Typ enthält, `FilePut` schreibt zwei Bytes zur Identifizierung der `VarType` des Objekts und schreibt dann die Variable. Enthält z. B. wenn ein Objekt zu schreiben, die eine ganze Zahl, `FilePut` schreibt sechs Bytes: 2 Bytes, die das Objekt als identifizieren `VarType(3)` (`Integer`) und vier Bytes, die Daten enthalten. Die Datensatzlänge gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss größer als die tatsächliche Anzahl von Bytes zum Speichern der Variablen benötigt mindestens zwei Bytes sein.  
  
-   Wenn die Variable geschrieben wird ein Objekt, das eine Zeichenfolge, enthält `FilePut` schreibt eine 2-Byte-Deskriptor, identifiziert die `VarType(8)` des Objekts ein 2-Byte-Deskriptor, der angibt, der Länge der Zeichenfolge ein, und klicken Sie dann die Zeichenfolgendaten. Die Datensatzlänge gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss über mindestens vier Bytes größer als die tatsächliche Länge der Zeichenfolge sein. Wenn Sie eine Zeichenfolge ohne den Deskriptor ablegen möchten, sollten Sie übergeben `True` auf die `StringIsFixedLength` -Parameter, und die Zeichenfolge, die Sie lesen in muss die richtige Länge.  
  
-   Wenn die Zielvariable ein Array ist, müssen Sie entscheiden, ob einen Deskriptor für die Größe und die Dimensionen des Arrays zu schreiben. Schreiben den Dateideskriptor für ein dynamisches Array aber nicht für Arrays mit fester Größe, Visual Basic 6.0 und früheren Versionen. Visual Basic 2005 standardmäßig nicht das Schreiben des Deskriptors. Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`. Wenn Sie das Array zu schreiben, müssen Sie die Möglichkeit zu entsprechen, die das Array gelesen werden; Wenn sie mit der gelesen wird, müssen Sie den Deskriptor schreiben. Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang. Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl der Dimensionen: (2 + 8 * NumberOfDimensions). Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Deskriptor des Arrays zu schreiben. Beispielsweise erfordert die folgende Arraydeklaration 218 Bytes, wenn das Array geschrieben wird auf dem Datenträger.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Wenn die Variable geschrieben wird einen anderen Typ von Variablen (keine Zeichenfolge variabler Länge oder ein Objekt), `FilePut` schreibt nur die Daten der Variablen. Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge des zu schreibenden Daten.  
  
-   `FilePut` Schreibt die Elemente von Strukturen als ob jedes einzeln geschrieben wäre jedoch ohne Abstand zwischen Elementen. Die `VBFixedString` Attribut angewendet werden kann, Zeichenfolgenfelder in den Strukturen, das die Größe der Zeichenfolge beim Schreiben auf den Datenträger.  
  
    > [!NOTE]
    >  Felder, die mehr als Bytes angegeben Zeichenfolge die `VBFixedString` Attribut werden abgeschnitten, beim Schreiben auf den Datenträger  
  
## <a name="binary-mode"></a>Binärmodus  
 Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` Modus Regeln anzuwenden, bis auf einige Ausnahmen. Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:  
  
-   Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen. `FilePut` Schreibt alle Variablen zusammenhängend, d. h. ohne Leerraum zwischen Datensätzen Datenträger.  
  
-   Für ein beliebiges Array als ein Array in einer Struktur `FilePut` schreibt nur die Daten. Es wird kein Deskriptor geschrieben.  
  
-   `FilePut` Schreibt die Zeichenfolgen mit variabler Länge, die nicht Elemente der Strukturen sind, ohne die von 2-Byte-Längendeskriptor. Die Anzahl der geschriebenen Bytes entspricht die Anzahl der Zeichen in der Zeichenfolge. Beispielsweise schreiben die folgenden Anweisungen 11 Bytes beträgt, Dateinummer 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Schreiben in eine Datei mit den `FilePut` -Funktion erfordert `Write` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `FilePut` Funktion, um Daten in eine Datei zu schreiben. Fünf Datensätze in der Struktur `Person` in die Datei geschrieben werden.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</exception>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, short Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int16 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Short, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * int16 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="Value">Erforderlich. Gültiger Variablenname, der auf den Datenträger geschriebene Daten enthält.</param>
        <param name="RecordNumber">Dies ist optional. Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), an der der Schreibvorgang beginnt.</param>
        <summary>Schreibt Daten aus einer Variablen in eine Datei auf einem Datenträger. Die <see langword="My" />-Funktion bietet eine höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FilePut" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` gilt nur in `Random` und `Binary` Modus.  
  
 Mit `FilePut` geschriebene Daten werden normalerweise mit `FileGet` aus einer Datei gelesen.  
  
 Der erste Datensatz oder Bytes in eine Datei ist an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 und So weiter. Wenn Sie weglassen `RecordNumber`, den nächsten Datensatz bzw. Byte nach dem letzten `FileGet` oder `FilePut` Funktion oder auf die von der letzten gezeigt `Seek` Funktion geschrieben ist.  
  
 Die `StringIsFixedLength` -Argument steuert, ob die Funktion Zeichenfolgen variabler oder fester Länge interpretiert. `FilePut` den Längendeskriptor wird nicht geschrieben werden, wenn das Argument ist `True`. Bei Verwendung von `StringIsFixedLength`  =  `True` mit `FilePut`, müssen Sie das gleiche mit `FileGet`, und Sie müssen sicherstellen, dass die Zeichenfolge mit der erwarteten Länge initialisiert wird.  
  
## <a name="random-mode"></a>Zufällige Modus  
 Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:  
  
-   Wenn die Länge des zu schreibenden Daten kleiner als die Länge, die im angegebenen die `RecordLength` -Klausel der `FileOpen` -Funktion `FilePut` nachfolgende Datensätze auf Datensatzlänge schreibt. Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt. Da die Menge der Daten der Auffüllung nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen eine gute Idee, die Datensatzlänge die Länge des zu schreibenden Daten überein. Ist die Länge des zu schreibenden Daten größer als die Länge angegeben wird, der `RecordLength` -Klausel der `FileOpen` -Funktion eine Ausnahme ausgelöst.  
  
-   Wenn die Variable geschrieben wird eine Zeichenfolge, `FilePut` schreibt einen 2-Byte-Deskriptor, die Länge der Zeichenfolge enthält, und schreibt dann die Daten, die in der Variablen wechselt. Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge sein.  
  
-   Wenn die Variable geschrieben wird ein Objekt, das einen numerischen Typ enthält, `FilePut` schreibt zwei Bytes zur Identifizierung der `VarType` des Objekts und schreibt dann die Variable. Enthält z. B. wenn ein Objekt zu schreiben, die eine ganze Zahl, `FilePut` schreibt sechs Bytes: 2 Bytes, die das Objekt als identifizieren `VarType(3)` (`Integer`) und vier Bytes, die Daten enthalten. Die Datensatzlänge gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss größer als die tatsächliche Anzahl von Bytes zum Speichern der Variablen benötigt mindestens zwei Bytes sein.  
  
-   Wenn die Variable geschrieben wird ein Objekt, das eine Zeichenfolge, enthält `FilePut` schreibt eine 2-Byte-Deskriptor, identifiziert die`VarType(8)` des Objekts ein 2-Byte-Deskriptor, der angibt, der Länge der Zeichenfolge ein, und klicken Sie dann die Zeichenfolgendaten. Die Datensatzlänge gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss über mindestens vier Bytes größer als die tatsächliche Länge der Zeichenfolge sein. Wenn Sie eine Zeichenfolge ohne den Deskriptor ablegen möchten, sollten Sie übergeben `True` auf die `StringIsFixedLength` -Parameter, und die Zeichenfolge, die Sie lesen in muss die richtige Länge.  
  
-   Wenn die Zielvariable ein Array ist, müssen Sie entscheiden, ob einen Deskriptor für die Größe und die Dimensionen des Arrays zu schreiben. Schreiben den Dateideskriptor für ein dynamisches Array aber nicht für Arrays mit fester Größe, Visual Basic 6.0 und früheren Versionen. Visual Basic 2005 standardmäßig nicht das Schreiben des Deskriptors. Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`. Wenn Sie das Array zu schreiben, müssen Sie die Möglichkeit zu entsprechen, die das Array gelesen werden; Wenn sie mit der gelesen wird, müssen Sie den Deskriptor schreiben. Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang. Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl der Dimensionen: (2 + 8 * NumberOfDimensions). Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Deskriptor des Arrays zu schreiben. Beispielsweise erfordert die folgende Arraydeklaration 218 Bytes, wenn das Array geschrieben wird auf dem Datenträger.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Wenn die Variable geschrieben wird einen anderen Typ von Variablen (keine Zeichenfolge variabler Länge oder ein Objekt), `FilePut` schreibt nur die Daten der Variablen. Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge des zu schreibenden Daten.  
  
-   `FilePut` Schreibt die Elemente von Strukturen als ob jedes einzeln geschrieben wäre jedoch ohne Abstand zwischen Elementen. Die `VBFixedString` Attribut angewendet werden kann, Zeichenfolgenfelder in den Strukturen, das die Größe der Zeichenfolge beim Schreiben auf den Datenträger.  
  
    > [!NOTE]
    >  Felder, die mehr als Bytes angegeben Zeichenfolge die `VBFixedString` Attribut werden abgeschnitten, beim Schreiben auf den Datenträger  
  
## <a name="binary-mode"></a>Binärmodus  
 Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` Modus Regeln anzuwenden, bis auf einige Ausnahmen. Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:  
  
-   Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen. `FilePut` Schreibt alle Variablen zusammenhängend, d. h. ohne Leerraum zwischen Datensätzen Datenträger.  
  
-   Für ein beliebiges Array als ein Array in einer Struktur `FilePut` schreibt nur die Daten. Es wird kein Deskriptor geschrieben.  
  
-   `FilePut` Schreibt die Zeichenfolgen mit variabler Länge, die nicht Elemente der Strukturen sind, ohne die von 2-Byte-Längendeskriptor. Die Anzahl der geschriebenen Bytes entspricht die Anzahl der Zeichen in der Zeichenfolge. Beispielsweise schreiben die folgenden Anweisungen 11 Bytes beträgt, Dateinummer 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Schreiben in eine Datei mit den `FilePut` -Funktion erfordert `Write` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `FilePut` Funktion, um Daten in eine Datei zu schreiben. Fünf Datensätze in der Struktur `Person` in die Datei geschrieben werden.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</exception>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, int Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int32 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Integer, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="Value">Erforderlich. Gültiger Variablenname, der auf den Datenträger geschriebene Daten enthält.</param>
        <param name="RecordNumber">Dies ist optional. Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), an der der Schreibvorgang beginnt.</param>
        <summary>Schreibt Daten aus einer Variablen in eine Datei auf einem Datenträger. Die <see langword="My" />-Funktion bietet eine höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FilePut" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` gilt nur in `Random` und `Binary` Modus.  
  
 Mit `FilePut` geschriebene Daten werden normalerweise mit `FileGet` aus einer Datei gelesen.  
  
 Der erste Datensatz oder Bytes in eine Datei ist an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 und So weiter. Wenn Sie weglassen `RecordNumber`, den nächsten Datensatz bzw. Byte nach dem letzten `FileGet` oder `FilePut` Funktion oder auf die von der letzten gezeigt `Seek` Funktion geschrieben ist.  
  
 Die `StringIsFixedLength` -Argument steuert, ob die Funktion Zeichenfolgen variabler oder fester Länge interpretiert. `FilePut` den Längendeskriptor wird nicht geschrieben werden, wenn das Argument ist `True`. Bei Verwendung von `StringIsFixedLength`  =  `True` mit `FilePut`, müssen Sie das gleiche mit `FileGet`, und Sie müssen sicherstellen, dass die Zeichenfolge mit der erwarteten Länge initialisiert wird.  
  
## <a name="random-mode"></a>Zufällige Modus  
 Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:  
  
-   Wenn die Länge des zu schreibenden Daten kleiner als die Länge, die im angegebenen die `RecordLength` -Klausel der `FileOpen` -Funktion `FilePut` nachfolgende Datensätze auf Datensatzlänge schreibt. Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt. Da die Menge der Daten der Auffüllung nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen eine gute Idee, die Datensatzlänge die Länge des zu schreibenden Daten überein. Ist die Länge des zu schreibenden Daten größer als die Länge angegeben wird, der `RecordLength` -Klausel der `FileOpen` -Funktion eine Ausnahme ausgelöst.  
  
-   Wenn die Variable geschrieben wird eine Zeichenfolge, `FilePut` schreibt einen 2-Byte-Deskriptor, die Länge der Zeichenfolge enthält, und schreibt dann die Daten, die in der Variablen wechselt. Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge sein.  
  
-   Wenn die Variable geschrieben wird ein Objekt, das einen numerischen Typ enthält, `FilePut` schreibt zwei Bytes zur Identifizierung der `VarType` des Objekts und schreibt dann die Variable. Enthält z. B. wenn ein Objekt zu schreiben, die eine ganze Zahl, `FilePut` schreibt sechs Bytes: 2 Bytes, die das Objekt als identifizieren `VarType(3)` (`Integer`) und vier Bytes, die Daten enthalten. Die Datensatzlänge gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss größer als die tatsächliche Anzahl von Bytes zum Speichern der Variablen benötigt mindestens zwei Bytes sein.  
  
-   Wenn die Variable geschrieben wird ein Objekt, das eine Zeichenfolge, enthält `FilePut` schreibt eine 2-Byte-Deskriptor, identifiziert die `VarType(8)` des Objekts ein 2-Byte-Deskriptor, der angibt, der Länge der Zeichenfolge ein, und klicken Sie dann die Zeichenfolgendaten. Die Datensatzlänge gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss über mindestens vier Bytes größer als die tatsächliche Länge der Zeichenfolge sein. Wenn Sie eine Zeichenfolge ohne den Deskriptor ablegen möchten, sollten Sie übergeben `True` auf die `StringIsFixedLength` -Parameter, und die Zeichenfolge, die Sie lesen in muss die richtige Länge.  
  
-   Wenn die Zielvariable ein Array ist, müssen Sie entscheiden, ob einen Deskriptor für die Größe und die Dimensionen des Arrays zu schreiben. Schreiben den Dateideskriptor für ein dynamisches Array aber nicht für Arrays mit fester Größe, Visual Basic 6.0 und früheren Versionen. Visual Basic 2005 standardmäßig nicht das Schreiben des Deskriptors. Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`. Wenn Sie das Array zu schreiben, müssen Sie die Möglichkeit zu entsprechen, die das Array gelesen werden; Wenn sie mit der gelesen wird, müssen Sie den Deskriptor schreiben. Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang. Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl der Dimensionen: (2 + 8 * NumberOfDimensions). Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Deskriptor des Arrays zu schreiben. Beispielsweise erfordert die folgende Arraydeklaration 218 Bytes, wenn das Array geschrieben wird auf dem Datenträger.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Wenn die Variable geschrieben wird einen anderen Typ von Variablen (keine Zeichenfolge variabler Länge oder ein Objekt), `FilePut` schreibt nur die Daten der Variablen. Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge des zu schreibenden Daten.  
  
-   `FilePut` Schreibt die Elemente von Strukturen als ob jedes einzeln geschrieben wäre jedoch ohne Abstand zwischen Elementen. Die `VBFixedString` Attribut angewendet werden kann, Zeichenfolgenfelder in den Strukturen, das die Größe der Zeichenfolge beim Schreiben auf den Datenträger.  
  
    > [!NOTE]
    >  Felder, die mehr als Bytes angegeben Zeichenfolge die `VBFixedString` Attribut werden abgeschnitten, beim Schreiben auf den Datenträger  
  
## <a name="binary-mode"></a>Binärmodus  
 Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` Modus Regeln anzuwenden, bis auf einige Ausnahmen. Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:  
  
-   Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen. `FilePut` Schreibt alle Variablen zusammenhängend, d. h. ohne Leerraum zwischen Datensätzen Datenträger.  
  
-   Für ein beliebiges Array als ein Array in einer Struktur `FilePut` schreibt nur die Daten. Es wird kein Deskriptor geschrieben.  
  
-   `FilePut` Schreibt die Zeichenfolgen mit variabler Länge, die nicht Elemente der Strukturen sind, ohne die von 2-Byte-Längendeskriptor. Die Anzahl der geschriebenen Bytes entspricht die Anzahl der Zeichen in der Zeichenfolge. Beispielsweise schreiben die folgenden Anweisungen 11 Bytes beträgt, Dateinummer 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Schreiben in eine Datei mit den `FilePut` -Funktion erfordert `Write` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `FilePut` Funktion, um Daten in eine Datei zu schreiben. Fünf Datensätze in der Struktur `Person` in die Datei geschrieben werden.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</exception>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, long Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int64 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Long, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * int64 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="Value">Erforderlich. Gültiger Variablenname, der auf den Datenträger geschriebene Daten enthält.</param>
        <param name="RecordNumber">Dies ist optional. Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), an der der Schreibvorgang beginnt.</param>
        <summary>Schreibt Daten aus einer Variablen in eine Datei auf einem Datenträger. Die <see langword="My" />-Funktion bietet eine höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FilePut" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` gilt nur in `Random` und `Binary` Modus.  
  
 Mit `FilePut` geschriebene Daten werden normalerweise mit `FileGet` aus einer Datei gelesen.  
  
 Der erste Datensatz oder Bytes in eine Datei ist an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 und So weiter. Wenn Sie weglassen `RecordNumber`, den nächsten Datensatz bzw. Byte nach dem letzten `FileGet` oder `FilePut` Funktion oder auf die von der letzten gezeigt `Seek` Funktion geschrieben ist.  
  
 Die `StringIsFixedLength` -Argument steuert, ob die Funktion Zeichenfolgen variabler oder fester Länge interpretiert. `FilePut` den Längendeskriptor wird nicht geschrieben werden, wenn das Argument ist `True`. Bei Verwendung von `StringIsFixedLength`  =  `True` mit `FilePut`, müssen Sie das gleiche mit `FileGet`, und Sie müssen sicherstellen, dass die Zeichenfolge mit der erwarteten Länge initialisiert wird.  
  
## <a name="random-mode"></a>Zufällige Modus  
 Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:  
  
-   Wenn die Länge des zu schreibenden Daten kleiner als die Länge, die im angegebenen die `RecordLength` -Klausel der `FileOpen` -Funktion `FilePut` nachfolgende Datensätze auf Datensatzlänge schreibt. Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt. Da die Menge der Daten der Auffüllung nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen eine gute Idee, die Datensatzlänge die Länge des zu schreibenden Daten überein. Ist die Länge des zu schreibenden Daten größer als die Länge angegeben wird, der `RecordLength` -Klausel der `FileOpen` -Funktion eine Ausnahme ausgelöst.  
  
-   Wenn die Variable geschrieben wird eine Zeichenfolge, `FilePut` schreibt einen 2-Byte-Deskriptor, die Länge der Zeichenfolge enthält, und schreibt dann die Daten, die in der Variablen wechselt. Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge sein.  
  
-   Wenn die Variable geschrieben wird ein Objekt, das einen numerischen Typ enthält, `FilePut` schreibt zwei Bytes zur Identifizierung der `VarType` des Objekts und schreibt dann die Variable. Enthält z. B. wenn ein Objekt zu schreiben, die eine ganze Zahl, `FilePut` schreibt sechs Bytes: 2 Bytes, die das Objekt als identifizieren `VarType(3)` (`Integer`) und vier Bytes, die Daten enthalten. Die Datensatzlänge gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss größer als die tatsächliche Anzahl von Bytes zum Speichern der Variablen benötigt mindestens zwei Bytes sein.  
  
-   Wenn die Variable geschrieben wird ein Objekt, das eine Zeichenfolge, enthält `FilePut` schreibt eine 2-Byte-Deskriptor, identifiziert die `VarType(8)` des Objekts ein 2-Byte-Deskriptor, der angibt, der Länge der Zeichenfolge ein, und klicken Sie dann die Zeichenfolgendaten. Die Datensatzlänge gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss über mindestens vier Bytes größer als die tatsächliche Länge der Zeichenfolge sein. Wenn Sie eine Zeichenfolge ohne den Deskriptor ablegen möchten, sollten Sie übergeben `True` auf die `StringIsFixedLength` -Parameter, und die Zeichenfolge, die Sie lesen in muss die richtige Länge.  
  
-   Wenn die Zielvariable ein Array ist, müssen Sie entscheiden, ob einen Deskriptor für die Größe und die Dimensionen des Arrays zu schreiben. Schreiben den Dateideskriptor für ein dynamisches Array aber nicht für Arrays mit fester Größe, Visual Basic 6.0 und früheren Versionen. Visual Basic 2005 standardmäßig nicht das Schreiben des Deskriptors. Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`. Wenn Sie das Array zu schreiben, müssen Sie die Möglichkeit zu entsprechen, die das Array gelesen werden; Wenn sie mit der gelesen wird, müssen Sie den Deskriptor schreiben. Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang. Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl der Dimensionen: (2 + 8 * NumberOfDimensions). Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Deskriptor des Arrays zu schreiben. Beispielsweise erfordert die folgende Arraydeklaration 218 Bytes, wenn das Array geschrieben wird auf dem Datenträger.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Wenn die Variable geschrieben wird einen anderen Typ von Variablen (keine Zeichenfolge variabler Länge oder ein Objekt), `FilePut` schreibt nur die Daten der Variablen. Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge des zu schreibenden Daten.  
  
-   `FilePut` Schreibt die Elemente von Strukturen als ob jedes einzeln geschrieben wäre jedoch ohne Abstand zwischen Elementen. Die `VBFixedString` Attribut angewendet werden kann, Zeichenfolgenfelder in den Strukturen, das die Größe der Zeichenfolge beim Schreiben auf den Datenträger.  
  
    > [!NOTE]
    >  Felder, die mehr als Bytes angegeben Zeichenfolge die `VBFixedString` Attribut werden abgeschnitten, beim Schreiben auf den Datenträger  
  
## <a name="binary-mode"></a>Binärmodus  
 Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` Modus Regeln anzuwenden, bis auf einige Ausnahmen. Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:  
  
-   Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen. `FilePut` Schreibt alle Variablen zusammenhängend, d. h. ohne Leerraum zwischen Datensätzen Datenträger.  
  
-   Für ein beliebiges Array als ein Array in einer Struktur `FilePut` schreibt nur die Daten. Es wird kein Deskriptor geschrieben.  
  
-   `FilePut` Schreibt die Zeichenfolgen mit variabler Länge, die nicht Elemente der Strukturen sind, ohne die von 2-Byte-Längendeskriptor. Die Anzahl der geschriebenen Bytes entspricht die Anzahl der Zeichen in der Zeichenfolge. Beispielsweise schreiben die folgenden Anweisungen 11 Bytes beträgt, Dateinummer 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Schreiben in eine Datei mit den `FilePut` -Funktion erfordert `Write` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `FilePut` Funktion, um Daten in eine Datei zu schreiben. Fünf Datensätze in der Struktur `Person` in die Datei geschrieben werden.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</exception>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, float Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, float32 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Single, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * single * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="Value">Erforderlich. Gültiger Variablenname, der auf den Datenträger geschriebene Daten enthält.</param>
        <param name="RecordNumber">Dies ist optional. Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), an der der Schreibvorgang beginnt.</param>
        <summary>Schreibt Daten aus einer Variablen in eine Datei auf einem Datenträger. Die <see langword="My" />-Funktion bietet eine höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FilePut" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` gilt nur in `Random` und `Binary` Modus.  
  
 Mit `FilePut` geschriebene Daten werden normalerweise mit `FileGet` aus einer Datei gelesen.  
  
 Der erste Datensatz oder Bytes in eine Datei ist an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 und So weiter. Wenn Sie weglassen `RecordNumber`, den nächsten Datensatz bzw. Byte nach dem letzten `FileGet` oder `FilePut` Funktion oder auf die von der letzten gezeigt `Seek` Funktion geschrieben ist.  
  
 Die `StringIsFixedLength` -Argument steuert, ob die Funktion Zeichenfolgen variabler oder fester Länge interpretiert. `FilePut` den Längendeskriptor wird nicht geschrieben werden, wenn das Argument ist `True`. Bei Verwendung von `StringIsFixedLength`  =  `True` mit `FilePut`, müssen Sie das gleiche mit `FileGet`, und Sie müssen sicherstellen, dass die Zeichenfolge mit der erwarteten Länge initialisiert wird.  
  
## <a name="random-mode"></a>Zufällige Modus  
 Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:  
  
-   Wenn die Länge des zu schreibenden Daten kleiner als die Länge, die im angegebenen die `RecordLength` -Klausel der `FileOpen` -Funktion `FilePut` nachfolgende Datensätze auf Datensatzlänge schreibt. Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt. Da die Menge der Daten der Auffüllung nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen eine gute Idee, die Datensatzlänge die Länge des zu schreibenden Daten überein. Ist die Länge des zu schreibenden Daten größer als die Länge angegeben wird, der `RecordLength` -Klausel der `FileOpen` -Funktion eine Ausnahme ausgelöst.  
  
-   Wenn die Variable geschrieben wird eine Zeichenfolge, `FilePut` schreibt einen 2-Byte-Deskriptor, die Länge der Zeichenfolge enthält, und schreibt dann die Daten, die in der Variablen wechselt. Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge sein.  
  
-   Wenn die Variable geschrieben wird ein Objekt, das einen numerischen Typ enthält, `FilePut` schreibt zwei Bytes zur Identifizierung der `VarType` des Objekts und schreibt dann die Variable. Enthält z. B. wenn ein Objekt zu schreiben, die eine ganze Zahl, `FilePut` schreibt sechs Bytes: 2 Bytes, die das Objekt als identifizieren `VarType(3)` (`Integer`) und vier Bytes, die Daten enthalten. Die Datensatzlänge gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss größer als die tatsächliche Anzahl von Bytes zum Speichern der Variablen benötigt mindestens zwei Bytes sein.  
  
-   Wenn die Variable geschrieben wird ein Objekt, das eine Zeichenfolge, enthält `FilePut` schreibt eine 2-Byte-Deskriptor, identifiziert die `VarType(8)` des Objekts ein 2-Byte-Deskriptor, der angibt, der Länge der Zeichenfolge ein, und klicken Sie dann die Zeichenfolgendaten. Die Datensatzlänge gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss über mindestens vier Bytes größer als die tatsächliche Länge der Zeichenfolge sein. Wenn Sie eine Zeichenfolge ohne den Deskriptor ablegen möchten, sollten Sie übergeben `True` auf die `StringIsFixedLength` -Parameter, und die Zeichenfolge, die Sie lesen in muss die richtige Länge.  
  
-   Wenn die Zielvariable ein Array ist, müssen Sie entscheiden, ob einen Deskriptor für die Größe und die Dimensionen des Arrays zu schreiben. Schreiben den Dateideskriptor für ein dynamisches Array aber nicht für Arrays mit fester Größe, Visual Basic 6.0 und früheren Versionen. Visual Basic 2005 standardmäßig nicht das Schreiben des Deskriptors. Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`. Wenn Sie das Array zu schreiben, müssen Sie die Möglichkeit zu entsprechen, die das Array gelesen werden; Wenn sie mit der gelesen wird, müssen Sie den Deskriptor schreiben. Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang. Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl der Dimensionen: (2 + 8 * NumberOfDimensions). Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Deskriptor des Arrays zu schreiben. Beispielsweise erfordert die folgende Arraydeklaration 218 Bytes, wenn das Array geschrieben wird auf dem Datenträger.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Wenn die Variable geschrieben wird einen anderen Typ von Variablen (keine Zeichenfolge variabler Länge oder ein Objekt), `FilePut` schreibt nur die Daten der Variablen. Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge des zu schreibenden Daten.  
  
-   `FilePut` Schreibt die Elemente von Strukturen als ob jedes einzeln geschrieben wäre jedoch ohne Abstand zwischen Elementen. Die `VBFixedString` Attribut angewendet werden kann, Zeichenfolgenfelder in den Strukturen, das die Größe der Zeichenfolge beim Schreiben auf den Datenträger.  
  
    > [!NOTE]
    >  Felder, die mehr als Bytes angegeben Zeichenfolge die `VBFixedString` Attribut werden abgeschnitten, beim Schreiben auf den Datenträger  
  
## <a name="binary-mode"></a>Binärmodus  
 Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` Modus Regeln anzuwenden, bis auf einige Ausnahmen. Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:  
  
-   Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen. `FilePut` Schreibt alle Variablen zusammenhängend, d. h. ohne Leerraum zwischen Datensätzen Datenträger.  
  
-   Für ein beliebiges Array als ein Array in einer Struktur `FilePut` schreibt nur die Daten. Es wird kein Deskriptor geschrieben.  
  
-   `FilePut` Schreibt die Zeichenfolgen mit variabler Länge, die nicht Elemente der Strukturen sind, ohne die von 2-Byte-Längendeskriptor. Die Anzahl der geschriebenen Bytes entspricht die Anzahl der Zeichen in der Zeichenfolge. Beispielsweise schreiben die folgenden Anweisungen 11 Bytes beträgt, Dateinummer 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Schreiben in eine Datei mit den `FilePut` -Funktion erfordert `Write` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `FilePut` Funktion, um Daten in eine Datei zu schreiben. Fünf Datensätze in der Struktur `Person` in die Datei geschrieben werden.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</exception>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, ValueType Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, class System.ValueType Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As ValueType, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * ValueType * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.ValueType" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="Value">Erforderlich. Gültiger Variablenname, der auf den Datenträger geschriebene Daten enthält.</param>
        <param name="RecordNumber">Dies ist optional. Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), an der der Schreibvorgang beginnt.</param>
        <summary>Schreibt Daten aus einer Variablen in eine Datei auf einem Datenträger. Die <see langword="My" />-Funktion bietet eine höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FilePut" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` gilt nur in `Random` und `Binary` Modus.  
  
 Mit `FilePut` geschriebene Daten werden normalerweise mit `FileGet` aus einer Datei gelesen.  
  
 Der erste Datensatz oder Bytes in eine Datei ist an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 und So weiter. Wenn Sie weglassen `RecordNumber`, den nächsten Datensatz bzw. Byte nach dem letzten `FileGet` oder `FilePut` Funktion oder auf die von der letzten gezeigt `Seek` Funktion geschrieben ist.  
  
 Die `StringIsFixedLength` -Argument steuert, ob die Funktion Zeichenfolgen variabler oder fester Länge interpretiert. `FilePut` den Längendeskriptor wird nicht geschrieben werden, wenn das Argument ist `True`. Bei Verwendung von `StringIsFixedLength`  =  `True` mit `FilePut`, müssen Sie das gleiche mit `FileGet`, und Sie müssen sicherstellen, dass die Zeichenfolge mit der erwarteten Länge initialisiert wird.  
  
## <a name="random-mode"></a>Zufällige Modus  
 Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:  
  
-   Wenn die Länge des zu schreibenden Daten kleiner als die Länge, die im angegebenen die`RecordLength` -Klausel der `FileOpen` -Funktion `FilePut` nachfolgende Datensätze auf Datensatzlänge schreibt. Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt. Da die Menge der Daten der Auffüllung nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen eine gute Idee, die Datensatzlänge die Länge des zu schreibenden Daten überein. Ist die Länge des zu schreibenden Daten größer als die Länge angegeben wird, der `RecordLength` -Klausel der `FileOpen` -Funktion eine Ausnahme ausgelöst.  
  
-   Wenn die Variable geschrieben wird eine Zeichenfolge, `FilePut` schreibt einen 2-Byte-Deskriptor, die Länge der Zeichenfolge enthält, und schreibt dann die Daten, die in der Variablen wechselt. Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge sein.  
  
-   Wenn die Variable geschrieben wird ein Objekt, das einen numerischen Typ enthält, `FilePut` schreibt zwei Bytes zur Identifizierung der `VarType` des Objekts und schreibt dann die Variable. Enthält z. B. wenn ein Objekt zu schreiben, die eine ganze Zahl, `FilePut` schreibt sechs Bytes: 2 Bytes, die das Objekt als identifizieren `VarType(3)` (`Integer`) und vier Bytes, die Daten enthalten. Die Datensatzlänge gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss größer als die tatsächliche Anzahl von Bytes zum Speichern der Variablen benötigt mindestens zwei Bytes sein.  
  
-   Wenn die Variable geschrieben wird ein Objekt, das eine Zeichenfolge, enthält `FilePut` schreibt eine 2-Byte-Deskriptor, identifiziert die `VarType(8)` des Objekts ein 2-Byte-Deskriptor, der angibt, der Länge der Zeichenfolge ein, und klicken Sie dann die Zeichenfolgendaten. Die Datensatzlänge gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss über mindestens vier Bytes größer als die tatsächliche Länge der Zeichenfolge sein. Wenn Sie eine Zeichenfolge ohne den Deskriptor ablegen möchten, sollten Sie übergeben `True` auf die `StringIsFixedLength` -Parameter, und die Zeichenfolge, die Sie lesen in muss die richtige Länge.  
  
-   Wenn die Zielvariable ein Array ist, müssen Sie entscheiden, ob einen Deskriptor für die Größe und die Dimensionen des Arrays zu schreiben. Schreiben den Dateideskriptor für ein dynamisches Array aber nicht für Arrays mit fester Größe, Visual Basic 6.0 und früheren Versionen. Visual Basic 2005 standardmäßig nicht das Schreiben des Deskriptors. Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`. Wenn Sie das Array zu schreiben, müssen Sie die Möglichkeit zu entsprechen, die das Array gelesen werden; Wenn sie mit der gelesen wird, müssen Sie den Deskriptor schreiben. Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang. Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl der Dimensionen: (2 + 8 * NumberOfDimensions). Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Deskriptor des Arrays zu schreiben. Beispielsweise erfordert die folgende Arraydeklaration 218 Bytes, wenn das Array geschrieben wird auf dem Datenträger.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Wenn die Variable geschrieben wird einen anderen Typ von Variablen (keine Zeichenfolge variabler Länge oder ein Objekt), `FilePut` schreibt nur die Daten der Variablen. Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge des zu schreibenden Daten.  
  
-   `FilePut` Schreibt die Elemente von Strukturen als ob jedes einzeln geschrieben wäre jedoch ohne Abstand zwischen Elementen. Die `VBFixedString` Attribut angewendet werden kann, Zeichenfolgenfelder in den Strukturen, das die Größe der Zeichenfolge beim Schreiben auf den Datenträger.  
  
    > [!NOTE]
    >  Felder, die mehr als Bytes angegeben Zeichenfolge die `VBFixedString` Attribut werden abgeschnitten, beim Schreiben auf den Datenträger  
  
## <a name="binary-mode"></a>Binärmodus  
 Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` Modus Regeln anzuwenden, bis auf einige Ausnahmen. Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:  
  
-   Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen. `FilePut` Schreibt alle Variablen zusammenhängend, d. h. ohne Leerraum zwischen Datensätzen Datenträger.  
  
-   Für ein beliebiges Array als ein Array in einer Struktur `FilePut` schreibt nur die Daten. Es wird kein Deskriptor geschrieben.  
  
-   `FilePut` Schreibt die Zeichenfolgen mit variabler Länge, die nicht Elemente der Strukturen sind, ohne die von 2-Byte-Längendeskriptor. Die Anzahl der geschriebenen Bytes entspricht die Anzahl der Zeichen in der Zeichenfolge. Beispielsweise schreiben die folgenden Anweisungen 11 Bytes beträgt, Dateinummer 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Schreiben in eine Datei mit den `FilePut` -Funktion erfordert `Write` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `FilePut` Funktion, um Daten in eine Datei zu schreiben. Fünf Datensätze in der Struktur `Person` in die Datei geschrieben werden.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</exception>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (object FileNumber, object Value, object RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(object FileNumber, object Value, object RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Object, Value As Object, Optional RecordNumber As Object = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : obj * obj * obj -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("This member has been deprecated. Please use FilePutObject to write Object types, or coerce FileNumber and RecordNumber to Integer for writing non-Object types. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Obsolete("Use FilePutObject to write Object types, or coerce FileNumber and RecordNumber to Integer for writing non-Object types")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Object" />
        <Parameter Name="Value" Type="System.Object" />
        <Parameter Name="RecordNumber" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="Value">Erforderlich. Gültiger Variablenname, der auf den Datenträger geschriebene Daten enthält.</param>
        <param name="RecordNumber">Dies ist optional. Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), an der der Schreibvorgang beginnt.</param>
        <summary>Schreibt Daten aus einer Variablen in eine Datei auf einem Datenträger. Die <see langword="My" />-Funktion bietet eine höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FilePut" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` gilt nur in `Random` und `Binary` Modus.  
  
 Mit `FilePut` geschriebene Daten werden normalerweise mit `FileGet` aus einer Datei gelesen.  
  
 Der erste Datensatz oder Bytes in eine Datei ist an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 und So weiter. Wenn Sie weglassen `RecordNumber`, den nächsten Datensatz bzw. Byte nach dem letzten `FileGet` oder `FilePut` Funktion oder auf die von der letzten gezeigt `Seek` Funktion geschrieben ist.  
  
 Die `StringIsFixedLength` -Argument steuert, ob die Funktion Zeichenfolgen variabler oder fester Länge interpretiert. `FilePut` den Längendeskriptor wird nicht geschrieben werden, wenn das Argument ist `True`. Bei Verwendung von `StringIsFixedLength`  =  `True` mit `FilePut`, müssen Sie das gleiche mit `FileGet`, und Sie müssen sicherstellen, dass die Zeichenfolge mit der erwarteten Länge initialisiert wird.  
  
## <a name="random-mode"></a>Zufällige Modus  
 Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:  
  
-   Wenn die Länge des zu schreibenden Daten kleiner als die Länge, die im angegebenen die `RecordLength` -Klausel der `FileOpen` -Funktion `FilePut` nachfolgende Datensätze auf Datensatzlänge schreibt. Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt. Da die Menge der Daten der Auffüllung nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen eine gute Idee, die Datensatzlänge die Länge des zu schreibenden Daten überein. Ist die Länge des zu schreibenden Daten größer als die Länge angegeben wird, der `RecordLength` -Klausel der `FileOpen` -Funktion eine Ausnahme ausgelöst.  
  
-   Wenn die Variable geschrieben wird eine Zeichenfolge, `FilePut` schreibt einen 2-Byte-Deskriptor, die Länge der Zeichenfolge enthält, und schreibt dann die Daten, die in der Variablen wechselt. Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge sein.  
  
-   Wenn die Variable geschrieben wird ein Objekt, das einen numerischen Typ enthält, `FilePut` schreibt zwei Bytes zur Identifizierung der `VarType` des Objekts und schreibt dann die Variable. Enthält z. B. wenn ein Objekt zu schreiben, die eine ganze Zahl, `FilePut` schreibt sechs Bytes: 2 Bytes, die das Objekt als identifizieren `VarType(3)` (`Integer`) und vier Bytes, die Daten enthalten. Die Datensatzlänge gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss größer als die tatsächliche Anzahl von Bytes zum Speichern der Variablen benötigt mindestens zwei Bytes sein.  
  
-   Wenn die Variable geschrieben wird ein Objekt, das eine Zeichenfolge, enthält `FilePut` schreibt eine 2-Byte-Deskriptor, identifiziert die `VarType(8)` des Objekts ein 2-Byte-Deskriptor, der angibt, der Länge der Zeichenfolge ein, und klicken Sie dann die Zeichenfolgendaten. Die Datensatzlänge gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss über mindestens vier Bytes größer als die tatsächliche Länge der Zeichenfolge sein. Wenn Sie eine Zeichenfolge ohne den Deskriptor ablegen möchten, sollten Sie übergeben `True` auf die `StringIsFixedLength` -Parameter, und die Zeichenfolge, die Sie lesen in muss die richtige Länge.  
  
-   Wenn die Zielvariable ein Array ist, müssen Sie entscheiden, ob einen Deskriptor für die Größe und die Dimensionen des Arrays zu schreiben. Schreiben den Dateideskriptor für ein dynamisches Array aber nicht für Arrays mit fester Größe, Visual Basic 6.0 und früheren Versionen. Visual Basic 2005 standardmäßig nicht das Schreiben des Deskriptors. Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`. Wenn Sie das Array zu schreiben, müssen Sie die Möglichkeit zu entsprechen, die das Array gelesen werden; Wenn sie mit der gelesen wird, müssen Sie den Deskriptor schreiben. Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang. Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl der Dimensionen: (2 + 8 * NumberOfDimensions). Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Deskriptor des Arrays zu schreiben. Beispielsweise erfordert die folgende Arraydeklaration 218 Bytes, wenn das Array geschrieben wird auf dem Datenträger.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Wenn die Variable geschrieben wird einen anderen Typ von Variablen (keine Zeichenfolge variabler Länge oder ein Objekt), `FilePut` schreibt nur die Daten der Variablen. Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge des zu schreibenden Daten.  
  
-   `FilePut` Schreibt die Elemente von Strukturen als ob jedes einzeln geschrieben wäre jedoch ohne Abstand zwischen Elementen. Die `VBFixedString` Attribut angewendet werden kann, Zeichenfolgenfelder in den Strukturen, das die Größe der Zeichenfolge beim Schreiben auf den Datenträger.  
  
    > [!NOTE]
    >  Felder, die mehr als Bytes angegeben Zeichenfolge die `VBFixedString` Attribut werden abgeschnitten, beim Schreiben auf den Datenträger  
  
## <a name="binary-mode"></a>Binärmodus  
 Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` Modus Regeln anzuwenden, bis auf einige Ausnahmen. Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:  
  
-   Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen. `FilePut` Schreibt alle Variablen zusammenhängend, d. h. ohne Leerraum zwischen Datensätzen Datenträger.  
  
-   Für ein beliebiges Array als ein Array in einer Struktur `FilePut` schreibt nur die Daten. Es wird kein Deskriptor geschrieben.  
  
-   `FilePut` Schreibt die Zeichenfolgen mit variabler Länge, die nicht Elemente der Strukturen sind, ohne die von 2-Byte-Längendeskriptor. Die Anzahl der geschriebenen Bytes entspricht die Anzahl der Zeichen in der Zeichenfolge. Beispielsweise schreiben die folgenden Anweisungen 11 Bytes beträgt, Dateinummer 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Schreiben in eine Datei mit den `FilePut` -Funktion erfordert `Write` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `FilePut` Funktion, um Daten in eine Datei zu schreiben. Fünf Datensätze in der Struktur `Person` in die Datei geschrieben werden.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</exception>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, string Value, long RecordNumber = -1, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, string Value, int64 RecordNumber, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As String, Optional RecordNumber As Long = -1, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * string * int64 * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="Value">Erforderlich. Gültiger Variablenname, der auf den Datenträger geschriebene Daten enthält.</param>
        <param name="RecordNumber">Dies ist optional. Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), an der der Schreibvorgang beginnt.</param>
        <param name="StringIsFixedLength">Dies ist optional. Betrifft nur das Schreiben einer Zeichenfolge. Gibt an, ob ein 2-Byte-Zeichenfolgenlängendeskriptor in die Datei für die Zeichenfolge geschrieben werden soll. Der Standardwert ist <see langword="False" />.</param>
        <summary>Schreibt Daten aus einer Variablen in eine Datei auf einem Datenträger. Die <see langword="My" />-Funktion bietet eine höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FilePut" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` gilt nur in `Random` und `Binary` Modus.  
  
 Mit `FilePut` geschriebene Daten werden normalerweise mit `FileGet` aus einer Datei gelesen.  
  
 Der erste Datensatz oder Bytes in eine Datei ist an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 und So weiter. Wenn Sie weglassen `RecordNumber`, den nächsten Datensatz bzw. Byte nach dem letzten `FileGet` oder `FilePut` Funktion oder auf die von der letzten gezeigt `Seek` Funktion geschrieben ist.  
  
 Die `StringIsFixedLength` -Argument steuert, ob die Funktion Zeichenfolgen variabler oder fester Länge interpretiert. `FilePut` den Längendeskriptor wird nicht geschrieben werden, wenn das Argument ist `True`. Bei Verwendung von `StringIsFixedLength`  =  `True` mit `FilePut`, müssen Sie das gleiche mit `FileGet`, und Sie müssen sicherstellen, dass die Zeichenfolge mit der erwarteten Länge initialisiert wird.  
  
## <a name="random-mode"></a>Zufällige Modus  
 Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:  
  
-   Wenn die Länge des zu schreibenden Daten kleiner als die Länge, die im angegebenen die `RecordLength` -Klausel der `FileOpen` -Funktion `FilePut` nachfolgende Datensätze auf Datensatzlänge schreibt. Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt. Da die Menge der Daten der Auffüllung nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen eine gute Idee, die Datensatzlänge die Länge des zu schreibenden Daten überein. Ist die Länge des zu schreibenden Daten größer als die Länge angegeben wird, der `RecordLength` -Klausel der `FileOpen` -Funktion eine Ausnahme ausgelöst.  
  
-   Wenn die Variable geschrieben wird eine Zeichenfolge, `FilePut` schreibt einen 2-Byte-Deskriptor, die Länge der Zeichenfolge enthält, und schreibt dann die Daten, die in der Variablen wechselt. Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge sein.  
  
-   Wenn die Variable geschrieben wird ein Objekt, das einen numerischen Typ enthält, `FilePut` schreibt zwei Bytes zur Identifizierung der `VarType` des Objekts und schreibt dann die Variable. Enthält z. B. wenn ein Objekt zu schreiben, die eine ganze Zahl, `FilePut` schreibt sechs Bytes: 2 Bytes, die das Objekt als identifizieren `VarType(3)` (`Integer`) und vier Bytes, die Daten enthalten. Die Datensatzlänge gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss größer als die tatsächliche Anzahl von Bytes zum Speichern der Variablen benötigt mindestens zwei Bytes sein.  
  
-   Wenn die Variable geschrieben wird ein Objekt, das eine Zeichenfolge, enthält `FilePut` schreibt eine 2-Byte-Deskriptor, identifiziert die `VarType(8)` des Objekts ein 2-Byte-Deskriptor, der angibt, der Länge der Zeichenfolge ein, und klicken Sie dann die Zeichenfolgendaten. Die Datensatzlänge gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss über mindestens vier Bytes größer als die tatsächliche Länge der Zeichenfolge sein. Wenn Sie eine Zeichenfolge ohne den Deskriptor ablegen möchten, sollten Sie übergeben `True` auf die `StringIsFixedLength` -Parameter, und die Zeichenfolge, die Sie lesen in muss die richtige Länge.  
  
-   Wenn die Zielvariable ein Array ist, müssen Sie entscheiden, ob einen Deskriptor für die Größe und die Dimensionen des Arrays zu schreiben. Schreiben den Dateideskriptor für ein dynamisches Array aber nicht für Arrays mit fester Größe, Visual Basic 6.0 und früheren Versionen. Visual Basic 2005 standardmäßig nicht das Schreiben des Deskriptors. Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`. Wenn Sie das Array zu schreiben, müssen Sie die Möglichkeit zu entsprechen, die das Array gelesen werden; Wenn sie mit der gelesen wird, müssen Sie den Deskriptor schreiben. Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang. Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl der Dimensionen: (2 + 8 * NumberOfDimensions). Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Deskriptor des Arrays zu schreiben. Beispielsweise erfordert die folgende Arraydeklaration 218 Bytes, wenn das Array geschrieben wird auf dem Datenträger.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Wenn die Variable geschrieben wird einen anderen Typ von Variablen (keine Zeichenfolge variabler Länge oder ein Objekt), `FilePut` schreibt nur die Daten der Variablen. Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge des zu schreibenden Daten.  
  
-   `FilePut` Schreibt die Elemente von Strukturen als ob jedes einzeln geschrieben wäre jedoch ohne Abstand zwischen Elementen. Die `VBFixedString` Attribut angewendet werden kann, Zeichenfolgenfelder in den Strukturen, das die Größe der Zeichenfolge beim Schreiben auf den Datenträger.  
  
    > [!NOTE]
    >  Felder, die mehr als Bytes angegeben Zeichenfolge die `VBFixedString` Attribut werden abgeschnitten, beim Schreiben auf den Datenträger  
  
## <a name="binary-mode"></a>Binärmodus  
 Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` Modus Regeln anzuwenden, bis auf einige Ausnahmen. Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:  
  
-   Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen. `FilePut` Schreibt alle Variablen zusammenhängend, d. h. ohne Leerraum zwischen Datensätzen Datenträger.  
  
-   Für ein beliebiges Array als ein Array in einer Struktur `FilePut` schreibt nur die Daten. Es wird kein Deskriptor geschrieben.  
  
-   `FilePut` Schreibt die Zeichenfolgen mit variabler Länge, die nicht Elemente der Strukturen sind, ohne die von 2-Byte-Längendeskriptor. Die Anzahl der geschriebenen Bytes entspricht die Anzahl der Zeichen in der Zeichenfolge. Beispielsweise schreiben die folgenden Anweisungen 11 Bytes beträgt, Dateinummer 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Schreiben in eine Datei mit den `FilePut` -Funktion erfordert `Write` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `FilePut` Funktion, um Daten in eine Datei zu schreiben. Fünf Datensätze in der Struktur `Person` in die Datei geschrieben werden.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</exception>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, class System.Array Value, int64 RecordNumber, bool ArrayIsDynamic, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Array, Optional RecordNumber As Long = -1, Optional ArrayIsDynamic As Boolean = false, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * Array * int64 * bool * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber, ArrayIsDynamic, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Array" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="ArrayIsDynamic" Type="System.Boolean" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="Value">Erforderlich. Gültiger Variablenname, der auf den Datenträger geschriebene Daten enthält.</param>
        <param name="RecordNumber">Dies ist optional. Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), an der der Schreibvorgang beginnt.</param>
        <param name="ArrayIsDynamic">Dies ist optional. Betrifft nur das Schreiben eines Arrays. Gibt an, ob das Array als dynamisches Array behandelt werden soll und ein Arraydeskriptor für die Zeichenfolge erforderlich ist, der die Länge beschreibt.</param>
        <param name="StringIsFixedLength">Dies ist optional. Betrifft nur das Schreiben einer Zeichenfolge. Gibt an, ob ein 2-Byte-Zeichenfolgenlängendeskriptor in die Datei für die Zeichenfolge geschrieben werden soll. Der Standardwert ist <see langword="False" />.</param>
        <summary>Schreibt Daten aus einer Variablen in eine Datei auf einem Datenträger. Die <see langword="My" />-Funktion bietet eine höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FilePut" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` gilt nur in `Random` und `Binary` Modus.  
  
 Mit `FilePut` geschriebene Daten werden normalerweise mit `FileGet` aus einer Datei gelesen.  
  
 Der erste Datensatz oder Bytes in eine Datei ist an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 und So weiter. Wenn Sie weglassen `RecordNumber`, den nächsten Datensatz bzw. Byte nach dem letzten `FileGet` oder `FilePut` Funktion oder auf die von der letzten gezeigt `Seek` Funktion geschrieben ist.  
  
 Die `StringIsFixedLength` -Argument steuert, ob die Funktion Zeichenfolgen variabler oder fester Länge interpretiert. `FilePut` den Längendeskriptor wird nicht geschrieben werden, wenn das Argument ist `True`. Bei Verwendung von `StringIsFixedLength`  =  `True` mit `FilePut`, müssen Sie das gleiche mit `FileGet`, und Sie müssen sicherstellen, dass die Zeichenfolge mit der erwarteten Länge initialisiert wird.  
  
## <a name="random-mode"></a>Zufällige Modus  
 Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:  
  
-   Wenn die Länge des zu schreibenden Daten kleiner als die Länge, die im angegebenen die `RecordLength` -Klausel der `FileOpen` -Funktion `FilePut` nachfolgende Datensätze auf Datensatzlänge schreibt. Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt. Da die Menge der Daten der Auffüllung nicht mit Sicherheit bestimmt werden kann, ist es im Allgemeinen eine gute Idee, die Datensatzlänge die Länge des zu schreibenden Daten überein. Ist die Länge des zu schreibenden Daten größer als die Länge angegeben wird, der `RecordLength` -Klausel der `FileOpen` -Funktion eine Ausnahme ausgelöst.  
  
-   Wenn die Variable geschrieben wird eine Zeichenfolge, `FilePut` schreibt einen 2-Byte-Deskriptor, die Länge der Zeichenfolge enthält, und schreibt dann die Daten, die in der Variablen wechselt. Aus diesem Grund die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss über mindestens zwei Bytes größer als die tatsächliche Länge der Zeichenfolge sein.  
  
-   Wenn die Variable geschrieben wird ein Objekt, das einen numerischen Typ enthält, `FilePut` schreibt zwei Bytes zur Identifizierung der `VarType` des Objekts und schreibt dann die Variable. Enthält z. B. wenn ein Objekt zu schreiben, die eine ganze Zahl, `FilePut` schreibt sechs Bytes: 2 Bytes, die das Objekt als identifizieren `VarType(3)` (`Integer`) und vier Bytes, die Daten enthalten. Die Datensatzlänge gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss größer als die tatsächliche Anzahl von Bytes zum Speichern der Variablen benötigt mindestens zwei Bytes sein.  
  
-   Wenn die Variable geschrieben wird ein Objekt, das eine Zeichenfolge, enthält `FilePut` schreibt eine 2-Byte-Deskriptor, identifiziert die `VarType(8)` des Objekts ein 2-Byte-Deskriptor, der angibt, der Länge der Zeichenfolge ein, und klicken Sie dann die Zeichenfolgendaten. Die Datensatzlänge gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss über mindestens vier Bytes größer als die tatsächliche Länge der Zeichenfolge sein. Wenn Sie eine Zeichenfolge ohne den Deskriptor ablegen möchten, sollten Sie übergeben `True` auf die `StringIsFixedLength` -Parameter, und die Zeichenfolge, die Sie lesen in muss die richtige Länge.  
  
-   Wenn die Zielvariable ein Array ist, müssen Sie entscheiden, ob einen Deskriptor für die Größe und die Dimensionen des Arrays zu schreiben. Schreiben den Dateideskriptor für ein dynamisches Array aber nicht für Arrays mit fester Größe, Visual Basic 6.0 und früheren Versionen. Visual Basic 2005 standardmäßig nicht das Schreiben des Deskriptors. Legen Sie zum Schreiben des Deskriptors der `ArrayIsDynamic` Parameter `True`. Wenn Sie das Array zu schreiben, müssen Sie die Möglichkeit zu entsprechen, die das Array gelesen werden; Wenn sie mit der gelesen wird, müssen Sie den Deskriptor schreiben. Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang. Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl der Dimensionen: (2 + 8 * NumberOfDimensions). Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Deskriptor des Arrays zu schreiben. Beispielsweise erfordert die folgende Arraydeklaration 218 Bytes, wenn das Array geschrieben wird auf dem Datenträger.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Wenn die Variable geschrieben wird einen anderen Typ von Variablen (keine Zeichenfolge variabler Länge oder ein Objekt), `FilePut` schreibt nur die Daten der Variablen. Die Datensatzlänge gemäß der `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Länge des zu schreibenden Daten.  
  
-   `FilePut` Schreibt die Elemente von Strukturen als ob jedes einzeln geschrieben wäre jedoch ohne Abstand zwischen Elementen. Die `VBFixedString` Attribut angewendet werden kann, Zeichenfolgenfelder in den Strukturen, das die Größe der Zeichenfolge beim Schreiben auf den Datenträger.  
  
    > [!NOTE]
    >  Felder, die mehr als Bytes angegeben Zeichenfolge die `VBFixedString` Attribut werden abgeschnitten, beim Schreiben auf den Datenträger  
  
## <a name="binary-mode"></a>Binärmodus  
 Für Dateien in geöffnet `Binary` Modus, die meisten der `Random` Modus Regeln anzuwenden, bis auf einige Ausnahmen. Die folgenden Regeln für Dateien geöffnet, `Binary` Modus unterscheiden sich von den Regeln für `Random` Modus:  
  
-   Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen. `FilePut` Schreibt alle Variablen zusammenhängend, d. h. ohne Leerraum zwischen Datensätzen Datenträger.  
  
-   Für ein beliebiges Array als ein Array in einer Struktur `FilePut` schreibt nur die Daten. Es wird kein Deskriptor geschrieben.  
  
-   `FilePut` Schreibt die Zeichenfolgen mit variabler Länge, die nicht Elemente der Strukturen sind, ohne die von 2-Byte-Längendeskriptor. Die Anzahl der geschriebenen Bytes entspricht die Anzahl der Zeichen in der Zeichenfolge. Beispielsweise schreiben die folgenden Anweisungen 11 Bytes beträgt, Dateinummer 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Schreiben in eine Datei mit den `FilePut` -Funktion erfordert `Write` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `FilePut` Funktion, um Daten in eine Datei zu schreiben. Fünf Datensätze in der Struktur `Person` in die Datei geschrieben werden.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 und ungleich –1.</exception>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePutObject">
      <MemberSignature Language="C#" Value="public static void FilePutObject (int FileNumber, object Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePutObject(int32 FileNumber, object Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePutObject (FileNumber As Integer, Value As Object, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePutObject : int * obj * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePutObject (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="Value">Erforderlich. Gültiger Variablenname, der auf den Datenträger geschriebene Daten enthält.</param>
        <param name="RecordNumber">Dies ist optional. Datensatznummer (Dateien im <see langword="Random" />-Modus) oder Bytenummer (Dateien im <see langword="Binary" />-Modus), an der der Schreibvorgang beginnt.</param>
        <summary>Schreibt Daten aus einer Variablen in eine Datei auf einem Datenträger.  Die <see langword="My" />-Funktion bietet eine höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FilePutObject" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `FilePutObject` Funktion dient anstelle von `FilePut` um Mehrdeutigkeiten zum Zeitpunkt der Kompilierung zu vermeiden, wenn Typ `Object` wird z. B. anstelle eines anderen Typs übergeben `Integer`, `Long`, `Short`usw.  
  
 `FilePutObject` schreibt, und liest Deskriptoren, die das Objekt zu beschreiben. Wenn Sie beabsichtigen, schreibt die `Variant` Typ `FilePutObject` ist erforderlich. Im Zweifelsfall, wenn Sie ein Objekt für den zweiten Parameter verwenden, wird empfohlen, dass Sie immer verwenden `FilePutObject` und `FileGetObject`.  
  
 `FilePutObject` gilt nur in `Random` und `Binary` Modus.  
  
 Mit `FilePutObject` geschriebene Daten werden normalerweise mit `FileGetObject` aus einer Datei gelesen.  
  
 Der erste Datensatz oder Bytes in eine Datei ist an Position 1, den zweiten Datensatz bzw. das Byte an Position 2 und So weiter. Wenn Sie weglassen `RecordNumber`, `FilePutObject` schreibt den Datensatz bzw. das Byte nach dem letzten `FileGetObject` oder `FilePutObject` Funktion (oder den Datensatz bzw. das Byte zeigt den letzten `Seek` Funktion).  
  
 Die `StringIsFixedLength` -Argument steuert, ob die Funktion Zeichenfolgen variabler oder fester Länge interpretiert. `FilePutObject` den Längendeskriptor wird nicht geschrieben werden, wenn das Argument ist `True`. Bei Verwendung von `StringIsFixedLength`  =  `True` mit `FilePutObject`, müssen Sie das gleiche mit `FileGetObject`, und Sie müssen auch sicherstellen, dass die Zeichenfolge mit der erwarteten Länge initialisiert wird.  
  
## <a name="random-mode"></a>Zufällige Modus  
 Für Dateien in geöffnet `Random` Modus gelten die folgenden Regeln:  
  
-   Wenn die Länge des zu schreibenden Daten kleiner als die Länge, die im angegebenen die `RecordLength` -Klausel der `FileOpen` -Funktion `FilePutObject` nachfolgende Datensätze auf Datensatzlänge schreibt. Der Abstand zwischen dem Ende eines Datensatzes und dem Beginn des nächsten Datensatzes wird mit den vorhandenen Inhalt des Dateipuffers aufgefüllt. Da die Menge der Daten der Auffüllung nicht genau bestimmt werden kann, ist es im Allgemeinen eine gute Idee, die Datensatzlänge die Länge des zu schreibenden Daten überein. Ist die Länge des zu schreibenden Daten größer als die Länge angegeben wird, der `RecordLength` -Klausel der `FileOpen` -Funktion eine Ausnahme ausgelöst.  
  
-   Wenn die Variable geschrieben wird ein Objekt, das einen numerischen Typ enthält, `FilePutObject` schreibt zwei Bytes zur Identifizierung der `VarType` des Objekts und schreibt dann die Variable. Enthält z. B. wenn ein Objekt zu schreiben, die eine ganze Zahl, `FilePutObject` schreibt sechs Bytes: 2 Bytes, die das Objekt als identifizieren `VarType(3)` (`Integer`) und vier Bytes, die Daten enthalten. Die Datensatzlänge gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss größer als die tatsächliche Anzahl von Bytes zum Speichern der Variablen benötigt mindestens zwei Bytes sein.  
  
-   Wenn die Variable geschrieben wird ein Objekt, das eine Zeichenfolge, enthält `FilePutObject` schreibt eine 2-Byte-Deskriptor, identifiziert die `VarType(8)` des Objekts ein 2-Byte-Deskriptor, der angibt, der Länge der Zeichenfolge ein, und klicken Sie dann die Zeichenfolgendaten. Die Datensatzlänge gemäß der `RecordLength` Parameter in der `FileOpen` Funktion muss über mindestens vier Bytes größer als die tatsächliche Länge der Zeichenfolge sein. Wenn Sie eine Zeichenfolge ohne den Deskriptor ablegen möchten, sollten Sie übergeben `True` auf die `StringIsFixedLength` -Parameter, und die Zeichenfolge, die Sie lesen in muss die richtige Länge.  
  
-   Wenn die Zielvariable ein Array, und klicken Sie dann auf die angegebene Datensatzlänge ist die `RecordLength` -Klausel in der `FileOpen` Funktion muss größer als oder gleich der Summe aller Bytes erforderlich, um die Daten des Arrays und den Deskriptor des Arrays zu schreiben. Der Deskriptor gibt den Rang des Arrays, die Größe und die unteren Grenzen für jeden Rang. Seine Länge entspricht 2 plus 8 multipliziert mit der Anzahl der Dimensionen: (2 + 8 * NumberOfDimensions).  
  
## <a name="binary-mode"></a>Binärmodus  
 Für Dateien in geöffnet `Binary` Modus alle die `Random` Modus Regeln anwenden, mit Ausnahme von:  
  
-   Die `RecordLength` -Klausel in der `FileOpen` Funktion hat keine Auswirkungen. `FilePutObject` Schreibt alle Variablen zusammenhängend, d. h. ohne Leerraum zwischen Datensätzen Datenträger.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `FilePutObject` Funktion, um eine Zeichenfolge in eine Datei zu schreiben.  
  
 [!code-vb[VbVbalrCatRef#54](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#54)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />
      </Docs>
    </Member>
    <Member MemberName="FileWidth">
      <MemberSignature Language="C#" Value="public static void FileWidth (int FileNumber, int RecordWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileWidth(int32 FileNumber, int32 RecordWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileWidth (FileNumber As Integer, RecordWidth As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileWidth(int FileNumber, int RecordWidth);" />
      <MemberSignature Language="F#" Value="static member FileWidth : int * int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileWidth (FileNumber, RecordWidth)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="RecordWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="RecordWidth">Erforderlich. Ein numerischer Ausdruck im Bereich 0-255 einschließlich, der angibt, wie viele Zeichen auf einer Zeile stehen, bevor eine neue Zeile beginnt. Wenn <c>RecordWidth</c> gleich 0 ist, ist die Länge einer Zeile unbegrenzt. Der Standardwert für <c>RecordWidth</c> ist 0 (null).</param>
        <summary>Weist einer Datei, die mit der <see langword="FileOpen" />-Funktion geöffnet wurde, eine Ausgabezeilenbreite zu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Dieses Beispiel verwendet die `FileWidth` Funktion, um die Breite einer Zeile für eine Datei festgelegt.  
  
 [!code-vb[VbVbalrCatRef#10](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FreeFile">
      <MemberSignature Language="C#" Value="public static int FreeFile ();" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 FreeFile() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FreeFile" />
      <MemberSignature Language="VB.NET" Value="Public Function FreeFile () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int FreeFile();" />
      <MemberSignature Language="F#" Value="static member FreeFile : unit -&gt; int" Usage="Microsoft.VisualBasic.FileSystem.FreeFile " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen <see langword="Integer" />-Wert zurück, der die nächste zur Verwendung durch die <see langword="FileOpen" />-Funktion verfügbare Dateinummer darstellt.</summary>
        <returns>Gibt einen <see langword="Integer" />-Wert zurück, der die nächste zur Verwendung durch die <see langword="FileOpen" />-Funktion verfügbare Dateinummer darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwendung `FreeFile` zahlreiche Datei angeben, die nicht bereits verwendet wird.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `FreeFile` Funktion, um die nächste verfügbare Dateinummer zurückzugeben. Für die Ausgabe innerhalb der Schleife werden fünf Dateien geöffnet, und einige Beispieldaten in jeder geschrieben.  
  
 [!code-vb[VbVbalrCatRef#55](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#55)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Mehr als 255 Dateien verwendet.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="GetAttr">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.FileAttribute GetAttr (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.FileAttribute GetAttr(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAttr (PathName As String) As FileAttribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::FileAttribute GetAttr(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member GetAttr : string -&gt; Microsoft.VisualBasic.FileAttribute" Usage="Microsoft.VisualBasic.FileSystem.GetAttr PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.FileAttribute</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">Erforderlich. Ein <see langword="String" />-Ausdruck, der einen Datei-, Verzeichnis- oder Ordnernamen angibt. <c>PathName</c> kann auch das Verzeichnis oder den Ordner sowie das Laufwerk beinhalten.</param>
        <summary>Gibt einen <see langword="FileAttribute" />-Wert zurück, der die Attribute einer Datei, eines Verzeichnisses oder eines Ordners darstellt. Die <see langword="My" />-Funktion bietet eine höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="FileAttribute" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <returns>Der von <see langword="GetAttr" /> zurückgegebene Wert ist die Summe aus folgenden Enumerationswerten: 
 <list type="table"><item><term> Wert  </term><description> Kontante </description><description> Beschreibung  </description></item><item><term><see langword="Normal" /></term><description><see langword="vbNormal" /></description><description> Normal.  </description></item><item><term><see langword="ReadOnly" /></term><description><see langword="vbReadOnly" /></description><description> Schreibgeschützt.  </description></item><item><term><see langword="Hidden" /></term><description><see langword="vbHidden" /></description><description> Ausgeblendet.  </description></item><item><term><see langword="System" /></term><description><see langword="vbSystem" /></description><description> Systemdatei.  </description></item><item><term><see langword="Directory" /></term><description><see langword="vbDirectory" /></description><description> Verzeichnis oder Ordner.  </description></item><item><term><see langword="Archive" /></term><description><see langword="vbArchive" /></description><description> Die Datei wurde nach der letzten Sicherung geändert.  </description></item><item><term><see langword="Alias" /></term><description><see langword="vbAlias" /></description><description> Die Datei hat einen anderen Namen.  </description></item></list><block subset="none" type="note"><para> Diese Enumerationen werden von der Programmiersprache Visual Basic angegeben. Die Namen können überall im Code anstelle von tatsächlichen Werten verwendet werden.  </para></block></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden, um zu bestimmen, welche Attribute festgelegt sind, die `And` Operator, um einen bitweisen Vergleich, der den Rückgabewert von führen die `GetAttr` -Funktion und der Wert des Dateiattributs werden sollen. Wenn das Ergebnis nicht 0 (null) ist, wird dieses Attribut für die angegebene Datei festgelegt. Beispielsweise ist der Rückgabewert der folgenden `And` Ausdruck ist NULL, wenn die `Archive` Attribut nicht festgelegt ist:  
  
```vb  
Result = GetAttr(FName) And vbArchive  
```  
  
 Ein Wert ungleich NULL wird zurückgegeben, wenn die `Archive` -Attribut festgelegt ist.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `GetAttr` -Funktion können Sie die Attribute einer Datei und Verzeichnis oder Ordner zu ermitteln.  
  
 [!code-vb[VbVbalrCatRef#25](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <paramref name="Pathname" /> ist ungültig oder enthält Platzhalterzeichen.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Zieldatei ist nicht vorhanden.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Input">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Liest Daten aus einer geöffneten sequenziellen Datei und weist diese Variablen zu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref bool Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, bool&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, bool % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="Value">Erforderlich. Eine Variable, der die aus der Datei gelesenen Werte zugewiesen werden, kann kein Array und keine Objektvariable sein.</param>
        <summary>Liest Daten aus einer geöffneten sequenziellen Datei und weist diese Variablen zu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Input` -Funktion wird für Abwärtskompatibilität angeboten und die Leistung beeinträchtigen. Für neue Anwendungen die `My.Computer.FileSystem` Objekt bietet eine bessere Leistung. Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Mit gelesene Daten `Input` in der Regel in eine Datei geschrieben wird, mithilfe von `Write`. Verwenden Sie diese Funktion nur für Dateien, die im geöffneten `Input` oder `Binary` Modus.  
  
> [!IMPORTANT]
>  Beim Lesen aus Dateien, nehmen Sie keine Entscheidungen für den Inhalt der Datei anhand der Dateinamenerweiterung. Z. B. möglicherweise eine Datei mit dem Namen "Form1.vb" in einer Visual Basic 2005-Quelldatei nicht.  
  
 Beim Lesen standard Zeichenfolgen- oder numerische Daten Variablen ohne Änderung zugewiesen ist. Die folgende Tabelle zeigt, wie die Eingabedaten behandelt werden.  
  
|Daten|Wert, der Variablen zugewiesen|  
|-|-|  
|Als Trennzeichen Komma oder die leere Zeile|Empty|  
|#NULL #|`DBNull`|  
|#TRUE # oder #FALSE|`True` oder `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Das Datum und/oder eine Uhrzeit, die durch den Ausdruck dargestellt wird.|  
|#ERROR `errornumber`#|`errornumber` (die Variable ist ein Objekt, das als "Fehler" gekennzeichnet)|  
  
 Wenn Sie das Ende der Datei, erreichen während Sie eines Datenelements, wird die Eingabe wird beendet, und ein Fehler auftritt.  
  
> [!NOTE]
>  Die `Input` Funktion ist nicht lokalisiert. Z. B. Wenn Sie 3,14159, geben Sie in der deutschen Version wird nur 3 zurückgegeben, da das Komma als Trennzeichen Variablen statt als Dezimaltrennzeichen behandelt wird.  
  
> [!IMPORTANT]
>  Lesen aus einer Datei mithilfe der `Input` -Funktion erfordert `Read` aus Zugriff auf die `FileIOPermissionAccess` Enumeration. Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `Input` Funktion zum Lesen von Daten aus einer Datei in zwei Variablen. In diesem Beispiel wird vorausgesetzt, dass `TestFile` ist eine Datei, die einige Zeilen der Daten geschrieben werden, mithilfe der `Write` Funktion, jede Zeile mit einer Zeichenfolge in Anführungszeichen und eine Zahl, die durch ein Komma getrennt, z. B.: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref byte Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, unsigned int8&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Byte % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="Value">Erforderlich. Eine Variable, der die aus der Datei gelesenen Werte zugewiesen werden, kann kein Array und keine Objektvariable sein.</param>
        <summary>Liest Daten aus einer geöffneten sequenziellen Datei und weist diese Variablen zu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Input` -Funktion wird für Abwärtskompatibilität angeboten und die Leistung beeinträchtigen. Für neue Anwendungen die `My.Computer.FileSystem` Objekt bietet eine bessere Leistung. Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Mit gelesene Daten `Input` in der Regel in eine Datei geschrieben wird, mithilfe von `Write`. Verwenden Sie diese Funktion nur für Dateien, die im geöffneten `Input` oder `Binary` Modus.  
  
> [!IMPORTANT]
>  Beim Lesen aus Dateien, nehmen Sie keine Entscheidungen für den Inhalt der Datei anhand der Dateinamenerweiterung. Z. B. möglicherweise eine Datei mit dem Namen "Form1.vb" in einer Visual Basic 2005-Quelldatei nicht.  
  
 Beim Lesen standard Zeichenfolgen- oder numerische Daten Variablen ohne Änderung zugewiesen ist. Die folgende Tabelle zeigt, wie die Eingabedaten behandelt werden.  
  
|Daten|Wert, der Variablen zugewiesen|  
|-|-|  
|Als Trennzeichen Komma oder die leere Zeile|Empty|  
|#NULL #|`DBNull`|  
|#TRUE # oder #FALSE|`True` oder `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Das Datum und/oder eine Uhrzeit, die durch den Ausdruck dargestellt wird.|  
|#ERROR `errornumber`#|`errornumber` (die Variable ist ein Objekt, das als "Fehler" gekennzeichnet)|  
  
 Wenn Sie das Ende der Datei, erreichen während Sie eines Datenelements, wird die Eingabe wird beendet, und ein Fehler auftritt.  
  
> [!NOTE]
>  Die `Input` Funktion ist nicht lokalisiert. Z. B. Wenn Sie 3,14159, geben Sie in der deutschen Version wird nur 3 zurückgegeben, da das Komma als Trennzeichen Variablen statt als Dezimaltrennzeichen behandelt wird.  
  
> [!IMPORTANT]
>  Lesen aus einer Datei mithilfe der `Input` -Funktion erfordert `Read` aus Zugriff auf die `FileIOPermissionAccess` Enumeration. Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `Input` Funktion zum Lesen von Daten aus einer Datei in zwei Variablen. In diesem Beispiel wird vorausgesetzt, dass `TestFile` ist eine Datei, die einige Zeilen der Daten geschrieben werden, mithilfe der `Write` Funktion, jede Zeile mit einer Zeichenfolge in Anführungszeichen und eine Zahl, die durch ein Komma getrennt, z. B.: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref char Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, char&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, char % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="Value">Erforderlich. Eine Variable, der die aus der Datei gelesenen Werte zugewiesen werden, kann kein Array und keine Objektvariable sein.</param>
        <summary>Liest Daten aus einer geöffneten sequenziellen Datei und weist diese Variablen zu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Input` -Funktion wird für Abwärtskompatibilität angeboten und die Leistung beeinträchtigen. Für neue Anwendungen die `My.Computer.FileSystem` Objekt bietet eine bessere Leistung. Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Mit gelesene Daten `Input` in der Regel in eine Datei geschrieben wird, mithilfe von `Write`. Verwenden Sie diese Funktion nur für Dateien, die im geöffneten `Input` oder `Binary` Modus.  
  
> [!IMPORTANT]
>  Beim Lesen aus Dateien, nehmen Sie keine Entscheidungen für den Inhalt der Datei anhand der Dateinamenerweiterung. Z. B. möglicherweise eine Datei mit dem Namen "Form1.vb" in einer Visual Basic 2005-Quelldatei nicht.  
  
 Beim Lesen standard Zeichenfolgen- oder numerische Daten Variablen ohne Änderung zugewiesen ist. Die folgende Tabelle zeigt, wie die Eingabedaten behandelt werden.  
  
|Daten|Wert, der Variablen zugewiesen|  
|-|-|  
|Als Trennzeichen Komma oder die leere Zeile|Empty|  
|#NULL #|`DBNull`|  
|#TRUE # oder #FALSE|`True` oder `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Das Datum und/oder eine Uhrzeit, die durch den Ausdruck dargestellt wird.|  
|#ERROR `errornumber`#|`errornumber` (die Variable ist ein Objekt, das als "Fehler" gekennzeichnet)|  
  
 Wenn Sie das Ende der Datei, erreichen während Sie eines Datenelements, wird die Eingabe wird beendet, und ein Fehler auftritt.  
  
> [!NOTE]
>  Die `Input` Funktion ist nicht lokalisiert. Z. B. Wenn Sie 3,14159, geben Sie in der deutschen Version wird nur 3 zurückgegeben, da das Komma als Trennzeichen Variablen statt als Dezimaltrennzeichen behandelt wird.  
  
> [!IMPORTANT]
>  Lesen aus einer Datei mithilfe der `Input` -Funktion erfordert `Read` aus Zugriff auf die `FileIOPermissionAccess` Enumeration. Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `Input` Funktion zum Lesen von Daten aus einer Datei in zwei Variablen. In diesem Beispiel wird vorausgesetzt, dass `TestFile` ist eine Datei, die mehrere Zeilen mit Daten geschrieben werden, mithilfe der `Write` Funktion, jede Zeile mit einer Zeichenfolge in Anführungszeichen und eine Zahl, die durch ein Komma getrennt, z. B.: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref DateTime Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, valuetype System.DateTime&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, DateTime % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="Value">Erforderlich. Eine Variable, der die aus der Datei gelesenen Werte zugewiesen werden, kann kein Array und keine Objektvariable sein.</param>
        <summary>Liest Daten aus einer geöffneten sequenziellen Datei und weist diese Variablen zu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Input` -Funktion wird für Abwärtskompatibilität angeboten und die Leistung beeinträchtigen. Für neue Anwendungen die `My.Computer.FileSystem` Objekt bietet eine bessere Leistung. Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Mit gelesene Daten `Input` in der Regel in eine Datei geschrieben wird, mithilfe von `Write`. Verwenden Sie diese Funktion nur für Dateien, die im geöffneten `Input` oder `Binary` Modus.  
  
> [!IMPORTANT]
>  Beim Lesen aus Dateien, nehmen Sie keine Entscheidungen für den Inhalt der Datei anhand der Dateinamenerweiterung. Z. B. möglicherweise eine Datei mit dem Namen "Form1.vb" in einer Visual Basic 2005-Quelldatei nicht.  
  
 Beim Lesen standard Zeichenfolgen- oder numerische Daten Variablen ohne Änderung zugewiesen ist. Die folgende Tabelle zeigt, wie die Eingabedaten behandelt werden.  
  
|Daten|Wert, der Variablen zugewiesen|  
|-|-|  
|Als Trennzeichen Komma oder die leere Zeile|Empty|  
|#NULL #|`DBNull`|  
|#TRUE # oder #FALSE|`True` oder `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Das Datum und/oder eine Uhrzeit, die durch den Ausdruck dargestellt wird.|  
|#ERROR `errornumber`#|`errornumber` (die Variable ist ein Objekt, das als "Fehler" gekennzeichnet)|  
  
 Wenn Sie das Ende der Datei, erreichen während Sie eines Datenelements, wird die Eingabe wird beendet, und ein Fehler auftritt.  
  
> [!NOTE]
>  Die `Input` Funktion ist nicht lokalisiert. Z. B. Wenn Sie 3,14159, geben Sie in der deutschen Version wird nur 3 zurückgegeben, da das Komma als Trennzeichen Variablen statt als Dezimaltrennzeichen behandelt wird.  
  
> [!IMPORTANT]
>  Lesen aus einer Datei mithilfe der `Input` -Funktion erfordert `Read` aus Zugriff auf die `FileIOPermissionAccess` Enumeration. Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `Input` Funktion zum Lesen von Daten aus einer Datei in zwei Variablen. In diesem Beispiel wird vorausgesetzt, dass `TestFile` ist eine Datei, die mehrere Zeilen mit Daten geschrieben werden, mithilfe der `Write` Funktion, jede Zeile mit einer Zeichenfolge in Anführungszeichen und eine Zahl, die durch ein Komma getrennt, z. B.: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref decimal Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, valuetype System.Decimal&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Decimal % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="Value">Erforderlich. Eine Variable, der die aus der Datei gelesenen Werte zugewiesen werden, kann kein Array und keine Objektvariable sein.</param>
        <summary>Liest Daten aus einer geöffneten sequenziellen Datei und weist diese Variablen zu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Input` -Funktion wird für Abwärtskompatibilität angeboten und die Leistung beeinträchtigen. Für neue Anwendungen die `My.Computer.FileSystem` Objekt bietet eine bessere Leistung. Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Mit gelesene Daten `Input` in der Regel in eine Datei geschrieben wird, mithilfe von `Write`. Verwenden Sie diese Funktion nur für Dateien, die im geöffneten `Input` oder `Binary` Modus.  
  
> [!IMPORTANT]
>  Beim Lesen aus Dateien, nehmen Sie keine Entscheidungen für den Inhalt der Datei anhand der Dateinamenerweiterung. Z. B. möglicherweise eine Datei mit dem Namen "Form1.vb" in einer Visual Basic 2005-Quelldatei nicht.  
  
 Beim Lesen standard Zeichenfolgen- oder numerische Daten Variablen ohne Änderung zugewiesen ist. Die folgende Tabelle zeigt, wie die Eingabedaten behandelt werden.  
  
|Daten|Wert, der Variablen zugewiesen|  
|-|-|  
|Als Trennzeichen Komma oder die leere Zeile|Empty|  
|#NULL #|`DBNull`|  
|#TRUE # oder #FALSE|`True` oder `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Das Datum und/oder eine Uhrzeit, die durch den Ausdruck dargestellt wird.|  
|#ERROR `errornumber`#|`errornumber` (die Variable ist ein Objekt, das als "Fehler" gekennzeichnet)|  
  
 Wenn Sie das Ende der Datei, erreichen während Sie eines Datenelements, wird die Eingabe wird beendet, und ein Fehler auftritt.  
  
> [!NOTE]
>  Die `Input` Funktion ist nicht lokalisiert. Z. B. Wenn Sie 3,14159, geben Sie in der deutschen Version wird nur 3 zurückgegeben, da das Komma als Trennzeichen Variablen statt als Dezimaltrennzeichen behandelt wird.  
  
> [!IMPORTANT]
>  Lesen aus einer Datei mithilfe der `Input` -Funktion erfordert `Read` aus Zugriff auf die `FileIOPermissionAccess` Enumeration. Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `Input` Funktion zum Lesen von Daten aus einer Datei in zwei Variablen. In diesem Beispiel wird vorausgesetzt, dass `TestFile` ist eine Datei, die mehrere Zeilen mit Daten geschrieben werden, mithilfe der `Write` Funktion, jede Zeile mit einer Zeichenfolge in Anführungszeichen und eine Zahl, die durch ein Komma getrennt, z. B.: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref double Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, float64&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, double % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="Value">Erforderlich. Eine Variable, der die aus der Datei gelesenen Werte zugewiesen werden, kann kein Array und keine Objektvariable sein.</param>
        <summary>Liest Daten aus einer geöffneten sequenziellen Datei und weist diese Variablen zu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Input` -Funktion wird für Abwärtskompatibilität angeboten und die Leistung beeinträchtigen. Für neue Anwendungen die `My.Computer.FileSystem` Objekt bietet eine bessere Leistung. Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Mit gelesene Daten `Input` in der Regel in eine Datei geschrieben wird, mithilfe von `Write`. Verwenden Sie diese Funktion nur für Dateien, die im geöffneten `Input` oder `Binary` Modus.  
  
> [!IMPORTANT]
>  Beim Lesen aus Dateien, nehmen Sie keine Entscheidungen für den Inhalt der Datei anhand der Dateinamenerweiterung. Z. B. möglicherweise eine Datei mit dem Namen "Form1.vb" in einer Visual Basic 2005-Quelldatei nicht.  
  
 Beim Lesen standard Zeichenfolgen- oder numerische Daten Variablen ohne Änderung zugewiesen ist. Die folgende Tabelle zeigt, wie die Eingabedaten behandelt werden.  
  
|Daten|Wert, der Variablen zugewiesen|  
|-|-|  
|Als Trennzeichen Komma oder die leere Zeile|Empty|  
|#NULL #|`DBNull`|  
|#TRUE # oder #FALSE|`True` oder `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Das Datum und/oder eine Uhrzeit, die durch den Ausdruck dargestellt wird.|  
|#ERROR `errornumber`#|`errornumber` (die Variable ist ein Objekt, das als "Fehler" gekennzeichnet)|  
  
 Wenn Sie das Ende der Datei, erreichen während Sie eines Datenelements, wird die Eingabe wird beendet, und ein Fehler auftritt.  
  
> [!NOTE]
>  Die `Input` Funktion ist nicht lokalisiert. Z. B. Wenn Sie 3,14159, geben Sie in der deutschen Version wird nur 3 zurückgegeben, da das Komma als Trennzeichen Variablen statt als Dezimaltrennzeichen behandelt wird.  
  
> [!IMPORTANT]
>  Lesen aus einer Datei mithilfe der `Input` -Funktion erfordert `Read` aus Zugriff auf die `FileIOPermissionAccess` Enumeration. Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `Input` Funktion zum Lesen von Daten aus einer Datei in zwei Variablen. In diesem Beispiel wird vorausgesetzt, dass `TestFile` ist eine Datei, die mehrere Zeilen mit Daten geschrieben werden, mithilfe der `Write` Funktion, jede Zeile mit einer Zeichenfolge in Anführungszeichen und eine Zahl, die durch ein Komma getrennt, z. B.: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref short Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int16&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, short % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="Value">Erforderlich. Eine Variable, der die aus der Datei gelesenen Werte zugewiesen werden, kann kein Array und keine Objektvariable sein.</param>
        <summary>Liest Daten aus einer geöffneten sequenziellen Datei und weist diese Variablen zu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Input` -Funktion wird für Abwärtskompatibilität angeboten und die Leistung beeinträchtigen. Für neue Anwendungen die `My.Computer.FileSystem` Objekt bietet eine bessere Leistung. Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Mit gelesene Daten `Input` in der Regel in eine Datei geschrieben wird, mithilfe von `Write`. Verwenden Sie diese Funktion nur für Dateien, die im geöffneten `Input` oder `Binary` Modus.  
  
> [!IMPORTANT]
>  Beim Lesen aus Dateien, nehmen Sie keine Entscheidungen für den Inhalt der Datei anhand der Dateinamenerweiterung. Z. B. möglicherweise eine Datei mit dem Namen "Form1.vb" in einer Visual Basic 2005-Quelldatei nicht.  
  
 Beim Lesen standard Zeichenfolgen- oder numerische Daten Variablen ohne Änderung zugewiesen ist. Die folgende Tabelle zeigt, wie die Eingabedaten behandelt werden.  
  
|Daten|Wert, der Variablen zugewiesen|  
|-|-|  
|Als Trennzeichen Komma oder die leere Zeile|Empty|  
|#NULL #|`DBNull`|  
|#TRUE # oder #FALSE|`True` oder `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Das Datum und/oder eine Uhrzeit, die durch den Ausdruck dargestellt wird.|  
|#ERROR `errornumber`#|`errornumber` (die Variable ist ein Objekt, das als "Fehler" gekennzeichnet)|  
  
 Wenn Sie das Ende der Datei, erreichen während Sie eines Datenelements, wird die Eingabe wird beendet, und ein Fehler auftritt.  
  
> [!NOTE]
>  Die `Input` Funktion ist nicht lokalisiert. Z. B. Wenn Sie 3,14159, geben Sie in der deutschen Version wird nur 3 zurückgegeben, da das Komma als Trennzeichen Variablen statt als Dezimaltrennzeichen behandelt wird.  
  
> [!IMPORTANT]
>  Lesen aus einer Datei mithilfe der `Input` -Funktion erfordert `Read` aus Zugriff auf die `FileIOPermissionAccess` Enumeration. Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `Input` Funktion zum Lesen von Daten aus einer Datei in zwei Variablen. In diesem Beispiel wird vorausgesetzt, dass `TestFile` ist eine Datei, die mehrere Zeilen mit Daten geschrieben werden, mithilfe der `Write` Funktion, jede Zeile mit einer Zeichenfolge in Anführungszeichen und eine Zahl, die durch ein Komma getrennt, z. B.: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref int Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int32&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, int % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="Value">Erforderlich. Eine Variable, der die aus der Datei gelesenen Werte zugewiesen werden, kann kein Array und keine Objektvariable sein.</param>
        <summary>Liest Daten aus einer geöffneten sequenziellen Datei und weist diese Variablen zu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Input` -Funktion wird für Abwärtskompatibilität angeboten und die Leistung beeinträchtigen. Für neue Anwendungen die `My.Computer.FileSystem` Objekt bietet eine bessere Leistung. Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Mit gelesene Daten `Input` in der Regel in eine Datei geschrieben wird, mithilfe von `Write`. Verwenden Sie diese Funktion nur für Dateien, die im geöffneten `Input` oder `Binary` Modus.  
  
> [!IMPORTANT]
>  Beim Lesen aus Dateien, nehmen Sie keine Entscheidungen für den Inhalt der Datei anhand der Dateinamenerweiterung. Z. B. möglicherweise eine Datei mit dem Namen "Form1.vb" in einer Visual Basic 2005-Quelldatei nicht.  
  
 Beim Lesen standard Zeichenfolgen- oder numerische Daten Variablen ohne Änderung zugewiesen ist. Die folgende Tabelle zeigt, wie die Eingabedaten behandelt werden.  
  
|Daten|Wert, der Variablen zugewiesen|  
|-|-|  
|Als Trennzeichen Komma oder die leere Zeile|Empty|  
|#NULL #|`DBNull`|  
|#TRUE # oder #FALSE|`True` oder `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Das Datum und/oder eine Uhrzeit, die durch den Ausdruck dargestellt wird.|  
|#ERROR `errornumber`#|`errornumber` (die Variable ist ein Objekt, das als "Fehler" gekennzeichnet)|  
  
 Wenn Sie das Ende der Datei, erreichen während Sie eines Datenelements, wird die Eingabe wird beendet, und ein Fehler auftritt.  
  
> [!NOTE]
>  Die `Input` Funktion ist nicht lokalisiert. Z. B. Wenn Sie 3,14159, geben Sie in der deutschen Version wird nur 3 zurückgegeben, da das Komma als Trennzeichen Variablen statt als Dezimaltrennzeichen behandelt wird.  
  
> [!IMPORTANT]
>  Lesen aus einer Datei mithilfe der `Input` -Funktion erfordert `Read` aus Zugriff auf die `FileIOPermissionAccess` Enumeration. Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `Input` Funktion zum Lesen von Daten aus einer Datei in zwei Variablen. In diesem Beispiel wird vorausgesetzt, dass `TestFile` ist eine Datei, die mehrere Zeilen mit Daten geschrieben werden, mithilfe der `Write` Funktion, jede Zeile mit einer Zeichenfolge in Anführungszeichen und eine Zahl, die durch ein Komma getrennt, z. B.: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref long Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int64&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, long % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="Value">Erforderlich. Eine Variable, der die aus der Datei gelesenen Werte zugewiesen werden, kann kein Array und keine Objektvariable sein.</param>
        <summary>Liest Daten aus einer geöffneten sequenziellen Datei und weist diese Variablen zu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Input` -Funktion wird für Abwärtskompatibilität angeboten und die Leistung beeinträchtigen. Für neue Anwendungen die `My.Computer.FileSystem` Objekt bietet eine bessere Leistung. Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Mit gelesene Daten `Input` in der Regel in eine Datei geschrieben wird, mithilfe von `Write`. Verwenden Sie diese Funktion nur für Dateien, die im geöffneten `Input` oder `Binary` Modus.  
  
> [!IMPORTANT]
>  Beim Lesen aus Dateien, nehmen Sie keine Entscheidungen für den Inhalt der Datei anhand der Dateinamenerweiterung. Z. B. möglicherweise eine Datei mit dem Namen "Form1.vb" in einer Visual Basic 2005-Quelldatei nicht.  
  
 Beim Lesen standard Zeichenfolgen- oder numerische Daten Variablen ohne Änderung zugewiesen ist. Die folgende Tabelle zeigt, wie die Eingabedaten behandelt werden.  
  
|Daten|Wert, der Variablen zugewiesen|  
|-|-|  
|Als Trennzeichen Komma oder die leere Zeile|Empty|  
|#NULL #|`DBNull`|  
|#TRUE # oder #FALSE|`True` oder `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Das Datum und/oder eine Uhrzeit, die durch den Ausdruck dargestellt wird.|  
|#ERROR `errornumber`#|`errornumber` (die Variable ist ein Objekt, das als "Fehler" gekennzeichnet)|  
  
 Wenn Sie das Ende der Datei, erreichen während Sie eines Datenelements, wird die Eingabe wird beendet, und ein Fehler auftritt.  
  
> [!NOTE]
>  Die `Input` Funktion ist nicht lokalisiert. Z. B. Wenn Sie 3,14159, geben Sie in der deutschen Version wird nur 3 zurückgegeben, da das Komma als Trennzeichen Variablen statt als Dezimaltrennzeichen behandelt wird.  
  
> [!IMPORTANT]
>  Lesen aus einer Datei mithilfe der `Input` -Funktion erfordert `Read` aus Zugriff auf die `FileIOPermissionAccess` Enumeration. Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `Input` Funktion zum Lesen von Daten aus einer Datei in zwei Variablen. In diesem Beispiel wird vorausgesetzt, dass `TestFile` ist eine Datei, die mehrere Zeilen mit Daten geschrieben werden, mithilfe der `Write` Funktion, jede Zeile mit einer Zeichenfolge in Anführungszeichen und eine Zahl, die durch ein Komma getrennt, z. B.: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref object Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, object&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Object ^ % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="Value">Erforderlich. Eine Variable, der die aus der Datei gelesenen Werte zugewiesen werden, kann kein Array und keine Objektvariable sein.</param>
        <summary>Liest Daten aus einer geöffneten sequenziellen Datei und weist diese Variablen zu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Input` -Funktion wird für Abwärtskompatibilität angeboten und die Leistung beeinträchtigen. Für neue Anwendungen die `My.Computer.FileSystem` Objekt bietet eine bessere Leistung. Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Mit gelesene Daten `Input` in der Regel in eine Datei geschrieben wird, mithilfe von `Write`. Verwenden Sie diese Funktion nur für Dateien, die im geöffneten `Input` oder `Binary` Modus.  
  
> [!IMPORTANT]
>  Beim Lesen aus Dateien, nehmen Sie keine Entscheidungen für den Inhalt der Datei anhand der Dateinamenerweiterung. Z. B. möglicherweise eine Datei mit dem Namen "Form1.vb" in einer Visual Basic 2005-Quelldatei nicht.  
  
 Beim Lesen standard Zeichenfolgen- oder numerische Daten Variablen ohne Änderung zugewiesen ist. Die folgende Tabelle zeigt, wie die Eingabedaten behandelt werden.  
  
|Daten|Wert, der Variablen zugewiesen|  
|-|-|  
|Als Trennzeichen Komma oder die leere Zeile|Empty|  
|#NULL #|`DBNull`|  
|#TRUE # oder #FALSE|`True` oder `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Das Datum und/oder eine Uhrzeit, die durch den Ausdruck dargestellt wird.|  
|#ERROR `errornumber`#|`errornumber` (die Variable ist ein Objekt, das als "Fehler" gekennzeichnet)|  
  
 Wenn Sie das Ende der Datei, erreichen während Sie eines Datenelements, wird die Eingabe wird beendet, und ein Fehler auftritt.  
  
> [!NOTE]
>  Die `Input` Funktion ist nicht lokalisiert. Z. B. Wenn Sie 3,14159, geben Sie in der deutschen Version wird nur 3 zurückgegeben, da das Komma als Trennzeichen Variablen statt als Dezimaltrennzeichen behandelt wird.  
  
> [!IMPORTANT]
>  Lesen aus einer Datei mithilfe der `Input` -Funktion erfordert `Read` aus Zugriff auf die `FileIOPermissionAccess` Enumeration. Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `Input` Funktion zum Lesen von Daten aus einer Datei in zwei Variablen. In diesem Beispiel wird vorausgesetzt, dass `TestFile` ist eine Datei, die mehrere Zeilen mit Daten geschrieben werden, mithilfe der `Write` Funktion, jede Zeile mit einer Zeichenfolge in Anführungszeichen und eine Zahl, die durch ein Komma getrennt, z. B.: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref float Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, float32&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, float % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="Value">Erforderlich. Eine Variable, der die aus der Datei gelesenen Werte zugewiesen werden, kann kein Array und keine Objektvariable sein.</param>
        <summary>Liest Daten aus einer geöffneten sequenziellen Datei und weist diese Variablen zu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Input` -Funktion wird für Abwärtskompatibilität angeboten und die Leistung beeinträchtigen. Für neue Anwendungen die `My.Computer.FileSystem` Objekt bietet eine bessere Leistung. Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Mit gelesene Daten `Input` in der Regel in eine Datei geschrieben wird, mithilfe von `Write`. Verwenden Sie diese Funktion nur für Dateien, die im geöffneten `Input` oder `Binary` Modus.  
  
> [!IMPORTANT]
>  Beim Lesen aus Dateien, nehmen Sie keine Entscheidungen für den Inhalt der Datei anhand der Dateinamenerweiterung. Z. B. möglicherweise eine Datei mit dem Namen "Form1.vb" in einer Visual Basic 2005-Quelldatei nicht.  
  
 Beim Lesen standard Zeichenfolgen- oder numerische Daten Variablen ohne Änderung zugewiesen ist. Die folgende Tabelle zeigt, wie die Eingabedaten behandelt werden.  
  
|Daten|Wert, der Variablen zugewiesen|  
|-|-|  
|Als Trennzeichen Komma oder die leere Zeile|Empty|  
|#NULL #|`DBNull`|  
|#TRUE # oder #FALSE|`True` oder `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Das Datum und/oder eine Uhrzeit, die durch den Ausdruck dargestellt wird.|  
|#ERROR `errornumber`#|`errornumber` (die Variable ist ein Objekt, das als "Fehler" gekennzeichnet)|  
  
 Wenn Sie das Ende der Datei, erreichen während Sie eines Datenelements, wird die Eingabe wird beendet, und ein Fehler auftritt.  
  
> [!NOTE]
>  Die `Input` Funktion ist nicht lokalisiert. Z. B. Wenn Sie 3,14159, geben Sie in der deutschen Version wird nur 3 zurückgegeben, da das Komma als Trennzeichen Variablen statt als Dezimaltrennzeichen behandelt wird.  
  
> [!IMPORTANT]
>  Lesen aus einer Datei mithilfe der `Input` -Funktion erfordert `Read` aus Zugriff auf die `FileIOPermissionAccess` Enumeration. Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `Input` Funktion zum Lesen von Daten aus einer Datei in zwei Variablen. In diesem Beispiel wird vorausgesetzt, dass `TestFile` ist eine Datei, die mehrere Zeilen mit Daten geschrieben werden, mithilfe der `Write` Funktion, jede Zeile mit einer Zeichenfolge in Anführungszeichen und eine Zahl, die durch ein Komma getrennt, z. B.: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref string Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, string&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::String ^ % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="Value">Erforderlich. Eine Variable, der die aus der Datei gelesenen Werte zugewiesen werden, kann kein Array und keine Objektvariable sein.</param>
        <summary>Liest Daten aus einer geöffneten sequenziellen Datei und weist diese Variablen zu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Input` -Funktion wird für Abwärtskompatibilität angeboten und die Leistung beeinträchtigen. Für neue Anwendungen die `My.Computer.FileSystem` Objekt bietet eine bessere Leistung. Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Mit gelesene Daten `Input` in der Regel in eine Datei geschrieben wird, mithilfe von `Write`. Verwenden Sie diese Funktion nur für Dateien, die im geöffneten `Input` oder `Binary` Modus.  
  
> [!IMPORTANT]
>  Beim Lesen aus Dateien, nehmen Sie keine Entscheidungen für den Inhalt der Datei anhand der Dateinamenerweiterung. Z. B. möglicherweise eine Datei mit dem Namen "Form1.vb" in einer Visual Basic 2005-Quelldatei nicht.  
  
 Beim Lesen standard Zeichenfolgen- oder numerische Daten Variablen ohne Änderung zugewiesen ist. Die folgende Tabelle zeigt, wie die Eingabedaten behandelt werden.  
  
|Daten|Wert, der Variablen zugewiesen|  
|-|-|  
|Als Trennzeichen Komma oder die leere Zeile|Empty|  
|#NULL #|`DBNull`|  
|#TRUE # oder #FALSE|`True` oder `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Das Datum und/oder eine Uhrzeit, die durch den Ausdruck dargestellt wird.|  
|#ERROR `errornumber`#|`errornumber` (die Variable ist ein Objekt, das als "Fehler" gekennzeichnet)|  
  
 Wenn Sie das Ende der Datei, erreichen während Sie eines Datenelements, wird die Eingabe wird beendet, und ein Fehler auftritt.  
  
> [!NOTE]
>  Die `Input` Funktion ist nicht lokalisiert. Z. B. Wenn Sie 3,14159, geben Sie in der deutschen Version wird nur 3 zurückgegeben, da das Komma als Trennzeichen Variablen statt als Dezimaltrennzeichen behandelt wird.  
  
> [!IMPORTANT]
>  Lesen aus einer Datei mithilfe der `Input` -Funktion erfordert `Read` aus Zugriff auf die `FileIOPermissionAccess` Enumeration. Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `Input` Funktion zum Lesen von Daten aus einer Datei in zwei Variablen. In diesem Beispiel wird vorausgesetzt, dass `TestFile` ist eine Datei, die mehrere Zeilen mit Daten geschrieben werden, mithilfe der `Write` Funktion, jede Zeile mit einer Zeichenfolge in Anführungszeichen und eine Zahl, die durch ein Komma getrennt, z. B.: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="InputString">
      <MemberSignature Language="C#" Value="public static string InputString (int FileNumber, int CharCount);" />
      <MemberSignature Language="ILAsm" Value=".method public static string InputString(int32 FileNumber, int32 CharCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function InputString (FileNumber As Integer, CharCount As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ InputString(int FileNumber, int CharCount);" />
      <MemberSignature Language="F#" Value="static member InputString : int * int -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.InputString (FileNumber, CharCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="CharCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="CharCount">Erforderlich. Ein beliebiger gültiger numerischer Ausdruck, der die Anzahl der zu lesenden Zeichen angibt.</param>
        <summary>Gibt einen <see langword="String" />-Wert zurück, der Zeichen aus einer im Modus <see langword="Input" /> oder <see langword="Binary" /> geöffneten Datei enthält. Die <see langword="My" />-Funktion bietet eine höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="InputString" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <returns>Gibt einen <see langword="String" />-Wert zurück, der Zeichen aus einer im Modus <see langword="Input" /> oder <see langword="Binary" /> geöffneten Datei enthält. Die <see langword="My" />-Funktion bietet eine höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="InputString" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `InputString` -Funktion wird für Abwärtskompatibilität angeboten und die Leistung beeinträchtigen. Für neue Anwendungen die `My.Computer.FileSystem` Objekt bietet eine bessere Leistung. Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Mit gelesene Daten der `InputString` Funktion ist in der Regel in eine Datei geschrieben, mit `Print` oder `FilePut`. Verwenden Sie diese Funktion nur für Dateien, die im geöffneten `Input` oder `Binary` Modus.  
  
 Im Gegensatz zu den `Input` -Funktion, die `InputString` Funktionsergebnis ist die gelesenen Zeichen. Dies schließt Kommas, Wagenrücklaufzeichen, Zeilenvorschübe, Anführungszeichen und Leerzeichen.  
  
 Dateien für geöffnet `Binary` für den Zugriff auf einem Versuch, lesen in der Datei mit der `InputString` Funktion bis `EOF` gibt `True` wird ein Fehler generiert. Verwenden Sie die `LOF` und `Loc` anstelle von Funktionen `EOF` beim Lesen von Binärdateien mit `InputString`, oder verwenden Sie `FileGet` bei Verwendung der `EOF` Funktion.  
  
> [!NOTE]
>  Beim Lesen aus Dateien, nehmen Sie keine Sicherheitsfragen die richtigen Entscheidungen über den Inhalt der Datei anhand der Dateinamenerweiterung. Z. B. möglicherweise eine Datei namens "Form1.vb" in einer Visual Basic-Quelldatei nicht.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `InputString` Funktion, um Zeichen aus einer Datei gelesen und zum Drucken der `Output` Fenster. In diesem Beispiel wird vorausgesetzt, dass `MyFile` ist eine Textdatei, die mehrere Zeilen mit Beispieldaten.  
  
 [!code-vb[VbVbalrCatRef#33](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#33)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <paramref name="FileNumber" /> ist nicht vorhanden.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="CharCount" /> &lt; 0 oder &gt; 214.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
      </Docs>
    </Member>
    <Member MemberName="Kill">
      <MemberSignature Language="C#" Value="public static void Kill (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Kill(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Kill (PathName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Kill(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member Kill : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Kill PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">Erforderlich. Ein <see langword="String" />-Ausdruck, der einen oder mehrere Namen von zu löschenden Dateien angibt. <c>PathName</c> kann auch das Verzeichnis oder den Ordner sowie das Laufwerk beinhalten.</param>
        <summary>Löscht Dateien von einem Datenträger. Die <see langword="My" />-Funktion bietet eine höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="Kill" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Kill` unterstützt die Verwendung von mehreren Zeichen (`*`) und ein einzelnes Zeichen (`?`) mit Platzhaltern für mehrere Dateien anzugeben.  
  
 **Sicherheitshinweis** zum Ausführen der `Kill` -Funktion erfordert `Read` und `PathDiscovery` flags der <xref:System.Security.Permissions.FileIOPermission> der ausgeführte Code erteilt werden. Weitere Informationen finden Sie unter <xref:System.Security.SecurityException> [Codezugriffsberechtigungen](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `Kill` Funktion, um eine Datei von einem Datenträger zu löschen.  
  
 [!code-vb[VbVbalrCatRef#60](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#60)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Zieldatei(en) geöffnet.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Zieldatei(en) nicht gefunden.</exception>
        <exception cref="T:System.Security.SecurityException">Berechtigung verweigert.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <Member MemberName="LineInput">
      <MemberSignature Language="C#" Value="public static string LineInput (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static string LineInput(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.LineInput(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LineInput (FileNumber As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ LineInput(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member LineInput : int -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.LineInput FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <summary>Liest eine einzelne Zeile aus einer offenen sequenziellen Datei und weist diese einer <see langword="String" />-Variablen zu.</summary>
        <returns>Liest eine einzelne Zeile aus einer offenen sequenziellen Datei und weist diese einer <see langword="String" />-Variablen zu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `LineInput` -Funktion wird für Abwärtskompatibilität angeboten und die Leistung beeinträchtigen. Für neue Anwendungen die `My.Computer.FileSystem` Objekt bietet eine bessere Leistung. Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Mit gelesene Daten `LineInput` in der Regel in eine Datei geschrieben wird, mithilfe von `Print`.  
  
> [!IMPORTANT]
>  Beim Lesen aus Dateien, nehmen Sie keine Entscheidungen für den Inhalt einer Datei, die anhand der Dateinamenerweiterung. Z. B. möglicherweise eine Datei mit dem Namen "Form1.vb" in einer Visual Basic-Quelldatei nicht.  
  
 Die `LineInput` Funktion liest Zeichen aus einer Datei ein, zu einem Zeitpunkt, bis er feststellt, dass einen Wagenrücklauf (`Chr(13)`) oder Wagenrücklauf/Zeilenvorschub (`Chr(13) + Chr(10)`) Sequenz. Carriage Return/Line feed Sequenzen werden übersprungen und nicht auf die Zeichenfolge angefügt.  
  
> [!IMPORTANT]
>  Lesen aus einer Datei mithilfe der `LineInput` -Funktion erfordert `Read` aus Zugriff auf die <xref:System.Security.Permissions.FileIOPermissionAccess> Enumeration.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `LineInput` -Funktion zum Lesen einer Zeile aus einer sequenziellen Datei und einer Variablen zuweisen. In diesem Beispiel wird vorausgesetzt, dass `TestFile` ist eine Textdatei, die mehrere Zeilen mit Beispieldaten.  
  
 [!code-vb[VbVbalrCatRef#19](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.EndOfStreamException">Dateiende erreicht.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="FileNumber" /> ist nicht vorhanden.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Strings.Chr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.ChrW(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
      </Docs>
    </Member>
    <Member MemberName="Loc">
      <MemberSignature Language="C#" Value="public static long Loc (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 Loc(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Loc (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Loc(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Loc : int -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.Loc FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige <see langword="Integer" />-Dateinummer.</param>
        <summary>Gibt einen <see langword="Long" />-Wert zurück, der die aktuelle Lese-/Schreibposition in einer offenen Datei angibt.</summary>
        <returns>Gibt einen <see langword="Long" />-Wert zurück, der die aktuelle Lese-/Schreibposition in einer offenen Datei angibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Loc` Funktion ist nullbasiert, verwenden, um das erste Byte in einer Datei abrufen gibt 0 zurück.  
  
 Die `Loc` -Funktion wird für Abwärtskompatibilität angeboten und die Leistung beeinträchtigen. Für neue Anwendungen die `My.Computer.FileSystem` Objekt bietet eine bessere Leistung. Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Im folgenden wird den Rückgabewert für jede Dateizugriffsmodus beschrieben:  
  
|Modus|Rückgabewert|  
|-|-|  
|`Random`|Anzahl der dem letzten Datensatz gelesen oder geschrieben werden, auf die Datei.|  
|`Sequential`|Aktuelle Byte-Position in der Datei geteilt durch 128. Zurückgegebene Informationen werden jedoch von `Loc` für sequenzielle Dateien ist weder verwendet noch benötigt.|  
|`Binary`|Die Position des letzten Bytes gelesen bzw. geschrieben werden.|  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `Loc` Funktion, um die aktuelle Lese-/Schreibposition in einer offenen Datei zurückzugeben. In diesem Beispiel wird vorausgesetzt, dass `MyFile` ist eine Textdatei, die mehrere Zeilen mit Beispieldaten.  
  
 [!code-vb[VbVbalrCatRef#17](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Lock">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Steuert den Zugriff durch andere Prozesse auf die gesamte mithilfe der <see langword="Open" />-Funktion geöffnete Datei oder einen Teil davon. Das <see langword="My" />-Feature ermöglicht bei Datei-E/A-Vorgängen höhere Produktivität und Leistung als <see langword="Lock" /> und <see langword="Unlock" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Lock : int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Lock FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <summary>Steuert den Zugriff durch andere Prozesse auf die gesamte mithilfe der <see langword="Open" />-Funktion geöffnete Datei oder einen Teil davon. Das <see langword="My" />-Feature ermöglicht bei Datei-E/A-Vorgängen höhere Produktivität und Leistung als <see langword="Lock" /> und <see langword="Unlock" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Lock` und `Unlock` Funktionen werden, in denen mehrere Prozesse den Zugriff auf die gleiche Datei möglicherweise in Umgebungen verwendet.  
  
 `Lock` und `Unlock` Funktionen werden immer paarweise verwendet. Die Argumente für `Lock` und `Unlock` müssen identisch sein.  
  
 Wenn `Record`, oder `FromRecord` und `ToRecord` sind nicht angegeben wird, wird die Sperre für die gesamte Datei sein. Wenn `Record` allein angegeben ist der einzelne Datensatz wird gesperrt/freigegeben werden.  
  
 Wenn die Datei für sequenzielle ein- oder Ausgabe geöffnet wurde `Lock` und `Unlock` Auswirkungen auf die gesamte Datei, unabhängig von dem vom angegebenen Bereich `FromRecord` und`ToRecord`.  
  
   
  
## Examples  
 Dieses Beispiel veranschaulicht die Verwendung der `Lock` und `Unlock` Funktionen. In diesem Beispiel wird vorausgesetzt, dass `People.txt` ist eine Datei, die Datensätze der Struktur enthält `Person`.  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber, long Record);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber, int64 Record) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer, Record As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber, long Record);" />
      <MemberSignature Language="F#" Value="static member Lock : int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Lock (FileNumber, Record)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Record" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="Record">Dies ist optional. Die Nummer des einzigen zu sperrenden oder zu entsperrenden Datensatzes.</param>
        <summary>Steuert den Zugriff durch andere Prozesse auf die gesamte mithilfe der <see langword="Open" />-Funktion geöffnete Datei oder einen Teil davon. Das <see langword="My" />-Feature ermöglicht bei Datei-E/A-Vorgängen höhere Produktivität und Leistung als <see langword="Lock" /> und <see langword="Unlock" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Lock` und `Unlock` Funktionen werden, in denen mehrere Prozesse den Zugriff auf die gleiche Datei möglicherweise in Umgebungen verwendet.  
  
 `Lock` und `Unlock` Funktionen werden immer paarweise verwendet. Die Argumente für `Lock` und `Unlock` müssen identisch sein.  
  
 Wenn `Record`, oder `FromRecord` und `ToRecord` sind nicht angegeben wird, wird die Sperre für die gesamte Datei sein. Wenn `Record` allein angegeben ist der einzelne Datensatz wird gesperrt/freigegeben werden.  
  
 Wenn die Datei für sequenzielle ein- oder Ausgabe geöffnet wurde `Lock` und `Unlock` Auswirkungen auf die gesamte Datei, unabhängig von dem vom angegebenen Bereich `FromRecord` und`ToRecord`.  
  
   
  
## Examples  
 Dieses Beispiel veranschaulicht die Verwendung der `Lock` und `Unlock` Funktionen. In diesem Beispiel wird vorausgesetzt, dass `People.txt` ist eine Datei, die Datensätze der Struktur enthält `Person`.  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber, int64 FromRecord, int64 ToRecord) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer, FromRecord As Long, ToRecord As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="F#" Value="static member Lock : int * int64 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Lock (FileNumber, FromRecord, ToRecord)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FromRecord" Type="System.Int64" />
        <Parameter Name="ToRecord" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="FromRecord">Dies ist optional. Die Nummer des ersten zu sperrenden oder zu entsperrenden Datensatzes.</param>
        <param name="ToRecord">Dies ist optional. Die Nummer des letzten zu sperrenden oder zu entsperrenden Datensatzes.</param>
        <summary>Steuert den Zugriff durch andere Prozesse auf die gesamte mithilfe der <see langword="Open" />-Funktion geöffnete Datei oder einen Teil davon. Das <see langword="My" />-Feature ermöglicht bei Datei-E/A-Vorgängen höhere Produktivität und Leistung als <see langword="Lock" /> und <see langword="Unlock" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Lock` und `Unlock` Funktionen werden, in denen mehrere Prozesse den Zugriff auf die gleiche Datei möglicherweise in Umgebungen verwendet.  
  
 `Lock` und `Unlock` Funktionen werden immer paarweise verwendet. Die Argumente für `Lock` und `Unlock` müssen identisch sein.  
  
 Wenn `Record`, oder `FromRecord` und `ToRecord` sind nicht angegeben wird, wird die Sperre für die gesamte Datei sein. Wenn `Record` allein angegeben ist der einzelne Datensatz wird gesperrt/freigegeben werden.  
  
 Wenn die Datei für sequenzielle ein- oder Ausgabe geöffnet wurde `Lock` und `Unlock` Auswirkungen auf die gesamte Datei, unabhängig von dem vom angegebenen Bereich `FromRecord` und`ToRecord`.  
  
   
  
## Examples  
 Dieses Beispiel veranschaulicht die Verwendung der `Lock` und `Unlock` Funktionen. In diesem Beispiel wird vorausgesetzt, dass `People.txt` ist eine Datei, die Datensätze der Struktur enthält `Person`.  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="LOF">
      <MemberSignature Language="C#" Value="public static long LOF (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 LOF(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LOF (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long LOF(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member LOF : int -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.LOF FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Ein <see langword="Integer" /> mit einer gültigen Dateinummer.</param>
        <summary>Gibt einen <see langword="Long" /> zurück, der die Größe einer mit der <see langword="FileOpen" />-Funktion geöffneten Datei in Bytes darstellt. Die <see langword="My" />-Funktion bietet eine höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="LOF" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <returns>Gibt einen <see langword="Long" /> zurück, der die Größe einer mit der <see langword="FileOpen" />-Funktion geöffneten Datei in Bytes darstellt. Die <see langword="My" />-Funktion bietet eine höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="LOF" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der `FileLen` Funktion, um die Länge einer Datei zu erhalten, die nicht geöffnet ist.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `LOF` Funktion, um die Größe einer geöffneten Datei zu bestimmen. In diesem Beispiel wird vorausgesetzt, dass `TestFile` ist eine Textdatei, die Beispieldaten enthält.  
  
 [!code-vb[VbVbalrCatRef#23](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="MkDir">
      <MemberSignature Language="C#" Value="public static void MkDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void MkDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MkDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MkDir(System::String ^ Path);" />
      <MemberSignature Language="F#" Value="static member MkDir : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.MkDir Path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">Erforderlich. <see langword="String" />-Ausdruck, der das zu erstellende Verzeichnis identifiziert. <c>Path</c> enthält möglicherweise das Laufwerk. Wenn kein Laufwerk angegeben wird, erstellt <see langword="MkDir" /> das neue Verzeichnis auf dem aktuellen Laufwerk.</param>
        <summary>Erstellt ein neues Verzeichnis. Die <see langword="My" />-Funktion bietet eine höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="MkDir" />. Weitere Informationen finden Sie unter <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CreateDirectory(System.String)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Funktion erstellt ein neues Verzeichnis.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `MkDir` Funktion, um ein Verzeichnis zu erstellen. Wenn das Laufwerk nicht angegeben ist, wird das neue Verzeichnis auf dem aktuellen Laufwerk erstellt.  
  
 [!code-vb[VbVbalrCatRef#38](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#38)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Path" /> ist nicht angegeben oder leer.</exception>
        <exception cref="T:System.Security.SecurityException">Berechtigung verweigert.</exception>
        <exception cref="T:System.IO.IOException">Verzeichnis ist bereits vorhanden.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Print">
      <MemberSignature Language="C#" Value="public static void Print (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Print(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Print (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Print(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member Print : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Print (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="Output">Dies ist optional. 0 (null) oder mehr durch Kommas getrennte Ausdrücke, die in eine Datei geschrieben werden sollen.  
  
Die <c>Output</c>-Argumenteinstellungen lauten: 
 <see langword="T:System.IO.IOException" />: Dateimodus ist ungültig.  
  
 <see langword="T:System.IO.IOException" />: <c>FileNumber</c> ist nicht vorhanden.</param>
        <summary>Schreibt für die Anzeige formatierte Daten in eine sequenzielle Datei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Print` und `PrintLine` Funktionen werden für die Abwärtskompatibilität bereitgestellt und auf die Leistung auswirken kann. Für neue Anwendungen die `My.Computer.FileSystem` Objekt bietet eine bessere Leistung. Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 `Print` Schließt einen Zeilenvorschub am Ende einer Zeile nicht; allerdings `PrintLine` umfasst einen Zeilenvorschub.  
  
 Mit geschriebene Daten `Print` wird in der Regel aus einer Datei gelesen, mithilfe von `LineInput` oder `Input`.  
  
 Wenn Sie weglassen `Output` für `PrintLine`, eine leere Zeile wird ausgegeben, in der Datei; `Print`, nichts wird ausgegeben. Mehrere Ausdrücke, die durch ein Komma voneinander getrennt werden an den Begrenzungen der Registerkarte ", aber Mischen von Kommas ausgerichtet und `TAB` kann zu inkonsistente Ergebnissen führen.  
  
 Für `Boolean` Daten, entweder `True` oder `False` gedruckt wird. Die `True` und `False` Schlüsselwörter werden nicht übersetzt, unabhängig vom Gebietsschema.  
  
 Daten werden in die Datei geschrieben, mit das standardmäßige kurze Datumsformat, die vom System erkannt wird. Wenn das Datum oder die Komponente fehlt oder gleich NULL, so wird nur der Teil werden in die Datei geschrieben.  
  
 "Nothing" in die Datei geschrieben wird, wenn `Output` Daten ist leer. Aber wenn `Output` Daten aus der Liste ist `DBNull`, `Null` in die Datei geschrieben wird.  
  
 Für `Error` Daten, die Ausgabe angezeigt, als `Error errorcode`. Die `Error` Schlüsselwort wird nicht unabhängig vom Gebietsschema übersetzt.  
  
 Alle Daten, die in die Datei geschrieben werden, mithilfe von `Print` Dezimaltrennzeichen; ist, also die Daten ordnungsgemäß formatiert mit entsprechenden Dezimaltrennzeichen. Wenn der Benutzer zur Ausgabe von Daten für die Verwendung durch mehrere Sprachversionen möchte `Write` verwendet werden soll.  
  
 Schreiben in eine Datei mit den `Print` oder `PrintLine` Functions erfordert `Write` aus Zugriff auf die `FileIOPermissionAccess` Enumeration. Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `Print` und `PrintLine` Funktionen zum Schreiben von Daten in eine Datei.  
  
 [!code-vb[VbVbalrCatRef#53](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#53)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="PrintLine">
      <MemberSignature Language="C#" Value="public static void PrintLine (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void PrintLine(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub PrintLine (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PrintLine(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member PrintLine : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.PrintLine (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="Output">Dies ist optional. 0 (null) oder mehr durch Kommas getrennte Ausdrücke, die in eine Datei geschrieben werden sollen.  
  
Die <c>Output</c>-Argumenteinstellungen lauten: 
 <see langword="T:System.IO.IOException" />: Dateimodus ist ungültig.  
  
 <see langword="T:System.IO.IOException" />: <c>FileNumber</c> ist nicht vorhanden.</param>
        <summary>Schreibt für die Anzeige formatierte Daten in eine sequenzielle Datei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Print` und `PrintLine` Funktionen werden für die Abwärtskompatibilität bereitgestellt und auf die Leistung auswirken kann. Für neue Anwendungen die `My.Computer.FileSystem` Objekt bietet eine bessere Leistung. Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 `Print` Schließt einen Zeilenvorschub am Ende einer Zeile nicht; allerdings`PrintLine` umfasst einen Zeilenvorschub.  
  
 Mit geschriebene Daten `Print` wird in der Regel aus einer Datei gelesen, mithilfe von `LineInput` oder `Input`.  
  
 Wenn Sie weglassen `Output` für `PrintLine`, eine leere Zeile wird ausgegeben, in der Datei; `Print`, nichts wird ausgegeben. Mehrere Ausdrücke, die durch ein Komma voneinander getrennt werden an den Begrenzungen der Registerkarte ", aber Mischen von Kommas ausgerichtet und `TAB` kann zu inkonsistente Ergebnissen führen.  
  
 Für `Boolean` Daten, entweder `True` oder `False` gedruckt wird. Die `True` und `False` Schlüsselwörter werden nicht übersetzt, unabhängig vom Gebietsschema.  
  
 Daten werden in die Datei geschrieben, mit das standardmäßige kurze Datumsformat, die vom System erkannt. Wenn das Datum oder die Komponente fehlt oder gleich NULL, so wird nur der Teil werden in die Datei geschrieben.  
  
 "Nothing" in die Datei geschrieben wird, wenn `Output` Daten ist leer. Aber wenn `Output` Daten aus der Liste ist `DBNull`, `Null` in die Datei geschrieben wird.  
  
 Für `Error` Daten, die Ausgabe angezeigt, als `Error errorcode`. Die `Error` Schlüsselwort wird nicht unabhängig vom Gebietsschema übersetzt.  
  
 Alle Daten, die in die Datei geschrieben werden, mithilfe von `Print` Dezimaltrennzeichen; ist, also die Daten ordnungsgemäß formatiert mit entsprechenden Dezimaltrennzeichen. Wenn der Benutzer zur Ausgabe von Daten für die Verwendung durch mehrere Sprachversionen möchte `Write` verwendet werden soll.  
  
 Schreiben in eine Datei mit den `Print` oder `PrintLine` Functions erfordert `Write` aus Zugriff auf die `FileIOPermissionAccess` Enumeration. Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `Print` und `PrintLine` Funktionen zum Schreiben von Daten in eine Datei.  
  
 [!code-vb[VbVbalrCatRef#53](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#53)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Rename">
      <MemberSignature Language="C#" Value="public static void Rename (string OldPath, string NewPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Rename(string OldPath, string NewPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Rename (OldPath As String, NewPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Rename(System::String ^ OldPath, System::String ^ NewPath);" />
      <MemberSignature Language="F#" Value="static member Rename : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Rename (OldPath, NewPath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="OldPath" Type="System.String" />
        <Parameter Name="NewPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="OldPath">Erforderlich. Ein <see langword="String" />-Ausdruck, der den Namen und den Speicherort der vorhandenen Datei angibt. <c>OldPath</c> kann das Verzeichnis und das Laufwerk der Datei beinhalten.</param>
        <param name="NewPath">Erforderlich. Ein <see langword="String" />-Ausdruck, der den Namen und den Speicherort der neuen Datei angibt. <c>NewPath</c> kann das Verzeichnis und das Laufwerk des Zielspeicherorts beinhalten. Der durch <c>NewPath</c> angegebene Dateiname darf noch nicht vorhanden sein.</param>
        <summary>Benennt eine Datenträgerdatei oder ein Verzeichnis um. Die <see langword="My" />-Funktion bietet eine höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="Rename" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die`Rename` Funktion benennt eine Datei und verschiebt ihn in ein anderes Verzeichnis aus, wenn dies erforderlich ist. Die `Rename` Funktion kann eine Datei auf Laufwerken verschoben, aber es kann nur ein vorhandenes Verzeichnis umbenennen Wenn beide `NewPath` und `OldPath` auf dem gleichen Laufwerk befinden. `Rename` eine neue Datei oder ein Verzeichnis kann nicht erstellt werden.  
  
 Mithilfe der `Rename` erzeugt einen Fehler, Funktion, die auf eine geöffnete Datei. Sie müssen eine geöffnete Datei schließen, bevor Sie es umbenennen. `Rename` Argumente können nicht mehrere Zeichen (*) und Platzhalter für einzelne Zeichen (?) enthalten.  
  
> [!IMPORTANT]
>  Bei Verwendung `Rename` um eine Datei von einem nicht geschützten Speicherort auf einem geschützten Speicherort zu kopieren, behält die Datei weniger eingeschränkte Rechte. Stellen Sie sicher, dass kein potenzielles Sicherheitsrisiko entstehen.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `Rename` Funktion, um eine Datei umzubenennen. Für die Zwecke dieses Beispiels wird davon ausgegangen Sie, dass die Verzeichnisse, die bereits angegeben sind vorhanden.  
  
 [!code-vb[VbVbalrCatRef#30](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#30)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Pfad ist ungültig.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die <paramref name="OldPath" />-Datei ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Kann nicht auf anderes Gerät umbenannt werden.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public static void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public static void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Reset();" />
      <MemberSignature Language="F#" Value="static member Reset : unit -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Schließt alle mit der <see langword="FileOpen" />-Funktion geöffneten Datenträgerdateien. Die <see langword="My" />-Funktion bietet eine höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="Reset" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Reset` -Funktion schließt alle aktive Dateien geöffnet, indem die `FileOpen` Funktion, und hat die gleiche Funktion wie `FileClose()` ohne Parameter.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `Reset` Funktion, um alle geöffneten Dateien geschlossen und der Inhalt der alle Puffer auf Datenträger geschrieben. Beachten Sie die Verwendung der `Object` Variable `FileNumber` als eine Zeichenfolge und eine Zahl.  
  
 [!code-vb[VbVbalrCatRef#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#12)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="RmDir">
      <MemberSignature Language="C#" Value="public static void RmDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void RmDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RmDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RmDir(System::String ^ Path);" />
      <MemberSignature Language="F#" Value="static member RmDir : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.RmDir Path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">Erforderlich. <see langword="String" />-Ausdruck, der das zu entfernende Verzeichnis oder den zu entfernenden Ordner identifiziert. <c>Path</c> kann das Laufwerk enthalten. Wenn kein Laufwerk angegeben wird, entfernt <see langword="RmDir" /> das Verzeichnis vom aktuellen Laufwerk.</param>
        <summary>Entfernt ein vorhandenes Verzeichnis. Die <see langword="My" />-Funktion bietet eine höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="RmDir" />. Weitere Informationen finden Sie unter <see cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Fehler auftritt, wenn Sie versuchen, `RmDir` in einem Verzeichnis, das Dateien enthält. Verwenden der `Kill` Funktion, um alle Dateien zu löschen, bevor Sie versuchen, ein Verzeichnis zu entfernen.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `RmDir` Funktion, um ein vorhandenes Verzeichnis zu entfernen.  
  
 [!code-vb[VbVbalrCatRef#31](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#31)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Path" /> ist nicht angegeben oder leer.</exception>
        <exception cref="T:System.IO.IOException">Zielverzeichnis enthält Dateien.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Verzeichnis ist nicht vorhanden.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Seek">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt einen <see langword="Long" />-Wert zurück, der die aktuelle Lese-/Schreibposition innerhalb einer mithilfe der <see langword="FileOpen" />-Funktion geöffneten Datei angibt, oder legt die Position des nächsten Lese-/Schreibvorgangs innerhalb einer mithilfe der <see langword="FileOpen" />-Funktion geöffneten Datei fest. Die <see langword="My" />-Funktion bietet eine höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="Seek" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public static long Seek (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 Seek(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Seek (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Seek(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Seek : int -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.Seek FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Ein <see langword="Integer" /> mit einer gültigen Dateinummer.</param>
        <summary>Gibt einen <see langword="Long" />-Wert zurück, der die aktuelle Lese-/Schreibposition innerhalb einer mithilfe der <see langword="FileOpen" />-Funktion geöffneten Datei angibt, oder legt die Position des nächsten Lese-/Schreibvorgangs innerhalb einer mithilfe der <see langword="FileOpen" />-Funktion geöffneten Datei fest. Die <see langword="My" />-Funktion bietet eine höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="Seek" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <returns>Gibt einen <see langword="Long" />-Wert zurück, der die aktuelle Lese-/Schreibposition innerhalb einer mithilfe der <see langword="FileOpen" />-Funktion geöffneten Datei angibt, oder legt die Position des nächsten Lese-/Schreibvorgangs innerhalb einer mithilfe der <see langword="FileOpen" />-Funktion geöffneten Datei fest.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Seek` Gibt einen Wert zwischen 1 und 2.147.483.647 zurück (entspricht 2 ^ 31-1), inklusive.  
  
 Im folgenden werden die Rückgabewerte für jede Dateizugriffsmodus beschrieben:  
  
|Modus|Rückgabewert|  
|-|-|  
|`Random`|Anzahl des nächsten Datensatzes gelesen bzw. geschrieben werden|  
|`Binary`, `Input`, `Output`, `Append`|Byte-Position, an dem der nächste Vorgang auftritt. Das erste Byte in einer Datei ist an Position 1, das zweite Byte an Position 2 und So weiter.|  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `Seek` Funktion die aktuelle Dateiposition zurück. Im Beispiel wird vorausgesetzt `TestFile` ist eine Datei, die Datensätze der Struktur enthält `Record`.  
  
 [!code-vb[VbVbalrCatRef#47](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#47)]  
  
 Für Dateien in geöffnet `Random` Modus `Seek` gibt die Anzahl des nächsten Datensatzes zurück.  
  
 [!code-vb[VbVbalrCatRef#48](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#48)]  
  
 Für Dateien, die nicht in den Modi geöffnet `Random` Modus `Seek` gibt zurück, die mit der der nächste Vorgang stattfindet, Byte-Position. Angenommen `TestFile` ist eine Datei, die mehrere Zeilen Text enthält.  
  
 [!code-vb[VbVbalrCatRef#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#49)]  
  
 Dieses Beispiel verwendet die `Seek` Funktion zum Festlegen der Position für den nächsten Lesevorgang oder in einer Datei zu schreiben.  
  
 Anders als in den Modi geöffneten Dateien `Random` Modus `Seek` die Byte-Position, an dem der nächste Vorgang tritt auf, legt sie fest. Angenommen `TestFile` ist eine Datei, die mehrere Zeilen Text enthält.  
  
 [!code-vb[VbVbalrCatRef#52](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public static void Seek (int FileNumber, long Position);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Seek(int32 FileNumber, int64 Position) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Seek (FileNumber As Integer, Position As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Seek(int FileNumber, long Position);" />
      <MemberSignature Language="F#" Value="static member Seek : int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Seek (FileNumber, Position)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Position" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Ein <see langword="Integer" /> mit einer gültigen Dateinummer.</param>
        <param name="Position">Erforderlich. Eine Zahl im Bereich 1-2.147.483.647 einschließlich, die angibt, wo die nächste Lese-/Schreiboperation erfolgen soll.</param>
        <summary>Gibt einen <see langword="Long" />-Wert zurück, der die aktuelle Lese-/Schreibposition innerhalb einer mithilfe der <see langword="FileOpen" />-Funktion geöffneten Datei angibt, oder legt die Position des nächsten Lese-/Schreibvorgangs innerhalb einer mithilfe der <see langword="FileOpen" />-Funktion geöffneten Datei fest. Die <see langword="My" />-Funktion bietet eine höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="Seek" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Seek` Gibt einen Wert zwischen 1 und 2.147.483.647 zurück (entspricht 2 ^ 31-1), inklusive.  
  
 Im folgenden werden die Rückgabewerte für jede Dateizugriffsmodus beschrieben:  
  
|Modus|Rückgabewert|  
|-|-|  
|`Random`|Anzahl des nächsten Datensatzes gelesen bzw. geschrieben werden|  
|`Binary`, `Input`, `Output`, `Append`|Byte-Position, an dem der nächste Vorgang auftritt. Das erste Byte in einer Datei ist an Position 1, das zweite Byte an Position 2 und So weiter.|  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `Seek` Funktion die aktuelle Dateiposition zurück. Im Beispiel wird vorausgesetzt `TestFile` ist eine Datei, die Datensätze der Struktur enthält `Record`.  
  
 [!code-vb[VbVbalrCatRef#47](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#47)]  
  
 Für Dateien in geöffnet `Random` Modus `Seek` gibt die Anzahl des nächsten Datensatzes zurück.  
  
 [!code-vb[VbVbalrCatRef#48](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#48)]  
  
 Für Dateien, die nicht in den Modi geöffnet `Random` Modus `Seek` gibt zurück, die mit der der nächste Vorgang stattfindet, Byte-Position. Angenommen `TestFile` ist eine Datei, die mehrere Zeilen Text enthält.  
  
 [!code-vb[VbVbalrCatRef#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#49)]  
  
 Dieses Beispiel verwendet die `Seek` Funktion zum Festlegen der Position für den nächsten Lesevorgang oder in einer Datei zu schreiben.  
  
 Anders als in den Modi geöffneten Dateien `Random` Modus `Seek` die Byte-Position, an dem der nächste Vorgang tritt auf, legt sie fest. Angenommen `TestFile` ist eine Datei, die mehrere Zeilen Text enthält.  
  
 [!code-vb[VbVbalrCatRef#52](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="SetAttr">
      <MemberSignature Language="C#" Value="public static void SetAttr (string PathName, Microsoft.VisualBasic.FileAttribute Attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static void SetAttr(string PathName, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAttr (PathName As String, Attributes As FileAttribute)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetAttr(System::String ^ PathName, Microsoft::VisualBasic::FileAttribute Attributes);" />
      <MemberSignature Language="F#" Value="static member SetAttr : string * Microsoft.VisualBasic.FileAttribute -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.SetAttr (PathName, Attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
        <Parameter Name="Attributes" Type="Microsoft.VisualBasic.FileAttribute" />
      </Parameters>
      <Docs>
        <param name="PathName">Erforderlich. Ein <see langword="String" />-Ausdruck, der einen Dateinamen angibt. <c>PathName</c> kann auch das Verzeichnis oder den Ordner sowie das Laufwerk beinhalten.</param>
        <param name="Attributes">Erforderlich. Konstanter oder numerischer Ausdruck, dessen Summe Dateiattribute angibt.</param>
        <summary>Legt Attributinformationen für eine Datei fest. Die <see langword="My" />-Funktion bietet eine höhere Produktivität und Leistung bei Datei-E/A-Vorgängen als <see langword="SetAttr" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Laufzeitfehler tritt auf, wenn Sie versuchen, die die Attribute einer geöffneten Datei festzulegen.  
  
 Die `Attributes` Argument Enumerationswerte lauten wie folgt:  
  
|Wert|Konstante|Beschreibung |  
|-|-|-|  
|`Normal`|`vbNormal`|Normal (Standard).|  
|`ReadOnly`|`vbReadOnly`|Schreibgeschützt.|  
|`Hidden`|`vbHidden`|Ausgeblendet.|  
|`System`|`vbSystem`|Systemdatei.|  
|`Volume`|`vbVolume`|Volumebezeichnung|  
|`Directory`|`vbDirectory`|Verzeichnis oder Ordner.|  
|`Archive`|`vbArchive`|Die Datei wurde nach der letzten Sicherung geändert.|  
|`Alias`|`vbAlias`|Die Datei hat einen anderen Namen.|  
  
> [!NOTE]
>  Diese Enumerationen werden von der Programmiersprache Visual Basic angegeben. Die Namen können eine beliebige Stelle im Code anstelle der tatsächlichen Werte verwendet werden.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `SetAttr` -Funktion zum Festlegen der Attribute einer Datei.  
  
 [!code-vb[VbVbalrCatRef#14](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Attribute" />-Typ ist ungültig.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />
      </Docs>
    </Member>
    <Member MemberName="SPC">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.SpcInfo SPC (short Count);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.SpcInfo SPC(int16 Count) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function SPC (Count As Short) As SpcInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::SpcInfo SPC(short Count);" />
      <MemberSignature Language="F#" Value="static member SPC : int16 -&gt; Microsoft.VisualBasic.SpcInfo" Usage="Microsoft.VisualBasic.FileSystem.SPC Count" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.SpcInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Count" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="Count">Erforderlich. Die Anzahl von Leerzeichen, die vor dem Anzeigen oder Ausgeben des nächsten Ausdrucks in einer Liste eingefügt werden sollen.</param>
        <summary>Wird mit der <see langword="Print" />-Funktion oder der <see langword="PrintLine" />-Funktion zum Positionieren der Ausgabe verwendet.</summary>
        <returns>Wird mit der <see langword="Print" />-Funktion oder der <see langword="PrintLine" />-Funktion zum Positionieren der Ausgabe verwendet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `Count` ist kleiner als die Zeilenbreite der Ausgabe, die nächste Ausgabeposition sofort die Anzahl der ausgegebenen Leerzeichen folgt. Wenn`Count` ist größer als die Breite der Ausgabe, `SPC` die nächste Ausgabeposition unter Verwendung der Formel berechnet:  
  
 `currentprintposition`(+(`Count``Mod``width`))  
  
 Beispielsweise ist die aktuelle Ausgabeposition 24, Breite der Ausgabe ist 80, und geben Sie `SPC(90)`, die nächste Ausgabe beginnt an Position 34 (aktuelle Ausgabeposition + die restlichen 90/80). Ist der Unterschied zwischen der aktuellen Ausgabeposition und der Breite der Ausgabe weniger als `Count` (oder `Count` `Mod` *Breite*), wird die `SPC` Funktion springt an den Anfang der nächsten Zeile und generiert Leerzeichen gleich `Count` – (*Breite* – *aktuelleAusgabeposition*).  
  
> [!NOTE]
>  Stellen Sie sicher, dass die tabellarischen Spalten breit genug, um die Breite Buchstaben zu ermöglichen.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `SPC` -Funktion zum Positionieren der Ausgabe in einer Datei und in der **Ausgabe** Fenster.  
  
 [!code-vb[VbVbalrCatRef#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="TAB">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wird mit der <see langword="Print" />-Funktion oder der <see langword="PrintLine" />-Funktion zum Positionieren der Ausgabe verwendet.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TAB">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.TabInfo TAB ();" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.TabInfo TAB() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.TAB" />
      <MemberSignature Language="VB.NET" Value="Public Function TAB () As TabInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::TabInfo TAB();" />
      <MemberSignature Language="F#" Value="static member TAB : unit -&gt; Microsoft.VisualBasic.TabInfo" Usage="Microsoft.VisualBasic.FileSystem.TAB " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.TabInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wird mit der <see langword="Print" />-Funktion oder der <see langword="PrintLine" />-Funktion zum Positionieren der Ausgabe verwendet.</summary>
        <returns>Wird mit der <see langword="Print" />-Funktion oder der <see langword="PrintLine" />-Funktion zum Positionieren der Ausgabe verwendet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die aktuelle Ausgabeposition in der aktuellen Zeile größer als `Column`, `TAB` der Spaltenwert gleich ans `Column` in der nächsten Ausgabezeile. Wenn `Column` ist kleiner als 1, `TAB` verschiebt die Ausgabeposition in Spalte 1. Wenn `Column` ist größer als die Breite der Ausgabe, `TAB` die nächste Ausgabeposition unter Verwendung der Formel berechnet:  
  
 Mod Spaltenbreite  
  
 Z. B. wenn *Breite* ist 80, und geben Sie Sie `TAB(90)`, beginnt die nächste Ausgabe in der Spalte 10 (der Rest von 90/80). Wenn `Column` ist kleiner als die aktuelle Ausgabeposition, beginnt die Ausgabe in der nächsten Zeile an die berechneten. Wenn die berechnete Position größer als die aktuelle Position ist, Drucken beginnt die Ausgabe an die berechnete Position in der gleichen Zeile an.  
  
 Die am weitesten links stehende Ausgabeposition in eine Ausgabezeile ist immer 1. Bei Verwendung der `Print` oder `PrintLine` Funktionen in Dateien, die Ausgabeposition ist die aktuelle Breite der Ausgabedatei, die Sie festlegen können, mit der `FileWidth` Funktion.  
  
 Die `TAB` Funktion kann auch verwendet werden, mit der `WriteLine` Funktion. Es kann nicht verwendet werden, mit <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType> oder <xref:System.Console.WriteLine%2A?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Stellen Sie sicher, dass die tabellarischen Spalten breit genug, um die Breite der Buchstaben enthalten.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `TAB` -Funktion zum Positionieren der Ausgabe in einer Datei und in der **Ausgabe** Fenster.  
  
 [!code-vb[VbVbalrCatRef#37](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#37)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="TAB">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.TabInfo TAB (short Column);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.TabInfo TAB(int16 Column) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.TAB(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function TAB (Column As Short) As TabInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::TabInfo TAB(short Column);" />
      <MemberSignature Language="F#" Value="static member TAB : int16 -&gt; Microsoft.VisualBasic.TabInfo" Usage="Microsoft.VisualBasic.FileSystem.TAB Column" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.TabInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Column" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="Column">Dies ist optional. Die Spaltennummer, zu der vor dem Anzeigen oder Drucken des nächsten Ausdrucks in einer Liste gewechselt wird. Wenn der Wert nicht angegeben wird, verschiebt <see langword="TAB" /> die Einfügemarke an den Anfang der nächsten Ausgabezone.</param>
        <summary>Wird mit der <see langword="Print" />-Funktion oder der <see langword="PrintLine" />-Funktion zum Positionieren der Ausgabe verwendet.</summary>
        <returns>Wird mit der <see langword="Print" />-Funktion oder der <see langword="PrintLine" />-Funktion zum Positionieren der Ausgabe verwendet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die aktuelle Ausgabeposition in der aktuellen Zeile überschreitet `Column`, `TAB` der Spaltenwert gleich ans `Column` in der nächsten Ausgabezeile. Wenn `Column` ist kleiner als 1, `TAB` verschiebt die Ausgabeposition in Spalte 1. Wenn `Column` ist größer als die Breite der Ausgabe, `TAB` die nächste Ausgabeposition unter Verwendung der Formel berechnet:  
  
 Mod Spaltenbreite  
  
 Z. B. wenn *Breite* ist 80, und geben Sie Sie `TAB(90)`, beginnt die nächste Ausgabe in der Spalte 10 (der Rest von 90/80). Wenn `Column` ist kleiner als die aktuelle Ausgabeposition, beginnt die Ausgabe in der nächsten Zeile an die berechneten. Wenn die berechnete Position größer als die aktuelle Position ist, Drucken beginnt die Ausgabe an die berechnete Position in der gleichen Zeile.  
  
 Die am weitesten links stehende Ausgabeposition in eine Ausgabezeile ist immer 1. Bei Verwendung der `Print` oder `PrintLine` Funktionen in Dateien, die Ausgabeposition ist die aktuelle Breite der Ausgabedatei, die Sie festlegen können, mit der `FileWidth` Funktion.  
  
 Die `TAB` Funktion kann auch verwendet werden, mit der `WriteLine` Funktion. Es kann nicht verwendet werden, mit <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType> oder <xref:System.Console.WriteLine%2A?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Stellen Sie sicher, dass die tabellarischen Spalten breit genug, um die Breite der Buchstaben enthalten.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `TAB` -Funktion zum Positionieren der Ausgabe in einer Datei und in der **Ausgabe** Fenster.  
  
 [!code-vb[VbVbalrCatRef#37](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#37)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Unlock">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Steuert den Zugriff durch andere Prozesse auf die gesamte mithilfe der <see langword="Open" />-Funktion geöffnete Datei oder einen Teil davon. Das <see langword="My" />-Feature ermöglicht bei Datei-E/A-Vorgängen höhere Produktivität und Leistung als <see langword="Lock" /> und <see langword="Unlock" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Unlock : int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Unlock FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <summary>Steuert den Zugriff durch andere Prozesse auf die gesamte mithilfe der <see langword="Open" />-Funktion geöffnete Datei oder einen Teil davon. Das <see langword="My" />-Feature ermöglicht bei Datei-E/A-Vorgängen höhere Produktivität und Leistung als <see langword="Lock" /> und <see langword="Unlock" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Lock` und `Unlock` Funktionen werden, in denen mehrere Prozesse den Zugriff auf die gleiche Datei möglicherweise in Umgebungen verwendet.  
  
 `Lock` und `Unlock` Funktionen werden immer paarweise verwendet. Die Argumente für `Lock` und `Unlock` müssen identisch sein.  
  
 Wenn `Record`, oder `FromRecord` und `ToRecord` sind nicht angegeben wird, wird die Sperre für die gesamte Datei sein. Wenn `Record` allein angegeben ist der einzelne Datensatz wird gesperrt/freigegeben werden.  
  
 Wenn die Datei für sequenzielle ein- oder Ausgabe geöffnet wurde `Lock` und `Unlock` Auswirkungen auf die gesamte Datei, unabhängig von dem vom angegebenen Bereich `FromRecord` und`ToRecord`.  
  
   
  
## Examples  
 Dieses Beispiel veranschaulicht die Verwendung der `Lock` und `Unlock` Funktionen. In diesem Beispiel wird vorausgesetzt, dass `People.txt` ist eine Datei, die Datensätze der Struktur enthält `Person`.  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber, long Record);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber, int64 Record) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer, Record As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber, long Record);" />
      <MemberSignature Language="F#" Value="static member Unlock : int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Unlock (FileNumber, Record)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Record" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="Record">Dies ist optional. Die Nummer des einzigen zu sperrenden oder zu entsperrenden Datensatzes.</param>
        <summary>Steuert den Zugriff durch andere Prozesse auf die gesamte mithilfe der <see langword="Open" />-Funktion geöffnete Datei oder einen Teil davon. Das <see langword="My" />-Feature ermöglicht bei Datei-E/A-Vorgängen höhere Produktivität und Leistung als <see langword="Lock" /> und <see langword="Unlock" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Lock` und `Unlock` Funktionen werden, in denen mehrere Prozesse den Zugriff auf die gleiche Datei möglicherweise in Umgebungen verwendet.  
  
 `Lock` und `Unlock` Funktionen werden immer paarweise verwendet. Die Argumente für `Lock` und `Unlock` müssen identisch sein.  
  
 Wenn `Record`, oder `FromRecord` und `ToRecord` sind nicht angegeben wird, wird die Sperre für die gesamte Datei sein. Wenn `Record` allein angegeben ist der einzelne Datensatz wird gesperrt/freigegeben werden.  
  
 Wenn die Datei für sequenzielle ein- oder Ausgabe geöffnet wurde `Lock` und `Unlock` Auswirkungen auf die gesamte Datei, unabhängig von dem vom angegebenen Bereich `FromRecord` und`ToRecord`.  
  
   
  
## Examples  
 Dieses Beispiel veranschaulicht die Verwendung der `Lock` und `Unlock` Funktionen. In diesem Beispiel wird vorausgesetzt, dass `People.txt` ist eine Datei, die Datensätze der Struktur enthält `Person`.  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber, int64 FromRecord, int64 ToRecord) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer, FromRecord As Long, ToRecord As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="F#" Value="static member Unlock : int * int64 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Unlock (FileNumber, FromRecord, ToRecord)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FromRecord" Type="System.Int64" />
        <Parameter Name="ToRecord" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Eine beliebige gültige Dateinummer.</param>
        <param name="FromRecord">Dies ist optional. Die Nummer des ersten zu sperrenden oder zu entsperrenden Datensatzes.</param>
        <param name="ToRecord">Dies ist optional. Die Nummer des letzten zu sperrenden oder zu entsperrenden Datensatzes.</param>
        <summary>Steuert den Zugriff durch andere Prozesse auf die gesamte mithilfe der <see langword="Open" />-Funktion geöffnete Datei oder einen Teil davon. Das <see langword="My" />-Feature ermöglicht bei Datei-E/A-Vorgängen höhere Produktivität und Leistung als <see langword="Lock" /> und <see langword="Unlock" />. Weitere Informationen finden Sie unter <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Lock` und `Unlock` Funktionen werden, in denen mehrere Prozesse den Zugriff auf die gleiche Datei möglicherweise in Umgebungen verwendet.  
  
 `Lock` und `Unlock` Funktionen werden immer paarweise verwendet. Die Argumente für `Lock` und `Unlock` müssen identisch sein.  
  
 Wenn `Record`, oder `FromRecord` und `ToRecord` sind nicht angegeben wird, wird die Sperre für die gesamte Datei sein. Wenn `Record` allein angegeben ist der einzelne Datensatz wird gesperrt/freigegeben werden.  
  
 Wenn die Datei für sequenzielle ein- oder Ausgabe geöffnet wurde `Lock` und `Unlock` Auswirkungen auf die gesamte Datei, unabhängig von dem vom angegebenen Bereich `FromRecord` und`ToRecord`.  
  
   
  
## Examples  
 Dieses Beispiel veranschaulicht die Verwendung der `Lock` und `Unlock` Funktionen. In diesem Beispiel wird vorausgesetzt, dass `People.txt` ist eine Datei, die Datensätze der Struktur enthält `Person`.  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Write(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member Write : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Write (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Ein <see langword="Integer" />-Ausdruck, der eine beliebige gültige Dateinummer enthält.</param>
        <param name="Output">Dies ist optional. Ein oder mehr durch Kommas getrennte Ausdrücke, die in eine Datei geschrieben werden sollen.</param>
        <summary>Schreibt Daten in eine sequenzielle Datei. Mit <see langword="Write" /> geschriebene Daten werden normalerweise mit <see langword="Input" /> aus einer Datei gelesen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Write` und `WriteLine` Funktionen werden für die Abwärtskompatibilität bereitgestellt und auf die Leistung auswirken kann. Für neue Anwendungen die `My.Computer.FileSystem` Objekt bietet eine bessere Leistung. Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Wenn Sie weglassen `Output`, eine leere Zeile wird in der Datei ausgegeben. Mehrere Ausdrücke können durch ein Komma getrennt werden.  
  
 Im Gegensatz zu den `Print` -Funktion, die `Write` Funktion fügt Kommas zwischen Elementen und Zeichenfolgen in Anführungszeichen an, wie sie in der Datei geschrieben werden. Sie müssen keinen explizite Trennzeichen in der Liste anzugeben. Wenn `Write` wird verwendet, um das Schreiben von Daten in eine Datei, die nur numerische `Boolean`, Datum, Null, und `Error` Datenformate unterstützt werden. Die folgenden Annahmen für die universelle gefolgt sind, damit die Daten immer gelesen werden können und unter Verwendung ordnungsgemäß interpretiert `Input`, unabhängig vom Gebietsschema:  
  
-   Numerische Daten werden immer geschrieben mit einem Punkt als Dezimaltrennzeichen verwendet.  
  
-   Für `Boolean` Daten, entweder `#TRUE#` oder `#FALSE#` gedruckt wird. Die `True` und `False` Schlüsselwörter werden nicht übersetzt, unabhängig vom Gebietsschema.  
  
-   Datumsdaten werden in die Datei unter Verwendung des universellen Datumsformat geschrieben. Wenn das Datum oder die Komponente fehlt oder gleich NULL, so wird nur der Teil werden in die Datei geschrieben.  
  
-   "Nothing" in die Datei geschrieben wird, wenn `Output` Daten ist leer. Allerdings für null-Daten `#NULL#` geschrieben wird.  
  
-   Für `Error` Daten, die Ausgabe angezeigt, als `#ERROR errorcode#`. Die `Error` Schlüsselwort wird unabhängig vom Gebietsschema nicht übersetzt.  
  
 `WriteLine` Fügt ein Zeilenumbruchzeichen (d. h. ein Wagenrücklauf-/Zeilenvorschubzeichen, oder `Chr(13) + Chr(10)`), nachdem das letzte Zeichen im geschrieben wurde `Output` in die Datei.  
  
 Sie können Anführungszeichen in einer Zeichenfolge mit doppelten Anführungszeichen einbetten oder "". Ein auf ein Objekt angewendeter  
  
 [!code-vb[VbVbalrCatRef#63](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#63)]  
  
 Gibt eine Zeichenfolge mit dem Wert des `Double quotation marks aren't "difficult" to handle`.  
  
 Schreiben in eine Datei mit den `Write` oder `WriteLine` Functions erfordert `Append` aus Zugriff auf die `FileIOPermissionAccess` Enumeration. Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `Write` Funktion zum Schreiben von Rohdaten in eine sequenzielle Datei.  
  
 [!code-vb[VbVbalrCatRef#64](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#64)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Dateimodus ist ungültig.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void WriteLine(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteLine (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member WriteLine : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.WriteLine (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">Erforderlich. Ein <see langword="Integer" />-Ausdruck, der eine beliebige gültige Dateinummer enthält.</param>
        <param name="Output">Dies ist optional. Ein oder mehr durch Kommas getrennte Ausdrücke, die in eine Datei geschrieben werden sollen.</param>
        <summary>Schreibt Daten in eine sequenzielle Datei. Mit <see langword="Write" /> geschriebene Daten werden normalerweise mit <see langword="Input" /> aus einer Datei gelesen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Write` und `WriteLine` Funktionen werden für die Abwärtskompatibilität bereitgestellt und auf die Leistung auswirken kann. Für neue Anwendungen die `My.Computer.FileSystem` Objekt bietet eine bessere Leistung. Weitere Informationen finden Sie unter [Dateizugriff mit Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Wenn Sie weglassen `Output`, eine leere Zeile wird in der Datei ausgegeben. Mehrere Ausdrücke können durch ein Komma getrennt werden.  
  
 Im Gegensatz zu den `Print` -Funktion, die `Write` Funktion fügt Kommas zwischen Elementen und Zeichenfolgen in Anführungszeichen an, wie sie in der Datei geschrieben werden. Sie müssen keinen explizite Trennzeichen in der Liste anzugeben. Wenn `Write` wird verwendet, um das Schreiben von Daten in eine Datei, die nur numerische `Boolean`, Datum, Null, und `Error` Datenformate unterstützt werden. Die folgenden Annahmen für die universelle gefolgt sind, damit die Daten immer gelesen werden können und unter Verwendung ordnungsgemäß interpretiert `Input`, unabhängig vom Gebietsschema:  
  
-   Numerische Daten werden immer geschrieben mit einem Punkt als Dezimaltrennzeichen verwendet.  
  
-   Für `Boolean` Daten, entweder `#TRUE#` oder `#FALSE#` gedruckt wird. Die `True` und `False` Schlüsselwörter werden nicht übersetzt, unabhängig vom Gebietsschema.  
  
-   Datumsdaten werden in die Datei unter Verwendung des universellen Datumsformat geschrieben. Wenn das Datum oder die Komponente fehlt oder gleich NULL, so wird nur der Teil werden in die Datei geschrieben.  
  
-   "Nothing" in die Datei geschrieben wird, wenn `Output` Daten ist leer. Allerdings für null-Daten `#NULL#` geschrieben wird.  
  
-   Für `Error` Daten, die Ausgabe angezeigt, als `#ERROR errorcode#`. Die `Error` Schlüsselwort wird unabhängig vom Gebietsschema nicht übersetzt.  
  
 `WriteLine` Fügt ein Zeilenumbruchzeichen (d. h. ein Wagenrücklauf-/Zeilenvorschubzeichen, oder `Chr(13) + Chr(10)`), nachdem das letzte Zeichen im geschrieben wurde `Output` in die Datei.  
  
 Sie können Anführungszeichen in einer Zeichenfolge mit doppelten Anführungszeichen einbetten oder "". Ein auf ein Objekt angewendeter  
  
 [!code-vb[VbVbalrCatRef#63](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#63)]  
  
 Gibt eine Zeichenfolge mit dem Wert des `Double quotation marks aren't "difficult" to handle`.  
  
 Schreiben in eine Datei mit den `Write` oder `WriteLine` Functions erfordert `Append` aus Zugriff auf die `FileIOPermissionAccess` Enumeration. Weitere Informationen finden Sie unter <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `Write` Funktion zum Schreiben von Rohdaten in eine sequenzielle Datei.  
  
 [!code-vb[VbVbalrCatRef#64](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#64)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
  </Members>
</Type>